language: scala
name: HumanEval_159_eat
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n\
    \        var carrots = number\n        var carrots_left = remaining\n        while\
    \ (carrots_left > 0) {\n            carrots -= 1\n            carrots_left -=\
    \ 1\n            list += carrots\n        }\n        list += carrots_left\n  \
    \      list.takeWhile(_ <= need).takeWhile(_ <= remaining).toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfok1i6fv.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        val needList = List(need.toLong)\n\
    \        val needRemaining = remaining - need\n        val needRemainingList =\
    \ List(needRemaining.toLong)\n        val needRemainingList2 = List(needRemaining.toLong)\n\
    \        val needRemainingList3 = List(needRemaining.toLong)\n        val needRemainingList4\
    \ = List(needRemaining.toLong)\n        val needRemainingList5 = List(needRemaining.toLong)\n\
    \        val needRemainingList6 = List(needRemaining.toLong)\n        val needRemainingList7\
    \ = List(needRemaining.toLong)\n        val needRemainingList8 = List(needRemaining.toLong)\n\
    \        val needRemainingList9 = List(needRemaining.toLong)\n        val needRemainingList10\
    \ = List(needRemaining.toLong)\n        val needRemainingList11 = List(needRemaining.toLong)\n\
    \        val needRemainingList12 = List(needRemaining.toLong)\n        val needRemainingList13\
    \ = List(needRemaining.toLong)\n        val needRemainingList14 = List(needRemaining.toLong)\n\
    \        val needRemainingList15 = List(needRemaining.toLong)\n        val needRemainingList16\
    \ = List(needRemaining.toLong)\n        val needRemainingList17 = List(needRemaining.toLong)\n\
    \        val needRemainingList18 = List(needRemaining.toLong)\n        val needRemainingList19\
    \ = List(needRemaining.toLong)\n        val needRemainingList20 = List(needRemaining.toLong)\n\
    \        val needRemainingList21 = List(needRemaining.toLong)\n        val needRemainingList22\
    \ = List(needRemaining.toLong)\n        val needRemainingList23 = List(needRemaining.toLong)\n\
    \        val needRemainingList24 = List(needRemaining.toLong)\n        val needRemainingList25\
    \ = List(needRemaining.toLong)\n        val needRemainingList26 = List(needRemaining.toLong)\n\
    \        val needRemainingList27 = List(needRemaining.toLong)\n        val needRemainingList28\
    \ = List(needRemaining.toLong)\n        val needRemainingList29 = List(needRemaining.toLong)\n\
    \        val needRemainingList30 = List(needRemaining.toLong)\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnovezv7u.scala:66:5\
    \ ---------------------\e[0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        val hungryList2 = List(hungry.toLong)\n\
    \        val hungryList3 = List(hungry.toLong)\n        val hungryList4 = List(hungry.toLong)\n\
    \        val hungryList5 = List(hungry.toLong)\n        val hungryList6 = List(hungry.toLong)\n\
    \        val hungryList7 = List(hungry.toLong)\n        val hungryList8 = List(hungry.toLong)\n\
    \        val hungryList9 = List(hungry.toLong)\n        val hungryList10 = List(hungry.toLong)\n\
    \        val hungryList11 = List(hungry.toLong)\n        val hungryList12 = List(hungry.toLong)\n\
    \        val hungryList13 = List(hungry.toLong)\n        val hungryList14 = List(hungry.toLong)\n\
    \        val hungryList15 = List(hungry.toLong)\n        val hungryList16 = List(hungry.toLong)\n\
    \        val hungryList17 = List(hungry.toLong)\n        val hungryList18 = List(hungry.toLong)\n\
    \        val hungryList19 = List(hungry.toLong)\n        val hungryList20 = List(hungry.toLong)\n\
    \        val hungryList21 = List(hungry.toLong)\n        val hungryList22 = List(hungry.toLong)\n\
    \        val hungryList23 = List(hungry.toLong)\n        val hungryList24 = List(hungry.toLong)\n\
    \        val hungryList25 = List(hungry.toLong)\n        val hungryList26 = List(hungry.toLong)\n\
    \        val hungryList27 = List(hungry.toLong)\n        val hungryList28 = List(hungry.toLong)\n\
    \        val hungryList29 = List(h\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxbbs5a0q.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxbbs5a0q.scala:60:32\
    \ ------------------------\e[0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryList29\e[0m = List(h\n\e[31m\e[31m   |\e[0m                        \
    \        ^\e[0m\n\e[31m   |\e[0m                                Not found: h\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxbbs5a0q.scala:61:5\
    \ ---------------------\e[0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals - carrots\n\
    \        val mealsLeftList = List(mealsLeft.toLong)\n        val carrotsLeftList\
    \ = List(carrots.toLong)\n        val mealsLeftAndCarrotsLeftList = mealsLeftList\
    \ ++ carrotsLeftList\n        val mealsLeftAndCarrotsLeftListList = List(mealsLeftAndCarrotsLeftList.toList)\n\
    \        val mealsLeftAndCarrotsLeftListListList = List(mealsLeftAndCarrotsLeftListList.toList)\n\
    \        val mealsLeftAndCarrotsLeftListListListList = List(mealsLeftAndCarrotsLeftListListList.toList)\n\
    \        val mealsLeftAndCarrotsLeftListListListListList = List(mealsLeftAndCarrotsLeftListListListList.toList)\n\
    \        val mealsLeftAndCarrotsLeftListListListListListList = List(mealsLeftAndCarrotsLeftListListListListList.toList)\n\
    \        val mealsLeftAndCarrotsLeftListListListListListListList = List(mealsLeftAndCarrotsLeftListListListListListList.toList)\n\
    \        val mealsLeftAndCarrotsLeftListListListListListListListList = List(mealsLeftAndCarrotsLeftListListListListListListList.toList)\n\
    \        val mealsLeftAndCarrotsLeftListListListListListListListListList = List(mealsLeftAndCarrotsLeftListListListListListListListList.toList)\n\
    \        val mealsLeftAndCarrotsLeftListListListListListListListListListListList\
    \ = List(mealsLeftAndCarrotsLeftListListListListListListListListListList.toList)\n\
    \        val mealsLeftAndCarrotsLeftListListListListListListListListListListListList\
    \ = List(mealsLeftAndCarrotsLeftListListListListListListListListListListList.toList)\n\
    \        val mealsLeftAndCarrotsLeftListListListListListListListListListListListListList\
    \ = List(mealsLeftAndCarrotsLeftListListListListListListListListListListListListList.toList)\n\
    \        val mealsLeftAndCarrotsLeftListListListListListListListListListListListListListListList\
    \ = List(mealsLeftAndCarrotsLeftList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptj4ci9ch.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptj4ci9ch.scala:45:87\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e\
    [36mmealsLeftAndCarrotsLeftListListListListListListListListListListList\e[0m =\
    \ List(mealsLeftAndCarrotsLeftListListListListListListListListListList.toList)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: mealsLeftAndCarrotsLeftListListListListListListListListListList\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptj4ci9ch.scala:47:95\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeftAndCarrotsLeftListListListListListListListListListListListListList\e\
    [0m = List(mealsLeftAndCarrotsLeftListListListListListListListListListListListListList.toList)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                       ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  mealsLeftAndCarrotsLeftListListListListListListListListListListListListList\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmptj4ci9ch.scala:49:5 ---------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = carrots - remainingToEat\n        val carrotLeftToEat\
    \ = carrots - needToEat\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList,\
    \ carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv8tzpk08.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        (carrotEatenList, carrotLeftToEatList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e[31m]\e[0m\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804457
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - hungry\n        if (hungryRemaining\
    \ <= 0) {\n            List(number + need)\n        } else {\n            val\
    \ hungryEaten = eat(hungry, need, remaining)\n            val hungryLeft = (hungryRemaining\
    \ - hungryEaten)\n            val hungryEatenAndLeft = (hungryEaten + hungryLeft)\n\
    \            List(hungryEatenAndLeft, hungryLeft)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpbdhv0z1l.scala:37:46 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mhungryLeft\e[0m = (hungryRemaining\
    \ - hungryEaten)\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch\
    \ arguments ((hungryEaten : List[Long]))\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpbdhv0z1l.scala:38:50 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m            \e[33mval\e[0m \e[36mhungryEatenAndLeft\e[0m = (hungryEaten + hungryLeft)\n\
    \e[31m\e[31m   |\e[0m                                      ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue + is not a member of List[Long], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1659804459
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        if (remaining > need) {\n\
    \            hungryList :+ need.toLong\n        } else {\n            hungryList\
    \ :+ remaining\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp78kf40pi.scala:40)\n\tat Problem.main(tmp78kf40pi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining == 0)\
    \ {\n            result.add(carrots)\n        } else {\n            if (carrots\
    \ >= needs) {\n                result.add(carrots - needs)\n                carrots\
    \ -= needs\n            } else {\n                result.add(carrots)\n      \
    \          carrots = remaining\n            }\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgecw3wmg.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgecw3wmg.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpgecw3wmg.scala:40:24 ------------------------\e[0m\e[0m\n\e[31m40 |\e\
    [0m                carrots -= needs\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m              value -= is not a member of Int - did you mean\
    \ carrots.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpgecw3wmg.scala:43:24\
    \ -----------------------------\e[0m\e[0m\n\e[31m43 |\e[0m                carrots\
    \ = remaining\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Reassignment to val carrots\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        val hungryList2 = List(hungry.toLong)\n\
    \        val hungryList3 = List(hungry.toLong)\n        val hungryList4 = List(hungry.toLong)\n\
    \        val hungryList5 = List(hungry.toLong)\n        val hungryList6 = List(hungry.toLong)\n\
    \        val hungryList7 = List(hungry.toLong)\n        val hungryList8 = List(hungry.toLong)\n\
    \        val hungryList9 = List(hungry.toLong)\n        val hungryList10 = List(hungry.toLong)\n\
    \        val hungryList11 = List(hungry.toLong)\n        val hungryList12 = List(hungry.toLong)\n\
    \        val hungryList13 = List(hungry.toLong)\n        val hungryList14 = List(hungry.toLong)\n\
    \        val hungryList15 = List(hungry.toLong)\n        val hungryList16 = List(hungry.toLong)\n\
    \        val hungryList17 = List(hungry.toLong)\n        val hungryList18 = List(hungry.toLong)\n\
    \        val hungryList19 = List(hungry.toLong)\n        val hungryList20 = List(hungry.toLong)\n\
    \        val hungryList21 = List(hungry.toLong)\n        val hungryList22 = List(hungry.toLong)\n\
    \        val hungryList23 = List(hungry.toLong)\n        val hungryList24 = List(hungry.toLong)\n\
    \        val hungryList25 = List(hungry.toLong)\n        val hungryList26 = List(hungry.toLong)\n\
    \        val hungryList27 = List(hungry.toLong)\n        val hungryList28 = List(hungry.toLong)\n\
    \        val hungryList29 = List(h\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxbbs5a0q.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxbbs5a0q.scala:60:32\
    \ ------------------------\e[0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryList29\e[0m = List(h\n\e[31m\e[31m   |\e[0m                        \
    \        ^\e[0m\n\e[31m   |\e[0m                                Not found: h\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxbbs5a0q.scala:61:5\
    \ ---------------------\e[0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals\
    \ = carrots_left % needs_left\n        val carrots_after_meals = carrots_left_after_meals\
    \ / needs_left\n        val carrots_after_meals_remaining = carrots_left_after_meals\
    \ % needs_left\n        val carrots_after_meals_remaining_remaining = carrots_after_meals_remaining\
    \ / needs_left\n        val carrots_after_meals_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining / needs_left\n        val\
    \ carrots_after_meals_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining\
    \ % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining / needs_left\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining % needs_left\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ % needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ / needs_left\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe9vmqfh0.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\e\
    [0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ / needs_left\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpe9vmqfh0.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\e\
    [0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ / needs_left\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining_remaining\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpe9vmqfh0.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e["
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        val carrots_left = remaining\
    \ - carrots\n        val carrots_left_to_eat = (carrots_left - needs).toInt\n\
    \        val carrots_left_to_eat_2 = (carrots_left_to_eat - 1)\n        val carrots_left_to_eat_3\
    \ = (carrots_left_to_eat_2 - 1)\n        val carrots_left_to_eat_4 = (carrots_left_to_eat_3\
    \ - 1)\n        val carrots_left_to_eat_5 = (carrots_left_to_eat_4 - 1)\n    \
    \    val carrots_left_to_eat_6 = (carrots_left_to_eat_5 - 1)\n        val carrots_left_to_eat_7\
    \ = (carrots_left_to_eat_6 - 1)\n        val carrots_left_to_eat_8 = (carrots_left_to_eat_7\
    \ - 1)\n        val carrots_left_to_eat_9 = (carrots_left_to_eat_8 - 1)\n    \
    \    val carrots_left_to_eat_10 = (carrots_left_to_eat_9 - 1)\n        val carrots_left_to_eat_11\
    \ = (carrots_left_to_eat_10 - 1)\n        val carrots_left_to_eat_12 = (carrots_left_to_eat_11\
    \ - 1)\n        val carrots_left_to_eat_13 = (carrots_left_to_eat_12 - 1)\n  \
    \      val carrots_left_to_eat_14 = (carrots_left_to_eat_13 - 1)\n        val\
    \ carrots_left_to_eat_15 = (carrots_left_to_eat_14 - 1)\n        val carrots_left_to_eat_16\
    \ = (carrots_left_to_eat_15 - 1)\n        val carrots_left_to_eat_17 = (carrots_left_to_eat_16\
    \ - 1)\n        val carrots_left_to_eat_18 = (carrots_left_to_eat_17 - 1)\n  \
    \      val carrots_left_to_eat_19 = (carrots_left_to_eat_18 - 1)\n        val\
    \ carrots_left_to_eat_20 = (carrots_left_to_eat_19 - 1)\n        val carrots_left_to_eat_21\
    \ = (carrots_left_to_eat_20 - 1)\n        val carrots_left_to_eat_22 = (carrots_left_to_eat_21\
    \ - 1)\n\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx8srcf0p.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx8srcf0p.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx8srcf0p.scala:59:5\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804457
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        var carrots_left =\
    \ remaining\n        while(carrots_left > 0) {\n            carrots_left -= 1\n\
    \            val carrots_needed = needs - carrots_left\n            val carrots_eaten\
    \ = carrots - carrots_left\n            val carrots_left_to_eat = carrots_needed\
    \ - carrots_eaten\n            val carrots_left_to_eat2 = carrots_left_to_eat.toInt\n\
    \            val carrots_left_to_eat3 = carrots_left_to_eat2.toInt\n         \
    \   val carrots_left_to_eat4 = carrots_left_to_eat3.toInt\n            val carrots_left_to_eat5\
    \ = carrots_left_to_eat4.toInt\n            val carrots_left_to_eat6 = carrots_left_to_eat5.toInt\n\
    \            val carrots_left_to_eat7 = carrots_left_to_eat6.toInt\n         \
    \   val carrots_left_to_eat8 = carrots_left_to_eat7.toInt\n            val carrots_left_to_eat9\
    \ = carrots_left_to_eat8.toInt\n            val carrots_left_to_eat10 = carrots_left_to_eat9.toInt\n\
    \            val carrots_left_to_eat11 = carrots_left_to_eat10.toInt\n       \
    \     val carrots_left_to_eat12 = carrots_left_to_eat11.toInt\n            val\
    \ carrots_left_to_eat13 = carrots_left_to_eat12.toInt\n            val carrots_left_to_eat14\
    \ = carrots_left_to_eat13.toInt\n            val carrots_left_to_eat15 = carrots_left_to_eat14.toInt\n\
    \            val carrots_left_to_eat16 = carrots_left_to_eat15.toInt\n       \
    \     val carrots_left_to_eat17 = carrots_left_to_eat16.toInt\n            val\
    \ carrots_left_to_eat18 = carrots_left_to_eat17.toInt\n            val carrots_left_to_eat19\
    \ = carrots_left_to_eat18.toInt\n            val carrots_left_to_eat20 = carrots_left_to_eat19.toInt\n\
    \            val carrots_left_to_eat21 = carrots_left_to_eat20.toInt\n       \
    \     val carrots_left_to_eat22 = carrot\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaa28lipx.scala:73:0 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpaa28lipx.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpaa28lipx.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpaa28lipx.scala:61:40 ------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m            \e[33mval\e[0m \e[36mcarrots_left_to_eat22\e\
    [0m = carrot\n\e[31m\e[31m   |\e[0m                                        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                        Not found: carrot\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaa28lipx.scala:72:1\
    \ ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpaa28lipx.scala:63:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m63 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n5 errors found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left - needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left - carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left\
    \ - needs_left_2).toInt\n        val needs_left_to_eat_2 = (needs_left - carrots_left_2).toInt\n\
    \        val carrots_left_to_eat_3 = (carrots_left - needs_left_3).toInt\n   \
    \     val needs_left_to_eat_3 = (needs_left - carrots_left_3).toInt\n        val\
    \ carrots_left_to_eat_4 = (carrots_left - needs_left_4).toInt\n        val needs_left_to_eat_4\
    \ = (needs_left - carrots_left_4).toInt\n        val carrots_left_to_eat_5 = (carrots_left\
    \ - needs_left_5).toInt\n        val needs_left_to_eat_5 = (needs_left - carrots_left_5).toInt\n\
    \        val carrots_left_to_eat_6 = (carrots_left - needs_left_6).toInt\n   \
    \     val needs_left_to_eat_6 = (needs_left - carrots_left_6).toInt\n        val\
    \ carrots_left_to_eat_7 = (carrots_left - needs_left_7).toInt\n        val needs_left_to_eat_7\
    \ = (needs_left - carrots_left_7).toInt\n        val carrots_left_to_eat_8 = (carrots_left\
    \ - needs_left_8).toInt\n        val needs_left_to_eat_8 = (needs_left - carrots_left_8).toInt\n\
    \        val carrots_left_to_eat_9 = (carrots_left - needs_left_9).toInt\n   \
    \     val needs_left_to_eat_9 = (needs_left - carrots_left_9).toInt\n        val\
    \ carrots_left_to_eat_10 = (carrots_left - needs_left_10).toInt\n        val needs_left_to_eat_10\
    \ = (needs_left - carrots_left_10).toInt\n        val carrots_left_to_eat_11\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_hjbgecy.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_hjbgecy.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp_hjbgecy.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_hjbgecy.scala:58:5 ---------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n\
    \        var carrots = number\n        var remaining = remaining\n        while\
    \ (carrots > 0 && remaining > 0) {\n            list.append((carrots - remaining).toLong)\n\
    \            carrots -= remaining\n            remaining -= need\n        }\n\
    \        if (remaining > 0) {\n            list += (remaining).toLong\n      \
    \  }\n        list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbwcuukzh.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpbwcuukzh.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804455
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = carrots - meals\n\
    \        val hungryList = List(hungry.toLong)\n        val hungryList2 = List(hungry.toLong)\n\
    \        val hungryList3 = List(hungry.toLong)\n        val hungryList4 = List(hungry.toLong)\n\
    \        val hungryList5 = List(hungry.toLong)\n        val hungryList6 = List(hungry.toLong)\n\
    \        val hungryList7 = List(hungry.toLong)\n        val hungryList8 = List(hungry.toLong)\n\
    \        val hungryList9 = List(hungry.toLong)\n        val hungryList10 = List(hungry.toLong)\n\
    \        val hungryList11 = List(hungry.toLong)\n        val hungryList12 = List(hungry.toLong)\n\
    \        val hungryList13 = List(hungry.toLong)\n        val hungryList14 = List(hungry.toLong)\n\
    \        val hungryList15 = List(hungry.toLong)\n        val hungryList16 = List(hungry.toLong)\n\
    \        val hungryList17 = List(hungry.toLong)\n        val hungryList18 = List(hungry.toLong)\n\
    \        val hungryList19 = List(hungry.toLong)\n        val hungryList20 = List(hungry.toLong)\n\
    \        val hungryList21 = List(hungry.toLong)\n        val hungryList22 = List(hungry.toLong)\n\
    \        val hungryList23 = List(hungry.toLong)\n        val hungryList24 = List(hungry.toLong)\n\
    \        val hungryList25 = List(hungry.toLong)\n        val hungryList26 = List(hungry.toLong)\n\
    \        val hungryList27 = \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpywi9k0a8.scala:62:26 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36mhungryList27\e[0m = \n\e\
    [31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m         \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpywi9k0a8.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpywi9k0a8.scala:63:5\
    \ ---------------------\e[0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - hungry\n        if (hungryRemaining\
    \ <= 0) {\n            List(number.toLong, hungry.toLong)\n        } else {\n\
    \            val hungryEaten = eat(number, need, hungryRemaining)\n          \
    \  val hungryLeft = hungryRemaining - hungryEaten._1\n            List(hungryEaten._1\
    \ + hungryEaten._2, hungryLeft.toLong)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp60riwmbe.scala:37:59 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mhungryLeft\e[0m = hungryRemaining\
    \ - hungryEaten._1\n\e[31m\e[31m   |\e[0m                                    \
    \           ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \     value _1 is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp60riwmbe.scala:38:29 ------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m            List(hungryEaten._1 + hungryEaten._2, hungryLeft.toLong)\n\
    \e[31m\e[31m   |\e[0m                 ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \              value _1 is not a member of List[Long]\n2 errors found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining\n        val carrots_left_after_meals = carrots - carrots_left\n \
    \       val carrots_left_after_meals_after_meals = carrots_left - carrots_left_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals\
    \ - carrots_left_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpv7zru0pe.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv7zru0pe.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpv7zru0pe.scala:43:123 --------------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                   ^\e[0m\n\e\
    [31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpv7zru0pe.scala:44:5 ---------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804457
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val eatenCarrots = carrots - needToEat\n        val leftToEat = remainingToEat\
    \ - eatenCarrots\n        val remainingCarrots = leftToEat.toLong\n        val\
    \ hungryCarrots = carrots - remainingCarrots\n        val hungryCarrotsList =\
    \ List(hungryCarrots.toLong)\n        val hungryCarrotsListWithRemaining = hungryCarrotsList\
    \ :+ remainingCarrots\n        val hungryCarrotsListWithRemainingWithRemaining\
    \ = hungryCarrotsListWithRemaining :+ remainingToEat\n        val hungryCarrotsListWithRemainingWithRemainingWithRemaining\
    \ = hungryCarrotsListWithRemainingWithRemaining :+ needToEat\n        val hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryCarrotsListWithRemainingWithRemainingWithRemaining :+ carrots\n    \
    \    val hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemaining :+ need\n\
    \        val hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemaining :+ remaining\n\
    \        val hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ :+ carrots\n        val hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ :+ need\n        val hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungry\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcg83gx7o.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\e\
    [0m = hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemaining :+\
    \ remaining\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpcg83gx7o.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\e\
    [0m = hungry\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  hungryCarrotsListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpcg83gx7o.scala:48:5 ---------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        val needList = List(need.toLong)\n\
    \        val needList2 = List(need.toLong)\n        val needList3 = List(need.toLong)\n\
    \        val needList4 = List(need.toLong)\n        val needList5 = List(need.toLong)\n\
    \        val needList6 = List(need.toLong)\n        val needList7 = List(need.toLong)\n\
    \        val needList8 = List(need.toLong)\n        val needList9 = List(need.toLong)\n\
    \        val needList10 = List(need.toLong)\n        val needList11 = List(need.toLong)\n\
    \        val needList12 = List(need.toLong)\n        val needList13 = List(need.toLong)\n\
    \        val needList14 = List(need.toLong)\n        val needList15 = List(need.toLong)\n\
    \        val needList16 = List(need.toLong)\n        val needList17 = List(need.toLong)\n\
    \        val needList18 = List(need.toLong)\n        val needList19 = List(need.toLong)\n\
    \        val needList20 = List(need.toLong)\n        val needList21 = List(need.toLong)\n\
    \        val needList22 = List(need.toLong)\n        val needList23 = List(need.toLong)\n\
    \        val needList24 = List(need.toLong)\n        val needList25 = List(need.toLong)\n\
    \        val needList26 = List(need.toLong)\n        val needList27 = List(need.toLong)\n\
    \        val needList28 = List(need.toLong)\n        val needList29 = List(need.toLong)\n\
    \        val needList30 = List(need.toLong)\n        val needList31 = List(need.toLong)\n\
    \        val needList32 = List(need.toLong)\n        val needList33 = List(need.toLong)\n\
    \        val needList34 = List(need.toLong)\n        val needList35 = List(need.toLong)\n\
    \        val needList36 = List(need.toLong)\n        val needList37 = List(need.toLong)\n\
    \        val needList38 = List(need.toLong)\n        val needList39 = List(need.toLong)\n\
    \        val needList40 = List(need.toLong)\n        val needList41 = List(need.toLong)\n\
    \        val needList42 = List(\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpo0697dwu.scala:74:30 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36mneedList42\e[0m = List(\n\
    \e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m   \
    \                           expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo0697dwu.scala:75:5 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        var carrots_left =\
    \ remaining\n        var carrots_eaten = 0\n        while (carrots_left > 0 &&\
    \ carrots_eaten < needs) {\n            carrots_left -= 1\n            carrots_eaten\
    \ += 1\n            result.add(carrots_eaten.toLong)\n        }\n        if (carrots_left\
    \ > 0) {\n            carrots_eaten = needs - carrots_eaten\n            result.add(carrots_eaten.toLong)\n\
    \        }\n        result.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1f7ivlh2.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1f7ivlh2.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining > 0)\
    \ {\n            val carrots_left = carrots - remaining\n            if (carrots_left\
    \ >= needs) {\n                result.add(carrots_left)\n                result.add(carrots)\n\
    \            } else {\n                result.add(carrots)\n            }\n  \
    \      }\n        return result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbckdbjo1.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbckdbjo1.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804454
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val numCarrots = number.toInt\n\
    \        val needCarrots = need.toInt\n        val remainingCarrots = remaining.toInt\n\
    \        val carrots = mutable.ListBuffer.empty[Long]\n        val hungry = true\n\
    \        val hungryCarrots = mutable.ListBuffer.empty[Long]\n        val hungryCarrots\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCarrots = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCarrots = mutable.ListBuffer.empty[Long]\n        val hungryCarrots\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCarrots = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCarrots = mutable.ListBuffer.empty[Long]\n        val hungryCarrots\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCarrots = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCarrots = mutable.ListBuffer.empty[Long]\n        val hungryCarrots\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCarrots = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCarrots = mutable.ListBuffer.empty[Long]\n        val hungryCarrots\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCarrots = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCarrots = mutable.ListBuffer.empty[Long]\n        val hungryCarrots\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCarrots = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCarrots = mutable.ListBuffer.empty[Long]\n        val hungryCarrots\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCarrots = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCarrots = mutable.ListBuffer.empty[Long]\n        val hungryCarrots\
    \ = mutable.ListBuffer.empty[Long]\n        val hungryCarrots = mutable.ListBuffer.empty[Long]\n\
    \        val hungryCarrots = mutable.ListBuffer.empty[Long]\n        val hungryCarrots\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbwebfynx.scala:61:27 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = \n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m        \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbwebfynx.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbwebfynx.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbwebfynx.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbwebfynx.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659804457
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        val carrots_left = remaining\n\
    \        val carrots_needed = carrots - carrots_left\n        val carrots_needed_to_eat\
    \ = (carrots_needed - needs).toInt\n        val carrots_left_to_eat = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat2 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat3 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat4 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat5 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat6 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat7 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat8 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat9 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat10 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat11 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat12 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat13 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat14 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat15 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat16 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_eat17 = (carrots_needed\
    \ - carrots_needed_to_eat).toInt\n        val carrots_left_to_\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfhqpmrqb.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfhqpmrqb.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpfhqpmrqb.scala:34:19 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpfhqpmrqb.scala:56:5 ---------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = carrots - remainingToEat\n        val carrotLeftToEat\
    \ = carrotEaten - needToEat\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList,\
    \ carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplup52mnk.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        (carrotEatenList, carrotLeftToEatList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e[31m]\e[0m\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = needs - carrots\n        val carrots_left_after_meals\
    \ = carrots - carrots_left\n        val needs_left_after_meals = needs - needs_left\n\
    \        val carrots_left_after_meals_after_meals = carrots_left - carrots_left_after_meals\n\
    \        val needs_left_after_meals_after_meals = needs_left - needs_left_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals\
    \ - carrots_left_after_meals_after_meals\n        val needs_left_after_meals_after_meals_after_meals\
    \ = needs_left_after_meals - needs_left_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals\n\
    \        val needs_left_after_meals_after_meals_after_meals_after_meals = needs_left_after_meals_after_meals\
    \ - needs_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals\n\
    \        val needs_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = needs_left_after_meals_after_meals_after_meals - needs_left_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals_after_\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk64shave.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk64shave.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpk64shave.scala:48:5 ---------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        val needList = List(need.toLong)\n\
    \        val needList2 = List(need.toLong)\n        val needList3 = List(need.toLong)\n\
    \        val needList4 = List(need.toLong)\n        val needList5 = List(need.toLong)\n\
    \        val needList6 = List(need.toLong)\n        val needList7 = List(need.toLong)\n\
    \        val needList8 = List(need.toLong)\n        val needList9 = List(need.toLong)\n\
    \        val needList10 = List(need.toLong)\n        val needList11 = List(need.toLong)\n\
    \        val needList12 = List(need.toLong)\n        val needList13 = List(need.toLong)\n\
    \        val needList14 = List(need.toLong)\n        val needList15 = List(need.toLong)\n\
    \        val needList16 = List(need.toLong)\n        val needList17 = List(need.toLong)\n\
    \        val needList18 = List(need.toLong)\n        val needList19 = List(need.toLong)\n\
    \        val needList20 = List(need.toLong)\n        val needList21 = List(need.toLong)\n\
    \        val needList22 = List(need.toLong)\n        val needList23 = List(need.toLong)\n\
    \        val needList24 = List(need.toLong)\n        val needList25 = List(need.toLong)\n\
    \        val needList26 = List(need.toLong)\n        val needList27 = List(need.toLong)\n\
    \        val needList28 = List(need.toLong)\n        val needList29 = List(need.toLong)\n\
    \        val needList30 = List(need.toLong)\n        val needList31 = List(need.toLong)\n\
    \        val needList32 = List(need.toLong)\n        val needList33 = List(need.toLong)\n\
    \        val needList34 = List(need.toLong)\n        val needList35 = List(need.toLong)\n\
    \        val needList36 = List(need.toLong)\n        val needList37 = List(need.toLong)\n\
    \        val needList38 = List(need.toLong)\n        val needList39 = List(need.toLong)\n\
    \        val needList40 = List(need.toLong)\n        val needList41 = List(need.toLong)\n\
    \        val needList42 = List(\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpo0697dwu.scala:74:30 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36mneedList42\e[0m = List(\n\
    \e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m   \
    \                           expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo0697dwu.scala:75:5 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val remainingCarrots = remaining\
    \ - carrots\n        val hungry = carrots > 0\n        val hungryCarrots = carrots\
    \ - hungry\n        val hungryMeals = meals - hungryCarrots\n        val hungryRemainingCarrots\
    \ = remainingCarrots - hungryCarrots\n        val hungryRemainingMeals = remainingMeals\
    \ - hungryRemainingCarrots\n        val hungryRemainingMealsString = hungryRemainingMeals.toString\n\
    \        val hungryRemainingCarrotsString = hungryRemainingCarrots.toString\n\
    \        val hungryMealsString = hungryMeals.toString\n        val hungryCarrotsString\
    \ = hungryCarrots.toString\n        val hungryString = hungry.toString\n     \
    \   val hungryRemainingString = hungryRemainingCarrotsString + hungryRemainingMealsString\n\
    \        val hungryMealsString = hungryMealsString + hungryRemainingMealsString\n\
    \        val hungryCarrotsString = hungryCarrotsString + hungryRemainingCarrotsString\n\
    \        val hungryString = hungryString + hungryMealsString + hungryCarrotsString\n\
    \        val hungryRemainingString = hungryRemainingString + hungryMealsString\
    \ + hungryCarrotsString\n        val hungryString = hungryString + hungryRemainingString\n\
    \        val hungryString = hungryString + hungryString\n        val hungryString\
    \ = hungryString + hungryString\n        val hungryString = hungryString + hungryString\n\
    \        val hungryString = hungryString + hungryString\n        val hungryString\
    \ = hungryString + hungryString\n        val hungryString = hungryString + hungryString\n\
    \        val h\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpetvzr68d.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpetvzr68d.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryMealsString\e[0m = hungryMealsString + hungryRemainingMealsString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryMealsString is already defined as \e[33mvalue\e[0m \e\
    [35mhungryMealsString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpetvzr68d.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrotsString\e[0m\
    \ = hungryCarrotsString + hungryRemainingCarrotsString\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrotsString is already defined as \e[33mvalue\e[0m\
    \ \e[35mhungryCarrotsString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpetvzr68d.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mhungryString\e[0m = hungryString\
    \ + hungryMealsString + hungryCarrotsString\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryString is already defined as \e[33mvalue\e[0m \e[35mhungryString\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpetvzr68d.scala:48:12 ---------------------------\e[0m\e[0m\n\e\
    [31m48 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingString\e[0m = hungryRemainingString\
    \ + hungryMealsString + hungryCarrotsString\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659804467
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val carrots_left_to_eat = (carrots_left - needs).toInt\n\
    \        val carrots_left_to_eat2 = (carrots_left_to_eat * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat3 = (carrots_left_to_eat2 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat4 = (carrots_left_to_eat3 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat5 = (carrots_left_to_eat4 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat6 = (carrots_left_to_eat5 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat7 = (carrots_left_to_eat6 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat8 = (carrots_left_to_eat7 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat9 = (carrots_left_to_eat8 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat10 = (carrots_left_to_eat9 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat11 = (carrots_left_to_eat10 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat12 = (carrots_left_to_eat11 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat13 = (carrots_left_to_eat12 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat14 = (carrots_left_to_eat13 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat15 = (carrots_left_to_eat14 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat16 = (carrots_left_to_eat15 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat17 = (carrots_left_to_eat16 * carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat18 = (carrots_left_to_eat17\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzww3cpd6.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzww3cpd6.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpzww3cpd6.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzww3cpd6.scala:54:5 ---------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804467
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        val hungryList2 = List(hungry.toLong)\n\
    \        if (remaining > need) {\n            hungryList2 :+ remaining\n     \
    \   }\n        if (remaining < need) {\n            hungryList :+ remaining\n\
    \        }\n        if (hungryList.size == 0) {\n            hungryList2 :+ 0\n\
    \        }\n        if (hungryList2.size == 0) {\n            hungryList :+ 0\n\
    \        }\n        if (hungryList.size == 1) {\n            hungryList :+ 0\n\
    \        }\n        if (hungryList2.size == 1) {\n            hungryList2 :+ 0\n\
    \        }\n        if (hungryList.size == 2) {\n            hungryList :+ 0\n\
    \        }\n        if (hungryList2.size == 2) {\n            hungryList2 :+ 0\n\
    \        }\n        if (hungryList.size == 3) {\n            hungryList :+ 0\n\
    \        }\n        if (hungryList2.size == 3) {\n            hungryList2 :+ 0\n\
    \        }\n        if (hungryList.size == 4) {\n            hungryList :+ 0\n\
    \        }\n        if (hungryList2.size == 4) {\n            hungryList2 :+ 0\n\
    \        }\n        if (hungryList.size == 5) {\n            hungryList :+ 0\n\
    \        }\n        if (hungryList2.size == 5) {\n            hungryList2 :+ 0\n\
    \        }\n        if (hungryList.size == 6) {\n            hungryList :+ 0\n\
    \        }\n        if (hungryList2.size == 6) {\n            hungryList2 :+ 0\n\
    \        }\n        if (hungryList.size == 7) {\n            hungryList :+ 0\n\
    \        }\n        if (hungryList2.size == 7) {\n            hungryList2 :+ 0\n\
    \        }\n        if (hungryList.size == 8) {\n            hungryList :+ 0\n\
    \        }\n        if (hungryList2.size == 8) {\n            hungryList2 :+ 0\n\
    \        }\n        if (hungryList.size == 9) {\n            hungryList :+ 0\n\
    \        }\n        if (hungryList2.size == 9) {\n            hungryList2 :+ 0\n\
    \        }\n        if (h\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9737cgyz.scala:101:4 ---------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9737cgyz.scala:100:12\
    \ -----------------------\e[0m\e[0m\n\e[31m100 |\e[0m        \e[33mif\e[0m (h\n\
    \e[31m\e[31m    |\e[0m            ^\e[0m\n\e[31m    |\e[0m            Not found:\
    \ h\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804463
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val totalCarrots = carrots - remaining\n        val needCarrots = needs\
    \ - remaining\n        val carrotList = List[Long]()\n        carrotList += totalCarrots.toLong\n\
    \        carrotList += needCarrots.toLong\n        carrotList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqpoxeodu.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqpoxeodu.scala:37:19\
    \ ------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        carrotList += totalCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is\
    \ not a member of List[Long] - did you mean carrotList.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpqpoxeodu.scala:38:19 ------------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m        carrotList += needCarrots.toLong\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value += is not a member of\
    \ List[Long] - did you mean carrotList.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659804469
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat\
    \ = carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList,\
    \ carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps8fmvzka.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        (carrotEatenList, carrotLeftToEatList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e[31m]\e[0m\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804468
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = carrots - meals\n\
    \        val hungryList = List(hungry.toLong)\n        val mealsList = List(meals.toLong)\n\
    \        val hungryList2 = List(hungry.toLong)\n        val mealsList2 = List(meals.toLong)\n\
    \        if (remaining == 0) {\n            hungryList2 :+ 0\n            mealsList2\
    \ :+ 0\n        } else {\n            if (meals < need) {\n                hungryList2\
    \ :+ meals\n                mealsList2 :+ 0\n            } else {\n          \
    \      hungryList2 :+ 0\n                mealsList2 :+ meals\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp24206i_1.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804464
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val remaining = remaining\
    \ - number\n        if (remaining < need) {\n            val carrots = math.min(need,\
    \ remaining)\n            List(number + carrots.toLong)\n        } else {\n  \
    \          val carrots = math.min(need, remaining)\n            List(number +\
    \ carrots.toLong, carrots)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy1w0zhoa.scala:31:24 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - number\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804464
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = carrots > 0\n      \
    \  val hungryCarrots = carrots - hungry\n        val hungryMeals = meals - hungry\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = h\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzxpqh7o4.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzxpqh7o4.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzxpqh7o4.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzxpqh7o4.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzxpqh7o4.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1659804469
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = carrots - need\n        val needs_left_in_stock\
    \ = needs_left / need\n        val needs_left_in_stock2 = needs_left_in_stock.toInt\n\
    \        val needs_left_in_stock3 = needs_left_in_stock2 * need\n        val needs_left_in_stock4\
    \ = needs_left_in_stock3 * need\n        val needs_left_in_stock5 = needs_left_in_stock4\
    \ * need\n        val needs_left_in_stock6 = needs_left_in_stock5 * need\n   \
    \     val needs_left_in_stock7 = needs_left_in_stock6 * need\n        val needs_left_in_stock8\
    \ = needs_left_in_stock7 * need\n        val needs_left_in_stock9 = needs_left_in_stock8\
    \ * need\n        val needs_left_in_stock10 = needs_left_in_stock9 * need\n  \
    \      val needs_left_in_stock11 = needs_left_in_stock10 * need\n        val needs_left_in_stock12\
    \ = needs_left_in_stock11 * need\n        val needs_left_in_stock13 = needs_left_in_stock12\
    \ * need\n        val needs_left_in_stock14 = needs_left_in_stock13 * need\n \
    \       val needs_left_in_stock15 = needs_left_in_stock14 * need\n        val\
    \ needs_left_in_stock16 = needs_left_in_stock15 * need\n        val needs_left_in_stock17\
    \ = needs_left_in_stock16 * need\n        val needs_left_in_stock18 = needs_left_in_stock17\
    \ * need\n        val needs_left_in_stock19 = needs_left_in_stock18 * need\n \
    \       val needs_left_in_stock20 = needs_left_in_stock19 * need\n        val\
    \ needs_left_in_stock21 = needs_left_in_stock20 * need\n        val needs_left_in_stock22\
    \ = needs_left_in_stock21 * need\n        val needs_left_in_stock23 = needs_left_in_stock22\
    \ * need\n        val needs_left_in_stock24 = needs_left_in_stock23 * need\n \
    \       val needs_left_in_stock25 = needs_left_in_stock24 * need\n        val\
    \ needs_left_in_stock26 = needs_left_in_stock25 * need\n        val needs_left_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn3dfg083.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpn3dfg083.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpn3dfg083.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn3dfg083.scala:64:5 ---------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804468
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrotsLeft = carrots - remaining\n        val needsToEat = needs -\
    \ remaining\n        val carrotsToEat = carrotsLeft - needsToEat\n        val\
    \ carrotsToEatList = List(carrotsToEat.toLong)\n        val carrotsToEatList2\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList3 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList4 = List(carrotsToEat.toLong)\n        val carrotsToEatList5\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList6 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList7 = List(carrotsToEat.toLong)\n        val carrotsToEatList8\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList9 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList10 = List(carrotsToEat.toLong)\n        val carrotsToEatList11\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList12 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList13 = List(carrotsToEat.toLong)\n        val carrotsToEatList14\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList15 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList16 = List(carrotsToEat.toLong)\n        val carrotsToEatList17\
    \ = List(carrotsToEat.toLong)\n        val carrotsToEatList18 = List(carrotsToEat.toLong)\n\
    \        val carrotsToEatList19 = List(carrotsToEat.toLong)\n        val carrotsToEatList20\
    \ = List(carrotsToEat.toLong)\n\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_3y4f6sr.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_3y4f6sr.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804468
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val carrots_needed = needs\
    \ - carrots_left\n        val carrots_left_after_meals = carrots_left - carrots_needed\n\
    \        val carrots_needed_after_meals = carrots_needed - carrots_left\n    \
    \    val carrots_left_after_meals_after_meals = carrots_left_after_meals - carrots_needed_after_meals\n\
    \        val carrots_needed_after_meals_after_meals = carrots_needed_after_meals\
    \ - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals - carrots_needed_after_meals_after_meals\n\
    \        val carrots_needed_after_meals_after_meals_after_meals = carrots_needed_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals\n        val carrots_needed_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_needed_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_needed_after_me\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4g8j5qrf.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4g8j5qrf.scala:43:89\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                 ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mcarrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4g8j5qrf.scala:44:101\
    \ --------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                             ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_needed_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4g8j5qrf.scala:45:113 -----------------------\e[0m\e[0m\n\e[31m45 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrots_needed_a"
  stdout: ''
  timestamp: 1659804468
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new ArrayList[Long]()\n        val remaining =\
    \ remaining - carrots\n        val needs = needs - carrots\n        val result\
    \ = result :+ carrots\n        if (remaining <= 0) {\n            val result =\
    \ result :+ remaining\n        }\n        if (needs > 0) {\n            val result\
    \ = result :+ needs\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuu6az4yp.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mremaining is already defined as \e[33mvalue\e[0m \e[35mremaining\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuu6az4yp.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mneeds\e[0m = needs - carrots\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mneeds is\
    \ already defined as \e[33mvalue\e[0m \e[35mneeds\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuu6az4yp.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mresult\e[0m = result :+ carrots\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpuu6az4yp.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuu6az4yp.scala:34:37 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Not found: type ArrayList\n\e[31"
  stdout: ''
  timestamp: 1659804465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val mealsLeft = meals - remaining\n        val carrotsLeft = carrots - meals\n\
    \        val mealsLeft = mealsLeft.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val result = List(carrotsLeft.toLong, mealsLeft.toLong)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1e_m486d.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1e_m486d.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrotsLeft\e[0m = carrotsLeft.toLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mcarrotsLeft is already defined as \e[33mvalue\e[0m \e[35mcarrotsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp1e_m486d.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = carrots - meals\n\
    \        val hungryList = List(meals, hungry)\n        val hungryList2 = List(meals,\
    \ hungry)\n        val hungryList3 = List(meals, hungry)\n        val hungryList4\
    \ = List(meals, hungry)\n        val hungryList5 = List(meals, hungry)\n     \
    \   val hungryList6 = List(meals, hungry)\n        val hungryList7 = List(meals,\
    \ hungry)\n        val hungryList8 = List(meals, hungry)\n        val hungryList9\
    \ = List(meals, hungry)\n        val hungryList10 = List(meals, hungry)\n    \
    \    val hungryList11 = List(meals, hungry)\n        val hungryList12 = List(meals,\
    \ hungry)\n        val hungryList13 = List(meals, hungry)\n        val hungryList14\
    \ = List(meals, hungry)\n        val hungryList15 = List(meals, hungry)\n    \
    \    val hungryList16 = List(meals, hungry)\n        val hungryList17 = List(meals,\
    \ hungry)\n        val hungryList18 = List(meals, hungry)\n        val hungryList19\
    \ = List(meals, hungry)\n        val hungryList20 = List(meals, hungry)\n    \
    \    val hungryList21 = List(meals, hungry)\n        val hungryList22 = List(meals,\
    \ hungry)\n        val hungryList23 = List(meals, hungry)\n        val hungryList24\
    \ = List(meals, hungry)\n        val hungryList25 = List(meals, hungry)\n    \
    \    val hungryList26 = List(meals, hungry)\n        val hungryList27 = \n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpilfm6myw.scala:62:26 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36mhungryList27\e[0m = \n\e\
    [31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m         \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpilfm6myw.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpilfm6myw.scala:63:5\
    \ ---------------------\e[0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804468
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new ArrayList[Long]()\n        val carrots_remaining\
    \ = remaining - carrots\n        val needs_remaining = carrots - needs\n     \
    \   val needs_remaining_2 = needs_remaining / 2\n        val needs_remaining_3\
    \ = needs_remaining - needs_remaining_2\n        val needs_remaining_4 = needs_remaining\
    \ - needs_remaining_3\n        val needs_remaining_5 = needs_remaining - needs_remaining_4\n\
    \        val needs_remaining_6 = needs_remaining - needs_remaining_5\n       \
    \ val needs_remaining_7 = needs_remaining - needs_remaining_6\n        val needs_remaining_8\
    \ = needs_remaining - needs_remaining_7\n        val needs_remaining_9 = needs_remaining\
    \ - needs_remaining_8\n        val needs_remaining_10 = needs_remaining - needs_remaining_9\n\
    \        val needs_remaining_11 = needs_remaining - needs_remaining_10\n     \
    \   val needs_remaining_12 = needs_remaining - needs_remaining_11\n        val\
    \ needs_remaining_13 = needs_remaining - needs_remaining_12\n        val needs_remaining_14\
    \ = needs_remaining - needs_remaining_13\n        val needs_remaining_15 = needs_remaining\
    \ - needs_remaining_14\n        val needs_remaining_16 = needs_remaining - needs_remaining_15\n\
    \        val needs_remaining_17 = needs_remaining - needs_remaining_16\n     \
    \   val needs_remaining_18 = needs_remaining - needs_remaining_17\n        val\
    \ needs_remaining_19 = needs_remaining - needs_remaining_18\n        val needs_remaining_20\
    \ = needs_remaining - needs_remaining_19\n        val needs_remaining_21 = needs_remaining\
    \ - needs_remaining_20\n        val needs_remaining_22 = needs_remaining - needs_remaining_21\n\
    \        val needs_remaining_23 = needs_remaining - needs_remaining_22\n     \
    \   val needs_remaining_24 = needs_remaining - needs_remaining_23\n        val\
    \ needs_remaining_25 = needs_remaining - needs_remaining_24\n        val needs_remaining_26\
    \ = needs_remaining - needs_remaining_25\n        val needs_remaining_27 = needs_remaining\
    \ - needs_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0zhhgn46.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0zhhgn46.scala:34:37\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArrayList\e\
    [0m[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                \
    \     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     Not\
    \ found: type ArrayList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0zhhgn46.scala:62:51\
    \ ------------------------\e[0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e\
    [36mneeds_remaining_27\e[0m = needs_remaining - needs_\n\e[31m\e[31m   |\e[0m\
    \                                                   ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                   Not found: needs_\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0zhhgn46.scala:63:5 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804468
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining > 0)\
    \ {\n            val carrots_left = carrots - remaining\n            val needs_left\
    \ = needs - remaining\n            if (carrots_left == 0) {\n                result\
    \ += carrots_left\n                result += needs_left\n            } else {\n\
    \                result += carrots_left\n                result += needs_left\n\
    \                result += remaining\n            }\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_crjbtg6.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_crjbtg6.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        var carrots_left = remaining\n\
    \        while (carrots_left > 0) {\n            carrots_left -= 1\n         \
    \   list += carrots_left\n        }\n        if (carrots_left < needs) {\n   \
    \         list += carrots_left\n        }\n        list += carrots - needs.toInt\n\
    \        list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpme4s1biw.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpme4s1biw.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = List[Long]()\n        val carrots_left = carrots - remaining\n\
    \        val needs_left = needs - remaining\n        val carrots_left_to_eat =\
    \ carrots_left - needs_left\n        val needs_left_to_eat = needs_left - carrots_left\n\
    \        val carrots_left_to_eat2 = carrots_left_to_eat.toInt\n        val needs_left_to_eat2\
    \ = needs_left_to_eat.toInt\n        val carrots_left_to_eat3 = carrots_left_to_eat2.toInt\n\
    \        val needs_left_to_eat3 = needs_left_to_eat2.toInt\n        val carrots_left_to_eat4\
    \ = carrots_left_to_eat3.toInt\n        val needs_left_to_eat4 = needs_left_to_eat3.toInt\n\
    \        val carrots_left_to_eat5 = carrots_left_to_eat4.toInt\n        val needs_left_to_eat5\
    \ = needs_left_to_eat4.toInt\n        val carrots_left_to_eat6 = carrots_left_to_eat5.toInt\n\
    \        val needs_left_to_eat6 = needs_left_to_eat5.toInt\n        val carrots_left_to_eat7\
    \ = carrots_left_to_eat6.toInt\n        val needs_left_to_eat7 = needs_left_to_eat6.toInt\n\
    \        val carrots_left_to_eat8 = carrots_left_to_eat7.toInt\n        val needs_left_to_eat8\
    \ = needs_left_to_eat7.toInt\n        val carrots_left_to_eat9 = carrots_left_to_eat8.toInt\n\
    \        val needs_left_to_eat9 = needs_left_to_eat8.toInt\n        val carrots_left_to_eat10\
    \ = carrots_left_to_eat9.toInt\n        val needs_left_to_eat10 = needs_left_to_eat9.toInt\n\
    \        val carrots_left_to_eat11 = carrots_left_to_eat10.toInt\n        val\
    \ needs_left_to_eat11 = needs_left_to_eat10.toInt\n        val carrots_left_to_eat12\
    \ = carrots_left_to_eat11.toInt\n        val needs_left_to_eat12 = needs_left_to_eat11.toInt\n\
    \        val carrots_left_to_eat13 = carrots_left_to_eat12.toInt\n        val\
    \ needs_left_to_eat13 = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjgb8fq44.scala:62:33 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_to_eat13\e[0m\
    \ = \n\e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e\
    [0m                                 expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjgb8fq44.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpjgb8fq44.scala:63:5 ---------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804469
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = carrots - remainingToEat\n        val carrotNeed =\
    \ carrotEaten + needToEat\n        val carrotNeededToEat = carrotNeed - carrotEaten\n\
    \        val carrotNeededToEatList = List(carrotNeededToEat.toLong)\n        val\
    \ carrotNeededToEatList2 = List(carrotNeededToEat.toLong)\n        val carrotNeededToEatList3\
    \ = List(carrotNeededToEat.toLong)\n        val carrotNeededToEatList4 = List(carrotNeededToEat.toLong)\n\
    \        val carrotNeededToEatList5 = List(carrotNeededToEat.toLong)\n       \
    \ val carrotNeededToEatList6 = List(carrotNeededToEat.toLong)\n        val carrotNeededToEatList7\
    \ = List(carrotNeededToEat.toLong)\n        val carrotNeededToEatList8 = List(carrotNeededToEat.toLong)\n\
    \        val carrotNeededToEatList9 = List(carrotNeededToEat.toLong)\n       \
    \ val carrotNeededToEatList10 = List(carrotNeededToEat.toLong)\n        val carrotNeededToEatList11\
    \ = List(carrotNeededToEat.toLong)\n        val carrotNeededToEatList12 = List(carrotNeededToEat.toLong)\n\
    \        val carrotNeededToEatList13 = List(carrotNeededToEat.toLong)\n      \
    \  val carrotNeededToEatList14 = List(carrotNeededToEat.toLong)\n        val carrotNeededToEatList15\
    \ = List(carrotNeededToEat.toLong)\n        val carrotNeededToEatList16 = List(carrotNeededToEat.toLong)\n\
    \        val carrotNeededToEatList17 = List(carrotNeededToEat.toLong)\n      \
    \  val carrotNeededToEatList18 = List(carrotNe\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3z9lftko.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3z9lftko.scala:54:43\
    \ ------------------------\e[0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrotNeededToEatList18\e[0m = List(carrotNe\n\e[31m\e[31m   |\e[0m      \
    \                                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                                  Not found: carrotNe\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp3z9lftko.scala:55:5 ---------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804469
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - hungry\n        val hungryEaten = if\
    \ (hungryRemaining < 0) 0 else hungry\n        val hungryEatenRemaining = if (hungryRemaining\
    \ < 0) 0 else hungryRemaining\n        val hungryEatenRemainingList = List(hungryEaten.toLong,\
    \ hungryEatenRemaining.toLong)\n        val hungryEatenRemainingListSorted = hungryEatenRemainingList.sortWith(_\
    \ < _)\n        val hungryEatenRemainingListSortedLast = hungryEatenRemainingListSorted.last\n\
    \        val hungryEatenRemainingListSortedLastIndex = hungryEatenRemainingListSorted.lastIndex\n\
    \        val hungryEatenRemainingListSortedLastIndex = if (hungryEatenRemainingListSortedLastIndex\
    \ == 0) 0 else hungryEatenRemainingListSortedLastIndex\n        val hungryEatenRemainingListSortedLastIndexList\
    \ = List(hungryEatenRemainingListSortedLastIndex.toLong)\n        val hungryEatenRemainingListSortedLastIndexListSorted\
    \ = hungryEatenRemainingListSortedLastIndexList.sortWith(_ < _)\n        val hungryEatenRemainingListSortedLastIndexListSortedLast\
    \ = hungryEatenRemainingListSortedLastIndexListSorted.last\n        val hungryEatenRemainingListSortedLastIndexListSortedLastIndex\
    \ = hungryEatenRemainingListSortedLastIndexListSorted.lastIndex\n        val hungryEatenRemainingListSortedLastIndexListSortedLastIndexList\
    \ = List(hungryEatenRemainingListSortedLastIndexListSortedLast.toLong)\n     \
    \   val hungryEatenRemainingListSortedLastIndexListSortedLastIndexListSorted =\
    \ hungryEatenRemainingListSortedLastIndexListSortedLastIndexList.sortWith(_ <\
    \ _)\n        val hungryEatenRemainingListSortedLastIndexListSortedLastIndexListSortedLast\
    \ = hungryEatenRemainingList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplrhxnpu8.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mhungryEatenRemainingListSortedLastIndex\e\
    [0m = \e[33mif\e[0m (hungryEatenRemainingListSortedLastIndex == \e[31m0\e[0m)\
    \ \e[31m0\e[0m \e[33melse\e[0m hungryEatenRemainingListSortedLastIndex\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryEatenRemainingListSortedLastIndex is already defined\
    \ as \e[33mvalue\e[0m \e[35mhungryEatenRemainingListSortedLastIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmplrhxnpu8.scala:38:85 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryEatenRemainingListSortedLastIndex\e[0m =\
    \ hungryEatenRemainingListSorted.lastIndex\n\e[31m\e[31m   |\e[0m            \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue lastIndex is not a member of List[Long] - did you mean\
    \ hungryEatenRemainingListSorted.lastIndexOf?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmplrhxnpu8.scala:41:119 -----------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        \e[33mval\e[0m \e[36mhungryEatenRemainingListSortedLastIndexListSorted\e\
    [0m = hungryEatenRemainingListSortedLastIndexList.sortWith(_ < _)\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                                  ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ < is not a member of Nothing, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\e[31m   |\e[0m  import\
    \ Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import\
    \ Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import\
    \ Char.char2double\n\e[31m   |\e[0m  import C"
  stdout: ''
  timestamp: 1659804472
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - need\n        val hungryEaten = if\
    \ (hungryRemaining <= 0) 0 else hungry\n        val hungryEatenRemaining = if\
    \ (hungryRemaining <= 0) 0 else hungryRemaining\n        val hungryEatenRemainingToEat\
    \ = hungryEatenRemaining / 2\n        val hungryEatenRemainingToEat2 = hungryEatenRemaining\
    \ - hungryEatenRemainingToEat\n        val hungryEatenRemainingToEat3 = hungryEatenRemaining\
    \ - hungryEatenRemainingToEat2\n        val hungryEatenRemainingToEat4 = hungryEatenRemaining\
    \ - hungryEatenRemainingToEat3\n        val hungryEatenRemainingToEat5 = hungryEatenRemaining\
    \ - hungryEatenRemainingToEat4\n        val hungryEatenRemainingToEat6 = hungryEatenRemaining\
    \ - hungryEatenRemainingToEat5\n        val hungryEatenRemainingToEat7 = hungryEatenRemaining\
    \ - hungryEatenRemainingToEat6\n        val hungryEatenRemainingToEat8 = hungryEatenRemaining\
    \ - hungryEatenRemainingToEat7\n        val hungryEatenRemainingToEat9 = hungryEatenRemaining\
    \ - hungryEatenRemainingToEat8\n        val hungryEatenRemainingToEat10 = hungryEatenRemaining\
    \ - hungryEatenRemainingToEat9\n        val hungryEatenRemainingToEat11 = hungryEatenRemaining\
    \ - hungryEatenRemainingToEat10\n        val hungryEatenRemainingToEat12 = hungryEaten\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf3ja_o35.scala:47:5\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804470
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryRabbit = number\
    \ - need\n        val hungryRabbitRemaining = remaining - hungryRabbit\n     \
    \   val hungryRabbitEaten = math.min(hungryRabbit, math.min(hungryRabbitRemaining,\
    \ 100))\n        val hungryRabbitLeft = (100 - hungryRabbitEaten)\n        val\
    \ hungryRabbitEatenList = List(hungryRabbitEaten.toLong)\n        val hungryRabbitLeftList\
    \ = List(hungryRabbitLeft.toLong)\n        val hungryRabbitList = List(hungryRabbitEatenList\
    \ ++ hungryRabbitLeftList)\n        hungryRabbitList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa1jxjask.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        hungryRabbitList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    (hungryRabbitList : List[List[Long]])\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804470
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - need\n        val hungryEaten = if\
    \ (hungryRemaining > 0) hungryRemaining else 0\n        val hungryEatenList =\
    \ List(hungryEaten.toLong)\n        val hungryEatenList2 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList3 = List(hungryEaten.toLong)\n        val hungryEatenList4\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList5 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList6 = List(hungryEaten.toLong)\n        val hungryEatenList7\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList8 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList9 = List(hungryEaten.toLong)\n        val hungryEatenList10\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList11 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList12 = List(hungryEaten.toLong)\n        val hungryEatenList13\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList14 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList15 = List(hungryEaten.toLong)\n        val hungryEatenList16\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList17 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList18 = List(hungryEaten.toLong)\n        val hungryEatenList19\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList20 = List(hungryEat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbiw5p30l.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbiw5p30l.scala:53:37\
    \ ------------------------\e[0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryEatenList20\e[0m = List(hungryEat\n\e[31m\e[31m   |\e[0m           \
    \                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                  Not found: hungryEat\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpbiw5p30l.scala:54:5 ---------------------\e[0m\e\
    [0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804474
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = carrots - meals\n\
    \        val left = (remaining - needs).toInt\n        val mealsLeft = meals -\
    \ left\n        val hungryLeft = hungry - left\n        val mealsLeftList = List(0,\
    \ mealsLeft)\n        val hungryLeftList = List(0, hungryLeft)\n        val mealsLeftList2\
    \ = List(0, mealsLeft - 1)\n        val hungryLeftList2 = List(0, hungryLeft -\
    \ 1)\n        val mealsLeftList3 = List(0, mealsLeft - 2)\n        val hungryLeftList3\
    \ = List(0, hungryLeft - 2)\n        val mealsLeftList4 = List(0, mealsLeft -\
    \ 3)\n        val hungryLeftList4 = List(0, hungryLeft - 3)\n        val mealsLeftList5\
    \ = List(0, mealsLeft - 4)\n        val hungryLeftList5 = List(0, hungryLeft -\
    \ 4)\n        val mealsLeftList6 = List(0, mealsLeft - 5)\n        val hungryLeftList6\
    \ = List(0, hungryLeft - 5)\n        val mealsLeftList7 = List(0, mealsLeft -\
    \ 6)\n        val hungryLeftList7 = List(0, hungryLeft - 6)\n        val mealsLeftList8\
    \ = List(0, mealsLeft - 7)\n        val hungryLeftList8 = List(0, hungryLeft -\
    \ 7)\n        val mealsLeftList9 = List(0, mealsLeft - 8)\n        val hungryLeftList9\
    \ = List(0, hungryLeft - 8)\n        val mealsLeftList10 = List(0, mealsLeft -\
    \ 9)\n        val hungryLeftList10 = List(0, hungryLeft - 9)\n        val mealsLeftList11\
    \ = List(0, mealsLeft - 10)\n        val hungryLeftList11 = List(0, hungryLeft\
    \ - 10)\n        val mealsLeftList12 = List(0, mealsLeft - 11)\n        val hungryLeftList12\
    \ = List(0, hungryLeft - 11)\n        val mealsLeftList13 = List(0, mealsLeft\
    \ - 12)\n        val hungryLeftList13 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpw51fhsr5.scala:64:30 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m \e[36mhungryLeftList13\e[0m =\
    \ \n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m\
    \                              expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpw51fhsr5.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpw51fhsr5.scala:65:5 ---------------------\e[0m\e[0m\n\e[31m65\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804474
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val eaten = need\n        val left  = hungry\n        if (left <= 0)\
    \ {\n            List(number.toLong)\n        } else {\n            val hungryList\
    \ = List(number.toLong)\n            val eatenList = List(need.toLong)\n     \
    \       val leftList = List(hungry.toLong)\n            while (left > 0) {\n \
    \               val hungryList2 = hungryList.takeWhile(_ <= 0)\n             \
    \   val eatenList2 = eatenList.takeWhile(_ <= 0)\n                val leftList2\
    \ = leftList.takeWhile(_ <= 0)\n                hungryList ++= hungryList2\n \
    \               eatenList ++= eatenList2\n                leftList ++= leftList2\n\
    \                left -= 1\n            }\n            hungryList ++= eatenList\n\
    \            hungryList ++= leftList\n            hungryList\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpacg_rqts.scala:44:27 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m                hungryList ++= hungryList2\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value ++=\
    \ is not a member of List[Long] - did you mean hungryList.++?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpacg_rqts.scala:45:26 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                eatenList ++= eatenList2\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    value ++= is\
    \ not a member of List[Long] - did you mean eatenList.++?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpacg_rqts.scala:46:25 ------------------------\e[0m\e\
    [0m\n\e[31m46 |\e[0m                leftList ++= leftList2\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     value ++= is not a member\
    \ of List[Long] - did you mean leftList.++?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpacg_rqts.scala:47:21 ------------------------\e[0m\e[0m\n\e[31m47 |\e\
    [0m                left -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m               \
    \ ^^^^^^^\e[0m\n\e[31m   |\e[0m                value -= is not a member of Long\
    \ - did you mean left.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpacg_rqts.scala:49:23\
    \ ------------------------\e[0m\e[0m\n\e[31m49 |\e[0m            hungryList ++=\
    \ eatenList\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m   value ++= is not a member of List[Long] - did you mean hungryList.++?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpacg_rqts.scala:50:23 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m            hungryList ++= leftList\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   value ++= is not a member\
    \ of List[Long] - did you mean hungryList.++?\n6 errors found\n"
  stdout: ''
  timestamp: 1659804478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left\
    \ / needs_left_2).toInt\n        val needs_left_to_eat_2 = (needs_left / carrots_left_2).toInt\n\
    \        val carrots_left_to_eat_3 = (carrots_left / needs_left_3).toInt\n   \
    \     val needs_left_to_eat_3 = (needs_left / carrots_left_3).toInt\n        val\
    \ carrots_left_to_eat_4 = (carrots_left / needs_left_4).toInt\n        val needs_left_to_eat_4\
    \ = (needs_left / carrots_left_4).toInt\n        val carrots_left_to_eat_5 = (carrots_left\
    \ / needs_left_5).toInt\n        val needs_left_to_eat_5 = (needs_left / carrots_left_5).toInt\n\
    \        val carrots_left_to_eat_6 = (carrots_left / needs_left_6).toInt\n   \
    \     val needs_left_to_eat_6 = (needs_left / carrots_left_6).toInt\n        val\
    \ carrots_left_to_eat_7 = (carrots_left / needs_left_7).toInt\n        val needs_left_to_eat_7\
    \ = (needs_left / carrots_left_7).toInt\n        val carrots_left_to_eat_8 = (carrots_left\
    \ / needs_left_8).toInt\n        val needs_left_to_eat_8 = (needs_left / carrots_left_8).toInt\n\
    \        val carrots_left_to_eat_9 = (carrots_left / needs_left_9).toInt\n   \
    \     val needs_left_to_eat_9 = (needs_left / carrots_left_9).toInt\n        val\
    \ carrots_left_to_eat_10 = (carrots_left / needs_left_10).toInt\n        val needs_left_to_eat_10\
    \ = (needs_left / carrots_left_10).toInt\n        val carrots_left_to_eat_11\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpry82zxu3.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpry82zxu3.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpry82zxu3.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpry82zxu3.scala:58:5 ---------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804476
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new ArrayList[Long]()\n        var carrots_left\
    \ = remaining\n        while (carrots_left > 0) {\n            carrots_left -=\
    \ 1\n            if (carrots > 0) {\n                result.add(carrots)\n   \
    \             carrots -= 1\n            } else {\n                carrots = remaining\n\
    \                carrots_left = remaining\n            }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpoh4rc21o.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoh4rc21o.scala:34:37\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArrayList\e\
    [0m[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                \
    \     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     Not\
    \ found: type ArrayList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoh4rc21o.scala:39:23\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                result.add(carrots)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \        value add is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpoh4rc21o.scala:40:24 ------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m                carrots -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -= is not a member\
    \ of Int - did you mean carrots.!=?\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpoh4rc21o.scala:42:24\
    \ -----------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                carrots\
    \ = remaining\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Reassignment to val carrots\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659804477
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrotsToEat = carrots - remaining\n        val carrotsToEatList = List(carrotsToEat)\n\
    \        val carrotsToEatList2 = List(carrotsToEat)\n        val carrotsToEatList3\
    \ = List(carrotsToEat)\n        val carrotsToEatList4 = List(carrotsToEat)\n \
    \       val carrotsToEatList5 = List(carrotsToEat)\n        val carrotsToEatList6\
    \ = List(carrotsToEat)\n        val carrotsToEatList7 = List(carrotsToEat)\n \
    \       val carrotsToEatList8 = List(carrotsToEat)\n        val carrotsToEatList9\
    \ = List(carrotsToEat)\n        val carrotsToEatList10 = List(carrotsToEat)\n\
    \        val carrotsToEatList11 = List(carrotsToEat)\n        val carrotsToEatList12\
    \ = List(carrotsToEat)\n        val carrotsToEatList13 = List(carrotsToEat)\n\
    \        val carrotsToEatList14 = List(carrotsToEat)\n        val carrotsToEatList15\
    \ = List(carrotsToEat)\n        val carrotsToEatList16 = List(carrotsToEat)\n\
    \        val carrotsToEatList17 = List(carrotsToEat)\n        val carrotsToEatList18\
    \ = List(carrotsToEat)\n        val carrotsToEatList19 = List(carrotsToEat)\n\
    \        val carrotsToEatList20 = List(carrotsToEat)\n        val carrotsToEatList21\
    \ = List(carrotsToEat)\n        val carrotsToEatList22 = List(carrotsToEat)\n\
    \        val carrotsToEatList23 = List(carrotsToEat)\n        val car\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsw7dsc09.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsw7dsc09.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsw7dsc09.scala:59:5 ---------------------\e[0m\e[0m\n\e[31m59\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804477
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - number\n        val result = List(number\
    \ + need)\n        if (leftCarrots > 0) {\n            result :+ eat(leftCarrots,\
    \ need, remaining)\n        } else {\n            result :+ number\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdj9ej_1o.scala:35:25\
    \ --------------------\e[0m\e[0m\n\e[31m35 |\e[0m            result :+ eat(leftCarrots,\
    \ need, remaining)\n\e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      Found:    \e[1m\e[31mList\e[0m\e[1m\e\
    [31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                      Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804477
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots).toInt\n        val carrots_to_eat = carrots_left_to_eat\
    \ * needs_left_to_eat\n        val needs_to_eat = needs_left_to_eat * carrots_left_to_eat\n\
    \        val carrots_to_eat_left = carrots_to_eat - needs_to_eat\n        val\
    \ needs_to_eat_left = needs_to_eat - carrots_to_eat\n        val carrots_to_eat_left_to_eat\
    \ = (carrots_to_eat_left / needs_to_eat).toInt\n        val needs_to_eat_left_to_eat\
    \ = (needs_to_eat_left / carrots_to_eat).toInt\n        val carrots_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat * needs_to_eat_left_to_eat\n        val needs_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat * carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left / needs_to_eat_left_to_eat).toInt\n     \
    \   val needs_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left\
    \ / carrots_to_eat_left_to_eat).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat * needs_to_eat_left_to_eat_left_to_eat\n\
    \        val needs_to_eat_left_to_eat_left_to_eat_left = needs_to_eat_left_to_eat_left_to_eat\
    \ * carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat / needs_to_eat_left_to_eat_left_to_eat).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left_to_eat\
    \ / carrots_to_eat_left_to_e\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxic6qnyj.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxic6qnyj.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpxic6qnyj.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxic6qnyj.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n\
    \        var carrots = number\n        var carrots_left = remaining\n        while\
    \ (carrots_left > 0 && carrots > 0) {\n            carrots -= 1\n            carrots_left\
    \ -= 1\n            list += carrots.toLong\n        }\n        list += carrots.toLong\n\
    \        list += carrots_left.toLong\n        list.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy2ii4dzt.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804475
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_to_eat = (carrots_left - needs_left).toInt\n\
    \        val needs_left_to_eat = (needs_left - carrots_left).toInt\n        val\
    \ carrots_left_to_eat_left = carrots_left - carrots_left_to_eat\n        val needs_left_to_eat_left\
    \ = needs_left - needs_left_to_eat\n        val carrots_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left - needs_left_to_eat_left).toInt\n        val needs_left_to_eat_left_to_eat\
    \ = (needs_left_to_eat_left - carrots_left_to_eat_left).toInt\n        val carrots_left_to_eat_left_to_eat_left\
    \ = carrots_left_to_eat_left - carrots_left_to_eat_left_to_eat\n        val needs_left_to_eat_left_to_eat_left\
    \ = needs_left_to_eat_left - needs_left_to_eat_left_to_eat\n        val carrots_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left_to_eat - needs_left_to_eat_left_to_eat_left).toInt\n\
    \        val needs_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat\
    \ - carrots_left_to_eat_left_to_eat_left).toInt\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left\
    \ = (carrots_left_to_eat_left_to_eat_left - carrots_left_to_eat_left_to_eat_left_to_eat).toInt\n\
    \        val needs_left_to_eat_left_to_eat_left_to_eat_left = (needs_left_to_eat_left_to_eat_left\
    \ - needs_left_to_eat_left_to_eat_left_to_eat).toInt\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left_to_eat_left_to_eat - needs_left_to_eat_left_to_eat_left_to_eat_left).toInt\n\
    \        val needs_left_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_left_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8wblzqit.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8wblzqit.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp8wblzqit.scala:49:69 ------------------------\e[0m\e[0m\n\e[31m49 |\e\
    [0m        \e[33mval\e[0m \e[36mneeds_left_to_eat_left_to_eat_left_to_eat_left_to_eat\e\
    [0m = (needs_left_\n\e[31m\e[31m   |\e[0m                                    \
    \                                 ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                        Not found: needs_left_\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8wblzqit.scala:50:5 ---------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = carrots - remainingToEat\n        val carrotLeftToEat\
    \ = carrots - needToEat\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList,\
    \ carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv8tzpk08.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        (carrotEatenList, carrotLeftToEatList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e[31m]\e[0m\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804457
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots).toInt\n        val carrots_left_to_eat_and_needs =\
    \ (carrots_left_to_eat + needs_left_to_eat).toInt\n        val needs_left_to_eat_and_carrots\
    \ = (needs_left_to_eat + carrots_left_to_eat).toInt\n        val carrots_left_to_eat_and_needs_and_carrots\
    \ = (carrots_left_to_eat_and_needs + needs_left_to_eat_and_carrots).toInt\n  \
    \      val needs_left_to_eat_and_needs_and_carrots = (needs_left_to_eat_and_needs\
    \ + carrots_left_to_eat_and_carrots).toInt\n        val needs_left_to_eat_and_needs_and_carrots_and_carrots\
    \ = needs_left_to_eat_and_needs_and_carrots + carrots_left_to_eat_and_carrots_and_carrots\n\
    \        val needs_left_to_eat_and_needs_and_carrots_and_carrots_and_carrots =\
    \ needs_left_to_eat_and_needs_and_carrots_and_carrots + carrots_left_to_eat_and_carrots_and_carrots_and_carrots\n\
    \        val needs_left_to_eat_and_needs_and_carrots_and_carrots_and_carrots_and_carrots\
    \ = needs_left_to_eat_and_needs_and_carrots_and_carrots_and_carrots + carrots_left_to_eat_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots\n\
    \        val needs_left_to_eat_and_needs_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots\
    \ = needs_left_to_eat_and_needs_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots\n\
    \        val needs_left_to_eat_and_needs_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots\
    \ = needs_left_to_eat_and_needs_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots_and_carrot\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjvpulnpl.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjvpulnpl.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpjvpulnpl.scala:42:55 ------------------------\e[0m\e[0m\n\e[31m42 |\e\
    [0m        \e[33mval\e[0m \e[36mneeds_left_to_eat_and_needs_and_carrots\e[0m =\
    \ (needs_left_to_eat_and_needs + carrots_left_to_eat_and_carrots).toInt\n\e[31m\e\
    [31m   |\e[0m                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Not found: needs_left_to_eat_and_needs\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjvpulnpl.scala:46:114\
    \ -----------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e\
    [36mneeds_left_to_eat_and_needs_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots\e\
    [0m = needs_left_to_eat_and_needs_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: needs_left_to_eat_and_needs_and_carrots_and_carrots_and_carrots_and_carrots_and_carrots_a"
  stdout: ''
  timestamp: 1659804479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number.toInt\n\
    \        val left  = need.toInt\n        val total = hungry + left\n        val\
    \ result = new mutable.ListBuffer[Long]()\n        val carrots = total - remaining\n\
    \        if (carrots > 0) {\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            val carrots = math.min(math.max(math.ceil(carrots\
    \ / 2), 1), 100)\n            \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7bwmcji5.scala:73:0 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7bwmcji5.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7bwmcji5.scala:38:16 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m            \e[33mval\e[0m \e[36mcarrots\e[0m = math.min(math.max(math.ceil(carrots\
    \ / \e[31m2\e[0m), \e[31m1\e[0m), \e[31m100\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7bwmcji5.scala:39:16 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m            \e[33mval\e[0m \e[36mcarrots\e[0m = math.min(math.max(math.ceil(carrots\
    \ / \e[31m2\e[0m), \e[31m1\e[0m), \e[31m100\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7bwmcji5.scala:40:16 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m            \e[33mval\e[0m \e[36mcarrots\e[0m = math.min(math.max(math.ceil(carrots\
    \ / \e[31m2\e[0m), \e[31m1\e[0m), \e[31m100\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m\n\e[31m   |\e"
  stdout: ''
  timestamp: 1659804480
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealList = List(meals.toLong)\n\
    \        val carrotList = List(carrots.toLong)\n        val result = carrotList.zipWithIndex.map\
    \ { case (carrots, index) =>\n            if (index == 0) mealList\n         \
    \   else carrotList.take(index).sum\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7mfsgolb.scala:39:8\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Matchable])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryCarrots = number\
    \ - remaining\n        val hungryCarrotsToEat = need - hungryCarrots\n       \
    \ val hungryCarrotsToEatList = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatListWithRemaining\
    \ = hungryCarrotsToEatList ++ List(remaining.toLong)\n        val hungryCarrotsToEatListWithRemainingList\
    \ = hungryCarrotsToEatListWithRemaining.toList\n        val hungryCarrotsToEatListWithRemainingListWithRemaining\
    \ = hungryCarrotsToEatListWithRemainingList ++ List(remaining.toLong)\n      \
    \  val hungryCarrotsToEatListWithRemainingListWithRemainingList = hungryCarrotsToEatListWithRemainingListWithRemaining.toList\n\
    \        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemaining\
    \ = hungryCarrotsToEatListWithRemainingListWithRemainingList ++ List(remaining.toLong)\n\
    \        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingList\
    \ = hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemaining.toList\n\
    \        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemaining\
    \ = hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingList\
    \ ++ List(remaining.toLong)\n        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemainingList\
    \ = hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemaining.toList\n\
    \        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemainingListWithRemaining\
    \ = hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemainingList\
    \ ++ List(remaining.toLong)\n        val hungr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvji5obbb.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpvji5obbb.scala:44:5 ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val lefts = remaining - needs\n\
    \        val mealsLeft = meals - lefts\n        val leftsLeft = lefts - meals\n\
    \        val mealsLeftLeft = mealsLeft - leftsLeft\n        val leftsLeftLeft\
    \ = leftsLeft - mealsLeft\n        val mealsLeftLeftLeft = mealsLeftLeft - leftsLeftLeft\n\
    \        val leftsLeftLeftLeft = leftsLeftLeft - mealsLeftLeft\n        val mealsLeftLeftLeftLeft\
    \ = mealsLeftLeftLeft - leftsLeftLeftLeft\n        val leftsLeftLeftLeftLeft =\
    \ leftsLeftLeftLeft - mealsLeftLeftLeftLeft\n        val mealsLeftLeftLeftLeftLeft\
    \ = mealsLeftLeftLeftLeft - leftsLeftLeftLeftLeft\n        val leftsLeftLeftLeftLeftLeft\
    \ = leftsLeftLeftLeftLeft - mealsLeftLeftLeftLeftLeft\n        val mealsLeftLeftLeftLeftLeftLeft\
    \ = mealsLeftLeftLeftLeftLeft - leftsLeftLeftLeftLeftLeft\n        val leftsLeftLeftLeftLeftLeftLeft\
    \ = leftsLeftLeftLeftLeftLeft - mealsLeftLeftLeftLeftLeftLeft\n        val mealsLeftLeftLeftLeftLeftLeftLeft\
    \ = mealsLeftLeftLeftLeftLeftLeft - leftsLeftLeftLeftLeftLeftLeft\n        val\
    \ leftsLeftLeftLeftLeftLeftLeftLeft = leftsLeftLeftLeftLeftLeftLeft - mealsLeftLeftLeftLeftLeftLeftLeft\n\
    \        val mealsLeftLeftLeftLeftLeftLeftLeftLeft = mealsLeftLeftLeftLeftLeftLeftLeftLeft\
    \ - leftsLeftLeftLeftLeftLeftLeftLeft\n        val leftsLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = leftsLeftLeftLeftLeftLeftLeftLeft - mealsLeftLeftLeftLeftLeftLeftLeftLeftLeft\n\
    \        val mealsLeftLeftLeftLeftLeftLeftLeftLeftLeft = mealsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft\
    \ - leftsLeftLeftLeftLeftLeftLeftLeftLeft\n        val leftsLeftLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = leftsLeftLeftLeftLeftLeftLeftLeftLeft - mealsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft\n\
    \        val mealsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft = mealsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft\
    \ - leftsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft\n        val leftsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = leftsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft - meals\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph_c3tel6.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph_c3tel6.scala:50:52\
    \ ---------------------------\e[0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeftLeftLeftLeftLeftLeftLeftLeft\e[0m = mealsLeftLeftLeftLeftLeftLeftLeftLeft\
    \ - leftsLeftLeftLeftLeftLeftLeftLeft\n\e[31m\e[31m   |\e[0m                 \
    \                                   ^\e[0m\n\e[31m   |\e[0m        Recursive \e\
    [33mvalue\e[0m \e[35mmealsLeftLeftLeftLeftLeftLeftLeftLeft\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph_c3tel6.scala:54:60\
    \ ------------------------\e[0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e\
    [36mmealsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft\e[0m = mealsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft\
    \ - leftsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft\n\e[31m\e[31m   |\e[0m     \
    \                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Not found: mealsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmph_c3tel6.scala:55:60\
    \ ---------------------------\e[0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m\
    \ \e[36mleftsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft\e[0m = leftsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft\
    \ - meals\n\e[31m\e[31m   |\e[0m                                             \
    \               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mleftsLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m--"
  stdout: ''
  timestamp: 1659804480
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryCarrots = number\
    \ - remaining\n        val hungryCarrotsToEat = need - hungryCarrots\n       \
    \ val hungryCarrotsToEatList = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatListWithRemaining\
    \ = hungryCarrotsToEatList ++ List(remaining.toLong)\n        val hungryCarrotsToEatListWithRemainingList\
    \ = hungryCarrotsToEatListWithRemaining ++ List(hungryCarrots)\n        val hungryCarrotsToEatListWithRemainingListWithRemaining\
    \ = hungryCarrotsToEatListWithRemainingList ++ List(remaining.toLong)\n      \
    \  val hungryCarrotsToEatListWithRemainingListWithRemainingList = hungryCarrotsToEatListWithRemainingListWithRemaining\
    \ ++ List(hungryCarrots)\n        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemaining\
    \ = hungryCarrotsToEatListWithRemainingListWithRemainingList ++ List(remaining.toLong)\n\
    \        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingList\
    \ = hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemaining ++ List(hungryCarrots)\n\
    \        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemaining\
    \ = hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingList\
    \ ++ List(remaining.toLong)\n        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemainingList\
    \ = hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemaining\
    \ ++ List(hungryCarrots)\n        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemainingListWithRemaining\
    \ = hungryCarrotsToEatListWithRemain\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgjj62qee.scala:42:118 -----------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemainingListWithRemaining\e\
    [0m = hungryCarrotsToEatListWithRemain\n\e[31m\e[31m   |\e[0m                \
    \                                                                            \
    \                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                             Not found: hungryCarrotsToEatListWithRemain\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgjj62qee.scala:43:5\
    \ ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804480
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = List(carrots_left, needs_left)\n        meals\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpodv4qxjn.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804477
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val result = ListBuffer[Long]()\n        val carrotLeft = carrots - needToEat\n\
    \        val needLeft = needToEat - remainingToEat\n        val needToEatLeft\
    \ = needLeft + needToEat\n        val remainingToEatLeft = remainingToEat + remainingToEat\n\
    \        val carrotLeftLeft = carrotLeft - needToEatLeft\n        val needLeftLeft\
    \ = needToEatLeft - remainingToEatLeft\n        val needToEatLeftLeft = needLeftLeft\
    \ + needToEatLeft\n        val remainingToEatLeftLeft = remainingToEatLeft + remainingToEatLeft\n\
    \        result ++= List(\n            carrotLeftLeft,\n            needToEatLeftLeft,\n\
    \            remainingToEatLeftLeft\n        )\n        result ++= List(\n   \
    \         carrotLeft,\n            needToEatLeft,\n            remainingToEatLeft\n\
    \        )\n        result ++= List(\n            carrotLeft,\n            needToEatLeft,\n\
    \            remainingToEatLeft\n        )\n        result ++= List(\n       \
    \     carrotLeft,\n            needToEatLeft,\n            remainingToEatLeft\n\
    \        )\n        result ++= List(\n            carrotLeft,\n            needToEatLeft,\n\
    \            remainingToEatLeft\n        )\n        result ++= List(\n       \
    \     carrotLeft,\n            needToEatLeft,\n            remainingToEatLeft\n\
    \        )\n        result ++= List(\n            carrotLeft,\n            needToEatLeft,\n\
    \            remainingToEatLeft\n        )\n        result ++= List(\n       \
    \     carrotLeft,\n            needToEatLeft,\n            remainingToEatLeft\n\
    \        )\n        result ++= List(\n            carrotLeft,\n            needToEatLeft,\n\
    \            remainingToEatLeft\n        )\n        result ++= List(\n       \
    \     carrotLeft,\n            needToEatLeft,\n            remainingToEatLeft\n\
    \        )\n        result ++= List(\n            carrotLeft,\n            needToEatLeft,\n\
    \            remainingToEatLeft\n        )\n        result ++= List(\n       \
    \     carrot\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzq30jrac.scala:100:4 ---------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzq30jrac.scala:99:12\
    \ ------------------------\e[0m\e[0m\n\e[31m99 |\e[0m            carrot\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found: carrot\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = needs - carrots\n        val carrots_left_to_eat\
    \ = carrots_left - needs_left\n        val needs_left_to_eat = needs_left - carrots_left\n\
    \        val carrots_left_to_eat2 = carrots_left_to_eat * carrots_left_to_eat\n\
    \        val needs_left_to_eat2 = needs_left_to_eat * needs_left_to_eat\n    \
    \    val carrots_left_to_eat3 = carrots_left_to_eat2 * carrots_left_to_eat\n \
    \       val needs_left_to_eat3 = needs_left_to_eat2 * needs_left_to_eat\n    \
    \    val carrots_left_to_eat4 = carrots_left_to_eat3 * carrots_left_to_eat\n \
    \       val needs_left_to_eat4 = needs_left_to_eat3 * needs_left_to_eat\n    \
    \    val carrots_left_to_eat5 = carrots_left_to_eat4 * carrots_left_to_eat\n \
    \       val needs_left_to_eat5 = needs_left_to_eat4 * needs_left_to_eat\n    \
    \    val carrots_left_to_eat6 = carrots_left_to_eat5 * carrots_left_to_eat\n \
    \       val needs_left_to_eat6 = needs_left_to_eat5 * needs_left_to_eat\n    \
    \    val carrots_left_to_eat7 = carrots_left_to_eat6 * carrots_left_to_eat\n \
    \       val needs_left_to_eat7 = needs_left_to_eat6 * needs_left_to_eat\n    \
    \    val carrots_left_to_eat8 = carrots_left_to_eat7 * carrots_left_to_eat\n \
    \       val needs_left_to_eat8 = needs_left_to_eat7 * needs_left_to_eat\n    \
    \    val carrots_left_to_eat9 = carrots_left_to_eat8 * carrots_left_to_eat\n \
    \       val needs_left_to_eat9 = needs_left_to_eat8 * needs_left_to_eat\n    \
    \    val carrots_left_to_eat10 = carrots_left_to_eat9 * carrots_left_to_eat\n\
    \        val needs_left_to_eat10 = needs_left_to_eat9 * needs_left_to_eat\n  \
    \      val carrots_left_to_eat11 = carrots_left_to_eat10 * carrots_left_to_eat\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9eh27ulx.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9eh27ulx.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp9eh27ulx.scala:59:5 ---------------------\e[0m\e[0m\n\e[31m59\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804480
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        var carrots_left = remaining\n\
    \        while(carrots_left > 0) {\n            carrots_left -= 1\n          \
    \  list += carrots_left\n        }\n        list += carrots - list.last\n    \
    \    list += carrots - list.last\n        list += carrots - list.last\n      \
    \  list += carrots - list.last\n        list += carrots - list.last\n        list\
    \ += carrots - list.last\n        list += carrots - list.last\n        list +=\
    \ carrots - list.last\n        list += carrots - list.last\n        list += carrots\
    \ - list.last\n        list += carrots - list.last\n        list += carrots -\
    \ list.last\n        list += carrots - list.last\n        list += carrots - list.last\n\
    \        list += carrots - list.last\n        list += carrots - list.last\n  \
    \      list += carrots - list.last\n        list += carrots - list.last\n    \
    \    list += carrots - list.last\n        list += carrots - list.last\n      \
    \  list += carrots - list.last\n        list += carrots - list.last\n        list\
    \ += carrots - list.last\n        list += carrots - list.last\n        list +=\
    \ carrots - list.last\n        list += carrots - list.last\n        list += carrots\
    \ - list.last\n        list += carrots - list.last\n        list += carrots -\
    \ list.last\n        list += carrots - list.last\n        list += carrots - list.last\n\
    \        list += carrots - list.last\n        list += carrots - list.last\n  \
    \      list += carrots - list.last\n        list += carrots - list.last\n    \
    \    list += carrots - list.last\n        list += carrots - list.last\n      \
    \  list += carrots - list.last\n        list += carrots - list.last\n        list\
    \ += carrots - list.last\n        list += carrots - list.last\n        list +=\
    \ carrots - list.last\n        list += carrots - list.last\n        list += carrots\
    \ - list.last\n        list += carrots - list.last\n        list += carrots -\
    \ list.last\n        list += carrots - list.last\n        list += carrots - list.last\n\
    \        list += carrots - list.last\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpdiaqa4wv.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdiaqa4wv.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        val carrots_left = remaining\
    \ - carrots\n        val carrots_left_after_meals = carrots_left - needs\n   \
    \     val carrots_left_after_meals_after_meals = carrots_left_after_meals - carrots\n\
    \        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals\
    \ - carrots\n        val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - carrots\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals - carrots\n \
    \       val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ carrots\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots\n        val carrots_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp23k7pp_q.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp23k7pp_q.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp23k7pp_q.scala:34:19 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp23k7pp_q.scala:43:123 --------------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots\n\e[31m\e[31m   |\e[0m                                           \
    \                                                                            \
    \    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m\
    \  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp23k7pp_q.scala:44:135 --------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_afte"
  stdout: ''
  timestamp: 1659804481
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = meals > 0\n      \
    \  val hungryCarrots = if (hungry) meals else 0\n        val hungryNeeds = if\
    \ (hungry) needs else 0\n        val hungryRemaining = if (hungry) remaining else\
    \ 0\n        val hungryTotal = if (hungry) carrots else 0\n        val hungryTotalNeeds\
    \ = if (hungry) needs else 0\n        val hungryTotalRemaining = if (hungry) remaining\
    \ else 0\n        val hungryTotalNeedsRemaining = if (hungry) needs + remaining\
    \ else 0\n        val hungryTotalNeedsRemainingCarrots = if (hungry) needs + remaining\
    \ + carrots else 0\n        val hungryTotalNeedsRemainingCarrots = if (hungry)\
    \ needs + remaining + carrots else 0\n        val hungryTotalNeedsRemainingCarrots\
    \ = if (hungry) needs + remaining + carrots else 0\n        val hungryTotalNeedsRemainingCarrots\
    \ = if (hungry) needs + remaining + carrots else 0\n        val hungryTotalNeedsRemainingCarrots\
    \ = if (hungry) needs + remaining + carrots else 0\n        val hungryTotalNeedsRemainingCarrots\
    \ = if (hungry) needs + remaining + carrots else 0\n        val hungryTotalNeedsRemainingCarrots\
    \ = if (hungry) needs + remaining + carrots else 0\n        val hungryTotalNeedsRemainingCarrots\
    \ = if (hungry) needs + remaining + carrots else 0\n        val hungryTotalNeedsRemainingCarrots\
    \ = if (hungry) needs + remaining + carrots else 0\n        val hungryTotalNeedsRemainingCarrots\
    \ = if (hungry) needs + remaining + carrots else 0\n        val hungryTotalNeedsRemainingCarrots\
    \ = if (hungry) needs + remaining + carrots else 0\n        val hungryTotalNeedsRemainingCarrots\
    \ = if (hungry) needs + remaining + carrots else 0\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppsm4tja1.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mhungryTotalNeedsRemainingCarrots\e\
    [0m = \e[33mif\e[0m (hungry) needs + remaining + carrots \e[33melse\e[0m \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryTotalNeedsRemainingCarrots is already defined as \e\
    [33mvalue\e[0m \e[35mhungryTotalNeedsRemainingCarrots\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppsm4tja1.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryTotalNeedsRemainingCarrots\e[0m = \e[33mif\e[0m (hungry) needs +\
    \ remaining + carrots \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryTotalNeedsRemainingCarrots is already defined as \e\
    [33mvalue\e[0m \e[35mhungryTotalNeedsRemainingCarrots\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppsm4tja1.scala:46:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryTotalNeedsRemainingCarrots\e[0m = \e[33mif\e[0m (hungry) needs +\
    \ remaining + carrots \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryTotalNeedsRemainingCarrots is already defined as \e\
    [33mvalue\e[0m \e[35mhungryTotalNeedsRemainingCarrots\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppsm4tja1.scala:47:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryTotalNeedsRemainingCarrots\e[0m = \e[33mif\e[0m (hungry) needs +\
    \ remaining + "
  stdout: ''
  timestamp: 1659804480
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        val carrots_left = remaining\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.toInt\n\
    \        val carrots_left = carrots_left.toInt\n        val carrots_left = carrots_left.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzzec_lq7.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left\e[0m = carrots_left.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mcarrots_left is already defined as \e[33mvalue\e[0m \e[35mcarrots_left\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzzec_lq7.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left\e[0m = carrots_left.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mcarrots_left is already defined as \e[33mvalue\e[0m \e[35mcarrots_left\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzzec_lq7.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left\e[0m = carrots_left.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mcarrots_left is already defined as \e[33mvalue\e[0m \e[35mcarrots_left\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzzec_lq7.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left\e[0m = carrots_left.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mcarrots_left is already defined as \e[33mvalue\e[0m \e[35mcarrots_left\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzzec_lq7.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left\e[0m = carrots_left.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mcar"
  stdout: ''
  timestamp: 1659804483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val carrots_left_to_eat\
    \ = (carrots_left * needs).toInt\n        val carrots_to_eat = (carrots_left_to_eat\
    \ * needs).toInt\n        val carrots_to_eat_left = carrots_to_eat - carrots_left\n\
    \        val carrots_to_eat_left_to_eat = (carrots_to_eat_left * needs).toInt\n\
    \        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat - carrots_left_to_eat\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left\
    \ * needs).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat\
    \ - carrots_left_to_eat_left\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left * needs).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_left_to_eat_left_to_eat\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat =\
    \ (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left * needs).toInt\n  \
    \      val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_left_to_eat_left_to_eat_left\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left * needs).toInt\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpv3fabkve.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv3fabkve.scala:47:94\
    \ ------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\e\
    [0m = carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m  Not found: carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv3fabkve.scala:48:5\
    \ ---------------------\e[0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val remaining = remaining - carrots\n        if (remaining <= 0) {\n   \
    \         List(number.toLong, remaining.toLong)\n        } else {\n          \
    \  val needs = needs - carrots\n            val needs = needs.toInt\n        \
    \    val remaining = remaining - carrots\n            val remaining = remaining\
    \ - needs\n            val needs = needs.toInt\n            val needs = needs.toLong\n\
    \            val remaining = remaining.toLong\n            val remaining = remaining\
    \ - needs\n            val needs = needs.toLong\n            val needs = needs.toInt\n\
    \            val needs = needs.toLong\n            val remaining = remaining.toLong\n\
    \            val remaining = remaining - needs\n            val needs = needs.toLong\n\
    \            val needs = needs.toInt\n            val needs = needs.toLong\n \
    \           val remaining = remaining.toLong\n            val remaining = remaining\
    \ - needs\n            val needs = needs.toLong\n            val needs = needs.toInt\n\
    \            val needs = needs.toLong\n            val remaining = remaining.toLong\n\
    \            val remaining = remaining - needs\n            val needs = needs.toLong\n\
    \            val needs = needs.toInt\n            val needs = needs.toLong\n \
    \           val remaining = remaining.toLong\n            val remaining = remaining\
    \ - needs\n            val needs = needs.toLong\n            val needs = needs.toInt\n\
    \            val needs = needs.toLong\n            val remaining = remaining.toLong\n\
    \            val remaining = remaining - needs\n            val needs = needs.toLong\n\
    \            val needs = needs.toInt\n            val needs = needs.toLong\n \
    \           val remaining = remaining.toLong\n            val remaining = remaining\
    \ - needs\n            val needs = needs.toLong\n            val needs = needs.toInt\n\
    \            val needs = needs.toLong\n            val remaining = remaining.toLong\n\
    \            val remaining = remaining - needs\n            val needs = needs.toLong\n\
    \            val needs = needs.toInt\n            val needs = needs.toLong\n \
    \           val remaining = remaining.toLong\n            val remaining = remaining\
    \ - needs\n            val needs = needs.toLong\n            val needs = needs.toInt\n\
    \            val needs = needs.toLong\n            val remaining = remaining.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm5xhkwcu.scala:90:4 ----------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpm5xhkwcu.scala:101:0 ---------------------------\e[0m\e[0m\n\e[31m101\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm5xhkwcu.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mremaining is already defined as \e[33mvalue\e[0m \e[35mremaining\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpm5xhkwcu.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm5xhkwcu.scala:39:16 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e[0m \e[36mneeds\e[0m = needs.toInt\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mneeds\
    \ is already defined as \e[33mvalue\e[0m \e[35mneeds\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm5xhkwcu.scala:41:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e\
    [0m \e[36mremaining\e[0m = remaining - needs\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mremaining is already\
    \ defined as \e[33mvalue\e[0m \e[35mremaining\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group o"
  stdout: ''
  timestamp: 1659804487
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        val needList = List(need.toLong)\n\
    \        val remainingList = List(remaining.toLong)\n        val hungryNeedList\
    \ = hungryList.zip(needList).filter(_._1 > 0).map(_._2)\n        val hungryRemainingList\
    \ = hungryList.zip(remainingList).filter(_._1 > 0).map(_._2)\n        val hungryNeedRemainingList\
    \ = hungryNeedList.zip(hungryRemainingList).filter(_._1 > 0).map(_._2)\n     \
    \   val hungryNeedRemainingList2 = hungryNeedRemainingList.filter(_._2 > 0).map(_._2)\n\
    \        val hungryNeedRemainingList3 = hungryNeedRemainingList2.filter(_._2 >\
    \ 0).map(_._2)\n        val hungryNeedRemainingList4 = hungryNeedRemainingList3.filter(_._2\
    \ > 0).map(_._2)\n        val hungryNeedRemainingList5 = hungryNeedRemainingList4.filter(_._2\
    \ > 0).map(_._2)\n        val hungryNeedRemainingList6 = hungryNeedRemainingList5.filter(_._2\
    \ > 0).map(_._2)\n        val hungryNeedRemainingList7 = hungryNeedRemainingList6.filter(_._2\
    \ > 0).map(_._2)\n        val hungryNeedRemainingList8 = hungryNeedRemainingList7.filter(_._2\
    \ > 0).map(_._2)\n        val hungryNeedRemainingList9 = hungryNeedRemainingList8.filter(_._2\
    \ > 0).map(_._2)\n        val hungryNeedRemainingList10 = hungryNeedRemainingList9.filter(_._2\
    \ > 0).map(_._2)\n        val hungryNeedRemainingList11 = hungryNeedRemainingList10.filter(_._2\
    \ > 0).map(_._2)\n        val hungryNeedRemainingList12 = hungryNeedRemainingList11.filter(_._2\
    \ > 0).map(_._2)\n        val hungryNeedRemainingList13 = hungryNeedRemainingList12.filter(_._2\
    \ > 0).map(_._2)\n        val h\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp06undmlc.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp06undmlc.scala:38:72\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryNeedRemainingList2\e[0m = hungryNeedRemainingList.filter(_._2 > \e[31m0\e\
    [0m).map(_._2)\n\e[31m\e[31m   |\e[0m                                        \
    \                              ^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                    value _2 is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp06undmlc.scala:38:86 ------------------------\e[0m\e[0m\n\
    \e[31m38 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedRemainingList2\e[0m = hungryNeedRemainingList.filter(_._2\
    \ > \e[31m0\e[0m).map(_._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                                         ^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                        value _2 is not a member of Long\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp06undmlc.scala:39:73 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedRemainingList3\e\
    [0m = hungryNeedRemainingList2.filter(_._2 > \e[31m0\e[0m).map(_._2)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \       ^^^^\e[0m\n\e[31m   |\e[0mvalue _2 is not a member of Nothing, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mThe\
    \ following import might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import\
    \ concurrent.duration.durationToPair\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp06undmlc.scala:39:87 ------------------------\e[0m\e[0m\n\
    \e[31m39 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedRemainingList3\e[0m = hungryNeedRemainingList2.filter(_._2\
    \ > \e[31m0\e[0m).map(_._2)\n\e[31m\e[31m   |\e[0m                           \
    \                                                          ^^^^\e[0m\n\e[31m \
    \  |\e[0mvalue _2 is not a member of Nothing, but could be made available as an\
    \ extensi"
  stdout: ''
  timestamp: 1659804491
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new ListBuffer[Long]()\n        val carrots_left\
    \ = carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat: Long = carrots_left / needs_left\n        val carrots_left_to_eat_2\
    \ = carrots_left % needs_left\n        val needs_left_to_eat: Long = needs_left\
    \ / carrots_left_to_eat\n        val needs_left_to_eat_2 = needs_left % carrots_left_to_eat\n\
    \        val needs_left_to_eat_3 = needs_left_to_eat / carrots_left_to_eat_2\n\
    \        val needs_left_to_eat_4 = needs_left_to_eat % carrots_left_to_eat_2\n\
    \        val needs_left_to_eat_5 = needs_left_to_eat_2 / carrots_left_to_eat_4\n\
    \        val needs_left_to_eat_6 = needs_left_to_eat_2 % carrots_left_to_eat_4\n\
    \        val needs_left_to_eat_7 = needs_left_to_eat_4 / carrots_left_to_eat_6\n\
    \        val needs_left_to_eat_8 = needs_left_to_eat_4 % carrots_left_to_eat_6\n\
    \        val needs_left_to_eat_9 = needs_left_to_eat_6 / carrots_left_to_eat_8\n\
    \        val needs_left_to_eat_10 = needs_left_to_eat_6 % carrots_left_to_eat_8\n\
    \        val needs_left_to_eat_11 = needs_left_to_eat_8 / carrots_left_to_eat_10\n\
    \        val needs_left_to_eat_12 = needs_left_to_eat_8 % carrots_left_to_eat_10\n\
    \        val needs_left_to_eat_13 = needs_left_to_eat_10 / carrots_left_to_eat_12\n\
    \        val needs_left_to_eat_14 = needs_left_to_eat_10 % carrots_left_to_eat_12\n\
    \        val needs_left_to_eat_15 = needs_left_to_eat_12 / carrots_left_to_eat_14\n\
    \        val needs_left_to_eat_16 = needs_left_to_eat_12 % carrots_left_to_eat_14\n\
    \        val needs_left_to_e\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzhmr6lbt.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzhmr6lbt.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpzhmr6lbt.scala:34:33 --------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e\
    [0m] = \e[33mnew\e[0m \e[35mListBuffer\e[0m[\e[35mLong\e[0m]()\n\e[31m\e[31m \
    \  |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m                     Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzhmr6lbt.scala:56:5 ---------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_to_eat = carrots_left_to_eat\
    \ * needs_left_to_eat\n        val needs_to_eat = needs_left_to_eat * carrots_left_to_eat\n\
    \        val carrots_to_eat_left = carrots_to_eat - carrots_left\n        val\
    \ needs_to_eat_left = needs_to_eat - needs_left\n        val carrots_to_eat_left_to_eat\
    \ = (carrots_to_eat_left / needs_to_eat_left).toInt\n        val needs_to_eat_left_to_eat\
    \ = (needs_to_eat_left / carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat * needs_to_eat_left_to_eat\n        val needs_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat * carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left / needs_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left\
    \ / carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat * needs_to_eat_left_to_eat_left\n \
    \       val needs_to_eat_left_to_eat_left_to_eat_left = needs_to_eat_left_to_eat_left\
    \ * carrots_to_eat_left_to_eat_left\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat / needs_to_eat_left_to_eat_left_to_eat).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat_left = needs_to_eat_left_to_eat_left\
    \ * carrots_to_eat_left_to_eat_left_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpf7nn0t7j.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mneeds_to_eat_left_to_eat_left_to_eat_left\e\
    [0m = needs_to_eat_left_to_eat_left * carrots_to_eat_left_to_eat_left_\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_to_eat_left_to_eat_left_to_eat_left is already defined\
    \ as \e[33mvalue\e[0m \e[35mneeds_to_eat_left_to_eat_left_to_eat_left\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpf7nn0t7j.scala:33:24 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf7nn0t7j.scala:34:25 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf7nn0t7j.scala:53:5\
    \ ---------------------\e[0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_to_eat = (carrots_left - needs_left).toInt\n\
    \        val carrots_left_to_eat_left = carrots_left_to_eat - carrots_left\n \
    \       val carrots_left_to_eat_left_to_eat = (carrots_left_to_eat_left - carrots_left).toInt\n\
    \        val carrots_left_to_eat_left_to_eat_left = carrots_left_to_eat_left_to_eat\
    \ - carrots_left\n        val carrots_left_to_eat_left_to_eat_left_to_eat = (carrots_left_to_eat_left_to_eat_left\
    \ - carrots_left).toInt\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_left_to_eat_left_to_eat_left_to_eat - carrots_left\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left_to_eat_left_to_eat_left - carrots_left).toInt\n\
    \        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left = carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ - carrots_left\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left - carrots_left).toInt\n\
    \        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat - carrots_left\n\
    \        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ - carrots_left).toInt\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_to_eat_left_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp96vgckip.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp96vgckip.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp96vgckip.scala:48:5 ---------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804487
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - hungry\n        val hungryRemaining2\
    \ = hungryRemaining / 2\n        val hungryRemaining3 = hungryRemaining2 / 2\n\
    \        val hungryRemaining4 = hungryRemaining3 / 2\n        val hungryRemaining5\
    \ = hungryRemaining4 / 2\n        val hungryRemaining6 = hungryRemaining5 / 2\n\
    \        val hungryRemaining7 = hungryRemaining6 / 2\n        val hungryRemaining8\
    \ = hungryRemaining7 / 2\n        val hungryRemaining9 = hungryRemaining8 / 2\n\
    \        val hungryRemaining10 = hungryRemaining9 / 2\n        val hungryRemaining11\
    \ = hungryRemaining10 / 2\n        val hungryRemaining12 = hungryRemaining11 /\
    \ 2\n        val hungryRemaining13 = hungryRemaining12 / 2\n        val hungryRemaining14\
    \ = hungryRemaining13 / 2\n        val hungryRemaining15 = hungryRemaining14 /\
    \ 2\n        val hungryRemaining16 = hungryRemaining15 / 2\n        val hungryRemaining17\
    \ = hungryRemaining16 / 2\n        val hungryRemaining18 = hungryRemaining17 /\
    \ 2\n        val hungryRemaining19 = hungryRemaining18 / 2\n        val hungryRemaining20\
    \ = hungryRemaining19 / 2\n        val hungryRemaining21 = hungryRemaining20 /\
    \ 2\n        val hungryRemaining22 = hungryRemaining21 / 2\n        val hungryRemaining23\
    \ = hungryRemaining22 / 2\n        val hungryRemaining24 = hungryRemaining23 /\
    \ 2\n        val hungryRemaining25 = hungryRemaining24 / 2\n        val hungryRemaining26\
    \ = hungryRemaining25 / 2\n        val hungryRemaining27 = hungry\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzk9bn22k.scala:59:5\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val numEaten = number.toInt\n\
    \        val numNeed = need.toInt\n        val numRemaining = remaining.toInt\n\
    \        val numEatenRemaining = numEaten - numNeed\n        val numEatenRemaining2\
    \ = numEatenRemaining.toInt\n        val numEatenRemaining3 = numEatenRemaining2.toInt\n\
    \        val numEatenRemaining4 = numEatenRemaining3.toInt\n        val numEatenRemaining5\
    \ = numEatenRemaining4.toInt\n        val numEatenRemaining6 = numEatenRemaining5.toInt\n\
    \        val numEatenRemaining7 = numEatenRemaining6.toInt\n        val numEatenRemaining8\
    \ = numEatenRemaining7.toInt\n        val numEatenRemaining9 = numEatenRemaining8.toInt\n\
    \        val numEatenRemaining10 = numEatenRemaining9.toInt\n        val numEatenRemaining11\
    \ = numEatenRemaining10.toInt\n        val numEatenRemaining12 = numEatenRemaining11.toInt\n\
    \        val numEatenRemaining13 = numEatenRemaining12.toInt\n        val numEatenRemaining14\
    \ = numEatenRemaining13.toInt\n        val numEatenRemaining15 = numEatenRemaining14.toInt\n\
    \        val numEatenRemaining16 = numEatenRemaining15.toInt\n        val numEatenRemaining17\
    \ = numEatenRemaining16.toInt\n        val numEatenRemaining18 = numEatenRemaining17.toInt\n\
    \        val numEatenRemaining19 = numEatenRemaining18.toInt\n        val numEatenRemaining20\
    \ = numEatenRemaining19.toInt\n        val numEatenRemaining21 = numEatenRemaining20.toInt\n\
    \        val numEatenRemaining22 = numEatenRemaining21.toInt\n        val numEatenRemaining23\
    \ = numEatenRemaining22.toInt\n        val numEatenRemaining24 = numEatenRemaining23.toInt\n\
    \        val numEatenRemaining25 = numEatenRemaining24.to\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E051] Reference Error: /tmp/tmpckvinqw_.scala:58:54 ------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mnumEatenRemaining25\e[0m\
    \ = numEatenRemaining24.to\n\e[31m\e[31m   |\e[0m                            \
    \      ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mto\e[0m in \e[33mclass\e[0m \e[35mRichInt\e\
    [0m with types\n\e[31m   |\e[0m (end: Int, step: Int): scala.collection.immutable.Range.Inclusive\n\
    \e[31m   |\e[0m (end: Int): scala.collection.immutable.Range.Inclusive\n\e[31m\
    \   |\e[0mboth match expected type <?>\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpckvinqw_.scala:59:5 ---------------------\e[0m\e\
    [0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        var carrots_left =\
    \ remaining\n        var carrots_eaten = 0\n        while (carrots_left > 0 &&\
    \ carrots_eaten < needs) {\n            carrots_left -= 1\n            carrots_eaten\
    \ += 1\n        }\n        result += carrots_eaten\n        result += carrots_left\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx18ilgrl.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx18ilgrl.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804485
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals\
    \ = carrots_left % needs_left\n        val carrots_left_after_meals_after_meals\
    \ = carrots_left_after_meals / meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals % meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals / meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals % meals\n   \
    \     val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals /\
    \ meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ % meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ / meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6izghrl5.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6izghrl5.scala:44:123\
    \ --------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ / meals\n\e[31m\e[31m   |\e[0m                                             \
    \                                                                            \
    \  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m \
    \ carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp6izghrl5.scala:45:147 -----------------------\e[0m\e[0m\n\e[31m45 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m lo"
  stdout: ''
  timestamp: 1659804490
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        if (remaining <= 0) {\n\
    \            List(number.toLong)\n        } else {\n            val carrots =\
    \ math.min(remaining, 1000)\n            val need = math.min(need, 1000)\n   \
    \         val remaining = math.min(remaining, 1000)\n            val list = eat(number,\
    \ need, remaining)\n            val newList = list :+ carrots\n            newList\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnlhfdvvz.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnlhfdvvz.scala:38:37\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            \e[33mval\e\
    [0m \e[36mremaining\e[0m = math.min(remaining, \e[31m1000\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m       \
    \                             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnlhfdvvz.scala:37:32\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36mneed\e[0m = math.min(need, \e[31m1000\e[0m)\n\e[31m\e[31m   |\e[0m \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \          Recursive \e[33mvalue\e[0m \e[35mneed\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - need\n        val hungryEaten = if\
    \ (hungryRemaining > 0) hungryRemaining else 0\n        val hungryEatenList =\
    \ List(hungryEaten)\n        val hungryEatenList2 = List(hungryEaten, hungryEaten)\n\
    \        val hungryEatenList3 = List(hungryEaten, hungryEaten, hungryEaten)\n\
    \        val hungryEatenList4 = List(hungryEaten, hungryEaten, hungryEaten, hungryEaten)\n\
    \        val hungryEatenList5 = List(hungryEaten, hungryEaten, hungryEaten, hungryEaten,\
    \ hungryEaten)\n        val hungryEatenList6 = List(hungryEaten, hungryEaten,\
    \ hungryEaten, hungryEaten, hungryEaten, hungryEaten, hungryEaten)\n        val\
    \ hungryEatenList7 = List(hungryEaten, hungryEaten, hungryEaten, hungryEaten,\
    \ hungryEaten, hungryEaten, hungryEaten, hungryEaten, hungryEaten)\n        val\
    \ hungryEatenList8 = List(hungryEaten, hungryEaten, hungryEaten, hungryEaten,\
    \ hungryEaten, hungryEaten, hungryEaten, hungryEaten, hungryEaten, hungryEaten,\
    \ hungryEaten)\n        val hungryEatenList9 = List(hungryEaten, hungryEaten,\
    \ hungryEaten, hungryEaten, hungryEaten, hungryEaten, hungr\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv_q0qf8i.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv_q0qf8i.scala:42:114\
    \ -----------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryEatenList9\e[0m = List(hungryEaten, hungryEaten, hungryEaten, hungryEaten,\
    \ hungryEaten, hungryEaten, hungr\n\e[31m\e[31m   |\e[0m                     \
    \                                                                            \
    \                 ^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \                        Not found: hungr\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpv_q0qf8i.scala:43:5 ---------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804489
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        var carrots_left = remaining\n\
    \        while (carrots_left > 0 && carrots > 0) {\n            carrots_left -=\
    \ 1\n            carrots -= 1\n            list += carrots_left\n        }\n \
    \       list += carrots\n        list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpeqgxfpj8.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpeqgxfpj8.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeqgxfpj8.scala:38:20\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m            carrots -= \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value -= is not a member of Int - did you mean carrots.!=?\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659804490
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val carrots_needed = needs - carrots\n        val\
    \ carrots_left_needed = carrots_left - carrots_needed\n        val carrots_left_needed_to_eat\
    \ = carrots_needed - carrots_left\n        val carrots_left_needed_to_eat2 = carrots_left_needed\
    \ - carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat3 = carrots_left_needed_to_eat2\
    \ - carrots_left_needed_to_eat\n        val carrots_left_needed_to_eat4 = carrots_left_needed_to_eat3\
    \ - carrots_left_needed_to_eat3\n        val carrots_left_needed_to_eat5 = carrots_left_needed_to_eat4\
    \ - carrots_left_needed_to_eat4\n        val carrots_left_needed_to_eat6 = carrots_left_needed_to_eat5\
    \ - carrots_left_needed_to_eat5\n        val carrots_left_needed_to_eat7 = carrots_left_needed_to_eat6\
    \ - carrots_left_needed_to_eat6\n        val carrots_left_needed_to_eat8 = carrots_left_needed_to_eat7\
    \ - carrots_left_needed_to_eat7\n        val carrots_left_needed_to_eat9 = carrots_left_needed_to_eat8\
    \ - carrots_left_needed_to_eat8\n        val carrots_left_needed_to_eat10 = carrots_left_needed_to_eat9\
    \ - carrots_left_needed_to_eat9\n        val carrots_left_needed_to_eat11 = carrots_left_needed_to_eat10\
    \ - carrots_left_needed_to_eat10\n        val carrots_left_needed_to_eat12 = carrots_left_needed_to_eat11\
    \ - carrots_left_needed_to_eat11\n        val carrots_left_needed_to_eat13 = carrots_left_needed_to_eat12\
    \ - carrots_left_needed_to_eat12\n        val carrots_left_needed_to_eat14 = carrots_left_needed_to_eat13\
    \ - carrots_left_needed_to_eat13\n        val carrots_left_needed_to_eat15 = car\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5v_infmw.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5v_infmw.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp5v_infmw.scala:52:43 ------------------------\e[0m\e[0m\n\e[31m52 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrots_left_needed_to_eat15\e[0m = car\n\e[31m\e\
    [31m   |\e[0m                                           ^^^\e[0m\n\e[31m   |\e\
    [0m                                           Not found: car\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5v_infmw.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804490
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - need\n        val hungryRemainingInt\
    \ = hungryRemaining.toInt\n        val hungryRemainingLong = hungryRemaining.toLong\n\
    \        val hungryRemainingDouble = hungryRemaining.toDouble\n        val hungryRemainingFloat\
    \ = hungryRemaining.toFloat\n        val hungryRemainingBigDecimal = hungryRemaining.toBigDecimal\n\
    \        val hungryRemainingBigInt = hungryRemaining.toBigInt\n        val hungryRemainingInt\
    \ = hungryRemaining.toInt\n        val hungryRemainingLong = hungryRemaining.toLong\n\
    \        val hungryRemainingDouble = hungryRemaining.toDouble\n        val hungryRemainingFloat\
    \ = hungryRemaining.toFloat\n        val hungryRemainingBigDecimal = hungryRemaining.toBigDecimal\n\
    \        val hungryRemainingBigInt = hungryRemaining.toBigInt\n        val hungryRemainingInt\
    \ = hungryRemaining.toInt\n        val hungryRemainingLong = hungryRemaining.toLong\n\
    \        val hungryRemainingDouble = hungryRemaining.toDouble\n        val hungryRemainingFloat\
    \ = hungryRemaining.toFloat\n        val hungryRemainingBigDecimal = hungryRemaining.toBigDecimal\n\
    \        val hungryRemainingBigInt = hungryRemaining.toBigInt\n        val hungryRemainingInt\
    \ = hungryRemaining.toInt\n        val hungryRemainingLong = hungryRemaining.toLong\n\
    \        val hungryRemainingDouble = hungryRemaining.toDouble\n        val hungryRemainingFloat\
    \ = hungryRemaining.toFloat\n        val hungryRemainingBigDecimal = hungryRemaining.toBigDecimal\n\
    \        val hungryRemainingBigInt = hungryRemaining.toBigInt\n        val hungryRemainingInt\
    \ = hungryRemaining.toInt\n        val hungryRemainingLong = hungryRemaining.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbnszfvqm.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbnszfvqm.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingInt\e[0m = hungryRemaining.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingInt is already defined as \e[33mvalue\e[0m\
    \ \e[35mhungryRemainingInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbnszfvqm.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingLong\e[0m\
    \ = hungryRemaining.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingLong is already defined as \e[33mvalue\e[0m\
    \ \e[35mhungryRemainingLong\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbnszfvqm.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingDouble\e\
    [0m = hungryRemaining.toDouble\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingDouble is already defined as \e[33mvalue\e\
    [0m \e[35mhungryRemainingDouble\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbnszfvqm.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingFloat\e[0m\
    \ = hungryRemaining.toFloat\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRemainingFloat is already defined as \e[33mvalue\e[0m\
    \ \e[35mhungryRemainingFloat\e[0m\n\e[31m   |\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1659804492
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - carrots\n        val result = List(carrots,\
    \ leftCarrots)\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5p2ouvd0.scala:37)\n\tat Problem.main(tmp5p2ouvd0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804492
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val meals = List(need +\
    \ carrots)\n        val hungry = List(need + carrots)\n        val hungryRemaining\
    \ = remaining - carrots\n        val hungryMeals = List(need + carrots)\n    \
    \    val hungryRemainingMeals = List(need + carrots)\n        val hungryMealsRemaining\
    \ = List(need + carrots)\n        val hungryMealsRemainingMeals = List(need +\
    \ carrots)\n        val hungryMealsRemainingMealsRemaining = List(need + carrots)\n\
    \        val hungryMealsRemainingMealsRemainingMeals = List(need + carrots)\n\
    \        val hungryMealsRemainingMealsRemainingMealsRemaining = List(need + carrots)\n\
    \        val hungryMealsRemainingMealsRemainingMealsRemainingMeals = List(need\
    \ + carrots)\n        val hungryMealsRemainingMealsRemainingMealsRemainingMealsRemaining\
    \ = List(need + carrots)\n        val hungryMealsRemainingMealsRemainingMealsRemainingMealsRemainingMeals\
    \ = List(need + carrots)\n        val hungryMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemaining\
    \ = List(need + carrots)\n        val hungryMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemainingMeals\
    \ = List(need + carrots)\n        val hungryMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemaining\
    \ = List(need + carrots)\n        val hungryMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemainingMeals\
    \ = List(need + carrots)\n        val hungryMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemaining\
    \ = List(need + carrots)\n        val hungryMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemainingMeals\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3jx02c2_.scala:51:123 --------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36mhungryMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemainingMealsRemainingMeals\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                                                                           ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp3jx02c2_.scala:32:24 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining - carrots\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3jx02c2_.scala:52:5 ---------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804491
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = carrots - remainingToEat\n        val carrotLeftToEat\
    \ = carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList,\
    \ carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_vzo6ads.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        (carrotEatenList, carrotLeftToEatList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e[31m]\e[0m\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804492
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        var carrots_left =\
    \ remaining\n        while (carrots_left > 0) {\n            val carrots_needed\
    \ = needs - carrots_left\n            val carrots_eaten = carrots - carrots_left\n\
    \            val carrots_left = carrots_left - carrots_eaten\n            val\
    \ carrots_remaining = carrots_left - carrots_needed\n            result += carrots_eaten\n\
    \            carrots_left += carrots_remaining\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpvlcm9ily.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvlcm9ily.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpvlcm9ily.scala:39:31 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m            \e[33mval\e[0m \e[36mcarrots_left\e[0m = carrots_left - carrots_eaten\n\
    \e[31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m  \
    \                             Recursive \e[33mvalue\e[0m \e[35mcarrots_left\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = needs - carrots\n        val carrots_left_to_eat\
    \ = (carrots_left / needs_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left\
    \ % needs_left).toInt\n        val needs_left_to_eat = (needs_left / carrots_left_to_eat_2).toInt\n\
    \        val needs_left_to_eat_2 = (needs_left % carrots_left_to_eat_2).toInt\n\
    \        val carrots_left_to_eat_3 = (carrots_left_to_eat / needs_left_to_eat_2).toInt\n\
    \        val carrots_left_to_eat_4 = (carrots_left_to_eat % needs_left_to_eat_2).toInt\n\
    \        val needs_left_to_eat_3 = (needs_left_to_eat / carrots_left_to_eat_4).toInt\n\
    \        val needs_left_to_eat_4 = (needs_left_to_eat % carrots_left_to_eat_4).toInt\n\
    \        val carrots_left_to_eat_5 = (carrots_left_to_eat_3 / needs_left_to_eat_4).toInt\n\
    \        val carrots_left_to_eat_6 = (carrots_left_to_eat_3 % needs_left_to_eat_4).toInt\n\
    \        val needs_left_to_eat_5 = (needs_left_to_eat_3 / carrots_left_to_eat_6).toInt\n\
    \        val needs_left_to_eat_6 = (needs_left_to_eat_3 % carrots_left_to_eat_6).toInt\n\
    \        val carrots_left_to_eat_7 = (carrots_left_to_eat_5 / needs_left_to_eat_6).toInt\n\
    \        val carrots_left_to_eat_8 = (carrots_left_to_eat_5 % needs_left_to_eat_6).toInt\n\
    \        val needs_left_to_eat_7 = (needs_left_to_eat_5 / carrots_left_to_eat_8).toInt\n\
    \        val needs_left_to_eat_8 = (needs_left_to_eat_5 % carrots_left_to_eat_8).toInt\n\
    \        val carrots_left_to_eat_9 = (\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnk47akkr.scala:53:37 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_9\e\
    [0m = (\n\e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e\
    [31m   |\e[0m                                     expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnk47akkr.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpnk47akkr.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnk47akkr.scala:54:5 ---------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804491
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        var carrots_left =\
    \ remaining\n        var carrots_eaten = 0\n        while (carrots_left > 0 &&\
    \ carrots_eaten < needs) {\n            carrots_left -= 1\n            carrots_eaten\
    \ += 1\n        }\n        if (carrots_left > 0) {\n            carrots_left -=\
    \ 1\n        }\n        result.add(carrots_eaten)\n        result.add(carrots_left)\n\
    \        return result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp21qi09an.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp21qi09an.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804490
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val carrots_left_to_eat = carrots - carrots_left\n\
    \        val carrots_left_to_eat2 = carrots_left - carrots_left_to_eat\n     \
    \   val carrots_left_to_eat3 = carrots_left_to_eat2 - carrots_left_to_eat2\n \
    \       val carrots_left_to_eat4 = carrots_left_to_eat3 - carrots_left_to_eat3\n\
    \        val carrots_left_to_eat5 = carrots_left_to_eat4 - carrots_left_to_eat4\n\
    \        val carrots_left_to_eat6 = carrots_left_to_eat5 - carrots_left_to_eat5\n\
    \        val carrots_left_to_eat7 = carrots_left_to_eat6 - carrots_left_to_eat6\n\
    \        val carrots_left_to_eat8 = carrots_left_to_eat7 - carrots_left_to_eat7\n\
    \        val carrots_left_to_eat9 = carrots_left_to_eat8 - carrots_left_to_eat8\n\
    \        val carrots_left_to_eat10 = carrots_left_to_eat9 - carrots_left_to_eat9\n\
    \        val carrots_left_to_eat11 = carrots_left_to_eat10 - carrots_left_to_eat10\n\
    \        val carrots_left_to_eat12 = carrots_left_to_eat11 - carrots_left_to_eat11\n\
    \        val carrots_left_to_eat13 = carrots_left_to_eat12 - carrots_left_to_eat12\n\
    \        val carrots_left_to_eat14 = carrots_left_to_eat13 - carrots_left_to_eat13\n\
    \        val carrots_left_to_eat15 = carrots_left_to_eat14 - carrots_left_to_eat14\n\
    \        val carrots_left_to_eat16 = carrots_left_to_eat15 - carrots_left_to_eat15\n\
    \        val carrots_left_to_eat17 = carrots_left_to_eat16 - carrots_left_to_eat16\n\
    \        val carrots_left_to_eat18 = carrots_left_to_eat17 - carrots_left_to_eat17\n\
    \        val carrots_left_to_eat19 = carrots_left_to_eat18 - carrot\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzgvy4iyq.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzgvy4iyq.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpzgvy4iyq.scala:55:5 ---------------------\e[0m\e[0m\n\e[31m55\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804493
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = carrots - needToEat\n        val carrotLeftToEat =\
    \ carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList,\
    \ carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0bioo2hf.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        (carrotEatenList, carrotLeftToEatList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e[31m]\e[0m\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804495
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n\
    \        var carrots = number\n        var remaining = remaining\n        while(number\
    \ > 0 && remaining > 0) {\n            carrots = carrots - 1\n            list.+=(carrots)\n\
    \            remaining = remaining - 1\n        }\n        if(carrots > 0) {\n\
    \            list.+=(carrots)\n        }\n        list.+=(remaining)\n       \
    \ list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp15zkdukh.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp15zkdukh.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804493
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val remainingCarrots = remaining\
    \ - carrots\n        val hungry = true\n        val hungryCarrots = remainingCarrots\n\
    \        val hungryMeals = meals\n        val hungryCarrotsList = List(hungryCarrots)\n\
    \        val hungryMealsList = List(hungryMeals)\n        val hungryMealsList2\
    \ = List(hungryMeals)\n        val hungryCarrotsList2 = List(hungryCarrots)\n\
    \        val hungryMealsList3 = List(hungryMeals)\n        val hungryCarrotsList3\
    \ = List(hungryCarrots)\n        val hungryMealsList4 = List(hungryMeals)\n  \
    \      val hungryCarrotsList4 = List(hungryCarrots)\n        val hungryMealsList5\
    \ = List(hungryMeals)\n        val hungryCarrotsList5 = List(hungryCarrots)\n\
    \        val hungryMealsList6 = List(hungryMeals)\n        val hungryCarrotsList6\
    \ = List(hungryCarrots)\n        val hungryMealsList7 = List(hungryMeals)\n  \
    \      val hungryCarrotsList7 = List(hungryCarrots)\n        val hungryMealsList8\
    \ = List(hungryMeals)\n        val hungryCarrotsList8 = List(hungryCarrots)\n\
    \        val hungryMealsList9 = List(hungryMeals)\n        val hungryCarrotsList9\
    \ = List(hungryCarrots)\n        val hungryMealsList10 = List(hungryMeals)\n \
    \       val hungryCarrotsList10 = List(hungryCarrots)\n        val hungryMealsList11\
    \ = List(hungryMeals)\n        val hungryCarrotsList11 = List(hungryCarrots)\n\
    \        val hungryMealsList12 = List(hungryMeals)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptlt9nko2.scala:61:5\
    \ ---------------------\e[0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804497
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        val needList = List(need.toLong)\n\
    \        val remainingList = List(remaining.toLong)\n        val hungryNeedList\
    \ = hungryList ++ needList\n        val hungryNeedRemainingList = hungryNeedList\
    \ ++ remainingList\n        if (hungryNeedRemainingList.size < 1) {\n        \
    \    hungryNeedRemainingList\n        } else {\n            hungryNeedRemainingList.takeWhile(x\
    \ => x <= 1000).reverse\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm2t2trih.scala:44)\n\tat Problem.main(tmpm2t2trih.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804499
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = remainingToEat - needToEat\n        val carrotLeftToEat\
    \ = carrots - carrotEaten\n        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n\
    \        if (carrotLeftToEat == 0) {\n            carrotLeftToEatList :+ carrotEaten\n\
    \        } else {\n            carrotLeftToEatList :+ carrotLeftToEat\n      \
    \  }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpypppfwyn.scala:44)\n\tat Problem.main(tmpypppfwyn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804500
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - meals\n        val carrots_left_after_meals\
    \ = carrots_left - remaining\n        val carrots_left_after_meals_as_string =\
    \ carrots_left_after_meals.toString\n        val carrots_left_after_meals_as_long\
    \ = carrots_left_after_meals_as_string.map(_.toLong)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        val carrots_left_after_meals_as_long_list\
    \ = List(carrots_left_after_meals_as_long_list)\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptg_cm1p6.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_as_long_list\e\
    [0m = List(carrots_left_after_meals_as_long_list)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_after_meals_as_long_list is already defined as\
    \ \e[33mvalue\e[0m \e[35mcarrots_left_after_meals_as_long_list\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptg_cm1p6.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_as_long_list\e[0m = List(carrots_left_after_meals_as_long_list)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_after_meals_as_long_list is already defined as\
    \ \e[33mvalue\e[0m \e[35mcarrots_left_after_meals_as_long_list\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptg_cm1p6.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_as_long_list\e[0m = List(carrots_left_after_meals_as_long_list)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_after_meals_as_long_list is already defined as\
    \ \e[33mvalue\e[0m \e[35mcarrots_left_after_meals_as_long_list\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptg_cm1p6.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_as_long_list\e[0m = List(carrots_left_after_meals_as_long_list)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^"
  stdout: ''
  timestamp: 1659804499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_to_eat = (carrots_left_to_eat\
    \ + needs_left_to_eat).toInt\n        val needs_to_eat = (needs_left_to_eat +\
    \ carrots_left_to_eat).toInt\n        val carrots_to_eat_left = carrots_to_eat\
    \ - needs_to_eat\n        val needs_to_eat_left = needs_to_eat - carrots_to_eat\n\
    \        val carrots_to_eat_left_to_eat = (carrots_to_eat_left / needs_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat = (needs_to_eat_left / carrots_to_eat_left).toInt\n\
    \        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat - needs_to_eat_left\n\
    \        val needs_to_eat_left_to_eat_left = needs_to_eat_left_to_eat - carrots_to_eat_left_to_eat\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left\
    \ / needs_to_eat_left_to_eat_left).toInt\n        val needs_to_eat_left_to_eat_left_to_eat\
    \ = (needs_to_eat_left_to_eat_left / carrots_to_eat_left_to_eat_left).toInt\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat\
    \ - needs_to_eat_left_to_eat_left\n        val needs_to_eat_left_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left_to_eat\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left_to_eat\
    \ / needs_to_eat_left_to_eat_left_to_eat_left).toInt\n        val needs_to_eat_left_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7fb0rb4x.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mneeds_to_eat_left_to_eat_left_to_eat_left\e\
    [0m = needs_to_eat_left_to_\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_to_eat_left_to_eat_left_to_eat_left is already defined\
    \ as \e[33mvalue\e[0m \e[35mneeds_to_eat_left_to_eat_left_to_eat_left\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp7fb0rb4x.scala:33:24 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e\
    [31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m                 \
    \       Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7fb0rb4x.scala:34:25 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7fb0rb4x.scala:53:5\
    \ ---------------------\e[0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots).toInt\n        val carrots_left_to_eat_left = carrots_left\
    \ - carrots_left_to_eat * needs\n        val needs_left_to_eat_left = needs_left\
    \ - needs_left_to_eat * carrots\n        val carrots_left_to_eat_left_to_eat =\
    \ (carrots_left_to_eat_left / needs_left_to_eat).toInt\n        val needs_left_to_eat_left_to_eat\
    \ = (needs_left_to_eat_left / carrots_left_to_eat).toInt\n        val carrots_left_to_eat_left_to_eat_left\
    \ = carrots_left_to_eat_left - carrots_left_to_eat_left_to_eat * needs_left_to_eat\n\
    \        val needs_left_to_eat_left_to_eat_left = needs_left_to_eat_left - needs_left_to_eat_left_to_eat\
    \ * carrots_left_to_eat\n        val carrots_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left_to_eat / needs_left_to_eat_left_to_eat).toInt\n\
    \        val needs_left_to_eat_left_to_eat_left_to_eat = (needs_left_to_eat_left_to_eat\
    \ / carrots_left_to_eat_left_to_eat).toInt\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_left_to_eat_left_to_eat_left - carrots_left_to_eat_left_to_eat_left\
    \ * needs_left_to_eat_left_to_eat\n        val needs_left_to_eat_left_to_eat_left_to_eat_left\
    \ = needs_left_to_eat_left_to_eat_left - needs_left_to_eat_left_to_eat_left *\
    \ carrots_left_to_eat_left_to_eat\n        val carrots_left_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_left_to_eat_left_to_eat_left / needs_left_to_eat_left_to_eat_left_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptjp9zpxv.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptjp9zpxv.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptjp9zpxv.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptjp9zpxv.scala:50:5 ---------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804500
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining\n        val carrots_needed = carrots - carrots_left\n        val\
    \ carrots_needed_to_eat = carrots_needed - carrots_left\n        val carrots_left_to_eat\
    \ = (carrots_needed - carrots_needed).toInt\n        val carrots_left_to_eat_at_least_one\
    \ = carrots_left_to_eat - 1\n        val carrots_left_to_eat_at_least_two = carrots_left_to_eat\
    \ - 2\n        val carrots_left_to_eat_at_least_three = carrots_left_to_eat -\
    \ 3\n        val carrots_left_to_eat_at_least_four = carrots_left_to_eat - 4\n\
    \        val carrots_left_to_eat_at_least_five = carrots_left_to_eat - 5\n   \
    \     val carrots_left_to_eat_at_least_six = carrots_left_to_eat - 6\n       \
    \ val carrots_left_to_eat_at_least_seven = carrots_left_to_eat - 7\n        val\
    \ carrots_left_to_eat_at_least_eight = carrots_left_to_eat - 8\n        val carrots_left_to_eat_at_least_nine\
    \ = carrots_left_to_eat - 9\n        val carrots_left_to_eat_at_least_ten = carrots_left_to_eat\
    \ - 10\n        val carrots_left_to_eat_at_least_eleven = carrots_left_to_eat\
    \ - 11\n        val carrots_left_to_eat_at_least_twelve = carrots_left_to_eat\
    \ - 12\n        val carrots_left_to_eat_at_least_thirteen = carrots_left_to_eat\
    \ - 13\n        val carrots_left_to_eat_at_least_fourteen = carrots_left_to_eat\
    \ - 14\n        val carrots_left_to_eat_at_least_fifteen = carrots_left_to_eat\
    \ - 15\n        val carrots_left_to_eat_at_least_sixteen = carrots_left_to_eat\
    \ - 16\n        val carrots_left_to_eat_at_least_seventeen = carrots_left_to_eat\
    \ - 17\n        val carrots_left_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxif5lgbf.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxif5lgbf.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpxif5lgbf.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxif5lgbf.scala:57:5 ---------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - need\n        val result = if (remaining\
    \ <= 0) List(number) else List(number, remaining)\n        carrots match {\n \
    \           case 0 => result\n            case _ => eat(number - remaining, need,\
    \ remaining)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpph03rxf1.scala:32:24 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - need\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m\
    \                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryList = List(hungry.toLong)\n        val hungryRemaining = remaining\
    \ - hungry\n        val hungryRemainingList = List(hungryRemaining.toLong)\n \
    \       val hungryRemainingList2 = List(hungryRemaining.toLong)\n        val hungryRemainingList3\
    \ = List(hungryRemaining.toLong)\n        val hungryRemainingList4 = List(hungryRemaining.toLong)\n\
    \        val hungryRemainingList5 = List(hungryRemaining.toLong)\n        val\
    \ hungryRemainingList6 = List(hungryRemaining.toLong)\n        val hungryRemainingList7\
    \ = List(hungryRemaining.toLong)\n        val hungryRemainingList8 = List(hungryRemaining.toLong)\n\
    \        val hungryRemainingList9 = List(hungryRemaining.toLong)\n        val\
    \ hungryRemainingList10 = List(hungryRemaining.toLong)\n        val hungryRemainingList11\
    \ = List(hungryRemaining.toLong)\n        val hungryRemainingList12 = List(hungryRemaining.toLong)\n\
    \        val hungryRemainingList13 = List(hungryRemaining.toLong)\n        val\
    \ hungryRemainingList14 = List(hungryRemaining.toLong)\n        val hungryRemainingList15\
    \ = List(hungryRemaining.toLong)\n        val hungryRemainingList16 = List(hungryRemaining.toLong)\n\
    \        val hungryRemainingList17 = List(hungryRemaining.toLong)\n        val\
    \ hungryRemainingList18 = List(hungryRemaining.toLong)\n        val hungryRemainingList19\
    \ = List(hungryRemaining.toLong)\n        val hungryRemainingList20 = List(hungryRemaining.toLong)\n\
    \        val hungryRemainingList21 = List(hungryRemaining.toLong)\n        val\
    \ hungryRemainingList22 = List(hungryRemaining.toLong)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_9k6smsr.scala:57:5\
    \ ---------------------\e[0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        var carrots_left =\
    \ remaining\n        while (carrots_left > 0) {\n            carrots_left -= 1\n\
    \            val carrots_needed = math.min(carrots_left, meals)\n            carrots\
    \ += carrots_needed\n            meals -= carrots_needed\n            result.add(carrots)\n\
    \        }\n        if (meals > 0) {\n            val carrots_needed = math.min(carrots,\
    \ meals)\n            carrots += carrots_needed\n            meals -= carrots_needed\n\
    \            result.add(carrots)\n        }\n        result.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1d1gj820.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1d1gj820.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp1d1gj820.scala:39:20 ------------------------\e[0m\e[0m\n\e[31m39 |\e\
    [0m            carrots += carrots_needed\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ carrots.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1d1gj820.scala:40:18\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m            meals -= carrots_needed\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Int - did you mean meals.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp1d1gj820.scala:45:20 ------------------------\e[0m\e[0m\n\
    \e[31m45 |\e[0m            carrots += carrots_needed\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member\
    \ of Int - did you mean carrots.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1d1gj820.scala:46:18\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m            meals -= carrots_needed\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ -= is not a member of Int - did you mean meals.!=?\n6 errors found\n"
  stdout: ''
  timestamp: 1659804502
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = carrots_left\
    \ % needs_left\n        val needs_left_to_eat_2 = needs_left % carrots_left\n\
    \        val carrots_left_to_eat_3 = carrots_left % needs_left_2\n        val\
    \ needs_left_to_eat_3 = needs_left % carrots_left_2\n        val carrots_left_to_eat_4\
    \ = carrots_left % needs_left_3\n        val needs_left_to_eat_4 = needs_left\
    \ % carrots_left_3\n        val carrots_left_to_eat_5 = carrots_left % needs_left_4\n\
    \        val needs_left_to_eat_5 = needs_left % carrots_left_4\n        val carrots_left_to_eat_6\
    \ = carrots_left % needs_left_5\n        val needs_left_to_eat_6 = needs_left\
    \ % carrots_left_5\n        val carrots_left_to_eat_7 = carrots_left % needs_left_6\n\
    \        val needs_left_to_eat_7 = needs_left % carrots_left_6\n        val carrots_left_to_eat_8\
    \ = carrots_left % needs_left_7\n        val needs_left_to_eat_8 = needs_left\
    \ % carrots_left_7\n        val carrots_left_to_eat_9 = carrots_left % needs_left_8\n\
    \        val needs_left_to_eat_9 = needs_left % carrots_left_8\n        val carrots_left_to_eat_10\
    \ = carrots_left % needs_left_9\n        val needs_left_to_eat_10 = needs_left\
    \ % carrots_left_9\n        val carrots_left_to_eat_11 = carrots_left % needs_left_10\n\
    \        val needs_left_to_eat_11 = needs_left % carrots_left_10\n        val\
    \ carrots_left_to_eat_12 = carrots_left % needs_left_11\n        val needs_left_to_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptamlkqxw.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptamlkqxw.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptamlkqxw.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptamlkqxw.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804500
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = needs - carrots\n        val carrots_left_to_eat\
    \ = carrots_left - needs_left\n        val needs_left_to_eat = needs_left - carrots_left\n\
    \        val carrots_left_to_eat2 = carrots_left_to_eat.toInt\n        val needs_left_to_eat2\
    \ = needs_left_to_eat.toInt\n        val carrots_left_to_eat3 = carrots_left_to_eat2.toInt\n\
    \        val needs_left_to_eat3 = needs_left_to_eat2.toInt\n        val carrots_left_to_eat4\
    \ = carrots_left_to_eat3.toInt\n        val needs_left_to_eat4 = needs_left_to_eat3.toInt\n\
    \        val carrots_left_to_eat5 = carrots_left_to_eat4.toInt\n        val needs_left_to_eat5\
    \ = needs_left_to_eat4.toInt\n        val carrots_left_to_eat6 = carrots_left_to_eat5.toInt\n\
    \        val needs_left_to_eat6 = needs_left_to_eat5.toInt\n        val carrots_left_to_eat7\
    \ = carrots_left_to_eat6.toInt\n        val needs_left_to_eat7 = needs_left_to_eat6.toInt\n\
    \        val carrots_left_to_eat8 = carrots_left_to_eat7.toInt\n        val needs_left_to_eat8\
    \ = needs_left_to_eat7.toInt\n        val carrots_left_to_eat9 = carrots_left_to_eat8.toInt\n\
    \        val needs_left_to_eat9 = needs_left_to_eat8.toInt\n        val carrots_left_to_eat10\
    \ = carrots_left_to_eat9.toInt\n        val needs_left_to_eat10 = needs_left_to_eat9.toInt\n\
    \        val carrots_left_to_eat11 = carrots_left_to_eat10.toInt\n        val\
    \ needs_left_to_eat11 = needs_left_to_eat10.toInt\n        val carrots_left_to_eat12\
    \ = carrots_left_to_eat11.toInt\n        val needs_left_to_eat12 = needs_left_to_eat11.toInt\n\
    \        val carrots_left_to_eat13 = carrots_left_to_eat12.toInt\n        \n \
    \   }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphygdhuwi.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphygdhuwi.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphygdhuwi.scala:63:5 ---------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val need_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left - need_left).toInt\n        val need_left_to_eat\
    \ = (need_left - carrots_left).toInt\n        val carrots_left_to_eat_minus_need_left_to_eat\
    \ = (carrots_left_to_eat - need_left_to_eat).toInt\n        val need_left_to_eat_minus_carrots_left_to_eat\
    \ = (need_left_to_eat - carrots_left_to_eat).toInt\n        val carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat\
    \ = (carrots_left_to_eat_minus_need_left_to_eat - need_left_to_eat_minus_carrots_left_to_eat).toInt\n\
    \        val need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat\
    \ = (need_left_to_eat_minus_carrots_left_to_eat - carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat).toInt\n\
    \        val carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat\
    \ = (carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat - need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat).toInt\n\
    \        val need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat\
    \ = (need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat - carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat).toInt\n\
    \        val carrots_left_\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq1h5p4nu.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpq1h5p4nu.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpq1h5p4nu.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpq1h5p4nu.scala:44:179 -----------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mneed_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat\e\
    [0m = (need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat - carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat).toInt\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: need_left_to_eat_minus_carrots_left_to_eat_minus_need_left_to_eat\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq1h5p4nu.scala:46:5\
    \ --------------------"
  stdout: ''
  timestamp: 1659804500
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val carrotEaten\
    \ = needToEat - remainingToEat\n        val carrotLeftToEat = carrots - carrotEaten\n\
    \        val carrotLeftToEatString = carrotLeftToEat.toString\n        val carrotEatenString\
    \ = carrotEaten.toString\n        val carrotLeftToEatLong = Long.parseLong(carrotLeftToEatString)\n\
    \        val carrotEatenLong = Long.parseLong(carrotEatenString)\n        val\
    \ carrotEatenLongString = carrotEatenLong.toString\n        val carrotLeftToEatLongString\
    \ = carrotLeftToEatLong.toString\n        val carrotEatenLongString2 = carrotEatenLongString.substring(0,\
    \ carrotEatenLongString.length - 1)\n        val carrotLeftToEatLongString2 =\
    \ carrotLeftToEatLongString.substring(0, carrotLeftToEatLongString.length - 1)\n\
    \        val carrotEatenLongString3 = carrotEatenLongString2.substring(0, carrotEatenLongString2.length\
    \ - 1)\n        val carrotLeftToEatLongString3 = carrotLeftToEatLongString2.substring(0,\
    \ carrotLeftToEatLongString2.length - 1)\n        val carrotEatenLongString4 =\
    \ carrotEatenLongString3.substring(0, carrotEatenLongString3.length - 1)\n   \
    \     val carrotLeftToEatLongString4 = carrotLeftToEatLongString3.substring(0,\
    \ carrotLeftToEatLongString3.length - 1)\n        val carrotEatenLongString5 =\
    \ carrotEatenLongString4.substring(0, carrotEatenLongString4.length - 1)\n   \
    \     val carrotLeftToEatLongString5 = carrotLeftToEatLongString4.substring(0,\
    \ carrotLeftToEatLongString4.length - 1)\n        val carrotEatenLongString6 =\
    \ carrotEatenLongString5.substring(0, carrotEatenLongString5.length - 1)\n   \
    \     val carrotLeftToEatLongString6 = carrotLeftToEatLongString5.substring(0,\
    \ carrotLeftToEatLongString5.length - 1)\n        val carrotEatenLongString7 =\
    \ car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxujrfm1m.scala:34:25 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxujrfm1m.scala:39:39\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrotLeftToEatLong\e[0m = Long.parseLong(carrotLeftToEatString)\n\e[31m\e\
    [31m   |\e[0m                                  ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value parseLong is not a member of object Long\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpxujrfm1m.scala:40:35 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrotEatenLong\e[0m = Long.parseLong(carrotEatenString)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          value parseLong is not a member of object\
    \ Long\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxujrfm1m.scala:53:37 ------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36mcarrotEatenLongString7\e\
    [0m = car\n\e[31m\e[31m   |\e[0m                                     ^^^\e[0m\n\
    \e[31m   |\e[0m                                     Not found: car\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxujrfm1m.scala:54:5 ---------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659804503
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        if (remaining == 0) {\n \
    \           list += carrots.toLong\n        }\n        else {\n            val\
    \ remaining = remaining - carrots.toInt\n            if (remaining <= needs) {\n\
    \                list += carrots.toLong\n            }\n            else {\n \
    \               list += carrots.toLong\n                list += remaining.toLong\n\
    \            }\n        }\n        list.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqkig2k0v.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqkig2k0v.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqkig2k0v.scala:39:28\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m            \e[33mval\e\
    [0m \e[36mremaining\e[0m = remaining - carrots.toInt\n\e[31m\e[31m   |\e[0m  \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \ Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804498
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        val carrots_left = carrots\
    \ - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat\
    \ = carrots_left - needs_left\n        val needs_left_to_eat = needs_left - carrots_left\n\
    \        val carrots_left_to_eat2 = carrots_left - needs_left_to_eat\n       \
    \ val needs_left_to_eat2 = needs_left - carrots_left_to_eat\n        val carrots_left_to_eat3\
    \ = carrots_left - needs_left_to_eat2\n        val needs_left_to_eat3 = needs_left\
    \ - carrots_left_to_eat2\n        val carrots_left_to_eat4 = carrots_left - needs_left_to_eat3\n\
    \        val needs_left_to_eat4 = needs_left - carrots_left_to_eat3\n        val\
    \ carrots_left_to_eat5 = carrots_left - needs_left_to_eat4\n        val needs_left_to_eat5\
    \ = needs_left - carrots_left_to_eat4\n        val carrots_left_to_eat6 = carrots_left\
    \ - needs_left_to_eat5\n        val needs_left_to_eat6 = needs_left - carrots_left_to_eat5\n\
    \        val carrots_left_to_eat7 = carrots_left - needs_left_to_eat6\n      \
    \  val needs_left_to_eat7 = needs_left - carrots_left_to_eat6\n        val carrots_left_to_eat8\
    \ = carrots_left - needs_left_to_eat7\n        val needs_left_to_eat8 = needs_left\
    \ - carrots_left_to_eat7\n        val carrots_left_to_eat9 = carrots_left - needs_left_to_eat8\n\
    \        val needs_left_to_eat9 = needs_left - carrots_left_to_eat8\n        val\
    \ carrots_left_to_eat10 = carrots_left - needs_left_to_eat9\n        val needs_left_to_eat10\
    \ = needs_left - carrots_left_to_eat9\n        val carrots_left_to_eat11 = carrots_left\
    \ - needs_left_to_eat10\n        val needs_left_to_eat11 = needs_left - carrots_left_to_eat10\n\
    \        val carrots_left_to_eat12 = carrot\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplpnofwi0.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplpnofwi0.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplpnofwi0.scala:59:36\
    \ ------------------------\e[0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_left_to_eat12\e[0m = carrot\n\e[31m\e[31m   |\e[0m               \
    \                     ^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \         Not found: carrot\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmplpnofwi0.scala:60:5 ---------------------\e[0m\e[0m\n\e[31m60\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804502
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val remaining = remaining\
    \ - number\n        if (remaining <= 0) {\n            List(number.toLong, remaining.toLong)\n\
    \        } else {\n            val need = need - number\n            val remaining\
    \ = remaining - need\n            val list = List(number.toLong, remaining.toLong)\n\
    \            list.map(x => if (x == 0) x else x + 1)\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa68cjd8z.scala:31:24 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - number\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa68cjd8z.scala:35:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36mneed\e[0m = need - number\n\e[31m\e[31m   |\e[0m                   \
    \    ^\e[0m\n\e[31m   |\e[0m                       Recursive \e[33mvalue\e[0m\
    \ \e[35mneed\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpa68cjd8z.scala:36:28 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            \e[33mval\e[0m \e[36mremaining\e[0m = remaining - need\n\e\
    [31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m       \
    \                     Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val carrotLeft =\
    \ carrots - remainingToEat\n        val needToEatLeft = needToEat - carrotLeft\n\
    \        val needToEatLeftToEat = needToEatLeft - carrotLeft\n        val needToEatLeftToEatToEat\
    \ = needToEatLeftToEat - carrotLeft\n        val needToEatLeftToEatToEatToEat\
    \ = needToEatLeftToEatToEat - carrotLeft\n        val needToEatLeftToEatToEatToEatToEat\
    \ = needToEatLeftToEatToEatToEatToEat - carrotLeft\n        val needToEatLeftToEatToEatToEatToEatToEat\
    \ = needToEatLeftToEatToEatToEatToEatToEat - carrotLeft\n        val needToEatLeftToEatToEatToEatToEatToEatToEatToEat\
    \ = needToEatLeftToEatToEatToEatToEatToEatToEatToEat - carrotLeft\n        val\
    \ needToEatLeftToEatToEatToEatToEatToEatToEatToEatToEatToEat = needToEatLeftToEatToEatToEatToEatToEatToEatToEatToEatToEat\
    \ - carrotLeft\n        val needToEatLeftToEatToEatToEatToEatToEatToEatToEatToEatToEatToEatToEat\
    \ = needToEatLeftToEatToEatToEatToEatToEatToEatToEatToEatToEatToEatToEat - carrotLeft\n\
    \        val needToEatLeftToEatToEatToEatToEatToEatToEatToEatToEatToEatToEatToEatToEatToEat\
    \ = needToEatLeftToEatToEatToEatTo\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfjzsbeg6.scala:34:25 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfjzsbeg6.scala:40:48\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mneedToEatLeftToEatToEatToEatToEat\e[0m = needToEatLeftToEatToEatToEatToEat\
    \ - carrotLeft\n\e[31m\e[31m   |\e[0m                                        \
    \        ^\e[0m\n\e[31m   |\e[0m            Recursive \e[33mvalue\e[0m \e[35mneedToEatLeftToEatToEatToEatToEat\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfjzsbeg6.scala:41:53\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mneedToEatLeftToEatToEatToEatToEatToEat\e[0m = needToEatLeftToEatToEatToEatToEatToEat\
    \ - carrotLeft\n\e[31m\e[31m   |\e[0m                                        \
    \             ^\e[0m\n\e[31m   |\e[0m       Recursive \e[33mvalue\e[0m \e[35mneedToEatLeftToEatToEatToEatToEatToEat\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfjzsbeg6.scala:42:63\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mneedToEatLeftToEatToEatToEatToEatToEatToEatToEat\e[0m = needToEatLeftToEatToEatToEatToEatToEatToEatToEat\
    \ - carrotLeft\n\e[31m\e[31m   |\e[0m                                        \
    \                       ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mneedToEatLeftToEatToEatToEatToEatToEatToEatToEat\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfjzsbeg6.scala:43:73\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m      "
  stdout: ''
  timestamp: 1659804503
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = remaining - carrots\n        val meals = carrots - need\n\
    \        val meals_left = carrots_left - meals\n        val meals_left_to_eat\
    \ = (meals_left - needs).toInt\n        val meals_left_to_eat_left = meals_left_to_eat\
    \ - meals_left\n        val meals_left_to_eat_left_left = meals_left_to_eat_left\
    \ - meals_left_left\n        val meals_left_to_eat_left_left_left = meals_left_to_eat_left_left\
    \ - meals_left_left_left\n        val meals_left_to_eat_left_left_left_left =\
    \ meals_left_to_eat_left_left_left - meals_left_left_left_left\n        val meals_left_to_eat_left_left_left_left_left\
    \ = meals_left_to_eat_left_left_left_left - meals_left_left_left_left_left\n \
    \       val meals_left_to_eat_left_left_left_left_left_left = meals_left_to_eat_left_left_left_left_left\
    \ - meals_left_left_left_left_left_left\n        val meals_left_to_eat_left_left_left_left_left_left_left\
    \ = meals_left_to_eat_left_left_left_left_left_left - meals_left_left_left_left_left_left_left\n\
    \        val meals_left_to_eat_left_left_left_left_left_left_left_left = meals_left_to_eat_left_left_left_left_left_left_left\
    \ - meals_left_left_left_left_left_left_left\n        val meals_left_to_eat_left_left_left_left_left_left_left_left_left\
    \ = meals_left_to_eat_left_left_left_left_left_left_left_left - meals_left_left_left_left_left_left_left_left\n\
    \        val meals_left_to_eat_left_left_left_left_left_left_left_left_left_left\
    \ = meals_left_to_eat_left_left_left_left_left_left_left_left_left - meals_left_left_left_left_left_left_left_left_left\n\
    \        val meals_left_to_eat_left_left_left_left_left_left_left_left_left_left_left\
    \ = meals_left_to_eat_left_left_left_left_left_left_left_left_left_left - meals_left_left_left_left_left_left_left_left_left\n\
    \        val meals_left_to_eat_left_left_left_left_left_left_left_left_left_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8zstwvo2.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8zstwvo2.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp8zstwvo2.scala:50:5 ---------------------\e[0m\e[0m\n\e[31m50\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804503
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val lefts = remaining - needs\n\
    \        val totalCarrots = carrots + lefts\n        val totalLefts = lefts +\
    \ meals\n        val totalMeals = meals + lefts\n        val totalNeeds = needs\
    \ + lefts\n        val totalRemaining = remaining + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = needs + lefts\n        val totalNeedsLeft\
    \ = needs + lefts\n        val totalNeedsLeft = need\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo58uqjwq.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mtotalNeedsLeft\e[0m = needs\
    \ + lefts\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mtotalNeedsLeft is already defined as \e[33mvalue\e[0m \e[35mtotalNeedsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo58uqjwq.scala:43:12 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m        \e[33mval\e[0m \e[36mtotalNeedsLeft\e[0m = needs + lefts\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mtotalNeedsLeft is already defined as \e[33mvalue\e[0m \e[35mtotalNeedsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo58uqjwq.scala:44:12 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m        \e[33mval\e[0m \e[36mtotalNeedsLeft\e[0m = needs + lefts\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mtotalNeedsLeft is already defined as \e[33mvalue\e[0m \e[35mtotalNeedsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo58uqjwq.scala:45:12 ---------------------------\e[0m\e[0m\n\e\
    [31m45 |\e[0m        \e[33mval\e[0m \e[36mtotalNeedsLeft\e[0m = needs + lefts\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mtotalNeedsLeft is already defined as \e[33mvalue\e[0m \e[35mtotalNeedsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo58uqjwq.scala:46:12 ---------------------------\e[0m\e[0m\n\e\
    [31m46 |\e[0m        \e[33mval\e[0m \e[36mtotalNeedsLeft\e[0m = needs + lefts\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mtotalNeedsLeft is"
  stdout: ''
  timestamp: 1659804504
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        val carrots_left = carrots\
    \ - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat\
    \ = (carrots_left / needs).toInt\n        val needs_left_to_eat = (needs_left\
    \ / carrots).toInt\n        val carrots_left_to_eat_minus_one = carrots_left -\
    \ carrots_left_to_eat\n        val needs_left_to_eat_minus_one = needs_left -\
    \ needs_left_to_eat\n        val carrots_left_to_eat_minus_two = carrots_left\
    \ - carrots_left_to_eat - carrots_left_to_eat_minus_one\n        val needs_left_to_eat_minus_two\
    \ = needs_left - needs_left_to_eat - needs_left_to_eat_minus_one\n        val\
    \ carrots_left_to_eat_minus_three = carrots_left - carrots_left_to_eat - carrots_left_to_eat_minus_one\
    \ - carrots_left_to_eat_minus_two\n        val needs_left_to_eat_minus_three =\
    \ needs_left - needs_left_to_eat - needs_left_to_eat_minus_one - needs_left_to_eat_minus_two\n\
    \        val carrots_left_to_eat_minus_four = carrots_left - carrots_left_to_eat\
    \ - carrots_left_to_eat_minus_one - carrots_left_to_eat_minus_two - carrots_left_to_eat_minus_three\n\
    \        val needs_left_to_eat_minus_four = needs_left - needs_left_to_eat - needs_left_to_eat_minus_one\
    \ - needs_left_to_eat_minus_two - needs_left_to_eat_minus_three\n        val carrots_left_to_eat_minus_five\
    \ = carrots_left - carrots_left_to_eat - carrots_left_to_eat_minus_one - carrots_left_to_eat_minus_two\
    \ - carrots_left_to_eat_minus_three - carrots_left_to_eat_minus_four\n       \
    \ val needs_left_to_eat_minus_five = needs_left - needs_left_to_eat - needs_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4r619b9e.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4r619b9e.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4r619b9e.scala:49:5\
    \ ---------------------\e[0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804503
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = carrots - meals\n\
    \        val hungryList = List(hungry.toLong)\n        val hungryList2 = List(hungry.toLong)\n\
    \        val hungryList3 = List(hungry.toLong)\n        val hungryList4 = List(hungry.toLong)\n\
    \        val hungryList5 = List(hungry.toLong)\n        val hungryList6 = List(hungry.toLong)\n\
    \        val hungryList7 = List(hungry.toLong)\n        val hungryList8 = List(hungry.toLong)\n\
    \        val hungryList9 = List(hungry.toLong)\n        val hungryList10 = List(hungry.toLong)\n\
    \        val hungryList11 = List(hungry.toLong)\n        val hungryList12 = List(hungry.toLong)\n\
    \        val hungryList13 = List(hungry.toLong)\n        val hungryList14 = List(hungry.toLong)\n\
    \        val hungryList15 = List(hungry.toLong)\n        val hungryList16 = List(hungry.toLong)\n\
    \        val hungryList17 = List(hungry.toLong)\n        val hungryList18 = List(hungry.toLong)\n\
    \        val hungryList19 = List(hungry.toLong)\n        val hungryList20 = List(hungry.toLong)\n\
    \        val hungryList21 = List(hungry.toLong)\n        val hungryList22 = List(hungry.toLong)\n\
    \        val hungryList23 = List(hungry.toLong)\n        val hungryList24 = List(hungry.toLong)\n\
    \        val hungryList25 = List(hungry.toLong)\n        val hungryList26 = List(hungry.toLong)\n\
    \        val hungryList27 = \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpywi9k0a8.scala:62:26 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36mhungryList27\e[0m = \n\e\
    [31m\e[31m   |\e[0m                          ^\e[0m\n\e[31m   |\e[0m         \
    \                 expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpywi9k0a8.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpywi9k0a8.scala:63:5\
    \ ---------------------\e[0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        val carrots_left = remaining\n\
    \        val carrots_left_after_meals = carrots - carrots_left\n        val carrots_left_after_meals_after_meals\
    \ = carrots_left_after_meals - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals - carrots_left_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals\n        val\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmonv02e1.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmonv02e1.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmonv02e1.scala:40:87\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmonv02e1.scala:41:111\
    \ -----------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                   "
  stdout: ''
  timestamp: 1659804505
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining == 0)\
    \ {\n            result.add(carrots)\n        }\n        else {\n            val\
    \ remaining = remaining - carrots\n            if (remaining <= needs) {\n   \
    \             result.add(carrots)\n            }\n            else {\n       \
    \         val needs = needs - remaining\n                result.add(needs)\n \
    \               result.add(carrots)\n            }\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp80xh86yn.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp80xh86yn.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp80xh86yn.scala:39:28 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m            \e[33mval\e[0m \e[36mremaining\e[0m = remaining - carrots\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp80xh86yn.scala:44:28\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m                \e[33mval\e\
    [0m \e[36mneeds\e[0m = needs - remaining\n\e[31m\e[31m   |\e[0m              \
    \              ^\e[0m\n\e[31m   |\e[0m                            Recursive \e\
    [33mvalue\e[0m \e[35mneeds\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804503
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n\
    \        var carrots = number\n        var remaining = remaining\n        while(remaining\
    \ > 0){\n            carrots = carrots + 1\n            list.+=(carrots)\n   \
    \         remaining = remaining - 1\n        }\n        list.+=(need)\n      \
    \  list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp12e5wd2s.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp12e5wd2s.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804504
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val meals = if (remaining\
    \ <= 0) List(number) else List(number, need)\n        meals.reverse.foldLeft(List[Long](0l.toLong))\
    \ { (list, meal) =>\n            val carrots = meal._1 - meal._2\n           \
    \ val remaining = meal._2 - carrots\n            val meals = if (remaining <=\
    \ 0) List(meal) else List(meal, meal._1)\n            meals.reverse.foldLeft(List[Long](0l.toLong))\
    \ { (list, meal) =>\n                val carrots = meal._1 - meal._2\n       \
    \         val remaining = meal._2 - carrots\n                val meals = if (remaining\
    \ <= 0) List(meal) else List(meal, meal._1)\n                meals.reverse.foldLeft(List[Long](0l.toLong))\
    \ { (list, meal) =>\n                    val carrots = meal._1 - meal._2\n   \
    \                 val remaining = meal._2 - carrots\n                    val meals\
    \ = if (remaining <= 0) List(meal) else List(meal, meal._1)\n                \
    \    meals.reverse.foldLeft(List[Long](0l.toLong)) { (list, meal) =>\n       \
    \                 val carrots = meal._1 - meal._2\n                        val\
    \ remaining = meal._2 - carrots\n                        val meals = if (remaining\
    \ <= 0) List(meal) else List(meal, meal._1)\n                        meals.reverse.foldLeft(List[Long](0l.toLong))\
    \ { (list, meal) =>\n                            val carrots = meal._1 - meal._2\n\
    \                            val remaining = meal._2 - carrots\n             \
    \               val meals = if (remaining <= 0) List(meal) else List(meal, meal._1)\n\
    \                            meals.reverse.foldLeft(List[Long](0l.toLong)) { (list,\
    \ meal) =>\n                                val carrots = meal._1 - meal._2\n\
    \                                val remaining = meal._2 - carrots\n         \
    \                       val meals = if (remaining <= 0) List(meal) else List(meal,\
    \ meal._1)\n                                meals.reverse.foldLeft(List[Long](0l.toLong))\
    \ { (list, meal) =>\n                                    val carrots = meal._1\
    \ - meal._2\n                                    val remaining = me\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7wje55js.scala:72:0 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7wje55js.scala:32:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining - carrots\n\e[31m\e[31m   |\e[0m          \
    \              ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp7wje55js.scala:35:31 ------------------------\e[0m\e[0m\n\e[31m35 |\e\
    [0m            \e[33mval\e[0m \e[36mcarrots\e[0m = meal._1 - meal._2\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp7wje55js.scala:36:33 ------------------------\e[0m\e[0m\n\
    \e[31m36 |\e[0m            \e[33mval\e[0m \e[36mremaining\e[0m = meal._2 - carrots\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            value _2 is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp7wje55js.scala:37:76 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mmeals\e[0m = \e[33mif\e\
    [0m (remaining <= \e[31m0\e[0m) List(meal) \e[33melse\e[0m List(meal, meal._1)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \        value _1 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp7wje55js.scala:39:35 ------------------------\e[0m\e[0m\n\e[31m39 |\e\
    [0m                \e[33mval\e[0m \e[36mcarrots\e[0m = meal._1 - meal._2\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                         value _1 is not a member of Long\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp7wje55js.scala:40:37 ------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m        "
  stdout: ''
  timestamp: 1659804512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n\
    \        var carrots = number\n        var remaining = remaining\n        while\
    \ (carrots > 0 && remaining > 0) {\n            list.add(remaining)\n        \
    \    carrots -= 1\n            remaining -= 1\n        }\n        if (remaining\
    \ > 0) {\n            list.add(remaining)\n        }\n        list.map(_.toLong)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3qen00s4.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp3qen00s4.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mvar\e[0m \e[36mremaining\e[0m = remaining\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvariable\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804505
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = carrots - needToEat\n        val carrotLeftToEat =\
    \ carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList,\
    \ carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0bioo2hf.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        (carrotEatenList, carrotLeftToEatList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e[31m]\e[0m\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804495
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_list = List(carrots_left.toLong)\n     \
    \   val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        val carrots_left_list = List(carrots_left.toLong)\n\
    \        val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list\
    \ = List(carrots_left.toLong)\n        val needs_left_list = List(needs_left.toLong)\n\
    \        val carrots_left_list = List(carrots_left.toLong)\n        val needs_left_list\
    \ = List(needs_left.toLong)\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo4jljy6_.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m =\
    \ List(carrots_left.toLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpo4jljy6_.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_list\e[0m = List(needs_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mneeds_left_list is already defined as \e[33mvalue\e[0m \e[35mneeds_left_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo4jljy6_.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_list\e[0m = List(carrots_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_list is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_list\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpo4jljy6_.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mneeds_left_list\e[0m = List(needs_left.toLong)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mneeds_left_list is already defined as \e[33mvalue\e[0m \e[35mneeds_left_list\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo4jljy6_.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mcarrots_le"
  stdout: ''
  timestamp: 1659804509
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals\
    \ = carrots_left % needs_left\n        val meals_left = carrots_left_after_meals\
    \ / needs_left\n        val carrots_left_after_meals_left = carrots_left_after_meals\
    \ % needs_left\n        val meals_left_left = carrots_left_after_meals_left /\
    \ needs_left\n        val carrots_left_after_meals_left_left = carrots_left_after_meals_left\
    \ % needs_left\n        val meals_left_left_left = carrots_left_after_meals_left_left\
    \ / needs_left\n        val carrots_left_after_meals_left_left_left = carrots_left_after_meals_left_left\
    \ % needs_left\n        val meals_left_left_left_left = carrots_left_after_meals_left_left_left\
    \ / needs_left\n        val carrots_left_after_meals_left_left_left_left = carrots_left_after_meals_left_left_left\
    \ % needs_left\n        val meals_left_left_left_left_left = carrots_left_after_meals_left_left_left_left\
    \ / needs_left\n        val carrots_left_after_meals_left_left_left_left_left\
    \ = carrots_left_after_meals_left_left_left_left % needs_left\n        val meals_left_left_left_left_left_left\
    \ = carrots_left_after_meals_left_left_left_left_left / needs_left\n        val\
    \ carrots_left_after_meals_left_left_left_left_left_left = carrots_left_after_meals_left_left_left_left_left\
    \ % needs_left\n        val meals_left_left_left_left_left_left_left = carrots_left_after_meals_left_left_left_left_left_left\
    \ / needs_left\n        val carrots_left_after_meals_left_left_left_left_left_left_left\
    \ = carrots_left_after_meals_left_left_left_left_left_left % needs_left\n    \
    \    val meals_left_left_left_left_left_left_left_left = carrots_left_after_meals_left_left_left_left_left_left_left\
    \ / needs_left\n        val carrots_left_after_meals_left_left_left_left_left_left_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi8cbk4yq.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpi8cbk4yq.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpi8cbk4yq.scala:54:5 ---------------------\e[0m\e[0m\n\e[31m54\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804510
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val meals_left = meals - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left * 2).toInt\n        val meals_left_to_eat\
    \ = (meals_left * 2).toInt\n        val carrots_left_to_eat_2 = (carrots_left\
    \ * 3).toInt\n        val meals_left_to_eat_2 = (meals_left * 3).toInt\n     \
    \   val carrots_left_to_eat_3 = (carrots_left * 4).toInt\n        val meals_left_to_eat_3\
    \ = (meals_left * 4).toInt\n        val carrots_left_to_eat_4 = (carrots_left\
    \ * 5).toInt\n        val meals_left_to_eat_4 = (meals_left * 5).toInt\n     \
    \   val carrots_left_to_eat_5 = (carrots_left * 6).toInt\n        val meals_left_to_eat_5\
    \ = (meals_left * 6).toInt\n        val carrots_left_to_eat_6 = (carrots_left\
    \ * 7).toInt\n        val meals_left_to_eat_6 = (meals_left * 7).toInt\n     \
    \   val carrots_left_to_eat_7 = (carrots_left * 8).toInt\n        val meals_left_to_eat_7\
    \ = (meals_left * 8).toInt\n        val carrots_left_to_eat_8 = (carrots_left\
    \ * 9).toInt\n        val meals_left_to_eat_8 = (meals_left * 9).toInt\n     \
    \   val carrots_left_to_eat_9 = (carrots_left * 10).toInt\n        val meals_left_to_eat_9\
    \ = (meals_left * 10).toInt\n        val carrots_left_to_eat_10 = (carrots_left\
    \ * 11).toInt\n        val meals_left_to_eat_10 = (meals_left * 11).toInt\n  \
    \      val carrots_left_to_eat_11 = (carrots_left * 12).toInt\n        val meals_left_to_eat_11\
    \ = (meals_left * 12).toInt\n        val carrots_left_to_eat_12 = (carrots_left\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptc0295bs.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptc0295bs.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptc0295bs.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptc0295bs.scala:60:5 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804509
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val meals = carrots_left\
    \ / need\n        val carrots_left_after_meals = carrots_left % need\n       \
    \ val carrots_after_meals = carrots_left_after_meals * need\n        val carrots_after_meals_remaining\
    \ = carrots_after_meals + remaining\n        val carrots_after_meals_remaining_remaining\
    \ = carrots_after_meals_remaining + remaining\n        val carrots_after_meals_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining + remaining\n        val carrots_after_meals_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining + remaining\n        val\
    \ carrots_after_meals_remaining_remaining_remaining_remaining_remaining = carrots_after_meals_remaining_remaining_remaining_remaining\
    \ + remaining\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining + remaining\n\
    \        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ + remaining\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ + remaining\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ + remaining\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ + remaining\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ + remaining\n        val carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqfxh_ois.scala:49:103 --------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                                                       ^\e[0m\n\e[31m   |\e[0m\
    \                                       expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqfxh_ois.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\e\
    [0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ + remaining\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpqfxh_ois.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining_remaining\e\
    [0m = carrots_after_meals_remaining_remaining_remaining_remaining_remaining_remaining\
    \ + remaining\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_after_m"
  stdout: ''
  timestamp: 1659804509
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals_left = carrots_left - needs_left\n        val meals\
    \ = List(meals_left)\n        val carrots_left = carrots_left - meals_left\n \
    \       val carrots = List(carrots_left)\n        val needs = List(needs_left)\n\
    \        val meals_left = carrots_left - needs_left\n        val meals = List(meals_left)\n\
    \        val carrots_left = carrots_left - meals_left\n        val carrots = List(carrots_left)\n\
    \        val needs = List(needs_left)\n        val meals_left = carrots_left -\
    \ needs_left\n        val meals = List(meals_left)\n        val carrots_left =\
    \ carrots_left - meals_left\n        val carrots = List(carrots_left)\n      \
    \  val needs = List(needs_left)\n        val meals_left = carrots_left - needs_left\n\
    \        val meals = List(meals_left)\n        val carrots_left = carrots_left\
    \ - meals_left\n        val carrots = List(carrots_left)\n        val needs =\
    \ List(needs_left)\n        val meals_left = carrots_left - needs_left\n     \
    \   val meals = List(meals_left)\n        val carrots_left = carrots_left - meals_left\n\
    \        val carrots = List(carrots_left)\n        val needs = List(needs_left)\n\
    \        val meals_left = carrots_left - needs_left\n        val meals = List(meals_left)\n\
    \        val carrots_left = carrots_left - meals_left\n        val carrots = List(carrots_left)\n\
    \        val needs = List(needs_left)\n        val meals_left = carrots_left -\
    \ needs_left\n        val meals = List(meals_left)\n        val carrots_left =\
    \ carrots_left - meals_left\n        val carrots = List(carrots_left)\n      \
    \  val needs = List(needs_left)\n        val meals_left = carrots_left - needs_left\n\
    \        val meals = List(meals_left)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzvmz6uz2.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left\e[0m = carrots_left\
    \ - meals_left\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left is already defined as \e[33mvalue\e[0m \e[35mcarrots_left\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzvmz6uz2.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = List(carrots_left)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzvmz6uz2.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36mneeds\e[0m = List(needs_left)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mneeds is already\
    \ defined as \e[33mvalue\e[0m \e[35mneeds\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzvmz6uz2.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmeals_left\e[0m = carrots_left - needs_left\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmeals_left\
    \ is already defined as \e[33mvalue\e[0m \e[35mmeals_left\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzvmz6uz2.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmeals\e[0m = List(meals_left)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmeals is already defined as \e[33mvalue\e[0m \e[35mmeals"
  stdout: ''
  timestamp: 1659804510
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val numEaten = number -\
    \ need\n        val numLeft  = remaining - numEaten\n        if (numLeft <= 0)\
    \ {\n            List(numEaten.toLong)\n        } else {\n            List(numEaten.toLong,\
    \ numLeft.toLong)\n        }\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxce2dioa.scala:40)\n\tat Problem.main(tmpxce2dioa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = meals > 0\n      \
    \  val left = (carrots - meals).toLong\n        val lefts = left.toInt\n     \
    \   val result = if (hungry) List(left.toLong, lefts) else List(left.toLong, 0)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpibmhgceu.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpibmhgceu.scala:39:8\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : List[Int])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804510
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val mealsLeft = carrots - meals\n        val carrotsLeft = carrots - remaining\n\
    \        val result = List(carrotsLeft.toLong, mealsLeft.toLong)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6jkiiifs.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804508
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = carrots_left / needs_left\n        val carrots_left_after_meals\
    \ = carrots_left % needs_left\n        val meals_left_after_meals = needs_left\
    \ - carrots_left_after_meals\n        val meals_left_after_meals_as_string = meals_left_after_meals.toString\n\
    \        val carrots_left_after_meals_as_string = carrots_left_after_meals.toString\n\
    \        val meals_left_after_meals_as_string_with_commas = meals_left_after_meals_as_string.replaceAll(\"\
    ,\", \".\")\n        val carrots_left_after_meals_as_string_with_commas = carrots_left_after_meals_as_string.replaceAll(\"\
    ,\", \".\")\n        val meals_left_after_meals_as_string_with_commas_with_commas\
    \ = meals_left_after_meals_as_string_with_commas.replaceAll(\",\", \".\")\n  \
    \      val carrots_left_after_meals_as_string_with_commas_with_commas = carrots_left_after_meals_as_string_with_commas.replaceAll(\"\
    ,\", \".\")\n        val meals_left_after_meals_as_string_with_commas_with_commas_with_commas\
    \ = meals_left_after_meals_as_string_with_commas_with_commas.replaceAll(\",\"\
    , \".\")\n        val carrots_left_after_meals_as_string_with_commas_with_commas_with_commas\
    \ = carrots_left_after_meals_as_string_with_commas_with_commas.replaceAll(\",\"\
    , \".\")\n        val meals_left_after_meals_as_string_with_commas_with_commas_with_commas_with_commas\
    \ = meals_left_after_meals_as_string_with_commas_with_commas_with_commas.replaceAll(\"\
    ,\", \".\")\n        val carrots_left_after_meals_as_string_with_commas_with_commas_with_commas_with_commas\
    \ = carrots_left_after_meals_as_string_with_commas_with_commas_with_commas.replaceAll(\"\
    ,\", \".\")\n        val meals_left_after_meals_as_string_with_commas_with_commas_with_commas_with_commas\
    \ = meals_left_after_me\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_97cqdui.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mmeals_left_after_meals_as_string_with_commas_with_commas_with_commas_with_commas\e\
    [0m = meals_left_after_me\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmeals_left_after_meals_as_string_with_commas_with_commas_with_commas_with_commas\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  meals_left_after_meals_as_string_with_commas_with_commas_with_commas_with_commas\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmp_97cqdui.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_97cqdui.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = List(needs_left.toLong, carrots_left.toLong)\n\
    \        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy4bdx1vr.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804508
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = carrots - remainingToEat\n        val carrotLeftToEat\
    \ = carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        (carrotEatenList,\
    \ carrotLeftToEatList)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_vzo6ads.scala:38:8\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m        (carrotEatenList, carrotLeftToEatList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    \e[1m\e[31m(\e[0mList[Long\e[1m\e[31m]\e[0m\e[1m\e\
    [31m,\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0m\e[1m\e[31mLong\e\
    [0m]\e[1m\e[31m)\e[0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659804492
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        var carrots_left = remaining\n\
    \        val hungry = true\n        val hungry_carrots = carrots - need\n    \
    \    val hungry_needs = needs - carrots_left\n        val hungry_remaining = remaining\
    \ - carrots_left\n        val hungry_hungry = hungry_carrots + hungry_needs +\
    \ hungry_remaining\n        val hungry_hungry_carrots = hungry_carrots + hungry_remaining\n\
    \        val hungry_hungry_needs = hungry_needs + hungry_remaining\n        val\
    \ hungry_hungry_remaining = hungry_remaining + hungry_remaining\n        val hungry_hungry_hungry\
    \ = hungry_hungry_carrots + hungry_hungry_needs + hungry_hungry_remaining\n  \
    \      val hungry_hungry_hungry_carrots = hungry_hungry_carrots + hungry_hungry_remaining\n\
    \        val hungry_hungry_hungry_needs = hungry_hungry_needs + hungry_hungry_remaining\n\
    \        val hungry_hungry_hungry_remaining = hungry_hungry_remaining + hungry_hungry_remaining\n\
    \        val hungry_hungry_hungry_hungry = hungry_hungry_hungry_carrots + hungry_hungry_hungry_needs\
    \ + hungry_hungry_hungry_remaining\n        val hungry_hungry_hungry_hungry_carrots\
    \ = hungry_hungry_hungry_carrots + hungry_hungry_hungry_remaining\n        val\
    \ hungry_hungry_hungry_hungry_needs = hungry_hungry_hungry_needs + hungry_hungry_hungry_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqjlbw_j5.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqjlbw_j5.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqjlbw_j5.scala:51:5\
    \ ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804512
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - hungry\n        val hungryEaten = if\
    \ (hungryRemaining <= 0) 0 else hungryRemaining\n        val hungryEatenList =\
    \ List(hungryEaten.toLong)\n        val hungryEatenList2 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList3 = List(hungryEaten.toLong)\n        val hungryEatenList4\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList5 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList6 = List(hungryEaten.toLong)\n        val hungryEatenList7\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList8 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList9 = List(hungryEaten.toLong)\n        val hungryEatenList10\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList11 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList12 = List(hungryEaten.toLong)\n        val hungryEatenList13\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList14 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList15 = List(hungryEaten.toLong)\n        val hungryEatenList16\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList17 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList18 = List(hungryEaten.toLong)\n        val hungryEatenList19\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList20 = List(hungry\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp37eguvpq.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp37eguvpq.scala:54:5 ---------------------\e[0m\e[0m\n\e[31m54 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val remaining = remaining\
    \ - number\n        if (remaining <= 0) {\n            List(number.toLong, remaining.toLong)\n\
    \        } else {\n            val need = need - number\n            val remaining\
    \ = remaining - need\n            val list = List(number.toLong, remaining.toLong)\n\
    \            val newList = list.zipWithIndex.filter(_._2 > 0).map(_._1)\n    \
    \        val newList2 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n       \
    \     val newList3 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n          \
    \  val newList4 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n            val\
    \ newList5 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n            val newList6\
    \ = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n            val newList7 = list.zipWithIndex.filter(_._2\
    \ < 0).map(_._1)\n            val newList8 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n\
    \            val newList9 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n   \
    \         val newList10 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n     \
    \       val newList11 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n       \
    \     val newList12 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n         \
    \   val newList13 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n           \
    \ val newList14 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n            val\
    \ newList15 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n            val newList16\
    \ = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n            val newList17 =\
    \ list.zipWithIndex.filter(_._2 < 0).map(_._1)\n            val newList18 = list.zipWithIndex.filter(_._2\
    \ < 0).map(_._1)\n            val newList19 = list.zipWithIndex.filter(_._2 <\
    \ 0).map(_._1)\n            val newList20 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n\
    \            val newList21 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n  \
    \          val newList22 = list.zipWithIndex.filter(_._2 < 0).map(_._1)\n    \
    \        val newList23\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpadf314v7.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpadf314v7.scala:72:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m72 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpadf314v7.scala:31:24 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining - number\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpadf314v7.scala:35:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36mneed\e[0m = need - number\n\e[31m\e[31m   |\e[0m                   \
    \    ^\e[0m\n\e[31m   |\e[0m                       Recursive \e[33mvalue\e[0m\
    \ \e[35mneed\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpadf314v7.scala:36:28 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            \e[33mval\e[0m \e[36mremaining\e[0m = remaining - need\n\e\
    [31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m       \
    \                     Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpadf314v7.scala:71:1\
    \ ---------------------\e[0m\e[0m\n\e[31m71 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpadf314v7.scala:62:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m62 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m"
  stdout: ''
  timestamp: 1659804514
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        if (remaining <= 0) {\n \
    \           list += 0\n        } else {\n            list += carrots - remaining\n\
    \        }\n        if (needs > 0) {\n            list += carrots - list.last\n\
    \        }\n        list.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpiewfm2dl.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiewfm2dl.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804510
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needToEat = need.toInt\n        val remainingToEat = remaining.toInt\n\
    \        val carrotEaten = carrots - needToEat\n        val carrotLeftToEat =\
    \ carrots - carrotEaten\n        val carrotEatenList = List(carrotEaten.toLong)\n\
    \        val carrotLeftToEatList = List(carrotLeftToEat.toLong)\n        val carrotEatenAndLeftToEatList\
    \ = carrotEatenList.::carrotLeftToEatList\n        carrotEatenAndLeftToEatList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgcyq9_f0.scala:38:60 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mcarrotEatenAndLeftToEatList\e\
    [0m = carrotEatenList.::carrotLeftToEatList\n\e[31m\e[31m   |\e[0m           \
    \                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m         value carrotLeftToEatList is not a member of Long => List[Long]\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgcyq9_f0.scala:39:8 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        carrotEatenAndLeftToEatList\n\e[31m\e[31m   |\e\
    [0m        ^\e[0m\n\e[31m   |\e[0m        Recursive \e[33mvalue\e[0m \e[35mcarrotEatenAndLeftToEatList\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgcyq9_f0.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804515
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = meals > 0\n      \
    \  val left = (carrots - meals).toInt\n        val result = if(hungry) List(meals.toLong,\
    \ left.toLong) else List(0l.toLong, 0l.toLong)\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzwhn650b.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804511
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val meals = List(needs_left.toLong, carrots_left.toLong)\n\
    \        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpy4bdx1vr.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804508
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val remaining = remaining\
    \ - number\n        val need = need - number\n        if (remaining < 0)\n   \
    \         List(number + need)\n        else if (remaining == 0)\n            List(number)\n\
    \        else\n            List(number, need)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpth9l92le.scala:31:24 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - number\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpth9l92le.scala:32:19\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mneed\e[0m = need - number\n\e[31m\e[31m   |\e[0m                   ^\e\
    [0m\n\e[31m   |\e[0m                   Recursive \e[33mvalue\e[0m \e[35mneed\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804511
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryRabbit = number\
    \ - remaining\n        val hungryRabbits = hungryRabbit / need\n        val hungryRabbitsLeft\
    \ = hungryRabbit % need\n        val hungryRabbitsList = List(hungryRabbits)\n\
    \        if (hungryRabbitsLeft > 0) {\n            hungryRabbitsList :+ hungryRabbitsLeft\n\
    \        } else {\n            hungryRabbitsList\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzvmv2qth.scala:42)\n\tat Problem.main(tmpzvmv2qth.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new mutable.ListBuffer[Long]()\n        val carrots_left\
    \ = carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_to_eat = (carrots_left_to_eat\
    \ * needs_left_to_eat).toInt\n        val needs_to_eat = (needs_left_to_eat *\
    \ carrots_left_to_eat).toInt\n        val carrots_to_eat_left = carrots_to_eat\
    \ - remaining\n        val needs_to_eat_left = needs_to_eat - remaining\n    \
    \    val carrots_to_eat_left_to_eat = (carrots_to_eat_left / needs_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat = (needs_to_eat_left / carrots_to_eat_left).toInt\n\
    \        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat - remaining\n\
    \        val needs_to_eat_left_to_eat_left = needs_to_eat_left_to_eat - remaining\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat = (carrots_to_eat_left_to_eat_left\
    \ / needs_to_eat_left_to_eat_left).toInt\n        val needs_to_eat_left_to_eat_left_to_eat\
    \ = (needs_to_eat_left_to_eat_left / carrots_to_eat_left_to_eat_left).toInt\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat\
    \ - remaining\n        val needs_to_eat_left_to_eat_left_to_eat_left = needs_to_eat_left_to_eat_left_to_eat\
    \ - remaining\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left / needs_to_eat_left_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left_to_eat_left\
    \ / carrots_to_eat_left_to_eat_left_to_eat_left).toInt\n        val carrots_to_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8hba7umh.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8hba7umh.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp8hba7umh.scala:34:37 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m]\
    \ = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                                     ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp8hba7umh.scala:54:5 ---------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804514
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        val carrots_left = remaining\n\
    \        val carrots_left_after_meals = carrots - carrots_left\n        val carrots_left_after_meals_2\
    \ = carrots_left - carrots_left_after_meals\n        val carrots_left_after_meals_3\
    \ = carrots_left_after_meals - carrots_left_after_meals_2\n        val carrots_left_after_meals_4\
    \ = carrots_left_after_meals_3 - carrots_left_after_meals_2\n        val carrots_left_after_meals_5\
    \ = carrots_left_after_meals_4 - carrots_left_after_meals_3\n        val carrots_left_after_meals_6\
    \ = carrots_left_after_meals_5 - carrots_left_after_meals_4\n        val carrots_left_after_meals_7\
    \ = carrots_left_after_meals_6 - carrots_left_after_meals_5\n        val carrots_left_after_meals_8\
    \ = carrots_left_after_meals_7 - carrots_left_after_meals_6\n        val carrots_left_after_meals_9\
    \ = carrots_left_after_meals_8 - carrots_left_after_meals_7\n        val carrots_left_after_meals_10\
    \ = carrots_left_after_meals_9 - carrots_left_after_meals_8\n        val carrots_left_after_meals_11\
    \ = carrots_left_after_meals_10 - carrots_left_after_meals_9\n        val carrots_left_after_meals_12\
    \ = carrots_left_after_meals_11 - carrots_left_after_meals_10\n        val carrots_left_after_meals_13\
    \ = carrots_left_after_meals_12 - carrots_left_after_meals_11\n        val carrots_left_after_meals_14\
    \ = carrots_left_after_meals_13 - carrots_left_after_meals_12\n        val carrots_left_after_meals_15\
    \ = carrots_left_after_meals_14 - carrots_left_after_meals_13\n        val carrots_left_after_meals_16\
    \ = carrots_left_after_meals_15 - \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpw84ppsj5.scala:51:71 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_16\e\
    [0m = carrots_left_after_meals_15 - \n\e[31m\e[31m   |\e[0m                  \
    \                                                     ^\e[0m\n\e[31m   |\e[0m\
    \                                       expression expected but \e[31m'}'\e[0m\
    \ found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpw84ppsj5.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpw84ppsj5.scala:34:19 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpw84ppsj5.scala:52:5 ---------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804515
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_list = List(carrots_left.toLong)\n     \
    \   val needs_left_list = List(needs_left.toLong)\n        val carrots_left_list2\
    \ = List(carrots_left.toLong)\n        val needs_left_list2 = List(needs_left.toLong)\n\
    \        val carrots_left_list3 = List(carrots_left.toLong)\n        val needs_left_list3\
    \ = List(needs_left.toLong)\n        val carrots_left_list4 = List(carrots_left.toLong)\n\
    \        val needs_left_list4 = List(needs_left.toLong)\n        val carrots_left_list5\
    \ = List(carrots_left.toLong)\n        val needs_left_list5 = List(needs_left.toLong)\n\
    \        val carrots_left_list6 = List(carrots_left.toLong)\n        val needs_left_list6\
    \ = List(needs_left.toLong)\n        val carrots_left_list7 = List(carrots_left.toLong)\n\
    \        val needs_left_list7 = List(needs_left.toLong)\n        val carrots_left_list8\
    \ = List(carrots_left.toLong)\n        val needs_left_list8 = List(needs_left.toLong)\n\
    \        val carrots_left_list9 = List(carrots_left.toLong)\n        val needs_left_list9\
    \ = List(needs_left.toLong)\n        val carrots_left_list10 = List(carrots_left.toLong)\n\
    \        val needs_left_list10 = List(needs_left.toLong)\n        val carrots_left_list11\
    \ = List(carrots_left.toLong)\n        val needs_left_list11 = List(needs_left.toLong)\n\
    \        val carrots_left_list12 = List(carrots_left.toLong)\n        val needs_left_list12\
    \ = List(needs_left.toLong)\n        val carrots_left_list13 = List(carrots_left.toLong)\n\
    \        val needs_left_list13 = List(needs_left.toLong)\n        val carrots_left_list14\
    \ = List(carrots_left.toLong)\n        val needs_left_list14 = List(needs_left.toLong)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpof62_xb8.scala:64:11 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpof62_xb8.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpof62_xb8.scala:65:5\
    \ ---------------------\e[0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804515
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        var carrots_left =\
    \ remaining\n        var carrots_eaten = 0\n        while(carrots_left > 0 &&\
    \ carrots_eaten < needs) {\n            carrots_left -= carrots_eaten\n      \
    \      carrots_eaten += 1\n        }\n        if(carrots_left > 0) {\n       \
    \     carrots_eaten += needs - carrots_left\n        }\n        result ++= carrots_eaten.toLong\
    \ :: carrots.toLong\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjmxmlvct.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjmxmlvct.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804515
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - hungry\n        val hungryEaten = if\
    \ (hungryRemaining > 0) hungryRemaining else 0\n        val hungryEatenList =\
    \ List(hungryEaten.toLong)\n        val hungryEatenListWithRemaining = hungryEatenList\
    \ :+ hungryRemaining\n        val hungryEatenListWithRemainingWithRemaining =\
    \ hungryEatenListWithRemaining :+ remaining\n        val hungryEatenListWithRemainingWithRemainingWithRemaining\
    \ = hungryEatenListWithRemainingWithRemaining :+ hungryRemaining\n        val\
    \ hungryEatenListWithRemainingWithRemainingWithRemainingWithRemaining = hungryEatenListWithRemainingWithRemainingWithRemaining\
    \ :+ remaining\n        val hungryEatenListWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryEatenListWithRemainingWithRemainingWithRemainingWithRemaining :+ hungryRemaining\n\
    \        val hungryEatenListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryEatenListWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ :+ remaining\n        val hungryEatenListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryEatenListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ :+ hungryRemaining\n        val hungryEatenListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryEatenListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ :+ remaining\n        val hungryEatenListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\
    \ = hungryEatenListWithRemainingWith\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp986xs1j4.scala:43:147 -----------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mhungryEatenListWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemainingWithRemaining\e\
    [0m = hungryEatenListWithRemainingWith\n\e[31m\e[31m   |\e[0m                \
    \                                                                            \
    \                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: hungryEatenListWithRemainingWith\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp986xs1j4.scala:44:5\
    \ ---------------------\e[0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_to_eat = (carrots_left\
    \ / needs_left_to_eat).toInt\n        val needs_to_eat = (needs_left_to_eat /\
    \ carrots_to_eat).toInt\n        val carrots_to_eat_left = carrots_to_eat * needs_to_eat\n\
    \        val needs_to_eat_left = needs_to_eat * carrots_to_eat\n        val carrots_to_eat_left_to_eat\
    \ = (carrots_to_eat_left / needs_to_eat_left).toInt\n        val needs_to_eat_left_to_eat\
    \ = (needs_to_eat_left / carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat * needs_to_eat_left\n        val needs_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat * carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left / needs_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left\
    \ / carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat * needs_to_eat_left_to_eat_left\n \
    \       val needs_to_eat_left_to_eat_left_to_eat_left = needs_to_eat_left_to_eat_left_to_eat\
    \ * carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat / needs_to_eat_left_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left_to_eat\
    \ / car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppwf9ukye.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppwf9ukye.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmppwf9ukye.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppwf9ukye.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804519
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - remaining\n\
    \        val hungryCarrots = math.min(need, hungry)\n        val hungryCarrotsToEat\
    \ = math.min(hungry, remaining)\n        val hungryCarrotsToEatList = List(hungryCarrotsToEat.toLong)\n\
    \        val hungryCarrotsToEatList2 = List(hungryCarrotsToEat.toLong)\n     \
    \   val hungryCarrotsToEatList3 = List(hungryCarrotsToEat.toLong)\n        val\
    \ hungryCarrotsToEatList4 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList5\
    \ = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList6 = List(hungryCarrotsToEat.toLong)\n\
    \        val hungryCarrotsToEatList7 = List(hungryCarrotsToEat.toLong)\n     \
    \   val hungryCarrotsToEatList8 = List(hungryCarrotsToEat.toLong)\n        val\
    \ hungryCarrotsToEatList9 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList10\
    \ = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList11 = List(hungryCarrotsToEat.toLong)\n\
    \        val hungryCarrotsToEatList12 = List(hungryCarrotsToEat.toLong)\n    \
    \    val hungryCarrotsToEatList13 = List(hungryCarrotsToEat.toLong)\n        val\
    \ hungryCarrotsToEatList14 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList15\
    \ = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList16 = List(hungryCarrotsToEat.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn9aol_4f.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E051] Reference Error: /tmp/tmpn9aol_4f.scala:49:63\
    \ ------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryCarrotsToEatList16\e[0m = List(hungryCarrotsToEat.to\n\e[31m\e[31m \
    \  |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e\
    [0m \e[35mto\e[0m in \e[33mtrait\e[0m \e[35mIntegralProxy\e[0m with types\n\e\
    [31m   |\e[0m (end: Long, step: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\
    \e[31m   |\e[0m (end: Long): scala.collection.immutable.NumericRange.Inclusive[Long]\n\
    \e[31m   |\e[0mboth match expected type A\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn9aol_4f.scala:50:5 ---------------------\e[0m\e\
    [0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new mutable.ListBuffer[Long]()\n        var carrots_left\
    \ = remaining\n        while (carrots_left > 0) {\n            carrots_left -=\
    \ 1\n            if (carrots == 0) {\n                result.add(carrots)\n  \
    \          } else {\n                carrots -= 1\n            }\n        }\n\
    \        if (carrots_left > 0) {\n            carrots -= 1\n        }\n      \
    \  result.add(carrots)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppyzpg4ry.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppyzpg4ry.scala:34:37\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                     Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppyzpg4ry.scala:39:23\
    \ ------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                result.add(carrots)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \        value add is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmppyzpg4ry.scala:41:24 ------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m                carrots -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m       \
    \         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value -= is not a member\
    \ of Int - did you mean carrots.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppyzpg4ry.scala:45:20\
    \ ------------------------\e[0m\e[0m\n\e[31m45 |\e[0m            carrots -= \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \            value -= is not a member of Int - did you mean carrots.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmppyzpg4ry.scala:47:15 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        result.add(carrots)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue add is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31"
  stdout: ''
  timestamp: 1659804522
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        var carrots_left = remaining\n\
    \        while (carrots_left > 0) {\n            carrots_left -= 1\n         \
    \   list += carrots_left\n        }\n        list += carrots - list.last\n   \
    \     list += carrots - list.last\n        list += carrots - list.last\n     \
    \   list += carrots - list.last\n        list += carrots - list.last\n       \
    \ list += carrots - list.last\n        list += carrots - list.last\n        list\
    \ += carrots - list.last\n        list += carrots - list.last\n        list +=\
    \ carrots - list.last\n        list += carrots - list.last\n        list += carrots\
    \ - list.last\n        list += carrots - list.last\n        list += carrots -\
    \ list.last\n        list += carrots - list.last\n        list += carrots - list.last\n\
    \        list += carrots - list.last\n        list += carrots - list.last\n  \
    \      list += carrots - list.last\n        list += carrots - list.last\n    \
    \    list += carrots - list.last\n        list += carrots - list.last\n      \
    \  list += carrots - list.last\n        list += carrots - list.last\n        list\
    \ += carrots - list.last\n        list += carrots - list.last\n        list +=\
    \ carrots - list.last\n        list += carrots - list.last\n        list += carrots\
    \ - list.last\n        list += carrots - list.last\n        list += carrots -\
    \ list.last\n        list += carrots - list.last\n        list += carrots - list.last\n\
    \        list += carrots - list.last\n        list += carrots - list.last\n  \
    \      list += carrots - list.last\n        list += carrots - list.last\n    \
    \    list += carrots - list.last\n        list += carrots - list.last\n      \
    \  list += carrots - list.last\n        list += carrots - list.last\n        list\
    \ += carrots - list.last\n        list += carrots - list.last\n        list +=\
    \ carrots - list.last\n        list += carrots - list.last\n        list += carrots\
    \ - list.last\n        list += carrots - list.last\n        list += carrots -\
    \ list.last\n        list += carrots - list.last\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprpbatw4a.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprpbatw4a.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804516
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrotsLeft = remaining - carrots\n        val meals = List(carrots,\
    \ carrotsLeft)\n        meals\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7bi9jlq1.scala:37)\n\tat Problem.main(tmp7bi9jlq1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804522
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsList = List(meals.toLong)\n\
    \        val carrotsList = List(carrots.toLong)\n        val remainingList = List(remaining.toLong)\n\
    \        val result = mealsList ++ carrotsList ++ remainingList\n        result\
    \ match {\n            case Nil => List(number.toLong)\n            case x =>\
    \ x\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkfd24b7f.scala:43)\n\tat Problem.main(tmpkfd24b7f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804522
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = math.min(needs, carrots)\n        val lefts = math.min(remaining,\
    \ carrots)\n        val totalCarrots = carrots - meals\n        val leftCarrots\
    \ = remaining - lefts\n        val totalEaten = meals + lefts\n        val leftEaten\
    \ = lefts - meals\n        val totalLefts = leftCarrots + leftEaten\n        val\
    \ totalEatenCarrots = totalEaten.toLong\n        val leftEatenCarrots = leftEaten.toLong\n\
    \        val totalLeftCarrots = totalLefts.toLong\n        val totalEatenCarrots\
    \ = totalEatenCarrots.toLong\n        val leftEatenCarrots = leftEatenCarrots.toLong\n\
    \        val totalLeftCarrots = totalLeftCarrots.toLong\n        val totalEatenCarrots\
    \ = totalEatenCarrots.toLong\n        val leftEatenCarrots = leftEatenCarrots.toLong\n\
    \        val totalLeftCarrots = totalLeftCarrots.toLong\n        val totalEatenCarrots\
    \ = totalEatenCarrots.toLong\n        val leftEatenCarrots = leftEatenCarrots.toLong\n\
    \        val totalLeftCarrots = totalLeftCarrots.toLong\n        val totalEatenCarrots\
    \ = totalEatenCarrots.toLong\n        val leftEatenCarrots = leftEatenCarrots.toLong\n\
    \        val totalLeftCarrots = totalLeftCarrots.toLong\n        val totalEatenCarrots\
    \ = totalEatenCarrots.toLong\n        val leftEatenCarrots = leftEatenCarrots.toLong\n\
    \        val totalLeftCarrots = totalLeftCarrots.toLong\n        val totalEatenCarrots\
    \ = totalEatenCarrots.toLong\n        val leftEatenCarrots = leftEatenCarrots.toLong\n\
    \        val totalLeftCarrots = totalLeftCarrots.toLong\n        val totalEatenCarrots\
    \ = totalEatenCarrots.toLong\n        val leftEatenCarrots = leftEatenCarrots.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb7knqjaj.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpb7knqjaj.scala:44:12 ---------------------------\e[0m\e[0m\n\e[31m44\
    \ |\e[0m        \e[33mval\e[0m \e[36mtotalEatenCarrots\e[0m = totalEatenCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mtotalEatenCarrots is already defined as \e[33mvalue\e[0m \e\
    [35mtotalEatenCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpb7knqjaj.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mleftEatenCarrots\e[0m =\
    \ leftEatenCarrots.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftEatenCarrots is already defined as \e[33mvalue\e[0m \e\
    [35mleftEatenCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpb7knqjaj.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mtotalLeftCarrots\e[0m =\
    \ totalLeftCarrots.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mtotalLeftCarrots is already defined as \e[33mvalue\e[0m \e\
    [35mtotalLeftCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpb7knqjaj.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mtotalEatenCarrots\e[0m =\
    \ totalEatenCarrots.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mtotalEatenCarrots is already defined as \e[33mvalue\e[0m \e\
    [35mtotalEatenCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must "
  stdout: ''
  timestamp: 1659804521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new ListBuffer[Long]()\n        if (remaining ==\
    \ 0) {\n            result.add(carrots)\n        }\n        else {\n         \
    \   val carrots_left = carrots - remaining\n            val meals_left = meals\
    \ - carrots_left\n            if (carrots_left == 0) {\n                result.add(carrots)\n\
    \            }\n            else {\n                result.add(carrots_left)\n\
    \                result.add(meals_left)\n            }\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpzmbxy0xz.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzmbxy0xz.scala:34:33\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mListBuffer\e[0m[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m                     Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpzmbxy0xz.scala:36:19 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            result.add(carrots)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue add is not a member of List[Long],\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might fix the problem:\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection asJava\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzmbxy0xz.scala:42:23\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m                result.add(carrots)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue add\
    \ is not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m "
  stdout: ''
  timestamp: 1659804525
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_to_eat = carrots_left_to_eat\
    \ * needs_left_to_eat\n        val needs_to_eat = needs_left_to_eat * carrots_left_to_eat\n\
    \        val carrots_to_eat = (carrots_to_eat * needs_to_eat).toInt\n        val\
    \ needs_to_eat = (needs_to_eat * carrots_to_eat).toInt\n        val carrots_to_eat_left\
    \ = carrots_to_eat - carrots_to_eat\n        val needs_to_eat_left = needs_to_eat\
    \ - needs_to_eat\n        val carrots_to_eat_left_to_eat = (carrots_to_eat_left\
    \ / needs_to_eat_left).toInt\n        val needs_to_eat_left_to_eat = (needs_to_eat_left\
    \ / carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat = (carrots_to_eat_left_to_eat\
    \ * needs_to_eat_left_to_eat).toInt\n        val needs_to_eat_left_to_eat = (needs_to_eat_left_to_eat\
    \ * carrots_to_eat_left_to_eat).toInt\n        val carrots_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat - carrots_to_eat_left_to_eat\n        val needs_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat - needs_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left / needs_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left\
    \ / carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left\
    \ = (carrots_to_eat_left_to_eat_left_to_eat * needs_to_eat_left_to_eat_left_to_eat).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat_left = (need\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp30jokhrp.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp30jokhrp.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_to_eat\e[0m = (carrots_to_eat * needs_to_eat).toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_to_eat is already defined as \e[33mvalue\e[0m \e[35mcarrots_to_eat\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp30jokhrp.scala:42:12 ---------------------------\e[0m\e[0m\n\e\
    [31m42 |\e[0m        \e[33mval\e[0m \e[36mneeds_to_eat\e[0m = (needs_to_eat *\
    \ carrots_to_eat).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_to_eat is already defined as \e[33mvalue\e[0m \e[35mneeds_to_eat\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp30jokhrp.scala:47:12 ---------------------------\e[0m\e[0m\n\e\
    [31m47 |\e[0m        \e[33mval\e[0m \e[36mcarrots_to_eat_left_to_eat\e[0m = (carrots_to_eat_left_to_eat\
    \ * needs_to_eat_left_to_eat).toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_to_eat_left_to_eat is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_to_eat_left_to_eat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp30jokhrp.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mneeds_to_eat_left_to_eat\e\
    [0m = (needs_to_eat_left_to_eat * carrots_to_eat_left_to_eat).toInt\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659804522
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryCarrots = number\
    \ - remaining\n        val hungryCarrotsToEat = need - remaining\n        val\
    \ hungryCarrotsToEatList = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList2\
    \ = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList3 = List(hungryCarrotsToEat.toLong)\n\
    \        val hungryCarrotsToEatList4 = List(hungryCarrotsToEat.toLong)\n     \
    \   val hungryCarrotsToEatList5 = List(hungryCarrotsToEat.toLong)\n        val\
    \ hungryCarrotsToEatList6 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList7\
    \ = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList8 = List(hungryCarrotsToEat.toLong)\n\
    \        val hungryCarrotsToEatList9 = List(hungryCarrotsToEat.toLong)\n     \
    \   val hungryCarrotsToEatList10 = List(hungryCarrotsToEat.toLong)\n        val\
    \ hungryCarrotsToEatList11 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList12\
    \ = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList13 = List(hungryCarrotsToEat.toLong)\n\
    \        val hungryCarrotsToEatList14 = List(hungryCarrotsToEat.toLong)\n    \
    \    val hungryCarrotsToEatList15 = List(hungryCarrotsToEat.toLong)\n        val\
    \ hungryCarrotsToEatList16 = List(hungryCarrotsToEat.toLong)\n        val hungryCarrotsToEatList17\
    \ = List\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz6h5g67e.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804523
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftOver = remaining - carrots\n        val result = List(carrots.toLong,\
    \ leftOver.toLong)\n        if (leftOver > 0) {\n            val newRemaining\
    \ = remaining - carrots\n            val newNumber = number + need\n         \
    \   val newNeed = newNumber - newRemaining\n            val newResult = eat(newNumber,\
    \ newNeed, newRemaining)\n            result ::: newResult\n        } else {\n\
    \            result\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp3lgv7i4.scala:45)\n\tat Problem.main(tmpp3lgv7i4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        var carrots_left =\
    \ remaining\n        while (carrots_left > 0 && carrots > 0) {\n            carrots_left\
    \ -= 1\n            carrots -= 1\n            result.add(carrots)\n        }\n\
    \        if (carrots_left == 0) {\n            result.add(carrots)\n        }\n\
    \        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp3i2efnqy.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3i2efnqy.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp3i2efnqy.scala:38:20 ------------------------\e[0m\e[0m\n\e[31m38 |\e\
    [0m            carrots -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            value -= is not a member of Int - did you mean\
    \ carrots.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1659804523
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        val carrots_left = carrots\
    \ - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat\
    \ = carrots_left - needs_left\n        val needs_left_to_eat = needs_left - carrots_left\n\
    \        val carrots_to_eat = (carrots_left_to_eat + needs_left_to_eat) / 2\n\
    \        val needs_to_eat = (needs_left_to_eat + carrots_left_to_eat) / 2\n  \
    \      val carrots_to_eat_left = carrots_to_eat - needs_to_eat\n        val needs_to_eat_left\
    \ = needs_to_eat - carrots_to_eat\n        val carrots_to_eat_left_to_eat = carrots_to_eat_left\
    \ - needs_to_eat_left\n        val needs_to_eat_left_to_eat = needs_to_eat_left\
    \ - carrots_to_eat_left\n        val carrots_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat\
    \ - needs_to_eat_left_to_eat\n        val needs_to_eat_left_to_eat_left = needs_to_eat_left_to_eat\
    \ - carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat\
    \ = carrots_to_eat_left_to_eat_left - needs_to_eat_left_to_eat_left\n        val\
    \ needs_to_eat_left_to_eat_left_to_eat = needs_to_eat_left_to_eat_left - carrots_to_eat_left_to_eat_left\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left = carrots_to_eat_left_to_eat_left_to_eat\
    \ - needs_to_eat_left_to_eat_left_to_eat\n        val needs_to_eat_left_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat_left_to_eat - carrots_to_eat_left_to_eat_left_to_eat\n\
    \        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat = carrots_to_eat_left_to_eat_left_to_eat_left\
    \ - needs_to_eat_left_to_eat_left_to_eat_left\n        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = needs_to_eat_left_to_eat_left_to_eat_left - car\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpaa_bps0k.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaa_bps0k.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaa_bps0k.scala:53:5\
    \ ---------------------\e[0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val numCarrots = number.toInt\n\
    \        val needCarrots = need.toInt\n        val remainingCarrots = remaining.toInt\n\
    \        val carrotEaten = remainingCarrots - needCarrots\n        val carrotLeftAfterMeals\
    \ = numCarrots - carrotEaten\n        val carrotLeftAfterMealsString = carrotLeftAfterMeals.toString.toLong\n\
    \        val carrotLeftAfterMealsLong = Long.parseLong(carrotLeftAfterMealsString)\n\
    \        val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n \
    \       val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n  \
    \      val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n   \
    \     val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n    \
    \    val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n     \
    \   val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n      \
    \  val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n       \
    \ val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n        val\
    \ carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n        val carrotLeftAfterMealsLongList\
    \ = List(carrotLeftAfterMealsLong)\n        val carrotLeftAfterMealsLongList =\
    \ List(carrotLeftAfterMealsLong)\n        val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n\
    \        val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n \
    \       val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n  \
    \      val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n   \
    \     val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n    \
    \    val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n     \
    \   val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n      \
    \  val carrotLeftAfterMealsLongList = List(carrotLeftAfterMealsLong)\n       \
    \ val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmptwaxqmxe.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmptwaxqmxe.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mcarrotLeftAfterMealsLongList\e\
    [0m = List(carrotLeftAfterMealsLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotLeftAfterMealsLongList is already defined as \e[33mvalue\e\
    [0m \e[35mcarrotLeftAfterMealsLongList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptwaxqmxe.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrotLeftAfterMealsLongList\e\
    [0m = List(carrotLeftAfterMealsLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotLeftAfterMealsLongList is already defined as \e[33mvalue\e\
    [0m \e[35mcarrotLeftAfterMealsLongList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptwaxqmxe.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mcarrotLeftAfterMealsLongList\e\
    [0m = List(carrotLeftAfterMealsLong)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotLeftAfterMealsLongList is already defined as \e[33mvalue\e\
    [0m \e[35mcarrotLeftAfterMealsLongList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmptwaxqmxe.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mcarrotL"
  stdout: ''
  timestamp: 1659804524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n\
    \        val carrots = number - remaining\n        val carrots_left = need - carrots\n\
    \        val carrots_left_in_stock = remaining - carrots\n        val carrots_left_in_stock_in_stock\
    \ = carrots_left_in_stock - carrots_left\n        val carrots_left_in_stock_in_stock_in_stock\
    \ = carrots_left_in_stock_in_stock - carrots_left_in_stock\n        val carrots_left_in_stock_in_stock_in_stock_in_stock\
    \ = carrots_left_in_stock_in_stock_in_stock - carrots_left_in_stock_in_stock\n\
    \        val carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock = carrots_left_in_stock_in_stock_in_stock_in_stock\
    \ - carrots_left_in_stock_in_stock_in_stock_in_stock\n        val carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\
    \ = carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock - carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\n\
    \        val carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\
    \ = carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\
    \ - carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\n\
    \        val carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\
    \ = carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\
    \ - carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\n\
    \        val carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\
    \ = carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\
    \ - carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\n\
    \        val carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\
    \ = carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\
    \ - carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\n\
    \        val car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprguhrxlt.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprguhrxlt.scala:31:19\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprguhrxlt.scala:39:81\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\e[0m\
    \ = carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock - carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                         ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e\
    [35mcarrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprguhrxlt.scala:40:90\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\e\
    [0m = carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\
    \ - carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  carrots_left_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock_in_stock\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmprguhrxlt.scala:42:108 ---------------"
  stdout: ''
  timestamp: 1659804524
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots).toInt\n        val carrots_left_to_eat_2 = (carrots_left\
    \ / needs_left).toInt\n        val needs_left_to_eat_2 = (needs_left / carrots_left).toInt\n\
    \        val carrots_left_to_eat_3 = (carrots_left / needs_left_2).toInt\n   \
    \     val needs_left_to_eat_3 = (needs_left / carrots_left_2).toInt\n        val\
    \ carrots_left_to_eat_4 = (carrots_left / needs_left_3).toInt\n        val needs_left_to_eat_4\
    \ = (needs_left / carrots_left_3).toInt\n        val carrots_left_to_eat_5 = (carrots_left\
    \ / needs_left_4).toInt\n        val needs_left_to_eat_5 = (needs_left / carrots_left_4).toInt\n\
    \        val carrots_left_to_eat_6 = (carrots_left / needs_left_5).toInt\n   \
    \     val needs_left_to_eat_6 = (needs_left / carrots_left_5).toInt\n        val\
    \ carrots_left_to_eat_7 = (carrots_left / needs_left_6).toInt\n        val needs_left_to_eat_7\
    \ = (needs_left / carrots_left_6).toInt\n        val carrots_left_to_eat_8 = (carrots_left\
    \ / needs_left_7).toInt\n        val needs_left_to_eat_8 = (needs_left / carrots_left_7).toInt\n\
    \        val carrots_left_to_eat_9 = (carrots_left / needs_left_8).toInt\n   \
    \     val needs_left_to_eat_9 = (needs_left / carrots_left_8).toInt\n        val\
    \ carrots_left_to_eat_10 = (carrots_left / needs_left_9).toInt\n        val needs_left_to_eat_10\
    \ = (needs_left / carrots_left_9).toInt\n        val carrots_left_to_eat_11 =\
    \ (carrots_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpltaux2b8.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpltaux2b8.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpltaux2b8.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpltaux2b8.scala:57:38 ------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_11\e\
    [0m = (carrots_\n\e[31m\e[31m   |\e[0m                                      ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      Not found: carrots_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpltaux2b8.scala:58:5\
    \ ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659804525
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val left = (remaining - hungry).toLong\n        val hungryList = List(number.toLong,\
    \ need.toLong)\n        val leftList = List(left.toLong)\n        if (left <=\
    \ 0) {\n            hungryList :+ 0\n        } else {\n            hungryList\
    \ :+ left\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpotsdm_ku.scala:42)\n\tat Problem.main(tmpotsdm_ku.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - carrots\n        val result = List(carrots.toLong,\
    \ leftCarrots.toLong)\n        if (leftCarrots > 0) {\n            val newRemaining\
    \ = remaining - carrots\n            val newNumber = number - carrots\n      \
    \      val newNeed = need + carrots\n            val newResult = eat(newNumber,\
    \ newNeed, newRemaining)\n            result ::: newResult\n        } else {\n\
    \            result\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.collection.ArrayOps$ArrayIterator.<init>(ArrayOps.scala:125)\n\
    \tat scala.collection.ArrayOps$ArrayIterator$mcJ$sp.<init>(ArrayOps.scala:123)\n\
    \tat scala.collection.immutable.ArraySeq$ofLong.iterator(ArraySeq.scala:541)\n\
    \tat scala.collection.immutable.List.prependedAll(List.scala:151)\n\tat scala.collection.immutable.List$.from(List.scala:684)\n\
    \tat scala.collection.immutable.List$.from(List.scala:681)\n\tat scala.collection.IterableFactory.apply(Factory.scala:103)\n\
    \tat scala.collection.IterableFactory.apply$(Factory.scala:103)\n\tat scala.collection.immutable.List$.apply(List.scala:681)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:33)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38)\n\
    \tat Problem$.eat(tmpqta12ovl.scala:38)\n\tat Problem$.eat(tmpqta12ovl.scala:38"
  stdout: ''
  timestamp: 1659804528
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrots_left = remaining - carrots\n        val carrots_left_to_eat\
    \ = (carrots_left / carrots).toLong\n        val carrots_left_to_eat_2 = (carrots_left\
    \ % carrots).toLong\n        val carrots_left_to_eat_3 = (carrots_left % carrots).toLong\n\
    \        val carrots_left_to_eat_4 = (carrots_left % carrots).toLong\n       \
    \ val carrots_left_to_eat_5 = (carrots_left % carrots).toLong\n        val carrots_left_to_eat_6\
    \ = (carrots_left % carrots).toLong\n        val carrots_left_to_eat_7 = (carrots_left\
    \ % carrots).toLong\n        val carrots_left_to_eat_8 = (carrots_left % carrots).toLong\n\
    \        val carrots_left_to_eat_9 = (carrots_left % carrots).toLong\n       \
    \ val carrots_left_to_eat_10 = (carrots_left % carrots).toLong\n        val carrots_left_to_eat_11\
    \ = (carrots_left % carrots).toLong\n        val carrots_left_to_eat_12 = (carrots_left\
    \ % carrots).toLong\n        val carrots_left_to_eat_13 = (carrots_left % carrots).toLong\n\
    \        val carrots_left_to_eat_14 = (carrots_left % carrots).toLong\n      \
    \  val carrots_left_to_eat_15 = (carrots_left % carrots).toLong\n        val carrots_left_to_eat_16\
    \ = (carrots_left % carrots).toLong\n        val carrots_left_to_eat_17 = (carrots_left\
    \ % carrots).toLong\n        val carrots_left_to_eat_18 = (carrots_left % carrots).toLong\n\
    \        val carrots_left_to_eat_19 = (carrots_left % carrots).toLong\n      \
    \  val carrots_left_to_eat_20 = (carrots_left % carrots).toLong\n        val carrots_left_to_eat_21\
    \ = (carrots_left % carrots).toLong\n        val carrots_left_to_eat_22 = (carrots_left\
    \ % carrots).toLong\n        val carrots_left_to_e\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsh_21m49.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpsh_21m49.scala:56:5 ---------------------\e[0m\e[0m\n\e[31m56 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = ListBuffer[Long]()\n        if (remaining > 0) {\n        \
    \    val carrots_left = carrots - remaining\n            val meals_left = meals\
    \ - remaining\n            val carrots_left_after_meals = carrots_left - meals\n\
    \            val meals_left_after_meals = meals_left - carrots_left\n        \
    \    val carrots_left_after_meals_after_meals = carrots_left_after_meals - meals_left\n\
    \            val meals_left_after_meals_after_meals = meals_left_after_meals -\
    \ carrots_left_after_meals\n            val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals - meals_left_after_meals\n          \
    \  val meals_left_after_meals_after_meals_after_meals = meals_left_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals\n            val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - meals_left_after_meals_after_meals\n\
    \            val meals_left_after_meals_after_meals_after_meals_after_meals =\
    \ meals_left_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals\n\
    \            val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals - meals_left_after_meals_after_meals_after_meals\n\
    \            val meals_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = meals_left_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals\n\
    \            val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5i4f1tuq.scala:60:0 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5i4f1tuq.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp5i4f1tuq.scala:48:103 -----------------------\e[0m\e[0m\n\e[31m48 |\e\
    [0m            \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_\n\e[31m\e[31m   |\e[0m           \
    \                                                                            \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                       Not found: carrots_left_after_meals_after_meals_\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5i4f1tuq.scala:59:1 ---------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmp5i4f1tuq.scala:50:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m50 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659804527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_to_eat = (carrots_left\
    \ % needs_left).toInt\n        val needs_to_eat = (needs_left % carrots_left).toInt\n\
    \        val carrots_to_eat_left = carrots_to_eat * needs_to_eat\n        val\
    \ needs_to_eat_left = needs_to_eat * carrots_to_eat\n        val carrots_to_eat_left_to_eat\
    \ = (carrots_to_eat_left / needs_to_eat_left).toInt\n        val needs_to_eat_left_to_eat\
    \ = (needs_to_eat_left / carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat * needs_to_eat_left\n        val needs_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat * carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left / needs_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left\
    \ / carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat * needs_to_eat_left_to_eat_left\n \
    \       val needs_to_eat_left_to_eat_left_to_eat_left = needs_to_eat_left_to_eat_left_to_eat\
    \ * carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left / needs_to_eat_left_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left_to_eat_left\
    \ / carrots_to_e\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0r7li5pi.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0r7li5pi.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp0r7li5pi.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0r7li5pi.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = carrots - meals\n\
    \        val lefts = remaining - meals\n        val list = List[Long](meals.toLong,\
    \ hungry.toLong)\n        if (hungry > 0) {\n            list :+ eat(lefts, needs,\
    \ remaining)\n        } else {\n            list\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmjllfoyd.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmjllfoyd.scala:39:23\
    \ --------------------\e[0m\e[0m\n\e[31m39 |\e[0m            list :+ eat(lefts,\
    \ needs, remaining)\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Found:    \e[1m\e[31mList\e[0m\e[1m\e\
    [31m[\e[0mLong\e[1m\e[31m]\e[0m\n\e[31m   |\e[0m                    Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val totalCarrots = carrots - remaining\n        val carrotLeft = meals -\
    \ totalCarrots\n        val carrotLeftList = List(carrotLeft.toLong)\n       \
    \ val carrotLeftList2 = List(carrotLeft)\n        val carrotLeftList3 = List(carrotLeftList2)\n\
    \        val carrotLeftList4 = List(carrotLeftList3)\n        val carrotLeftList5\
    \ = List(carrotLeftList4)\n        val carrotLeftList6 = List(carrotLeftList5)\n\
    \        val carrotLeftList7 = List(carrotLeftList6)\n        val carrotLeftList8\
    \ = List(carrotLeftList7)\n        val carrotLeftList9 = List(carrotLeftList8)\n\
    \        val carrotLeftList10 = List(carrotLeftList9)\n        val carrotLeftList11\
    \ = List(carrotLeftList10)\n        val carrotLeftList12 = List(carrotLeftList11)\n\
    \        val carrotLeftList13 = List(carrotLeftList12)\n        val carrotLeftList14\
    \ = List(carrotLeftList13)\n        val carrotLeftList15 = List(carrotLeftList14)\n\
    \        val carrotLeftList16 = List(carrotLeftList15)\n        val carrotLeftList17\
    \ = List(carrotLeftList16)\n        val carrotLeftList18 = List(carrotLeftList17)\n\
    \        val carrotLeftList19 = List(carrotLeftList18)\n        val carrotLeftList20\
    \ = List(carrotLeftList19)\n        val carrotLeftList21 = List(carrotLeftList20)\n\
    \        val carrotLeftList22 = List(carrotLeftList21)\n        val carrotLeftList23\
    \ = List(carrotLeftList22)\n        val carrotLeftList24 = List(carrotLeftList23)\n\
    \        val carrotLeftList25 = List(carrotLeftList24)\n        val carrotLeftList26\
    \ = List(carrotLeftList25)\n        val carrotLeftList27 = List(carrotLeftList26)\n\
    \        val carrotLeftList28 = List(carrotLeftList27)\n        val carrotLeftList29\
    \ = List(carrotLeftList28)\n        val carrot\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2hrcg39e.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2hrcg39e.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp2hrcg39e.scala:66:5 ---------------------\e[0m\e[0m\n\e[31m66\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804528
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ remaining - carrots\n        val needs_left = carrots - need\n        val needs_left_in_stock\
    \ = needs_left / need\n        val carrots_left_in_stock = carrots_left / carrots\n\
    \        val needs_left_in_stock2 = needs_left_in_stock.toInt\n        val carrots_left_in_stock2\
    \ = carrots_left_in_stock.toInt\n        val needs_left_in_stock3 = needs_left_in_stock2\
    \ * needs_left_in_stock\n        val carrots_left_in_stock3 = carrots_left_in_stock2\
    \ * carrots_left_in_stock\n        val needs_left_in_stock4 = needs_left_in_stock3\
    \ * needs_left_in_stock\n        val carrots_left_in_stock4 = carrots_left_in_stock3\
    \ * carrots_left_in_stock\n        val needs_left_in_stock5 = needs_left_in_stock4\
    \ * needs_left_in_stock\n        val carrots_left_in_stock5 = carrots_left_in_stock4\
    \ * carrots_left_in_stock\n        val needs_left_in_stock6 = needs_left_in_stock5\
    \ * needs_left_in_stock\n        val carrots_left_in_stock6 = carrots_left_in_stock5\
    \ * carrots_left_in_stock\n        val needs_left_in_stock7 = needs_left_in_stock6\
    \ * needs_left_in_stock\n        val carrots_left_in_stock7 = carrots_left_in_stock6\
    \ * carrots_left_in_stock\n        val needs_left_in_stock8 = needs_left_in_stock7\
    \ * needs_left_in_stock\n        val carrots_left_in_stock8 = carrots_left_in_stock7\
    \ * carrots_left_in_stock\n        val needs_left_in_stock9 = needs_left_in_stock8\
    \ * needs_left_in_stock\n        val carrots_left_in_stock9 = carrots_left_in_stock8\
    \ * carrots_left_in_stock\n        val needs_left_in_stock10 = needs_left_in_stock9\
    \ * needs_left_in_stock\n        val carrots_left_in_stock10 = carrots_left_in_stock9\
    \ * carrots_left_in_stock\n        val needs_left_in_stock11 = needs_left_in_stock10\
    \ * needs_left_in_stock\n        val carrots_left_in_stock11 = carrots_left_in_stock10\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpugkzvs92.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpugkzvs92.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpugkzvs92.scala:59:5 ---------------------\e[0m\e[0m\n\e[31m59\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804529
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remainingCarrots = remaining - carrots\n        if (remainingCarrots\
    \ == 0) {\n            List(number.toLong)\n        } else {\n            val\
    \ newRemaining = remainingCarrots - 1\n            val newNumber = number + need\n\
    \            val newNeed = newNumber - newRemaining\n            val newRemainingCarrots\
    \ = newRemaining - 1\n            val newCarrots = newNumber - newNeed\n     \
    \       val newList: List[Long] = List(newCarrots.toLong, newRemainingCarrots.toLong)\n\
    \            newList\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8lv6684z.scala:46)\n\tat Problem.main(tmp8lv6684z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val remain = math.min(number,\
    \ remaining)\n        val needn = math.min(need, remain)\n        val remaining\
    \ = math.max(0, remaining - needn)\n        val list = mutable.ListBuffer[Long]()\n\
    \        val carrots = math.max(0, number - need)\n        val carrots = math.max(0,\
    \ carrots)\n        val carrots = math.max(0, carrots)\n        val carrots =\
    \ math.max(0, carrots)\n        val carrots = math.max(0, carrots)\n        val\
    \ carrots = math.max(0, carrots)\n        val carrots = math.max(0, carrots)\n\
    \        val carrots = math.max(0, carrots)\n        val carrots = math.max(0,\
    \ carrots)\n        val carrots = math.max(0, carrots)\n        val carrots =\
    \ math.max(0, carrots)\n        val carrots = math.max(0, carrots)\n        val\
    \ carrots = math.max(0, carrots)\n        val carrots = math.max(0, carrots)\n\
    \        val carrots = math.max(0, carrots)\n        val carrots = math.max(0,\
    \ carrots)\n        val carrots = math.max(0, carrots)\n        val carrots =\
    \ math.max(0, carrots)\n        val carrots = math.max(0, carrots)\n        val\
    \ carrots = math.max(0, carrots)\n        val carrots = math.max(0, carrots)\n\
    \        val carrots = math.max(0, carrots)\n        val carrots = math.max(0,\
    \ carrots)\n        val carrots = math.max(0, carrots)\n        val carrots =\
    \ math.max(0, carrots)\n        val carrots = math.max(0, carrots)\n        val\
    \ carrots = math.max(0, carrots)\n        val carrots = math.max(0, carrots)\n\
    \        val carrots = math.max(0, carrots)\n        val carrots = math.max(0,\
    \ carrots)\n        val carrots = math.max(0, carrots)\n        val carrots =\
    \ math.max(0, carrots)\n        val carrots = math.max(0, carrots)\n        val\
    \ carrots = math.max(0, carrots)\n        val carrots = math.max(0, carrots)\n\
    \        val carrots = math.max(0, carrots)\n        val carrots = math.max(0,\
    \ carrots)\n        val carrots = math.max(0, carrots)\n        val carrots =\
    \ math.max(0, carrots)\n        val carrots = math.max(0, carrots)\n        val\
    \ carrots = math.max(0, carrots)\n        val carrots = math.max(0, carrots)\n\
    \        val carrots = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6isfa6q0.scala:77:21 ---------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = \n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp6isfa6q0.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = math.max(\e\
    [31m0\e[0m, carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6isfa6q0.scala:37:12 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = math.max(\e[31m0\e[0m,\
    \ carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6isfa6q0.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = math.max(\e[31m0\e[0m,\
    \ carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp6isfa6q0.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = math.max(\e[31m0\e[0m,\
    \ carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overlo"
  stdout: ''
  timestamp: 1659804531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n\
    \        var carrots = number\n        while (carrots > 0 && carrots <= 1000 &&\
    \ carrots <= remaining) {\n            list += carrots\n            carrots -=\
    \ need\n        }\n        list += carrots\n        list.takeWhile(_ <= remaining).toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpccz8kuzv.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804528
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val remainingCarrots = remaining\
    \ - carrots\n        val hungry = carrots > 0\n        val hungryCarrots = carrots\
    \ - hungry\n        val hungryMeals = meals - hungryCarrots\n        val hungryRemainingCarrots\
    \ = remainingCarrots - hungryCarrots\n        val hungryRemainingMeals = remainingMeals\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals2 = hungryRemainingMeals\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals3 = hungryRemainingMeals2\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals4 = hungryRemainingMeals3\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals5 = hungryRemainingMeals4\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals6 = hungryRemainingMeals5\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals7 = hungryRemainingMeals6\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals8 = hungryRemainingMeals7\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals9 = hungryRemainingMeals8\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals10 = hungryRemainingMeals9\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals11 = hungryRemainingMeals10\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals12 = hungryRemainingMeals11\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals13 = hungryRemainingMeals12\
    \ - hungryRemainingCarrots\n        val hungryRemainingMeals14 = hungry\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpqufven6r.scala:35:36 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = carrots\
    \ - hungry\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\
    \e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e\
    [0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments\
    \ ((hungry : Boolean))\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqufven6r.scala:38:35\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryRemainingMeals\e[0m = remainingMeals - hungryRemainingCarrots\n\e[31m\e\
    [31m   |\e[0m                                   ^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                   Not found: remainingMeals\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqufven6r.scala:52:5 ---------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val left  = remaining - need\n        val list = mutable.ListBuffer.empty[Long]\n\
    \        if (hungry > 0) list += hungry\n        if (left > 0) list += left\n\
    \        list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp78n53whz.scala:33:19 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659804529
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = carrots_left - needs_left\n        val needs_left_to_eat\
    \ = needs_left - carrots_left\n        val carrots_left_to_eat2 = carrots_left_to_eat.toInt\n\
    \        val needs_left_to_eat2 = needs_left_to_eat.toInt\n        val carrots_left_to_eat3\
    \ = carrots_left_to_eat2.toInt\n        val needs_left_to_eat3 = needs_left_to_eat2.toInt\n\
    \        val carrots_left_to_eat4 = carrots_left_to_eat3.toInt\n        val needs_left_to_eat4\
    \ = needs_left_to_eat3.toInt\n        val carrots_left_to_eat5 = carrots_left_to_eat4.toInt\n\
    \        val needs_left_to_eat5 = needs_left_to_eat4.toInt\n        val carrots_left_to_eat6\
    \ = carrots_left_to_eat5.toInt\n        val needs_left_to_eat6 = needs_left_to_eat5.toInt\n\
    \        val carrots_left_to_eat7 = carrots_left_to_eat6.toInt\n        val needs_left_to_eat7\
    \ = needs_left_to_eat6.toInt\n        val carrots_left_to_eat8 = carrots_left_to_eat7.toInt\n\
    \        val needs_left_to_eat8 = needs_left_to_eat7.toInt\n        val carrots_left_to_eat9\
    \ = carrots_left_to_eat8.toInt\n        val needs_left_to_eat9 = needs_left_to_eat8.toInt\n\
    \        val carrots_left_to_eat10 = carrots_left_to_eat9.toInt\n        val needs_left_to_eat10\
    \ = needs_left_to_eat9.toInt\n        val carrots_left_to_eat11 = carrots_left_to_eat10.toInt\n\
    \        val needs_left_to_eat11 = needs_left_to_eat10.toInt\n        val carrots_left_to_eat12\
    \ = carrots_left_to_eat11.toInt\n        val needs_left_to_eat12 = needs_left_to_eat11.toInt\n\
    \        val carrots_left_to_eat13 = carrots_left_to_eat12.toInt\n        val\
    \ needs_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjia9l8yc.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjia9l8yc.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpjia9l8yc.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjia9l8yc.scala:63:5 ---------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        var carrots_left =\
    \ remaining\n        var carrots_eaten = 0\n        while(true) {\n          \
    \  if(carrots_left == 0) {\n                carrots_eaten = carrots_eaten + carrots_left\n\
    \                carrots_left = 0\n            }\n            if(carrots_eaten\
    \ >= needs) {\n                result.add(carrots_eaten)\n                carrots_eaten\
    \ = 0\n                carrots_left = carrots - carrots_eaten\n            } else\
    \ {\n                carrots_eaten = carrots_eaten + 1\n                carrots_left\
    \ = carrots - carrots_eaten\n            }\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwet9ld4k.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwet9ld4k.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804529
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val needs_left = needs -\
    \ remaining\n        val carrots_left_to_eat = (carrots_left / needs_left).toInt\n\
    \        val needs_left_to_eat = (needs_left / carrots_left).toInt\n        val\
    \ carrots_to_eat = (carrots_left_to_eat * needs_left_to_eat).toInt\n        val\
    \ needs_to_eat = (needs_left_to_eat * carrots_left_to_eat).toInt\n        val\
    \ carrots_to_eat_left = carrots_to_eat - remaining\n        val needs_to_eat_left\
    \ = needs_to_eat - remaining\n        val carrots_to_eat_left_to_eat = (carrots_to_eat_left\
    \ / needs_to_eat_left).toInt\n        val needs_to_eat_left_to_eat = (needs_to_eat_left\
    \ / carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left =\
    \ carrots_to_eat_left_to_eat - remaining\n        val needs_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat - remaining\n        val carrots_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left / needs_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left\
    \ / carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat - remaining\n        val needs_to_eat_left_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat_left_to_eat - remaining\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat_left / needs_to_eat_left_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left_to_eat_left\
    \ / carrots_to_eat_left_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left\
    \ = car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnf4zqayl.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnf4zqayl.scala:52:70\
    \ ------------------------\e[0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_to_eat_left_to_eat_left_to_eat_left_to_eat_left\e[0m = car\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \      ^^^\e[0m\n\e[31m   |\e[0m                                             \
    \             Not found: car\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpnf4zqayl.scala:53:5 ---------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804532
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val carrots_left = carrots - meals\n\
    \        val carrots_left_after = carrots - needs - meals\n        val carrots_left_after_meals\
    \ = carrots - needs - remaining\n        val carrots_left_after_meals_after =\
    \ carrots - needs - remaining - meals\n        val carrots_left_after_meals_after_meals\
    \ = carrots - needs - remaining - meals - meals\n        val carrots_left_after_meals_after_meals_after\
    \ = carrots - needs - remaining - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots - needs - remaining - meals - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after\
    \ = carrots - needs - remaining - meals - meals - meals - meals - meals\n    \
    \    val carrots_left_after_meals_after_meals_after_meals_after_meals = carrots\
    \ - needs - remaining - meals - meals - meals - meals - meals - meals\n      \
    \  val carrots_left_after_meals_after_meals_after_meals_after_meals_after = carrots\
    \ - needs - remaining - meals - meals - meals - meals - meals - meals - meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots - needs - remaining - meals - meals - meals - meals - meals - meals\
    \ - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after\
    \ = carrots - needs - remaining - meals - meals - meals - meals - meals - meals\
    \ - meals - meals - meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots - needs - remaining - meals - meals - meals - meals - me\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphwzl4mbr.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphwzl4mbr.scala:48:5\
    \ ---------------------\e[0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result: List[Long] = new ListBuffer[Long]\n        if (remaining > carrots)\
    \ {\n            val remaining = remaining - carrots\n            val needs =\
    \ needs + 1\n            val result = result :+ carrots\n        }\n        if\
    \ (remaining < needs) {\n            val remaining = remaining + needs - carrots\n\
    \            val needs = needs + 1\n            val result = result :+ remaining\n\
    \        }\n        if (remaining == 0) {\n            val result = result :+\
    \ 0\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpogc3pa2l.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpogc3pa2l.scala:34:33\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mListBuffer\e[0m[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\
    \e[31m   |\e[0m                     Required: List[Long]\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpogc3pa2l.scala:36:28 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m \
    \  |\e[0m                            Recursive \e[33mvalue\e[0m \e[35mremaining\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpogc3pa2l.scala:37:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36mneeds\e[0m = needs + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m           \
    \             ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mneeds\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpogc3pa2l.scala:38:25 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m            \e[33mval\e[0m \e[36mresult\e[0m = result :+ carrots\n\e[31m\e\
    [31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m                \
    \         Recursive \e[33mvalue\e[0m \e[35mresult\e[0m need"
  stdout: ''
  timestamp: 1659804534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining > 0)\
    \ {\n            val remaining = remaining - carrots\n            val needs =\
    \ needs - carrots\n            if (needs > 0) {\n                val need = needs.toInt\n\
    \                val result = new mutable.ListBuffer[Long]()\n               \
    \ val carrots = carrots + need\n                val remaining = remaining - need\n\
    \                result.add(carrots)\n                result.add(remaining)\n\
    \            }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx4pymxos.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx4pymxos.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpx4pymxos.scala:36:28 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m            \e[33mval\e[0m \e[36mremaining\e[0m = remaining - carrots\n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx4pymxos.scala:37:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36mneeds\e[0m = needs - carrots\n\e[31m\e[31m   |\e[0m                \
    \        ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mneeds\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpx4pymxos.scala:40:33 ------------------------\e[0m\e[0m\n\e[31m40 |\e\
    [0m                \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045"
  stdout: ''
  timestamp: 1659804531
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val mealsRemainingInt = mealsRemaining.toInt\n        val mealsRemainingLong\
    \ = mealsRemaining.toLong\n        val mealsRemainingDouble = mealsRemaining.toDouble\n\
    \        val mealsRemainingFloat = mealsRemaining.toFloat\n        val mealsRemainingInt\
    \ = mealsRemainingInt.toInt\n        val mealsRemainingLong = mealsRemainingLong.toLong\n\
    \        val mealsRemainingDouble = mealsRemainingDouble.toDouble\n        val\
    \ mealsRemainingFloat = mealsRemainingFloat.toFloat\n        val mealsRemainingInt\
    \ = mealsRemainingInt.toInt\n        val mealsRemainingLong = mealsRemainingLong.toLong\n\
    \        val mealsRemainingDouble = mealsRemainingDouble.toDouble\n        val\
    \ mealsRemainingFloat = mealsRemainingFloat.toFloat\n        val mealsRemainingInt\
    \ = mealsRemainingInt.toInt\n        val mealsRemainingLong = mealsRemainingLong.toLong\n\
    \        val mealsRemainingDouble = mealsRemainingDouble.toDouble\n        val\
    \ mealsRemainingFloat = mealsRemainingFloat.toFloat\n        val mealsRemainingInt\
    \ = mealsRemainingInt.toInt\n        val mealsRemainingLong = mealsRemainingLong.toLong\n\
    \        val mealsRemainingDouble = mealsRemainingDouble.toDouble\n        val\
    \ mealsRemainingFloat = mealsRemainingFloat.toFloat\n        val mealsRemainingInt\
    \ = mealsRemainingInt.toInt\n        val mealsRemainingLong = mealsRemainingLong.toLong\n\
    \        val mealsRemainingDouble = mealsRemainingDouble.toDouble\n        val\
    \ mealsRemainingFloat = mealsRemainingFloat.toFloat\n        val mealsRemainingInt\
    \ = mealsRemainingInt.toInt\n        val mealsRemainingLong = mealsRemainingLong.toLong\n\
    \        val mealsRemainingDouble = mealsRemainingDouble.toDouble\n        val\
    \ mealsRemainingFloat = mealsRemainingFloat.toFloat\n        val mealsRemainingInt\
    \ = mealsRemainingInt.toInt\n        val mealsRemainingLong = mealsRemainingLong.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpll2j5mcu.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingInt\e[0m =\
    \ mealsRemainingInt.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingInt is already defined as \e[33mvalue\e[0m \e\
    [35mmealsRemainingInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpll2j5mcu.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingLong\e[0m\
    \ = mealsRemainingLong.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingLong is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsRemainingLong\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpll2j5mcu.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingDouble\e[0m\
    \ = mealsRemainingDouble.toDouble\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingDouble is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsRemainingDouble\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpll2j5mcu.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingFloat\e[0m\
    \ = mealsRemainingFloat.toFloat\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingFloat is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsRemainingFloat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpll2j5mcu.scala:42:12 ---------------------------\e\
    ["
  stdout: ''
  timestamp: 1659804534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        val carrots_left = carrots\
    \ - remaining\n        val needs_left = needs - remaining\n        val carrots_left\
    \ = carrots_left.toLong\n        val needs_left = needs_left.toLong\n        val\
    \ needs_left_carrots = needs_left * carrots_left\n        val needs_left_carrots_left\
    \ = needs_left_carrots - carrots_left\n        val needs_left_carrots_left_carrots\
    \ = needs_left_carrots_left * carrots_left\n        val needs_left_carrots_left_carrots_left\
    \ = needs_left_carrots_left_carrots - carrots_left\n        val needs_left_carrots_left_carrots_left_carrots\
    \ = needs_left_carrots_left_carrots_left * carrots_left\n        val needs_left_carrots_left_carrots_left_carrots_left\
    \ = needs_left_carrots_left_carrots_left_carrots - carrots_left\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots\
    \ = needs_left_carrots_left_carrots_left_carrots_left * carrots_left\n       \
    \ val needs_left_carrots_left_carrots_left_carrots_left_carrots_left = needs_left_carrots_left_carrots_left_carrots_left_carrots\
    \ - carrots_left\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots\
    \ = needs_left_carrots_left_carrots_left_carrots_left_carrots_left * carrots_left\n\
    \        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\
    \ = needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots - carrots_left\n\
    \        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots\
    \ = needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\
    \ * carrots_left\n        val needs_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpszbd95c2.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpszbd95c2.scala:37:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left\e[0m = carrots_left.toLong\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots_left is\
    \ already defined as \e[33mvalue\e[0m \e[35mcarrots_left\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpszbd95c2.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mneeds_left\e[0m = needs_left.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mneeds_left is already defined as \e[33mvalue\e[0m \e[35mneeds_left\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpszbd95c2.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpszbd95c2.scala:34:19 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpszbd95c2.scala:51:5 ---------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Re"
  stdout: ''
  timestamp: 1659804534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = carrots_left - needs_left\n        val needs_left_to_eat\
    \ = needs_left - carrots_left\n        val carrots_left_to_eat2 = carrots_left\
    \ - needs_left_to_eat\n        val needs_left_to_eat2 = needs_left - carrots_left_to_eat\n\
    \        val carrots_left_to_eat3 = carrots_left - needs_left_to_eat2\n      \
    \  val needs_left_to_eat3 = needs_left - carrots_left_to_eat2\n        val carrots_left_to_eat4\
    \ = carrots_left - needs_left_to_eat3\n        val needs_left_to_eat4 = needs_left\
    \ - carrots_left_to_eat3\n        val carrots_left_to_eat5 = carrots_left - needs_left_to_eat4\n\
    \        val needs_left_to_eat5 = needs_left - carrots_left_to_eat4\n        val\
    \ carrots_left_to_eat6 = carrots_left - needs_left_to_eat5\n        val needs_left_to_eat6\
    \ = needs_left - carrots_left_to_eat5\n        val carrots_left_to_eat7 = carrots_left\
    \ - needs_left_to_eat6\n        val needs_left_to_eat7 = needs_left - carrots_left_to_eat6\n\
    \        val carrots_left_to_eat8 = carrots_left - needs_left_to_eat7\n      \
    \  val needs_left_to_eat8 = needs_left - carrots_left_to_eat7\n        val carrots_left_to_eat9\
    \ = carrots_left - needs_left_to_eat8\n        val needs_left_to_eat9 = needs_left\
    \ - carrots_left_to_eat8\n        val carrots_left_to_eat10 = carrots_left - needs_left_to_eat9\n\
    \        val needs_left_to_eat10 = needs_left - carrots_left_to_eat9\n       \
    \ val carrots_left_to_eat11 = carrots_left - needs_left_to_eat10\n        val\
    \ needs_left_to_eat11 = needs_left - carrots_left_to_eat10\n        val carrots_left_to_eat12\
    \ = car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp88jvvshk.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp88jvvshk.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp88jvvshk.scala:59:36 ------------------------\e[0m\e[0m\n\e[31m59 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat12\e[0m = car\n\e[31m\e[31m\
    \   |\e[0m                                    ^^^\e[0m\n\e[31m   |\e[0m      \
    \                              Not found: car\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp88jvvshk.scala:60:5 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804533
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val meals = carrots - remaining\n        val hungry = carrots % needs ==\
    \ 0\n        val hungryList = if (hungry) List(meals, remaining) else List(0,\
    \ meals)\n        val hungryListString = hungryList.map(_.toString).mkString(\"\
    ,\")\n        val hungryListLong = hungryList.map(_.toLong).mkString(\",\")\n\
    \        val hungryListString = if (hungryListLong.isEmpty) hungryListString else\
    \ hungryListLong\n        val hungryListLong = if (hungryListString.isEmpty) hungryListLong\
    \ else hungryListString\n        val hungryListString = if (hungryListLong.isEmpty)\
    \ hungryListString else hungryListLong\n        val hungryListLong = if (hungryListString.isEmpty)\
    \ hungryListLong else hungryListString\n        val hungryListString = if (hungryListLong.isEmpty)\
    \ hungryListString else hungryListLong\n        val hungryListLong = if (hungryListString.isEmpty)\
    \ hungryListLong else hungryListString\n        val hungryListString = if (hungryListLong.isEmpty)\
    \ hungryListString else hungryListLong\n        val hungryListLong = if (hungryListString.isEmpty)\
    \ hungryListLong else hungryListString\n        val hungryListString = if (hungryListLong.isEmpty)\
    \ hungryListString else hungryListLong\n        val hungryListLong = if (hungryListString.isEmpty)\
    \ hungryListLong else hungryListString\n        val hungryListString = if (hungryListLong.isEmpty)\
    \ hungryListString else hungryListLong\n        val hungryListLong = if (hungryListString.isEmpty)\
    \ hungryListLong else hungryListString\n        val hungryListString = if (\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpebie2gyb.scala:51:35 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36mhungryListString\e[0m =\
    \ \e[33mif\e[0m (\n\e[31m\e[31m   |\e[0m                                   ^\e\
    [0m\n\e[31m   |\e[0m                                   expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpebie2gyb.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryListString\e[0m = \e[33mif\e[0m (hungryListLong.isEmpty) hungryListString\
    \ \e[33melse\e[0m hungryListLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryListString is already defined as \e[33mvalue\e[0m \e\
    [35mhungryListString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpebie2gyb.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mhungryListLong\e[0m = \e\
    [33mif\e[0m (hungryListString.isEmpty) hungryListLong \e[33melse\e[0m hungryListString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryListLong is already defined as \e[33mvalue\e[0m \e[35mhungryListLong\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpebie2gyb.scala:41:12 ---------------------------\e[0m\e[0m\n\e\
    [31m41 |\e[0m        \e[33mval\e[0m \e[36mhungryListString\e[0m = \e[33mif\e[0m\
    \ (hungryListLong.isEmpty) hungryListString \e[33melse\e[0m hungryListLong\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryListString is already defined as \e[33mvalue\e[0m \e\
    [35mhungryListString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that o"
  stdout: ''
  timestamp: 1659804535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = ListBuffer[Long]()\n        val carrots_left = carrots - remaining\n\
    \        val meals_left = meals - remaining\n        if (meals_left == 0) {\n\
    \            result += (meals.toLong)\n        }\n        if (carrots_left ==\
    \ 0) {\n            result += (meals.toLong)\n        }\n        if (meals_left\
    \ > 0 && carrots_left > 0) {\n            result += (meals_left.toLong)\n    \
    \        result += (carrots_left.toLong)\n        }\n        if (meals_left >\
    \ 0 && carrots_left == 0) {\n            result += (meals_left.toLong)\n     \
    \   }\n        if (meals_left == 0 && carrots_left > 0) {\n            result\
    \ += (meals.toLong)\n        }\n        if (meals_left == 0 && carrots_left ==\
    \ 0) {\n            result += (meals.toLong)\n        }\n        if (meals_left\
    \ == 0 && carrots_left == 0) {\n            result += (meals.toLong)\n       \
    \ }\n        if (meals_left > 0 && carrots_left > 0) {\n            result +=\
    \ (meals_left.toLong)\n            result += (carrots_left.toLong)\n        }\n\
    \        if (meals_left > 0 && carrots_left > 0) {\n            result += (meals_left.toLong)\n\
    \            result += (carrots_left.toLong)\n        }\n        if (meals_left\
    \ > 0 && carrots_left > 0) {\n            result += (meals_left.toLong)\n    \
    \        result += (carrots_left.toLong)\n        }\n        if (meals_left >\
    \ 0 && carrots_left > 0) {\n            result += (meals_left.toLong)\n      \
    \      result += (carrots_left.toLong)\n        }\n        if (meals_left > 0\
    \ && carrots_left > 0) {\n            result += (meals_left.toLong)\n        \
    \    result += (carrots_left.toLong)\n        }\n        if (meals_left > 0 &&\
    \ carrots_left > 0) {\n            result += (meals_left.toLong)\n           \
    \ result += (carrots_left.toLong)\n        }\n        if (meals_left > 0 && carrots_left\
    \ > 0) {\n            result += (meals_left.toLong)\n            result += (carrots_left.toLong)\n\
    \        }\n        if (meals_left \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7h7yc66g.scala:88:4 ----------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7h7yc66g.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659804534
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val list = mutable.ListBuffer[Long]()\n        val carrots_left = carrots\
    \ - remaining\n        val needs_left = needs - remaining\n        val carrots_left_to_eat\
    \ = (carrots_left - needs_left).toInt\n        val needs_left_to_eat = (needs_left\
    \ - carrots_left).toInt\n        val carrots_to_eat = (carrots_left_to_eat + needs_left_to_eat).toInt\n\
    \        val needs_to_eat = (needs_left_to_eat + carrots_left_to_eat).toInt\n\
    \        val carrots_to_eat_left = carrots_to_eat - needs_to_eat\n        val\
    \ needs_to_eat_left = needs_to_eat - carrots_to_eat\n        val carrots_to_eat_left_to_eat\
    \ = (carrots_to_eat_left - needs_to_eat_left).toInt\n        val needs_to_eat_left_to_eat\
    \ = (needs_to_eat_left - carrots_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat - needs_to_eat_left_to_eat\n        val needs_to_eat_left_to_eat_left\
    \ = needs_to_eat_left_to_eat - carrots_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left - needs_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat = (needs_to_eat_left_to_eat_left\
    \ - carrots_to_eat_left_to_eat_left).toInt\n        val carrots_to_eat_left_to_eat_left_to_eat_left\
    \ = carrots_to_eat_left_to_eat_left_to_eat - needs_to_eat_left_to_eat_left_to_eat\n\
    \        val needs_to_eat_left_to_eat_left_to_eat_left = needs_to_eat_left_to_eat_left_to_eat\
    \ - carrots_to_eat_left_to_eat_left_to_eat\n        val carrots_to_eat_left_to_eat_left_to_eat_left_to_eat\
    \ = (carrots_to_eat_left_to_eat_left_to_eat - needs_to_eat_left_to_eat_left_to_eat_left).toInt\n\
    \        val needs_to_eat_left_to_eat_left_to_eat_left_to_eat = (\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmponv913zw.scala:52:64 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mneeds_to_eat_left_to_eat_left_to_eat_left_to_eat\e\
    [0m = (\n\e[31m\e[31m   |\e[0m                                               \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmponv913zw.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmponv913zw.scala:34:19\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mlist\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmponv913zw.scala:53:5\
    \ ---------------------\e[0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = carrots_left\
    \ % needs_left\n        val needs_left_to_eat_2 = needs_left % carrots_left\n\
    \        val carrots_left_to_eat_3 = carrots_left % needs_left_2\n        val\
    \ needs_left_to_eat_3 = needs_left % carrots_left_2\n        val carrots_left_to_eat_4\
    \ = carrots_left % needs_left_3\n        val needs_left_to_eat_4 = needs_left\
    \ % carrots_left_3\n        val carrots_left_to_eat_5 = carrots_left % needs_left_4\n\
    \        val needs_left_to_eat_5 = needs_left % carrots_left_4\n        val carrots_left_to_eat_6\
    \ = carrots_left % needs_left_5\n        val needs_left_to_eat_6 = needs_left\
    \ % carrots_left_5\n        val carrots_left_to_eat_7 = carrots_left % needs_left_6\n\
    \        val needs_left_to_eat_7 = needs_left % carrots_left_6\n        val carrots_left_to_eat_8\
    \ = carrots_left % needs_left_7\n        val needs_left_to_eat_8 = needs_left\
    \ % carrots_left_7\n        val carrots_left_to_eat_9 = carrots_left % needs_left_8\n\
    \        val needs_left_to_eat_9 = needs_left % carrots_left_8\n        val carrots_left_to_eat_10\
    \ = carrots_left % needs_left_9\n        val needs_left_to_eat_10 = needs_left\
    \ % carrots_left_9\n        val carrots_left_to_eat_11 = carrots_left % needs_left_10\n\
    \        val needs_left_to_eat_11 = needs_left % carrots_left_10\n        val\
    \ carrots_left_to_eat_12 = carrots_left % needs_left_11\n        val needs_left_to_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmptamlkqxw.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptamlkqxw.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmptamlkqxw.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptamlkqxw.scala:61:5 ---------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804500
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - carrots\n        val result = List(carrots,\
    \ leftCarrots)\n        if (leftCarrots == 0) {\n            List(number + need)\n\
    \        } else {\n            List(number + need, leftCarrots)\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7jzi8ih9.scala:41)\n\tat Problem.main(tmp7jzi8ih9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804536
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val list = mutable.ListBuffer[Long]()\n\
    \        val carrots = number.toInt\n        val needs = need.toInt\n        val\
    \ remaining = remaining.toInt\n        val carrots_left = carrots - remaining\n\
    \        val needs_left = needs - remaining\n        val carrots_left_to_eat =\
    \ (carrots_left / needs_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left\
    \ % needs_left).toInt\n        val carrots_left_to_eat_3 = (carrots_left_to_eat_2\
    \ * needs_left).toInt\n        val carrots_left_to_eat_4 = (carrots_left_to_eat_3\
    \ * needs_left).toInt\n        val carrots_left_to_eat_5 = (carrots_left_to_eat_4\
    \ * needs_left).toInt\n        val carrots_left_to_eat_6 = (carrots_left_to_eat_5\
    \ * needs_left).toInt\n        val carrots_left_to_eat_7 = (carrots_left_to_eat_6\
    \ * needs_left).toInt\n        val carrots_left_to_eat_8 = (carrots_left_to_eat_7\
    \ * needs_left).toInt\n        val carrots_left_to_eat_9 = (carrots_left_to_eat_8\
    \ * needs_left).toInt\n        val carrots_left_to_eat_10 = (carrots_left_to_eat_9\
    \ * needs_left).toInt\n        val carrots_left_to_eat_11 = (carrots_left_to_eat_10\
    \ * needs_left).toInt\n        val carrots_left_to_eat_12 = (carrots_left_to_eat_11\
    \ * needs_left).toInt\n        val carrots_left_to_eat_13 = (carrots_left_to_eat_12\
    \ * needs_left).toInt\n        val carrots_left_to_eat_14 = (carrots_left_to_eat_13\
    \ * needs_left).toInt\n        val carrots_left_to_eat_15 = (carrots_left_to_eat_14\
    \ * needs_left).toInt\n        val carrots_left_to_eat_16 = (carrots_left_to_eat_15\
    \ * needs_left).toInt\n        val carrots_left_to_eat_17 = (carrots_left_to_eat_16\
    \ * needs_left).toInt\n        val carrots_left_to_eat_18 = (carrots_left_to_eat_17\
    \ * needs_left).toInt\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpxyqm1vg2.scala:55:11 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpxyqm1vg2.scala:31:19 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlist\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpxyqm1vg2.scala:34:24 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxyqm1vg2.scala:56:5\
    \ ---------------------\e[0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659804535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        val carrots_left =\
    \ carrots - remaining\n        val needs_left = needs - remaining\n        val\
    \ carrots_left_to_eat = (carrots_left / needs_left).toInt\n        val needs_left_to_eat\
    \ = (needs_left / carrots_left).toInt\n        val carrots_left_to_eat_2 = (carrots_left\
    \ / needs_left_2).toInt\n        val needs_left_to_eat_2 = (needs_left / carrots_left_2).toInt\n\
    \        val carrots_left_to_eat_3 = (carrots_left / needs_left_3).toInt\n   \
    \     val needs_left_to_eat_3 = (needs_left / carrots_left_3).toInt\n        val\
    \ carrots_left_to_eat_4 = (carrots_left / needs_left_4).toInt\n        val needs_left_to_eat_4\
    \ = (needs_left / carrots_left_4).toInt\n        val carrots_left_to_eat_5 = (carrots_left\
    \ / needs_left_5).toInt\n        val needs_left_to_eat_5 = (needs_left / carrots_left_5).toInt\n\
    \        val carrots_left_to_eat_6 = (carrots_left / needs_left_6).toInt\n   \
    \     val needs_left_to_eat_6 = (needs_left / carrots_left_6).toInt\n        val\
    \ carrots_left_to_eat_7 = (carrots_left / needs_left_7).toInt\n        val needs_left_to_eat_7\
    \ = (needs_left / carrots_left_7).toInt\n        val carrots_left_to_eat_8 = (carrots_left\
    \ / needs_left_8).toInt\n        val needs_left_to_eat_8 = (needs_left / carrots_left_8).toInt\n\
    \        val carrots_left_to_eat_9 = (carrots_left / needs_left_9).toInt\n   \
    \     val needs_left_to_eat_9 = (needs_left / carrots_left_9).toInt\n        val\
    \ carrots_left_to_eat_10 = (carrots_left / needs_left_10).toInt\n        val needs_left_to_eat_10\
    \ = (needs_left / carrots_left_10).toInt\n        val carrots_left_to_eat_11\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpry82zxu3.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpry82zxu3.scala:33:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining.toInt\n\e[31m\e[31m   |\e[0m              \
    \          ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpry82zxu3.scala:34:25 ------------------------\e[0m\e[0m\n\e[31m34 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                         Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpry82zxu3.scala:58:5 ---------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804476
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val totalCarrots = carrots - remaining\n        val remaining = remaining\
    \ - meals\n        val hungry = carrots <= 0\n        val hungryList = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList2 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList3 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList4 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList5 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList6 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList7 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList8 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList9 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList10 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList11 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList12 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList13 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList14 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList15 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList16 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList17 = if (hungry)\
    \ List(1l.toLong) else List(0l.toLong)\n        val hungryList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpptx4bgti.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpptx4bgti.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining - meals\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mremaining is already defined as \e[33mvalue\e[0m \e[35mremaining\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmpptx4bgti.scala:33:24 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpptx4bgti.scala:55:5 ---------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659804535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - need\n        val hungryEaten = if\
    \ (hungryRemaining > 0) hungryRemaining else 0\n        val hungryEatenList =\
    \ List(hungryEaten.toLong)\n        val hungryEatenList2 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList3 = List(hungryEaten.toLong)\n        val hungryEatenList4\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList5 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList6 = List(hungryEaten.toLong)\n        val hungryEatenList7\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList8 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList9 = List(hungryEaten.toLong)\n        val hungryEatenList10\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList11 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList12 = List(hungryEaten.toLong)\n        val hungryEatenList13\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList14 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList15 = List(hungryEaten.toLong)\n        val hungryEatenList16\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList17 = List(hungryEaten.toLong)\n\
    \        val hungryEatenList18 = List(hungryEaten.toLong)\n        val hungryEatenList19\
    \ = List(hungryEaten.toLong)\n        val hungryEatenList20 = List(hungryEat\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbiw5p30l.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbiw5p30l.scala:53:37\
    \ ------------------------\e[0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryEatenList20\e[0m = List(hungryEat\n\e[31m\e[31m   |\e[0m           \
    \                          ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \                  Not found: hungryEat\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpbiw5p30l.scala:54:5 ---------------------\e[0m\e\
    [0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804474
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val hungryRemaining = remaining - need\n        val hungryEaten = if\
    \ (hungryRemaining > 0) hungryRemaining else 0\n        val hungryEatenList =\
    \ List(hungryEaten)\n        val hungryEatenList2 = List(hungryEaten, hungryEaten)\n\
    \        val hungryEatenList3 = List(hungryEaten, hungryEaten, hungryEaten)\n\
    \        val hungryEatenList4 = List(hungryEaten, hungryEaten, hungryEaten, hungryEaten)\n\
    \        val hungryEatenList5 = List(hungryEaten, hungryEaten, hungryEaten, hungryEaten,\
    \ hungryEaten)\n        val hungryEatenList6 = List(hungryEaten, hungryEaten,\
    \ hungryEaten, hungryEaten, hungryEaten, hungryEaten, hungryEaten)\n        val\
    \ hungryEatenList7 = List(hungryEaten, hungryEaten, hungryEaten, hungryEaten,\
    \ hungryEaten, hungryEaten, hungryEaten, hungryEaten, hungryEaten)\n        val\
    \ hungryEatenList8 = List(hungryEaten, hungryEaten, hungryEaten, hungryEaten,\
    \ hungryEaten, hungryEaten, hungryEaten, hungryEaten, hungryEaten, hungryEaten,\
    \ hungryEaten)\n        val hungryEatenList9 = List(hungryEaten, hungryEaten,\
    \ hungryEaten, hungryEaten, hungryEaten, hungryEaten, hungr\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv_q0qf8i.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv_q0qf8i.scala:42:114\
    \ -----------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryEatenList9\e[0m = List(hungryEaten, hungryEaten, hungryEaten, hungryEaten,\
    \ hungryEaten, hungryEaten, hungr\n\e[31m\e[31m   |\e[0m                     \
    \                                                                            \
    \                 ^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \                        Not found: hungr\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpv_q0qf8i.scala:43:5 ---------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659804489
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val left  = remaining - need\n        if (hungry < 0) {\n           \
    \ val hungryList = List(hungry.toLong)\n            val leftList = List(left.toLong)\n\
    \            hungryList ++ leftList\n        } else {\n            val hungryList\
    \ = List(hungry.toLong)\n            val leftList = List(left.toLong)\n      \
    \      val hungryList2 = List(hungry.toLong)\n            val leftList2 = List(left.toLong)\n\
    \            hungryList2 ++ leftList2 ++ hungryList ++ leftList\n        }\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_e5eyk8w.scala:46)\n\tat Problem.main(tmp_e5eyk8w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659804536
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val needs = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val carrots_left = carrots - remaining\n        val carrots_left_after_meals\
    \ = carrots - carrots_left\n        val carrots_left_after_meals_after_meals =\
    \ carrots_left - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals - carrots_left_after_meals_after_meals\n        val\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_me\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr1mhbh62.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpr1mhbh62.scala:42:135\
    \ --------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_me\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \   ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m\
    \  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpr1mhbh62.scala:43:5 ---------------------\e[0m\e[0m\n\e[31m43\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804535
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return a list of [ total number of eaten carrots after\
    \ your meals,\n    // the number of carrots left after your meals ]\n    // if\
    \ there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // >>> eat((5l), (6l), (10l))\n\
    \    // (List[Long](11l.toLong, 4l.toLong))\n    // >>> eat((4l), (8l), (9l))\n\
    \    // (List[Long](12l.toLong, 1l.toLong))\n    // >>> eat((1l), (10l), (10l))\n\
    \    // (List[Long](11l.toLong, 0l.toLong))\n    // >>> eat((2l), (11l), (5l))\n\
    \    // (List[Long](7l.toLong, 0l.toLong))\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number.toInt\n\
    \        val meals = need.toInt\n        val remaining = remaining.toInt\n   \
    \     val result = new mutable.ListBuffer[Long]()\n        if (remaining == 0)\
    \ {\n            result.add(carrots)\n        } else {\n            if (carrots\
    \ >= meals) {\n                result.add(carrots)\n                result.add(0)\n\
    \            } else {\n                val carrots = carrots - meals\n       \
    \         result.add(carrots)\n                result.add(remaining)\n       \
    \     }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpkbpva1jc.scala:33:24 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining.toInt\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkbpva1jc.scala:34:25\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpkbpva1jc.scala:42:30 ---------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m                \e[33mval\e[0m \e[36mcarrots\e[0m = carrots - meals\n\e\
    [31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e[0m     \
    \                         Recursive \e[33mvalue\e[0m \e[35mcarrots\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659804534
