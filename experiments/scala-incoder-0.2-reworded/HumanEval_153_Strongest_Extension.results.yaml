language: scala
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(_.toUpperCase).zipWithIndex.toMap\n        val class_name_map\
    \ = class_name.zipWithIndex.toMap\n        val strength = class_name_map.get(class_name_map.keys.toList.sortBy(_._2).last)\n\
    \        val extension_strength = extensions_map.get(extensions_map.keys.toList.sortBy(_._2).last)\n\
    \        val strength_diff = strength - extension_strength\n        if (strength_diff\
    \ == 0) class_name_map.get(class_name_map.keys.toList.sortBy(_._1).last)\n   \
    \     else class_name_map.get(class_name_map.keys.toList.sortBy(_._1).last) +\
    \ extensions_map.get(extensions_map.keys.toList.sortBy(_._1).last) + extensions_map.get(extensions_map.keys.toList.sortBy(_._2).last)\
    \ + extensions_map.get(extensions_map.keys.toList.sortBy(_._3).last) + extensions_map.get(extensions_map.keys.toList.sortBy(_._4).last)\
    \ + extensions_map.get(extensions_map.keys.toList.sortBy(_._5).last) + extensions_map.get(extensions_map.keys.toList.sortBy(_._6).last)\
    \ + extensions_map.get(extensions_map.keys.toList.sortBy(_._7).last) + extensions_map.get(extensions_map.keys.toList.sortBy(_._8).last)\
    \ + extensions_map.get(extensions_map.keys.toList.sortBy(_._9).last) + extensions_map.get(extensions_map.keys.toList.sortBy(_._10).last)\
    \ + extensions_map.get(extensions_map.keys.toList.sortBy(_._11).last) + extensions_map.get(extensions_map.keys.toList.sortBy(_._12).last)\
    \ + extensions_map.get(extensions_map.keys.toList.sortBy(_._13).last) + extensions_map.get(extensions_map.keys.toList.sortBy(_._14).last)\
    \ + extensions_map.get(extensions_map.keys.toList.sortBy(_._15).last) + extensions_map.get(extensions_map.keys.toList.sortBy(_._16).last)\
    \ + extensions_map.get(extensions_map.keys.toList.sortBy(_._17).last) + extensions_map.get(extensions_map.keys.toList.sortBy(_._18).last)\
    \ + extensions_map.get(extensions_map.keys.toList.sortBy(_._19).last) + extensions_map.get(extensions_map.keys.toList.sortBy(_._20).last)\
    \ + extensions_map.get(extensions_map.keys.toList.sortBy(_._21).last) + extensions_map.get(extensions_map.keys.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqzcl15an.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpqzcl15an.scala:23:78 ------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = class_name_map.get(class_name_map.keys.toList.sortBy(_._2).last)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                    ^^^^\e[0m\n\e[31m   |\e[0m                              \
    \          value _2 is not a member of Char\n\e[31m\e[31m-- Error: /tmp/tmpqzcl15an.scala:23:81\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mstrength\e[0m = class_name_map.get(class_name_map.keys.toList.sortBy(_._2).last)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                         ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and\
    \ \e[33mobject\e[0m \e[35mBigDecimal\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35msortBy\e\
    [0m in \e[33mtrait\e[0m \e[35mSeqOps\e[0m\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpqzcl15an.scala:24:88 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m        \e[33mval\e[0m \e[36mextension_strength\e[0m = extensions_map.get(extensions_map.keys.toList.sortBy(_._2).last)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                              ^^^^\e[0m\n\e[31m   |\e[0m                    \
    \                  value _2 is not a member of String\n\e[31m\e[31m-- Error: /tmp/tmpqzcl15an.scala:24:91\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m       \
    \ \e[33mval\e[0m \e[36mextension_strength\e[0m = extensions_map.get(extensions_map.keys.toList.sortBy(_._2).last)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                   ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33m"
  stdout: ''
  timestamp: 1659799577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extensions_sorted =\
    \ extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n        val extensions_sorted\
    \ = extensions_sorted.toList\n        val extensions_sorted = extensions_sorted.map(e\
    \ => class_name + \".\" + e)\n        extensions_sorted.headOption.getOrElse(class_name)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplugthzlv.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplugthzlv.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplugthzlv.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36me\e[0m => class_name + \e[31m\".\"\e[0m + e)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmplugthzlv.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e"
  stdout: ''
  timestamp: 1659799574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toString.toUpperCase.length).toList.max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7elgakgk.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp7elgakgk.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7elgakgk.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e\
    [31m0\e[0m) - x.toString.toUpperCase.length).toList.max\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \   ^\e[0m\n\e[31m   |\e[0m                                                  Found:\
    \    (x : String)\n\e[31m   |\e[0m                                           \
    \       Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp7elgakgk.scala:24:49 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mextension\e[0m = extensions_map.getOrElse(strength,\
    \ \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                                    \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \             Found:    (strength : Int)\n\e[31m   |\e[0m                    \
    \                          Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659799576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase - x.toLowerCase -> x)).toMap\n        val\
    \ extensions_sorted = extensions_map.values.toList.sortWith(_._2 > _._2)\n   \
    \     val extensions_sorted = extensions_sorted.take(extensions_sorted.length-1)\n\
    \        val extensions_sorted = extensions_sorted.map(x => class_name + x._1\
    \ + x._2)\n        extensions_sorted.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdhd9ntsh.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(extensions_sorted.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpdhd9ntsh.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36mx\e[0m => class_name + x._1 + x._2)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpdhd9ntsh.scala:21:64 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36mx\e[0m => (x.toUpperCase - x.toLowerCase -> x)).toMap\n\e[31m\e[31m   |\e\
    [0m                                                  ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue - is not a member of String, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdhd9ntsh.scala:22:72\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_sorted\e[0m = extensions_map.values.toList.sortWith(_._2 > _._2)\n\
    \e[31m\e[3"
  stdout: ''
  timestamp: 1659799575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(_.toUpperCase).zip(extensions.map(_.toLowerCase)).toMap\n \
    \       val class_name_map = class_name.map(_.toUpperCase).zip(class_name.map(_.toLowerCase)).toMap\n\
    \        val strength = extensions_map.filter(_._2 > class_name_map.getOrElse(_._2,\
    \ 0)).length\n        val extension = extensions_map.filter(_._2 == strength).head._1\n\
    \        class_name + \".\" + extension\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqj136e0v.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(_.toUpperCase).zip(class_name.map(_.toLowerCase)).toMap\n\
    \e[31m\e[31m   |\e[0m                                            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqj136e0v.scala:23:87\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.filter(_._2 > class_name_map.getOrElse(_._2,\
    \ \e[31m0\e[0m)).length\n\e[31m\e[31m   |\e[0m                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     value length is not a member of Map[String,\
    \ String]\n2 errors found\n"
  stdout: ''
  timestamp: 1659799575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') / e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C') / e.toUpperCase.count(_ == 'D')).toMap\n\
    \        val strength = extensions_map.getOrElse(class_name, 0)\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extensions_sorted =\
    \ extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\".\")\n        val\
    \ extensions_sorted = extensions_sorted.dropRight(1)\n        val extensions_sorted\
    \ = extensions_sorted.dropRight(1)\n        val extensions_sorted = extensions_sorted.dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(1)\n        val extensions_sorted\
    \ = extensions_sorted.dropRight(1)\n        val extensions_sorted = extensions_sorted.dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(1)\n        val extensions_sorted\
    \ = extensions_sorted.dropRight(1)\n        val extensions_sorted = extensions_sorted.dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(1)\n        val extensions_sorted\
    \ = extensions_sorted.dropRight(1)\n        val extensions_sorted = extensions_sorted.dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(1)\n        val extensions_sorted\
    \ = extensions_sorted.dropRight(1)\n        val extensions_sorted = extensions_sorted.dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(1)\n        val extensions_sorted\
    \ = extensions_sorted.dropRight(1)\n        val extensions_sorted = extensions_sorted.dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(1)\n        val extensions_sorted\
    \ = extensions_sorted.dropRight(1)\n        val extensions_sorted = extensions_sorted.dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(1)\n        val extensions_sorted\
    \ = extensions_sorted.dropRight(1)\n        val extensions_sorted = extensions_sorted.dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(1)\n        val extensions_sorted\
    \ = extensions_sorted.dropRight(1)\n        val extensions_sorted = extensions_sorted.dropRight(1)\n\
    \        val extensions_sorted = extensions_sorted.dropRight(1)\n        val extensions_sorted\
    \ = extensions_sorted.\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6r9iqblm.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp6r9iqblm.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_._2\
    \ > \e[31m0\e[0m).map(_._1).mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6r9iqblm.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6r9iqblm.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6r9iqblm.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659799574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length).sum\n\
    \        val extensions_count_sorted_length_sorted = extensions_count_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted.sortWith(_.length < _.length)\n    \
    \    val extensions_count_sorted_length_sorted_length_sorted_length = extensions_count_sorted_length_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted.sortWith(_.length < _.length)\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5t4xqwdw.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5t4xqwdw.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp5t4xqwdw.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the "
  stdout: ''
  timestamp: 1659799574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_upper - extensions_count_diff\n\
    \        val extensions_count_diff_lower = extensions_count_lower - extensions_count_diff\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper -\
    \ extensions_count_diff_lower\n        val extensions_count_diff_diff_lower =\
    \ extensions_count_diff_lower - extensions_count_diff_upper\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper - extensions_count_diff_diff_lower\n    \
    \    val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_lower\
    \ - extensions_count_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper - extensions_count_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_upper\n        val\
    \ extensions_count_diff_diff_diff_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_l4q23v8.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_l4q23v8.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_upper is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_upper\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_l4q23v8.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_l4q23v8.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659799573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase - e.toLowerCase -> 1)).toMap\n        val\
    \ class_name_map = class_name.map(c => (c.toUpperCase - c.toLowerCase -> 1)).toMap\n\
    \        val max_key = extensions_map.keys.max\n        val max_value = extensions_map.values.max\n\
    \        val max_key_value = class_name_map.get(max_key)\n        max_key_value.map(c\
    \ => c._1 + \".\" + c._2).getOrElse(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3h4dcvhs.scala:21:64 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => (e.toUpperCase - e.toLowerCase -> \e[31m1\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp3h4dcvhs.scala:22:52 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mc\e[0m => (c.toUpperCase - c.toLowerCase -> \e[31m1\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmp3h4dcvhs.scala:23:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = extensions_map.keys.max\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mLong\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- Error: /tmp/tmp3h4dcvhs.scala:24:49 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmax_value\e[0m = extensions_map.values.max\n\
    \e[31m\e[31m   |\e[0m                                                 ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobje"
  stdout: ''
  timestamp: 1659799576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper_smallest = extensions.minBy(_.toUpperCase.length)\n\
    \        val extensions_count_lower_smallest = extensions.minBy(_.toLowerCase.length)\n\
    \        val extensions_count_smallest = extensions_count_upper_smallest - extensions_count_lower_smallest\n\
    \        val extensions_count_largest_upper = extensions.maxBy(_.toUpperCase.length)\n\
    \        val extensions_count_largest_lower = extensions.maxBy(_.toLowerCase.length)\n\
    \        val extensions_count_largest_smallest = extensions_count_largest_upper\
    \ - extensions_count_largest_lower\n        val extensions_count_largest_largest_upper\
    \ = extensions.maxBy(_.toUpperCase.length)\n        val extensions_count_largest_largest_lower\
    \ = extensions.maxBy(_.toLowerCase.length)\n        val extensions_count_largest_largest_smallest\
    \ = extensions_count_largest_largest_upper - extensions_count_largest_largest_lower\n\
    \        val extensions_count_largest_largest_largest_upper = extensions.maxBy(_.toUpperCase.length)\n\
    \        val extensions_count_largest_largest_largest_lower = extensions.maxBy(_.toLowerCase.length)\n\
    \        val extensions_count_largest_largest_largest_smallest = extensions_count_largest_largest_largest_upper\
    \ - extensions_count_largest_largest_largest_lower\n        val extensions_count_largest_largest_largest_largest_upper\
    \ = extensions.maxBy(_.toUpperCase.length)\n        val extensions_count_largest_largest_largest_largest_lower\
    \ = extensions.maxBy(_.toLowerCase.length)\n        val extensions_count_largest_largest_largest_largest_smallest\
    \ = extensions_count_largest_largest_largest_largest_upper - extensions_count_largest_largest_largest_largest_lower\n\
    \        val extensions_count_largest_largest_largest_largest_largest_upper =\
    \ extensions.maxBy(_.toUpperCase.length)\n        val extensions_count_largest_largest_largest_largest_largest_lower\
    \ = extensions.maxBy(_.toLowerCase.length)\n        val extensions_count_largest_largest_largest_largest_largest_smallest\
    \ = extensions_count_largest_largest_largest_largest_largest_upper - extensions_count_largest_largest_largest_largest_largest_largest_lower\n\
    \        val extensions_count_largest_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxpqoteaz.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxpqoteaz.scala:27:72\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_smallest\e[0m = extensions_count_upper_smallest - extensions_count_lower_smallest\n\
    \e[31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxpqoteaz.scala:30:79 ------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_largest_smallest\e\
    [0m = extensions_count_largest_upper - extensions_count_largest_lower\n\e[31m\e\
    [31m   |\e[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxpqoteaz.scala:33:95 ------------------------\e[0m\e\
    [0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_largest_largest_smallest\e\
    [0m = extensions_count_largest_largest_upper - extensions_count_largest_largest_lower\n\
    \e[31m\e[31m   |\e[0m                                                  "
  stdout: ''
  timestamp: 1659799577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val extensions_count\
    \ = extensions_map.size\n        val class_name_count = class_name_map.size\n\
    \        val strength = extensions_count - class_name_count\n        if (strength\
    \ == 0) class_name\n        else if (strength > 0) class_name + extensions_map.getOrElse(class_name_map.getOrElse(strength,\
    \ \"\"), \"\")\n        else class_name + extensions_map.getOrElse(class_name_map.getOrElse(strength,\
    \ \"\"), \"\") + extensions_map.getOrElse(class_name_map.getOrElse(strength, \"\
    \"), \"\")\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpie8lm_eo.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpie8lm_eo.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpie8lm_eo.scala:27:94\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (strength > \e[31m0\e[0m) class_name + extensions_map.getOrElse(class_name_map.getOrElse(strength,\
    \ \e[31m\"\"\e[0m), \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                                                                            ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                              Found:    (strength\
    \ : Int)\n\e[31m   |\e[0m                                              Required:\
    \ Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpie8lm_eo.scala:28:76\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33melse\e[0m class_name\
    \ + extensions_map.getOrElse(class_name_map.getOrElse(strength, \e[31m\"\"\e[0m),\
    \ \e[31m\"\"\e[0m) + extensions_map.getOrElse(class_name_map.getOrElse(strength,\
    \ \e[31m\"\"\e[0m), \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                                                          ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                              Found:    (strength :\
    \ Int)\n\e[31m   |\e[0m                                              Required:\
    \ Nothin"
  stdout: ''
  timestamp: 1659799576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val class_name_map = class_name.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\
    \        val max_value = extensions_map.values.max\n        val max_key = extensions_map.keys.max\n\
    \        val max_key_value = class_name_map.get(max_key)\n        val max_key_key_value\
    \ = max_key_value.map(x => (x._1, x._2))\n        val max_key_key_value = max_key_key_value.max\n\
    \        val max_key_key_value = max_key_key_value._2\n        val max_key_key_value\
    \ = max_key_key_value._1\n        val max_key_key_value = max_key_key_value._1\n\
    \        val max_key_key_value = max_key_key_value._1\n        val max_key_key_value\
    \ = max_key_key_value._1\n        val max_key_key_value = max_key_key_value._1\n\
    \        val max_key_key_value = max_key_key_value._1\n        val max_key_key_value\
    \ = max_key_key_value._1\n        val max_key_key_value = max_key_key_value._1\n\
    \        val max_key_key_value = max_key_key_value._1\n        val max_key_key_value\
    \ = max_key_key_value._1\n        val max_key_key_value = max_key_key_value._1\n\
    \        val max_key_key_value = max_key_key_value._1\n        val max_key_key_value\
    \ = max_key_key_value._1\n        val max_key_key_value = max_key_key_value._1\n\
    \        val max_key_key_value = max_key_key_value._1\n        val max_key_key_value\
    \ = max_key_key_value._1\n        val max_key_key_value = max_key_key_value._1\n\
    \        val max_key_key_value = max_key_key_value._1\n        val max_key_key_value\
    \ = max_key_key_value._1\n        val max_key_key_value = max_key_key_value._1\n\
    \        val max_key_key_value = max_key_key_value._1\n        val max_key_key_value\
    \ = max_key_key_value._1\n        val max_key_key_value = max_key_key_value._1\n\
    \        val max_key_key_value = max_key_key_value._1\n        val max_key_key_value\
    \ = max_key_key_value._1\n        val max_key_key_value = max_key_key_value._1\n\
    \        val max_key_key_value = max_key_key_value._1\n        val max_key_key_value\
    \ = max_key_key_value._1\n        val max_key_key_value = max_key_key_value._1\n\
    \        val max_key_key_value = max_key_key_value._1\n        val max_\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv2rp0iye.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv2rp0iye.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_key_key_value\e[0m = max_key_key_value.max\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax_key_key_value\
    \ is already defined as \e[33mvalue\e[0m \e[35mmax_key_key_value\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpv2rp0iye.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mmax_key_key_value\e[0m = max_key_key_value._2\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_key_value is already defined as \e[33mvalue\e[0m \e[35mmax_key_key_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv2rp0iye.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmax_key_key_value\e[0m = max_key_key_value._1\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_key_value is already defined as \e[33mvalue\e[0m \e[35mmax_key_key_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv2rp0iye.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mmax_key_key_value\e[0m = max_key_key_value._1\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_key_value is already defined as \e[33mvalue\e[0m \e[35mmax_key_key_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same g"
  stdout: ''
  timestamp: 1659799576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extension_strength = extensions_count.toDouble\
    \ / extensions.length\n        val extension_strength_upper = extensions_count_upper.toDouble\
    \ / extensions.length\n        val extension_strength_lower = extensions_count_lower.toDouble\
    \ / extensions.length\n        val strength_upper = extension_strength_upper -\
    \ extension_strength_lower\n        val strength_lower = extension_strength_lower\
    \ - extension_strength_upper\n        val strength_diff = strength_upper - strength_lower\n\
    \        val strength_diff_upper = strength_diff / strength_upper\n        val\
    \ strength_diff_lower = strength_diff / strength_lower\n        val strength_diff_diff_upper\
    \ = strength_diff_upper - strength_diff_lower\n        val strength_diff_diff_lower\
    \ = strength_diff_lower - strength_diff_upper\n        val strength_diff_diff_diff_upper\
    \ = strength_diff_diff_upper - strength_diff_diff_lower\n        val strength_diff_diff_diff_lower\
    \ = strength_diff_diff_lower - strength_diff_diff_upper\n        val strength_diff_diff_diff_diff_upper\
    \ = strength_diff_diff_diff_upper - strength_diff_diff_diff_lower\n        val\
    \ strength_diff_diff_diff_diff_lower = strength_diff_diff_diff_lower - strength_diff_diff_diff_upper\n\
    \        val strength_diff_diff_diff_diff_upper = strength_diff_diff_diff_diff_upper\
    \ - strength_diff_diff_diff_diff_lower\n        val strength_diff_diff_diff_diff_lower\
    \ = strength_diff_diff_diff_diff_lower - strength_diff_diff_diff_diff_upper\n\
    \        val strength_diff_diff_diff_diff_diff_upper = strength_diff_diff_diff_diff_diff_upper\
    \ - strength_diff_diff_diff_diff_diff_lower\n        val strength_diff_diff_diff_diff_diff_lower\
    \ = strength_diff_diff_diff_diff_diff_lower - strength_diff_diff_diff_diff_diff_upper\n\
    \        val strength_diff_diff_diff_diff_diff_diff_upper = strength_diff_diff_diff_diff_diff_diff_upper\
    \ - strength_diff_diff_diff_diff_diff_diff_lower\n        val strength_diff_diff_diff_diff_diff_diff_lower\
    \ = strength_diff_diff_diff_diff_diff_diff_lower - strength_diff_diff_diff_diff_diff_diff_upper\n\
    \        val strength\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphfgepfbv.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphfgepfbv.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstrength_diff_diff_diff_diff_upper\e[0m = strength_diff_diff_diff_diff_upper\
    \ - strength_diff_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_diff_diff_diff_diff_upper is already defined as \e\
    [33mvalue\e[0m \e[35mstrength_diff_diff_diff_diff_upper\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphfgepfbv.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstrength_diff_diff_diff_diff_lower\e[0m = strength_diff_diff_diff_diff_lower\
    \ - strength_diff_diff_diff_diff_upper\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_diff_diff_diff_diff_lower is already defined as \e\
    [33mvalue\e[0m \e[35mstrength_diff_diff_diff_diff_lower\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphfgepfbv.scala:43:54\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstrength_diff_diff_diff_diff_diff_upper\e[0m = strength_diff_diff_diff_diff_diff_upper\
    \ - strength_diff_diff_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m           \
    \                                           ^\e[0m\n\e[31m   |\e[0m      Recursive\
    \ \e[33mvalue\e[0m \e[35mstrength_diff_diff_diff_diff_diff_upper\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/"
  stdout: ''
  timestamp: 1659799573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = class_name_map.foldLeft(0)((acc, x) => acc + (extensions_map(x._1).length\
    \ - extensions_map(x._2).length))\n        val strongest_extension = class_name_map.filter(_._1\
    \ == strength).map(_._2).mkString(\".\") + \".\" + class_name_map.filter(_._1\
    \ == strength).map(_._1).mkString(\".\") + \".\"\n        \n        if (extensions_map.size\
    \ == 0) strongest_extension\n        else strongest_extension + extensions_map.filter(_._1\
    \ == strength).map(_._2).mkString(\".\") + \".\" + extensions_map.filter(_._1\
    \ == strength).map(_._1).mkString(\".\") + \".\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6v27xzpx.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp6v27xzpx.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmp6v27xzpx.scala:27:57 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m strongest_extension + extensions_map.filter(_._1\
    \ == strength).map(_._2).mkString(\e[31m\".\"\e[0m) + \e[31m\".\"\e[0m + extensions_map.filter(_._1\
    \ == strength).map(_._1).mkString(\e[31m\".\"\e[0m) + \e[31m\".\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                         ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         Values of types String and Int cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp6v27xzpx.scala:27:129 ----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m strongest_extension + extensions_map.filter(_._1\
    \ == strength).map(_._2).mkString(\e[31m\".\"\e[0m) + \e[31m\".\"\e[0m + extensions_map.filter(_._1\
    \ == strength).map(_._1).mkString(\e[31m\".\"\e[0m) + \e[31m\".\"\e[0m\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                 ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m         Values of types String and Int cannot be compared\
    \ with == or !=\n4 errors found\n"
  stdout: ''
  timestamp: 1659799576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4fqfqpbx.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp4fqfqpbx.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fqfqpbx.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e\
    [31m0\e[0m) - x.toUpperCase.length).max\n\e[31m\e[31m   |\e[0m               \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                                                  Found:    (x : String)\n\
    \e[31m   |\e[0m                                                  Required: Nothing\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fqfqpbx.scala:24:49\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextension\e\
    [0m = extensions_map.getOrElse(strength, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                 ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                              Found:    (strength : Int)\n\e\
    [31m   |\e[0m                                              Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659799576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase).zipWithIndex.filter(_._2 > 0).map(_._1)\n\
    \        val extensions_count = extensions_map.length\n        val extensions_count_map\
    \ = extensions_map.map(e => (e.toUpperCase, 1)).reduceByKey(_ + _)\n        val\
    \ extensions_count_sorted = extensions_count_map.toSeq.sortBy(_._2).reverse\n\
    \        val extensions_count_sorted = extensions_count_sorted.take(extensions_count)\n\
    \        val extensions_count_sorted = extensions_count_sorted.map(_._1).mkString(\"\
    .\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\.\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_sorted.replaceAll(\"\
    \\\\B\", \"\")\n        val extensions_count_sorted = extensions_count_\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplpsqn5_c.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions_count_sorted.take(extensions_count)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplpsqn5_c.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions_count_sorted.map(_._1).mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplpsqn5_c.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions_count_sorted.replaceAll(\e[31m\"\\\\.\"\e[0m, \e[31m\"\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmplpsqn5_c.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions_count_sorted.replaceAll(\e[31m\"\\\\B\"\e[0m, \e[31m\"\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is al"
  stdout: ''
  timestamp: 1659799575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_upper - extensions_count_diff\n\
    \        val extensions_count_diff_lower = extensions_count_lower - extensions_count_diff\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper -\
    \ extensions_count_diff_lower\n        val extensions_count_diff_diff_lower =\
    \ extensions_count_diff_lower - extensions_count_diff_upper\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper - extensions_count_diff_diff_lower\n    \
    \    val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_lower\
    \ - extensions_count_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper - extensions_count_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_upper\n        val\
    \ extensions_count_diff_diff_diff_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_l4q23v8.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_l4q23v8.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_upper is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_upper\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_l4q23v8.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_l4q23v8.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659799573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.filter(_._2 > class_name_map.get(_._1)).map(_._1).sum\n   \
    \     val extension = extensions_map.filter(_._1 == class_name_map.get(_._1)).map(_._2).head\n\
    \        s\"$class_name.$extension\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpaph1dihc.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpaph1dihc.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpaph1dihc.scala:23:71\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e\
    [0m \e[36mstrength\e[0m = extensions_map.filter(_._2 > class_name_map.get(_._1)).map(_._1).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$2 of expanded\
    \ function:\n\e[31m   |\e[0m   _$2 => _$2._1.\n\e[31m\e[31m-- Error: /tmp/tmpaph1dihc.scala:23:91\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.filter(_._2 > class_name_map.get(_._1)).map(_._1).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                   ^\e[0m\n\e[31m   |\e[0m                No\
    \ implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          \
    \      where:    B is a type variable with constraint >: String\n\e[31m   |\e\
    [0m                .\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpaph1dihc.scala:24:73\
    \ -----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e\
    [0m \e[36mextension\e[0m = extensions_map.filter(_._1 == class_name_map.get(_._1)).map(_._2"
  stdout: ''
  timestamp: 1659799575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).toList\n\
    \        val extensions_sor\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprih6y_lt.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprih6y_lt.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_._2 > \e[31m0\e\
    [0m).map(_._1).toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmprih6y_lt.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmprih6y_lt.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmprih6y_lt.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map("
  stdout: ''
  timestamp: 1659799574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.get(x) - x.toString.toString.toUpperCase.length).toArray\n\
    \        val max_strength = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = extensions_map.values.toArray.max\n        val max_key\
    \ = class_name_map.get(max_key)\n        val max_value = max_key.map(x => class_name_map.get(x))\n\
    \        val max_key = max_key.map(x => x.toString.toString.toUpperCase)\n   \
    \     val max_value = max_value.map(x => x.toString.toString.toUpperCase)\n  \
    \      val max_key = max_key.map(x => x.toString.toString.toUpperCase)\n     \
    \   val max_value = max_value.map(x => x.toString.toString.toUpperCase)\n    \
    \    val max_key = max_key.map(x => x.toString.toString.toUpperCase)\n       \
    \ val max_value = max_value.map(x => x.toString.toString.toUpperCase)\n      \
    \  val max_key = max_key.map(x => x.toString.toString.toUpperCase)\n        val\
    \ max_value = max_value.map(x => x.toString.toString.toUpperCase)\n        val\
    \ max_key = max_key.map(x => x.toString.toString.toUpperCase)\n        val max_value\
    \ = max_value.map(x => x.toString.toString.toUpperCase)\n        val max_key =\
    \ max_key.map(x => x.toString.toString.toUpperCase)\n        val max_value = max_value.map(x\
    \ => x.toString.toString.toUpperCase)\n        val max_key = max_key.map(x =>\
    \ x.toString.toString.toUpperCase)\n        val max_value = max_value.map(x =>\
    \ x.toString.toString.toUpperCase)\n        val max_key = max_key.map(x => x.toString.toString.toUpperCase)\n\
    \        val max_value = max_value.map(x => x.toString.toString.toUpperCase)\n\
    \        val max_key = max_key.map(x => x.toString.toString.toUpperCase)\n   \
    \     val max_value = max_value.map(x => x.toString.toString.toUpperCase)\n  \
    \      val max_key = max_key.map(x => x.toString.toString.toUpperCase)\n     \
    \   val max_value = max_value.map(x => x.toString.toString.toUpperCase)\n    \
    \    val max_key = max_key.map(x => x.toString.toString.toUpperCase)\n       \
    \ val max_value = max_value.map(x \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd6ylmfhv.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd6ylmfhv.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_key\e[0m = class_name_map.get(max_key)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax_key is\
    \ already defined as \e[33mvalue\e[0m \e[35mmax_key\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd6ylmfhv.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_value\e[0m = max_key.map(\e[36mx\e[0m => class_name_map.get(x))\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_value is already defined as \e[33mvalue\e[0m \e[35mmax_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpd6ylmfhv.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = max_key.map(\e[36mx\e\
    [0m => x.toString.toString.toUpperCase)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key is already defined as \e[33mvalue\e[0m \e[35mmax_key\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpd6ylmfhv.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mmax_value\e[0m = max_value.map(\e[36mx\e\
    [0m => x.toString.toString.toUpperCase)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_value is already defined as \e[33mvalue\e[0m \e[35mmax_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that"
  stdout: ''
  timestamp: 1659799576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4fqfqpbx.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp4fqfqpbx.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fqfqpbx.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e\
    [31m0\e[0m) - x.toUpperCase.length).max\n\e[31m\e[31m   |\e[0m               \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                                                  Found:    (x : String)\n\
    \e[31m   |\e[0m                                                  Required: Nothing\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fqfqpbx.scala:24:49\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextension\e\
    [0m = extensions_map.getOrElse(strength, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                 ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                              Found:    (strength : Int)\n\e\
    [31m   |\e[0m                                              Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659799576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase - e.toLowerCase -> 1)).toMap\n        val\
    \ class_name_map = class_name.map(c => (c.toUpperCase - c.toLowerCase -> 1)).toMap\n\
    \        val strength = class_name_map.foldLeft(0)((a, b) => if (extensions_map.contains(a._1))\
    \ a._2._1 + a._2._2 else a._2._1 + a._2._2)\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val class_name_sorted = class_name_map.toSeq.sortBy(_._1).reverse\n\
    \        val class_name_sorted = class_name_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val strength_sorted = strength.toSeq.sortBy(_._1).reverse\n    \
    \    val strength_sorted = strength_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val class_name_sorted.concat(\".\").concat(extensions_sorted)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi1dtak7r.scala:30:41 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m class_name_sorted.concat(\e[31m\"\
    .\"\e[0m).concat(extensions_sorted)\n\e[31m\e[31m   |\e[0m                   \
    \                      ^\e[0m\n\e[31m   |\e[0m                               \
    \          '=' expected, but '.' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi1dtak7r.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_._2 > \e[31m0\e\
    [0m).map(_._1).mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpi1dtak7r.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mclass_name_sorted\e[0m =\
    \ class_name_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mclass_name_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpi1dtak7r.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mstrength_sorted\e[0m = strength_sorted.takeWhile(_._2\
    \ > \e[31m0\e[0m).map(_._1).mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mstrength_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e["
  stdout: ''
  timestamp: 1659799575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extensions_sorted =\
    \ extensions_sorted.take(extensions_sorted.length-1)\n        val extensions_sorted\
    \ = extensions_sorted.map(_._2)\n        val extensions_sorted = extensions_sorted.mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.replaceAll(\"\\\\.\",\
    \ \"\")\n        class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmgycqg2p.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(extensions_sorted.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmgycqg2p.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(_._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmgycqg2p.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmgycqg2p.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.replaceAll(\e[31m\"\\\\.\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel defini"
  stdout: ''
  timestamp: 1659799574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(x => x._1).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfy5we2ff.scala:47:66 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \n\e[31m\e[31m   |\e[0m                 \
    \                                                 ^\e[0m\n\e[31m   |\e[0m    \
    \                                   expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfy5we2ff.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_._2 > \e[31m0\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfy5we2ff.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).reverse\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfy5we2ff.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).reverse\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel"
  stdout: ''
  timestamp: 1659799573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_count = extensions_map.filter(_._2 > 0).map(_._1).length\n\
    \        val extensions_count_sorted = extensions_count.sortWith(_ < _)\n    \
    \    val strength = extensions_count_sorted.last\n        val extensions_sorted\
    \ = extensions_count_sorted.filter(_._2 == strength)\n        val extensions_sorted.head._1\
    \ + \".\" + extensions_sorted.head._2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpng061anz.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpng061anz.scala:21:100\
    \ -----------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_map\e[0m = extensions.map(\e[36me\e[0m => e.toUpperCase.charAt(\e\
    [31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e[0m).toLowerCase)\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                    value toLowerCase is not a member of Char\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpng061anz.scala:22:58 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_count\e[0m =\
    \ extensions_map.filter(_._2 > \e[31m0\e[0m).map(_._1).length\n\e[31m\e[31m  \
    \ |\e[0m                                                     ^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue > is not a member of Nothing, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import concurrent.duration.Deadline.DeadlineIsOrdered.mkOrderingOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpng061anz.scala:23:55\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted\e[0m = extensions_count.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value sortWith is not a\
    \ member of Int\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpng061anz.scala:26:4"
  stdout: ''
  timestamp: 1659799575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val strength = extensions_count - class_name_length\n        val extension\
    \ = extensions.find(_.length == class_name_length)\n        val extension_length\
    \ = extension.length\n        val extension_strength = extension.length - extension_length\n\
    \        if (strength < 0) extension.head\n        else extension.take(strength).mkString.drop(strength).mkString\
    \ + extension.drop(strength).mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoajvq1pj.scala:25:41 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextension_length\e[0m =\
    \ extension.length\n\e[31m\e[31m   |\e[0m                               ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value length is not a member of\
    \ Option[String]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpoajvq1pj.scala:26:43\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mextension_strength\e[0m = extension.length - extension_length\n\e[31m\e[31m\
    \   |\e[0m                                 ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                          value length is not a member of Option[String]\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659799586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => strength.compareTo(a.length - b.length))\n \
    \       extensions_sorted.head\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq5k8f4p6.scala:24:80\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e\
    [0m = extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength.compareTo(a.length\
    \ - b.length))\n\e[31m\e[31m   |\e[0m                                        \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                                       Found:    Int\n\
    \e[31m   |\e[0m                                                       Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase.size, e.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n  \
    \      val extensions_sorted = extensions_sorted.takeWhile(_._1 < strength).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.mkString(\"\")\n        class_name\
    \ + extensions_sorted\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmcgggxhb.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._1 < strength).map(_._2)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmcgggxhb.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659799582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    if (extensions_count > 1) {\n            val extensions_sorted = extensions.sortBy(_.length)\n\
    \            val extensions_sorted_upper = extensions_sorted.map(_.toUpperCase)\n\
    \            val extensions_sorted_lower = extensions_sorted.map(_.toLowerCase)\n\
    \            val strength_sorted = extensions_sorted_upper.map(_.length - extensions_sorted_lower.map(_.length)).sum\n\
    \            if (strength_sorted > strength) {\n                val extensions_sorted_sorted\
    \ = extensions_sorted_upper.sortBy(_.length)\n                val extensions_sorted_sorted_upper\
    \ = extensions_sorted_sorted.map(_.toUpperCase)\n                val extensions_sorted_sorted_lower\
    \ = extensions_sorted_sorted.map(_.toLowerCase)\n                val strength_sorted_sorted\
    \ = extensions_sorted_sorted_upper.map(_.length - extensions_sorted_sorted_lower.map(_.length)).sum\n\
    \                if (strength_sorted_sorted > strength) {\n                  \
    \  val extensions_sorted_sorted_sorted = extensions_sorted_sorted_upper.sortBy(_.length)\n\
    \                    val extensions_sorted_sorted_sorted_upper = extensions_sorted_sorted_sorted.map(_.toUpperCase)\n\
    \                    val extensions_sorted_sorted_sorted_lower = extensions_sorted_sorted_sorted.map(_.toLowerCase)\n\
    \                    val strength_sorted_sorted_sorted = extensions_sorted_sorted_sorted_upper.map(_.length\
    \ - extensions_sorted_sorted_sorted_lower.map(_.length)).sum\n               \
    \     if (strength_sorted_sorted_sorted > strength) {\n                      \
    \  val extensions_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_upper.sortBy(_.length)\n\
    \                        val extensions_sorted_sorted_sorted_sorted_upper = extensions_sorted_sorted_sorted_sorted.map(_.toUpperCase)\n\
    \                        val extensions_sorted_sorted_sorted_sorted_lower = extensions_sorted_sorted_sorted_sorted.map(_.toLowerCase)\n\
    \                        val strength_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted_upper.map(_.length\
    \ - extensions_sorted_sorted_sorted_sorted_lower.map(_.length)).sum\n        \
    \                if (strength_sorted_sorted_sorted_sorted > strength) {\n    \
    \                        val extensions_sorted_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted_upper.sortBy(_.length)\n\
    \                            val extensions_sorted_sorted_sorted_sorted_sorted_upper\
    \ = extensions_sorted_sorted_sorted_sorted_sorted.map(_.toUpperCase)\n       \
    \                     val extensions_sorted_sorted_sorted_sorted_sorted_lower\
    \ = extensions_sorted_sorted_sorted_sorted_sorted.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp073wgmmn.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp073wgmmn.scala:63:0 ----------------------------\e[0m\e[0m\n\e[31m63\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E134] Type Error: /tmp/tmp073wgmmn.scala:29:71 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mstrength_sorted\e[0m\
    \ = extensions_sorted_upper.map(_.length - extensions_sorted_lower.map(_.length)).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m None of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\
    \e[31m   |\e[0m  (x: Double): Double\n\e[31m   |\e[0m  (x: Float): Float\n\e[31m\
    \   |\e[0m  (x: Long): Long\n\e[31m   |\e[0m  (x: Int): Int\n\e[31m   |\e[0m \
    \ (x: Char): Int\n\e[31m   |\e[0m  (x: Short): Int\n\e[31m   |\e[0m  (x: Byte):\
    \ Int\n\e[31m   |\e[0m match arguments (List[Int])\n\e[31m\e[31m-- Error: /tmp/tmp073wgmmn.scala:29:115\
    \ ----------------------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \
    \    \e[33mval\e[0m \e[36mstrength_sorted\e[0m = extensions_sorted_upper.map(_.length\
    \ - extensions_sorted_lower.map(_.length)).sum\n\e[31m\e[31m   |\e[0m        \
    \                                                                            \
    \                               ^\e[0m\n\e[31m   |\e[0mambiguous given instances:\
    \ both \e[33mobject\e[0m \e[35mCharIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e\
    [0m and \e[33mobject\e[0m \e[35mBigDecimalIsFractional\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e[33mmethod\e\
    [0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m--\
    \ [E134] Type Error: /tmp/tmp073wgmmn.scala:34:89 -----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                \e[33mval\e[0m \e[36mstrength_sorted_sorted\e\
    [0m = extensions_sorted_sorted_upper.map(_.length - extensions_sorte"
  stdout: ''
  timestamp: 1659799585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper_sm = extensions_count_upper - extensions_count_lower\
    \ - extensions_count\n        val extensions_count_lower_sm = extensions_count_lower\
    \ - extensions_count_upper - extensions_count\n        val extensions_count_upper_sm_extensions_count_upper\
    \ = extensions_count_upper_sm - extensions_count_upper\n        val extensions_count_lower_sm_extensions_count_lower\
    \ = extensions_count_lower_sm - extensions_count_lower\n        val extensions_count_upper_sm_extensions_count_lower_sm\
    \ = extensions_count_upper_sm_extensions_count_upper - extensions_count_lower_sm\n\
    \        val extensions_count_lower_sm_extensions_count_upper_sm = extensions_count_lower_sm_extensions_count_lower\
    \ - extensions_count_upper_sm\n        val extensions_count_upper_sm_extensions_count_lower_sm_extensions_count_upper_sm\
    \ = extensions_count_upper_sm_extensions_count_lower_sm - extensions_count_lower_sm_extensions_count_upper_sm\n\
    \        val extensions_count_lower_sm_extensions_count_upper_sm_extensions_count_lower_sm\
    \ = extensions_count_lower_sm_extensions_count_upper_sm - extensions_count_upper_sm_extensions_count_lower_sm\n\
    \        val extensions_count_upper_sm_extensions_count_lower_sm_extensions_count_upper_sm_extensions_count_lower_sm\
    \ = extensions_count_upper_sm_extensions_count_lower_sm_extensions_count_upper_sm\
    \ - extensions_count_lower_sm_extensions_count_upper_sm_extensions_count_lower_sm\n\
    \        val extensions_count_lower_sm_extensions_count_upper_sm_extensions_count_lower_sm_extensions_count_upper_sm_extensions_count_lower_sm\
    \ = extensions_count_lower_sm_extensions_count_upper_sm_extensions_count_lower_sm\
    \ - extensions_count_upper_sm_extensions_count_lower_sm_extensions_count_upper_sm_extensions_count_lower_sm\n\
    \        val extensions_count_upper_sm_extensions_count_lower_sm_extensions_count_upper_sm_extensions_count_lower_sm_extensions_count_upper_sm_extensions_count_lower_sm\
    \ = extensions_count_upper_sm_extensions_count_lower_sm_extensions_count_upper_sm_extensions_count_lower_sm\
    \ - extensions_count_lower_sm_extensions_count_upper_sm_extensions_count_lower_sm_extensions_count_upper_sm_extensions_count_lower_sm\n\
    \        val extensions_count_lower_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbfye1782.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpbfye1782.scala:37:5 ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659799585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toUpperCase.length).toArray\n\
    \        val max_strength = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = strength(max_key)\n        val max_key = class_name_map.keys.toArray.max\n\
    \        val max_value = class_name_map.get(max_key)\n        val max_key = max_key.map(x\
    \ => x.toUpperCase).max\n        val max_value = max_value.map(x => x.toUpperCase).max\n\
    \        val max_key = max_key.map(x => x.toLowerCase).max\n        val max_value\
    \ = max_value.map(x => x.toLowerCase).max\n        val max_key = max_key.map(x\
    \ => x.toUpperCase).max\n        val max_value = max_value.map(x => x.toUpperCase).max\n\
    \        val max_key = max_key.map(x => x.toLowerCase).max\n        val max_value\
    \ = max_value.map(x => x.toLowerCase).max\n        val max_key = max_key.map(x\
    \ => x.toUpperCase).max\n        val max_value = max_value.map(x => x.toUpperCase).max\n\
    \        val max_key = max_key.map(x => x.toLowerCase).max\n        val max_value\
    \ = max_value.map(x => x.toLowerCase).max\n        val max_key = max_key.map(x\
    \ => x.toUpperCase).max\n        val max_value = max_value.map(x => x.toUpperCase).max\n\
    \        val max_key = max_key.map(x => x.toLowerCase).max\n        val max_value\
    \ = max_value.map(x => x.toLowerCase).max\n        val max_key = max_key.map(x\
    \ => x.toUpperCase).max\n        val max_value = max_value.map(x => x.toUpperCase).max\n\
    \        val max_key = max_key.map(x => x.toLowerCase).max\n        val max_value\
    \ = max_value.map(x => x.toLowerCase).max\n        val max_key = max_key.map(x\
    \ => x.toUpperCase).max\n        val max_value = max_value.map(x => x.toUpperCase).max\n\
    \        val max_key = max_key.map(x => x.toLowerCase).max\n        val max_value\
    \ = max_value.map(x => x.toLowerCase).max\n        val max_key = max_key.map(x\
    \ => x.toUpperCase).max\n        val max_value = max_value.map(x => x.toUpperCase).max\n\
    \        val max_key = max_key.map(x => x.toLowerCase).max\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8a9_dupc.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = class_name_map.keys.toArray.max\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key is already defined as \e[33mvalue\e[0m \e[35mmax_key\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8a9_dupc.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mmax_value\e[0m = class_name_map.get(max_key)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_value is already defined as \e[33mvalue\e[0m \e[35mmax_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8a9_dupc.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = max_key.map(\e[36mx\e\
    [0m => x.toUpperCase).max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key is already defined as \e[33mvalue\e[0m \e[35mmax_key\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8a9_dupc.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mmax_value\e[0m = max_value.map(\e[36mx\e\
    [0m => x.toUpperCase).max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_value is already defined as \e[33mvalue\e[0m \e[35mmax_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8a9_dupc.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = max_key.map(\e[36mx\e\
    [0m => x.toLowerCas"
  stdout: ''
  timestamp: 1659799589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase).zipWithIndex.toMap\n        val class_name_map\
    \ = class_name.zipWithIndex.toMap\n        val extensions_count = extensions_map.size\n\
    \        val class_name_count = class_name_map.size\n        val strength = extensions_count\
    \ - class_name_count\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._2).reverse\n\
    \        val class_name_sorted = class_name_map.toSeq.sortBy(_._2).reverse\n \
    \       val class_name_strength = class_name_sorted.map(x => x._1).sum\n     \
    \   val extensions_strength = extensions_sorted.map(x => x._1).sum\n        val\
    \ strength_fraction = strength / extensions_count\n        val strength_fraction\
    \ = strength_fraction * 100\n        val strength_fraction = strength_fraction.toInt\n\
    \        if (strength_fraction < 0) strength_fraction = 0\n        if (strength_fraction\
    \ > 100) strength_fraction = 100\n        if (strength_fraction == 0) strength_fraction\
    \ = 1\n        val strength_fraction = strength_fraction.toString.padLeft(2, '0')\n\
    \        val strength_fraction = strength_fraction.substring(0, strength_fraction.length\
    \ - 1)\n        val class_name_strength = class_name_strength.toString.padLeft(2,\
    \ '0')\n        val class_name_strength = class_name_strength.substring(0, class_name_strength.length\
    \ - 1)\n        if (strength_fraction < class_name_strength) class_name_strength\
    \ + extensions_strength\n        else class_name_strength + extensions_strength\
    \ + extensions_fraction\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7idkyoef.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mstrength_fraction\e[0m =\
    \ strength_fraction * \e[31m100\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_fraction is already defined as \e[33mvalue\e[0m \e\
    [35mstrength_fraction\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7idkyoef.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mstrength_fraction\e[0m =\
    \ strength_fraction.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_fraction is already defined as \e[33mvalue\e[0m \e\
    [35mstrength_fraction\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7idkyoef.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mstrength_fraction\e[0m =\
    \ strength_fraction.toString.padLeft(\e[31m2\e[0m, \e[31m'0'\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_fraction is already defined as \e[33mvalue\e[0m \e\
    [35mstrength_fraction\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7idkyoef.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mstrength_fraction\e[0m =\
    \ strength_fraction.substring(\e[31m0\e[0m, strength_fraction.length - \e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_fraction is already defined as \e[33mvalue\e[0m \e\
    [35mstrength_fraction\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of topl"
  stdout: ''
  timestamp: 1659799587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val sorted_extensions = extensions_map.toList.sortWith(x => x._2\
    \ > x._1)\n        val extension = sorted_extensions.find(x => x._2 == strength).getOrElse(\"\
    \")\n        class_name + extension\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp43jw5463.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1659799587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.count\n        val extensions_count_upper = extensions.count(x\
    \ => x.toUpperCase == x)\n        val extensions_count_lower = extensions.count(x\
    \ => x.toLowerCase == x)\n        val extensions_count_diff = extensions_count_upper\
    \ - extensions_count_lower\n        val extensions_count_diff_upper = extensions_count_diff\
    \ / extensions_count_upper\n        val extensions_count_diff_lower = extensions_count_diff\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_upper = extensions_count_diff_upper\
    \ / extensions_count_upper\n        val extensions_count_diff_diff_lower = extensions_count_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper / extensions_count_upper\n        val extensions_count_diff_diff_diff_lower\
    \ = extensions_count_diff_diff_lower / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper / extensions_count_upper\n        val\
    \ extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper / extensions_count_upper\n    \
    \    val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\
    \ / extensions_count_lower\n        val extensions_count_diff_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_diff_lower\
    \ / extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc0xwtxuo.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_lower / extensions_count_lower\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpc0xwtxuo.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_upper\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_diff_upper is already\
    \ defined as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_diff_upper\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc0xwtxuo.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_diff_upper\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_diff_upper / extensions_count_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_diff_diff_upper is already\
    \ defined as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_diff_diff_upper\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in th"
  stdout: ''
  timestamp: 1659799587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).max\n    \
    \    val extensions_sorted = extensions_map.values.sortWith((x, y) => strength\
    \ - y)\n        val class_name_sorted = class_name_map.values.sortWith((x, y)\
    \ => strength - y)\n        val extensions_sorted_list = extensions_sorted.map(x\
    \ => class_name_sorted + x).mkString(\".\")\n        extensions_sorted_list\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyp7gc6xb.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpyp7gc6xb.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpyp7gc6xb.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpyp7gc6xb.scala:23:78 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\e[31m\e[31m   |\e[0m    \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   (x : String)\n\e[31m   |\e[0m                                            \
    \      Required: Nothing\n\e[31"
  stdout: ''
  timestamp: 1659799589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val strength_upper = strength.toDouble / extensions_count.toDouble\n    \
    \    val strength_lower = strength.toDouble / extensions_count.toDouble\n    \
    \    val extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val\
    \ extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val strength_upper\
    \ = strength_upper.toDouble / extensions_count_upper.toDouble\n        val strength_lower\
    \ = strength_lower.toDouble / extensions_count_lower.toDouble\n        val extensions_count_upper\
    \ = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n\
    \        val strength_upper = strength_upper.toDouble / extensions_count_upper.toDouble\n\
    \        val strength_lower = strength_lower.toDouble / extensions_count_lower.toDouble\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_upper = strength_upper.toDouble / extensions_count_upper.toDouble\n\
    \        val strength_lower = strength_lower.toDouble / extensions_count_lower.toDouble\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_upper = strength_upper.toDouble / extensions_count_upper.toDouble\n\
    \        val strength_lower = strength_lower.toDouble / extensions_count_lower.toDouble\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_upper = strength_upper.toDouble / extensions_count_upper.toDouble\n\
    \        val strength_lower = strength_lower.toDouble / extensions_count_lower.toDouble\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_upper = strength_upper.toDouble / extensions_count_upper.toDouble\n\
    \        val strength_lower = strength_lower.toDouble / extensions_count_\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5mzsafl.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper\e\
    [0m = extensions.map(_.toUpperCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5mzsafl.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy5mzsafl.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mstrength_upper\e[0m = strength_upper.toDouble\
    \ / extensions_count_upper.toDouble\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_upper is already defined as \e[33mvalue\e[0m \e[35mstrength_upper\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpy5mzsafl.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mstrength_lower\e[0m = strength_lower.toDouble\
    \ / extensions_count_lower.toDouble\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_lower is already defined as \e[33mvalue\e[0m \e[35mstrength_lower\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all b"
  stdout: ''
  timestamp: 1659799588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase - x.toLowerCase -> x)).toMap\n        val\
    \ class_name_map = class_name.map(x => (x.toUpperCase - x.toLowerCase -> x)).toMap\n\
    \        val max_strength = extensions_map.values.foldLeft(0)((x, y) => if (x\
    \ > y) x else y)\n        val max_key = extensions_map.keys.foldLeft(0)((x, y)\
    \ => if (x > y) x else y)\n        val max_key_index = max_key - 1\n        val\
    \ max_key_value = extensions_map.get(max_key)\n        val max_key_value_map =\
    \ max_key_value.map(x => (x.toUpperCase - x.toLowerCase -> x)).toMap\n       \
    \ val max_key_value_map_keys = max_key_value_map.keys\n        val max_key_value_map_values\
    \ = max_key_value_map.values\n        val max_key_value_map_keys_sorted = max_key_value_map_keys.sortWith(_\
    \ < _)\n        val max_key_value_map_values_sorted = max_key_value_map_values.sortWith(_\
    \ < _)\n        val max_key_value_map_keys_sorted_index = max_key_value_map_keys_sorted.indexOf(max_key_value_map_keys_sorted[0])\n\
    \        val max_key_value_map_values_sorted_index = max_key_value_map_values_sorted.indexOf(max_key_value_map_values_sorted[0])\n\
    \        val max_key_value_map_keys_sorted_value = max_key_value_map_keys_sorted[max_key_value_map_keys_sorted_index]\n\
    \        val max_key_value_map_values_sorted_value = max_key_value_map_values_sorted[max_key_value_map_values_sorted_index]\n\
    \        val max_key_value_map_keys_sorted_value_map = max_key_value_map_keys_sorted_value.map(x\
    \ => (x.toUpperCase - x.toLowerCase -> x)).toMap\n        val max_key_value_map_values_sorted_value_map\
    \ = max_key_value_map_values_sorted_value.map(x => (x.toUpperCase - x.toLowerCase\
    \ -> x)).toMap\n        val max_key_value_map_keys_sorted_value_map_keys = max_key_value_map_keys_sorted_value_map.keys\n\
    \        val max_key_value_map_keys_sorted_value_map_values = max_key_value_map_keys_sorted_value_map.values\n\
    \        val max_key_value_map_keys_sorted_value_map_keys_sorted = max_key_value_map_keys_sorted_value_map_keys.sortWith(_\
    \ < _)\n        val max_key_value_map_keys_sorted_value_map_values_sorted = max_key_value_map_keys_sorted_value_map_values.sortWith(_\
    \ < _)\n        val max_key_value_map_keys_sorted_value_map_keys_sorted_index\
    \ = max_key_value_map_keys_sorted_value_map_keys_sorted.indexOf(max_key_value_map_keys_sorted_value_map_keys_sorted[0])\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt0qglw14.scala:21:64 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36mx\e[0m => (x.toUpperCase - x.toLowerCase -> x)).toMap\n\e[31m\e[31m   |\e\
    [0m                                                  ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue - is not a member of String, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpt0qglw14.scala:22:52\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase - x.toLowerCase\
    \ -> x)).toMap\n\e[31m\e[31m   |\e[0m                                        \
    \          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value\
    \ toUpperCase is not a member of Char\n\e[31m\e[31m-- [E051] Reference Error:\
    \ /tmp/tmpt0qglw14.scala:23:77 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mmax_strength\e[0m = extensions_map.values.foldLeft(\e\
    [31m0\e[0m)((\e[36mx\e[0m, \e[36my\e[0m) => \e[33mif\e[0m (x > y) x \e[33melse\e\
    [0m y)\n\e[31m\e[31m   |\e[0m                                                \
    \                           ^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m>\e[0m in \e[33mclass\e[0m \e[35mInt\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float):\
    \ Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\
    \e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m\
    \   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0mall match arguments ((y : Nothing))\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E051] Reference"
  stdout: ''
  timestamp: 1659799589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper_ratio = extensions_count_upper / extensions_count.toDouble\n\
    \        val extensions_count_lower_ratio = extensions_count_lower / extensions_count.toDouble\n\
    \        val strength_ratio = strength / extensions_count.toDouble\n        val\
    \ extensions_count_ratio = extensions_count / extensions_count.toDouble\n    \
    \    val extensions_count_ratio2 = extensions_count_ratio / extensions_count_ratio\n\
    \        val extensions_count_ratio3 = extensions_count_ratio * extensions_count_ratio\n\
    \        val extensions_count_ratio4 = extensions_count_ratio * extensions_count_ratio\
    \ * extensions_count_ratio\n        val extensions_count_ratio5 = extensions_count_ratio\
    \ * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio\n\
    \        val extensions_count_ratio6 = extensions_count_ratio * extensions_count_ratio\
    \ * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio\n\
    \        val extensions_count_ratio7 = extensions_count_ratio * extensions_count_ratio\
    \ * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio *\
    \ extensions_count_ratio\n        val extensions_count_ratio8 = extensions_count_ratio\
    \ * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio *\
    \ extensions_count_ratio * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio\n\
    \        val extensions_count_ratio9 = extensions_count_ratio * extensions_count_ratio\
    \ * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio *\
    \ extensions_count_ratio * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio\
    \ * extensions_count_ratio * extensions_count_ratio\n        val extensions_count_ratio10\
    \ = extensions_count_ratio * extensions_count_ratio * extensions_count_ratio *\
    \ extensions_count_ratio * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio\
    \ * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio *\
    \ extensions_count_ratio * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio\
    \ * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio *\
    \ extensions_count_ratio * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio\
    \ * extensions_count_ratio * extensions_count_ratio * extensions_count_ratio\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_dn7vusw.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase - e.toLowerCase -> 1)).toMap\n        val\
    \ class_name_map = class_name.map(c => (c.toUpperCase - c.toLowerCase -> 1)).toMap\n\
    \        val max_extension = extensions_map.maxBy(_._2)._1\n        val max_class_name\
    \ = class_name_map.maxBy(_._2)._1\n        val strength = max_class_name - max_extension\n\
    \        val class_name = max_class_name\n        val extension = max_extension\n\
    \        class_name + \".\" + extension\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphbnwastb.scala:21:64 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => (e.toUpperCase - e.toLowerCase -> \e[31m1\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                  ^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmphbnwastb.scala:24:29 ---------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmax_class_name\e[0m = class_name_map.maxBy(_._2)._1\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         Recursive \e[33mvalue\e[0m \e[35mclass_name_map\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmphbnwastb.scala:23:54\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mmax_extension\e[0m = extensions_map.maxBy(_._2)._1\n\e\
    [31m\e[31m   |\e[0m                                                      ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mLong\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ cmp of \e[33mmethod\e[0m \e[35mmaxBy\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n3 errors found\n"
  stdout: ''
  timestamp: 1659799588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val sorted_extensions = extensions_map.toSeq.sortBy(_._2).reverse\n\
    \        val first_extension = sorted_extensions.head._1\n        val first_extension_strength\
    \ = sorted_extensions.head._2\n        val second_extension = sorted_extensions.last._1\n\
    \        val second_extension_strength = sorted_extensions.last._2\n        val\
    \ strength_difference = strength - first_extension_strength - second_extension_strength\n\
    \        if(strength_difference < 0)\n            first_extension\n        else\n\
    \            second_extension\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0h48glaj.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1659799588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        var strongest_extension\
    \ = \"\"\n        var strongest_extension_strength = -1\n        var strongest_extension_strength_counter\
    \ = 0\n        var strongest_extension_strength_counter2 = 0\n        var strongest_extension_strength_counter3\
    \ = 0\n        var strongest_extension_strength_counter4 = 0\n        var strongest_extension_strength_counter5\
    \ = 0\n        var strongest_extension_strength_counter6 = 0\n        var strongest_extension_strength_counter7\
    \ = 0\n        var strongest_extension_strength_counter8 = 0\n        var strongest_extension_strength_counter9\
    \ = 0\n        var strongest_extension_strength_counter10 = 0\n        var strongest_extension_strength_counter11\
    \ = 0\n        var strongest_extension_strength_counter12 = 0\n        var strongest_extension_strength_counter13\
    \ = 0\n        var strongest_extension_strength_counter14 = 0\n        var strongest_extension_strength_counter15\
    \ = 0\n        var strongest_extension_strength_counter16 = 0\n        var strongest_extension_strength_counter17\
    \ = 0\n        var strongest_extension_strength_counter18 = 0\n        var strongest_extension_strength_counter19\
    \ = 0\n        var strongest_extension_strength_counter20 = 0\n        var strongest_extension_strength_counter21\
    \ = 0\n        var strongest_extension_strength_counter22 = 0\n        var strongest_extension_strength_counter23\
    \ = 0\n        var strongest_extension_strength_counter24 = 0\n        var strongest_extension_strength_counter25\
    \ = 0\n        var strongest_extension_strength_counter26 = 0\n        var strongest_extension_strength_counter27\
    \ = 0\n        var strongest_extension_strength_counter28 = 0\n        var strongest_extension_strength_counter29\
    \ = 0\n        var strongest_extension_strength_counter30 = 0\n        var strongest_extension_strength_counter31\
    \ = 0\n        var strongest_extension_strength_counter32 = 0\n        var strongest_extension_strength_counter33\
    \ = 0\n        var strongest_extension_strength_counter34 = 0\n        var strongest_extension_strength_counter35\
    \ = 0\n        var strongest_extension_strength_counter36 = 0\n        var strongest_extension_strength_counter37\
    \ = 0\n        var strongest_extension_strength_counter38 = 0\n        var strongest_extension_strength_counter39\
    \ = 0\n        var strongest_extension_strength_counter40 = 0\n        var strongest_extension_strength_counter41\
    \ = 0\n        var strongest_extension_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplfr6vjoa.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmplfr6vjoa.scala:65:5 ---------------------\e[0m\e[0m\n\e[31m65 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659799588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(_.toUpperCase).zip(extensions.map(_.toLowerCase)).toMap\n \
    \       val class_name_map = class_name.map(_.toUpperCase).zip(class_name.map(_.toLowerCase)).toMap\n\
    \        val strength = extensions_map.values.map(x => (x.toInt - class_name_map.getOrElse(x,\
    \ 0)))\n        val max_strength = strength.max\n        val max_index = strength.indexWhere(x\
    \ => x == max_strength)\n        val max_extension = extensions(max_index)\n \
    \       val class_name_with_max_extension = class_name ++ max_extension\n    \
    \    val extensions_with_max_extension = extensions filterNot (x => x == max_extension)\n\
    \        val extensions_with_max_extension_map = extensions_with_max_extension.map(_.toUpperCase).zip(extensions_with_max_extension.map(_.toLowerCase)).toMap\n\
    \        val strength_with_max_extension = extensions_map.values.map(x => (x.toInt\
    \ - extensions_with_max_extension_map.getOrElse(x, 0)))\n        val max_strength_with_max_extension\
    \ = strength_with_max_extension.max\n        val max_index_with_max_extension\
    \ = strength_with_max_extension.indexWhere(x => x == max_strength_with_max_extension)\n\
    \        val max_extension_with_max_extension = extensions_with_max_extension(max_index_with_max_extension)\n\
    \        val extensions_with_max_extension_with_max_extension = extensions_with_max_extension\
    \ filterNot (x => x == max_extension_with_max_extension)\n        val extensions_with_max_extension_with_max_extension_map\
    \ = extensions_with_max_extension_with_max_extension.map(_.toUpperCase).zip(extensions_with_max_extension_with_max_extension.map(_.toLowerCase)).toMap\n\
    \        val strength_with_max_extension_with_max_extension = extensions_map.values.map(x\
    \ => (x.toInt - extensions_with_max_extension_with_max_extension_map.getOrElse(x,\
    \ 0)))\n        val max_strength_with_max_extension_with_max_extension = strength_with_max_extension_with_max_extension.max\n\
    \        val max_index_with_max_extension_with_max_extension = strength_with_max_extension_with_max_extension.indexWhere(x\
    \ => x == max_strength_with_max_extension_with_max_extension)\n        val max_extension_with_max_extension_with_max_extension\
    \ = extensions_with_max_extension_with_max_extension(max_index_with_max_extension_with_max_extension)\n\
    \        val extensions_with_max_extension_with_max_extension_with_max_extension\
    \ = extensions_with_max_extension_with_max_extension filterNot (x => x == max_extension_with_max_extension_with_max_extension_with_max_extension)\n\
    \        val extensions_with_max_extension_with_max_extension_with_max_extension_map\
    \ = extensions_with_max_extension_with_max_extension_with_max_extension.map(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp2o624x9e.scala:41:158 --------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mextensions_with_max_extension_with_max_extension_with_max_extension_map\e\
    [0m = extensions_with_max_extension_with_max_extension_with_max_extension.map(\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \            expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp2o624x9e.scala:22:46 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(_.toUpperCase).zip(class_name.map(_.toLowerCase)).toMap\n\
    \e[31m\e[31m   |\e[0m                                            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmp2o624x9e.scala:24:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmax_strength\e[0m = strength.max\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mLong\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e[35mmax\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp2o624x9e.scala:25:33 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmax_index\e[0m = strength.indexWhere(\e\
    [36mx\e[0m => x == max_strength)\n\e[31m\e[31m   |\e[0m                      \
    \  ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   value indexWhere\
    \ is not a member of Iterable[Nothing]\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp2o624x9e.scala:30:82\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e"
  stdout: ''
  timestamp: 1659799589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val strength_upper = strength / extensions_count_upper\n        val strength_lower\
    \ = strength / extensions_count_lower\n        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n    \
    \    val extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val\
    \ extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val extensions_count_upper\
    \ = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower\
    \ = extensions.map(_.toLowerCase).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n    \
    \    val extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val\
    \ extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val extensions_count_upper\
    \ = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower\
    \ = extensions.map(_.toLowerCase).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n    \
    \    val extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val\
    \ extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val extensions_count_upper\
    \ = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower\
    \ = extensions.\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4wmomx6b.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp4wmomx6b.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper\e[0m = extensions.map(_.toUpperCase).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4wmomx6b.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4wmomx6b.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper\e\
    [0m = extensions.map(_.toUpperCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4wmomx6b.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e["
  stdout: ''
  timestamp: 1659799589
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val extensions_count\
    \ = extensions_map.size\n        val class_name_count = class_name_map.size\n\
    \        val strength = extensions_count - class_name_count\n        if (strength\
    \ == 0) class_name\n        else if (strength > 0) class_name + extensions_map.getOrElse(class_name_map.getOrElse(strength,\
    \ \"\"), \"\")\n        else class_name + extensions_map.getOrElse(class_name_map.getOrElse(strength,\
    \ \"\"), \"\") + extensions_map.getOrElse(class_name_map.getOrElse(strength, \"\
    \"), \"\")\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpie8lm_eo.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpie8lm_eo.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpie8lm_eo.scala:27:94\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33melse\e[0m \e[33mif\e\
    [0m (strength > \e[31m0\e[0m) class_name + extensions_map.getOrElse(class_name_map.getOrElse(strength,\
    \ \e[31m\"\"\e[0m), \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                                                                            ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                              Found:    (strength\
    \ : Int)\n\e[31m   |\e[0m                                              Required:\
    \ Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpie8lm_eo.scala:28:76\
    \ --------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33melse\e[0m class_name\
    \ + extensions_map.getOrElse(class_name_map.getOrElse(strength, \e[31m\"\"\e[0m),\
    \ \e[31m\"\"\e[0m) + extensions_map.getOrElse(class_name_map.getOrElse(strength,\
    \ \e[31m\"\"\e[0m), \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                  \
    \                                                          ^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                              Found:    (strength :\
    \ Int)\n\e[31m   |\e[0m                                              Required:\
    \ Nothin"
  stdout: ''
  timestamp: 1659799576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.foldLeft(0)((acc, x) => acc + (class_name_map(x._1) - class_name_map(x._2)))\n\
    \        val strongest_extension = extensions_map.maxBy(x => strength(x._1))\n\
    \        val strongest_extension_class = class_name_map(strongest_extension._1)\n\
    \        val strongest_extension_name = strongest_extension._2\n        val strongest_extension_class_name\
    \ = class_name_map(strongest_extension_class)\n        val strongest_extension_class_name_with_extension\
    \ = strongest_extension_class + \".\" + strongest_extension_name\n        val\
    \ strongest_extension_class_name_with_extension_with_slash = strongest_extension_class_name_with_extension\
    \ + \".\"\n        val strongest_extension_class_name_with_extension_with_slash_with_slash\
    \ = strongest_extension_class_name_with_extension_with_slash + \"/\"\n       \
    \ val strongest_extension_class_name_with_extension_with_slash_with_slash_with_slash\
    \ = strongest_extension_class_name_with_extension_with_slash_with_slash + \"//\"\
    \n        val strongest_extension_class_name_with_extension_with_slash_with_slash_with_slash_with_slash\
    \ = strongest_extension_class_name_with_extension_with_slash_with_slash_with_slash\
    \ + \"///\"\n        val strongest_extension_class_name_with_extension_with_slash_with_slash_with_slash_with_slash_with_slash\
    \ = strongest_extension_class_name_with_extension_with_slash_with_slash_with_slash_with_slash\
    \ + \"////\"\n        val strongest_extension_class_name_with_extension_with_slash_with_slash_with_slash_with_slash_with_slash_with_slash\
    \ = strongest_extension_class_name_with_extension_with_slash_with_slash_with_slash_with_slash_with_slash\
    \ + \"/////\"\n        val strongest_extension_class_name_with_extension_with_slash_with_slash_with_slash_with_slash_with_slash_with_slash_with_slash_with_slash\
    \ = strongest_extension_class_name_with_extension\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0pcwx1jk.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp0pcwx1jk.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0pcwx1jk.scala:23:86\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) =>\
    \ acc + (class_name_map(x._1) - class_name_map(x._2)))\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \        ^^^^\e[0m\n\e[31m   |\e[0m                                          \
    \             Found:    String\n\e[31m   |\e[0m                              \
    \                         Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp0pcwx1jk.scala:23:109 -------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.foldLeft(\e\
    [31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc + (class_name_map(x._1) - class_name_map(x._2)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                   ^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                       Found:    String\n\e[31m\
    \   |\e[0m                                                       Required: Nothing\n\
    \e[31m   |\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659799591
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val strength = extensions_count - class_name_length\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => strength - a.length - b.length)\n        val\
    \ extensions_sorted = extensions_sorted.take(1).mkString.concat(\".\").concat(extensions_sorted.last)\n\
    \        class_name+\".\"+extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpx_tzmek1.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(\e[31m1\e[0m).mkString.concat(\e[31m\".\"\e[0m).concat(extensions_sorted.last)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpx_tzmek1.scala:24:62 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                                     Found:    Int\n\e[31m   |\e[0m         \
    \                                              Required: Boolean\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659799588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwr_y4wp9.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwr_y4wp9.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_._2 > \e[31m0\e\
    [0m).map(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwr_y4wp9.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwr_y4wp9.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpwr_y4wp9.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^"
  stdout: ''
  timestamp: 1659799590
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x,\
    \ y) => if (x == 0) y else x + y)\n        val strength_map = strength.toMap\n\
    \        val strongest_extension = extensions_map.values.find(x => strength_map.contains(x))\n\
    \        strongest_extension match {\n            case Some(extension) => class_name_map\
    \ + extension\n            case None => class_name\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv464nda4.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpv464nda4.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv464nda4.scala:23:120\
    \ -------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => (x.toUpperCase, x.toLowerCase)).foldLeft(\e\
    [31m0\e[0m)((\e[36mx\e[0m, \e[36my\e[0m) => \e[33mif\e[0m (x == \e[31m0\e[0m)\
    \ y \e[33melse\e[0m x + y)\n\e[31m\e[31m   |\e[0m                            \
    \                                                                            \
    \                ^\e[0m\n\e[31m   |\e[0m                                     \
    \   Found:    (y : (String, String))\n\e[31m   |\e[0m                        \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpv464nda4.scala:23:129 ----------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).foldLeft(\e[31m0\e[0m)((\e[36mx\e\
    [0m, \e[36my\e[0m) => \e[33mif\e[0m (x == \e[31m0\e[0m) y \e[33melse\e[0m x +\
    \ y)\n\e[31m\e[31m   |\e[0m                                                  \
    \                                                                            \
    \ ^^^\e[0m\n\e[31m   |\e[0m None of the overloaded alternat"
  stdout: ''
  timestamp: 1659799591
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_cap = extensions.map(_.toUpperCase.length).sum -\
    \ extensions.map(_.toLowerCase.length).sum\n        val extensions_count_sm =\
    \ extensions.map(_.toLowerCase.length).sum - extensions.map(_.toUpperCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower - extensions_count_cap\
    \ - extensions_count_sm\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength.compareTo(a.toString.length - b.toString.length))\n        val\
    \ extensions_sorted = extensions_sorted.take(extensions_sorted.length-1)\n   \
    \     val extensions_sorted = extensions_sorted.mkString(\"\") + \".\" + extensions_sorted.last\n\
    \        val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val class_name_sorted = class_name_upper +\
    \ class_name_lower\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^A-Z]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^a-z]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^0-9]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^_]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^0-9]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^_]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^0-9]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^_]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^0-9]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^_]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^0-9]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^_]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^0-9]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^_]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^0-9]\", \"\")\n        val class_name_sorted = class_name_sorted.replaceAll(\"\
    [^_]\", \"\")\n        val class_name_sorted = class_name_sorted.replace\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkiw9wr2p.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(extensions_sorted.length-\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpkiw9wr2p.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m) + \e[31m\".\"\e[0m + extensions_sorted.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpkiw9wr2p.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mclass_name_sorted\e[0m =\
    \ class_name_sorted.replaceAll(\e[31m\"[^A-Z]\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mclass_name_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpkiw9wr2p.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mclass_name_sorted\e[0m =\
    \ class_name_sorted.replaceAll(\e[31m\"[^a-z]\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mclass_name_"
  stdout: ''
  timestamp: 1659799590
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val sorted_extensions = extensions_map.toSeq.sortBy(_._2).reverse\n\
    \        val first_extension = sorted_extensions.head\n        val first_extension_strength\
    \ = first_extension._2\n        if (strength == 0) first_extension\n        else\
    \ if (strength < first_extension_strength) first_extension\n        else class_name\
    \ + first_extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp_dh4qyry.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1659799595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith((a,\
    \ b) => b.length - a.length)\n        val extensions_count_sorted_reversed = extensions_count_sorted.reverse\n\
    \        val extensions_count_sorted_reversed_length = extensions_count_sorted_reversed.map(_.length)\n\
    \        val extensions_count_sorted_reversed_length_sum = extensions_count_sorted_reversed_length.sum\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted = extensions_count_sorted_reversed_length.sortWith((a,\
    \ b) => b - a)\n        val extensions_count_sorted_reversed_length_sum_sorted_reversed\
    \ = extensions_count_sorted_reversed_length_sum_sorted.reverse\n        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed.map(_.length)\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length.sum\n \
    \       val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length.sortWith((a,\
    \ b) => b - a)\n        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed.reverse\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length.map(_.length)\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sorted.sum\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sorted.sortWith((a,\
    \ b) => b - a)\n        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sorted.sum\n\
    \        val extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted\
    \ = extensions_count_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sum_sorted_reversed_length_sorted.sortWith((a,\
    \ b) => b - a)\n        val \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\",\
    \ \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp92e9tl59.scala:37:11 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp92e9tl59.scala:22:68 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => b.length - a.length)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \                                Found:    Int\n\e[31m   |\e[0m              \
    \                                         Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp92e9tl59.scala:26:124 -------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_reversed_length_sum_sorted\e\
    [0m = extensions_count_sorted_reversed_length.sortWith((\e[36ma\e[0m, \e[36mb\e\
    [0m) => b - a)\n\e[31m\e[31m   |\e[0m                                        \
    \                                                                            \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                                         \
    \              Found:    Int\n\e[31m   |\e[0m                                \
    \                       Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp92e9tl59.scala:28:147 -----------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_reversed_length_sum_sorted_reversed_length\e\
    [0m = extensions_count_sorted_reversed_length_sum_sorted_reversed.map(_.length)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \             ^^^^^^^^\e[0m"
  stdout: ''
  timestamp: 1659799600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length).sum\n\
    \        val extensions_count_sorted_length_sorted = extensions_count_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted.sortWith(_.length < _.length)\n    \
    \    val extensions_count_sorted_length_sorted_length_sorted_length = extensions_count_sorted_length_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted.sortWith(_.length < _.length)\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortWith(_.length\
    \ < _.length)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0wrn2x3g.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0wrn2x3g.scala:25:90\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length\e[0m = extensions_count_sorted_length.sortWith(_.length\
    \ < _.length)\n\e[31m\e[31m   |\e[0m                                         \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   value sortWith is not a member of Int\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0wrn2x3g.scala:38:5 ---------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659799599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => a.length - b.length)\n        val extension_first\
    \ = extensions_sorted.head\n        val extension_last = extensions_sorted.last\n\
    \        val extension_length = extension_last.length - extension_first.length\n\
    \        val extension_first_upper = extension_first.substring(0,1)\n        val\
    \ extension_last_upper = extension_last.substring(0,1)\n        val extension_first_lower\
    \ = extension_first.substring(1,2)\n        val extension_last_lower = extension_last.substring(1,2)\n\
    \        val extension_first_upper_count = extension_first_upper.length\n    \
    \    val extension_last_upper_count = extension_last_upper.length\n        val\
    \ extension_first_lower_count = extension_first_lower.length\n        val extension_last_lower_count\
    \ = extension_last_lower.length\n        val extension_first_upper_sm = extension_first_upper_count\
    \ - extension_first_upper_sm_count\n        val extension_last_upper_sm = extension_last_upper_count\
    \ - extension_last_upper_sm_count\n        val extension_first_lower_sm = extension_first_lower_count\
    \ - extension_first_lower_sm_count\n        val extension_last_lower_sm = extension_last_lower_count\
    \ - extension_last_lower_sm_count\n        val extension_strength = extension_length\
    \ - extension_first_upper_sm - extension_last_lower_sm\n        if (extension_strength\
    \ > strength) {\n            class_name + extension_first\n        } else if (extension_strength\
    \ == strength) {\n            class_name + extension_first + extension_last\n\
    \        } else if (extension_strength < strength) {\n            class_name +\
    \ extension_first + extension_last + extension_first\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3t5d1qqb.scala:24:62\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e\
    [0m = extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \                          Found:    Int\n\e[31m   |\e[0m                    \
    \                                   Required: Boolean\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3t5d1qqb.scala:36:69 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mextension_first_upper_sm\e\
    [0m = extension_first_upper_count - extension_first_upper_sm_count\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \         Not found: extension_first_upper_sm_count\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3t5d1qqb.scala:37:67 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mextension_last_upper_sm\e\
    [0m = extension_last_upper_count - extension_last_upper_sm_count\n\e[31m\e[31m\
    \   |\e[0m                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: extension_last_upper_sm_count\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3t5d1qqb.scala:38:69\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e\
    [36mextension_first_lower_sm\e[0m = extension_first_lower_count - extension_first_lower_sm_count\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                    Not found: exte"
  stdout: ''
  timestamp: 1659799600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs)\n        val\
    \ max_strength = strength.max\n        val max_key = strength.maxBy(x => x)\n\
    \        val max_key = max_key.key\n        val max_value = max_key.map(x => extensions_map(x)).mkString(\"\
    .\")\n        val max_value = max_value.substring(0,max_value.lastIndexOf(\".\"\
    ))\n        class_name + max_value\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpggtulu0j.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = max_key.key\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax_key\
    \ is already defined as \e[33mvalue\e[0m \e[35mmax_key\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpggtulu0j.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_value\e[0m = max_value.substring(\e[31m0\e[0m,max_value.lastIndexOf(\e\
    [31m\".\"\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_value is already defined as \e[33mvalue\e[0m \e[35mmax_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpggtulu0j.scala:22:52 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpggtulu0j.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpggtulu0j.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs)\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^\e\
    [0m\n\e["
  stdout: ''
  timestamp: 1659799602
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val extensions_count\
    \ = extensions_map.size\n        val class_name_count = class_name_map.size\n\
    \        val strength = extensions_count - class_name_count\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val class_name_sorted =\
    \ class_name_map.toSeq.sortBy(_._1).reverse\n        val extensions_first = extensions_sorted.head._2\n\
    \        val class_name_first = class_name_sorted.head._2\n        val extensions_last\
    \ = extensions_sorted.last._2\n        val class_name_last = class_name_sorted.last._2\n\
    \        val extensions_first_index = extensions_sorted.indexOf((extensions_first.toUpperCase\
    \ + extensions_first.toLowerCase))\n        val class_name_first_index = class_name_sorted.indexOf((class_name_first.toUpperCase\
    \ + class_name_first.toLowerCase))\n        val extensions_last_index = extensions_sorted.indexOf((extensions_last.toUpperCase\
    \ + extensions_last.toLowerCase))\n        val class_name_last_index = class_name_sorted.indexOf((class_name_last.toUpperCase\
    \ + class_name_last.toLowerCase))\n        val extensions_first_index_2 = extensions_sorted.indexOf((extensions_first.toUpperCase\
    \ + extensions_first.toLowerCase))\n        val class_name_first_index_2 = class_name_sorted.indexOf((class_name_first.toUpperCase\
    \ + class_name_first.toLowerCase))\n        val extensions_last_index_2 = extensions_sorted.indexOf((extensions_last.toUpperCase\
    \ + extensions_last.toLowerCase))\n        val class_name_last_index_2 = class_name_sorted.indexOf((class_name_last.toUpperCase\
    \ + class_name_last.toLowerCase))\n        if (extensions_first_index == -1 &&\
    \ class_name_first_index == -1 && extensions_last_index == -1 && class_name_last_index\
    \ == -1) {\n            class_name + \".\" + extensions_first\n        } else\
    \ if (extensions_first_index == -1 && class_name_first_index == -1 && extensions_last_index\
    \ != -1 && class_name_last_index != -1) {\n            class_name + \".\" + extensions_last\n\
    \        } else if (extensions_first_index == -1 && class_name_first_index !=\
    \ -1 && extensions_last_index == -1 && class_name_last_index != -1) {\n      \
    \      class_name + \".\" + extensions_first\n        } else if (extensions_first_index\
    \ != -1 && class_name_first_index == -1 && extensions_last_index == -1 && class_name_last_index\
    \ != -1) {\n            class_name + \".\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpgm914h7p.scala:47:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m            class_name + \".\n\e[31m\e[31m   |\e[0m \
    \                        ^\e[0m\n\e[31m   |\e[0m                         unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmpgm914h7p.scala:49:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgm914h7p.scala:62:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m62 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpgm914h7p.scala:22:52 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpgm914h7p.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmpgm914h7p.scala:27:65 -----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mclass_name_sorted\e[0m =\
    \ class_name_map.toSeq.sortBy(_._1).reverse\n\e[31m\e[31m   |\e[0m           \
    \                                                      ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m\
    \ \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e\
    [0m \e[35mOrderin"
  stdout: ''
  timestamp: 1659799600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val strength_upper = extensions_count_upper - strength\n        val strength_lower\
    \ = extensions_count_lower - strength\n        val strength_total = strength_upper\
    \ + strength_lower\n        val strength_total_upper = strength_upper + strength_total\n\
    \        val strength_total_lower = strength_lower + strength_total\n        val\
    \ strength_total_total = strength_total_upper + strength_total_lower\n       \
    \ val strength_total_total_upper = strength_total_upper + strength_total_total\n\
    \        val strength_total_total_lower = strength_total_lower + strength_total_total\n\
    \        val strength_total_total_total = strength_total_total_upper + strength_total_total_lower\n\
    \        val strength_total_total_total_upper = strength_total_total_upper + strength_total_total_total\n\
    \        val strength_total_total_total_lower = strength_total_total_lower + strength_total_total_total\n\
    \        val strength_total_total_total_total = strength_total_total_total_upper\
    \ + strength_total_total_total_lower\n        val strength_total_total_total_total_upper\
    \ = strength_total_total_total_upper + strength_total_total_total_total\n    \
    \    val strength_total_total_total_total_lower = strength_total_total_total_lower\
    \ + strength_total_total_total_total\n        val strength_total_total_total_total_total\
    \ = strength_total_total_total_total_upper + strength_total_total_total_total_lower\n\
    \        val strength_total_total_total_total_total_upper = strength_total_total_total_total_upper\
    \ + strength_total_total_total_total_total\n        val strength_total_total_total_total_total_lower\
    \ = strength_total_total_total_total_lower + strength_total_total_total_total_total\n\
    \        val strength_total_total_total_total_total_total = strength_total_total_total_total_total_upper\
    \ + strength_total_total_total_total_total_lower\n        val strength_total_total_total_total_total_total_upper\
    \ = strength_total_total_total_total_total_upper + strength_total_total_total_total_total_total\n\
    \        val strength_total_total_total_total_total_total_lower = strength_total_total_total_total_total_lower\
    \ + strength_total_total_total_total_total_total\n        val strength_total_total_total_total_total_total_total\
    \ = strength_total_total_total_total_total_upper + strength_total_total_total_total_total_total_lower\n\
    \        val strength_total_total_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpevtjsx99.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpevtjsx99.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659799600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') / e.toUpperCase.count(_\
    \ == 'Z') * -1)\n        val extensions_sorted = extensions_map.toList.sortWith(_\
    \ < _)\n        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ < 0).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_ > 0).reverse\n\
    \        val extensions_\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpthpamj4q.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpthpamj4q.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_ > \e[31m0\e[0m).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpthpamj4q.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ < \e[31m0\e[0m).reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpthpamj4q.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ > \e[31m0\e[0m).reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpthpamj4q.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ < \e[31m0\e[0m).reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659799600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_diff = extensions_count - extensions_count_upper\n \
    \       val extensions_count_diff_lower = extensions_count - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count - extensions_count_upper\n\
    \        val extensions_count_diff_diff_lower = extensions_count - extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count - extensions_count_upper\n\
    \        val extensions_count_diff_diff_lower = extensions_count - extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count - extensions_count_upper\n\
    \        val extensions_count_diff_diff_lower = extensions_count - extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count - extensions_count_upper\n\
    \        val extensions_count_diff_diff_lower = extensions_count - extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count - extensions_count_upper\n\
    \        val extensions_count_diff_diff_lower = extensions_count - extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count - extensions_count_upper\n\
    \        val extensions_count_diff_diff_lower = extensions_count - extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count - extensions_count_upper\n\
    \        val extensions_count_diff_diff_lower = extensions_count - extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count - extensions_count_upper\n\
    \        val extensions_count_diff_diff_lower = extensions_count - extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count - extensions_count_upper\n\
    \        val extensions_count_diff_diff_lower = extensions_count - extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count - extensions_count_upper\n\
    \        val extensions_count_diff_diff_lower = extensions_count - extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count - extensions_count_upper\n\
    \        val extensions_count_diff_diff_lower = extensions_count - extensions_count_lower\n\
    \        val extensions_count_diff_diff_upper = extensions_count - extensions_count_upper\n\
    \        val extensions_count_diff_diff_lower = extension\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8_dv8aih.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_lower\e\
    [0m = extensions_count - extensions_count_lower\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_lower is already defined as \e\
    [33mvalue\e[0m \e[35mextensions_count_diff_diff_lower\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8_dv8aih.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_upper\e[0m = extensions_count - extensions_count_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_upper is already defined as \e\
    [33mvalue\e[0m \e[35mextensions_count_diff_diff_upper\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8_dv8aih.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_lower\e[0m = extensions_count - extensions_count_lower\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_lower is already defined as \e\
    [33mvalue\e[0m \e[35mextensions_count_diff_diff_lower\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8_dv8aih.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_upper\e[0m = extensions_count - extensions_count_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m"
  stdout: ''
  timestamp: 1659799602
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val strength = extensions_count - class_name_length\n        val extensions_sorted\
    \ = extensions.sortWith(_.length > _.length)\n        val extension_length = extensions_sorted.map(_.length).sum\n\
    \        val extension_strength = extension_length - class_name_length\n     \
    \   val extension_sorted = extensions_sorted.sortWith(_.length > _.length)\n \
    \       val extension_first = extension_sorted.head\n        val extension_last\
    \ = extension_sorted.last\n        val extension_first_length = extension_first.length\n\
    \        val extension_last_length = extension_last.length\n        val extension_first_strength\
    \ = extension_first_length - class_name_length\n        val extension_last_strength\
    \ = extension_last_length - class_name_length\n        val extension_first_sorted\
    \ = extension_first.sortWith(_.length > _.length)\n        val extension_last_sorted\
    \ = extension_last.sortWith(_.length > _.length)\n        val extension_first_first\
    \ = extension_first_sorted.head\n        val extension_last_first = extension_last_sorted.head\n\
    \        val extension_first_last = extension_first_sorted.last\n        val extension_last_last\
    \ = extension_last_sorted.last\n        val extension_first_first_length = extension_first_first.length\n\
    \        val extension_last_first_length = extension_last_first.length\n     \
    \   val extension_first_last_strength = extension_first_last_length - class_name_length\n\
    \        val extension_last_last_strength = extension_last_last_length - class_name_length\n\
    \        val extension_first_last_sorted = extension_first_last.sortWith(_.length\
    \ > _.length)\n        val extension_last_last_sorted = extension_last_last.sortWith(_.length\
    \ > _.length)\n        val extension_first_last_first = extension_first_last_sorted.head\n\
    \        val extension_last_last_first = extension_last_last_sorted.head\n   \
    \     val extension_first_last_last = extension_first_last_sorted.last\n     \
    \   val extension_last_last_last = extension_last_last_sorted.last\n        val\
    \ extension_first_first_strength = extension_first_first_length - class_name_length\n\
    \        val extension_last_first_strength = extension_last_first_length - class_name_length\n\
    \        val extension_first_last_last_strength = extension_first_last_last_length\
    \ - class_name_length\n        val extension_last_last_last_strength = extension_last_last_last_length\
    \ - class_name_length\n        val extension_first_first_sorted = extension_first_first.sortWith(_.length\
    \ > _.length)\n        val \n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp6uvmlw7r.scala:55:11 ---------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp6uvmlw7r.scala:34:64 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mextension_first_sorted\e\
    [0m = extension_first.sortWith(_.length > _.length)\n\e[31m\e[31m   |\e[0m   \
    \                                                           ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                    value length is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6uvmlw7r.scala:35:62\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e\
    [36mextension_last_sorted\e[0m = extension_last.sortWith(_.length > _.length)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \    ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                    value length\
    \ is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6uvmlw7r.scala:40:65\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e\
    [36mextension_first_first_length\e[0m = extension_first_first.length\n\e[31m\e\
    [31m   |\e[0m                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value length is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6uvmlw7r.scala:41:63\
    \ ------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e\
    [36mextension_last_first_length\e[0m = extension_last_first.length\n\e[31m\e[31m\
    \   |\e[0m                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value length is not a\
    \ member of Char\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6uvmlw7r.scala:42:44\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e\
    [36mextension_first_last_strength\e[0m = extension_first_last_length - class_"
  stdout: ''
  timestamp: 1659799603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toString.toString.toUpperCase.length).toArray\n\
    \        val max_strength = strength.max\n        val max_key = extensions_map.keys.max\n\
    \        val max_value = strength.max\n        val max_key_value = class_name_map.getOrElse(max_key,\
    \ 0)\n        val max_key_value_length = max_key_value.toString.toString.length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsi1chog0.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length\e[0m\
    \ = max_key_value_length + max_key_value_length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_value_length is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_value_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsi1chog0.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length\e[0m\
    \ = max_key_value_length + max_key_value_length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_value_length is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_value_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsi1chog0.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length\e[0m\
    \ = max_key_value_length + max_key_value_length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_value_length is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_value_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsi1chog0.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length\e[0m\
    \ = max_key_value_length + max_key_value_length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_value_length is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_value_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ me"
  stdout: ''
  timestamp: 1659799603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase.size, e.toLowerCase.size)).toMap\n    \
    \    val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n     \
    \   val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl3mxg942.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl3mxg942.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl3mxg942.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl3mxg942.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._1 < extensions_sorted.last._1).map(_._2)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpl3mxg942.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36m"
  stdout: ''
  timestamp: 1659799601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_frac = extensions_count_diff / extensions_count_upper\n\
    \        val extensions_count_diff_frac_upper = extensions_count_diff_frac / extensions_count_upper\n\
    \        val extensions_count_diff_frac_lower = extensions_count_diff_frac / extensions_count_lower\n\
    \        val extensions_count_diff_frac_diff = extensions_count_diff_frac_upper\
    \ - extensions_count_diff_frac_lower\n        val extensions_count_diff_frac_diff_frac\
    \ = extensions_count_diff_frac_diff / extensions_count_diff_frac_upper\n     \
    \   val extensions_count_diff_frac_diff_frac_upper = extensions_count_diff_frac_diff_frac\
    \ / extensions_count_diff_frac_upper\n        val extensions_count_diff_frac_diff_frac_lower\
    \ = extensions_count_diff_frac_diff_frac / extensions_count_diff_frac_lower\n\
    \        val extensions_count_diff_frac_diff_frac_diff = extensions_count_diff_frac_diff_frac_upper\
    \ - extensions_count_diff_frac_diff_frac_lower\n        val extensions_count_diff_frac_diff_frac_diff_frac\
    \ = extensions_count_diff_frac_diff_frac_diff_frac / extensions_count_diff_frac_diff_frac_upper\n\
    \        val extensions_count_diff_frac_diff_frac_diff_frac_upper = extensions_count_diff_frac_diff_frac_diff_frac\
    \ / extensions_count_diff_frac_diff_frac_upper\n        val extensions_count_diff_frac_diff_frac_diff_frac_lower\
    \ = extensions_count_diff_frac_diff_frac_diff_frac / extensions_count_diff_frac_diff_frac_lower\n\
    \        val extensions_count_diff_frac_diff_frac_diff_frac_diff = extensions_count_diff_frac_diff_frac_diff_frac_upper\
    \ - extensions_count_diff_frac_diff_frac_diff_frac_lower\n        val extensions_count_diff_frac_diff_frac_diff_frac_diff_frac\
    \ = extensions_count_diff_frac_diff_frac_diff_frac_diff_frac / extensions_count_diff_frac_diff_frac_diff_frac_upper\n\
    \        val extensions_count_diff_frac_diff_frac_diff_frac_diff_frac_upper =\
    \ extensions_count_diff_frac_diff_frac_diff_frac_diff_frac / \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpiiu67q64.scala:38:135 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_frac_diff_frac_diff_frac_diff_frac_upper\e\
    [0m = extensions_count_diff_frac_diff_frac_diff_frac_diff_frac / \n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                                                    ^\e[0m\n\e\
    [31m   |\e[0m                                       expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpiiu67q64.scala:33:61\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_diff_frac_diff_frac\e[0m = extensions_count_diff_frac_diff_frac_diff_frac\
    \ / extensions_count_diff_frac_diff_frac_upper\n\e[31m\e[31m   |\e[0m        \
    \                                                     ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_frac_diff_frac_diff_frac\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpiiu67q64.scala:37:71\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_diff_frac_diff_frac_diff_frac\e[0m = extensions_count_diff_frac_diff_frac_diff_frac_diff_frac\
    \ / extensions_count_diff_frac_diff_frac_diff_frac_upper\n\e[31m\e[31m   |\e[0m\
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mextensions_count_diff_frac_diff_frac_diff_frac_diff_frac\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiiu67q64.scala:39:5\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation avail"
  stdout: ''
  timestamp: 1659799600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((x, y) => if (x < y) x else y)\n\
    \        val extensions_sorted = extensions_map.values.sortWith((x, y) => x <\
    \ y)\n        val extensions_sorted = extensions_sorted.takeWhile(_ < strength)\n\
    \        val extensions_sorted = extensions_sorted.map(_._1).mkString(\"\") +\
    \ extensions_sorted.last\n        class_name + extensions_sorted\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0kut1dpz.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ < strength)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0kut1dpz.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(_._1).mkString(\e[31m\"\"\e[0m) + extensions_sorted.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0kut1dpz.scala:23:54 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.values.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x < y)\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         value sortWith is not a member of\
    \ Iterable[Int]\n3 errors found\n"
  stdout: ''
  timestamp: 1659799601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs)\n        val\
    \ max_strength = strength.max\n        val max_key = strength.maxBy(x => x)\n\
    \        val max_key = max_key.key\n        val max_value = max_key.map(x => extensions_map(x)).mkString(\"\
    \")\n        val max_key = max_key.map(x => class_name_map(x)).mkString(\"\")\n\
    \        val max_value = max_key.map(x => extensions_map(x)).mkString(\"\")\n\
    \        val max_key = max_key.map(x => class_name_map(x)).mkString(\"\")\n  \
    \      val max_value = max_key.map(x => extensions_map(x)).mkString(\"\")\n  \
    \      val max_key = max_key.map(x => class_name_map(x)).mkString(\"\")\n    \
    \    val max_value = max_key.map(x => extensions_map(x)).mkString(\"\")\n    \
    \    val max_key = max_key.map(x => class_name_map(x)).mkString(\"\")\n      \
    \  val max_value = max_key.map(x => extensions_map(x)).mkString(\"\")\n      \
    \  val max_key = max_key.map(x => class_name_map(x)).mkString(\"\")\n        val\
    \ max_value = max_key.map(x => extensions_map(x)).mkString(\"\")\n        val\
    \ max_key = max_key.map(x => class_name_map(x)).mkString(\"\")\n        val max_value\
    \ = max_key.map(x => extensions_map(x)).mkString(\"\")\n        val max_key =\
    \ max_key.map(x => class_name_map(x)).mkString(\"\")\n        val max_value =\
    \ max_key.map(x => extensions_map(x)).mkString(\"\")\n        val max_key = max_key.map(x\
    \ => class_name_map(x)).mkString(\"\")\n        val max_value = max_key.map(x\
    \ => extensions_map(x)).mkString(\"\")\n        val max_key = max_key.map(x =>\
    \ class_name_map(x)).mkString(\"\")\n        val max_value = max_key.map(x =>\
    \ extensions_map(x)).mkString(\"\")\n        val max_key = max_key.map(x => class_name_map(x)).mkString(\"\
    \")\n        val max_value = max_key.map(x => extensions_map(x)).mkString(\"\"\
    )\n        val max_key = max_key.map(x => class_name_map(x)).mkString(\"\")\n\
    \        val max_value = max_key.map(x => extensions_map(x)).mkString(\"\")\n\
    \        val max_key = max_key.map(x => \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmph9vk4f4x.scala:50:38 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = max_key.map(\e\
    [36mx\e[0m => \n\e[31m\e[31m   |\e[0m                                      ^\e\
    [0m\n\e[31m   |\e[0m                                      expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph9vk4f4x.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = max_key.key\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax_key is already\
    \ defined as \e[33mvalue\e[0m \e[35mmax_key\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph9vk4f4x.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_key\e[0m = max_key.map(\e[36mx\e[0m => class_name_map(x)).mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key is already defined as \e[33mvalue\e[0m \e[35mmax_key\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph9vk4f4x.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmax_value\e[0m = max_key.map(\e[36mx\e\
    [0m => extensions_map(x)).mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmax_value is already defined as \e[33mvalue\e[0m \e[35mmax_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph9vk4f4x.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = max_key.map(\e[36mx\e\
    [0m => class_name_map(x"
  stdout: ''
  timestamp: 1659799604
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(_.toUpperCase).zipWithIndex.toMap\n        val class_name_map\
    \ = class_name.zipWithIndex.toMap\n        val strength = extensions_map.filter(_._2\
    \ > class_name_map.filter(_._2 == _._2).length).map(_._1).max\n        val class_name_with_strength\
    \ = class_name_map.filter(_._2 == strength).map(_._1).mkString(\".\") + \".\"\
    \ + extensions_map.filter(_._2 == strength).map(_._1).mkString(\".\") + \".\"\
    \ + extensions_map.filter(_._2 > class_name_map.filter(_._2 == _._2).length).map(_._1).mkString(\"\
    .\") + \".\" + extensions_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ == _._2).length).length).mkString(\".\") + \".\" + extensions_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ == _._2).length).length).length).mkString(\".\") + \".\" + extensions_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 == _._2).length).length).length).length).mkString(\"\
    .\") + \".\" + extensions_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvzkqt3k6.scala:25:4 ----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvzkqt3k6.scala:23:76\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.filter(_._2 > class_name_map.filter(_._2 ==\
    \ _._2).length).map(_._1).max\n\e[31m\e[31m   |\e[0m                         \
    \                                                 ^^^^\e[0m\n\e[31m   |\e[0m \
    \                                       value _2 is not a member of Char\n\e[31m\e\
    [31m-- Error: /tmp/tmpvzkqt3k6.scala:24:61 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_strength\e\
    [0m = class_name_map.filter(_._2 == strength).map(_._1).mkString(\e[31m\".\"\e\
    [0m) + \e[31m\".\"\e[0m + extensions_map.filter(_._2 == strength).map(_._1).mkString(\e\
    [31m\".\"\e[0m) + \e[31m\".\"\e[0m + extensions_map.filter(_._2 > class_name_map.filter(_._2\
    \ == _._2).length).map(_._1).mkString(\e[31m\".\"\e[0m) + \e[31m\".\"\e[0m + extensions_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 == _._2).length).length).mkString(\e\
    [31m\".\"\e[0m) + \e[31m\".\"\e[0m + extensions_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 == _._2).length).length).length).mkString(\e\
    [31m\".\"\e[0m) + \e[31m\".\"\e[0m + extensions_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ == _._2).length).length).length).length).mkString(\e[31m\".\"\e[0m) + \e[31m\"\
    .\"\e[0m + extensions_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filter(_._2 > class_name_map.filter(_._2\
    \ > class_name_map.filter(_._2 > class_name_map.filte"
  stdout: ''
  timestamp: 1659799606
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(_.toUpperCase).zipWithIndex.toMap\n        val extensions_sorted\
    \ = extensions.sortWith(_.toUpperCase.compareTo(_))\n        val extensions_sorted\
    \ = extensions_sorted.map(_.toUpperCase)\n        val extensions_sorted = extensions_sorted.map(x\
    \ => extensions_map(x))\n        val extensions_sorted = extensions_sorted.toList\n\
    \        val extensions_sorted = extensions_sorted.sortWith(_.toString.compareTo(_))\n\
    \        val extensions_sorted = extensions_sorted.map(_.toString.toUpperCase)\n\
    \        val extensions_sorted = extensions_sorted.map(x => extensions_map(x))\n\
    \        val extensions_sorted = extensions_sorted.toList\n        val extensions_sorted\
    \ = extensions_sorted.sortWith(_.toString.compareTo(_))\n        val extensions_sorted\
    \ = extensions_sorted.map(_.toString.toUpperCase)\n        val extensions_sorted\
    \ = extensions_sorted.map(x => extensions_map(x))\n        val extensions_sorted\
    \ = extensions_sorted.toList\n        val extensions_sorted = extensions_sorted.sortWith(_.toString.compareTo(_))\n\
    \        val extensions_sorted = extensions_sorted.map(_.toString.toUpperCase)\n\
    \        val extensions_sorted = extensions_sorted.map(x => extensions_map(x))\n\
    \        val extensions_sorted = extensions_sorted.toList\n        val extensions_sorted\
    \ = extensions_sorted.sortWith(_.toString.compareTo(_))\n        val extensions_sorted\
    \ = extensions_sorted.map(_.toString.toUpperCase)\n        val extensions_sorted\
    \ = extensions_sorted.map(x => extensions_map(x))\n        val extensions_sorted\
    \ = extensions_sorted.toList\n        val extensions_sorted = extensions_sorted.sortWith(_.toString.compareTo(_))\n\
    \        val extensions_sorted = extensions_sorted.map(_.toString.toUpperCase)\n\
    \        val extensions_sorted = extensions_sorted.map(x => extensions_map(x))\n\
    \        val extensions_sorted = extensions_sorted.toList\n        val extensions_sorted\
    \ = extensions_sorted.sortWith(_.toString.compareTo(_))\n        val extensions_sorted\
    \ = extensions_sorted.map(_.toString.toUpperCase)\n        val extensions_sorted\
    \ = extensions_sorted.map(x => extensions_map(x))\n        val extensions_sorted\
    \ = extensions_sorted.toList\n        val extensions_sorted = extensions_sor\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmskaqz4o.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(_.toUpperCase)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmskaqz4o.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36mx\e[0m => extensions_map(x))\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmskaqz4o.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmskaqz4o.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.sortWith(_.toString.compareTo(_))\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[3"
  stdout: ''
  timestamp: 1659799603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val strength = extensions_count - class_name_length\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => strength - a.length - b.length)\n        val\
    \ extensions_sorted = extensions_sorted.head\n        val class_name_with_extension\
    \ = class_name + extensions_sorted\n        val class_name_with_extension = class_name_with_extension.substring(class_name_length+1)\n\
    \        val class_name_with_extension = class_name_with_extension.substring(0,\
    \ class_name_length-1)\n        class_name_with_extension\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm25olruj.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.head\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpm25olruj.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_extension\e\
    [0m = class_name_with_extension.substring(class_name_length+\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_with_extension is already defined as \e[33mvalue\e\
    [0m \e[35mclass_name_with_extension\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm25olruj.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_extension\e\
    [0m = class_name_with_extension.substring(\e[31m0\e[0m, class_name_length-\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_with_extension is already defined as \e[33mvalue\e\
    [0m \e[35mclass_name_with_extension\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm25olruj.scala:24:62 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \  "
  stdout: ''
  timestamp: 1659799602
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_map = extensions_map.toMap\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '_')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '$')\n        val extensions_map = extensions_map.filter(_._2 != '!')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppaib2hq5.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions_map.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mextensions_map is already defined as \e[33mvalue\e[0m \e[35mextensions_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppaib2hq5.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions_map.filter(_._2\
    \ != \e[31m'_'\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map is already defined as \e[33mvalue\e[0m \e[35mextensions_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppaib2hq5.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions_map.filter(_._2\
    \ != \e[31m'$'\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map is already defined as \e[33mvalue\e[0m \e[35mextensions_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppaib2hq5.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions_map.filter(_._2\
    \ != \e[31m'!'\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map is already defined as \e[33mvalue\e[0m \e[35mextensions_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppaib2hq5.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1659799604
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val class_name_map = class_name.map(c => c.toUpperCase.charAt(0) -> c.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val strength = extensions_map.values.map(c => class_name_map.getOrElse(c,\
    \ -1)).sum\n        val strongest_extension = extensions_map.values.map(c => class_name_map.getOrElse(c,\
    \ -1)).min\n        val class_name = class_name_map.getOrElse(strongest_extension,\
    \ \"\")\n        val extension = extensions_map.getOrElse(strongest_extension,\
    \ \"\")\n        class_name + \".\" + extension\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprl7lcf3j.scala:21:100 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e\
    [0m).toLowerCase).toMap\n\e[31m\e[31m   |\e[0m                               \
    \                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprl7lcf3j.scala:25:25\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclass_name\e[0m = class_name_map.getOrElse(strongest_extension, \e[31m\"\
    \"\e[0m)\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m\
    \                         Recursive \e[33mvalue\e[0m \e[35mclass_name_map\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmprl7lcf3j.scala:23:90\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e[36mc\e[0m\
    \ => class_name_map.getOrElse(c, -\e[31m1\e[0m)).sum\n\e[31m\e[31m   |\e[0m  \
    \                                                                            \
    \            ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mByteIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e\
    [0m \e[35mIntIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type\
    \ Numeric[B] of parameter num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e\
    [0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- Error: /tmp/tmprl7lcf3j.scala:24:101\
    \ ----------------------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e\
    [33mval\e[0m \e[36mstrongest_extension\e[0m = extensions_map.values.map(\e[36mc\e\
    [0m => class_name_map.getOrElse(c, -\e[31m1\e[0m)).min\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \                         ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both\
    \ \e[33mobject\e[0m "
  stdout: ''
  timestamp: 1659799603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).max\n    \
    \    val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplnadv19a.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmplnadv19a.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplnadv19a.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmplnadv19a.scala:23:78 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\e[31m\e[31m   |\e[0m    \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   (x : String)\n\e[31m   |\e[0m                                            \
    \      Required: Nothing\n\e[31"
  stdout: ''
  timestamp: 1659799605
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4fqfqpbx.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp4fqfqpbx.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fqfqpbx.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e\
    [31m0\e[0m) - x.toUpperCase.length).max\n\e[31m\e[31m   |\e[0m               \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                                                  Found:    (x : String)\n\
    \e[31m   |\e[0m                                                  Required: Nothing\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fqfqpbx.scala:24:49\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextension\e\
    [0m = extensions_map.getOrElse(strength, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                 ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                              Found:    (strength : Int)\n\e\
    [31m   |\e[0m                                              Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659799576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.count\n        val extensions_count_upper = extensions.count(_.toUpperCase\
    \ == _)\n        val extensions_count_lower = extensions.count(_.toLowerCase ==\
    \ _)\n        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_frac = extensions_count_diff / extensions_count_upper\n\
    \        val extensions_count_diff_frac_int = extensions_count_diff_frac.toInt\n\
    \        val extensions_count_diff_frac_frac = extensions_count_diff_frac_int\
    \ / extensions_count_lower\n        val extensions_count_diff_frac_frac_int =\
    \ extensions_count_diff_frac_frac.toInt\n        val extensions_count_diff_frac_frac_frac\
    \ = extensions_count_diff_frac_frac_int / extensions_count_upper\n        val\
    \ extensions_count_diff_frac_frac_frac_int = extensions_count_diff_frac_frac_frac.toInt\n\
    \        val extensions_count_diff_frac_frac_frac_frac = extensions_count_diff_frac_frac_frac_int\
    \ / extensions_count_lower\n        val extensions_count_diff_frac_frac_frac_frac_int\
    \ = extensions_count_diff_frac_frac_frac_frac.toInt\n        val extensions_count_diff_frac_frac_frac_frac_frac\
    \ = extensions_count_diff_frac_frac_frac_frac_int / extensions_count_upper\n \
    \       val extensions_count_diff_frac_frac_frac_frac_frac_int = extensions_count_diff_frac_frac_frac_frac_frac_frac.toInt\n\
    \        val extensions_count_diff_frac_frac_frac_frac_frac_frac = extensions_count_diff_frac_frac_frac_frac_frac_int\
    \ / extensions_count_lower\n        val extensions_count_diff_frac_frac_frac_frac_frac_frac_frac\
    \ = extensions_count_diff_frac_frac_frac_frac_frac_frac_frac_int / extensions_count_upper\n\
    \        val extensions_count_diff_frac_frac_frac_frac_frac_frac_frac_int = extensions_count_diff_frac_frac_frac_frac_frac_frac_frac_frac.toInt\n\
    \        val extensions_count_diff_frac_frac_frac_frac_frac_frac_frac_frac = extensions_count_diff_frac_frac_frac_frac_frac_frac_frac_frac_int\
    \ / extensions_count_lower\n        val extensions_count_diff_frac_frac_frac_frac_frac_frac_frac_frac_frac\
    \ = extensions_count_diff_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_int\
    \ / extensions_count_upper\n        val extensions_count_diff_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac\
    \ = extensions_count_diff_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac\
    \ / extensions_count_lower\n        val extension\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpofduqin2.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpofduqin2.scala:22:54\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_upper\e[0m = extensions.count(_.toUpperCase == _)\n\e\
    [31m\e[31m   |\e[0m                                                      ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmpofduqin2.scala:23:54\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_lower\e[0m = extensions.count(_.toLowerCase == _)\n\e\
    [31m\e[31m   |\e[0m                                                      ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Wrong number of parameters,\
    \ expected: 1\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpofduqin2.scala:35:66\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_frac_frac_frac_frac_frac\e[0m = extensions_count_diff_frac_frac_frac_frac_frac_int\
    \ / extensions_count_lower\n\e[31m\e[31m   |\e[0m                            \
    \                                      ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mextensions_count_diff_frac_frac_frac_frac_frac_int\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpofduqin2.scala:38:76\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_diff_frac_frac_frac_frac_frac_frac_frac_frac\e[0m = extensions_count_diff_frac_frac_frac_frac_frac_frac_frac_frac_int\
    \ / extensions_count_lower\n\e[31m\e[31m   |\e[0m                            \
    \                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: extensions_count_diff_frac_frac_frac_frac_f"
  stdout: ''
  timestamp: 1659799603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.foldLeft(0) { (acc, e) =>\n            val c = class_name_map(e._1)\n\
    \            val s = class_name_map(e._2)\n            val cap = c.toUpperCase.length\n\
    \            val sm = s.toLowerCase().length\n            val strength = cap -\
    \ sm\n            if (strength > acc) strength else acc\n        }\n        val\
    \ class_name_with_strength = class_name_map.foldLeft(\"\") { (acc, e) =>\n   \
    \         val c = class_name_map(e._1)\n            val s = class_name_map(e._2)\n\
    \            val cap = c.toUpperCase.length\n            val sm = s.toLowerCase().length\n\
    \            val strength = cap - sm\n            if (strength == 0) acc else\
    \ acc + (e._1 + \".\" + e._2)\n        }\n        val class_name_with_strength_without_extension\
    \ = class_name_with_strength.dropRight(1)\n        val class_name_with_strength_without_extension_without_extension\
    \ = class_name_with_strength_without_extension.dropRight(1)\n        val class_name_with_strength_without_extension_without_extension_without_extension\
    \ = class_name_with_strength_without_extension_without_extension.dropRight(1)\n\
    \        val class_name_with_strength_without_extension_without_extension_without_extension_without_extension\
    \ = class_name_with_strength_without_extension_without_extension_without_extension.dropRight(1)\n\
    \        val class_name_with_strength_without_extension_without_extension_without_extension_without_extension_without_extension\
    \ = class_name_with_strength_without_extension_without_extension_without_extension_without_extension.dropRight(1)\n\
    \        val class_name_with_strength_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension\
    \ = class_name_with_strength_without_extension_without_extension_without_extension_without_extension_without_extension.dropRight(1)\n\
    \        val class_name_with_strength_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension\
    \ = class_name_with_strength_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.dropRight(1)\n\
    \        val class_name_with_strength_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension\
    \ = class_name_with_strength_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.drop\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp16uemw7q.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_strength_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension\e\
    [0m = class_name_with_strength_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_with_strength_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  class_name_with_strength_without_extension_without_extension_without_extension_without_extension_without_extension_without_extension\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp16uemw7q.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp16uemw7q.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E00"
  stdout: ''
  timestamp: 1659799607
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val strength = extensions_count - class_name_length\n        if (strength\
    \ < 0) \"\" else class_name + \".\" + extensions.sortWith(_ < _).head\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe2mijrr7.scala:28)\n\tat Problem.main(tmpe2mijrr7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val class_name_map = class_name.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\
    \        val max_strength = extensions_map.values.reduce((x, y) => if (x > y)\
    \ x else y)\n        val max_key = extensions_map.keys.max\n        val max_key_index\
    \ = extensions_map.keys.indexOf(max_key)\n        val max_key_value = extensions_map.get(max_key)\n\
    \        val max_key_value_map = max_key_value.map(x => (x._1, x._2)).toMap\n\
    \        val max_key_value_map_keys = max_key_value_map.keys\n        val max_key_value_map_values\
    \ = max_key_value_map.values\n        val max_key_value_map_keys_sorted = max_key_value_map_keys.sorted\n\
    \        val max_key_value_map_values_sorted = max_key_value_map_values.sorted\n\
    \        val max_key_value_map_keys_sorted_index = max_key_value_map_keys_sorted.indexOf(max_key_index)\n\
    \        val max_key_value_map_values_sorted_index = max_key_value_map_values_sorted.indexOf(max_key_index)\n\
    \        val max_key_value_map_keys_sorted_value = max_key_value_map_keys_sorted.take(max_key_value_map_keys_sorted_index)\n\
    \        val max_key_value_map_values_sorted_value = max_key_value_map_values_sorted.take(max_key_value_map_values_sorted_index)\n\
    \        val max_key_value_map_keys_sorted_value_sorted = max_key_value_map_keys_sorted_value.sorted\n\
    \        val max_key_value_map_values_sorted_value_sorted = max_key_value_map_values_sorted_value.sorted\n\
    \        val max_key_value_map_keys_sorted_value_sorted_index = max_key_value_map_keys_sorted_value_sorted.indexOf(max_key_index)\n\
    \        val max_key_value_map_values_sorted_value_sorted_index = max_key_value_map_values_sorted_value_sorted.indexOf(max_key_index)\n\
    \        val max_key_value_map_keys_sorted_value_sorted_value = max_key_value_map_keys_sorted_value_sorted.take(max_key_value_map_keys_sorted_value_sorted_index)\n\
    \        val max_key_value_map_values_sorted_value_sorted_value = max_key_value_map_values_sorted_value_sorted.take(max_key_value_map_values_sorted_value_sorted_index)\n\
    \        val max_key_value_map_keys_sorted_value_sorted_value_sorted = max_key_value_map_keys_sorted_value_sorted_value.sorted\n\
    \        val max_key_value_map_values_sorted_value_sorted_value_sorted = max_key_value_map_values_sorted_value_sorted_value.sorted\n\
    \        val max_key_value_map_keys_sorted_value_sorted_value_sorted_index = max_key_value_map_keys_sorted_value_sorted_value_sorted.indexOf(max_key_index)\n\
    \        val max_key_value_map_values_sorted_value_sorted_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_tsyko2s.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_tsyko2s.scala:22:52\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase.size,\
    \ x.toLowerCase.size)).toMap\n\e[31m\e[31m   |\e[0m                          \
    \                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \              value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp_tsyko2s.scala:22:72 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value toLowerCase\
    \ is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_tsyko2s.scala:25:48\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mmax_key_index\e[0m = extensions_map.keys.indexOf(max_key)\n\e[31m\e[31m  \
    \ |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                          value indexOf is not a member of Iterable[Int]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_tsyko2s.scala:27:58 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_map\e[0m =\
    \ max_key_value.map(\e[36mx\e[0m => (x._1, x._2)).toMap\n\e[31m\e[31m   |\e[0m\
    \                                                        ^^^^\e[0m\n\e[31m   |\e\
    [0m                                         value _1 is not a member of Int\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp_tsyko2s.scala:27:64 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_map\e[0m =\
    \ max_key_value.map(\e[36mx\e[0m => (x._1, x._2)).toMap\n\e[31m\e[31m   |\e[0m\
    \                                               "
  stdout: ''
  timestamp: 1659799615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n     \
    \   val strength = extensions_sorted.head._2 - extensions_sorted.head._1\n   \
    \     val extension = extensions_sorted.head._1\n        val class_name = class_name.replaceAll(\"\
    [^A-Z]\", \"\")\n        class_name + \".\" + extension\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpg0ziwvc3.scala:25:25 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name.replaceAll(\e\
    [31m\"[^A-Z]\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                 \
    \        ^\e[0m\n\e[31m   |\e[0m                         Recursive \e[33mvalue\e\
    [0m \e[35mclass_name\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799610
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.foldLeft(0) { (acc, x) => acc + (class_name_map(x._1) - class_name_map(x._2))\
    \ }\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted = extensions_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted = extensions_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(_._1).reverse\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnxyusghk.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpnxyusghk.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnxyusghk.scala:23:88\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.foldLeft(\e[31m0\e[0m) { (\e[36macc\e[0m, \e[36mx\e[0m) =>\
    \ acc + (class_name_map(x._1) - class_name_map(x._2)) }\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \          ^^^^\e[0m\n\e[31m   |\e[0m                                        \
    \               Found:    String\n\e[31m   |\e[0m                            \
    \                           Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpnxyusghk.scala:23:111 -------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.foldLeft(\e\
    [31m0\e[0m) { (\e[36macc\e[0m, \e[36mx\e[0m) => acc + (class_name_map(x._1) -\
    \ class_name_map(x._2)) }\n\e[31m\e[31m   |\e[0m                             \
    \                                                                            \
    \    ^^^^\e[0m\n\e[31m   |\e[0m                                              \
    \         Found:    String\n\e[31m   |\e[0m                                  \
    \                     Required: Nothing\n\e[31m   "
  stdout: ''
  timestamp: 1659799615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.values.max\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._2).reverse\n \
    \       val extensions_sorted = extensions_sorted.takeWhile(_._2 != strength).reverse\n\
    \        val extensions_sorted = extensions_sorted.take(1).mkString(\".\")\n \
    \       class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiznv4ieq.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 != strength).reverse\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpiznv4ieq.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(\e[31m1\e[0m).mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmpiznv4ieq.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n3 errors found\n"
  stdout: ''
  timestamp: 1659799612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4fqfqpbx.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp4fqfqpbx.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fqfqpbx.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e\
    [31m0\e[0m) - x.toUpperCase.length).max\n\e[31m\e[31m   |\e[0m               \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                                                  Found:    (x : String)\n\
    \e[31m   |\e[0m                                                  Required: Nothing\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fqfqpbx.scala:24:49\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextension\e\
    [0m = extensions_map.getOrElse(strength, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                 ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                              Found:    (strength : Int)\n\e\
    [31m   |\e[0m                                              Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659799576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_map_sorted = extensions_map.toSeq.sortBy(_._2).reverse\n\
    \        val extensions_map_sorted_keys = extensions_map_sorted.keys\n       \
    \ val extensions_map_sorted_values = extensions_map_sorted.values\n        val\
    \ extensions_map_sorted_keys_sorted = extensions_map_sorted_keys.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_map_sorted_keys_sorted_values = extensions_map_sorted_keys_sorted.map(e\
    \ => e -> extensions_map_sorted_values(extensions_map_sorted_keys.indexOf(e)))\n\
    \        val extensions_map_sorted_keys_sorted_values_sorted = extensions_map_sorted_keys_sorted_values.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_map_sorted_keys_sorted_values_sorted_keys = extensions_map_sorted_keys_sorted_values_sorted.keys\n\
    \        val extensions_map_sorted_keys_sorted_values_sorted_values = extensions_map_sorted_keys_sorted_values_sorted.values\n\
    \        val extensions_map_sorted_keys_sorted_values_sorted_keys_sorted = extensions_map_sorted_keys_sorted_values_sorted_keys.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values\
    \ = extensions_map_sorted_keys_sorted_values_sorted_keys_sorted.map(e => e ->\
    \ extensions_map_sorted_values_sorted_keys(extensions_map_sorted_keys_sorted_values_sorted_keys.indexOf(e)))\n\
    \        val extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted\
    \ = extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted_keys\
    \ = extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted_keys.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted_keys_sorted\
    \ = extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted_keys_sorted.map(e\
    \ => e -> extensions_map_sorted_values_sorted_keys_sorted_values(extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values.indexOf(e)))\n\
    \        val extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted_keys_sorted_values\
    \ = extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted_keys_sorted_values.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted\
    \ = extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted.toSeq.sortBy(_._1).reverse\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxyhkku18.scala:21:100 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e\
    [0m).toLowerCase)\n\e[31m\e[31m   |\e[0m                                     \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- Error: /tmp/tmpxyhkku18.scala:22:69 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_map_sorted\e\
    [0m = extensions_map.toSeq.sortBy(_._2).reverse\n\e[31m\e[31m   |\e[0m       \
    \                                                              ^\e[0m\n\e[31m\
    \   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in\
    \ \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod\e[0m \e[35msortBy\e[0m in \e[33mtrait\e[0m \e[35mSeqOps\e\
    [0m\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxyhkku18.scala:32:88 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mextensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted\e\
    [0m = extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted.toSeq.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mextensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxyhkku18.scala:33:93\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted_keys\e\
    [0m = extensions_map_sorted_keys_sorted_values_sorted_keys_sorted_values_sorted_keys.toSeq.sortBy("
  stdout: ''
  timestamp: 1659799614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val sorted_extensions = extensions_map.toList.sortWith(_._2 > _._2)\n\
    \        val first_extension = sorted_extensions.head\n        val class_name\
    \ = class_name + first_extension\n        class_name\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwdvxptev.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpwdvxptev.scala:25:25 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name + first_extension\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 Recursive \e[33mvalue\e[0m \e[35mclass_name\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659799613
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        if (strength\
    \ > 0) extensions(0) else extensions(1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpouvhuvjy.scala:27)\n\tat Problem.main(tmpouvhuvjy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper = extensions_count_upper.toDouble\n        val\
    \ extensions_count_lower = extensions_count_lower.toDouble\n        val strength_upper\
    \ = strength.toDouble / extensions_count_upper\n        val strength_lower = strength.toDouble\
    \ / extensions_count_lower\n        val strength_max = if (strength_upper > strength_lower)\
    \ strength_upper else strength_lower\n        val extensions_count_max = extensions_count.toDouble\n\
    \        val extensions_count_min = extensions_count_max.toDouble / extensions_count_upper\n\
    \        val extensions_count_min = extensions_count_min.toDouble\n        val\
    \ extensions_count_max = extensions_count_max.toDouble / extensions_count_lower\n\
    \        val extensions_count_max = extensions_count_max.toDouble\n        val\
    \ extensions_count_min = extensions_count_min.toDouble\n        val extensions_count_min\
    \ = extensions_count_min.toDouble\n        val extensions_count_max = extensions_count_max.toDouble\n\
    \        val extensions_count_max = extensions_count_max.toDouble\n        val\
    \ extensions_count_min = extensions_count_min.toDouble\n        val extensions_count_min\
    \ = extensions_count_min.toDouble\n        val extensions_count_max = extensions_count_max.toDouble\n\
    \        val extensions_count_max = extensions_count_max.toDouble\n        val\
    \ extensions_count_min = extensions_count_min.toDouble\n        val extensions_count_min\
    \ = extensions_count_min.toDouble\n        val extensions_count_max = extensions_count_max.toDouble\n\
    \        val extensions_count_max = extensions_count_max.toDouble\n        val\
    \ extensions_count_min = extensions_count_min.toDouble\n        val extensions_count_min\
    \ = extensions_count_min.toDouble\n        val extensions_count_max = extensions_count_max.toDouble\n\
    \        val extensions_count_max = extensions_count_max.toDouble\n        val\
    \ extensions_count_min = extensions_count_min.toDouble\n        val extensions_count_min\
    \ = extensions_count_min.toDouble\n        val extensions_count_max = extensions_count_max.toDouble\n\
    \        val extensions_count_max = extensions_count_max.toDouble\n        val\
    \ extensions_count_min = extensions_count_min.toDouble\n        val extensions_count_min\
    \ = extensions_count_min.toDouble\n        val extensions_count_max = extensions_count_max.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppapiwskn.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppapiwskn.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper\e[0m = extensions_count_upper.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppapiwskn.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions_count_lower.toDouble\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmppapiwskn.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_min\e[0m\
    \ = extensions_count_min.toDouble\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_min is already defined as \e[33mvalue\e[0m\
    \ \e[35mextensions_count_min\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppapiwskn.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_max\e[0m\
    \ = extensions_count_max.toDouble / extensions_count_lower\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659799613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (class_name_map.get(x), x)).maxBy(_._2)._2\n\
    \        val class_name_with_strength = class_name_map.get(strength)\n       \
    \ val extensions_with_strength = extensions_map.get(strength)\n        val extensions_with_strength_sorted\
    \ = extensions_with_strength.sortBy(x => x.length)\n        val extensions_with_strength_sorted_sorted\
    \ = extensions_with_strength_sorted.sortBy(x => x.length)\n        val extensions_with_strength_sorted_sorted_sorted\
    \ = extensions_with_strength_sorted_sorted.sortBy(x => x.length)\n        val\
    \ extensions_with_strength_sorted_sorted_sorted_sorted = extensions_with_strength_sorted_sorted_sorted.sortBy(x\
    \ => x.length)\n        val extensions_with_strength_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_with_strength_sorted_sorted_sorted_sorted.sortBy(x => x.length)\n\
    \        val extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_with_strength_sorted_sorted_sorted_sorted_sorted.sortBy(x => x.length)\n\
    \        val extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.length)\n        val extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.length)\n        val extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.length)\n        val extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.length)\n        val extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.length)\n        val extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.length)\n        val extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x.length)\n        val extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp42onhj5k.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp42onhj5k.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(\e\
    [36mx\e[0m => x.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_with_strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp42onhj5k.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp42onhj5k.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp42onhj5k.scala:23:74\
    \ --------"
  stdout: ''
  timestamp: 1659799617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.foldLeft(0)((acc, x) => acc + (class_name_map(x._1) - class_name_map(x._2)))\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(x => x._2).reverse\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x._2 != class_name_map(x._1))\n\
    \        val extensions_sor\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\", \"\
    eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsi3p6wxi.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsi3p6wxi.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(\e[36mx\e[0m => x._2\
    \ != class_name_map(x._1))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsi3p6wxi.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x._2 != class_name_map(x._1))\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsi3p6wxi.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x._2 != class_name_map(x._1))\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsi3p6wxi.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ ext"
  stdout: ''
  timestamp: 1659799615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (class_name_map.get(x), x)).maxBy(_._2)._2\n\
    \        val class_name = class_name_map.get(strength)\n        val extension\
    \ = extensions_map.get(strength)\n        class_name + \".\" + extension\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbo3r_k_q.scala:24:25 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name_map.get(strength)\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 Recursive \e[33mvalue\e[0m \e[35mclass_name_map\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val class_name_map = class_name.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\
    \        val max_key = class_name_map.maxBy(_._1)._1\n        val max_value =\
    \ class_name_map.maxBy(_._1)._2\n        val max_key_value = class_name_map.filter(_._1\
    \ == max_key).maxBy(_._1)._2\n        val max_key_value_map = class_name_map.filter(_._1\
    \ == max_key_value).maxBy(_._1)._2\n        val max_key_value_map_key = max_key_value_map.keys.max\n\
    \        val max_key_value_map_value = max_key_value_map.values.max\n        val\
    \ max_key_value_map_key_value = max_key_value_map.filter(_._1 == max_key_value_map_key).maxBy(_._1)._2\n\
    \        val max_key_value_map_key_value_map = max_key_value_map.filter(_._1 ==\
    \ max_key_value_map_key_value).maxBy(_._1)._2\n        val max_key_value_map_key_value_map_key\
    \ = max_key_value_map_key_value_map.keys.max\n        val max_key_value_map_key_value_map_value\
    \ = max_key_value_map_key_value_map.values.max\n        val max_key_value_map_key_value_map_key_value\
    \ = max_key_value_map_key_value_map.filter(_._1 == max_key_value_map_key_value_map_key).maxBy(_._1)._2\n\
    \        val max_key_value_map_key_value_map_key_value_map = max_key_value_map_key_value_map.filter(_._1\
    \ == max_key_value_map_key_value_map_key_value).maxBy(_._1)._2\n        val max_key_value_map_key_value_map_key_value_map_key\
    \ = max_key_value_map_key_value_map_key_value_map.keys.max\n        val max_key_value_map_key_value_map_key_value_map_value\
    \ = max_key_value_map_key_value_map_key_value_map.values.max\n        val max_key_value_map_key_value_map_key_value_map_key_value\
    \ = max_key_value_map_key_value_map_key_value_map.filter(_._1 == max_key_value_map_key_value_map_key_value_map_key).maxBy(_._1)._2\n\
    \        val max_key_value_map_key_value_map_key_value_map_key_value_map = max_key_value_map_key_value_map_key_value_map.filter(_._1\
    \ == max_key_value_map_key_value_map_key_value_map_key_value).maxBy(_._1)._2\n\
    \        val max_key_value_map_key_value_map_key_value_map_key_value_map_key =\
    \ max_key_value_map_key_value_map_key_value_map_key_value_map.keys.max\n     \
    \   val max_key_value_map_key_value_map_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiims5nb6.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiims5nb6.scala:22:52\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase.size,\
    \ x.toLowerCase.size)).toMap\n\e[31m\e[31m   |\e[0m                          \
    \                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \              value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpiims5nb6.scala:22:72 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value toLowerCase\
    \ is not a member of Char\n\e[31m\e[31m-- Error: /tmp/tmpiims5nb6.scala:23:48\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mmax_key\e[0m = class_name_map.maxBy(_._1)._1\n\e[31m\e\
    [31m   |\e[0m                                                ^\e[0m\n\e[31m  \
    \ |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e\
    [33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e\
    [33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter cmp of\
    \ \e[33mmethod\e[0m \e[35mmaxBy\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- Error: /tmp/tmpiims5nb6.scala:24:50 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmax_value\e[0m = class_name_map.maxBy(_._1)._2\n\
    \e[31m\e[31m   |\e[0m                                                  ^\e[0m\n\
    \e[31m   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mChar\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of pa"
  stdout: ''
  timestamp: 1659799616
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val extensions_sorted = extensions_map.toSeq.sortWith((a, b) =>\
    \ strength - a._2).reverse\n        val extensions_sorted = extensions_sorted.take(1)\n\
    \        val extensions_sorted = extensions_sorted.map(_._1).mkString(\"\") +\
    \ extensions_sorted.map(_._2).mkString(\"\")\n        extensions_sorted.mkString(class_name\
    \ + \".\")\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvh62qlb7.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpvh62qlb7.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(_._1).mkString(\e[31m\"\"\e[0m) + extensions_sorted.map(_._2).mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmpvh62qlb7.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n3 errors found\n"
  stdout: ''
  timestamp: 1659799614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.filter(_._2 > class_name_map.get(_._2)).map(_._1).size\n  \
    \      val extension = extensions_map.filter(_._2 == class_name_map.get(_._2)).map(_._1).head\n\
    \        val extension_map = extensions_map.filter(_._2 > class_name_map.get(_._2)).map(_._1)\n\
    \        val extension_strength = extension_map.filter(_._2 > class_name_map.get(_._2)).map(_._1).size\n\
    \        val extension_strength_sum = extension_strength.foldLeft(0)(_ + _)\n\
    \        val extension_strength_product = extension_strength.foldLeft(1)(_ * _)\n\
    \        val extension_strength_product = extension_strength_product / extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product * extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product / extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product * extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product / extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product * extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product / extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product * extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product / extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product * extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product / extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product * extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product / extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product * extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product / extension_strength_sum\n\
    \        val extension_strength_product = extension_strength_product * extension_strength_sum\n\
    \        val extension_strength\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcycxu09k.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcycxu09k.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextension_strength_product\e[0m = extension_strength_product / extension_strength_sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_product is already defined as \e[33mvalue\e\
    [0m \e[35mextension_strength_product\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcycxu09k.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_product\e\
    [0m = extension_strength_product * extension_strength_sum\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_product is already defined as \e[33mvalue\e\
    [0m \e[35mextension_strength_product\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcycxu09k.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_product\e\
    [0m = extension_strength_product / extension_strength_sum\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_product is already defined as \e[33mvalue\e\
    [0m \e[35mextension_strength_product\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcycxu09k.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mextension_st"
  stdout: ''
  timestamp: 1659799617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        val extensions_sorted\
    \ = extensions.sortWith(_.length < _.length)\n        val extension_first = extensions_sorted.head\n\
    \        val extension_last = extensions_sorted.last\n        val extension_length\
    \ = extension_last.length\n        val extension_first = extension_first.toLowerCase\
    \ + extension_last.substring(extension_length)\n        val extension_strength\
    \ = extension_length - class_name_count\n        val extension_strength_sorted\
    \ = extension_strength.sortWith(_.toDouble < _.toDouble)\n        val extension_strength_first\
    \ = extension_strength_sorted.head\n        val extension_strength_last = extension_strength_sorted.last\n\
    \        val extension_strength_length = extension_strength_last.length\n    \
    \    val extension_strength_first = extension_strength_first.toLowerCase + extension_strength_last.substring(extension_strength_length)\n\
    \        if (extension_strength_first == extension_first) {\n            class_name\
    \ + extension_first\n        } else {\n            class_name + extension_strength_first\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuv8hi_le.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextension_first\e[0m = extension_first.toLowerCase\
    \ + extension_last.substring(extension_length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_first is already defined as \e[33mvalue\e[0m \e\
    [35mextension_first\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpuv8hi_le.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_first\e\
    [0m = extension_strength_first.toLowerCase + extension_strength_last.substring(extension_strength_length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_first is already defined as \e[33mvalue\e\
    [0m \e[35mextension_strength_first\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuv8hi_le.scala:30:59 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_sorted\e\
    [0m = extension_strength.sortWith(_.toDouble < _.toDouble)\n\e[31m\e[31m   |\e\
    [0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                   value sortWith is not a member\
    \ of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1659799615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.foldLeft(0) { (s, e) =>\n            val c = class_name_map.getOrElse(e._1,\
    \ e._1)\n            val s = s + (c.toUpperCase.size - c.toLowerCase.size)\n \
    \       }\n        val strongest_extension = extensions.find(x => x.toUpperCase.size\
    \ == strength)\n        val class_name = class_name_map.getOrElse(strongest_extension._1,\
    \ strongest_extension._1)\n        val extension = strongest_extension._2\n  \
    \      class_name + \".\" + extension\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4e2_e6vd.scala:28:25 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name_map.getOrElse(strongest_extension._1,\
    \ strongest_extension._1)\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\
    \e[31m   |\e[0m                         Recursive \e[33mvalue\e[0m \e[35mclass_name_map\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4e2_e6vd.scala:25:65\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e\
    [36ms\e[0m = s + (c.toUpperCase.size - c.toLowerCase.size)\n\e[31m\e[31m   |\e\
    [0m                                                                 ^\e[0m\n\e\
    [31m   |\e[0m                                                          Found:\
    \    Unit\n\e[31m   |\e[0m                                                   \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4e2_e6vd.scala:29:44\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mextension\e[0m = strongest_extension._2\n\e[31m\e[31m   |\e[0m           \
    \             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \     value _2 is not a member of Option[String]\n3 errors found\n"
  stdout: ''
  timestamp: 1659799615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val strength = extensions_count - class_name_length\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => strength - a.length - b.length)\n        val\
    \ extension_length = extensions_sorted.map(_.length).sum\n        val extension_strength\
    \ = extensions_sorted.map(_.length).sum / extension_length\n        val extension_sorted\
    \ = extensions_sorted.sortWith((a, b) => extension_strength - a.length - b.length)\n\
    \        val extension_first = extension_sorted.head\n        val extension_last\
    \ = extension_sorted.last\n        val extension_first = extension_first.replaceAll(\"\
    [A-Z]\", \"\").replaceAll(\"[a-z]\", \"\")\n        val extension_last = extension_last.replaceAll(\"\
    [A-Z]\", \"\").replaceAll(\"[a-z]\", \"\")\n        class_name + extension_first\
    \ + extension_last\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_qtxb0_8.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextension_first\e[0m = extension_first.replaceAll(\e\
    [31m\"[A-Z]\"\e[0m, \e[31m\"\"\e[0m).replaceAll(\e[31m\"[a-z]\"\e[0m, \e[31m\"\
    \"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_first is already defined as \e[33mvalue\e[0m \e\
    [35mextension_first\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_qtxb0_8.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mextension_last\e[0m = extension_last.replaceAll(\e\
    [31m\"[A-Z]\"\e[0m, \e[31m\"\"\e[0m).replaceAll(\e[31m\"[a-z]\"\e[0m, \e[31m\"\
    \"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_last is already defined as \e[33mvalue\e[0m \e[35mextension_last\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp_qtxb0_8.scala:24:62 --------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m = extensions.sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\e[31m\e[31m   |\e\
    [0m                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                       Found:\
    \    Int\n\e[31m   |\e[0m                                                    \
    \   Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_qtxb0_8.scala:27:68\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextension_sorted\e\
    [0m = extensions_sorted.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => extension_strength\
    \ - a.length - b.length)\n\e[31m\e[31m   "
  stdout: ''
  timestamp: 1659799616
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length = extensions_count_sorted.map(_.length).sum\n\
    \        val extensions_count_sorted_length_sorted = extensions_count_sorted.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length = extensions_count_sorted_length.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted = extensions_count_sorted_length_sorted.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length = extensions_count_sorted_length_sorted_length.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortBy(_.length).reverse\n\
    \        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\",\
    \ \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb5t7ouhu.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length_sorted_length_sorted_length_sorted.sortBy(_.length).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpb5t7ouhu.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted.sortBy(_.length).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpb5t7ouhu.scala:25:90 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length\e\
    [0m"
  stdout: ''
  timestamp: 1659799617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.getOrElse(class_name, 0)\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extensions_sorted =\
    \ extensions_sorted.takeWhile(_._1 < strength)\n        val extensions_sorted\
    \ = extensions_sorted.map(_._2).mkString(\".\")\n        class_name + extensions_sorted\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjcmtmgi0.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._1 < strength)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpjcmtmgi0.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(_._2).mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e[35mextensions_sorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpjcmtmgi0.scala:22:48 --------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.getOrElse(class_name,\
    \ \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                                       \
    \         ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                   \
    \      Found:    (class_name : String)\n\e[31m   |\e[0m                      \
    \                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659799616
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = class_name_map.foldLeft(0) { (acc, x) => acc + (x._2 - x._1) }\n        val\
    \ extensions_sorted = extensions_map.toSeq.sortBy(x => x._2).reverse\n       \
    \ val extension_strength = extensions_sorted.foldLeft(0) { (acc, x) => acc + (x._2\
    \ - x._1) }\n        val strength_diff = strength - extension_strength\n     \
    \   if (strength_diff == 0) class_name_map.head\n        else if (strength_diff\
    \ < 0) extensions_sorted.head\n        else class_name_map.head + extensions_sorted.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzxg4hnpu.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpzxg4hnpu.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzxg4hnpu.scala:23:76\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = class_name_map.foldLeft(\e[31m0\e[0m) { (\e[36macc\e[0m, \e\
    [36mx\e[0m) => acc + (x._2 - x._1) }\n\e[31m\e[31m   |\e[0m                  \
    \                                                     ^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue - is not a member of Nothing, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzxg4hnpu.scala:25:89\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mextension_strength\e[0m = extensions_sorted.foldLeft(\e[31m0\e[0m) { (\e[36macc\e\
    [0m, \e[36mx\e[0m) => acc + (x._2 - x._1) }\n\e[31m\e[31"
  stdout: ''
  timestamp: 1659799619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n  \
    \      val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5rzgkl59.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5rzgkl59.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_._2 > \e[31m0\e\
    [0m).map(_._1)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5rzgkl59.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5rzgkl59.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5rzgkl59.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^"
  stdout: ''
  timestamp: 1659799619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val extensions_length_sum = extensions.map(_.length).sum\n        val\
    \ strength = extensions_length_sum / extensions_count - class_name_length / extensions_count\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength - a.length\
    \ - b.length)\n        extensions_sorted.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkcse0jdv.scala:25:62\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e\
    [0m = extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length\
    \ - b.length)\n\e[31m\e[31m   |\e[0m                                         \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                    Found:    Int\n\e[31m   |\e\
    [0m                                                       Required: Boolean\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799619
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_cap = extensions.map(_.toUpperCase.length).sum -\
    \ extensions.map(_.toLowerCase.length).sum\n        val extensions_count_sm =\
    \ extensions.map(_.toLowerCase.length).sum - extensions.map(_.toUpperCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower - extensions_count_cap\
    \ - extensions_count_sm\n        val class_name_upper = class_name.toUpperCase\n\
    \        val class_name_lower = class_name.toLowerCase\n        val class_name_count\
    \ = class_name_upper.length + class_name_lower.length\n        val class_name_count_upper\
    \ = class_name_upper.length\n        val class_name_count_lower = class_name_lower.length\n\
    \        val class_name_count_cap = class_name_count_upper - class_name_count_lower\n\
    \        val class_name_count_sm = class_name_count_lower - class_name_count_upper\n\
    \        val class_name_strength = class_name_count_upper - class_name_count_lower\
    \ - class_name_count_cap - class_name_count_sm\n        if (strength > 0) {\n\
    \            val extensions_count_str = extensions.map(_.length).sum.toString\n\
    \            val extensions_count_str_upper = extensions.map(_.toUpperCase.length).sum.toString\n\
    \            val extensions_count_str_lower = extensions.map(_.toLowerCase.length).sum.toString\n\
    \            val extensions_count_str_upper = extensions.map(_.toUpperCase.length).sum.toString\n\
    \            val extensions_count_str_lower = extensions.map(_.toLowerCase.length).sum.toString\n\
    \            val extensions_count_str_upper = extensions.map(_.toUpperCase.length).sum.toString\n\
    \            val extensions_count_str_lower = extensions.map(_.toLowerCase.length).sum.toString\n\
    \            val extensions_count_str_upper = extensions.map(_.toUpperCase.length).sum.toString\n\
    \            val extensions_count_str_lower = extensions.map(_.toLowerCase.length).sum.toString\n\
    \            val extensions_count_str_upper = extensions.map(_.toUpperCase.length).sum.toString\n\
    \            val extensions_count_str_lower = extensions.map(_.toLowerCase.length).sum.toString\n\
    \            val extensions_count_str_upper = extensions.map(_.toUpperCase.length).sum.toString\n\
    \            val extensions_count_str_lower = extensions.map(_.toLowerCase.length).sum.toString\n\
    \            val extensions_count_str_upper = extensions.map(_.toUpperCase.length).sum.toString\n\
    \            val extensions_count_str_lower = extensions.map(_.toLowerCase.length).sum.toString\n\
    \            val extensions_count_str_upper = extensions.map(_.toUpperCase.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpolzctz0_.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpolzctz0_.scala:66:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m66 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpolzctz0_.scala:39:16 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m            \e[33mval\e[0m \e[36mextensions_count_str_upper\e[0m\
    \ = extensions.map(_.toUpperCase.length).sum.toString\n\e[31m\e[31m   |\e[0m \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_str_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_str_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpolzctz0_.scala:40:16 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mval\e[0m \e[36mextensions_count_str_lower\e\
    [0m = extensions.map(_.toLowerCase.length).sum.toString\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_str_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_str_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpolzctz0_.scala:41:16 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36mextensions_count_str_upper\e\
    [0m = extensions.map(_.toUpperCase.length).sum.toString\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_str_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_str_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in"
  stdout: ''
  timestamp: 1659799623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs)\n        val\
    \ max_strength = strength.max\n        val max_extension = extensions_map.getOrElse(max_strength,\
    \ \"\")\n        (class_name + \".\" + max_extension)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe8ydj2oe.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpe8ydj2oe.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe8ydj2oe.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs)\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpe8ydj2oe.scala:23:78 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => (x - class_name_map.get(x)).abs)\n\e[31m\e[31m   |\e[0m        \
    \                                                                      ^\e[0m\n\
    \e[31m   |\e[0m                                                  Found:    (x\
    \ : String)\n\e[31m   |\e[0m                                                 \
    \ Required: Nothing\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1659799626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase).zipWithIndex.toMap\n        val class_name_map\
    \ = class_name.zipWithIndex.toMap\n        val extensions_count = extensions_map.values.toSet.size\n\
    \        val class_name_count = class_name_map.values.toSet.size\n        val\
    \ strength = extensions_count - class_name_count\n        val extension = extensions_map.values.toSet.min\n\
    \        val class_name = class_name_map.values.toSet.min\n        val extension_str\
    \ = extension.mkString.replaceAll(\"[A-Z]\", \"_$extension\")\n        val class_name_str\
    \ = class_name.mkString.replaceAll(\"[a-z]\", \"_$class_name\")\n        val class_name_str\
    \ = class_name_str.replaceAll(\"_\", \"\")\n        class_name_str + \".\" + extension_str\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5qin4yxi.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mclass_name_str\e[0m = class_name_str.replaceAll(\e\
    [31m\"_\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_str is already defined as \e[33mvalue\e[0m \e[35mclass_name_str\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp5qin4yxi.scala:27:25 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name_map.values.toSet.min\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 Recursive \e[33mvalue\e[0m \e[35mclass_name_map\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5qin4yxi.scala:28:38\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e\
    [36mextension_str\e[0m = extension.mkString.replaceAll(\e[31m\"[A-Z]\"\e[0m, \e\
    [31m\"_$extension\"\e[0m)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue mkString is not a member of Int - did you mean extension.toString?\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659799625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.get(x) - x.toString.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        extension\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpobpp9czy.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpobpp9czy.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpobpp9czy.scala:23:73\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.get(x) - x.toString.toUpperCase.length).max\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \              Found:    (x : String)\n\e[31m   |\e[0m                       \
    \                           Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpobpp9czy.scala:23:112 ----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => class_name_map.get(x) - x.toString.toUpperCase.length).max\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mBigInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e\
    [0m \e[35mOrdering\e[0m match type Ordering[B] of parameter ord of \e[33mmethod\e\
    [0m \e["
  stdout: ''
  timestamp: 1659799626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs)\n        val\
    \ max_strength = strength.max\n        val max_key = strength.indexWhere(x =>\
    \ x == max_strength)\n        val max_key = max_key match {\n            case\
    \ -1 => \"\"\n            case x => class_name_map.get(extensions_map.keys.toSeq(max_key).head)\n\
    \        }\n        max_key + extensions_map.get(max_key).last\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2xetvl39.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = max_key \e\
    [33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mmax_key\
    \ is already defined as \e[33mvalue\e[0m \e[35mmax_key\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m27 |\e[0m            \e[33mcase\e[0m -\e[31m1\e\
    [0m => \e[31m\"\"\e[0m\n\e[31m28 |\e[0m            \e[33mcase\e[0m x => class_name_map.get(extensions_map.keys.toSeq(max_key).head)\n\
    \e[31m29 |\e[0m        }\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2xetvl39.scala:22:52\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2xetvl39.scala:22:67\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value\
    \ toLowerCase is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp2xetvl39.scala:23:57 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e[36mx\e\
    [0m => (x - class_name_map.get(x)).abs)\n\e[31m\e[31m   |\e[0m               \
    \                                        ^^^\e[0m\n\e[31m   |\e[0mvalue - is not\
    \ a member of String, but could be made available as an extension method.\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infi"
  stdout: ''
  timestamp: 1659799627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(_.toUpperCase).zipWithIndex.toMap\n        val class_name_map\
    \ = class_name.zipWithIndex.toMap\n        val strength = extensions_map.filter(_._2\
    \ > class_name_map.get(_._1)).map(_._1).sum\n        val extension = extensions_map.filter(_._2\
    \ == strength).map(_._1).head\n        class_name + \".\" + extension\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E081] Type Error: /tmp/tmprnbe7qtj.scala:23:71 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.filter(_._2\
    \ > class_name_map.get(_._1)).map(_._1).sum\n\e[31m\e[31m   |\e[0m           \
    \                                                            ^\e[0m\n\e[31m  \
    \ |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could\
    \ not infer the type of the parameter _$3 of expanded function:\n\e[31m   |\e\
    [0m   _$3 => _$3._1.\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmprnbe7qtj.scala:23:50\
    \ -----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e\
    [0m \e[36mstrength\e[0m = extensions_map.filter(_._2 > class_name_map.get(_._1)).map(_._1).sum\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^\e[0m\n\
    \e[31m   |\e[0m None of the overloaded alternatives of \e[33mmethod\e[0m \e[35m>\e\
    [0m in \e[33mclass\e[0m \e[35mInt\e[0m with types\n\e[31m   |\e[0m  (x: Double):\
    \ Boolean\n\e[31m   |\e[0m  (x: Float): Boolean\n\e[31m   |\e[0m  (x: Long): Boolean\n\
    \e[31m   |\e[0m  (x: Int): Boolean\n\e[31m   |\e[0m  (x: Char): Boolean\n\e[31m\
    \   |\e[0m  (x: Short): Boolean\n\e[31m   |\e[0m  (x: Byte): Boolean\n\e[31m \
    \  |\e[0m match arguments (Option[Int])\n\e[31m\e[31m-- Error: /tmp/tmprnbe7qtj.scala:23:91\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.filter(_._2 > class_name_map.get(_._1)).map(_._1).sum\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                   ^\e[0m\n\e[31m   |\e[0m                No\
    \ implicit Ordering defined for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m          \
    \      where:    B is a type variable with constraint >: String\n\e[31m   |\e\
    [0m                .\n3 errors found\n"
  stdout: ''
  timestamp: 1659799626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.filter(_._2 > class_name_map.get(_._2)).map(_._1).size\n  \
    \      val extension = extensions_map.filter(_._2 == class_name_map.get(_._2)).map(_._1).head\n\
    \        val class_name = class_name_map.filter(_._2 == class_name_map.get(_._2)).map(_._1).head\n\
    \        val extension_name = extensions_map.filter(_._2 == class_name_map.get(_._2)).map(_._1).head\n\
    \        val class_name_with_extension = class_name + \".\" + extension_name\n\
    \        val extension_name_with_extension = extension_name + \".\" + class_name\n\
    \        val strength_with_name = strength + \".\" + class_name\n        val strength_with_name_with_extension\
    \ = strength + \".\" + extension_name\n        val extension_name_with_name =\
    \ extension_name + \".\" + class_name\n        val extension_name_with_name_with_extension\
    \ = extension_name + \".\" + extension_name\n        val extension_name_with_extension_name\
    \ = extension_name + \".\" + extension_name\n        val extension_name_with_name_with_extension_name\
    \ = extension_name + \".\" + extension_name\n        val extension_name_with_extension_name_with_name\
    \ = extension_name + \".\" + extension_name\n        val extension_name_with_extension_name_with_name_with_extension\
    \ = extension_name + \".\" + extension_name\n        val extension_name_with_extension_name_with_name_with_extension_name\
    \ = extension_name + \".\" + extension_name\n        val extension_name_with_extension_name_with_name_with_extension_name_with_extension\
    \ = extension_name + \".\" + extension_name\n        val extension_name_with_extension_name_with_name_with_extension_name_with_extension_name\
    \ = extension_name + \".\" + extension_name\n        val extension_name_with_extension_name_with_name_with_extension_name_with_extension_name_with_extension\
    \ = extension_name + \".\" + extension_name\n        val extension_name_with_extension_name_with_name_with_extension_name_with_extension_name_with_extension_name_with_extension\
    \ = extension_name + \".\" + extension_name\n        val extension_name_with_extension_name_with_name_with_extension_name_with_extension_name_with_extension_name_with_extension_name_with_extension\
    \ = extension_name + \".\" + extension_name\n        val extension_name_with_extension_name_with_name_with_extension_name_with_extension_name_with_extension_name_with_extension_name_with_extension_name_with_extension\
    \ = extension_name + \".\" + extension_name\n        val extension_name_with_extension_name_with_name_with_extension_name_with_extension_name_with_extension_name_with_extension_name_with_extension_name_with_extension_name_with_extension\
    \ = extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcfe8phe9.scala:25:25 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name_map.filter(_._2\
    \ == class_name_map.get(_._2)).map(_._1).head\n\e[31m\e[31m   |\e[0m         \
    \                ^\e[0m\n\e[31m   |\e[0m                         Recursive \e\
    [33mvalue\e[0m \e[35mclass_name_map\e[0m needs type\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpcfe8phe9.scala:45:5 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659799627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.values.max\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n \
    \       val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_ == '.').drop(1)\n\
    \        class_name + extensions_sorted + extensions_map(strength).mkString(\"\
    .\") + extensions_map(strength + 1).mkString(\".\") + extensions_map(strength\
    \ + 2).mkString(\".\") + extensions_map(strength + 3).mkString(\".\") + extensions_map(strength\
    \ + 4).mkString(\".\") + extensions_map(strength + 5).mkString(\".\") + extensions_map(strength\
    \ + 6).mkString(\".\") + extensions_map(strength + 7).mkString(\".\") + extensions_map(strength\
    \ + 8).mkString(\".\") + extensions_map(strength + 9).mkString(\".\") + extensions_map(strength\
    \ + 10).mkString(\".\") + extensions_map(strength + 11).mkString(\".\") + extensions_map(strength\
    \ + 12).mkString(\".\") + extensions_map(strength + 13).mkString(\".\") + extensions_map(strength\
    \ + 14).mkString(\".\") + extensions_map(strength + 15).mkString(\".\") + extensions_map(strength\
    \ + 16).mkString(\".\") + extensions_map(strength + 17).mkString(\".\") + extensions_map(strength\
    \ + 18).mkString(\".\") + extensions_map(strength + 19).mkString(\".\") + extensions_map(strength\
    \ + 20).mkString(\".\") + extensions_map(strength + 21).mkString(\".\") + extensions_map(strength\
    \ + 22).mkString(\".\") + extensions_map(strength + 23).mkString(\".\") + extensions_map(strength\
    \ + 24).mkString(\".\") + extensions_map(strength + 25).mkString(\".\") + extensions_map(strength\
    \ + 26).mkString(\".\") + extensions_map(strength + 27).mkString(\".\") + extensions_map(strength\
    \ + 28).mkString(\".\") + extensions_map(strength + 29).mkString(\".\") + extensions_map(strength\
    \ + 30).mkString(\".\") + extensions_map(strength + 31).mkString(\".\") + extensions_map(strength\
    \ + 32).mkString(\".\") + extension\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz_fxb3a5.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpz_fxb3a5.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropWhile(_ == \e[31m'.'\e[0m).drop(\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmpz_fxb3a5.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpz_fxb3a5.scala:26:1545 ----------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        class_"
  stdout: ''
  timestamp: 1659799627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((x, y) => x - y)\n        val\
    \ extensions_sorted = extensions_map.values.sortWith((x, y) => x < y)\n      \
    \  val extensions_sorted = extensions_sorted.takeWhile(_ <= strength)\n      \
    \  val extensions_sorted = extensions_sorted.mkString(\"\") + \".\" + extensions_sorted.last\n\
    \        class_name.toString + \".\" + extensions_sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmped6iwuer.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ <= strength)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmped6iwuer.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m) + \e[31m\".\"\e[0m + extensions_sorted.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmped6iwuer.scala:23:54 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.values.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x < y)\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         value sortWith is not a member of\
    \ Iterable[Int]\n3 errors found\n"
  stdout: ''
  timestamp: 1659799627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper_sm = extensions_count_upper - extensions_count_lower\
    \ - extensions_count\n        val extensions_count_lower_sm = extensions_count_lower\
    \ - extensions_count_upper - extensions_count\n        val extensions_count_upper_c\
    \ = extensions_count_upper - extensions_count_lower\n        val extensions_count_lower_c\
    \ = extensions_count_lower - extensions_count_upper\n        val extensions_count_upper_sm_c\
    \ = extensions_count_upper_sm - extensions_count_lower_sm - extensions_count_c\n\
    \        val extensions_count_lower_sm_c = extensions_count_lower_sm - extensions_count_upper_sm\
    \ - extensions_count_c\n        val extensions_count_upper_c = extensions_count_upper\
    \ - extensions_count_lower\n        val extensions_count_lower_c = extensions_count_lower\
    \ - extensions_count_upper\n        val extensions_count_upper_sm_c_c = extensions_count_upper_sm_c\
    \ - extensions_count_lower_sm_c - extensions_count_c\n        val extensions_count_lower_sm_c_c\
    \ = extensions_count_lower_sm_c - extensions_count_upper_sm_c - extensions_count_c\n\
    \        val extensions_count_upper_c = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_lower_c = extensions_count_lower - extensions_count_upper\n\
    \        val extensions_count_upper_sm_c_c_c = extensions_count_upper_sm_c_c -\
    \ extensions_count_lower_sm_c_c - extensions_count_c\n        val extensions_count_lower_sm_c_c_c\
    \ = extensions_count_lower_sm_c_c - extensions_count_upper_sm_c_c - extensions_count_c\n\
    \        val extensions_count_upper = extensions_count_upper - extensions_count_lower\
    \ - extensions_count\n        val extensions_count_lower = extensions_count_lower\
    \ - extensions_count_upper - extensions_count\n        val extensions_count_upper_sm\
    \ = extensions_count_upper_sm - extensions_count_lower_sm - extensions_count\n\
    \        val extensions_count_lower_sm = extensions_count_lower_sm - extensions_count_upper_sm\
    \ - extensions_count\n        val extensions_count_upper_c = extensions_count_upper_c\
    \ - extensions_count_lower_c - extensions_count\n        val extensions_count_lower_c\
    \ = extensions_count_lower_c - extensions_count_upper_c - extensions_count\n \
    \       val extensions_count_upper_sm_c = extensions_count_upper_s\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmhzfbepw.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper_c\e\
    [0m = extensions_count_upper - extensions_count_lower\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper_c is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper_c\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmhzfbepw.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower_c\e\
    [0m = extensions_count_lower - extensions_count_upper\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower_c is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower_c\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmhzfbepw.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper_c\e\
    [0m = extensions_count_upper - extensions_count_lower\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper_c is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper_c\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmhzfbepw.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower_c\e\
    [0m = extensions_count_lower - extensions_count_upper\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower_c is already defined as \e[3"
  stdout: ''
  timestamp: 1659799627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_low\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphfsovsd7.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphfsovsd7.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_upper\e[0m = extensions.map(_.toUpperCase.length).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphfsovsd7.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase.length).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphfsovsd7.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_count_upper\
    \ - extensions_count_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength is already defined as \e[33mvalue\e[0m \e[35mstrength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphfsovsd7.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mclass_name_upper\e[0m = class_name.toUpperCase\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mclass_name_upper is already defin"
  stdout: ''
  timestamp: 1659799628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C') - e.toUpperCase.count(_ == 'D') - e.toUpperCase.count(_\
    \ == 'E') - e.toUpperCase.count(_ == 'F') - e.toUpperCase.count(_ == 'G') - e.toUpperCase.count(_\
    \ == 'H') - e.toUpperCase.count(_ == 'I') - e.toUpperCase.count(_ == 'J') - e.toUpperCase.count(_\
    \ == 'K') - e.toUpperCase.count(_ == 'L') - e.toUpperCase.count(_ == 'M') - e.toUpperCase.count(_\
    \ == 'N') - e.toUpperCase.count(_ == 'O') - e.toUpperCase.count(_ == 'P') - e.toUpperCase.count(_\
    \ == 'Q') - e.toUpperCase.count(_ == 'R') - e.toUpperCase.count(_ == 'S') - e.toUpperCase.count(_\
    \ == 'T') - e.toUpperCase.count(_ == 'U') - e.toUpperCase.count(_ == 'V') - e.toUpperCase.count(_\
    \ == 'W') - e.toUpperCase.count(_ == 'X') - e.toUpperCase.count(_ == 'Y') - e.toUpperCase.count(_\
    \ == 'Z') - e.toUpperCase.count(_ == 'a') - e.toUpperCase.count(_ == 'b') - e.toUpperCase.count(_\
    \ == 'c') - e.toUpperCase.count(_ == 'd') - e.toUpperCase.count(_ == 'e') - e.toUpperCase.count(_\
    \ == 'f') - e.toUpperCase.count(_ == 'g') - e.toUpperCase.count(_ == 'h') - e.toUpperCase.count(_\
    \ == 'i') - e.toUpperCase.count(_ == 'j') - e.toUpperCase.count(_ == 'k') - e.toUpperCase.count(_\
    \ == 'l') - e.toUpperCase.count(_ == 'm') - e.toUpperCase.count(_ == 'n') - e.toUpperCase.count(_\
    \ == 'o') - e.toUpperCase.count(_ == 'p') - e.toUpperCase.count(_ == 'q') - e.toUpperCase.count(_\
    \ == 'r') - e.toUpperCase.count(_ == 's') - e.toUpperCase.count(_ == 't') - e.toUpperCase.count(_\
    \ == 'u') - e.toUpperCase.count(_ == 'v') - e.toUpperCase.count(_ == 'w') - e.toUpperCase.count(_\
    \ == 'x') - e.toUpperCase.count(_ == 'y') - e.toUpperCase.count(_\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzku3kgid.scala:22:4 ----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpzku3kgid.scala:21:1701\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_map\e[0m = extensions.map(\e[36me\e[0m => e.toUpperCase.count(_\
    \ == \e[31m'A'\e[0m) - e.toUpperCase.count(_ == \e[31m'B'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'C'\e[0m) - e.toUpperCase.count(_ == \e[31m'D'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'E'\e[0m) - e.toUpperCase.count(_ == \e[31m'F'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'G'\e[0m) - e.toUpperCase.count(_ == \e[31m'H'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'I'\e[0m) - e.toUpperCase.count(_ == \e[31m'J'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'K'\e[0m) - e.toUpperCase.count(_ == \e[31m'L'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'M'\e[0m) - e.toUpperCase.count(_ == \e[31m'N'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'O'\e[0m) - e.toUpperCase.count(_ == \e[31m'P'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'Q'\e[0m) - e.toUpperCase.count(_ == \e[31m'R'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'S'\e[0m) - e.toUpperCase.count(_ == \e[31m'T'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'U'\e[0m) - e.toUpperCase.count(_ == \e[31m'V'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'W'\e[0m) - e.toUpperCase.count(_ == \e[31m'X'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'Y'\e[0m) - e.toUpperCase.count(_ == \e[31m'Z'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'a'\e[0m) - e.toUpperCase.count(_ == \e[31m'b'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'c'\e[0m) - e.toUpperCase.count(_ == \e[31m'd'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'e'\e[0m) - e.toUpperCase.count(_ == \e[31m'f'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'g'\e[0m) - e.toUpperCase.count(_ == \e[31m'h'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'i'\e[0m) - e.toUpperCase.count(_ == \e[31m'j'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'k'\e[0m) - e.toUpperCase.count(_ == \e[31m'l'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'm'\e[0m) - e.toUpperCase.count(_ == \e[31m'n'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31"
  stdout: ''
  timestamp: 1659799629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x.toUpperCase, x.toLowerCase)).map(x => x._2.length\
    \ - x._1.length)\n        val max_strength = strength.max\n        val max_key\
    \ = extensions_map.keys.find(x => strength.contains(x))\n        val max_value\
    \ = extensions_map.get(max_key)\n        val max_key_name = class_name_map.get(max_key)\n\
    \        val max_key_name_with_extension = max_key_name + \".\" + max_value\n\
    \        val max_key_name_with_extension_map = max_key_name_with_extension.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).toMap\n        val max_key_name_with_extension_strength\
    \ = max_key_name_with_extension_map.values.map(x => (x.toUpperCase, x.toLowerCase)).map(x\
    \ => x._2.length - x._1.length)\n        val max_key_name_with_extension_strength_max\
    \ = max_key_name_with_extension_strength.max\n        val max_key_name_with_extension_strength_max_key\
    \ = max_key_name_with_extension_strength_max.keys.find(x => max_key_name_with_extension_strength_max.contains(x))\n\
    \        val max_key_name_with_extension_strength_max_value = max_key_name_with_extension_strength_max.get(max_key_name_with_extension_strength_max_key)\n\
    \        val max_key_name_with_extension_strength_max_key_name = max_key_name_with_extension_strength_max_key.map(x\
    \ => x.toUpperCase).mkString(\"\")\n        val max_key_name_with_extension_strength_max_key_name_with_extension\
    \ = max_key_name_with_extension_strength_max_key_name + \".\" + max_key_name_with_extension_strength_max_value\n\
    \        val max_key_name_with_extension_strength_max_key_name_with_extension_map\
    \ = max_key_name_with_extension_strength_max_key_name_with_extension.map(x =>\
    \ (x.toUpperCase, x.toLowerCase)).toMap\n        val max_key_name_with_extension_strength_max_key_name_with_extension_strength\
    \ = max_key_name_with_extension_strength_max_key_name_with_extension_map.values.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).map(x => x._2.length - x._1.length)\n   \
    \     val max_key_name_with_extension_strength_max_key_name_with_extension_strength_max\
    \ = max_key_name_with_extension_strength_max_key_name_with_extension_strength.max\n\
    \        val max_key_name_with_extension_strength\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxgirjzsj.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxgirjzsj.scala:22:52\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxgirjzsj.scala:22:67\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \         ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value\
    \ toLowerCase is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpxgirjzsj.scala:25:61 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        \e[33mval\e[0m \e[36mmax_key\e[0m = extensions_map.keys.find(\e[36mx\e\
    [0m => strength.contains(x))\n\e[31m\e[31m   |\e[0m                          \
    \                          ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue contains\
    \ is not a member of Iterable[Int], but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxgirjzsj.scala:26:43\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax_value\e\
    [0m = extensions_map.get(max_key)\n\e[31m\e[31m   |\e[0m                     \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \           Found:    (max_key : Option[String])\n\e[31m   |\e[0m  "
  stdout: ''
  timestamp: 1659799630
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.foldLeft(0)((x, y) =>\n            val cap = x.length\n   \
    \         val sm = y.length\n            val strength_of_extension = cap - sm\n\
    \            if (strength_of_extension > x) \n                strength_of_extension\n\
    \            else if (strength_of_extension == x)\n                if (class_name_map.contains(y))\n\
    \                    class_name_map(y)\n                else\n               \
    \     0\n            else\n                0\n        )\n        val class_name\
    \ = class_name_map.getOrElse(\"\", \"\")\n        val extension = extensions_map.getOrElse(\"\
    \", \"\")\n        val strength_str = if (strength == 0) \"\" else s\"(${strength})\"\
    \n        s\"$class_name.$extension$strength_str\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7up_ic65.scala:37:25 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name_map.getOrElse(\e\
    [31m\"\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                       \
    \  ^\e[0m\n\e[31m   |\e[0m                         Recursive \e[33mvalue\e[0m\
    \ \e[35mclass_name_map\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp7up_ic65.scala:24:24 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mcap\e[0m = x.length\n\e[31m\e\
    [31m   |\e[0m                      ^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \          value length is not a member of Int\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp7up_ic65.scala:25:23 ------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m            \e[33mval\e[0m \e[36msm\e[0m = y.length\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^^\e[0m\n\e[31m   |\e[0m                     value\
    \ length is not a member of (String, String)\n3 errors found\n"
  stdout: ''
  timestamp: 1659799628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val strength_upper = strength / extensions_count_upper\n        val strength_lower\
    \ = strength / extensions_count_lower\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_upper - strength_lower compareTo a.length - b.length)\n     \
    \   val extensions_sorted = extensions.sortWith((a, b) => strength_lower - strength_upper\
    \ compareTo a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_upper - strength_lower compareTo a.length - b.length)\n     \
    \   val extensions_sorted = extensions.sortWith((a, b) => strength_lower - strength_upper\
    \ compareTo a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_upper - strength_lower compareTo a.length - b.length)\n     \
    \   val extensions_sorted = extensions.sortWith((a, b) => strength_lower - strength_upper\
    \ compareTo a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_upper - strength_lower compareTo a.length - b.length)\n     \
    \   val extensions_sorted = extensions.sortWith((a, b) => strength_lower - strength_upper\
    \ compareTo a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_upper - strength_lower compareTo a.length - b.length)\n     \
    \   val extensions_sorted = extensions.sortWith((a, b) => strength_lower - strength_upper\
    \ compareTo a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_upper - strength_lower compareTo a.length - b.length)\n     \
    \   val extensions_sorted = extensions.sortWith((a, b) => strength_lower - strength_upper\
    \ compareTo a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_upper - strength_lower compareTo a.length - b.length)\n     \
    \   val extensions_sorted = extensions.sortWith((a, b) => strength_lower - strength_upper\
    \ compareTo a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_upper - strength_lower compareTo a.length - b.length)\n     \
    \   val extensions_sorted = extensions.sortWith((a, b) => strength_lower - strength_upper\
    \ compareTo a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfu8d0gir.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfu8d0gir.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions.sortWith((\e[36ma\e[0m, \e[36mb\e\
    [0m) => strength_lower - strength_upper compareTo a.length - b.length)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfu8d0gir.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength_upper - strength_lower\
    \ compareTo a.length - b.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfu8d0gir.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength_lower - strength_upper\
    \ compareTo a.length - b.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined "
  stdout: ''
  timestamp: 1659799629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val\
    \ extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val strength_upper\
    \ = extensions_count_upper - extensions_count_lower\n        val extensions_count_upper\
    \ = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n\
    \        val strength_lower = extensions_count_lower - extensions_count_upper\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_all = extensions_count_upper - extensions_count_lower\n        val\
    \ extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower\
    \ = extensions.map(_.toLowerCase).sum\n        val strength_all = extensions_count_upper\
    \ - extensions_count_lower\n        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n    \
    \    val strength_all = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val\
    \ extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val strength_all\
    \ = extensions_count_upper - extensions_count_lower\n        val extensions_count_upper\
    \ = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n\
    \        val strength_all = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_all = extensions_count_upper - extensions_count_lower\n        val\
    \ extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower\
    \ = extensions.map(_.toLowerCase).sum\n        val strength_all = extensions_count_upper\
    \ - extensions_count_lower\n        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n    \
    \    val strength_all = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper = extensions.map(_.toUpperCase).\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1zflh55p.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1zflh55p.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper\e[0m = extensions.map(_.toUpperCase).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1zflh55p.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1zflh55p.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper\e\
    [0m = extensions.map(_.toUpperCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1zflh55p.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e["
  stdout: ''
  timestamp: 1659799628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs)\n        val\
    \ max_strength = strength.max\n        val max_key = strength.max\n        val\
    \ max_key_index = strength.indexOfMax\n        val max_key_value = extensions_map.get(max_key)\n\
    \        val max_key_index = max_key_index + 1\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_value = max_key_value\
    \ + extensions_map.get(max_key_index).length\n        val max_key_\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"\
    ), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu0lr943z.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu0lr943z.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_key_index\e[0m = max_key_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax_key_index\
    \ is already defined as \e[33mvalue\e[0m \e[35mmax_key_index\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu0lr943z.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmax_key_value\e[0m = max_key_value + extensions_map.get(max_key_index).length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key_value is already defined as \e[33mvalue\e[0m \e[35mmax_key_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu0lr943z.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value\e[0m = max_key_value +\
    \ extensions_map.get(max_key_index).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key_value is already defined as \e[33mvalue\e[0m \e[35mmax_key_value\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu0lr943z.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value\e[0m = max_key_value +\
    \ extensions_map.get(max_key_index).length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key_va"
  stdout: ''
  timestamp: 1659799631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs)\n        val\
    \ max_strength = strength.max\n        val max_key = strength.maxBy(x => x)\n\
    \        val max_key = max_key._1\n        val max_value = max_key._2\n      \
    \  val class_name = class_name_map.get(max_key)\n        val extension = extensions_map.get(max_key)\n\
    \        val extension_str = extension.mkString.toLowerCase\n        val class_name_str\
    \ = class_name.mkString.toLowerCase\n        val strength_str = max_value.mkString.toUpperCase\n\
    \        val result = class_name_str + \".\" + extension_str\n        \n     \
    \   if(strength_str != max_strength) {\n            val strength_str = max_strength.mkString.toUpperCase\n\
    \            val result = class_name_str + \".\" + strength_str\n        }\n \
    \       \n        result\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1rb4dxb3.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmax_key\e[0m = max_key._1\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmax_key\
    \ is already defined as \e[33mvalue\e[0m \e[35mmax_key\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp1rb4dxb3.scala:28:25\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclass_name\e[0m = class_name_map.get(max_key)\n\e[31m\e[31m   |\e[0m \
    \                        ^\e[0m\n\e[31m   |\e[0m                         Recursive\
    \ \e[33mvalue\e[0m \e[35mclass_name_map\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp1rb4dxb3.scala:23:57 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => (x - class_name_map.get(x)).abs)\n\e[31m\e[31m   |\e[0m        \
    \                                               ^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ - is not a member of String, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- Error: /tmp/tmp1rb4dxb3.scala:24:39 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmax_strength\e[0m = strength.max\n\
    \e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m   |\e\
    [0mambiguous given instances: both \e[33mobject\e[0m \e[35mDeprecatedFloatOrdering\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mLong\e\
    [0m in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of parameter\
    \ ord of \e[33mmethod"
  stdout: ''
  timestamp: 1659799631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper_ratio = extensions_count_upper / extensions_count.toDouble\n\
    \        val extensions_count_lower_ratio = extensions_count_lower / extensions_count.toDouble\n\
    \        val strength_upper_ratio = strength / extensions_count_upper.toDouble\n\
    \        val strength_lower_ratio = strength / extensions_count_lower.toDouble\n\
    \        val extensions_count_ratio = extensions_count_upper / extensions_count.toDouble\n\
    \        val extensions_count_ratio_upper = extensions_count_upper / extensions_count.toDouble\n\
    \        val extensions_count_ratio_lower = extensions_count_lower / extensions_count.toDouble\n\
    \        val extensions_count_ratio_upper_ratio = extensions_count_upper / extensions_count.toDouble\n\
    \        val extensions_count_ratio_lower_ratio = extensions_count_lower / extensions_count.toDouble\n\
    \        val extensions_count_ratio_upper_ratio_upper = extensions_count_upper\
    \ / extensions_count.toDouble\n        val extensions_count_ratio_lower_ratio_lower\
    \ = extensions_count_lower / extensions_count.toDouble\n        val extensions_count_ratio_upper_ratio_lower_ratio\
    \ = extensions_count_lower / extensions_count.toDouble\n        val extensions_count_ratio_lower_ratio_upper\
    \ = extensions_count_lower / extensions_count.toDouble\n        val extensions_count_ratio_lower_ratio_lower\
    \ = extensions_count_lower / extensions_count.toDouble\n        val extensions_count_ratio_upper_ratio_lower_ratio_upper\
    \ = extensions_count_lower / extensions_count.toDouble\n        val extensions_count_ratio_lower_ratio_lower_ratio\
    \ = extensions_count_lower / extensions_count.toDouble\n        val extensions_count_ratio_upper_ratio_lower_ratio_lower\
    \ = extensions_count_lower / extensions_count.toDouble\n        val extensions_count_ratio_lower_ratio_lower_ratio_upper\
    \ = extensions_count_lower / extensions_count.toDouble\n        val extensions_count_ratio_lower_ratio_lower_ratio_lower\
    \ = extensions_count_lower / extensions_count.toDouble\n        val extensions_count_ratio_upper_ratio_lower_ratio_lower_ratio\
    \ = extensions_count_lower / extensions_count.toDouble\n        val extensions_count_ratio_lower_ratio_lower_ratio_lower\
    \ = extensions_count_lower / extensions_count.toDouble\n        val extensions_count_ratio_upper_ratio_lower_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7jzbusql.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7jzbusql.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_ratio_lower_ratio_lower\e[0m = extensions_count_lower\
    \ / extensions_count.toDouble\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_ratio_lower_ratio_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_ratio_lower_ratio_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7jzbusql.scala:45:12 ---------------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_ratio_lower_ratio_lower_ratio_lower\e\
    [0m = extensions_count_lower / extensions_count.toDouble\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_ratio_lower_ratio_lower_ratio_lower is already\
    \ defined as \e[33mvalue\e[0m \e[35mextensions_count_ratio_lower_ratio_lower_ratio_lower\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp7jzbusql.scala:47:5 ---------------------\e[0m\e[0m\n\
    \e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659799629
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val strength = extensions_count - class_name_length\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => strength - a.length - b.length)\n        val\
    \ extension_length = extensions_sorted.map(_.length).sum\n        val extension_strength\
    \ = extensions_sorted.map(_.length).sum\n        val extension_first = extensions_sorted.head\n\
    \        val extension_last = extensions_sorted.last\n        val extension_first\
    \ = extension_first.length\n        val extension_last = extension_last.length\n\
    \        val extension_first = extension_first / extension_length\n        val\
    \ extension_last = extension_last / extension_length\n        val extension_first\
    \ = extension_first - extension_last\n        val extension_last = extension_last\
    \ - extension_first\n        val extension_first = extension_first / extension_strength\n\
    \        val extension_last = extension_last / extension_strength\n        val\
    \ extension_first = extension_first - extension_last\n        val extension_last\
    \ = extension_last - extension_first\n        val extension_first = extension_first\
    \ / extension_length\n        val extension_last = extension_last / extension_length\n\
    \        val extension_first = extension_first - extension_last\n        val extension_last\
    \ = extension_last - extension_first\n        val extension_first = extension_first\
    \ / extension_strength\n        val extension_last = extension_last / extension_strength\n\
    \        val extension_first = extension_first - extension_last\n        val extension_last\
    \ = extension_last - extension_first\n        val extension_first = extension_first\
    \ / extension_length\n        val extension_last = extension_last / extension_length\n\
    \        val extension_first = extension_first - extension_last\n        val extension_last\
    \ = extension_last - extension_first\n        val extension_first = extension_first\
    \ / extension_strength\n        val extension_last = extension_last / extension_strength\n\
    \        val extension_first = extension_first - extension_last\n        val extension_last\
    \ = extension_last - extension_first\n        val extension_first = extension_first\
    \ / extension_length\n        val extension_last = extension_last / extension_length\n\
    \        val extension_first = extension_first - extension_last\n        val extension_last\
    \ = extension_last - extension_first\n        val extension_first = extension_first\
    \ / extension_strength\n        val extension_last = extension_last / extension_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsov5qgo8.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextension_first\e[0m = extension_first.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mextension_first is already defined as \e[33mvalue\e[0m \e[35mextension_first\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsov5qgo8.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mextension_last\e[0m = extension_last.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mextension_last is already defined as \e[33mvalue\e[0m \e[35mextension_last\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsov5qgo8.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mextension_first\e[0m = extension_first\
    \ / extension_length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_first is already defined as \e[33mvalue\e[0m \e\
    [35mextension_first\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpsov5qgo8.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mextension_last\e[0m = extension_last\
    \ / extension_length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_last is already defined as \e[33mvalue\e[0m \e[35mextension_last\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsov5qgo8.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mextens"
  stdout: ''
  timestamp: 1659799631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase).map(_.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase).map(_.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    if (extensions_count > 1) {\n            val extensions_sorted = extensions.sortBy(_.length)\n\
    \            val extensions_sorted_upper = extensions_sorted.map(_.toUpperCase)\n\
    \            val extensions_sorted_lower = extensions_sorted.map(_.toLowerCase)\n\
    \            val strength_sorted = extensions_sorted_upper.map(_.length) - extensions_sorted_lower.map(_.length)\n\
    \            val strength_sorted_upper = extensions_sorted_upper.map(_.toUpperCase).map(_.length).sum\n\
    \            val strength_sorted_lower = extensions_sorted_lower.map(_.toLowerCase).map(_.length).sum\n\
    \            if (strength_sorted > strength) {\n                val extensions_sorted_sorted\
    \ = extensions_sorted.sortBy(_.length)\n                val extensions_sorted_sorted_upper\
    \ = extensions_sorted_sorted.map(_.toUpperCase)\n                val extensions_sorted_sorted_lower\
    \ = extensions_sorted_sorted.map(_.toLowerCase)\n                val strength_sorted_sorted\
    \ = extensions_sorted_sorted_upper.map(_.length) - extensions_sorted_sorted_lower.map(_.length)\n\
    \                val strength_sorted_sorted_upper = extensions_sorted_sorted_upper.map(_.toUpperCase).map(_.length).sum\n\
    \                val strength_sorted_sorted_lower = extensions_sorted_sorted_lower.map(_.toLowerCase).map(_.length).sum\n\
    \                if (strength_sorted_sorted > strength) {\n                  \
    \  val extensions_sorted_sorted_sorted = extensions_sorted_sorted.sortBy(_.length)\n\
    \                    val extensions_sorted_sorted_sorted_upper = extensions_sorted_sorted_sorted.map(_.toUpperCase)\n\
    \                    val extensions_sorted_sorted_sorted_lower = extensions_sorted_sorted_sorted.map(_.toLowerCase)\n\
    \                    val strength_sorted_sorted_sorted = extensions_sorted_sorted_sorted_upper.map(_.length)\
    \ - extensions_sorted_sorted_sorted_lower.map(_.length)\n                    val\
    \ strength_sorted_sorted_sorted_upper = extensions_sorted_sorted_sorted_upper.map(_.toUpperCase).map(_.length).sum\n\
    \                    val strength_sorted_sorted_sorted_lower = extensions_sorted_sorted_sorted_lower.map(_.toLowerCase).map(_.length).sum\n\
    \                    if (strength_sorted_sorted_sorted > strength) {\n       \
    \                 val extensions_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted.sortBy(_.length)\n\
    \                        val extensions_sorted_sorted_sorted_sorted_upper = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpk38rxa1b.scala:48:74 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m                        \e[33mval\e[0m \e[36mextensions_sorted_sorted_sorted_sorted_upper\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \            expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpk38rxa1b.scala:63:0 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk38rxa1b.scala:29:72\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m\
    \ \e[36mstrength_sorted\e[0m = extensions_sorted_upper.map(_.length) - extensions_sorted_lower.map(_.length)\n\
    \e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of List[Int], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpk38rxa1b.scala:36:90 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m                \e[33mval\e[0m \e[36mstrength_sorted_sorted\e\
    [0m = extensions_sorted_sorted_upper.map(_.length) - extensions_sorted_sorted_lower.map(_.length)\n\
    \e[31m\e[31m   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of List[Int], but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  im"
  stdout: ''
  timestamp: 1659799634
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase - x.toLowerCase -> x)).toMap\n        val\
    \ class_name_map = class_name.map(x => (x.toUpperCase - x.toLowerCase -> x)).toMap\n\
    \        val strength = extensions_map.values.map(x => class_name_map.getOrElse(x,\
    \ 0)).sum\n        val extensions_sorted = extensions_map.values.sortBy(x => -x)\n\
    \        val class_name_sorted = class_name_map.values.sortBy(x => -x)\n     \
    \   val extensions_sorted_list = extensions_sorted.toList\n        val class_name_sorted_list\
    \ = class_name_sorted.toList\n        val index = extensions_sorted_list.indexOf(strength)\n\
    \        if (index >= 0) {\n            class_name_sorted_list(index)\n      \
    \  } else {\n            class_name_sorted_list.head\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcvbvfta8.scala:21:64 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36mx\e[0m => (x.toUpperCase - x.toLowerCase -> x)).toMap\n\e[31m\e[31m   |\e\
    [0m                                                  ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue - is not a member of String, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcvbvfta8.scala:22:52\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase - x.toLowerCase\
    \ -> x)).toMap\n\e[31m\e[31m   |\e[0m                                        \
    \          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value\
    \ toUpperCase is not a member of Char\n\e[31m\e[31m-- Error: /tmp/tmpcvbvfta8.scala:23:89\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m\
    \ => class_name_map.getOrElse(x, \e[31m0\e[0m)).sum\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \          ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mShortIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e\
    [33mobject\e[0m \e[35mDoubleIsFractional\e[0m in \e[33mobject\e[0m \e[35mNumeric\e\
    [0m match type Numeric[B] of parameter num of \e[33mmethod\e[0m \e[35msum\e[0m\
    \ in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpcvbvfta8.scala:24:54 ------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m = extensions_map.values.sortBy(\e\
    [36mx\e[0m => -x)\n\e[31m\e[31m   |\e[0m   "
  stdout: ''
  timestamp: 1659799633
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper_sm = extensions_count_upper - extensions_count_lower\
    \ * strength / extensions_count \n        val extensions_count_lower_sm = extensions_count_lower\
    \ - extensions_count_upper * strength / extensions_count \n        val extensions_count_upper_capped\
    \ = extensions_count_upper - extensions_count_upper_sm * strength / extensions_count\
    \ \n        val extensions_count_lower_capped = extensions_count_lower - extensions_count_lower_sm\
    \ * strength / extensions_count \n        val extensions_count_upper_capped2 =\
    \ extensions_count_upper - extensions_count_upper_capped * strength / extensions_count\
    \ \n        val extensions_count_lower_capped2 = extensions_count_lower - extensions_count_lower_capped\
    \ * strength / extensions_count \n        val extensions_count_upper_capped3 =\
    \ extensions_count_upper - extensions_count_upper_capped2 * strength / extensions_count\
    \ \n        val extensions_count_lower_capped3 = extensions_count_lower - extensions_count_lower_capped2\
    \ * strength / extensions_count \n        val extensions_count_upper_capped4 =\
    \ extensions_count_upper - extensions_count_upper_capped3 * strength / extensions_count\
    \ \n        val extensions_count_lower_capped4 = extensions_count_lower - extensions_count_lower_capped3\
    \ * strength / extensions_count \n        val extensions_count_upper_capped5 =\
    \ extensions_count_upper - extensions_count_upper_capped4 * strength / extensions_count\
    \ \n        val extensions_count_lower_capped5 = extensions_count_lower - extensions_count_lower_capped4\
    \ * strength / extensions_count \n        val extensions_count_upper_capped6 =\
    \ extensions_count_upper - extensions_count_upper_capped5 * strength / extensions_count\
    \ \n        val extensions_count_lower_capped6 = extensions_count_lower - extensions_count_lower_capped5\
    \ * strength / extensions_count \n        val extensions_count_upper_capped7 =\
    \ extensions_count_upper - extensions_count_upper_capped6 * strength / extensions_count\
    \ \n        val extensions_count_lower_capped7 = extensions_count_lower - extensions_count_lower_capped6\
    \ * strength / extensions_count \n        val extensions_count_upper_capped8 =\
    \ extensions_count_upper - extensions_count_upper_capped7 * strength / extensions_count\
    \ \n        val extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8qwdph21.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp8qwdph21.scala:43:5 ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659799632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val strength_upper = strength / extensions_count_upper\n        val strength_lower\
    \ = strength / extensions_count_lower\n        val strength_total = strength_upper\
    \ + strength_lower\n        val extensions_sorted = extensions.sortWith((a, b)\
    \ => strength_total - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_total - a.length - b.length)\n        val extensions_sorted =\
    \ extensions.sortWith((a, b) => strength_total - a.length - b.length)\n      \
    \  val extensions_sorted = extensions.sortWith((a, b) => strength_total - a.length\
    \ - b.length)\n        val extensions_sorted = extensions.sortWith((a, b) => strength_total\
    \ - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_total - a.length - b.length)\n        val extensions_sorted =\
    \ extensions.sortWith((a, b) => strength_total - a.length - b.length)\n      \
    \  val extensions_sorted = extensions.sortWith((a, b) => strength_total - a.length\
    \ - b.length)\n        val extensions_sorted = extensions.sortWith((a, b) => strength_total\
    \ - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_total - a.length - b.length)\n        val extensions_sorted =\
    \ extensions.sortWith((a, b) => strength_total - a.length - b.length)\n      \
    \  val extensions_sorted = extensions.sortWith((a, b) => strength_total - a.length\
    \ - b.length)\n        val extensions_sorted = extensions.sortWith((a, b) => strength_total\
    \ - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_total - a.length - b.length)\n        val extensions_sorted =\
    \ extensions.sortWith((a, b) => strength_total - a.length - b.length)\n      \
    \  val extensions_sorted = extensions.sortWith((a, b) => strength_total - a.length\
    \ - b.length)\n        val extensions_sorted = extensions.sortWith((a, b) => strength_total\
    \ - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength_total - a.length - b.length)\n        val extensions_sorted =\
    \ extensions.sortWith((a, b) => strength_total - a.length - b.length)\n      \
    \  val extensions_sorted = extensions.sortWith((a, b) => strength_total - a.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpizx6dr1_.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpizx6dr1_.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m = extensions.sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => strength_total - a.length - b.length)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpizx6dr1_.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength_total - a.length\
    \ - b.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpizx6dr1_.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength_total - a.length\
    \ - b.length)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpizx6dr1_.scala:32:12 ---------------------------\e\
    [0m\e[0m"
  stdout: ''
  timestamp: 1659799638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toString.toString.toUpperCase.length).toArray\n\
    \        val max_strength = strength.max\n        val max_extension = extensions_map.getOrElse(max_strength,\
    \ \"\")\n        val max_class_name = class_name_map.getOrElse(max_strength, \"\
    \")\n        val max_extension_name = max_extension.map(x => x.toUpperCase)\n\
    \        val max_extension_name_with_extension = max_extension_name ++ extensions\n\
    \        (max_class_name + \".\" + max_extension_name).mkString\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2eq6zowl.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp2eq6zowl.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2eq6zowl.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e\
    [31m0\e[0m) - x.toString.toString.toUpperCase.length).toArray\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \          ^\e[0m\n\e[31m   |\e[0m                                           \
    \       Found:    (x : String)\n\e[31m   |\e[0m                              \
    \                    Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp2eq6zowl.scala:25:53 --------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmax_extension\e[0m = extensions_map.getOrElse(max_strength,\
    \ \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                                    \
    \                 ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \                 Found:    (max_strength : Int)\n\e[31m   |\e[0m            \
    \                              Required: String\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp2eq"
  stdout: ''
  timestamp: 1659799641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper_ratio = extensions_count_upper / extensions_count.toDouble\n\
    \        val extensions_count_lower_ratio = extensions_count_lower / extensions_count.toDouble\n\
    \        val extensions_count_ratio = extensions_count_upper / extensions_count_lower\n\
    \        val extensions_count_ratio2 = extensions_count_upper / extensions_count_upper_ratio\n\
    \        val extensions_count_ratio3 = extensions_count_lower / extensions_count_lower_ratio\n\
    \        val extensions_count_ratio4 = extensions_count_upper / extensions_count_ratio3\n\
    \        val extensions_count_ratio5 = extensions_count_lower / extensions_count_ratio4\n\
    \        val extensions_count_ratio6 = extensions_count_upper / extensions_count_ratio5\n\
    \        val extensions_count_ratio7 = extensions_count_lower / extensions_count_ratio6\n\
    \        val extensions_count_ratio8 = extensions_count_upper / extensions_count_ratio7\n\
    \        val extensions_count_ratio9 = extensions_count_lower / extensions_count_ratio8\n\
    \        val extensions_count_ratio10 = extensions_count_upper / extensions_count_ratio9\n\
    \        val extensions_count_ratio11 = extensions_count_lower / extensions_count_ratio10\n\
    \        val extensions_count_ratio12 = extensions_count_upper / extensions_count_ratio11\n\
    \        val extensions_count_ratio13 = extensions_count_lower / extensions_count_ratio12\n\
    \        val extensions_count_ratio14 = extensions_count_upper / extensions_count_ratio13\n\
    \        val extensions_count_ratio15 = extensions_count_lower / extensions_count_ratio14\n\
    \        val extensions_count_ratio16 = extensions_count_upper / extensions_count_ratio15\n\
    \        val extensions_count_ratio17 = extensions_count_lower / extensions_count_ratio16\n\
    \        val extensions_count_ratio18 = extensions_count_upper / extensions_count_ratio17\n\
    \        val extensions_count_ratio19 = extensions_count_lower / extensions_count_ratio18\n\
    \        val extensions_count_ratio20 = extensions_count_upper / extensions_count_ratio19\n\
    \        val extensions_count_ratio21 = extensions_count_lower / extensions_count_ratio20\n\
    \        val extensions_count_ratio22 = extensions_count_upper / extensions_count_ratio21\n\
    \        val extensions_count_ratio23 = extensions_count_lower \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvqj3qoj0.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        val extension\
    \ = extensions.sortWith(_.length > _.length).head\n        val extension_length\
    \ = extension.length\n        val extension_strength = extension.length - extension_length\n\
    \        val extension_strength_str = extension_strength.toString\n        val\
    \ extension_strength_str_length = extension_strength_str.length\n        val extension_strength_str_length_str\
    \ = extension_strength_str_length.toString\n        val extension_strength_str_length_str_length\
    \ = extension_strength_str_length_str.length\n        val extension_strength_str_length_str_length_str\
    \ = extension_strength_str_length_str_length.toString\n        val extension_strength_str_length_str_length_str_length\
    \ = extension_strength_str_length_str_length_str.length.toString\n        val\
    \ extension_strength_str_length_str_length_str_length_str = extension_strength_str_length_str_length_str_length.toString\n\
    \        val extension_strength_str_length_str_length_str_length_str_length =\
    \ extension_strength_str_length_str_length_str_length_str.length.toString\n  \
    \      val extension_strength_str_length_str_length_str_length_str_length_str\
    \ = extension_strength_str_length_str_length_str_length_str_length.toString\n\
    \        val extension_strength_str_length_str_length_str_length_str_length_str_length\
    \ = extension_strength_str_length_str_length_str_length_str_length_str.length.toString\n\
    \        val extension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str\
    \ = extension_strength_str_length_str_length_str_length_str_length_str_length_str.length.toString\n\
    \        val extension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str_length\
    \ = extension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str.length.toString\n\
    \        val extension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str\
    \ = extension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str.length.toString\n\
    \        val extension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str_length\
    \ = extension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str.length.toString\n\
    \        val extension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str\
    \ = extension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str.length.toString\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpcezyq_hc.scala:42:11 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpcezyq_hc.scala:37:103 -----------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str\e\
    [0m = extension_strength_str_length_str_length_str_length_str_length_str_length_str.length.toString\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: extension_strength_str_length_str_length_str_length_str_length_str_length_str\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpcezyq_hc.scala:39:114\
    \ --------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str\e\
    [0m = extension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str.length.toString\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                          ^\e[0m\n\e[31m   |\e\
    [0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpcezyq_hc.scala:40:132 -----------------------\e[0m\e[0m\n\e[31m40 |\e\
    [0m        \e[33mval\e[0m \e[36mextension_strength_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str_length_str_length\e"
  stdout: ''
  timestamp: 1659799638
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n  \
    \      val extensions_sorted = extensions_sorted.takeWhile(_._2 > strength).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.mkString(class_name + \".\"\
    )\n        extensions_sorted.mkString(extensions_sorted.last)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo9y30tj4.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > strength).map(_._1)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpo9y30tj4.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(class_name + \e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpo9y30tj4.scala:26:53 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        extensions_sorted.mkString(extensions_sorted.last)\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Found:    (Int, Int)\n\e\
    [31m   |\e[0m                                   Required: String\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659799639
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase).zipWithIndex.toMap\n        val class_name_map\
    \ = class_name.zipWithIndex.toMap\n        val strength = extensions_map.foldLeft(0)\
    \ { (s, e) =>\n            val class_name_upper = class_name_map(e._1)\n     \
    \       val class_name_lower = class_name_map(e._2)\n            val class_name_length\
    \ = class_name_upper.length + class_name_lower.length\n            val extension_upper\
    \ = e._1\n            val extension_lower = e._2\n            val extension_length\
    \ = extension_upper.length + extension_lower.length\n            val strength_1\
    \ = if (class_name_length < extension_length) -1 else 0\n            val strength_2\
    \ = if (class_name_length == extension_length) 0 else 1\n            val strength_3\
    \ = if (class_name_length > extension_length) 1 else 0\n            val strength_4\
    \ = if (class_name_length < extension_length) 0 else 1\n            val strength_5\
    \ = if (class_name_length == extension_length) 1 else 0\n            val strength_6\
    \ = if (class_name_length > extension_length) 0 else 1\n            val strength_7\
    \ = if (class_name_length < extension_length) 1 else 0\n            val strength_8\
    \ = if (class_name_length == extension_length) 0 else 1\n            val strength_9\
    \ = if (class_name_length > extension_length) 0 else 1\n            val strength_10\
    \ = if (class_name_length < extension_length) 1 else 0\n            val strength_11\
    \ = if (class_name_length == extension_length) 0 else 1\n            val strength_12\
    \ = if (class_name_length > extension_length) 1 else 0\n            val strength_13\
    \ = if (class_name_length < extension_length) 0 else 1\n            val strength_14\
    \ = if (class_name_length == extension_length) 1 else 0\n            val strength_15\
    \ = if (class_name_length > extension_length) 0 else 1\n            val strength_16\
    \ = if (class_name_length < extension_length) 0 else 1\n            val strength_17\
    \ = if (class_name_length == extension_length) 1 else 0\n            val strength_18\
    \ = if (class_name_length > extension_length) 0 else 1\n            val strength_19\
    \ = if (class_name_length < extension_length) 0 else 1\n            val strength_20\
    \ = if (class_name_length == extension_length) 1 else 0\n            val strength_21\
    \ = if (class_name_length > extension_length) 0 else 1\n            val strength_22\
    \ = if (class_name_length < extension_length) 0 else 1\n            val strength_23\
    \ = if (\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1h1ci05c.scala:52:34 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m            \e[33mval\e[0m \e[36mstrength_23\e[0m = \e\
    [33mif\e[0m (\n\e[31m\e[31m   |\e[0m                                  ^\e[0m\n\
    \e[31m   |\e[0m                                  expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1h1ci05c.scala:67:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m67 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp1h1ci05c.scala:24:52 --------------------\e[0m\e[0m\n\
    \e[31m24 |\e[0m            \e[33mval\e[0m \e[36mclass_name_upper\e[0m = class_name_map(e._1)\n\
    \e[31m\e[31m   |\e[0m                                                  ^^^^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   String\n\e[31m   |\e[0m                                                  Required:\
    \ Char\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1h1ci05c.scala:25:52\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e\
    [36mclass_name_lower\e[0m = class_name_map(e._2)\n\e[31m\e[31m   |\e[0m      \
    \                                            ^^^^\e[0m\n\e[31m   |\e[0m      \
    \                                            Found:    Int\n\e[31m   |\e[0m  \
    \                                                Required: Char\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1h1ci05c.scala:26:53 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e[0m \e[36mclass_name_length\e\
    [0m = class_name_upper.length + class_name_lower.length\n\e[31m\e[31m   |\e[0m\
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                    value length is not a member of Int\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp1h1ci05c.scala:29"
  stdout: ''
  timestamp: 1659799641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper_ratio = extensions_count_upper / extensions_count.toDouble\n\
    \        val extensions_count_lower_ratio = extensions_count_lower / extensions_count.toDouble\n\
    \        val extensions_count_ratio = extensions_count_upper_ratio - extensions_count_lower_ratio\n\
    \        val extensions_count_ratio = extensions_count_ratio.toInt\n        val\
    \ extensions_count_ratio = extensions_count_ratio / 2\n        val extensions_count_ratio\
    \ = extensions_count_ratio.toInt\n        val extensions_count_ratio = extensions_count_ratio\
    \ / 2\n        val extensions_count_ratio = extensions_count_ratio.toInt\n   \
    \     val extensions_count_ratio = extensions_count_ratio / 2\n        val extensions_count_ratio\
    \ = extensions_count_ratio.toInt\n        val extensions_count_ratio = extensions_count_ratio\
    \ / 2\n        val extensions_count_ratio = extensions_count_ratio.toInt\n   \
    \     val extensions_count_ratio = extensions_count_ratio / 2\n        val extensions_count_ratio\
    \ = extensions_count_ratio.toInt\n        val extensions_count_ratio = extensions_count_ratio\
    \ / 2\n        val extensions_count_ratio = extensions_count_ratio.toInt\n   \
    \     val extensions_count_ratio = extensions_count_ratio / 2\n        val extensions_count_ratio\
    \ = extensions_count_ratio.toInt\n        val extensions_count_ratio = extensions_count_ratio\
    \ / 2\n        val extensions_count_ratio = extensions_count_ratio.toInt\n   \
    \     val extensions_count_ratio = extensions_count_ratio / 2\n        val extensions_count_ratio\
    \ = extensions_count_ratio.toInt\n        val extensions_count_ratio = extensions_count_ratio\
    \ / 2\n        val extensions_count_ratio = extensions_count_ratio.toInt\n   \
    \     val extensions_count_ratio = extensions_count_ratio / 2\n        val extensions_count_ratio\
    \ = extensions_count_ratio.toInt\n        val extensions_count_ratio = extensions_count_ratio\
    \ / 2\n        val extensions_count_ratio = extensions_count_ratio.toInt\n   \
    \     val extensions_count_ratio = extensions_count_ratio / 2\n        val extensions_count_ratio\
    \ = extensions_count_ratio.toInt\n        val extensions_count_\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvkuqsspk.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvkuqsspk.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_ratio\e[0m = extensions_count_ratio.toInt\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_ratio is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_ratio\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvkuqsspk.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_ratio\e\
    [0m = extensions_count_ratio / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_ratio is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_ratio\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvkuqsspk.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_ratio\e\
    [0m = extensions_count_ratio.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_ratio is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_ratio\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvkuqsspk.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_ratio\e\
    [0m = extensions_count_ratio / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_ratio is alr"
  stdout: ''
  timestamp: 1659799640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((x, y) => if (x > y) x else y)\n\
    \        val extensions_sorted = extensions_map.values.sortWith((x, y) => x <\
    \ y)\n        val extensions_sorted = extensions_sorted.takeWhile(x => x < strength)\n\
    \        val extensions_sorted = extensions_sorted.mkString(\"\") + extensions_sorted.last\n\
    \        class_name + \".\" + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9o6e_cl9.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x < strength)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9o6e_cl9.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m) + extensions_sorted.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9o6e_cl9.scala:23:54 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_map.values.sortWith((\e[36mx\e[0m, \e[36my\e[0m) => x < y)\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                         value sortWith is not a member of\
    \ Iterable[Int]\n3 errors found\n"
  stdout: ''
  timestamp: 1659799640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length).sum\n\
    \        val extensions_count_sorted_length_sorted = extensions_count_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length = extensions_count_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted = extensions_count_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted_length_sorted\
    \ = extensions_count_sorted_length.sortWith(_ < _)\n        val extensions_count_sorted_length_sorted_length_sorted_length_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9fzzlmr0.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9fzzlmr0.scala:25:90\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length\e[0m = extensions_count_sorted_length.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                                \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                               value sortWith is not a member of Int\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp9fzzlmr0.scala:26:97 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m  \
    \                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   value sortWith is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9fzzlmr0.scala:27:104\
    \ -----------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_count_sorted_length_sorted_length_sorted_length\e[0m = extensions_count_sorted_length.sortWith(_\
    \ < _)\n\e[31m\e[31m   |\e[0m                                                \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                   value sortWith is not a member of\
    \ Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9fzzlmr0.scala:28:111 -----------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sorted_length_sorted_length_sorted\e\
    [0m = extensions_count_sorted_length.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m  \
    \                                                                            \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                      value sortWith is not a member of Int\n\e"
  stdout: ''
  timestamp: 1659799642
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        val extensions_sorted\
    \ = extensions.sortWith(_.length > _.length)\n        val class_name_sorted =\
    \ extensions_sorted.head\n        val extension_sorted = extensions_sorted.last\n\
    \        val extension_length = extension_sorted.length\n        val extension_strength\
    \ = extension_length - class_name_count\n        if (extension_strength > strength)\
    \ class_name_sorted + extension_sorted else class_name_sorted\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"),\
    \ (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyty5or64.scala:32)\n\tat Problem.main(tmpyty5or64.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799643
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        var strongest_extension\
    \ = \"\"\n        var strongest_extension_strength = -1\n        for(extension\
    \ <- extensions) {\n            val cap = extension.filter(x => x.isUpper).length\n\
    \            val sm = extension.filter(x => x.isLower).length\n            val\
    \ strength = cap - sm\n            if(strength > strongest_extension_strength)\
    \ {\n                strongest_extension_strength = strength\n               \
    \ strongest_extension = extension\n            }\n        }\n        class_name\
    \ + \".\" + strongest_extension\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659799643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n     \
    \   val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.toList\n        val extensions_sorted\
    \ = extensions_sorted.map(x => class_name + x)\n        val extensions_sorted\
    \ = extensions_sorted.sortBy(x => extensions_map.getOrElse(x, 0))\n        extensions_sorted.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4nc5mawt.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4nc5mawt.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4nc5mawt.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36mx\e[0m => class_name + x)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp4nc5mawt.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.sortBy(\e[36mx\e[0m => extensions_map.getOrElse(x, \e[31m0\e\
    [0m))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods mu"
  stdout: ''
  timestamp: 1659799640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val sorted_extensions = extensions_map.toSeq.sortBy(_._2)\n    \
    \    val first_extension = sorted_extensions.head._1\n        val first_extension_strength\
    \ = sorted_extensions.head._2\n        if (strength == 0) first_extension\n  \
    \      else if (strength < first_extension_strength) first_extension\n       \
    \ else first_extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpqvy6l6fo.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1659799641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => extensions_map(a)\
    \ - extensions_map(b))\n        val extensions_sorted = extensions_sorted.map(e\
    \ => class_name + e.toUpperCase.charAt(0).toLowerCase)\n        extensions_sorted.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4rrwca2u.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36me\e[0m => class_name + e.toUpperCase.charAt(\e[31m0\e\
    [0m).toLowerCase)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4rrwca2u.scala:21:100 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e\
    [0m).toLowerCase).toMap\n\e[31m\e[31m   |\e[0m                               \
    \                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4rrwca2u.scala:22:77\
    \ --------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e\
    [0m = extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => extensions_map(a) -\
    \ extensions_map(b))\n\e[31m\e[31m   |\e[0m                                  \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                                        Found:    (a : String)\n\e[31m   |\e\
    [0m                                                  Required: Char\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4rrwca2u.scala:22:97 --------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => extensions_map(a) - extensions_map(b))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                          "
  stdout: ''
  timestamp: 1659799642
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_sorted = extensions_map.toSeq.sortWith((a, b) => a._2\
    \ > b._2)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._1 < b._1)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._2 < b._2)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._1 < b._1)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._2 < b._2)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._1 < b._1)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._2 < b._2)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._1 < b._1)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._2 < b._2)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._1 < b._1)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._2 < b._2)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._1 < b._1)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._2 < b._2)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._1 < b._1)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._2 < b._2)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._1 < b._1)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._2 < b._2)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._1 < b._1)\n        val extensions_sorted = extensions_sorted.toSeq.sortWith((a,\
    \ b) => a._2 < b._2)\n        val extensions_sorted = extensions_sorted.to\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0wmyj9o5.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.toSeq.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => a._1 < b._1)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0wmyj9o5.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.toSeq.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => a._2 < b._2)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0wmyj9o5.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.toSeq.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => a._1 < b._1)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0wmyj9o5.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.toSeq.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => a._2 < b._2)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_s"
  stdout: ''
  timestamp: 1659799644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase).zipWithIndex.toMap\n        val class_name_map\
    \ = class_name.zipWithIndex.toMap\n        val class_name_length = class_name_map.length\n\
    \        val extensions_length = extensions_map.length\n        val strength =\
    \ extensions_map.values.sum\n        val class_name_with_strength = class_name_map\
    \ + (strength -> class_name_length)\n        val extensions_with_strength = extensions_map\
    \ + (strength -> extensions_length)\n        val max_strength = extensions_with_strength.maxBy(_._2)\n\
    \        val max_extension = extensions_with_strength.find(_._2 == max_strength).get._1\n\
    \        val class_name_with_max_strength = class_name_with_strength.filter(_._1\
    \ == max_extension)\n        val extensions_with_max_strength = extensions_with_strength.filter(_._1\
    \ == max_extension)\n        val max_extension_length = extensions_with_max_strength.length\n\
    \        val class_name_with_max_extension = class_name_with_max_strength.map(_._2).mkString(\"\
    .\")\n        val extensions_with_max_extension = extensions_with_max_strength.map(_._2).mkString(\"\
    .\")\n        val max_extension_strength = extensions_with_max_extension.sum\n\
    \        val class_name_with_max_extension_strength = class_name_with_max_extension.concat(\"\
    .\" + max_extension_strength)\n        val extensions_with_max_extension_strength\
    \ = extensions_with_max_extension.concat(\".\" + max_extension_strength)\n   \
    \     val max_extension_strength_length = extensions_with_max_extension_strength.length\n\
    \        val class_name_with_max_extension_strength = class_name_with_max_extension_strength.concat(\"\
    .\" + max_extension_strength)\n        val extensions_with_max_extension_strength\
    \ = extensions_with_max_extension_strength.concat(\".\" + max_extension_strength)\n\
    \        val max_extension_strength_strength_length = extensions_with_max_extension_strength_strength.length\n\
    \        val class_name_with_max_extension_strength_strength = class_name_with_max_extension_strength.concat(\"\
    .\" + max_extension_strength_strength)\n        val extensions_with_max_extension_strength_strength\
    \ = extensions_with_max_extension_strength.concat(\".\" + max_extension_strength_strength)\n\
    \        val max_extension_strength_strength_strength_length = extensions_with_max_extension_strength_strength_strength.length\n\
    \        val class_name_with_max_extension_strength_strength_strength = class_name_with_max_extension_strength_strength.concat(\"\
    .\" + max_extension_strength_strength_strength)\n        val extensions_with_max_extension_strength_strength_strength\
    \ = extensions_with_max_extension_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa2fod3fn.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_max_extension_strength\e\
    [0m = class_name_with_max_extension_strength.concat(\e[31m\".\"\e[0m + max_extension_strength)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclass_name_with_max_extension_strength is already defined\
    \ as \e[33mvalue\e[0m \e[35mclass_name_with_max_extension_strength\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa2fod3fn.scala:40:12 ---------------------------\e[0m\e[0m\n\e[31m40\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_with_max_extension_strength\e\
    [0m = extensions_with_max_extension_strength.concat(\e[31m\".\"\e[0m + max_extension_strength)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_with_max_extension_strength is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_with_max_extension_strength\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpa2fod3fn.scala:23:47 ------------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mclass_name_length\e[0m = class_name_map.length\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          value length is not a member of Map[Char,\
    \ Int]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpa2fod3fn.scala:24:47 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_length\e[0m =\
    \ extensions_map.length\n\e[31m\e[31m   |\e[0m                               \
    \ ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        value length\
    \ is not a member of Map[String, Int]\n\e[31m\e[3"
  stdout: ''
  timestamp: 1659799644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_cap = extensions.map(_.toUpperCase.length).sum -\
    \ extensions.map(_.toLowerCase.length).sum\n        val extensions_count_sm =\
    \ extensions.map(_.toLowerCase.length).sum - extensions.map(_.toUpperCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower - extensions_count_cap\
    \ - extensions_count_sm\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.length)\n        val extensions_sorted = extensions.sortWith((a,\
    \ b) => strength - a.length - b.\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8d89por1.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8d89por1.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m = extensions.sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8d89por1.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8d89por1.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp8d89por1.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e"
  stdout: ''
  timestamp: 1659799645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).max\n    \
    \    val extensions_sorted = extensions_map.values.sortWith((x, y) => strength\
    \ - y)\n        val extensions_sorted_list = extensions_sorted.map(x => class_name\
    \ + x)\n        extensions_sorted_list.head\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe292kvlc.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpe292kvlc.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpe292kvlc.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpe292kvlc.scala:23:78 --------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\e[31m\e[31m   |\e[0m    \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   (x : String)\n\e[31m   |\e[0m                                            \
    \      Required: Nothing\n\e[31"
  stdout: ''
  timestamp: 1659799645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val strength = extensions_count_sorted.last\n        val extensions_count_sorted_sorted\
    \ = extensions_count_sorted.sort\n        val strength_sorted = extensions_count_sorted_sorted.last\n\
    \        val strength_sorted_sorted = extensions_count_sorted_sorted.sort\n  \
    \      val strength_sorted_sorted_sorted = extensions_count_sorted_sorted.sort\n\
    \        val strength_sorted_sorted_sorted_sorted = extensions_count_sorted_sorted.sort\n\
    \        val strength_sorted_sorted_sorted_sorted_sorted = extensions_count_sorted_sorted.sort\n\
    \        val strength_sorted_sorted_sorted_sorted_sorted_sorted = extensions_count_sorted_sorted.sort\n\
    \        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted = extensions_count_sorted_sorted.sort\n\
    \        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted.sort\n        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted.sort\n        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted.sort\n        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted.sort\n        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted.sort\n        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted.sort\n        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted.sort\n        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted.sort\n        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted.sort\n        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted.sort\n        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted.sort\n        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_count_sorted_sorted.sort\n        val strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sor\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkv91av7z.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkv91av7z.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstrength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_count_sorted_sorted.sort\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpkv91av7z.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mstrength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_count_sorted_sorted.sort\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstrength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  strength_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must "
  stdout: ''
  timestamp: 1659799643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val extensions_sorted\
    \ = extensions_map.toSeq.sortBy(_._1).reverse\n        val extensions_sorted =\
    \ extensions_sorted.take(extensions_sorted.length / 2)\n        val extensions_sorted\
    \ = extensions_sorted.map(e => class_name + \".\" + e._1)\n        extensions_sorted.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa3frwlcl.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(extensions_sorted.length / \e[31m2\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpa3frwlcl.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36me\e[0m => class_name + \e[31m\".\"\e[0m + e._1)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmpa3frwlcl.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n3 errors found\n"
  stdout: ''
  timestamp: 1659799643
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_map = extensions_map.toMap\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '_')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '$')\n        val extensions_map = extensions_map.filter(_._2 != '!')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter(_._2 != '-')\n        val extensions_map\
    \ = extensions_map.filter(_._2 != '-')\n        val extensions_map = extensions_map.filter(_._2\
    \ != '-')\n        val extensions_map = extensions_map.filter(_._2 != '-')\n \
    \       val extensions_map = extensions_map.filter\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppaib2hq5.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions_map.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mextensions_map is already defined as \e[33mvalue\e[0m \e[35mextensions_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppaib2hq5.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions_map.filter(_._2\
    \ != \e[31m'_'\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map is already defined as \e[33mvalue\e[0m \e[35mextensions_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppaib2hq5.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions_map.filter(_._2\
    \ != \e[31m'$'\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map is already defined as \e[33mvalue\e[0m \e[35mextensions_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppaib2hq5.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions_map.filter(_._2\
    \ != \e[31m'!'\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map is already defined as \e[33mvalue\e[0m \e[35mextensions_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppaib2hq5.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1659799604
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        val extension\
    \ = extensions.sortWith(_ < _).head\n        val extension_length = extension.length\n\
    \        val class_name_length = class_name.length\n        val strength_length\
    \ = extension_length - class_name_length\n        val strength_fraction = strength\
    \ / extensions_count\n        val extension_class_name = extension.substring(0,\
    \ extension_length)\n        val extension_class_name_count = extension_class_name.length\n\
    \        val extension_class_name_strength = extension_class_name_count - strength_length\n\
    \        val extension_class_name_strength_fraction = extension_class_name_strength\
    \ / extension_class_name_count\n        val extension_class_name_strength_fraction\
    \ = extension_class_name_strength_fraction.toString.toDouble\n        val extension_class_name_strength_fraction\
    \ = extension_class_name_strength_fraction * 100\n        val extension_class_name_strength_fraction\
    \ = extension_class_name_strength_fraction.toInt\n        val extension_class_name_strength_fraction\
    \ = extension_class_name_strength_fraction.toString\n        val extension_class_name_strength_fraction\
    \ = extension_class_name_strength_fraction.substring(0, extension_class_name_strength_fraction.length\
    \ - 1)\n        val extension_class_name_strength_fraction = extension_class_name_strength_fraction\
    \ + extension_class_name\n        val extension_class_name_strength_fraction =\
    \ extension_class_name_strength_fraction + extension_class_name_count\n      \
    \  val extension_class_name_strength_fraction = extension_class_name_strength_fraction\
    \ + extension_class_name_strength\n        val extension_class_name_strength_fraction\
    \ = extension_class_name_strength_fraction + extension_class_name_strength_fraction\n\
    \        val extension_class_name_strength_fraction = extension_class_name_strength_fraction\
    \ + extension_class_name_strength_fraction\n        val extension_class_name_strength_fraction\
    \ = extension_class_name_strength_fraction + extension_class_name_strength_fraction\n\
    \        val extension_class_name_strength_fraction = extension_class_name_strength_fraction\
    \ + extension_class_name_strength_fraction\n        val extension_class_name_strength_fraction\
    \ = extension_class_name_strength_fraction + extension_class_name_strength_fraction\n\
    \        val extension_class_name_strength_fraction = extension_class_name_strength_fraction\
    \ + extension_class_name_strength_fraction\n        val extension_class_name_strength_fraction\
    \ = extension_class_name_strength_fraction + extension_class_name_strength_fraction\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp55atryjp.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_strength_fraction\e\
    [0m = extension_class_name_strength_fraction.toString.toDouble\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_strength_fraction is already defined\
    \ as \e[33mvalue\e[0m \e[35mextension_class_name_strength_fraction\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp55atryjp.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_strength_fraction\e\
    [0m = extension_class_name_strength_fraction * \e[31m100\e[0m\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_strength_fraction is already defined\
    \ as \e[33mvalue\e[0m \e[35mextension_class_name_strength_fraction\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp55atryjp.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_strength_fraction\e\
    [0m = extension_class_name_strength_fraction.toInt\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_strength_fraction is already defined\
    \ as \e[33mvalue\e[0m \e[35mextension_class_name_strength_fraction\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp55atryjp.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_strength_fraction\e\
    [0m = extension_class_name_st"
  stdout: ''
  timestamp: 1659799645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.get(x) - x.toString.toUpperCase.length).toArray\n\
    \        val max_strength = strength.max\n        val max_key = extensions_map.keys.toArray.max\n\
    \        val max_value = extensions_map.values.toArray.max\n        val max_key_value\
    \ = class_name_map.get(max_key)\n        val max_key_value_length = max_key_value.length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_key_value_length + max_key_value_length\n\
    \        val max_key_value_length = max_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmperi8oelt.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length\e[0m\
    \ = max_key_value_length + max_key_value_length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_value_length is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_value_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmperi8oelt.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length\e[0m\
    \ = max_key_value_length + max_key_value_length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_value_length is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_value_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmperi8oelt.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length\e[0m\
    \ = max_key_value_length + max_key_value_length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_value_length is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_value_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmperi8oelt.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length\e[0m\
    \ = max_key_value_length + max_key_value_length\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmax_key_value_length is already defined as \e[33mvalue\e[0m \e\
    [35mmax_key_value_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ me"
  stdout: ''
  timestamp: 1659799648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C') - e.toUpperCase.count(_ == 'D') - e.toUpperCase.count(_\
    \ == 'E') - e.toUpperCase.count(_ == 'F') - e.toUpperCase.count(_ == 'G') - e.toUpperCase.count(_\
    \ == 'H') - e.toUpperCase.count(_ == 'I') - e.toUpperCase.count(_ == 'J') - e.toUpperCase.count(_\
    \ == 'K') - e.toUpperCase.count(_ == 'L') - e.toUpperCase.count(_ == 'M') - e.toUpperCase.count(_\
    \ == 'N') - e.toUpperCase.count(_ == 'O') - e.toUpperCase.count(_ == 'P') - e.toUpperCase.count(_\
    \ == 'Q') - e.toUpperCase.count(_ == 'R') - e.toUpperCase.count(_ == 'S') - e.toUpperCase.count(_\
    \ == 'T') - e.toUpperCase.count(_ == 'U') - e.toUpperCase.count(_ == 'V') - e.toUpperCase.count(_\
    \ == 'W') - e.toUpperCase.count(_ == 'X') - e.toUpperCase.count(_ == 'Y') - e.toUpperCase.count(_\
    \ == 'Z')).toMap\n        val strength = extensions_map.values.max\n        val\
    \ extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n        val extensions_sorted\
    \ = extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\".\")\n        val\
    \ extensions_sorted = extensions_sorted.replaceAll(\"\\\\..*\", \"\")\n      \
    \  class_name + extensions_sorted\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp228m3qau.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp228m3qau.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.replaceAll(\e[31m\"\\\\..*\"\e[0m, \e[31m\"\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmp228m3qau.scala:21:885 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'D'\e[0m) - e.toUpperCase.count(_ == \e[31m'E'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'F'\e[0m) - e.toUpperCase.count(_ == \e[31m'G'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'H'\e[0m) - e.toUpperCase.count(_ == \e[31m'I'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'J'\e[0m) - e.toUpperCase.count(_ == \e[31m'K'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'L'\e[0m) - e.toUpperCase.count(_ == \e[31m'M'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'N'\e[0m) - e.toUpperCase.count(_ == \e[31m'O'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'P'\e[0m) - e.toUpperCase.count(_ == \e[31m'Q'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'R'\e[0m) - e.toUpperCase.count("
  stdout: ''
  timestamp: 1659799647
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val class_name_map = class_name.map(c => c.toUpperCase.charAt(0) -> c.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val strength = extensions_map.values.map(c => class_name_map.get(c) -\
    \ class_name_map.get(c)).reduce(_ + _)\n        val strongest_extension = extensions_map.values.find(c\
    \ => class_name_map.get(c) == strength).getOrElse(\"\")\n        class_name +\
    \ strongest_extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy2fipk5i.scala:21:100 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e\
    [0m).toLowerCase).toMap\n\e[31m\e[31m   |\e[0m                               \
    \                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy2fipk5i.scala:22:51\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mc\e[0m => c.toUpperCase.charAt(\e\
    [31m0\e[0m) -> c.toUpperCase.charAt(\e[31m1\e[0m).toLowerCase).toMap\n\e[31m\e\
    [31m   |\e[0m                                                 ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy2fipk5i.scala:23:110\
    \ -----------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mc\e[0m => class_name_map.get(c)\
    \ - class_name_map.get(c)).reduce(_ + _)\n\e[31m\e[31m   |\e[0m              \
    \                                                                            \
    \                  ^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member of Any, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659799653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.count\n        val extensions_count_upper = extensions.count(_.toUpperCase.size\
    \ == extensions_count)\n        val extensions_count_lower = extensions.count(_.toLowerCase.size\
    \ == extensions_count)\n        val strength = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compareTo(a.compareTo(b)))\n\
    \        val extensions_sorted = extensions.sortWith((a, b) => strength.compare\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9a4i2ca1.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9a4i2ca1.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_sorted\e[0m = extensions.sortWith((\e[36ma\e[0m, \e[36mb\e\
    [0m) => strength.compareTo(a.compareTo(b)))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9a4i2ca1.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength.compareTo(a.compareTo(b)))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9a4i2ca1.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength.compareTo(a.compareTo(b)))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp9a4i2ca1.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        "
  stdout: ''
  timestamp: 1659799653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.count\n        val extensions_count_upper = extensions.count(_.toUpperCase.size\
    \ == extensions_count)\n        val extensions_count_lower = extensions.count(_.toLowerCase.size\
    \ == extensions_count)\n        val extensions_count_cap = extensions.count(_.toUpperCase.size\
    \ == extensions_count_lower)\n        val extensions_count_sm = extensions.count(_.toLowerCase.size\
    \ == extensions_count_upper)\n        val extensions_count_diff = extensions_count_cap\
    \ - extensions_count_sm\n        if (extensions_count_diff == 0) extensions(0)\n\
    \        else if (extensions_count_diff == 1) extensions(1)\n        else if (extensions_count_diff\
    \ == 2) extensions(2)\n        else if (extensions_count_diff == 3) extensions(3)\n\
    \        else if (extensions_count_diff == 4) extensions(4)\n        else if (extensions_count_diff\
    \ == 5) extensions(5)\n        else if (extensions_count_diff == 6) extensions(6)\n\
    \        else if (extensions_count_diff == 7) extensions(7)\n        else if (extensions_count_diff\
    \ == 8) extensions(8)\n        else if (extensions_count_diff == 9) extensions(9)\n\
    \        else if (extensions_count_diff == 10) extensions(10)\n        else if\
    \ (extensions_count_diff == 11) extensions(11)\n        else if (extensions_count_diff\
    \ == 12) extensions(12)\n        else if (extensions_count_diff == 13) extensions(13)\n\
    \        else if (extensions_count_diff == 14) extensions(14)\n        else if\
    \ (extensions_count_diff == 15) extensions(15)\n        else if (extensions_count_diff\
    \ == 16) extensions(16)\n        else if (extensions_count_diff == 17) extensions(17)\n\
    \        else if (extensions_count_diff == 18) extensions(18)\n        else if\
    \ (extensions_count_diff == 19) extensions(19)\n        else if (extensions_count_diff\
    \ == 20) extensions(20)\n        else if (extensions_count_diff == 21) extensions(21)\n\
    \        else if (extensions_count_diff == 22) extensions(22)\n        else if\
    \ (extensions_count_diff == 23) extensions(23)\n        else if (extensions_count_diff\
    \ == 24) extensions(24)\n        else if (extensions_count_diff == 25) extensions(25)\n\
    \        else if (extensions_count_diff == 26) extensions(26)\n        else if\
    \ (extensions_count_diff == 27) extensions(27)\n        else if (extensions_count_diff\
    \ == 28) extensions(28)\n        else if (extensions_count_diff == 29) extensions(29)\n\
    \        else if (extensions_count_diff == 30) extensions(30)\n        else if\
    \ (extensions_count_diff == 31) extensions(31)\n        else if (extensions_count_diff\
    \ == 32) extensions(32)\n        else if (extensions_count_diff == 33) extensions(33)\n\
    \        else if (extensions_count_diff == 34) \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpna071w9l.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    'then' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpna071w9l.scala:22:54\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m22 |\e[0m       \
    \ \e[33mval\e[0m \e[36mextensions_count_upper\e[0m = extensions.count(_.toUpperCase.size\
    \ == extensions_count)\n\e[31m\e[31m   |\e[0m                                \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mValues of types Int and (String => Boolean) => Int cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpna071w9l.scala:23:54 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.count(_.toLowerCase.size == extensions_count)\n\e[31m\e[31m \
    \  |\e[0m                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mValues of types Int and (String => Boolean) => Int cannot\
    \ be compared with == or !=\n3 errors found\n"
  stdout: ''
  timestamp: 1659799653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val class_name_map = class_name.map(c => c.toUpperCase.charAt(0) -> c.toUpperCase.charAt(1).toLowerCase)\n\
    \        val strength = extensions_map.foldLeft(0)((acc, e) => acc + (class_name_map(e._1)\
    \ - class_name_map(e._2)))\n        val strongest_extension = extensions.find(e\
    \ => e.toUpperCase.charAt(0) == class_name_map(strength))\n        strongest_extension\
    \ match {\n            case Some(extension) => extension\n            case None\
    \ => \"\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppfnny1nh.scala:21:100 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m) -> e.toUpperCase.charAt(\e[31m1\e\
    [0m).toLowerCase)\n\e[31m\e[31m   |\e[0m                                     \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppfnny1nh.scala:22:51\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mc\e[0m => c.toUpperCase.charAt(\e\
    [31m0\e[0m) -> c.toUpperCase.charAt(\e[31m1\e[0m).toLowerCase)\n\e[31m\e[31m \
    \  |\e[0m                                                 ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value toUpperCase is not a member\
    \ of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659799653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum = extensions_count_sorted_length.sum\n\
    \        val extensions_count_sorted_length_sum_sorted = extensions_count_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length = extensions_count_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum = extensions_count_sorted_length_sum_sorted_length.sum\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted = extensions_count_sorted_length_sum_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length.sum\n \
    \       val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sorted.sum\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sorted.sum\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sorted.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sorted.sum\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfoeq7q13.scala:38:145 --------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                                                                            \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \       expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpfoeq7q13.scala:26:111 -----------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sum_sorted_length\e\
    [0m = extensions_count_sorted_length_sum_sorted.map(_.length)\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \                                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                               value length is not a member of Int\n\e[31m\e\
    [31m-- Error: /tmp/tmpfoeq7q13.scala:27:119 ----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sum_sorted_length_sum\e\
    [0m = extensions_count_sorted_length_sum_sorted_length.sum\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByteIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mDoubleIsFractional\e[0m in\
    \ \e[33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num\
    \ of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfoeq7q13.scala:28:134 -----------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sum_sorted_length_sum_sorted\e\
    [0m = extensions_count_sorted_leng"
  stdout: ''
  timestamp: 1659799655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n  \
    \      val extensions_sorted = extensions_sorted.takeWhile(_._2 > strength).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.mkString(\"\") + \".\" + extensions_sorted.last\n\
    \        class_name+\".\"+extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfmcoi0ve.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > strength).map(_._1)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpfmcoi0ve.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m) + \e[31m\".\"\e[0m + extensions_sorted.last\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659799650
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extensions_count_upper_lower = extensions.map(_.toUpperCase.toLowerCase.length).sum\n\
    \        val extensions_count_lower_upper = extensions.map(_.toLowerCase.toUpperCase.length).sum\n\
    \        val strength_lower = extensions_count_lower_upper - extensions_count_upper\n\
    \        val strength_upper = extensions_count_upper_lower - extensions_count_lower\n\
    \        val strength_total = strength_lower + strength_upper\n        if (strength_total\
    \ > 0)\n            class_name_upper + extensions_count_upper + extensions_count_lower\
    \ + strength.toString + \".\" + extensions.map(_.toLowerCase).mkString(\".\")\n\
    \        else if (strength_total == 0)\n            class_name_upper + extensions_count_upper\
    \ + extensions_count_lower + strength.toString + \".\" + extensions.map(_.toLowerCase).mkString(\"\
    .\")\n        else if (strength_total == 1)\n            class_name_upper + extensions_count_upper\
    \ + extensions_count_lower + strength.toString + \".\" + extensions.map(_.toLowerCase).mkString(\"\
    .\") + extensions_count_lower_upper + extensions_count_upper.toString + \".\"\
    \ + extensions.map(_.toUpperCase).mkString(\".\")\n        else\n            class_name_upper\
    \ + extensions_count_upper + extensions_count_lower + strength.toString + \".\"\
    \ + extensions.map(_.toLowerCase).mkString(\".\") + extensions_count_lower_upper\
    \ + extensions_count_upper.toString + \".\" + extensions.map(_.toUpperCase).mkString(\"\
    .\")\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplwtainnp.scala:42)\n\tat Problem.main(tmplwtainnp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val class_name_map = class_name.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\
    \        val strength = class_name_map.foldLeft(0) { (s, x) =>\n            val\
    \ cap = x._1.toUpperCase.size\n            val sm = x._2.toUpperCase.size\n  \
    \          val diff = cap - sm\n            if (diff > s) diff else s\n      \
    \  }\n        val extension_strength = extensions_map.foldLeft(0) { (s, x) =>\n\
    \            val cap = x._1.toUpperCase.size\n            val sm = x._2.toUpperCase.size\n\
    \            val diff = cap - sm\n            if (diff > s) diff else s\n    \
    \    }\n        if (extension_strength > strength) class_name else class_name\
    \ + \"_\" + extensions_map.maxBy(_._1)._2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvk49wa1d.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\e[31m\e[31m  \
    \ |\e[0m                                                  ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value toUpperCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvk49wa1d.scala:22:72\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase.size,\
    \ x.toLowerCase.size)).toMap\n\e[31m\e[31m   |\e[0m                          \
    \                                            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toLowerCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpvk49wa1d.scala:24:27 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mcap\e[0m = x._1.toUpperCase.size\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value toUpperCase is not a member of Nothing\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpvk49wa1d.scala:25:26 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36msm\e[0m = x._2.toUpperCase.size\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     value toUpperCase is not a member of Nothing\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpvk49wa1d.scala:30:27 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36mcap\e[0m = x._1.toUpperCase.size\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                      value toUpperCase is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpvk49wa1d.scala:31:26 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m \e[36msm\e[0m = x._2.toUpperCase.size\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                     value t"
  stdout: ''
  timestamp: 1659799655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val strength = extensions_count - class_name_length\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => strength - a.length - b.length)\n        val\
    \ extensions_sorted = extensions_sorted.take(1)\n        val extensions_sorted\
    \ = extensions_sorted.mkString(\".\") + extensions_sorted.last\n        class_name\
    \ + extensions_sorted\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_n6h9ij5.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.take(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_n6h9ij5.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\".\"\e[0m) + extensions_sorted.last\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp_n6h9ij5.scala:24:62 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                                     Found:    Int\n\e[31m   |\e[0m         \
    \                                              Required: Boolean\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1659799653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val class_name_upper = class_name.toUpperCase\n        val class_name_lower\
    \ = class_name.toLowerCase\n        val extension_strength = extensions_count\
    \ - extensions_count_lower - extensions_count_upper\n        val extension_strength_upper\
    \ = extension_strength - extensions_count_lower\n        val extension_strength_lower\
    \ = extension_strength - extensions_count_upper\n        val extension_strength_sum\
    \ = extension_strength_upper + extension_strength_lower\n        val extension_strength_sum_upper\
    \ = extension_strength_sum - extensions_count_lower\n        val extension_strength_sum_lower\
    \ = extension_strength_sum - extensions_count_upper\n        val extension_strength_sum_sum\
    \ = extension_strength_sum_upper + extension_strength_sum_lower\n        val extension_strength_sum_sum_upper\
    \ = extension_strength_sum_sum - extensions_count_lower\n        val extension_strength_sum_sum_lower\
    \ = extension_strength_sum_sum - extensions_count_upper\n        val extension_strength_sum_sum_sum\
    \ = extension_strength_sum_sum_upper + extension_strength_sum_sum_lower\n    \
    \    val extension_strength_sum_sum_sum_upper = extension_strength_sum_sum_sum\
    \ - extensions_count_lower\n        val extension_strength_sum_sum_sum_lower =\
    \ extension_strength_sum_sum_sum - extensions_count_upper\n        val extension_strength_sum_sum_sum_sum\
    \ = extension_strength_sum_sum_sum_upper + extension_strength_sum_sum_sum_lower\n\
    \        val extension_strength_sum_sum_sum_sum_upper = extension_strength_sum_sum_sum_sum\
    \ - extensions_count_lower\n        val extension_strength_sum_sum_sum_sum_lower\
    \ = extension_strength_sum_sum_sum_sum - extensions_count_upper\n        val extension_strength_sum_sum_sum_sum_sum\
    \ = extension_strength_sum_sum_sum_sum_upper + extension_strength_sum_sum_sum_sum_lower\n\
    \        val extension_strength_sum_sum_sum_sum_sum_upper = extension_strength_sum_sum_sum_sum_sum\
    \ - extensions_count_lower\n        val extension_strength_sum_sum_sum_sum_sum_lower\
    \ = extension_strength_sum_sum_sum_sum_sum - extensions_count_upper\n        val\
    \ extension_strength_sum_sum_sum_sum_sum_sum = extension_strength_sum_sum_\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk3kcj4en.scala:45:57 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_sum_sum_sum_sum_sum_sum\e\
    [0m = extension_strength_sum_sum_\n\e[31m\e[31m   |\e[0m                     \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                  Not found: extension_strength_sum_sum_\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk3kcj4en.scala:46:5\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659799654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n     \
    \   val strength = extensions_sorted.head._2 - extensions_sorted.head._1\n   \
    \     val extension = extensions_sorted.head._1\n        val extension_name =\
    \ extensions_sorted.head._2\n        val class_name = class_name.replaceAll(\"\
    [^A-Z]\", \"\")\n        val class_name_with_extension = class_name + \".\" +\
    \ extension_name\n        val class_name_with_extension_with_same_strength = class_name_with_extension\
    \ + extensions_sorted.head._1\n        val class_name_with_extension_with_same_strength_with_same_extension\
    \ = class_name_with_extension_with_same_strength + extensions_sorted.head._2\n\
    \        val class_name_with_extension_with_same_strength_with_same_extension_with_same_extension\
    \ = class_name_with_extension_with_same_strength_with_same_extension + extensions_sorted.head._3\n\
    \        val class_name_with_extension_with_same_strength_with_same_extension_with_same_extension_with_same_extension\
    \ = class_name_with_extension_with_same_strength_with_same_extension_with_same_extension\
    \ + extensions_sorted.head._4\n        val class_name_with_extension_with_same_strength_with_same_extension_with_same_extension_with_same_extension_with_same_extension\
    \ = class_name_with_extension_with_same_strength_with_same_extension_with_same_extension_with_same_extension\
    \ + extensions_sorted.head._5\n        val class_name_with_extension_with_same_strength_with_same_extension_with_same_extension_with_same_extension_with_same_extension_with_same_extension\
    \ = class_name_with_extension_with_same_strength_with_same_extension_with_same_extension_with_same_extension_with_same_extension\
    \ + extensions_sorted.head._6\n        val class_name_with_extension_with_same_strength_with_same_extension_with_same_extension_with_same_extension_with_same_extension_with_same_extension_with_same_extension\
    \ = class_name_with_extension_with_same_strength_with_same_extension_with_same_extension_with_same_extension_with_same_extension_with_same_extension\
    \ + extensions_sorted.head._7\n        val class_name_with_extension_with_same_strength_with_same_extension_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphyyiql8b.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphyyiql8b.scala:26:25\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mclass_name\e[0m = class_name.replaceAll(\e[31m\"[^A-Z]\"\e[0m, \e[31m\"\
    \"\e[0m)\n\e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m\
    \                         Recursive \e[33mvalue\e[0m \e[35mclass_name\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphyyiql8b.scala:36:5\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659799655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_count = extensions_map.size\n        val extensions_count_map\
    \ = extensions_count.toList.map(e => (e, extensions_map.get(e))).toMap\n     \
    \   val extensions_count_sorted = extensions_count_map.toSeq.sortBy(_._1).reverse\n\
    \        val extensions_count_sorted = extensions_count_sorted.take(1).map(_._2)\n\
    \        val extensions_count_sorted = extensions_count_sorted.toList\n      \
    \  val extensions_count_sorted = extensions_count_sorted.sortBy(_._1).reverse\n\
    \        val extensions_count_sorted = extensions_count_sorted.take(1).map(_._2)\n\
    \        val extensions_count_sorted = extensions_count_sorted.toList\n      \
    \  val extensions_count_sorted = extensions_count_sorted.sortBy(_._1).reverse\n\
    \        val extensions_count_sorted = extensions_count_sorted.take(1).map(_._2)\n\
    \        val extensions_count_sorted = extensions_count_sorted.toList\n      \
    \  val extensions_count_sorted = extensions_count_sorted.sortBy(_._1).reverse\n\
    \        val extensions_count_sorted = extensions_count_sorted.take(1).map(_._2)\n\
    \        val extensions_count_sorted = extensions_count_sorted.toList\n      \
    \  val extensions_count_sorted = extensions_count_sorted.sortBy(_._1).reverse\n\
    \        val extensions_count_sorted = extensions_count_sorted.take(1).map(_._2)\n\
    \        val extensions_count_sorted = extensions_count_sorted.toList\n      \
    \  val extensions_count_sorted = extensions_count_sorted.sortBy(_._1).reverse\n\
    \        val extensions_count_sorted = extensions_count_sorted.take(1).map(_._2)\n\
    \        val extensions_count_sorted = extensions_count_sorted.toList\n      \
    \  val extensions_count_sorted = extensions_count_sorted.sortBy(_._1).reverse\n\
    \        val extensions_count_sorted = extensions_count_sorted.take(1).map(_._2)\n\
    \        val extensions_count_sorted = extensions_count_sorted.toList\n      \
    \  val extensions_count_sorted = extensions_count_sorted.sortBy(_._1).reverse\n\
    \        val extensions_count_sorted = extensions_count_sorted.take(1).map(_._2)\n\
    \        val extensions_count_sorted = extensions_count_sorted.toList\n      \
    \  val extensions_count_sorted = extensions_count_sorted.sortBy(_._1).reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_v245tf6.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions_count_sorted.take(\e[31m1\e[0m).map(_._2)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_v245tf6.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions_count_sorted.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_v245tf6.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions_count_sorted.sortBy(_._1).reverse\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_v245tf6.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions_count_sorted.take(\e[31m1\e[0m).map(_._2)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e["
  stdout: ''
  timestamp: 1659799656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase)\n\
    \        val extensions_map = extensions.map(e => (e.toUpperCase.charAt(0).toLowerCase,\
    \ e.toUpperCase.charAt(1).toLowerCase)).toMap\n        val extensions_map = extensions.map(e\
    \ => (e.toUpperCase.charAt(0).toLowerCase, e.toUpperCase.charAt(1).toLowerCase)).toMap\n\
    \        val extensions_map = extensions.map(e => (e.toUpperCase.charAt(0).toLowerCase,\
    \ e.toUpperCase.charAt(1).toLowerCase)).toMap\n        val extensions_map = extensions.map(e\
    \ => (e.toUpperCase.charAt(0).toLowerCase, e.toUpperCase.charAt(1).toLowerCase)).toMap\n\
    \        val extensions_map = extensions.map(e => (e.toUpperCase.charAt(0).toLowerCase,\
    \ e.toUpperCase.charAt(1).toLowerCase)).toMap\n        val extensions_map = extensions.map(e\
    \ => (e.toUpperCase.charAt(0).toLowerCase, e.toUpperCase.charAt(1).toLowerCase)).toMap\n\
    \        val extensions_map = extensions.map(e => (e.toUpperCase.charAt(0).toLowerCase,\
    \ e.toUpperCase.charAt(1).toLowerCase)).toMap\n        val extensions_map = extensions.map(e\
    \ => (e.toUpperCase.charAt(0).toLowerCase, e.toUpperCase.charAt(1).toLowerCase)).toMap\n\
    \        val extensions_map = extensions.map(e => (e.toUpperCase.charAt(0).toLowerCase,\
    \ e.toUpperCase.charAt(1).toLowerCase)).toMap\n        val extensions_map = extensions.map(e\
    \ => (e.toUpperCase.charAt(0).toLowerCase, e.toUpperCase.charAt(1).toLowerCase)).toMap\n\
    \        val extensions_map = extensions.map(e => (e.toUpperCase.charAt(0).toLowerCase,\
    \ e.toUpperCase.charAt(1).toLowerCase)).toMap\n        val extensions_map = extensions.map(e\
    \ => (e.toUpperCase.charAt(0).toLowerCase, e.toUpperCase.charAt(1).toLowerCase)).toMap\n\
    \        val extensions_map = extensions.map(e => (e.toUpperCase.charAt(0).toLowerCase,\
    \ e.toUpperCase.charAt(1).toLowerCase)).toMap\n        val extensions_map = extensions.map(e\
    \ => (e.toUpperCase.charAt(0).toLowerCase, e.toUpperCase.charAt(1).toLowerCase)).toMap\n\
    \        val extensions_map = extensions.map(e => (e.toUpperCase.charAt(0).toLowerCase,\
    \ e.toUpperCase.charAt(1).toLowerCase)).toMap\n        val extensions_map = extensions.map(e\
    \ => (e.toUpperCase.charAt(0).toLowerCase, e.toUpperCase.charAt(1).toLowerCase)).toMap\n\
    \        val extensions_map = extensions.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7n2yxqgi.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7n2yxqgi.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e[36me\e\
    [0m => (e.toUpperCase.charAt(\e[31m0\e[0m).toLowerCase, e.toUpperCase.charAt(\e\
    [31m1\e[0m).toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map is already defined as \e[33mvalue\e[0m \e[35mextensions_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7n2yxqgi.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => (e.toUpperCase.charAt(\e[31m0\e[0m).toLowerCase, e.toUpperCase.charAt(\e\
    [31m1\e[0m).toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map is already defined as \e[33mvalue\e[0m \e[35mextensions_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7n2yxqgi.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => (e.toUpperCase.charAt(\e[31m0\e[0m).toLowerCase, e.toUpperCase.charAt(\e\
    [31m1\e[0m).toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_map is already defined as \e[33mvalue\e[0m \e[35mextensions_map\e\
    [0m\n\e[31m   |\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1659799656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4fqfqpbx.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp4fqfqpbx.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fqfqpbx.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e\
    [31m0\e[0m) - x.toUpperCase.length).max\n\e[31m\e[31m   |\e[0m               \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                                                  Found:    (x : String)\n\
    \e[31m   |\e[0m                                                  Required: Nothing\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4fqfqpbx.scala:24:49\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextension\e\
    [0m = extensions_map.getOrElse(strength, \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                 ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                              Found:    (strength : Int)\n\e\
    [31m   |\e[0m                                              Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659799576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (class_name_map.get(x), x)).maxBy(_._2)._2\n\
    \        val class_name = class_name_map.get(strength)\n        val extension\
    \ = extensions_map.get(strength)\n        class_name + \".\" + extension\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbo3r_k_q.scala:24:25 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name_map.get(strength)\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 Recursive \e[33mvalue\e[0m \e[35mclass_name_map\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val strength_upper = extensions_count_upper - strength\n        val strength_lower\
    \ = extensions_count_lower - strength\n        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n    \
    \    val extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val\
    \ extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val extensions_count_upper\
    \ = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower\
    \ = extensions.map(_.toLowerCase).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n    \
    \    val extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val\
    \ extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val extensions_count_upper\
    \ = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower\
    \ = extensions.map(_.toLowerCase).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n    \
    \    val extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val\
    \ extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val extensions_count_upper\
    \ = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower\
    \ = extensions.\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgvvnggew.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgvvnggew.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper\e[0m = extensions.map(_.toUpperCase).sum\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgvvnggew.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgvvnggew.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper\e\
    [0m = extensions.map(_.toUpperCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgvvnggew.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e["
  stdout: ''
  timestamp: 1659799655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val class_name_map = class_name.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\
    \        val strength = class_name_map.map{case (k, v) => v - extensions_map(k)}.reduce(_\
    \ + _)\n        val strongest_extension = class_name_map.map{case (k, v) => (k,\
    \ v)}\n            .filter{case (k, v) => v == strength}\n            .sortWith(_._1\
    \ < _._1)\n            .map(_._2)\n            .head\n        s\"$class_name.$strongest_extension\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmproyhpxve.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\e[31m\e[31m  \
    \ |\e[0m                                                  ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value toUpperCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmproyhpxve.scala:22:72\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase.size,\
    \ x.toLowerCase.size)).toMap\n\e[31m\e[31m   |\e[0m                          \
    \                                            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toLowerCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmproyhpxve.scala:23:59 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = class_name_map.map{\e\
    [33mcase\e[0m (k, v) => v - extensions_map(k)}.reduce(_ + _)\n\e[31m\e[31m   |\e\
    [0m                                                         ^^^\e[0m\n\e[31m \
    \  |\e[0mvalue - is not a member of Nothing, but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m  import Char.char2float\n\
    \e[31m   |\e[0m  import Char.char2int\n\e[31m   |\e[0m  import Char.char2long\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmproyhpxve.scala:26:13\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mstrongest_extension\e[0m = class_name_map.map{\e[33mcase\e[0m (k, v) => (k,\
    \ v)}\n\e[31m25 |\e[0m            .filter{\e[33mcase\e[0m (k, v"
  stdout: ''
  timestamp: 1659799659
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val class_name_map = class_name.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\
    \        val max_strength = extensions_map.values.max\n        val max_key = extensions_map.keys.max\n\
    \        val max_key_index = extensions_map.keys.indexOf(max_key)\n        val\
    \ max_key_value = extensions_map.values.max\n        val max_key_value_index =\
    \ extensions_map.values.indexOf(max_key_value)\n        val max_key_value_length\
    \ = extensions_map.values.max\n        val max_key_value_length_index = extensions_map.values.indexOf(max_key_value_length)\n\
    \        val max_key_value_length_length = extensions_map.values.max\n       \
    \ val max_key_value_length_length_index = extensions_map.values.indexOf(max_key_value_length_length)\n\
    \        val max_key_value_length_length_length = extensions_map.values.max\n\
    \        val max_key_value_length_length_length_index = extensions_map.values.indexOf(max_key_value_length_length_length)\n\
    \        val max_key_value_length_length_length_length = extensions_map.values.max\n\
    \        val max_key_value_length_length_length_index = extensions_map.values.indexOf(max_key_value_length_length_length_length)\n\
    \        val max_key_value_length_length_length_length = extensions_map.values.max\n\
    \        val max_key_value_length_length_length_index = extensions_map.values.indexOf(max_key_value_length_length_length_length)\n\
    \        val max_key_value_length_length_length_length = extensions_map.values.max\n\
    \        val max_key_value_length_length_length_index = extensions_map.values.indexOf(max_key_value_length_length_length_length)\n\
    \        val max_key_value_length_length_length_length = extensions_map.values.max\n\
    \        val max_key_value_length_length_length_index = extensions_map.values.indexOf(max_key_value_length_length_length_length)\n\
    \        val max_key_value_length_length_length_length = extensions_map.values.max\n\
    \        val max_key_value_length_length_length_index = extensions_map.values.indexOf(max_key_value_length_length_length_length)\n\
    \        val max_key_value_length_length_length_length = extensions_map.values.max\n\
    \        val max_key_value_length_length_length_index = extensions_map.values.indexOf(max_key_value_length_length_length_length)\n\
    \        val max_key_value_length_length_length_length = extensions_map.values.max\n\
    \        val max_key_value_length_length_length_index = extensions_map.values.indexOf(max_key_value_length_length_length_length)\n\
    \        val max_key_value_length_length_length_length = extensions_map.values.max\n\
    \        val max_key_value_length_length_length_index = extensions_map.values.indexOf(max_key_value_length_length_length_length)\n\
    \        val max_key_value_length_length_length_length = extensions_map.values.max\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpqi8k_eh_.scala:51:11 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpqi8k_eh_.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length_length_length_index\e\
    [0m = extensions_map.values.indexOf(max_key_value_length_length_length_length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key_value_length_length_length_index is already defined\
    \ as \e[33mvalue\e[0m \e[35mmax_key_value_length_length_length_index\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqi8k_eh_.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length_length_length_length\e\
    [0m = extensions_map.values.max\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key_value_length_length_length_length is already defined\
    \ as \e[33mvalue\e[0m \e[35mmax_key_value_length_length_length_length\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqi8k_eh_.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mmax_key_value_length_length_length_index\e\
    [0m = extensions_map.values.indexOf(max_key_value_length_length_length_length)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmax_key_value_length_length_length_index is already defined\
    \ as \e[33mvalue\e[0m \e[35mma"
  stdout: ''
  timestamp: 1659799657
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val sorted_extensions = extensions_map.toSeq.sortBy(_._2).reverse\n\
    \        val extension = sorted_extensions.find(e => e._2 == strength).getOrElse(\"\
    \")\n        class_name + extension\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpndafe284.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n1 error found\n"
  stdout: ''
  timestamp: 1659799656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).max\n    \
    \    val extensions_sorted = extensions_map.values.sortBy(x => x - class_name_map.get(x))\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(x => x <= strength).mkString(\"\
    \")\n        class_name + \".\" + extensions_sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"\
    tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxh8hicex.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x <= strength).mkString(\e[31m\"\
    \"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpxh8hicex.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpxh8hicex.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxh8hicex.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |"
  stdout: ''
  timestamp: 1659799659
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase.size, e.toLowerCase.size)).toMap\n    \
    \    val class_name_map = class_name.map(c => (c.toUpperCase.size, c.toLowerCase.size)).toMap\n\
    \        val max_strength = extensions_map.values.max\n        val max_key = extensions_map.keys.max\n\
    \        val max_key_index = extensions_map.keys.indexOf(max_key)\n        val\
    \ max_key_value = extensions_map.get(max_key)\n        val max_key_key_index =\
    \ class_name_map.keys.indexOf(max_key_value)\n        val max_key_class_name =\
    \ class_name_map.get(max_key_value)\n        val max_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name)\n        val max_key_class_name_key_value\
    \ = extensions_map.get(max_key_class_name)\n        val max_key_class_name_key_key_index\
    \ = class_name_map.keys.indexOf(max_key_class_name_key_value)\n        val max_key_class_name_key_class_name\
    \ = class_name_map.get(max_key_class_name_key_value)\n        val max_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name_key_class_name)\n        val\
    \ max_key_class_name_key_class_name_key_value = extensions_map.get(max_key_class_name_key_class_name)\n\
    \        val max_key_class_name_key_class_name_key_key_index = class_name_map.keys.indexOf(max_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_index = extensions_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_value)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_key_index =\
    \ class_name_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_class_name_key_index)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_index)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_index)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_index)\n\
    \        val max_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_class_name_key_index\
    \ = extensions_map.keys.indexOf(max_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp28aw3cah.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp28aw3cah.scala:22:52\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mc\e[0m => (c.toUpperCase.size,\
    \ c.toLowerCase.size)).toMap\n\e[31m\e[31m   |\e[0m                          \
    \                        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \              value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp28aw3cah.scala:22:72 ------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mc\e[0m => (c.toUpperCase.size, c.toLowerCase.size)).toMap\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \ ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value toLowerCase\
    \ is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp28aw3cah.scala:25:48\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mmax_key_index\e[0m = extensions_map.keys.indexOf(max_key)\n\e[31m\e[31m  \
    \ |\e[0m                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                          value indexOf is not a member of Iterable[Int]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp28aw3cah.scala:27:52 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmax_key_key_index\e[0m =\
    \ class_name_map.keys.indexOf(max_key_value)\n\e[31m\e[31m   |\e[0m          \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 value indexOf is not a member of Iterable[Nothing]\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp28aw3cah.scala:28:52 --------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmax_key_class_name\e[0m\
    \ = class_name_map.get(max_key_value)\n\e[31m\e[31m   |\e[0m                 \
    \                                   ^^^^^^^^^^^^^\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659799661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val strength = extensions_count_sorted.last.toDouble / extensions_count.toDouble\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val extensions_count_sorted = extensions.map(_.length).sort\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val extensions_count_sorted = extensions.map(_.length).sort\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val extensions_count_sorted = extensions.map(_.length).sort\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val extensions_count_sorted = extensions.map(_.length).sort\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val extensions_count_sorted = extensions.map(_.length).sort\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val extensions_count_sorted = extensions.map(_.length).sort\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val extensions_count_sorted = extensions.map(_.length).sort\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val extensions_count_sorted = extensions.map(_.length).sort\n        val extensions_count_sorted\
    \ = extensions.map(_.length).sort\n        val extensions_count_sorted = extensions.map(_.length).sort\n\
    \        val extensions_count_sorted = extensions.map(_.length).sort\n       \
    \ val extensions_\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk8h8z4sv.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk8h8z4sv.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_sorted\e[0m = extensions.map(_.length).sort\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk8h8z4sv.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions.map(_.length).sort\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk8h8z4sv.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions.map(_.length).sort\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk8h8z4sv.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted\e\
    [0m = extensions.map(_.length).sort\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_"
  stdout: ''
  timestamp: 1659799659
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        var extensions_count\
    \ = extensions.length\n        var strongest_extension = \"\"\n        var strongest_extension_strength\
    \ = -1\n        var class_name_length = class_name.length\n        for(i <- 0\
    \ until extensions_count) {\n            var extension = extensions(i)\n     \
    \       var extension_length = extension.length\n            var extension_strength\
    \ = extension_length - class_name_length\n            if(extension_strength >\
    \ strongest_extension_strength) {\n                strongest_extension_strength\
    \ = extension_strength\n                strongest_extension = extension\n    \
    \        }\n        }\n        return class_name + \".\" + strongest_extension\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbhpgte_h.scala:39)\n\tat Problem.main(tmpbhpgte_h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799659
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size, x)).toMap\n \
    \       val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n\
    \        val extensions_sorted = extensions_map.values.sortBy(x => x)\n      \
    \  val extensions_sorted = extensions_sorted.takeWhile(x => x < strength)\n  \
    \      val extensions_sorted = extensions_sorted.map(x => extensions_map(x._2))\n\
    \        val extensions_sorted = extensions_sorted.mkString(\"\")\n        class_name\
    \ + extensions_sorted\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpk89v_tfo.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x < strength)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk89v_tfo.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36mx\e[0m => extensions_map(x._2))\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpk89v_tfo.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- Error: /tmp/tmpk89v_tfo.scala:21:99 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36mx\e[0m => (x.toUpperCase.size, x.toLowerCase.size, x)).toMap\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                ^\e[0m\n\e[31m   |\e[0m                     \
    \    Cannot prove that (Int, Int, String) <:< (K, V)\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m     "
  stdout: ''
  timestamp: 1659799659
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_sorted = extensions.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length = extensions_count_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum = extensions_count_sorted_length.sum\n\
    \        val extensions_count_sorted_length_sum_sorted = extensions_count_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length = extensions_count_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum = extensions_count_sorted_length_sum_sorted_length.sum\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted = extensions_count_sorted_length_sum_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length.sum\n \
    \       val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length.sum\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length.sortWith(_\
    \ < _)\n        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum\
    \ = extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sorted.map(_.length)\n\
    \        val extensions_count_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted_length_sum_sorted\
    \ = extensions_count_sorted_length_sum_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpej4165yx.scala:26:111 -----------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sum_sorted_length\e\
    [0m = extensions_count_sorted_length_sum_sorted.map(_.length)\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \                                        ^^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                               value length is not a member of Int\n\e[31m\e\
    [31m-- Error: /tmp/tmpej4165yx.scala:27:119 ----------------------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sum_sorted_length_sum\e\
    [0m = extensions_count_sorted_length_sum_sorted_length.sum\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                             ^\e[0m\n\e[31m   |\e[0mambiguous\
    \ given instances: both \e[33mobject\e[0m \e[35mByteIsIntegral\e[0m in \e[33mobject\e\
    [0m \e[35mNumeric\e[0m and \e[33mobject\e[0m \e[35mFloatIsFractional\e[0m in \e\
    [33mobject\e[0m \e[35mNumeric\e[0m match type Numeric[B] of parameter num of \e\
    [33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpej4165yx.scala:28:134 -----------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_sorted_length_sum_sorted_length_sum_sorted\e\
    [0m = extensions_count_sorted_length_sum_sorted_length.sortWith(_ < _)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                    ^^^\e[0m\n\
    \e[31m   |\e[0mvalue < is not a member of Nothing, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Byte.byte2double\n\
    \e[31m   |\e[0m  import Byte.byte2float\n\e[31m   |\e[0m  import Byte.byte2int\n\
    \e[31m   |\e[0m  import Byte.byte2long\n\e[31m   |\e[0m  import Byte.byte2short\n\
    \e[31m   |\e[0m  import Char.char2double\n\e[31m   |\e[0m "
  stdout: ''
  timestamp: 1659799664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.values.max\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n \
    \       val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7jsus3fv.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp7jsus3fv.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m = extensions_sorted.takeWhile(_._2\
    \ > \e[31m0\e[0m).map(_._1).mkString(\e[31m\".\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7jsus3fv.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7jsus3fv.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp7jsus3fv.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e"
  stdout: ''
  timestamp: 1659799663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.foldLeft(0)((acc, x) => acc + (class_name_map(x._1) - class_name_map(x._2)))\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(x => x._2).reverse\n\
    \        val extension_strength = extensions_sorted.head._2\n        val extension_class\
    \ = extensions_sorted.head._1\n        val extension_class_name = extension_class.replaceAll(\"\
    [A-Z]\", \"_$extension_strength\")\n        val extension_class_name_sorted =\
    \ extension_class_name.split(\"_\").sortBy(x => x.toUpperCase).reverse\n     \
    \   val extension_class_name_first = extension_class_name_sorted.head\n      \
    \  val extension_class_name_last = extension_class_name_sorted.last\n        val\
    \ extension_class_name_first = extension_class_name_first.replaceAll(\"[A-Z]\"\
    , \"_$strength\")\n        val extension_class_name_last = extension_class_name_last.replaceAll(\"\
    [A-Z]\", \"_$strength\")\n        val extension_class_name_first = extension_class_name_first.replaceAll(\"\
    [a-z]\", \"_$strength\")\n        val extension_class_name_last = extension_class_name_last.replaceAll(\"\
    [a-z]\", \"_$strength\")\n        val extension_class_name_first = extension_class_name_first.replaceAll(\"\
    [0-9]\", \"_$strength\")\n        val extension_class_name_last = extension_class_name_last.replaceAll(\"\
    [0-9]\", \"_$strength\")\n        val extension_class_name_first = extension_class_name_first.replaceAll(\"\
    \\\\W\", \"_$strength\")\n        val extension_class_name_last = extension_class_name_last.replaceAll(\"\
    \\\\W\", \"_$strength\")\n        val extension_class_name_first = extension_class_name_first.replaceAll(\"\
    \\\\s\", \"_$strength\")\n        val extension_class_name_last = extension_class_name_last.replaceAll(\"\
    \\\\s\", \"_$strength\")\n        val extension_class_name_first = extension_class_name_first.replaceAll(\"\
    \\\\W\", \"_$strength\")\n        val extension_class_name_last = extension_class_name_last.replaceAll(\"\
    \\\\W\", \"_$strength\")\n        val extension_class_name_first = extension_class_name_first.replaceAll(\"\
    \\\\s\", \"_$strength\")\n        val extension_class_name_last = extension_class_name_last.replaceAll(\"\
    \\\\s\", \"_$strength\")\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo9dwyzs8.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_first\e\
    [0m = extension_class_name_first.replaceAll(\e[31m\"[A-Z]\"\e[0m, \e[31m\"_$strength\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_first is already defined as \e[33mvalue\e\
    [0m \e[35mextension_class_name_first\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo9dwyzs8.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_last\e\
    [0m = extension_class_name_last.replaceAll(\e[31m\"[A-Z]\"\e[0m, \e[31m\"_$strength\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_last is already defined as \e[33mvalue\e\
    [0m \e[35mextension_class_name_last\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo9dwyzs8.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_first\e\
    [0m = extension_class_name_first.replaceAll(\e[31m\"[a-z]\"\e[0m, \e[31m\"_$strength\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_first is already defined as \e[33mvalue\e\
    [0m \e[35mextension_class_name_first\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpo9dwyzs8.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_last\e\
    [0m = extension_class_name_last.replaceAll(\e[31m\"[a-z]\"\e[0m, \e[31m\"_$streng"
  stdout: ''
  timestamp: 1659799667
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).max\n    \
    \    val extensions_sorted = extensions_map.values.sortBy(x => -x)\n        val\
    \ extensions_sorted = extensions_sorted.takeWhile(x => x < strength).mkString(\"\
    .\")\n        class_name + extensions_sorted\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpull_un6f.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(\e[36mx\e[0m => x < strength).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpull_un6f.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpull_un6f.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpull_un6f.scala:23:57\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x - class_name_map.get(x)).abs).max\n\
    \e[31m\e[31m   |\e[0m                                                       ^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |"
  stdout: ''
  timestamp: 1659799668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.getOrElse(x, 0) - x.toString.toString.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpu2bivpiz.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpu2bivpiz.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu2bivpiz.scala:23:79\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.getOrElse(x, \e\
    [31m0\e[0m) - x.toString.toString.toUpperCase.length).max\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \     ^\e[0m\n\e[31m   |\e[0m                                                \
    \  Found:    (x : String)\n\e[31m   |\e[0m                                   \
    \               Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpu2bivpiz.scala:24:49 --------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mextension\e[0m = extensions_map.getOrElse(strength,\
    \ \e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                                    \
    \             ^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \             Found:    (strength : Int)\n\e[31m   |\e[0m                    \
    \                          Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659799666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_upper - extensions_count_diff\n\
    \        val extensions_count_diff_lower = extensions_count_lower - extensions_count_diff\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper -\
    \ extensions_count_diff_lower\n        val extensions_count_diff_diff_lower =\
    \ extensions_count_diff_lower - extensions_count_diff_upper\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper - extensions_count_diff_diff_lower\n    \
    \    val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_lower\
    \ - extensions_count_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper - extensions_count_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_upper\n        val\
    \ extensions_count_diff_diff_diff_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_l4q23v8.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_l4q23v8.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_upper is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_upper\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_l4q23v8.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_l4q23v8.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659799573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_cap = extensions.map(_.toUpperCase.length).sum -\
    \ extensions.map(_.toLowerCase.length).sum\n        val extensions_count_sm =\
    \ extensions.map(_.toLowerCase.length).sum - extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_frac = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_frac_cap = extensions_count_upper - extensions_count_cap\n\
    \        val extensions_count_frac_sm = extensions_count_lower - extensions_count_sm\n\
    \        val extensions_count_frac_frac = extensions_count_frac_cap - extensions_count_frac_sm\n\
    \        val extensions_count_frac_frac_frac = extensions_count_frac_frac_frac\
    \ / extensions_count_frac_frac\n        val extensions_count_frac_frac_frac_frac\
    \ = extensions_count_frac_frac_frac_frac / extensions_count_frac_frac\n      \
    \  val extensions_count_frac_frac_frac_frac_frac = extensions_count_frac_frac_frac_frac_frac\
    \ / extensions_count_frac_frac\n        val extensions_count_frac_frac_frac_frac_frac_frac\
    \ = extensions_count_frac_frac_frac_frac_frac_frac / extensions_count_frac_frac\n\
    \        val extensions_count_frac_frac_frac_frac_frac_frac_frac = extensions_count_frac_frac_frac_frac_frac_frac_frac\
    \ / extensions_count_frac_frac\n        val extensions_count_frac_frac_frac_frac_frac_frac_frac_frac_frac\
    \ = extensions_count_frac_frac_frac_frac_frac_frac_frac_frac_frac / extensions_count_frac_frac\n\
    \        val extensions_count_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac\
    \ = extensions_count_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac / extensions_count_frac_frac\n\
    \        val extensions_count_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac\
    \ = extensions_count_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_frac_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_tqvfve_.scala:30:46 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_frac_frac_frac\e\
    [0m = extensions_count_frac_frac_frac / extensions_count_frac_frac\n\e[31m\e[31m\
    \   |\e[0m                                              ^\e[0m\n\e[31m   |\e[0m\
    \              Recursive \e[33mvalue\e[0m \e[35mextensions_count_frac_frac_frac\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_tqvfve_.scala:31:51\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_frac_frac_frac_frac\e[0m = extensions_count_frac_frac_frac_frac\
    \ / extensions_count_frac_frac\n\e[31m\e[31m   |\e[0m                        \
    \                           ^\e[0m\n\e[31m   |\e[0m         Recursive \e[33mvalue\e\
    [0m \e[35mextensions_count_frac_frac_frac_frac\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_tqvfve_.scala:32:56 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_frac_frac_frac_frac_frac\e\
    [0m = extensions_count_frac_frac_frac_frac_frac / extensions_count_frac_frac\n\
    \e[31m\e[31m   |\e[0m                                                        ^\e\
    [0m\n\e[31m   |\e[0m    Recursive \e[33mvalue\e[0m \e[35mextensions_count_frac_frac_frac_frac_frac\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_tqvfve_.scala:33:61\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_frac_frac_frac_frac_frac_frac\e[0m = extensions_count_frac_frac_frac_frac_frac_frac\
    \ / extensions_count_frac_frac\n\e[31m\e[31m   |\e[0m                        \
    \                                     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mextensions_count_frac_frac_frac_frac_frac_frac\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation av"
  stdout: ''
  timestamp: 1659799666
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val class_name_map = class_name.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\
    \        val max_extension_strength = extensions_map.values.max\n        val max_class_name_strength\
    \ = class_name_map.values.max\n        val max_extension_strength_pair = extensions_map.maxBy(x\
    \ => x._1)\n        val max_class_name_strength_pair = class_name_map.maxBy(x\
    \ => x._1)\n        val max_extension_strength_pair_str = max_extension_strength_pair._1.toString.replaceAll(\"\
    (.)\", \"$1\")\n        val max_class_name_strength_pair_str = max_class_name_strength_pair._1.toString.replaceAll(\"\
    (.)\", \"$1\")\n        val max_extension_strength_pair_str_with_extension = max_extension_strength_pair_str\
    \ + \".\" + max_extension_strength_pair._2\n        val max_class_name_strength_pair_str_with_extension\
    \ = max_class_name_strength_pair_str + \".\" + max_class_name_strength_pair._2\n\
    \        val max_extension_strength_pair_str_with_extension_with_slash = max_extension_strength_pair_str_with_extension.replaceAll(\"\
    (.)\", \"$1/\")\n        val max_class_name_strength_pair_str_with_extension_with_slash\
    \ = max_class_name_strength_pair_str_with_extension.replaceAll(\"(.)\", \"$1/\"\
    )\n        val max_extension_strength_pair_str_with_extension_with_slash_with_slash\
    \ = max_extension_strength_pair_str_with_extension_with_slash.replaceAll(\"(.)\"\
    , \"$1/\")\n        val max_class_name_strength_pair_str_with_extension_with_slash_with_slash\
    \ = max_class_name_strength_pair_str_with_extension_with_slash.replaceAll(\"(.)\"\
    , \"$1/\")\n        val max_extension_strength_pair_str_with_extension_with_slash_with_slash_with_slash\
    \ = max_extension_strength_pair_str_with_extension_with_slash_with_slash.replaceAll(\"\
    (.)\", \"$1/\")\n        val max_class_name_strength_pair_str_with_extension_with_slash_with_slash_with_slash\
    \ = max_class_name_strength_pair_str_with_extension_with_slash_with_slash.replaceAll(\"\
    (.)\", \"$1/\")\n        val max_extension_strength_pair_str_with_extension_with_slash_with_slash_with_slash_with_slash\
    \ = max_\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0vpn4qjc.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n\e[31m\e[31m  \
    \ |\e[0m                                                  ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value toUpperCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp0vpn4qjc.scala:22:72\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase.size,\
    \ x.toLowerCase.size)).toMap\n\e[31m\e[31m   |\e[0m                          \
    \                                            ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toLowerCase is not a member of Char\n\e\
    [31m\e[31m-- Error: /tmp/tmp0vpn4qjc.scala:24:63 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmax_class_name_strength\e\
    [0m = class_name_map.values.max\n\e[31m\e[31m   |\e[0m                       \
    \                                        ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter ord of \e[33mmethod\e[0m \e[35mmax\e[0m\
    \ in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- Error: /tmp/tmp0vpn4qjc.scala:26:74\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m26 |\e[0m       \
    \ \e[33mval\e[0m \e[36mmax_class_name_strength_pair\e[0m = class_name_map.maxBy(\e\
    [36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m                                   \
    \                                       ^\e[0m\n\e[31m   |\e[0mambiguous given\
    \ instances: both \e[33mobject\e[0m \e[35mInt\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m and \e[33mobject\e[0m \e[35mChar\e[0m in \e[33mobject\e[0m \e[35mOrdering\e\
    [0m match type Ordering[B] of parameter cmp of \e[33mmethod\e[0m \e[35mmaxBy\e\
    [0m in \e[33mtrait\e[0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- [E006] Not"
  stdout: ''
  timestamp: 1659799668
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.filter(_._2.length == class_name_map.filter(_._2.length).map(_._2.length).max)\n\
    \        val extension = strength.map(_._1).mkString.toLowerCase\n        val\
    \ class_name = class_name_map.filter(_._2.length == extensions_map.filter(_._2.length).map(_._2.length).max).map(_._1).mkString.toLowerCase\n\
    \        class_name + \".\" + extension\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp46m2aurv.scala:25:25 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name_map.filter(_._2.length\
    \ == extensions_map.filter(_._2.length).map(_._2.length).max).map(_._1).mkString.toLowerCase\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 Recursive \e[33mvalue\e[0m \e[35mclass_name_map\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase.size, e.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => if (a > b) a else b)\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n \
    \       val extension_strength = extensions_sorted.head._2\n        val extension_class\
    \ = extensions_sorted.head._1\n        val extension_class_name = extension_class.replaceAll(\"\
    \\\\W\", \"\")\n        val extension_class_name_sorted = extension_class_name.split(\"\
    \\\\W\").sortBy(_._1).reverse\n        val extension_class_name_strength = extension_class_name_sorted.head._2\n\
    \        val extension_class_name_sorted = extension_class_name_sorted.head._1\n\
    \        val extension_class_name_strength = extension_class_name_strength.replaceAll(\"\
    \\\\W\", \"\")\n        val extension_class_name_strength_sorted = extension_class_name_strength.split(\"\
    \\\\W\").sortBy(_._1).reverse\n        val extension_class_name_strength_sorted\
    \ = extension_class_name_strength_sorted.head._2\n        val extension_class_name_strength_sorted\
    \ = extension_class_name_strength_sorted.head._1\n        val extension_class_name_strength_sorted\
    \ = extension_class_name_strength_sorted.replaceAll(\"\\\\W\", \"\")\n       \
    \ val extension_class_name_strength_sorted = extension_class_name_strength_sorted.split(\"\
    \\\\W\").sortBy(_._1).reverse\n        val extension_class_name_strength_sorted\
    \ = extension_class_name_strength_sorted.head._2\n        val extension_class_name_strength_sorted\
    \ = extension_class_name_strength_sorted.head._1\n        val extension_class_name_strength_sorted\
    \ = extension_class_name_strength_sorted.replaceAll(\"\\\\W\", \"\")\n       \
    \ val extension_class_name_strength_sorted = extension_class_name_strength_sorted.split(\"\
    \\\\W\").sortBy(_._1).reverse\n        val extension_class_name_strength_sorted\
    \ = extension_class_name_strength_sorted.head._2\n        val extension_class_name_strength_sorted\
    \ = extension_class_name_strength_sorted.head._1\n        val extension_class_name_strength_sorted\
    \ = extension_class_name_strength_sorted.replaceAll(\"\\\\W\", \"\")\n       \
    \ val extension_class_name_strength_sorted = extension_class_name_strength_sorted.split(\"\
    \\\\W\").sortBy(_._1).reverse\n        val extension_class_name_strength_\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpca6npgy8.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpca6npgy8.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextension_class_name_sorted\e[0m = extension_class_name_sorted.head._1\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextension_class_name_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpca6npgy8.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_strength\e\
    [0m = extension_class_name_strength.replaceAll(\e[31m\"\\\\W\"\e[0m, \e[31m\"\"\
    \e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_strength is already defined as \e[33mvalue\e\
    [0m \e[35mextension_class_name_strength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpca6npgy8.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mextension_class_name_strength_sorted\e\
    [0m = extension_class_name_strength_sorted.head._2\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_strength_sorted is already defined as\
    \ \e[33mvalue\e[0m \e[35mextension_class_name_strength_sorted\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpca6npgy8.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e["
  stdout: ''
  timestamp: 1659799668
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        var extension_strength\
    \ = extensions.length\n        var strongest_extension = \"\"\n        extensions.foreach(extension\
    \ => {\n            val cap = extension.length\n            val sm = extension.toUpperCase.length\n\
    \            val strength = cap - sm\n            if (extension_strength > strength)\
    \ {\n                extension_strength = strength\n                strongest_extension\
    \ = extension\n            }\n        })\n        class_name + \".\" + strongest_extension\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphvppx59u.scala:35)\n\tat Problem.main(tmphvppx59u.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659799669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => strength - a.length - b.length)\n        val\
    \ extension_first = extensions_sorted.head\n        val extension_last = extensions_sorted.last\n\
    \        val extension_first_length = extension_first.length\n        val extension_last_length\
    \ = extension_last.length\n        val extension_first_first_letter = extension_first(extension_first_length\
    \ - 1)\n        val extension_last_last_letter = extension_last(extension_last_length\
    \ - 1)\n        val extension_first_last_letter = extension_first(extension_first_length\
    \ - 1)\n        val extension_last_first_letter = extension_last(extension_last_length\
    \ - 1)\n        val extension_first_first_letter_upper = extension_first_first_letter.toUpperCase\n\
    \        val extension_last_last_letter_upper = extension_last_last_letter.toUpperCase\n\
    \        val extension_first_last_letter_upper = extension_first_last_letter.toUpperCase\n\
    \        val extension_last_first_letter_upper = extension_last_first_letter.toUpperCase\n\
    \        val extension_first_first_letter_lower = extension_first_first_letter.toLowerCase\n\
    \        val extension_last_last_letter_lower = extension_last_last_letter.toLowerCase\n\
    \        val extension_first_last_letter_lower = extension_first_last_letter.toLowerCase\n\
    \        val extension_last_first_letter_lower = extension_last_first_letter.toLowerCase\n\
    \        val extension_first_first_letter_upper = extension_first_first_letter.toUpperCase\n\
    \        val extension_last_last_letter_upper = extension_last_last_letter.toUpperCase\n\
    \        val extension_first_last_letter_upper = extension_first_last_letter.toUpperCase\n\
    \        val extension_last_first_letter_upper = extension_last_first_letter.toUpperCase\n\
    \        val extension_first_first_letter_lower = extension_first_first_letter.toLowerCase\n\
    \        val extension_last_last_letter_lower = extension_last_last_letter.toLowerCase\n\
    \        val extension_first_last_letter_lower = extension_first_last_letter.toLowerCase\n\
    \        val extension_last_first_letter_lower = extension_last_first_letter.toLowerCase\n\
    \        val extension_first_first_letter_upper = extension_first_first_letter.toUpperCase\n\
    \        val extension_last_last_letter_upper = extension_last_last_letter.toUpperCase\n\
    \        val extension_first_last_letter_upper = extension_first_last_letter.toUpperCase\n\
    \        val extension_last_first_letter_upper = extension_last_first_letter.toUpperCase\n\
    \        val extension_first_first_letter_lower = extension_first_first_letter.toLowerCase\n\
    \        val extension_last_last_letter_low\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpovxujats.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpovxujats.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextension_first_first_letter_upper\e[0m = extension_first_first_letter.toUpperCase\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_first_first_letter_upper is already defined as \e\
    [33mvalue\e[0m \e[35mextension_first_first_letter_upper\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpovxujats.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextension_last_last_letter_upper\e[0m = extension_last_last_letter.toUpperCase\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_last_last_letter_upper is already defined as \e\
    [33mvalue\e[0m \e[35mextension_last_last_letter_upper\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpovxujats.scala:43:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextension_first_last_letter_upper\e[0m = extension_first_last_letter.toUpperCase\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_first_last_letter_upper is already defined as \e\
    [33mvalue\e[0m \e[35mextension_first_last_letter_upper\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpovxujats.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36m"
  stdout: ''
  timestamp: 1659799670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x,\
    \ y) => math.max(x, y))\n        val class_name_with_strength = class_name_map.values.map(x\
    \ => (x.toUpperCase, x.toLowerCase)).foldLeft(0)((x, y) => math.max(x, y))\n \
    \       val strength_of_extension = class_name_with_strength.foldLeft(0)((x, y)\
    \ => math.max(x, y))\n        val strongest_extension = extensions_map.values.filter(x\
    \ => x == strength).head\n        class_name_with_strength.foldLeft(strongest_extension)((x,\
    \ y) => x + \".\" + y)\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpglqiy8pd.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpglqiy8pd.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpglqiy8pd.scala:23:113\
    \ ----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m => (x.toUpperCase,\
    \ x.toLowerCase)).foldLeft(\e[31m0\e[0m)((\e[36mx\e[0m, \e[36my\e[0m) => math.max(x,\
    \ y))\n\e[31m\e[31m   |\e[0m                                                 \
    \                                                           ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mmax\e\
    [0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double, y: Double): Double\n\e[31m   |\e[0m (x: Float, y: Float): Float\n\e\
    [31m   |\e[0m (x: Long, y: Long): Long\n\e[31m   |\e[0m (x: Int, y: Int): Int\n\
    \e[31m   |\e[0mmatch arguments ((x : Int), (y : (String, String)))\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpglqiy8pd.scala:24:73 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mclass_name_with_strength\e\
    [0m = class_name_map.values.map(\e[36mx\e[0m => (x.toUpperCase, x.toLowerCase)).foldLeft(\e\
    [31m0\e[0m)((\e[36mx\e[0m, \e[36my\e[0m) => math.max(x, y))\n\e[31m\e[31m   |\e\
    [0m                                                                       ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                       "
  stdout: ''
  timestamp: 1659799671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n\
    \        val extension_first = extensions_sorted.head\n        val extension_last\
    \ = extensions_sorted.last\n        val extension_strength = extension_first._1\
    \ - extension_last._1\n        val extension_first = extension_first._2\n    \
    \    val extension_last = extension_last._2\n        val extension_strength_str\
    \ = extension_strength.toString\n        val extension_first = extension_first.toString\n\
    \        val extension_last = extension_last.toString\n        val extension_strength_str_first\
    \ = extension_strength_str.substring(0, 1)\n        val extension_strength_str_last\
    \ = extension_strength_str.substring(1, 2)\n        val extension_strength_str_first_last\
    \ = extension_strength_str_first + extension_strength_str_last\n        val extension_strength_str_first_last_str\
    \ = extension_strength_str_first_last + extension_strength_str\n        val extension_strength_str_first_last_str_first\
    \ = extension_strength_str_first_last_str.substring(0, 1)\n        val extension_strength_str_first_last_str_last\
    \ = extension_strength_str_first_last_str.substring(1, 2)\n        val extension_strength_str_first_last_str_first_last\
    \ = extension_strength_str_first_last_str_first + extension_strength_str_first_last_str_last\n\
    \        val extension_strength_str_first_last_str_first_last_str = extension_strength_str_first_last_str_first_last\
    \ + extension_strength_str_first_last_str\n        val extension_strength_str_first_last_str_first_last_str_first\
    \ = extension_strength_str_first_last_str_first_last_str_first + extension_strength_str_first_last_str_first_last\n\
    \        val extension_strength_str_first_last_str_first_last_str_last = extension_strength_str_first_last_str_first_last_str_first\
    \ + extension_strength_str_first_last_str_first_last_str_last\n        val extension_strength_str_first_last_str_first_last_str_first_last\
    \ = extension_strength_str_first_last_str_first_last_str_first_last + extension_strength_str_first_last_str_first_last_str_last\n\
    \        val extension_strength_str_first_last_str_first_last_str_first_last_str\
    \ = extension_strength_str_first_last_str_first_last_str_first_last_str + extension_strength_str_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5alu9de8.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextension_first\e[0m = extension_first._2\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mextension_first is already defined as \e[33mvalue\e[0m \e[35mextension_first\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5alu9de8.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mextension_last\e[0m = extension_last._2\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mextension_last is already defined as \e[33mvalue\e[0m \e[35mextension_last\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5alu9de8.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mextension_first\e[0m = extension_first.toString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_first is already defined as \e[33mvalue\e[0m \e\
    [35mextension_first\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5alu9de8.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mextension_last\e[0m = extension_last.toString\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mextension_last is already defined as \e[33mvalue\e[0m \e[35mextension_last\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- Error: /tmp/tmp5alu9de8.scala:21:149\
    \ ----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e\
    [33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e[36me\e[0m => e.toUpperCas"
  stdout: ''
  timestamp: 1659799669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val strength = extensions_count_upper - extensions_count_lower\n    \
    \    val extensions_count_upper = extensions.map(_.toUpperCase).sum\n        val\
    \ extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val strength_upper\
    \ = extensions_count_upper - extensions_count_lower\n        val extensions_count_upper\
    \ = extensions.map(_.toUpperCase).sum\n        val extensions_count_lower = extensions.map(_.toLowerCase).sum\n\
    \        val strength_lower = extensions_count_lower - extensions_count_upper\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_all = extensions_count_upper - extensions_count_lower - extensions_count_upper\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_all = extensions_count_upper - extensions_count_lower - extensions_count_upper\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_all = extensions_count_upper - extensions_count_lower - extensions_count_upper\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_all = extensions_count_upper - extensions_count_lower - extensions_count_upper\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_all = extensions_count_upper - extensions_count_lower - extensions_count_upper\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_all = extensions_count_upper - extensions_count_lower - extensions_count_upper\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = extensions.map(_.toLowerCase).sum\n        val\
    \ strength_all = extensions_count_upper - extensions_count_lower - extensions_count_upper\n\
    \        val extensions_count_upper = extensions.map(_.toUpperCase).sum\n    \
    \    val extensions_count_lower = \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1xu6iy2l.scala:53:36 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m\
    \   |\e[0m                                    expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1xu6iy2l.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_upper\e[0m = extensions.map(_.toUpperCase).sum\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1xu6iy2l.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_lower\e\
    [0m = extensions.map(_.toLowerCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_lower is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_lower\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1xu6iy2l.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_upper\e\
    [0m = extensions.map(_.toUpperCase).sum\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_upper is already defined as \e[33mvalue\e\
    [0m \e[35mextensions_count_upper\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1xu6iy2l.scala:29:12 --------------------------"
  stdout: ''
  timestamp: 1659799669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.charAt(0) -> e.toUpperCase.charAt(1).toLowerCase).toMap\n\
    \        val extensions_count = extensions.map(e => e.toUpperCase.charAt(0).toLowerCase).distinct.length\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extensions_count_map = extensions_count.map(e => e.toUpperCase.charAt(0).toLowerCase).toMap\n\
    \        val extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxwoux4f1.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxwoux4f1.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_map\e[0m = extensions_count.map(\e[36me\e[0m => e.toUpperCase.charAt(\e\
    [31m0\e[0m).toLowerCase).toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_map is already defined as \e[33mvalue\e[0m\
    \ \e[35mextensions_count_map\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxwoux4f1.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_map\e[0m\
    \ = extensions_count.map(\e[36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m).toLowerCase).toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_map is already defined as \e[33mvalue\e[0m\
    \ \e[35mextensions_count_map\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxwoux4f1.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_map\e[0m\
    \ = extensions_count.map(\e[36me\e[0m => e.toUpperCase.charAt(\e[31m0\e[0m).toLowerCase).toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_map is already defined as \e[33mvalue\e[0m\
    \ \e[35mextensions_count_map\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpxwoux4f1.scala:27:12 ---"
  stdout: ''
  timestamp: 1659799670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_count = class_name.length\n\
    \        val strength = extensions_count - class_name_count\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => strength - a.length - b.length)\n        extensions_sorted.head\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaehqtxcj.scala:24:62\
    \ --------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e\
    [0m = extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length\
    \ - b.length)\n\e[31m\e[31m   |\e[0m                                         \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                    Found:    Int\n\e[31m   |\e\
    [0m                                                       Required: Boolean\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799669
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        var strongest_extension\
    \ = \"\"\n        var strongest_extension_strength = -1\n        for(extension\
    \ <- extensions){\n            val CAP = extension.map(_.toUpperCase).length\n\
    \            val SM = extension.map(_.toLowerCase).length\n            val strength\
    \ = CAP - SM\n            if(strength > strongest_extension_strength){\n     \
    \           strongest_extension_strength = strength\n                strongest_extension\
    \ = extension\n            }\n        }\n        class_name + \".\" + strongest_extension\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsmk1inbh.scala:24:38 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mval\e[0m \e[36mCAP\e[0m = extension.map(_.toUpperCase).length\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                               value toUpperCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpsmk1inbh.scala:25:37\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m\
    \ \e[36mSM\e[0m = extension.map(_.toLowerCase).length\n\e[31m\e[31m   |\e[0m \
    \                                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                        value toLowerCase is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659799670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => (x - class_name_map.get(x)).abs).max\n    \
    \    val extensions_sorted = extensions_map.values.sortBy(x => x - class_name_map.get(x))\n\
    \        val extensions_sorted_sorted = extensions_sorted.sortBy(x => x - class_name_map.get(x))\n\
    \        val extensions_sorted_sorted_sorted = extensions_sorted_sorted.sortBy(x\
    \ => x - class_name_map.get(x))\n        val extensions_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted.sortBy(x => x - class_name_map.get(x))\n \
    \       val extensions_sorted_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x - class_name_map.get(x))\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted.sortBy(x => x - class_name_map.get(x))\n\
    \        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted = extensions_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x - class_name_map.get(x))\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x => x\
    \ - class_name_map.get(x))\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x - class_name_map.get(x))\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x - class_name_map.get(x))\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x - class_name_map.get(x))\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x - class_name_map.get(x))\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => x - class_name_map.get(x))\n        val extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(x\
    \ => \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8yfah5fs.scala:37:222 --------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(\e\
    [36mx\e[0m => \n\e[31m\e[31m   |\e[0m                                        \
    \                                                                            \
    \                                                                            \
    \                              ^\e[0m\n\e[31m   |\e[0m                       \
    \                expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp8yfah5fs.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted.sortBy(\e\
    [36mx\e[0m => x - class_name_map.get(x))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  extensions_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted_sorted\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8yfah5fs.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^"
  stdout: ''
  timestamp: 1659799672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase.size, x.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((x, y) => if (x > y) x else y)\n\
    \        val extensions_sorted = extensions_map.values.toList.sortWith((x, y)\
    \ => x < y)\n        val extensions_sorted = extensions_sorted.takeWhile(_ < strength)\n\
    \        val extensions_sorted = extensions_sorted.map(x => class_name + x.toString).mkString(\"\
    .\")\n        extensions_sorted\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppnhzvsm9.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_ < strength)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmppnhzvsm9.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.map(\e[36mx\e[0m => class_name + x.toString).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmppnhzvsm9.scala:26:8 ---------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        extensions_sorted\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (extensions_sorted\
    \ : List[Int])\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659799671
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val class_name_length = class_name.length\n\
    \        val strength = extensions_count - class_name_length\n        val extensions_sorted\
    \ = extensions.sortWith((a, b) => strength - a.length - b.length)\n        val\
    \ extension_length = extensions_sorted.map(_.length).sum\n        val extension_strength\
    \ = extensions_sorted.map(_.length).sum / extensions_sorted.length\n        val\
    \ extension_sorted = extensions_sorted.takeWhile(x => x.length == extension_length)\n\
    \        val extension_strength_sorted = extensions_sorted.takeWhile(x => x.length\
    \ == extension_length).map(_.length).sum / extensions_sorted.length\n        val\
    \ extension_strength_sorted_sorted = extensions_sorted.takeWhile(x => x.length\
    \ == extension_length).sortWith((a, b) => a.length - b.length).map(_.length).sum\
    \ / extensions_sorted.length\n        val extension_strength_sorted_sorted_sorted\
    \ = extensions_sorted.takeWhile(x => x.length == extension_length).sortWith((a,\
    \ b) => a.length - b.length).sortWith((a, b) => a.length - b.length).map(_.length).sum\
    \ / extensions_sorted.length\n        val extension_strength_sorted_sorted_sorted_sorted\
    \ = extensions_sorted.takeWhile(x => x.length == extension_length).sortWith((a,\
    \ b) => a.length - b.length).sortWith((a, b) => a.length - b.length).sortWith((a,\
    \ b) => a.length - b.length).map(_.length).sum / extensions_sorted.length\n  \
    \      val extension_strength_sorted_sorted_sorted_sorted_sorted = extensions_sorted.takeWhile(x\
    \ => x.length == extension_length).sortWith((a, b) => a.length - b.length).sortWith((a,\
    \ b) => a.length - b.length).sortWith((a, b) => a.length - b.length).sortWith((a,\
    \ b) => a.length - b.length).sortWith((a, b) => a.length - b.length).map(_.length).sum\
    \ / extensions_sorted.length\n        val extension_strength_sorted_sorted_sorted_sorted_sorted_sorted\
    \ = extensions_sorted.takeWhile(x => x.length == extension_length).sortWith((a,\
    \ b) => a.length - b.length).sortWith((a, b) => a.length - b.length).sortWith((a,\
    \ b) => a.length - b.length).sortWith((a, b) => a.length - b.length).sortWith((a,\
    \ b) => a.length - b.length).sortWith((a, b) => a.length - b.length).sortWith((a,\
    \ b) => a.length - b.length).sortWith((\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"\
    niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpauumww2j.scala:33:428 --------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_sorted_sorted_sorted_sorted_sorted_sorted\e\
    [0m = extensions_sorted.takeWhile(\e[36mx\e[0m => x.length == extension_length).sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => a.length - b.length).sortWith((\e[36ma\e[0m, \e[36mb\e\
    [0m) => a.length - b.length).sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => a.length\
    \ - b.length).sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => a.length - b.length).sortWith((\e\
    [36ma\e[0m, \e[36mb\e[0m) => a.length - b.length).sortWith((\e[36ma\e[0m, \e[36mb\e\
    [0m) => a.length - b.length).sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => a.length\
    \ - b.length).sortWith((\n\e[31m\e[31m   |\e[0m                              \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \    expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpauumww2j.scala:24:62 --------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions.sortWith((\e[36ma\e[0m, \e[36mb\e[0m) => strength - a.length - b.length)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                                     Found:    Int\n\e[31m   |\e[0m         \
    \                                              Required: Boolean\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpauumww2j.scala:29:129 -------------------\e\
    [0m\e[0m\n\e[31m29"
  stdout: ''
  timestamp: 1659799673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.split(\"\\\\.\").toMap\n        val class_name_length = class_name_map.size\n\
    \        val extensions_length = extensions_map.size\n        val strength = extensions_length\
    \ - class_name_length\n        val extensions_sorted = extensions_map.toSeq.sortBy(_._2).reverse\n\
    \        val extension_strength = extensions_sorted.head._2\n        val extension_length\
    \ = extensions_sorted.length\n        val extension_sorted = extensions_sorted.take(extension_length)\n\
    \        val extension_strength_map = extension_sorted.map(x => (x._1, x._2)).toMap\n\
    \        val extension_strength_length = extension_strength_map.size\n       \
    \ val extension_strength_sorted = extension_strength_map.toSeq.sortBy(_._2).reverse\n\
    \        val extension_strength_length = extension_strength_sorted.length\n  \
    \      val extension_strength_sorted = extension_strength_sorted.take(extension_strength_length)\n\
    \        val extension_strength_map = extension_strength_sorted.map(x => (x._1,\
    \ x._2)).toMap\n        val extension_strength_length = extension_strength_map.size\n\
    \        val extension_strength_sorted = extension_strength_map.toSeq.sortBy(_._2).reverse\n\
    \        val extension_strength_length = extension_strength_sorted.length\n  \
    \      val extension_strength_sorted = extension_strength_sorted.take(extension_strength_length)\n\
    \        val extension_strength_map = extension_strength_sorted.map(x => (x._1,\
    \ x._2)).toMap\n        val extension_strength_length = extension_strength_map.size\n\
    \        val extension_strength_sorted = extension_strength_map.toSeq.sortBy(_._2).reverse\n\
    \        val extension_strength_length = extension_strength_sorted.length\n  \
    \      val extension_strength_sorted = extension_strength_sorted.take(extension_strength_length)\n\
    \        val extension_strength_map = extension_strength_sorted.map(x => (x._1,\
    \ x._2)).toMap\n        val extension_strength_length = extension_strength_map.size\n\
    \        val extension_strength_sorted = extension_strength_map.toSeq.sortBy(_._2).reverse\n\
    \        val extension_strength_length = extension_strength_sorted.length\n  \
    \      val extension_strength_sorted = extension_strength_sorted.take(extension\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpex6t09kh.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpex6t09kh.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextension_strength_length\e[0m = extension_strength_sorted.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_length is already defined as \e[33mvalue\e\
    [0m \e[35mextension_strength_length\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpex6t09kh.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_sorted\e\
    [0m = extension_strength_sorted.take(extension_strength_length)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_sorted is already defined as \e[33mvalue\e\
    [0m \e[35mextension_strength_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpex6t09kh.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_map\e\
    [0m = extension_strength_sorted.map(\e[36mx\e[0m => (x._1, x._2)).toMap\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_strength_map is already defined as \e[33mvalue\e\
    [0m \e[35mextension_strength_map\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpex6t09kh.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mextension_strength_length\e\
    [0m = extension_stren"
  stdout: ''
  timestamp: 1659799673
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => (e.toUpperCase.size, e.toLowerCase.size)).toMap\n    \
    \    val strength = extensions_map.values.reduce((a, b) => math.max(a, b))\n \
    \       val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n  \
    \      val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        val extensions_sorted = extensions_sorted.dropWhile(_._2 > 0).map(_._1).mkString(\"\
    .\")\n        class_name + extensions_sorted + \".\" + extensions_sorted.last\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqhfb_lwc.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpqhfb_lwc.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.dropWhile(_._2 > \e[31m0\e[0m).map(_._1).mkString(\e[31m\"\
    .\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659799670
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase - x.toLowerCase -> x)).toMap\n        val\
    \ class_name_map = class_name.map(x => (x.toUpperCase - x.toLowerCase -> x)).toMap\n\
    \        val strength = extensions_map.values.map(x => class_name_map.getOrElse(x,\
    \ 0)).sum\n        val extensions_sorted = extensions_map.values.sortBy(x => -x)\n\
    \        val extensions_sorted_first = extensions_sorted.head\n        val extensions_sorted_last\
    \ = extensions_sorted.last\n        val extensions_sorted_first_upper = extensions_sorted_first.toUpperCase\
    \ \n        val extensions_sorted_last_upper = extensions_sorted_last.toUpperCase\
    \ \n        val extensions_sorted_first_lower = extensions_sorted_first.toLowerCase\
    \ \n        val extensions_sorted_last_lower = extensions_sorted_last.toLowerCase\
    \ \n        val extensions_sorted_first_first_upper = extensions_sorted_first_upper.substring(0,1)\
    \ \n        val extensions_sorted_last_first_upper = extensions_sorted_last_upper.substring(0,1)\
    \ \n        val extensions_sorted_first_first_lower = extensions_sorted_first_lower.substring(0,1)\
    \ \n        val extensions_sorted_last_first_lower = extensions_sorted_last_lower.substring(0,1)\
    \ \n        val extensions_sorted_first_last_upper = extensions_sorted_first_upper.substring(1,2)\
    \ \n        val extensions_sorted_last_last_upper = extensions_sorted_last_upper.substring(1,2)\
    \ \n        val extensions_sorted_first_last_lower = extensions_sorted_first_lower.substring(1,2)\
    \ \n        val extensions_sorted_last_last_lower = extensions_sorted_last_lower.substring(1,2)\
    \ \n        val extensions_sorted_first_first_last_upper = extensions_sorted_first_last_upper.substring(0,1)\
    \ \n        val extensions_sorted_last_first_last_upper = extensions_sorted_last_last_upper.substring(0,1)\
    \ \n        val extensions_sorted_first_first_last_lower = extensions_sorted_first_last_lower.substring(0,1)\
    \ \n        val extensions_sorted_last_first_last_lower = extensions_sorted_last_last_lower.substring(0,1)\
    \ \n        val extensions_sorted_first_last_last_lower = extensions_sorted_first_last_lower.substring(1,2)\
    \ \n        val extensions_sorted_last_last_last_lower = extensions_sorted_last_last_lower.substring(1,2)\
    \ \n        val extensions_sorted_first_first_last_last_upper = extensions_sorted_first_last_last_upper.substring(0,1)\
    \ \n        val extensions_sorted_last_first_last_last_upper = extensions_sorted_last_last_upper.substring(0,1)\
    \ \n        val extensions_sorted_first_first_last_last_lower = extensions_sorted_first_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp2zk3kcu.scala:21:64 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36mx\e[0m => (x.toUpperCase - x.toLowerCase -> x)).toMap\n\e[31m\e[31m   |\e\
    [0m                                                  ^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue - is not a member of String, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp2zk3kcu.scala:22:52\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mclass_name_map\e[0m = class_name.map(\e[36mx\e[0m => (x.toUpperCase - x.toLowerCase\
    \ -> x)).toMap\n\e[31m\e[31m   |\e[0m                                        \
    \          ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value\
    \ toUpperCase is not a member of Char\n\e[31m\e[31m-- Error: /tmp/tmpp2zk3kcu.scala:23:89\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m23 |\e[0m       \
    \ \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e[36mx\e[0m\
    \ => class_name_map.getOrElse(x, \e[31m0\e[0m)).sum\n\e[31m\e[31m   |\e[0m   \
    \                                                                            \
    \          ^\e[0m\n\e[31m   |\e[0mambiguous given instances: both \e[33mobject\e\
    [0m \e[35mByteIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m and \e[33mobject\e\
    [0m \e[35mShortIsIntegral\e[0m in \e[33mobject\e[0m \e[35mNumeric\e[0m match type\
    \ Numeric[B] of parameter num of \e[33mmethod\e[0m \e[35msum\e[0m in \e[33mtrait\e\
    [0m \e[35mIterableOnceOps\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp2zk3kcu.scala:24:54\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mextensions_sorted\e[0m = extensions_map.values.sortBy(\e[36mx\e[0m => -x)\n\
    \e[31m\e[31m   |\e[0m       "
  stdout: ''
  timestamp: 1659799674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.count\n        val extensions_count_upper = extensions.count(_.toUpperCase.size\
    \ == extensions_count)\n        val extensions_count_lower = extensions.count(_.toLowerCase.size\
    \ == extensions_count)\n        val extensions_count_diff = extensions_count_upper\
    \ - extensions_count_lower\n        val extensions_count_diff_frac = extensions_count_diff\
    \ / extensions_count\n        val extensions_count_diff_frac_max = extensions_count_diff_frac.max\n\
    \        val extensions_count_diff_frac_max_index = extensions_count_diff_frac.indexOf(extensions_count_diff_frac_max)\n\
    \        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ - 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_frac_max_index\
    \ + 1\n        val extensions_count_diff_frac_max_index = extensions_count_diff_fra\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe7fxig5a.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_frac_max_index\e\
    [0m = extensions_count_diff_frac_max_index + \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_frac_max_index is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_frac_max_index\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe7fxig5a.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_max_index\e[0m = extensions_count_diff_frac_max_index\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_frac_max_index is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_frac_max_index\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe7fxig5a.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_max_index\e[0m = extensions_count_diff_frac_max_index\
    \ + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_frac_max_index is already defined as\
    \ \e[33mvalue\e[0m \e[35mextensions_count_diff_frac_max_index\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe7fxig5a.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_frac_max_index\e[0m = extensions_count_diff_frac_max_index\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^"
  stdout: ''
  timestamp: 1659799674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        var strongest_extension\
    \ = \"\"\n        var strength = -1\n        var extension = \"\"\n        var\
    \ extension_strength = -1\n        var extension_class = \"\"\n        var extension_class_strength\
    \ = -1\n        var extension_class_name = \"\"\n        var extension_class_name_strength\
    \ = -1\n        var extension_class_name_count = 0\n        var extension_class_name_count_strength\
    \ = -1\n        var extension_class_name_count_count = 0\n        var extension_class_name_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count = 0\n        var extension_class_name_count_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count_count = 0\n       \
    \ var extension_class_name_count_count_count_count_strength = -1\n        var\
    \ extension_class_name_count_count_count_count_count = 0\n        var extension_class_name_count_count_count_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count_count_count_count =\
    \ 0\n        var extension_class_name_count_count_count_count_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count_count_count_count_count_count\
    \ = 0\n        var extension_class_name_count_count_count_count_count_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count_count_count_count_count_count_count\
    \ = 0\n        var extension_class_name_count_count_count_count_count_count_count_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count\
    \ = 0\n        var extension_class_name_count_count_count_count_count_count_count_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count\
    \ = 0\n        var extension_class_name_count_count_count_count_count_count_count_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count_count\
    \ = 0\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count_count_count\
    \ = 0\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count_count_count_count\
    \ = 0\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count_count_count_count\
    \ = 0\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count_count_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count_count_count_count_count_count\
    \ = 0\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count_count_count_count_strength\
    \ = -1\n        var extension_class_name_count_count_count_count_count_count_count_count_count_count_count_count_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxfql63_z.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxfql63_z.scala:46:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mextension_class_name_count_count_count_count_count_count_count_count_count_strength\e\
    [0m = -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_count_count_count_count_count_count_count_count_count_strength\
    \ is already defined as \e[33mvariable\e[0m \e[35m\n\e[31m   |\e[0m  extension_class_name_count_count_count_count_count_count_count_count_count_strength\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpxfql63_z.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mvar\e[0m \e[36mextension_class_name_count_count_count_count_count_count_count_count_count_count\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_class_name_count_count_count_count_count_count_count_count_count_count\
    \ is already defined as \e[33mvariable\e[0m \e[35m\n\e[31m   |\e[0m  extension_class_name_count_count_count_count_count_count_count_count_count_count\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpxfql63_z.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mvar\e[0m \e[36mextension_class_name_count_count_count_count_count_count_count_count_count_strength\e\
    [0m = -\e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextension_cla"
  stdout: ''
  timestamp: 1659799674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.foldLeft(0) { (s, e) =>\n            val c = class_name_map(e._1)\n\
    \            val m = extensions_map(e._2)\n            val cap = m.size\n    \
    \        val sm = c.size\n            val strength = cap - sm\n            if\
    \ (strength > s) strength else s\n        }\n        val class_name = class_name_map(extensions_map.keys.toList.head)\n\
    \        val extension = extensions_map(extensions_map.keys.toList.head)\n   \
    \     class_name + extension\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\",\
    \ \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgpkh43_t.scala:31:25 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name_map(extensions_map.keys.toList.head)\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 Recursive \e[33mvalue\e[0m \e[35mclass_name_map\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659799672
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_upper - extensions_count_diff\n\
    \        val extensions_count_diff_lower = extensions_count_lower - extensions_count_diff\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper -\
    \ extensions_count_diff_lower\n        val extensions_count_diff_diff_lower =\
    \ extensions_count_diff_lower - extensions_count_diff_upper\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper - extensions_count_diff_diff_lower\n    \
    \    val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_lower\
    \ - extensions_count_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper - extensions_count_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_upper\n        val\
    \ extensions_count_diff_diff_diff_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_l4q23v8.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_l4q23v8.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_upper is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_upper\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_l4q23v8.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_l4q23v8.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659799573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val class_name_map\
    \ = class_name.map(x => (x.toUpperCase, x.toLowerCase)).toMap\n        val strength\
    \ = extensions_map.values.map(x => class_name_map.get(x) - x.toString.toString.toUpperCase.length).max\n\
    \        val extension = extensions_map.getOrElse(strength, \"\")\n        class_name\
    \ + extension\n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbhtf3hwb.scala:22:52 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                               ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                               value toUpperCase is not a member of Char\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpbhtf3hwb.scala:22:67 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mclass_name_map\e[0m = class_name.map(\e\
    [36mx\e[0m => (x.toUpperCase, x.toLowerCase)).toMap\n\e[31m\e[31m   |\e[0m   \
    \                                                              ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toLowerCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbhtf3hwb.scala:23:73\
    \ --------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e\
    [0m = extensions_map.values.map(\e[36mx\e[0m => class_name_map.get(x) - x.toString.toString.toUpperCase.length).max\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^\e[0m\n\e[31m   |\e[0m                                    \
    \              Found:    (x : String)\n\e[31m   |\e[0m                       \
    \                           Required: Nothing\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmpbhtf3hwb.scala:23:121 ----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mstrength\e[0m = extensions_map.values.map(\e\
    [36mx\e[0m => class_name_map.get(x) - x.toString.toString.toUpperCase.length).max\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                 ^\e[0m\n\e[31m\
    \   |\e[0mambiguous given instances: both \e[33mobject\e[0m \e[35mBigInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m and \e[33mobject\e[0m \e[35mInt\e[0m\
    \ in \e[33mobject\e[0m \e[35mOrdering\e[0m match type Ordering[B] of paramete"
  stdout: ''
  timestamp: 1659799675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.values.max\n\
    \        val extensions_sorted = extensions_map.toSeq.sortBy(_._1).reverse\n \
    \       val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val extensions_sorted = extensions_sorted.takeWhile(_._2 > 0).map(_._1)\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(StrongestExtension((\"\
    Watashi\"), (List[String](\"tEN\", \"niNE\", \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\"\
    )));\n    assert(StrongestExtension((\"Boku123\"), (List[String](\"nani\", \"\
    NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"))).equals((\"Boku123.YEs.WeCaNe\")));\n\
    \    assert(StrongestExtension((\"__YESIMHERE\"), (List[String](\"t\", \"eMptY\"\
    , \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"))).equals((\"__YESIMHERE.NuLl__\"\
    )));\n    assert(StrongestExtension((\"K\"), (List[String](\"Ta\", \"TAR\", \"\
    t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n    assert(StrongestExtension((\"\
    __HAHA\"), (List[String](\"Tab\", \"123\", \"781345\", \"-_-\"))).equals((\"__HAHA.123\"\
    )));\n    assert(StrongestExtension((\"YameRore\"), (List[String](\"HhAas\", \"\
    okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"))).equals((\"YameRore.okIWILL123\"\
    )));\n    assert(StrongestExtension((\"finNNalLLly\"), (List[String](\"Die\",\
    \ \"NowW\", \"Wow\", \"WoW\"))).equals((\"finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"\
    _\"), (List[String](\"Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"\
    Sp\"), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n\
    }\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpq_1hfuv2.scala:44:11 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpq_1hfuv2.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpq_1hfuv2.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpq_1hfuv2.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mextensions_sorted\e[0m =\
    \ extensions_sorted.takeWhile(_._2 > \e[31m0\e[0m).map(_._1)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_sorted is already defined as \e[33mvalue\e[0m \e\
    [35mextensions_sorted\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpq_1hfuv2.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mextensions"
  stdout: ''
  timestamp: 1659799675
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_map\
    \ = extensions.map(e => e.toUpperCase.count(_ == 'A') - e.toUpperCase.count(_\
    \ == 'B') - e.toUpperCase.count(_ == 'C')).toMap\n        val strength = extensions_map.getOrElse(class_name,\
    \ 0)\n        val sorted_extensions = extensions_map.toSeq.sortBy(_._1).reverse\n\
    \        val first_extension = sorted_extensions.head\n        val class_name\
    \ = class_name + first_extension\n        val extension_name = first_extension\n\
    \        val extension_strength = extensions_map.getOrElse(class_name, 0)\n  \
    \      val extension_strength_str = extension_strength.toString\n        if (extension_strength_str.length\
    \ < 2) extension_strength_str\n        else class_name + \".\" + extension_name\
    \ + \".\" + extension_strength_str\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpbfpz9ali.scala:21:149 ----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mextensions_map\e[0m = extensions.map(\e\
    [36me\e[0m => e.toUpperCase.count(_ == \e[31m'A'\e[0m) - e.toUpperCase.count(_\
    \ == \e[31m'B'\e[0m) - e.toUpperCase.count(_ == \e[31m'C'\e[0m)).toMap\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \         ^\e[0m\n\e[31m   |\e[0m                                        Cannot\
    \ prove that Int <:< (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                \
    \                        where:    K is a type variable\n\e[31m   |\e[0m     \
    \                                             V is a type variable\n\e[31m   |\e\
    [0m                                        .\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpbfpz9ali.scala:25:25 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mclass_name\e[0m = class_name + first_extension\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 Recursive \e[33mvalue\e[0m \e[35mclass_name\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659799674
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You will be given the name of a class (a string) and a list of extensions.\n\
    \    // The extensions are to be used to load additional classes to the class.\
    \ The\n    // strength of the extension is as follows: Let CAP be the number of\
    \ the uppercase\n    // letters in the extension's name, and let SM be the number\
    \ of lowercase letters \n    // in the extension's name, the strength is given\
    \ by the fraction CAP - SM. \n    // You should find the strongest extension and\
    \ return a string in this \n    // format: ClassName.StrongestExtensionName.\n\
    \    // If there are two or more extensions with the same strength, you should\n\
    \    // choose the one that comes first in the list.\n    // For example, if you\
    \ are given \"Slices\" as the class and a list of the\n    // extensions: ['SErviNGSliCes',\
    \ 'Cheese', 'StuFfed'] then you should\n    // return 'Slices.SErviNGSliCes' since\
    \ 'SErviNGSliCes' is the strongest extension \n    // (its strength is -1).\n\
    \    // Example:\n    // >>> StrongestExtension((\"my_class\"), (List[String](\"\
    AA\", \"Be\", \"CC\")))\n    // (\"my_class.AA\")\n    def StrongestExtension(class_name\
    \ : String, extensions : List[String]) : String = {\n        val extensions_count\
    \ = extensions.map(_.length).sum\n        val extensions_count_upper = extensions.map(_.toUpperCase.length).sum\n\
    \        val extensions_count_lower = extensions.map(_.toLowerCase.length).sum\n\
    \        val extensions_count_diff = extensions_count_upper - extensions_count_lower\n\
    \        val extensions_count_diff_upper = extensions_count_upper - extensions_count_diff\n\
    \        val extensions_count_diff_lower = extensions_count_lower - extensions_count_diff\n\
    \        val extensions_count_diff_diff_upper = extensions_count_diff_upper -\
    \ extensions_count_diff_lower\n        val extensions_count_diff_diff_lower =\
    \ extensions_count_diff_lower - extensions_count_diff_upper\n        val extensions_count_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_upper - extensions_count_diff_diff_lower\n    \
    \    val extensions_count_diff_diff_diff_lower = extensions_count_diff_diff_lower\
    \ - extensions_count_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_upper - extensions_count_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_upper\n        val extensions_count_diff_diff_diff_diff_diff_diff_upper\
    \ = extensions_count_diff_diff_diff_diff_diff_diff_diff_upper - extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\n\
    \        val extensions_count_diff_diff_diff_diff_diff_diff_lower = extensions_count_diff_diff_diff_diff_diff_diff_diff_lower\
    \ - extensions_count_diff_diff_diff_diff_diff_diff_diff_diff_upper\n        val\
    \ extensions_count_diff_diff_diff_\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(StrongestExtension((\"Watashi\"), (List[String](\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"))).equals((\"Watashi.eIGHt8OKe\")));\n    assert(StrongestExtension((\"\
    Boku123\"), (List[String](\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ))).equals((\"Boku123.YEs.WeCaNe\")));\n    assert(StrongestExtension((\"__YESIMHERE\"\
    ), (List[String](\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ))).equals((\"__YESIMHERE.NuLl__\")));\n    assert(StrongestExtension((\"K\"),\
    \ (List[String](\"Ta\", \"TAR\", \"t234An\", \"cosSo\"))).equals((\"K.TAR\")));\n\
    \    assert(StrongestExtension((\"__HAHA\"), (List[String](\"Tab\", \"123\", \"\
    781345\", \"-_-\"))).equals((\"__HAHA.123\")));\n    assert(StrongestExtension((\"\
    YameRore\"), (List[String](\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\",\
    \ \"-_-\"))).equals((\"YameRore.okIWILL123\")));\n    assert(StrongestExtension((\"\
    finNNalLLly\"), (List[String](\"Die\", \"NowW\", \"Wow\", \"WoW\"))).equals((\"\
    finNNalLLly.WoW\")));\n    assert(StrongestExtension((\"_\"), (List[String](\"\
    Bb\", \"91245\"))).equals((\"_.Bb\")));\n    assert(StrongestExtension((\"Sp\"\
    ), (List[String](\"671235\", \"Bb\"))).equals((\"Sp.671235\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_l4q23v8.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_l4q23v8.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mextensions_count_diff_diff_diff_diff_upper\e[0m = extensions_count_diff_diff_diff_diff_upper\
    \ - extensions_count_diff_diff_diff_diff_lower\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_upper is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_upper\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_l4q23v8.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mextensions_count_diff_diff_diff_diff_lower is already defined\
    \ as \e[33mvalue\e[0m \e[35mextensions_count_diff_diff_diff_diff_lower\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_l4q23v8.scala:38:12 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mextensions_count_diff_diff_diff_diff_diff_lower\e\
    [0m = extensions_count_diff_diff_diff_diff_diff_lower - extensions_count_diff_diff_diff_diff_diff_diff_upper\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659799573
