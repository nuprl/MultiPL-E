name: HumanEval_57_monotonic
language: ruby
prompt: "# Return True is list elements are monotonically increasing or decreasing.\n\
  # >>> monotonic([1, 2, 4, 20])\n# True\n# >>> monotonic([1, 20, 4, 10])\n# False\n\
  # >>> monotonic([4, 1, 0, -10])\n# True\ndef monotonic(l)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_monotonic\n\
  \    candidate = method(:monotonic)\n    assert_equal(true, candidate.call([1, 2,\
  \ 4, 10]))\n    assert_equal(true, candidate.call([1, 2, 4, 20]))\n    assert_equal(false,\
  \ candidate.call([1, 20, 4, 10]))\n    assert_equal(true, candidate.call([4, 1,\
  \ 0, -10]))\n    assert_equal(true, candidate.call([4, 1, 1, 0]))\n    assert_equal(false,\
  \ candidate.call([1, 2, 3, 2, 5, 60]))\n    assert_equal(true, candidate.call([1,\
  \ 2, 3, 4, 5, 60]))\n    assert_equal(true, candidate.call([9, 9, 9, 9]))\n  end\n\
  end\n"
completions: ["  return l.all? or l.all? { |x| x.succ <= x.pred }\nend", "  l.sort!\n\
    \  l.each_cons(2) do |a, b|\n    return false if a.nil? || b.nil? || a > b\n \
    \ end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return true if\
    \ x >= y\n  end\n  false\nend", "  l.sort!\n  return l.all? { |x| x >= l[0] }\n\
    end", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if a.nil? || b.nil?\n\
    \    return false if a.first > b.first\n    return false if a.last < b.last\n\
    \  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false\
    \ if y > x\n  end\n  true\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this\
    \ solution, but I wonder if there's a way to make it more efficient (maybe by\
    \ avoiding sorting the entire list every time).\n<|/ c |>\n<| c |>\n: I doubt\
    \ that you can do better than O(n). Sorting is a O(n) operation. Even if you could\
    \ do better than O(n), sorting would still be O(n), so you wouldn't gain much\
    \ from it.\n<|/ c |>\n<| c |>\n: I added a more efficient solution that doesn't\
    \ sort the list every time.\n<|/ c |>\n<| c |>\n: I added a more efficient solution\
    \ that doesn't sort the list every time.\n<|/ c |>\n<| c |>\n: I added a more\
    \ efficient solution that doesn't sort the list every time.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y <=\
    \ x\n  end\n  true\nend", "  return l.all? or l.all? { |x| x.succ <= x.pred }\n\
    end", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y < x\n  end\n\
    \  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return true if y > x\n\
    \  end\n  false\nend", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false\
    \ if a.nil? || b.nil?\n    return false if a.last < b.first\n  end\n  true\nend",
  "  return l.all? && l.all? { |e| e > l[0] && e < l[-1] }\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y < x\n  end\n  true\nend", "  l.sort!\n  l.each_with_index\
    \ do |x, i|\n    return false if l[i-1] > x\n  end\n  true\nend\n</code>\n<|/\
    \ a tags=ruby,arrays |>\n<| c |>\n`monotonic([4, 1, 0, -10])` returns `true` but\
    \ should return `false` because `-10` is less than `1`.\n<|/ c |>\n<| c |>\n:\
    \ I see what you mean. I've updated the answer to reflect that.\n<|/ c |>\n<|\
    \ c |>\nI like your answer, but I think it could be improved by using `each_cons`\
    \ instead of `each_with_index`\n<|/ c |>\n<| c |>\n: Yes, that's a good idea.\
    \ I've updated the answer to reflect that.\n<|/ c |>\n<| a dscore=2 |>\n<code>",
  "  l.sort!\n  return l.first <= l.last\nend", "  l.sort!\n  return l[-1] < l[0]\n\
    end", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y < x\n  end\n\
    \  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y <=\
    \ x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false\
    \ if x <= y\n  end\n  true\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis is\
    \ very elegant. Thanks!\n<|/ c |>\n<| c |>\nI like this solution, but I wonder\
    \ if there is a way to make it work for empty lists.\n<|/ c |>\n<| c |>\n: I added\
    \ a version that works for empty lists.\n<|/ c |>\n<| c |>\nI like it, but I wonder\
    \ if there is a way to make it work for empty lists.\n<|/ c |>\n<| c |>\n: Yes,\
    \ it does. I added a version that works for empty lists.\n<|/ c |>\n<| a |>\n\
    <code>", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y <= x\n \
    \ end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if\
    \ y <= x\n  end\n  true\nend", "  l.sort!\n  return l[-1] < l[0]\nend", "  l.sort!\n\
    \  return l.all? { |x| x.to_i <= x.to_i + 1 }\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if b < a\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,arrays,sorting\
    \ |>\n<| c |>\nThis doesn't work if you have a list like `[1, 1, 2, 3]`\n<|/ c\
    \ |>\n<| c |>\n: It does work, try it out. `[1, 1, 2, 3].sort.each_cons(2).all?\
    \ { |a, b| b < a }` is `true`.\n<|/ c |>\n<| c |>\n: It does work, try it out.\
    \ `[1, 1, 2, 3].sort.each_cons(2).all? { |a, b| b < a }` is `true`.\n<|/ c |>\n\
    <| c |>\n: It does work, try it out. `[1, 1, 2, 3].sort.each_cons(2).all? { |a,\
    \ b| b < a }` is `true`.\n<|/ c |>\n<| c |>\n: It does work, try it out. `[1,\
    \ 1, 2, 3].sort.each_cons(2).all? { |a, b| b < a }` is `true`.\n<|/ c |>\n<| a\
    \ tags=ruby,arrays,sorting |>\n<code>", "  l.sort!\n  l.each_cons(2) do |x,y|\n\
    \    return true if x.nil? || y.nil? || y > x\n  end\n  false\nend", "  l.sort!\n\
    \  l.each_cons(2) do |x,y|\n    return false if x < y\n  end\n  true\nend", " \
    \ l.sort!\n  l.each_cons(2) do |x,y|\n    return false if x <= y\n  end\n  true\n\
    end", "  return l.all? or l.all? { |x| x.succ <= x.pred }\nend", "  l.sort!\n\
    \  l.each_cons(2) do |x,y|\n    return false if y <= x\n  end\n  true\nend", " \
    \ l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y <= x\n  end\n  true\n\
    end\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if\
    \ the array is `[1, 1, 1]`\n<|/ c |>\n<| c |>\n: It works fine for me. `[1, 1,\
    \ 1]` returns `true`.\n<|/ c |>\n<| c |>\n: I guess you meant `[1, 1, 2]`? That\
    \ returns `false` as expected.\n<|/ c |>\n<| c |>\n: Yes, I meant `[1, 1, 2]`.\
    \ Sorry for the confusion.\n<|/ c |>\n<| c |>\n: I guess you meant `[1, 1, 2]`?\
    \ That returns `false` as expected.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n\
    <code>", "  return l.all? && l.all? { |e| e > l[0] && e < l[-1] }\nend", "  l.sort!\n\
    \  l.each_cons(2) do |x,y|\n    return true if y > x\n  end\n  false\nend", " \
    \ return l.all? or (l.min < l.max)\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n\
    \    return false if x == y\n    return true if x > y\n  end\n  true\nend", " \
    \ l.sort!\n  l.each_cons(2) do |x,y|\n    return true if y > x\n  end\n  false\n\
    end", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y > x\n  end\n\
    \  true\nend", "  l.sort!\n  return l.reduce(:<=) == l.reduce(:<)\nend", "  l.sort!\n\
    \  return l[0] < l[-1]\nend", "  l.sort!\n  l.each_with_index do |x, i|\n    return\
    \ false if l[i-1] < x\n  end\n  true\nend", "  l.sort!\n  return l[1] < l[-1]\n\
    end", "  l.sort!\n  l.each_with_index do |x, i|\n    return false if l[i-1] >\
    \ x\n  end\n  true\nend", "  return l.all? or l.all? { |x| x.succ <= x.pred }\n\
    end", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if a.nil? || b.nil?\n\
    \    return false if a.last < b.last\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if a.nil? || b.nil?\n    return false if a.nil?\
    \ && b.nil?\n    return false if b.nil? && a.nil?\n    return false if a.nil?\
    \ || b.nil? || a > b\n  end\n  true\nend", "  return l.all? or l.all? { |x| x.succ\
    \ <= x.pred }\nend", "  l.sort!\n  return l[0] < l[-1]\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y > x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if a.nil? || b.nil?\n    return false if a.last\
    \ < b.last\n    a.last > b.last ? true : false\n  end\n  true\nend", "  l.sort!\n\
    \  return l[1] < l[-1]\nend", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return\
    \ false if a.nil? || b.nil?\n    return false if a.nil? && b.nil?\n    return\
    \ false if b.nil? && a.nil?\n    return false if a.nil? || b.nil? || a > b\n \
    \ end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if\
    \ y <= x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return\
    \ false if b < a\n  end\n  true\nend", "  return l.all? && l.all? { |x| x.to_i\
    \ < x.to_i }\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if\
    \ y > x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return\
    \ true if y > x\n  end\n  false\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like\
    \ this solution, because it doesn't require any additional libraries. However,\
    \ it does require a little more memory than `sort!` + `each_cons`, so I wouldn't\
    \ use it unless I knew the list was going to be small.\n<|/ c |>\n<| c |>\nI like\
    \ this solution as well, but I prefer `each_cons(2)` over `each_cons(2..l.size)`\
    \ because `each_cons(2..l.size)` will create an intermediate array that gets garbage\
    \ collected as soon as `each_cons` returns.\n<|/ c |>\n<| c |>\nI like this solution\
    \ as well, but I prefer `each_cons(2)` over `each_cons(2..l.size)` because `each_cons(2..l.size)`\
    \ will create an intermediate array that gets garbage collected as soon as `each_cons`\
    \ returns.\n<|/ c |>\n<| c |>\nI like this solution as well, but I prefer `each_cons(2)`\
    \ over `each_cons(2..l.size)` because `each_cons(2..l.size)` will create an intermediate\
    \ array that gets garbage collected as soon as `each_cons` returns.\n<|/ c |>\n\
    <| c |>\nI like this solution as well, but I prefer `each_cons(2)` over `each_cons(2..l.size)`\
    \ because `each_cons(2..l.size)` will create an intermediate array that gets garbage\
    \ collected as soon as `each_cons` returns.\n<|/ c |>\n<| a dscore=5 tags=ruby,sorting,arrays\
    \ |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if a.nil?\
    \ || b.nil? || a > b\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n\
    \    return false if b < a\n  end\n  true\nend", "  l.sort!\n  return l.first\
    \ <= l.last\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if\
    \ y > x\n  end\n  true\nend", "  l.sort!\n  return l[1] < l[-1]\nend", "  l.sort!\n\
    \  l.each_with_index do |x, i|\n    return false if l[i-1] > x\n  end\n  true\n\
    end\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution, because it doesn't\
    \ require any additional libraries. However, it does require a little more memory\
    \ than other solutions, because of the additional array allocations.\n<|/ c |>\n\
    <| c |>\nThis solution is also very fast. Thanks!\n<|/ c |>\n<| c |>\nThis solution\
    \ is also very fast. Thanks!\n<|/ c |>\n<| c |>\nThis solution is also very fast.\
    \ Thanks!\n<|/ c |>\n<| c |>\nThis solution is also very fast. Thanks!\n<|/ c\
    \ |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if b < a\n  end\n  true\nend", "  return l.all?\
    \ or l.all? { |x| x.succ <= x.pred }\nend", "  l.sort!\n  l.each_cons(2) do |a,\
    \ b|\n    return false if b < a\n  end\n  true\nend", "  l.sort!\n  return l[-1]\
    \ < l[0]\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y >\
    \ x\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\n\
    This doesn't work if you have a list like `[1, 1, 2, 3]`\n<|/ c |>\n<| c |>\n\
    Yes, it does. Try it out. `[1, 1, 2, 3].sort!; [1, 1, 2, 3].each_cons(2).all?\
    \ { |x, y| y > x }; true` returns `true`.\n<|/ c |>\n<| c |>\nYes, it does. Try\
    \ it out. `[1, 1, 2, 3].sort!; [1, 1, 2, 3].each_cons(2).all? { |x, y| y > x };\
    \ true` returns `true`.\n<|/ c |>\n<| c |>\nYes, it does. Try it out. `[1, 1,\
    \ 2, 3].sort!; [1, 1, 2, 3].each_cons(2).all? { |x, y| y > x }; true` returns\
    \ `true`.\n<|/ c |>\n<| c |>\nYes, it does. Try it out. `[1, 1, 2, 3].sort!; [1,\
    \ 1, 2, 3].each_cons(2).all? { |x, y| y > x }; true` returns `true`.\n<|/ c |>\n\
    <| a dscore=5 |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false\
    \ if b < a or b == a and a < 0\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y > x\n  end\n  true\nend\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nI like this solution, but I wonder if it would be more efficient\
    \ to sort the list once and compare each element against the previous one?\n<|/\
    \ c |>\n<| c |>\n: I doubt it would be, since sorting is O(n log n), but comparing\
    \ each element is O(n).\n<|/ c |>\n<| c |>\n: I doubt it either, since sorting\
    \ is O(n log n), but comparing each element is O(n).\n<|/ c |>\n<| c |>\n: I doubt\
    \ it either, since sorting is O(n log n), but comparing each element is O(n).\n\
    <|/ c |>\n<| c |>\n: I doubt it either, since sorting is O(n log n), but comparing\
    \ each element is O(n).\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  return l.all?\
    \ or l.all? { |x| x.succ <= x.pred }\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n\
    \    return false if y <= x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if a.nil? || b.nil? || a > b\n  end\n  true\nend",
  "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if b < a\n    return true\
    \ if a < b\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return\
    \ false if b < a\n    return true if a < b\n  end\n  true\nend", "  l.sort!\n\
    \  return l[0] < l[-1]\nend", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return\
    \ false if b < a\n  end\n  true\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like\
    \ your solution. Very elegant. Thanks!\n<|/ c |>\n<| c |>\nI like your solution.\
    \ Very elegant. Thanks!\n<|/ c |>\n<| c |>\nI like your solution. Very elegant.\
    \ Thanks!\n<|/ c |>\n<| c |>\nI like your solution. Very elegant. Thanks!\n<|/\
    \ c |>\n<| c |>\nI like your solution. Very elegant. Thanks!\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if a.nil?\
    \ || b.nil?\n    return false if a.last < b.last\n  end\n  true\nend", "  l.sort!\n\
    \  l.each_cons(2) do |a, b|\n    return false if a.nil? || b.nil?\n    return\
    \ false if a.last < b.last\n    return false if a.first > b.first\n  end\n  true\n\
    end", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y > x\n  end\n\
    \  true\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return true if a < b\n\
    \    return false if a > b\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if b < a || b == a\n  end\n  true\nend", "  l.sort!\n\
    \  l.each_with_index do |x, i|\n    return false if l[i-1] > x\n  end\n  true\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work for me. `monotonic([4,\
    \ 1, 0, -10])` returns true.\n<|/ c |>\n<| c |>\nIt works for me. `monotonic([4,\
    \ 1, 0, -10])` returns false.\n<|/ c |>\n<| c |>\nI guess I should have mentioned\
    \ that I'm on ruby 1.9.3p194. I'll try it on 1.9.3p194.\n<|/ c |>\n<| c |>\nI\
    \ added a note about 1.9.3p194.\n<|/ c |>\n<| c |>\nI added a note about 1.9.3p194.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a,b|\n \
    \   return false if b < a\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do\
    \ |a, b|\n    return false if b < a\n  end\n  true\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis does not work if you have a list with duplicates. For example, `monotonic([1,\
    \ 1, 2, 3])` returns `true` instead of `false`.\n<|/ c |>\n<| c |>\nI believe\
    \ this fails for `monotonic([1, 1, 2, 3])` because `[1, 1, 2, 3]` sorts to `[1,\
    \ 2, 3]` and then `[1, 2, 3]` sorts to `[1, 3, 2]`, which is not monotonic.\n\
    <|/ c |>\n<| c |>\nI believe this fails for `monotonic([1, 1, 2, 3])` because\
    \ `[1, 1, 2, 3]` sorts to `[1, 2, 3]` and then `[1, 2, 3]` sorts to `[1, 3, 2]`,\
    \ which is not monotonic.\n<|/ c |>\n<| c |>\nI believe this fails for `monotonic([1,\
    \ 1, 2, 3])` because `[1, 1, 2, 3]` sorts to `[1, 2, 3]` and then `[1, 2, 3]`\
    \ sorts to `[1, 3, 2]`, which is not monotonic.\n<|/ c |>\n<| c |>\nI believe\
    \ this fails for `monotonic([1, 1, 2, 3])` because `[1, 1, 2, 3]` sorts to `[1,\
    \ 2, 3]` and then `[1, 2, 3]` sorts to `[1, 3, 2]`, which is not monotonic.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "  l.sort!\n  return l[1] < l[-1]\nend",
  "  return l.all? && l.all? { |x| x.to_i < x.to_i }\nend", "  return l.all? or l.all?\
    \ { |x| x.all? { |y| y > x } }\nend", "  l.sort!\n  l.each_with_index do |x, i|\n\
    \    return false if l[i-1] < x\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if you have duplicate elements in the array.\
    \ For example, `[1, 1, 2]` returns `true` but should be `false`.\n<|/ c |>\n<|\
    \ c |>\n: It doesn't work if you have duplicate elements in the array. For example,\
    \ `[1, 1, 2]` returns `true` but should be `false`.\n<|/ c |>\n<| c |>\n: It doesn't\
    \ work if you have duplicate elements in the array. For example, `[1, 1, 2]` returns\
    \ `true` but should be `false`.\n<|/ c |>\n<| c |>\n: It doesn't work if you have\
    \ duplicate elements in the array. For example, `[1, 1, 2]` returns `true` but\
    \ should be `false`.\n<|/ c |>\n<| c |>\n: It doesn't work if you have duplicate\
    \ elements in the array. For example, `[1, 1, 2]` returns `true` but should be\
    \ `false`.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return true if y > x\n  end\n  false\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if b < a\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y > x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y <= x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if x == y\n    return true if x > y\n  end\n  true\n\
    end", "  return l.all? or (l.all? and l.all? and l.reverse.all?)\nend", "  l.sort!\n\
    \  l.each_cons(2) do |x,y|\n    return false if y > x\n  end\n  true\nend", " \
    \ l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y < x\n  end\n  true\n\
    end", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y > x\n  end\n\
    \  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y <=\
    \ x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false\
    \ if x == y\n    return true if x > y\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y < x\n  end\n  true\nend", "  return l.all? or\
    \ (l.all? and l.all? and l.reverse.all? and l.reverse >= l)\nend", "  l.sort!\n\
    \  l.each_cons(2) do |x,y|\n    return false if y > x\n  end\n  true\nend", " \
    \ return l.all? or l.all? { |x| x.all? { |y| y > x } }\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y <= x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if b < a\n  end\n  true\nend", "  l.sort!\n  l.each_with_index\
    \ do |x, i|\n    return false if l[i-1] > x\n  end\n  true\nend", "  l.sort!\n\
    \  l.each_cons(2) do |x,y|\n    return false if y > x\n  end\n  true\nend\n</code>\n\
    <|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThis doesn't work if you have a list\
    \ like `[1, 1, 2, 3]`\n<|/ c |>\n<| c |>\n: Yes, it does. Try it yourself.\n<|/\
    \ c |>\n<| c |>\n: It does. Try it yourself.\n<|/ c |>\n<| c |>\n: It does. Try\
    \ it yourself.\n<|/ c |>\n<| c |>\n: It does. Try it yourself.\n<|/ c |>\n<| a\
    \ tags=ruby,arrays,sorting |>\n<code>", "  l.sort!\n  l.each_cons(2) do |x,y|\n\
    \    return false if y > x\n  end\n  true\nend\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nThis is very clever. Thanks for sharing!\n<|/ c |>\n<| c |>\nThis is very\
    \ clever. Thanks for sharing!\n<|/ c |>\n<| a dscore=3 |>\n<code>", '  return
    l.all? or (l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all?
    and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and
    l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all?
    and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and
    l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all?
    and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and
    l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all?
    and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and
    l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all?
    and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and
    l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all?
    and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and
    l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all?
    and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and
    l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all?
    and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and
    l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? and l.all? ',
  "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y > x\n  end\n  true\n\
    end\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| a dscore=2 |>\n<code>", " \
    \ l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y > x\n  end\n  true\n\
    end", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return true if y > x\n  end\n\
    \  false\nend", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if b\
    \ < a\n  end\n  true\nend", "  l.sort!\n  return l[0] < l[-1]\nend", "  l.sort!\n\
    \  l.each_cons(2) do |x,y|\n    return false if x <= y\n  end\n  true\nend", " \
    \ l.sort!\n  l.each_cons(2) do |a, b|\n    return false if b < a\n    return true\
    \ if a < b\n  end\n  true\nend", "  l.sort!\n  l.each_with_index { |e, i| return\
    \ false if i > 0 && e <= l[i-1] }\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if a.nil? || b.nil? || a > b\n  end\n  true\nend",
  "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if x < y\n  end\n  true\n\
    end\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThis doesn't work for\
    \ `monotonic([4, 1, 0, -10])` because `-10` is greater than `1`.\n<|/ c |>\n<|\
    \ c |>\nI didn't say it wouldn't. `-10` is greater than `1`, but `-10` is less\
    \ than `4`. `monotonic([4, 1, 0, -10])` returns `true` because `-10` is greater\
    \ than `1`.\n<|/ c |>\n<| c |>\nI see what you mean. I misread the question. My\
    \ apologies.\n<|/ c |>\n<| a dscore=4 |>\n<code>", "  return l.all? or l.all?\
    \ { |x| x.succ <= x.pred }\nend", "  l.sort!\n  l.each_cons(2) do |a, b|\n   \
    \ return false if b < a\n    return true if a < b\n  end\n  true\nend", "  l.sort!\n\
    \  l.each_cons(2) do |x,y|\n    return true if y > x\n  end\n  false\nend", " \
    \ return l.all? or l.all? { |e| e > l.min }\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return true if y > x\n  end\n  false\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if b < a\n    return true if a < b\n  end\n  true\n\
    end", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if a.nil? || b.nil?\
    \ || a > b\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return\
    \ true if y > x\n  end\n  false\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n\
    \    return false if y <= x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y > x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if b < a\n    return true if a < b\n  end\n  true\n\
    end\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nI like your solution,\
    \ however it fails for `monotonic([4, 1, 0, -10])` which returns `true` when it\
    \ should return `false`.\n<|/ c |>\n<| c |>\n: I fixed the bug. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| c |>\n: I added a more efficient solution that doesn't\
    \ require sorting.\n<|/ c |>\n<| c |>\n: I added a more efficient solution that\
    \ doesn't require sorting.\n<|/ c |>\n<| c |>\n: I added a more efficient solution\
    \ that doesn't require sorting.\n<|/ c |>\n<| a dscore=3 |>\n<code>", "  l.sort!\n\
    \  l.each_cons(2) do |a, b|\n    return false if b < a or b == a\n  end\n  true\n\
    end", "  l.sort!\n  return l[-1] < l[0]\nend", "  l.sort!\n  l.each_cons(2) do\
    \ |x,y|\n    return true if y > x\n  end\n  false\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis doesn't work for `monotonic([4, 1, 0, -10])` which returns true.\n\
    <|/ c |>\n<| c |>\nI fixed the bug, thanks for pointing it out. Now it works as\
    \ expected.\n<|/ c |>\n<| c |>\nI believe this fails for `monotonic([4, 1, 0,\
    \ -10])` because `[4, 1, 0, -10]` has two negative numbers and one positive number.\
    \ `[4, 1, -10, 0]` has three negative numbers and two positive numbers. `[4, 1,\
    \ -10, 0]` has three negative numbers and one positive number. `[4, 1, -10, 0]`\
    \ has three negative numbers and one positive number. `[4, 1, -10, 0]` has three\
    \ negative numbers and one positive number. `[4, 1, -10, 0]` has three negative\
    \ numbers and one positive number. `[4, 1, -10, 0]` has three negative numbers\
    \ and one positive number. `[4, 1, -10, 0]` has three negative numbers and one\
    \ positive number. `[4, 1, -10, 0]` has three negative numbers and one positive\
    \ number. `[4, 1, -10, 0]` has three negative numbers and one positive number.\
    \ `[4, 1, -10, 0]` has three negative numbers and one positive number. `[4, 1,\
    \ -10, 0]` has three negative numbers and one positive number. `[4, 1, -10, 0]`\
    \ has three negative numbers and one positive number. `[4, 1, -10, 0]` has three\
    \ negative numbers and one positive number. `[4, 1, -10, 0]` has three negative\
    \ numbers and one positive number. `[4, 1, -10, 0]` has three negative numbers\
    \ and one positive number. `[4, 1, -10, 0]` has three negative numbers and one\
    \ positive number. `[4, 1, -10, 0]` has three negative numbers and one positive\
    \ number. `[4, 1, -10, 0]` has three negative numbers and one positive number.\
    \ `[4, 1, -10, 0]` has three negative numbers and one positive number. `[4, 1,\
    \ -10, 0]` has three negative numbers and one positive number. `[4, 1, -10, 0]`\
    \ has three negative numbers and one positive number. `[4, 1, -10, 0]` has three\
    \ negative numbers and one positive number. `[4, 1, -10, 0]` has three negative\
    \ numbers and ", "  return l.all? or l.all? { |x| x.succ <= x.pred }\nend", " \
    \ l.sort!\n  l.each_cons(2) do |x,y|\n    return false if x <= y\n  end\n  true\n\
    end", "  l.sort!\n  l.each_with_index do |x, i|\n    return false if l[i-1] <\
    \ x\n  end\n  true\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work\
    \ if you have a list of negative numbers. `monotonic([-1, -10, -5, -20, -4, -15,\
    \ -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5,\
    \ -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4,\
    \ -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10,\
    \ -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20,\
    \ -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15,\
    \ -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5,\
    \ -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4,\
    \ -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10,\
    \ -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20,\
    \ -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15,\
    \ -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5,\
    \ -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4,\
    \ -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -10, -5, -20, -4, -15, -",
  "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if a.nil? || b.nil? ||\
    \ a > b\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return\
    \ false if b < a\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n\
    \    return false if y < x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return true if y > x\n  end\n  false\nend", "  l.sort!\n  l.each_with_index\
    \ { |e,i| return false if e<l[i-1] }\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y > x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y > x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if a.nil? || b.nil? || a > b\n  end\n  true\nend",
  "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y > x\n  end\n  true\n\
    end", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return true if y > x\n  end\n\
    \  false\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if a.nil?\
    \ || b.nil?\n    return false if a.last < b.last\n  end\n  true\nend", "  l.sort!\n\
    \  l.each_cons(2) do |x,y|\n    return false if x < y\n  end\n  true\nend", " \
    \ l.sort!\n  l.each_cons(2) do |a, b|\n    return false if b < a\n  end\n  true\n\
    end\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work for\
    \ `monotonic([4, 1, 0, -10])` which returns `true` when it should return `false`.\n\
    <|/ c |>\n<| c |>\nI agree with you. I've added a note to my answer.\n<|/ c |>\n\
    <| a dscore=4 |>\n<code>", "  return l.all? or l.all? { |x| x.succ <= x.pred }\n\
    end", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if a.nil? || b.nil?\
    \ || a < b\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return\
    \ false if y <= x\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are duplicates in the array. For example,\
    \ `monotonic([1,1,2,3,4])` returns `true` instead of `false`.\n<|/ c |>\n<| c\
    \ |>\n: Yes, it does. `monotonic([1,1,2,3,4])` returns `false` because `1` is\
    \ less than `1`.\n<|/ c |>\n<| c |>\n: I see what you mean. Yes, I see that now.\
    \ Thanks for pointing that out. I've updated my answer.\n<|/ c |>\n<| c |>\n:\
    \ I see what you mean. Yes, I see that now. Thanks for pointing that out. I've\
    \ updated my answer.\n<|/ c |>\n<| c |>\n: I see what you mean. Yes, I see that\
    \ now. Thanks for pointing that out. I've updated my answer.\n<|/ c |>\n<| a |>\n\
    <code>", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if b < a\n \
    \ end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if\
    \ a.nil? || b.nil? || a > b\n    return true if a < b\n  end\n  true\nend", " \
    \ l.sort!\n  l.each_cons(2) do |x,y|\n    return false if x <= y\n  end\n  true\n\
    end", "  l.sort!\n  return l[1] < l[-1]\nend", "  l.sort!\n  l.each_cons(2) do\
    \ |a, b|\n    return false if a.nil? || b.nil? || a > b\n  end\n  true\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\n`each_cons` doesn't work in Ruby 1.8.7.\
    \ `each_slice` does.\n<|/ c |>\n<| c |>\n: Yes, I know. That's why I wrote \"\
    in Ruby 1.8.7\".\n<|/ c |>\n<| c |>\n`each_cons` doesn't work in Ruby 1.8.7. `each_slice`\
    \ does.\n<|/ c |>\n<| c |>\n: Yes, I know. That's why I wrote \"in Ruby 1.8.7\"\
    .\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  l.sort!\n  l.each_cons(2) do |x,y|\n\
    \    return false if y > x\n  end\n  true\nend", "  return l.all? or l.all? {\
    \ |x| x.all? { |y| y > x } }\nend", "  l.sort!\n  l.each_with_index { |e, i| return\
    \ false if i > 0 && e <= l[i-1] }\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y > x\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,arrays\
    \ |>\n<| c |>\nThis doesn't work for `monotonic([4, 1, 0, -10])`, which returns\
    \ `true` when it should return `false`.\n<|/ c |>\n<| c |>\nIt doesn't work for\
    \ monotonic([4, 1, 0, -10]) because `-10` is greater than `1`.\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work for monotonic([4, 1, 0, -10]) because `-10` is greater than\
    \ `1`.\n<|/ c |>\n<| c |>\nIt doesn't work for monotonic([4, 1, 0, -10]) because\
    \ `-10` is greater than `1`.\n<|/ c |>\n<| c |>\nIt doesn't work for monotonic([4,\
    \ 1, 0, -10]) because `-10` is greater than `1`.\n<|/ c |>\n<| a dscore=4 |>\n\
    <code>", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return true if y > x\n  end\n\
    \  false\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution, but\
    \ I wonder if it can be made more efficient. Sorting is a O(n log n) operation,\
    \ so if there are many elements in the list this will be very inefficient.\n<|/\
    \ c |>\n<| c |>\n: I agree, sorting is O(n log n), but this algorithm is O(n),\
    \ so it's better than sorting.\n<|/ c |>\n<| c |>\n: I added a O(n) solution,\
    \ using an auxiliary array and binary search. Hope it helps.\n<|/ c |>\n<| c |>\n\
    : I added a O(n) solution, using an auxiliary array and binary search. Hope it\
    \ helps.\n<|/ c |>\n<| c |>\n: I added a O(n) solution, using an auxiliary array\
    \ and binary search. Hope it helps.\n<|/ c |>\n<| a |>\n<code>", "  l.sort!\n\
    \  l.each_cons(2) do |a, b|\n    return false if a.nil? || b.nil?\n    return\
    \ false if a.last < b.last\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if b < a\n  end\n  true\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work if you have a list like `[1, 1, 2, 3]`\n<|/ c |>\n\
    <| c |>\n: It works fine for me. `[1, 1, 2, 3]` returns `true`.\n<|/ c |>\n<|\
    \ c |>\nI meant that it doesn't work if you have a list like `[1, 1, 2, 3]`\n\
    <|/ c |>\n<| c |>\n: It returns `true` for `[1, 1, 2, 3]` as well.\n<|/ c |>\n\
    <| c |>\n: It returns `true` for `[1, 1, 2, 3]` as well.\n<|/ c |>\n<| a dscore=5\
    \ tags=ruby,sorting |>\n<code>", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return\
    \ false if b < a\n  end\n  true\nend\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis\
    \ doesn't work for me. `monotonic([1,4,2,5])` returns true, but `monotonic([1,4,2,5])`\
    \ returns false. I'm on ruby 1.9.3p194 (2012-04-20 revision 35410) [x86_64-darwin10.8.0]\n\
    <|/ c |>\n<| c |>\nI tested this in 1.9.3p194 on Mac OS X 10.7.5 and it worked\
    \ fine. Are you sure you copied the code correctly? I tested it again and it worked\
    \ fine.\n<|/ c |>\n<| c |>\nYeah, I copied it exactly. I'm running 1.9.3p194 on\
    \ Mac OS X 10.7.5\n<|/ c |>\n<| c |>\nI tested it on 1.9.3p194 on Mac OS X 10.7.5\
    \ and it worked fine. Are you sure you copied the code correctly? I tested it\
    \ again and it worked fine.\n<|/ c |>\n<| c |>\nYeah, I copied it exactly. I'm\
    \ running 1.9.3p194 on Mac OS X 10.7.5\n<|/ c |>\n<| a dscore=5 |>\n<code>", " \
    \ l.sort!\n  l.each_cons(2) do |x,y|\n    return true if y > x\n  end\n  false\n\
    end\n</code>\n<|/ a tags=ruby,arrays |>\n<| c |>\nThis doesn't work if you have\
    \ a list of negative numbers. `monotonic([-4, -20, -10, -5, -15, -10, -5, -10,\
    \ -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5,\
    \ -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10,\
    \ -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5,\
    \ -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10,\
    \ -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5,\
    \ -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10,\
    \ -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5,\
    \ -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10,\
    \ -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5,\
    \ -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10,\
    \ -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5,\
    \ -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10,\
    \ -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -5, -10, -", "  l.sort!\n\
    \  l.each_cons(2) do |x,y|\n    return false if x < y\n  end\n  true\nend", " \
    \ l.sort!\n  l.each_cons(2) do |x,y|\n    return true if y > x\n  end\n  false\n\
    end", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if a.nil? || b.nil?\
    \ || a > b\n  end\n  true\nend\n</code>\n<|/ a tags=ruby,sorting |>\n<| c |>\n\
    This doesn't work if you have a list like `[1, 1, 1]`\n<|/ c |>\n<| c |>\n: It\
    \ does. Try it yourself.\n<|/ c |>\n<| c |>\n: It does. Try it yourself. `[1,\
    \ 1, 1]` returns `true`.\n<|/ c |>\n<| c |>\n: It does. Try it yourself. `[1,\
    \ 1, 1]` returns `true`.\n<|/ c |>\n<| c |>\n: It does. Try it yourself. `[1,\
    \ 1, 1]` returns `true`.\n<|/ c |>\n<| a |>\n<code>", "  l.sort!\n  l.each_cons(2)\
    \ do |a,b|\n    return true if a > b\n  end\n  false\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return true if y > x\n  end\n  false\nend", "  return l.all? or\
    \ l.all? { |x| x.succ <= x.pred }\nend", "  l.sort!\n  l.each_cons(2) do |a, b|\n\
    \    return false if a.nil? || b.nil?\n    return false if a.succ < b.succ ||\
    \ (a.succ === b.succ && a.pred < b.pred)\n  end\n  true\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  l.sort!\n  l.each_with_index\
    \ { |e,i| return false if e<l[i-1] }\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y > x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a,b|\n    return false if b < a\n  end\n  true\nend", "  l.sort!\n  return\
    \ l.all? { |x| x >= l[0] }\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return\
    \ false if y > x\n  end\n  true\nend", "  l.sort!\n  return l[-1] < l[0]\nend",
  "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y > x\n  end\n  true\n\
    end", "  l.sort!\n  return l[0] < l[-1]\nend", "  l.sort!\n  l.each_cons(2) do\
    \ |x,y|\n    return true if y > x\n  end\n  false\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if a.nil? || b.nil? || a > b\n  end\n  true\nend\n\
    </code>\n<|/ a tags=ruby,arrays |>\n<| a dscore=1 |>\n<code>", "  l.sort!\n  return\
    \ l[-1] < l[0]\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false\
    \ if y > x\n  end\n  true\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't\
    \ work for `monotonic([4, 1, 0, -10])` because `-10` is greater than `1`.\n<|/\
    \ c |>\n<| c |>\n: Thanks, I fixed the example.\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return true if y > x\n  end\n\
    \  false\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return false if y >\
    \ x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return true\
    \ if y > x\n  end\n  false\nend", "  return l.all? or l.all? { |e| e > l[0] }\n\
    end", "  l.sort!\n  return l[0] < l[-1]\nend", "  l.sort!\n  l.each_cons(2) do\
    \ |a, b|\n    return false if a.nil? || b.nil? || a > b\n  end\n  true\nend",
  "  l.sort!\n  l.each_cons(2) do |a, b|\n    return false if a.nil? || b.nil? ||\
    \ a > b\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |a, b|\n    return\
    \ false if b < a\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |a, b|\n\
    \    return false if a.nil? || b.nil?\n    return false if a.nil? && b.nil?\n\
    \    return false if b.nil? && a.nil?\n    return false if a.nil? || b.nil? ||\
    \ a < b\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2) do |x,y|\n    return\
    \ true if x<y\n  end\n  false\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like\
    \ your answer, but I think it would be more efficient to just do `l.sort!; l.each_cons(2)\
    \ do |x,y|; return true if x<y; end; false`\n<|/ c |>\n<| c |>\nYeah, that would\
    \ work too. My code was more to show how it works, not necessarily be the most\
    \ efficient code.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  l.sort!\n  l.each_cons(2)\
    \ do |x,y|\n    return false if y < x\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a,b|\n    return false if b < a\n    return true if a < b\n  end\n  true\n\
    end\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThis doesn't work for\
    \ `monotonic([4, 1, 0, -10])`\n<|/ c |>\n<| c |>\n: It works for me. `monotonic([4,\
    \ 1, 0, -10])` returns `true`.\n<|/ c |>\n<| c |>\n: It works for me too. `monotonic([4,\
    \ 1, 0, -10])` returns `true`.\n<|/ c |>\n<| c |>\n: It works for me too. `monotonic([4,\
    \ 1, 0, -10])` returns `true`.\n<|/ c |>\n<| c |>\n: It works for me too. `monotonic([4,\
    \ 1, 0, -10])` returns `true`.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  return\
    \ l.all? or l.all? { |e| e > l.first }\nend", "  l.sort!\n  l.each_cons(2) do\
    \ |a, b|\n    return false if b < a\n  end\n  true\nend", "  l.sort!\n  l.each_cons(2)\
    \ do |a, b|\n    return false if b < a\n    return true if a < b\n  end\n  true\n\
    end", "  l.sort!\n  l.each_cons(2) do |a,b|\n    return false if b < a\n  end\n\
    \  true\nend\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like the idea of using each_cons\
    \ to find the first and last elements of the list, but this doesn't work if the\
    \ list contains duplicates.\n<|/ c |>\n<| c |>\n: It doesn't work if the list\
    \ contains duplicates. `each_cons` doesn't remove duplicates.\n<|/ c |>\n<| c\
    \ |>\n: It doesn't work if the list contains duplicates. `each_cons` doesn't remove\
    \ duplicates.\n<|/ c |>\n<| c |>\n: It doesn't work if the list contains duplicates.\
    \ `each_cons` doesn't remove duplicates.\n<|/ c |>\n<| c |>\n: It doesn't work\
    \ if the list contains duplicates. `each_cons` doesn't remove duplicates.\n<|/\
    \ c |>\n<| a |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
