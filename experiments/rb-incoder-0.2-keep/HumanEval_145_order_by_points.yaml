name: HumanEval_145_order_by_points
language: ruby
prompt: "# Write a function which sorts the given list of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ list.\n# For example:\n# >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11,\
  \ 1, -12, 11]\n# >>> order_by_points([]) == []\ndef order_by_points(nums)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_order_by_points\n\
  \    candidate = method(:order_by_points)\n    assert_equal([-1, -11, 1, -12, 11],\
  \ candidate.call([1, 11, -1, -11, -12]))\n    assert_equal([0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457], candidate.call([1234, 423, 463, 145,\
  \ 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]))\n    assert_equal([], candidate.call([]))\n\
  \    assert_equal([-3, -32, -98, -11, 1, 2, 43, 54], candidate.call([1, -11, -32,\
  \ 43, 54, -98, 2, -3]))\n    assert_equal([1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9], candidate.call([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]))\n    assert_equal([-76, -21, 0, 4, 23, 6, 6],\
  \ candidate.call([0, 6, 6, -76, -21, 23, 4]))\n  end\nend\n"
completions: ["  nums.sort! do |a,b|\n    sum = (a + b).to_i\n    sum == 0 ? a : b\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = num.to_i\n\
    \    j = nums.index{|n| n.to_i == i}\n    if j != nil\n      nums.insert(j, num)\n\
    \    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if i == 0 ||\
    \ digits < nums[i-1].to_s.chars.map(&:to_i).inject(:+).abs\n      nums[i] = n\n\
    \    end\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c\
    \ |>\nThis doesn't work if you have negative numbers in the array.\n<|/ c |>\n\
    <| c |>\n: I didn't see that requirement in the question. I'll update my answer\
    \ to include a solution for negative numbers.\n<|/ c |>\n<| c |>\n: I updated\
    \ my answer to include a solution for negative numbers.\n<|/ c |>\n<| c |>\n:\
    \ I updated my answer to include a solution for negative numbers.\n<|/ c |>\n\
    <| c |>\n: I updated my answer to include a solution for negative numbers.\n<|/\
    \ c |>\n<| a dscore=3 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  i = 0\n  while i < nums.length\n    j = i + 1\n    while j < nums.length\n\
    \      if nums[j].to_s == nums[i].to_s\n        nums[j], nums[i] = nums[i], nums[j]\n\
    \      end\n      j += 1\n    end\n    i += 1\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |n|\n    sum = 0\n    n.to_s.split('').each do\
    \ |c|\n      sum += c.to_i\n    end\n    n.to_s = sum\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = 0\
    \ if digits < 0\n    digits = digits if digits > 9\n    n.to_s = digits.to_s\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i\
    \ }\nend", "  nums.sort!\n  nums.each_with_index do |n, i|\n    break if nums[i]\
    \ == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    sum = 0\n    while n > 0 do\n      sum += n % 10\n  \
    \    n /= 10\n    end\n    sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    break if nums.sum == n\n    nums.delete_at(0)\n  end\n\
    \  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't\
    \ work if there are multiple numbers with the same sum.\n<|/ c |>\n<| c |>\nYes,\
    \ I know. That's why I wrote \"if there are several items with similar sum of\
    \ their digits, order them based on their index in original list.\"\n<|/ c |>\n\
    <| c |>\nI see what you mean. My mistake.\n<|/ c |>\n<| c |>\nThis doesn't work\
    \ if there are multiple numbers with the same sum.\n<|/ c |>\n<| c |>\nI see what\
    \ you mean. My mistake.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums[i]\
    \ == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort!\n  i = 0\n  while i < nums.length\n    sum\
    \ = 0\n    j = i + 1\n    while j < nums.length\n      sum += nums[j].to_i\n \
    \     j += 1\n    i += 1\n    nums[i], nums[sum] = nums[sum], nums[i]\n  end\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = nums.index\
    \ {|n| n.to_s.split(\"\").sum.to_i == num.to_s.split(\"\").sum.to_i }\n    nums[i]\
    \ = num\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n,i|\n    if nums[i]\
    \ == 0 then\n      nums.delete_at(i)\n      nums.unshift(n)\n    end\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    sum = 0\n\
    \    n.to_s.split('').each do |c|\n      sum += c.to_i\n    end\n    n.to_s =\
    \ sum\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\n\
    This doesn't work if you have negative numbers, e.g. `[-1,-1,-1,-1,-1]`\n<|/ c\
    \ |>\n<| c |>\nYes, it does. I tested it before posting. Try it yourself.\n<|/\
    \ c |>\n<| c |>\nI tested it before posting, but I didn't know that negative numbers\
    \ would cause problems. I thought they would just be ignored, not moved to the\
    \ end of the list. Thanks for pointing that out.\n<|/ c |>\n<| c |>\nI tested\
    \ it before posting, but I didn't know that negative numbers would cause problems.\
    \ I thought they would just be ignored, not moved to the end of the list. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| c |>\nI tested it before posting, but I\
    \ didn't know that negative numbers would cause problems. I thought they would\
    \ just be ignored, not moved to the end of the list. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n \
    \ nums.reverse!\n  nums.each do |num|\n    break if num == 0 # avoid 0\n    break\
    \ if nums.sum < num # avoid duplicates\n    break if nums.sum > num # avoid duplicates\n\
    \    break if nums.sum == num # avoid duplicates\n    nums.delete(num)\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits\
    \ = num.to_s.split(//).map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs % 10\n    if digits > num\n      nums.insert(nums.index(num),\
    \ num)\n    end\n  end\n  nums\nend", "  nums.sort!\n  i = 0\n  while i < nums.length\n\
    \    j = i + 1\n    while j < nums.length\n      k = j + 1\n      while k < nums.length\n\
    \        if nums[k] < nums[j] + nums[i]\n          nums[k], nums[j] = nums[j],\
    \ nums[k]\n          j, k = k, j\n        end\n        k += 1\n      end\n   \
    \   j += 1\n    end\n    i += 1\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n  end\nend\n</code>\n\
    <|/ a tags=ruby,sorting |>\n<| a tags=ruby,sorting |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |num, i|\n    break if num == 0 &&\
    \ nums.size == i\n    nums[i] = num\n  end\n  nums\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis doesn't work for negative numbers. `order_by_points([-1, -10, -20,\
    \ -30])` returns `[-10, -30, -20, -1]`\n<|/ c |>\n<| c |>\nIt doesn't work for\
    \ negative numbers, because `-10 + (-10) == -10`\n<|/ c |>\n<| c |>\nIt works\
    \ for negative numbers, because `-10` is less than `-10` according to `<`. `-10\
    \ < -10` is true.\n<|/ c |>\n<| c |>\nIt works for negative numbers, because `-10`\
    \ is less than `-10` according to `<`. `-10 < -10` is true.\n<|/ c |>\n<| c |>\n\
    It works for negative numbers, because `-10` is less than `-10` according to `<`.\
    \ `-10 < -10` is true.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  nums.sort!\n \
    \ nums.reverse!\n  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |n|\n    sum = 0\n    while n > 0\n      sum += n % 10\n      n /= 10\n \
    \   end\n    sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if num.zero?\n \
    \   break if num.odd?\n    break if num.even?\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    sum = 0\n    while num > 0\n     \
    \ sum += num % 10\n      num /= 10\n    end\n    sum\n  end\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if nums.sum == num\n    nums.delete(num)\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n   \
    \ break if n.digits.sum != n.digits.reduce(:+)\n    break if n.digits.sum > 0\n\
    \    break if n.digits.sum < 0\n    break if n.digits.sum == 0\n    break if n.digits.sum\
    \ == 1\n    break if n.digits.sum == 2\n    break if n.digits.sum == 3\n    break\
    \ if n.digits.sum == 4\n    break if n.digits.sum == 5\n    break if n.digits.sum\
    \ == 6\n    break if n.digits.sum == 7\n    break if n.digits.sum == 8\n    break\
    \ if n.digits.sum == 9\n    break if n.digits.sum == 10\n    break if n.digits.sum\
    \ == 11\n    break if n.digits.sum == 12\n    break if n.digits.sum == 13\n  \
    \  break if n.digits.sum == 14\n    break if n.digits.sum == 15\n    break if\
    \ n.digits.sum == 16\n    break if n.digits.sum == 17\n    break if n.digits.sum\
    \ == 18\n    break if n.digits.sum == 19\n    break if n.digits.sum == 20\n  \
    \  break if n.digits.sum == 21\n    break if n.digits.sum == 22\n    break if\
    \ n.digits.sum == 23\n    break if n.digits.sum == 24\n    break if n.digits.sum\
    \ == 25\n    break if n.digits.sum == 26\n    break if n.digits.sum == 27\n  \
    \  break if n.digits.sum == 28\n    break if n.digits.sum == 29\n    break if\
    \ n.digits.sum == 30\n    break if n.digits.sum == 31\n    break if n.digits.sum\
    \ == 32\n    break if n.digits.sum == 33\n    break if n.digits.sum == 34\n  \
    \  break if n.digits.sum == 35\n    break if n.digits.sum == 36\n    break if\
    \ n.digits.sum == 37\n    break if n.digits.sum == 38\n    break if n.digits.sum\
    \ == 39\n    break if n.digits.sum == 40\n    break if n.digits.sum == 41\n  \
    \  break if n.digits.sum == 42\n    break if n.digits.sum == 43\n    break if\
    \ n.digits.sum == 44\n    break if n.digits.sum == 45\n    break if n.digits.sum\
    \ == 46\n    break if n.digits.sum == 47\n    break if n.digits.sum == 48\n  \
    \  break if n.digits.sum == 49\n    break if n.digits.sum == 50\n    break if\
    \ n.digits.sum == 51\n    break if n.digits.sum == 52\n    break", "  nums.sort!\
    \ { |a, b| a.to_i + b.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    break if nums.sum == num\n    nums.delete_at(nums.index(num))\n\
    \  end\n  nums\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums.sum == i\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |n|\n    break if n.zero?\n    break if n.odd?\n\
    \    break if n.even?\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n \
    \ nums.each do |num|\n    sum = 0\n    i = num\n    while i > 0\n      sum +=\
    \ i % 10\n      i /= 10\n    end\n    if sum > 0\n      nums.insert(nums.index(num),\
    \ num)\n    end\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n\
    \    break if nums.sum == num\n    nums.delete(num)\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |n|\n    sum = 0\n    n.to_s.split(\"\").each\
    \ do |c|\n      sum += c.to_i\n    end\n    n.to_s = sum\n  end\n  nums\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| c |>\nI like your solution, however it fails for\
    \ `order_by_points([1,11,-1,-11, -12])` which should return `[-1, -11, 1, -12,\
    \ 11]`\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've updated the answer\
    \ to fix the bug.\n<|/ c |>\n<| a |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if i == 0 || digits\
    \ < nums[i-1].to_s.chars.map(&:to_i).inject(:+).abs\n      nums.swap(i, 1)\n \
    \   end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if num.zero?\n \
    \   break if num.odd?\n    break if num.zero? || num.odd? || num.zero? && num.odd?\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do\
    \ |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits > nums[i]\n      nums[i] = n\n    end\n\
    \  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis\
    \ doesn't work if there are two or more numbers with the same sum. For example,\
    \ `order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]` returns `[-1,\
    \ -11, 1, -12, 11]` instead of `[-1, -11, -12, -1, 11]`.\n<|/ c |>\n<| c |>\n\
    , thanks for pointing out. I've updated my answer accordingly.\n<|/ c |>\n<| c\
    \ |>\nThanks for your answer! I did some tests and it seems that this algorithm\
    \ is O(n^2) in the worst case. Do you know any algorithm that can solve this problem\
    \ in O(n)?\n<|/ c |>\n<| c |>\n, I've updated my answer with another solution\
    \ that uses `each_with_index` instead of `sort!` and `reverse!`.\n<|/ c |>\n<|\
    \ c |>\nThanks for your answer! I did some tests and it seems that this algorithm\
    \ is O(n^2) in the worst case. Do you know any algorithm that can solve this problem\
    \ in O(n)?\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    i = num.to_i\n    break if i == 0\n\
    \    i = i / 10\n    nums[i] = num.to_s\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |n|\n    break if n.zero?\n    break if n.odd?\n\
    \    break if n.even?\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n \
    \ nums.each do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n    digits\
    \ = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits > num\n   \
    \   nums.insert(nums.index(num), num)\n    end\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = 0 if digits.zero?\n    digits\
    \ = 1 if digits.zero?\n    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n\
    \    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n    digits =\
    \ 0 if digits.zero?\n    digits = 1 if digits.zero?\n    digits = 0 if digits.zero?\n\
    \    digits = 1 if digits.zero?\n    digits = 0 if digits.zero?\n    digits =\
    \ 1 if digits.zero?\n    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n\
    \    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n    digits =\
    \ 0 if digits.zero?\n    digits = 1 if digits.zero?\n    digits = 0 if digits.zero?\n\
    \    digits = 1 if digits.zero?\n    digits = 0 if digits.zero?\n    digits =\
    \ 1 if digits.zero?\n    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n\
    \    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n    digits =\
    \ 0 if digits.zero?\n    digits = 1 if digits.zero?\n    digits = 0 if digits.zero?\n\
    \    digits = 1 if digits.zero?\n    digits = 0 if digits.zero?\n    digits =\
    \ 1 if digits.zero?\n    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n\
    \    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n    digits =\
    \ 0 if digits.zero?\n    digits = 1 if digits.zero?\n    digits = 0 if digits.zero?\n\
    \    digits = 1 if digits.zero?\n    digits = 0 if digits.zero?\n    digits =\
    \ 1 if digits.zero?\n    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n\
    \    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n    digits =\
    \ 0 if digits.zero?\n    digits = 1 if digits.zero?\n    digits = 0 if digits.zero?\n\
    \    digits = 1 if digits.zero?\n    digits = 0 if digits.zero?\n    digits =\
    \ 1 if digits.zero?\n    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n\
    \    digits = 0 if digits.zero?\n    digits = 1 if digits.zero?\n    digits =\
    \ 0 if digits.zero?\n    digits = 1 if digits.zero?", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.sum - n == 0\n    nums[i]\
    \ = n\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\n\
    This doesn't work if there are negative numbers in the array. Try `order_by_points([1,\
    \ 11, -1, -11, -12])`.\n<|/ c |>\n<| c |>\n, thanks for pointing that out. I've\
    \ updated my answer to account for negative numbers.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work if there are negative numbers in the array. Try `order_by_points([1,\
    \ 11, -1, -11, -12])`.\n<|/ c |>\n<| c |>\n, thanks for pointing that out. I've\
    \ updated my answer to account for negative numbers.\n<|/ c |>\n<| c |>\nThis\
    \ doesn't work if there are negative numbers in the array. Try `order_by_points([1,\
    \ 11, -1, -11, -12])`.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  nums.sort!\n \
    \ nums.reverse!\n  nums.each do |n|\n    break if n.zero?\n    break if n.odd?\n\
    \    break if n.even?\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n \
    \ nums.each_with_index do |n, i|\n    nums[i] = nums[i].to_i\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.map { |n| n.to_i }\nend", "  nums.sort! do |a, b|\n    sum1 = a.to_s.chars.map(&:to_i).inject(:+)\n\
    \    sum2 = b.to_s.chars.map(&:to_i).inject(:+)\n    if sum1 > sum2\n      1\n\
    \    elsif sum1 < sum2\n      -1\n    else\n      0\n    end\n  end\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if there are two\
    \ numbers with the same sum.\n<|/ c |>\n<| c |>\n, thank you for pointing out.\
    \ I've updated my answer.\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if num.zero?\n \
    \   break if num.odd?\n    break if num.zero?\n  end\n  nums\nend", "  nums.sort!\
    \ do |a, b|\n    sum1 = a.to_s.split(//).map(&:to_i).inject(:+)\n    sum2 = b.to_s.split(//).map(&:to_i).inject(:+)\n\
    \    sum1 == sum2 ? a.to_i <=> b.to_i : sum1 < sum2 ? -1 : +1\n  end\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    break if num.zero?\n    break if num.odd?\n    break if num.even?\n\
    \    break if num.zero?\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |num, i|\n    break if num == 0 # ignore 0 because\
    \ it's sum of its digits\n    break if nums.count(num) == 1 # ignore same number\
    \ if there are more than one\n    nums[i] = num\n  end\n  nums\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |num, i|\n    nums[i] = num if num.digits.sum\
    \ < num.digits.max\n  end\n  nums\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\n\
    This doesn't work. Try it with `order_by_points([1, 11, -1, -11, -12])`\n<|/ c\
    \ |>\n<| c |>\nI see what you mean. Fixed it.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work. Try it with `order_by_points([1, 11, -1, -11, -12])`\n<|/ c |>\n<| c |>\n\
    I see what you mean. Fixed it.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\
    \ do |a,b|\n    sum1 = a.to_s.split(\"\").inject(0) {|sum, digit| sum + digit.to_i}\n\
    \    sum2 = b.to_s.split(\"\").inject(0) {|sum, digit| sum + digit.to_i}\n   \
    \ sum1 > sum2 ? -1 : sum1 < sum2 ? 1 : 0\n  end\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    break if num.zero?\n    break if num.odd?\n    break\
    \ if num.zero? || num.odd? || num.zero? && num.odd?\n    break if num.zero? ||\
    \ num.odd? || num.zero? && num.odd? && num.zero?\n  end\n  nums\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work for `order_by_points([1, 11, -1,\
    \ -11, -12])`\n<|/ c |>\n<| c |>\n, thanks for pointing that out. I've updated\
    \ my answer.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums.sum - n == 0\n    nums[i]\
    \ = n\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    break if num == 0 || (nums.size - i) == nums.find_index(num).to_i\n\
    \    nums.delete_at(i)\n    nums.insert(i, num)\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = 0\
    \ if digits < 0\n    digits = digits if digits > 9\n    nums[nums.index(num)]\
    \ = digits\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<|\
    \ a tags=ruby,arrays,sorting |>\n<code>", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if num == 0 # Don't\
    \ need to sort 0 since it has no digit\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    break if digits.sum < 0\n    break if digits.sum > 9\n    break if digits.sum\
    \ == 0 # Don't need to sort 0 since it has no digit\n    break if digits.max <\
    \ 0 # Don't need to sort negative numbers\n    break if digits.min > 9 # Don't\
    \ need to sort numbers larger than 9\n    break if digits.min == 0 # Don't need\
    \ to sort 0 since it has no digit\n    break if digits.min == 9 # Don't need to\
    \ sort 9 since it has no digit\n    break if digits.max == 9 # Don't need to sort\
    \ 9 since it has no digit\n    break if digits.min == 10 # Don't need to sort\
    \ 10 since it has no digit\n    break if digits.max == 10 # Don't need to sort\
    \ 10 since it has no digit\n    break if digits.min == 11 # Don't need to sort\
    \ 11 since it has no digit\n    break if digits.max == 11 # Don't need to sort\
    \ 11 since it has no digit\n    break if digits.min == 12 # Don't need to sort\
    \ 12 since it has no digit\n    break if digits.max == 12 # Don't need to sort\
    \ 12 since it has no digit\n    break if digits.min == 13 # Don't need to sort\
    \ 13 since it has no digit\n    break if digits.max == 13 # Don't need to sort\
    \ 13 since it has no digit\n    break if digits.min == 14 # Don't need to sort\
    \ 14 since it has no digit\n    break if digits.max == 14 # Don't need to sort\
    \ 14 since it has no digit\n    break if digits.min == 15 # Don't need to sort\
    \ 15 since it has no digit\n    break if digits.max == 15 # Don't need to sort\
    \ 15 since it has no digit\n    break if digits.min == 16 # Don't need to sort\
    \ 16 since it has no digit\n    break if digits.max == 16 # Don't need to sort\
    \ 16 since it has no digit\n    break if digits.min == 17 # Don't need to sort\
    \ 17 since it has no digit\n    break if digits.max == 17 # Don't need to sort\
    \ 17 since it has no digit\n    break if digits.min == 18 # Don't need to sort\
    \ 18 since it has no digit\n    break if digits.max == 18 # Don't need to sort\
    \ 18 since it has no digit\n    break if digits.min == 19 # Don't need to sort\
    \ 19 since it has no digit\n    break if digits.max == 19 # Don't need to sort\
    \ 19 since it has no digit\n    break if digits.min == 20 # Don't need to ", " \
    \ nums.sort!\n  i = 0\n  while i < nums.length\n    j = i + 1\n    while j < nums.length\n\
    \      sum = nums[i] + nums[j]\n      if sum > 0\n        nums[i], nums[j] = nums[j],\
    \ nums[i]\n      j += 1\n    end\n    i += 1\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    nums[i] = nums[i].to_i\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do\
    \ |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  i = 0\n  while i\
    \ < nums.length\n    j = i + 1\n    while j < nums.length\n      sum = 0\n   \
    \   while j < nums.length && nums[j].to_i < nums[i].to_i\n        sum += nums[j].to_i\n\
    \        j += 1\n      nums[i], nums[j] = nums[j], nums[i]\n      i += 1\n   \
    \   j += 1\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    nums[i] = n\n  end\n  nums\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n,\
    \ i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits >\
    \ num\n      nums.delete(num)\n      nums.insert(nums.index(num), num)\n    end\n\
    \  end\n  nums\nend", "  nums.sort! do |a, b|\n    sum1 = a.to_s.split(\"\").map\
    \ { |x| x.to_i }.inject(:+)\n    sum2 = b.to_s.split(\"\").map { |x| x.to_i }.inject(:+)\n\
    \    sum1 == sum2 ? a.to_i <=> b.to_i : sum1 < sum2 ? -1 : +1\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do\
    \ |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if num == 0 # break\
    \ when num is 0\n    break if num == -1 # break when num is -1\n    break if num\
    \ == -2 # break when num is -2\n    break if num == -3 # break when num is -3\n\
    \    break if num == -4 # break when num is -4\n    break if num == -5 # break\
    \ when num is -5\n    break if num == -6 # break when num is -6\n    break if\
    \ num == -7 # break when num is -7\n    break if num == -8 # break when num is\
    \ -8\n    break if num == -9 # break when num is -9\n    break if num == -10 #\
    \ break when num is -10\n    break if num == -11 # break when num is -11\n   \
    \ break if num == -12 # break when num is -12\n    break if num == -13 # break\
    \ when num is -13\n    break if num == -14 # break when num is -14\n    break\
    \ if num == -15 # break when num is -15\n    break if num == -16 # break when\
    \ num is -16\n    break if num == -17 # break when num is -17\n    break if num\
    \ == -18 # break when num is -18\n    break if num == -19 # break when num is\
    \ -19\n    break if num == -20 # break when num is -20\n    break if num == -21\
    \ # break when num is -21\n    break if num == -22 # break when num is -22\n \
    \   break if num == -23 # break when num is -23\n    break if num == -24 # break\
    \ when num is -24\n    break if num == -25 # break when num is -25\n    break\
    \ if num == -26 # break when num is -26\n    break if num == -27 # break when\
    \ num is -27\n    break if num == -28 # break when num is -28\n    break if num\
    \ == -29 # break when num is -29\n    break if num == -30 # break when num is\
    \ -30\n    break if num == -31 # break when num is -31\n    break if num == -32\
    \ # break when num is -32\n    break if num == -33 # break when num is -33\n \
    \   break if num == -34 # break when num is -34\n    ", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    i = num.abs\n    j = num.abs\n    while i > 0 && j\
    \ > 0\n      i -= 1\n      j -= 1\n      break if nums[i] + nums[j] > num\n  \
    \  end\n    nums[i] = num\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    break if nums.sum == num\n    nums.delete(num)\n  end\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work if there are negative numbers in the list. For\
    \ example, `order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]` returns\
    \ `nil`.\n<|/ c |>\n<| c |>\nI added a note about negative numbers. I tested it\
    \ and it works.\n<|/ c |>\n<| c |>\nThis doesn't work if there are negative numbers\
    \ in the list. For example, `order_by_points([1, 11, -1, -11, -12]) == [-1, -11,\
    \ 1, -12, 11]` returns `nil`.\n<|/ c |>\n<| c |>\nI added a note about negative\
    \ numbers. I tested it and it works.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ there are negative numbers in the list. For example, `order_by_points([1, 11,\
    \ -1, -11, -12]) == [-1, -11, 1, -12, 11]` returns `nil`.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if num == -1\n    break if num\
    \ == -num\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = num.abs\n    j = num.abs\n\
    \    while i > 0 && j > 0\n      i -= num % 10\n      j -= num % 10\n      num\
    \ = (num / 10).floor\n    end\n    nums[i] = num\n  end\n  nums\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if there are two\
    \ numbers with the same sum.\n<|/ c |>\n<| c |>\nYes, I forgot about that case.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums[i] == n\n\
    \    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break if nums.sum == num\n\
    \    nums.delete(num)\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n \
    \ nums.each do |num|\n    i = num.abs\n    break if i == 0\n    nums.delete_at(i)\n\
    \    nums.insert(i, num)\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |num, i|\n    nums[i] = num if nums.sum.to_i == num.to_i\n\
    \  end\n  nums\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if\
    \ there are two or more numbers with the same sum.\n<|/ c |>\n<| c |>\nYes, you\
    \ are right. I didn't think about that case. Thank you for pointing it out.\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n,i|\n    break if i == 0\n    break if nums[i-1].to_f\
    \ == n.to_f\n    nums.delete_at(i-1)\n    nums.insert(i, n)\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits >\
    \ nums[i].to_i\n      nums[i], nums[i] = nums[i], nums[i]\n    end\n  end\n  nums\n\
    end\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if\
    \ there are two numbers with the same sum of digits, as you stated in your answer.\n\
    <|/ c |>\n<| c |>\nI added a note about this in my answer.\n<|/ c |>\n<| c |>\n\
    I added a note about this in my answer.\n<|/ c |>\n<| c |>\nI added a note about\
    \ this in my answer.\n<|/ c |>\n<| c |>\nI added a note about this in my answer.\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do\
    \ |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    digits =\
    \ n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).to_i\n    if digits\
    \ > nums[i]\n      nums[i], nums[i] = nums[i], nums[i]\n    end\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = -digits\
    \ if digits < 0\n    digits = 0 if digits == 0\n    nums.insert(digits, num)\n\
    \  end\n  nums\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if\
    \ there are negative numbers in the list. Try `order_by_points([1, 11, -1, -11,\
    \ -12])`.\n<|/ c |>\n<| c |>\nThanks for pointing that out. I've updated my answer\
    \ to account for negative numbers.\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ Your solution works perfectly for positive numbers. However, it fails for negative\
    \ numbers. For example, `order_by_points([1, 11, -1, -11, -12])` returns `[1,\
    \ -11, -12, 11, 1]` instead of `[-1, -11, 1, -12, 11]`.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing that out. I've updated my answer to account for negative numbers.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's a solution using recursion:\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |num, i|\n    nums[i] = num if nums[i].to_s.chars.map(&:to_i).sum\
    \ == num.to_s.chars.map(&:to_i).sum\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort! do |a, b|\n    sum1 = a.to_s.split(\"\").map(&:to_i).inject(:+)\n\
    \    sum2 = b.to_s.split(\"\").map(&:to_i).inject(:+)\n    sum1 > sum2 ? 1 : sum1\
    \ < sum2 ? -1 : 0\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like your\
    \ solution, but I wonder if there is a way to do it without splitting and mapping\
    \ each string. Maybe using regular expressions?\n<|/ c |>\n<| c |>\nI added a\
    \ solution without splitting/mapping each string\n<|/ c |>\n<| c |>\nI like your\
    \ solution, but I wonder if there is a way to do it without splitting and mapping\
    \ each string. Maybe using regular expressions?\n<|/ c |>\n<| c |>\nI added a\
    \ solution without splitting/mapping each string\n<|/ c |>\n<| c |>\nI like your\
    \ solution, but I wonder if there is a way to do it without splitting and mapping\
    \ each string. Maybe using regular expressions?\n<|/ c |>\n<| a tags=ruby |>\n\
    <code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    sum = 0\n   \
    \ while n != 0\n      sum += n % 10\n      n /= 10\n    end\n    puts sum\n  end\n\
    end", "  nums.sort!\n  nums.each_with_index do |n,i|\n    break if nums[i] ==\
    \ n\n    nums[i] = n\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| a dscore=0 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.map {\
    \ |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   i = num.abs\n    break if i == 0\n    i = i / 10\n    j = num / i\n    nums[i]\
    \ = j\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits >\
    \ num\n      nums.delete(num)\n      nums.unshift(num)\n    end\n  end\n  nums\n\
    end\n</code>\n<|/ a tags=ruby,arrays,sorting |>\n<| c |>\nThis doesn't work if\
    \ there are two or more numbers with the same sum.\n<|/ c |>\n<| c |>\nYes, it\
    \ does. I tested it before posting. I added a comment to the question to clarify\
    \ this.\n<|/ c |>\n<| c |>\nI tested it again and it doesn't work. Try it with\
    \ `order_by_points([1, 11, -1, -11, -12])`.\n<|/ c |>\n<| c |>\nI tested it again\
    \ and it doesn't work. Try it with `order_by_points([1, 11, -1, -11, -12])`.\n\
    <|/ c |>\n<| c |>\nI tested it again and it doesn't work. Try it with `order_by_points([1,\
    \ 11, -1, -11, -12])`.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  nums.sort!\n \
    \ nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums[i] == n\n\
    \    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.map\
    \ { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n \
    \   sum = 0\n    while n > 0 do\n      sum += n % 10\n      n /= 10\n    end\n\
    \    sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n    break if\
    \ nums.sum < 0\n    nums.delete_at(i) if nums.sum == 0\n  end\n  nums\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", "  nums.sort!\n  i = 0\n  while\
    \ i < nums.length\n    sum = 0\n    j = i + 1\n    while j < nums.length\n   \
    \   sum += nums[j].to_i\n      j += 1\n    i += 1\n    if sum > 0\n      nums.swap(i,\
    \ nums.length - i - 1)\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |num, i|\n    nums[i] = num if nums.sum.to_i == num.to_i\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   sum = 0\n    while num > 0\n      sum += num % 10\n      num /= 10\n    end\n\
    \    break if sum == num\n    nums.insert(nums.index(num), num)\n  end\n  nums\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,sorting,arrays |>\n<code>", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits >\
    \ 1\n      nums.insert(nums.index(num), num)\n    end\n  end\n  nums\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThanks for your answer. Your solution\
    \ is very elegant and works perfectly. However I cannot understand why my solution\
    \ does not work. Could you please explain why my solution does not work?\n<|/\
    \ c |>\n<| c |>\nI added some explanation to the answer.\n<|/ c |>\n<| c |>\n\
    Thanks for your explanation. Now I understand why my solution does not work. Your\
    \ solution is very elegant and works perfectly. However I cannot understand why\
    \ my solution does not work. Could you please explain why my solution does not\
    \ work?\n<|/ c |>\n<| c |>\nI added some explanation to the answer.\n<|/ c |>\n\
    <| c |>\nThanks for your explanation. Now I understand why my solution does not\
    \ work. Your solution is very elegant and works perfectly. However I cannot understand\
    \ why my solution does not work. Could you please explain why my solution does\
    \ not work?\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.each_with_index do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    if digits == nums[i]\n      nums[i], nums[nums[i]]\
    \ = nums[nums[i]], nums[i]\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    break if n.to_s.size != n.to_s.chars.map(&:to_i).sum\n\
    \    break if n.to_s.size != n.to_s.chars.map(&:to_i).sum\n  end\n  nums\nend\n\
    </code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if the\
    \ array has negative numbers. For example, `[-2, -4, -6, -10, -12, -14, -16, -18,\
    \ -22, -24]` returns `[-10, -12, -14, -16, -18, -22, -24, -2, -4, -6]`.\n<|/ c\
    \ |>\n<| c |>\nYes, I noticed that and fixed it. I also added a note about how\
    \ to fix it.\n<|/ c |>\n<| c |>\nI added a note about how to fix it.\n<|/ c |>\n\
    <| c |>\nI added a note about how to fix it.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    n.to_s.split('').sort.reverse!\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_i }\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if digits >\
    \ nums.max_by{|n| n.to_s.chars.map(&:to_i).inject(:+).abs}\n      nums.insert(n,\
    \ n)\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |n|\n    sum = 0\n    while n != 0\n      sum += n % 10\n      n /= 10\n\
    \    end\n    sum\n  end\nend", "  nums.sort! do |a, b|\n    sum1 = sum2 = 0\n\
    \    a.each_byte { |x| sum1 += x }\n    b.each_byte { |x| sum2 += x }\n    sum1\
    \ < sum2 ? -1 : sum1 > sum2 ? 1 : 0\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThanks for your answer! I like your solution and it works great,\
    \ but I wonder if there is a way to do it without using sum1 and sum2? I tried\
    \ to do it without using sum1 and sum2 but I can't get it to work. Thanks again!\n\
    <|/ c |>\n<| c |>\nI updated my answer with a solution that doesn't use sum1 and\
    \ sum2.\n<|/ c |>\n<| c |>\nThanks for your answer! I like your solution and it\
    \ works great, but I wonder if there is a way to do it without using sum1 and\
    \ sum2? I tried to do it without using sum1 and sum2 but I can't get it to work.\
    \ Thanks again!\n<|/ c |>\n<| c |>\nI updated my answer with a solution that doesn't\
    \ use sum1 and sum2.\n<|/ c |>\n<| c |>\nThanks for your answer! I like your solution\
    \ and it works great, but I wonder if there is a way to do it without using sum1\
    \ and sum2? I tried to do it without using sum1 and sum2 but I can't get it to\
    \ work. Thanks again!\n<|/ c |>\n<| a |>\n<code>", "  nums.sort! do |a,b|\n  \
    \  sum1 = a.to_s.split(\"\").map(&:to_i).inject(:+)\n    sum2 = b.to_s.split(\"\
    \").map(&:to_i).inject(:+)\n    sum1 > sum2 ? 1 : sum1 < sum2 ? -1 : 0\n  end\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if there are negative numbers\
    \ in the list\n<|/ c |>\n<| c |>\nIt does work if there are negative numbers in\
    \ the list. Try it yourself.\n<|/ c |>\n<| c |>\nIt does work if there are negative\
    \ numbers in the list. Try it yourself. `order_by_points([1, 11, -1, -11, -12])\
    \ == [-1, -11, 1, -12, 11]`\n<|/ c |>\n<| c |>\nI didn't say it wouldn't work,\
    \ I said it didn't work if there are negative numbers in the list. Try it yourself.\n\
    <|/ c |>\n<| c |>\nI didn't say it wouldn't work, I said it didn't work if there\
    \ are negative numbers in the list. Try it yourself. `order_by_points([1, 11,\
    \ -1, -11, -12]) == [-1, -11, 1, -12, 11]`\n<|/ c |>\n<| a tags=ruby,sorting |>\n\
    <code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n  \
    \  break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |n|\n    break if nums.sum == n\n    nums.delete_at(0)\n\
    \  end\n  nums\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,arrays,sorting\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits\
    \ = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits\
    \ = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n    digits\
    \ = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n\
    \    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = ", "  nums.sort!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    if digits > nums[i]\n      nums[i], nums[i] = nums[i], nums[i]\n    end\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do\
    \ |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", " \
    \ nums.sort! { |a, b| a.to_i + b.to_i }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n   \
    \ sum = 0\n    while n > 0\n      sum += n % 10\n      n /= 10\n    end\n    sum\n\
    \  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    break\
    \ if nums.sum < num\n    nums.delete(num)\n  end\n  nums\nend\n</code>\n<|/ a\
    \ tags=ruby,sorting,arrays |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    break if num.zero?\n    break if num.odd?\n\
    \    break if num.even?\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |n|\n    sum = 0\n    n.to_s.split('').each do |c|\n      sum\
    \ += c.to_i\n    end\n    n.instance_variable_set(:@sum, sum)\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s }\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digits = digits.to_s.reverse\n    digits\
    \ = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    digits =\
    \ digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_s.reverse\n    digits = digits.chars.map(&:to_i)\n   \
    \ digits = digits.inject(:+).abs\n    digit", "  nums.sort!\n  nums.reverse!\n\
    \  nums.map { |n| n.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums.sum - n == 0\n    nums[i] = n\n  end\n  nums\n\
    end\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't work if\
    \ the array is `[1, 1, 1]`\n<|/ c |>\n<| c |>\nIt does work, try it out. `[1,\
    \ 1, 1]` becomes `[1, 1, 1]` after sorting. `[1, 1, 2]` becomes `[1, 1, 2]` after\
    \ sorting. `[1, 1, 3]` becomes `[1, 1, 3]` after sorting. `[1, 1, 4]` becomes\
    \ `[1, 1, 4]` after sorting. `[1, 1, 5]` becomes `[1, 1, 5]` after sorting. `[1,\
    \ 1, 6]` becomes `[1, 1, 6]` after sorting. `[1, 1, 7]` becomes `[1, 1, 7]` after\
    \ sorting. `[1, 1, 8]` becomes `[1, 1, 8]` after sorting. `[1, 1, 9]` becomes\
    \ `[1, 1, 9]` after sorting. `[1, 1, 10]` becomes `[1, 1, 10]` after sorting.\
    \ `[1, 1, 11]` becomes `[1, 1, 11]` after sorting. `[1, 1, 12]` becomes `[1, 1,\
    \ 12]` after sorting. `[1, 1, 13]` becomes `[1, 1, 13]` after sorting. `[1, 1,\
    \ 14]` becomes `[1, 1, 14]` after sorting. `[1, 1, 15]` becomes `[1, 1, 15]` after\
    \ sorting. `[1, 1, 16]` becomes `[1, 1, 16]` after sorting. `[1, 1, 17]` becomes\
    \ `[1, 1, 17]` after sorting. `[1, 1, 18]` becomes `[1, 1, 18]` after sorting.\
    \ `[1, 1, 19]` becomes `[1, 1, 19]` after sorting. `[1, 1, 20]` becomes `[1, 1,\
    \ 20]` after sorting. `[1, 1, 21]` becomes `[1, 1, 21]` after sorting. `[1, 1,\
    \ 22]` becomes `[1, 1, 22]` after sorting. `[1, 1, 23]` becomes `[1, 1, 23]` after\
    \ sorting. `[1, 1, 24]` becomes `[1, 1, 24]` after sorting. `[1, 1, 25]` becomes\
    \ `[1, 1, 25]` after sorting. `[1, 1, 26]` becomes `[1, 1, 26]", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums[i] == n\n\
    \    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |n|\n    break if n.digits.sum != 0\n    break if n.digits.sum > 0\n    break\
    \ if n.digits.sum < 0\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n \
    \ nums.each do |n|\n    sum = 0\n    while n > 0\n      sum += n % 10\n      n\
    \ /= 10\n    end\n    sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |n|\n    sum = 0\n    while n > 0\n      sum += n % 10\n      n /= 10\n \
    \   end\n    sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |num, i|\n    nums[i] = num if num.digits.sum < 0\n  end\n  nums\nend", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n    nums[i]\
    \ = num if num.zero?\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work for negative numbers. `order_by_points([-1, -10,\
    \ -20, -30, -40, -50, -60, -70, -80, -90, -100]) == [-100, -90, -80, -70, -60,\
    \ -50, -40, -30, -20, -10]`\n<|/ c |>\n<| c |>\nYes, it does. I tested it before\
    \ posting it. I just added a note at the bottom of the answer.\n<|/ c |>\n<| c\
    \ |>\nI tested it again and it doesn't work for negative numbers. `order_by_points([-1,\
    \ -10, -20, -30, -40, -50, -60, -70, -80, -90, -100]) == [-100, -90, -80, -70,\
    \ -60, -50, -40, -30, -20, -10]`\n<|/ c |>\n<| c |>\nI tested it again and it\
    \ doesn't work for negative numbers. `order_by_points([-1, -10, -20, -30, -40,\
    \ -50, -60, -70, -80, -90, -100]) == [-100, -90, -80, -70, -60, -50, -40, -30,\
    \ -20, -10]`\n<|/ c |>\n<| c |>\nI tested it again and it doesn't work for negative\
    \ numbers. `order_by_points([-1, -10, -20, -30, -40, -50, -60, -70, -80, -90,\
    \ -100]) == [-100, -90, -80, -70, -60, -50, -40, -30, -20, -10]`\n<|/ c |>\n<|\
    \ a dscore=3 |>\n<code>", "  nums.sort! do |a, b|\n    sum1 = sum2 = 0\n    a.each_byte\
    \ { |c| sum1 += c }\n    b.each_byte { |c| sum2 += c }\n    sum1 < sum2 ? -1 :\
    \ sum1 > sum2 ? 1 : 0\n  end\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n\
    <| c |>\nThis doesn't work if there are two equal sums.\n<|/ c |>\n<| c |>\nIt\
    \ does work if there are two equal sums. Try it out yourself.\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work if there are two equal sums. Try it out yourself.\n<|/ c\
    \ |>\n<| c |>\nIt doesn't work if there are two equal sums. Try it out yourself.\n\
    <|/ c |>\n<| c |>\nIt doesn't work if there are two equal sums. Try it out yourself.\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    break if num == 0 \n    break if num > 0\n    break\
    \ if num < 0\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |n|\n    break if n.to_s.size != n.to_s.chars.map(&:to_i).sum\n    break\
    \ if n.to_s.size != n.to_s.chars.map(&:to_i).sum\n  end\n  nums\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work for negative numbers. `order_by_points([-1,\
    \ -10, -100, -1000, -1000000000])` returns `[-1000, -1000000000, -100, -10, -1]`\
    \ instead of `[-1, -10, -100, -1000, -1000000000]`.\n<|/ c |>\n<| c |>\nI added\
    \ a note to the answer. Thanks for pointing it out.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits\
    \ = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n    if digits.zero?\n\
    \      nums.delete(num)\n    else\n      nums.insert(nums.index(num), num)\n \
    \   end\n  end\n  nums\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't\
    \ work if there are negative numbers in the list. For example, `order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]` returns `[-1, -11, 1, -12, 11]`\
    \ instead of `[1, -12, -11, 11, -1]`.\n<|/ c |>\n<| c |>\nI added a note about\
    \ negative numbers. I tested it and it works.\n<|/ c |>\n<| c |>\nI tested it\
    \ and it works. I added a note about negative numbers. I tested it and it works.\n\
    <|/ c |>\n<| a tags=ruby,sorting,algorithm |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   sum = 0\n    digits = num.to_s.chars.map(&:to_i)\n    digits.each do |d|\n\
    \      sum += d\n    end\n    if sum > 0\n      nums.delete(num)\n      nums.insert(nums.index(num),\
    \ num)\n    end\n  end\n  nums\nend", "  nums.sort! { |a, b| a.to_i + b.to_i }\n\
    \  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\
    \ do |a,b|\n    sum1 = a.to_s.chars.map(&:to_i).inject(0){|sum, el| sum + el}\n\
    \    sum2 = b.to_s.chars.map(&:to_i).inject(0){|sum, el| sum + el}\n    sum1 ==\
    \ sum2 ? a.to_i <=> b.to_i : sum1 < sum2 ? -1 : +1\n  end\nend\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    if digits > 0 && !(digits == 0 && num == 0)\n      nums.insert(nums.index(num),\
    \ num)\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    break if nums.sum == num\n    nums.delete(num)\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    sum = 0\n    digits\
    \ = num.to_s.split(//)\n    digits.each do |digit|\n      sum += digit.to_i\n\
    \    end\n    if sum > 0\n      nums.insert(nums.index(num), num)\n    end\n \
    \ end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    break\
    \ if n.to_s.size < 2\n    break if n.to_s.size % 2 == 0\n    break if n.to_s.size\
    \ != n.to_s.to_i\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    break if nums.sum == num\n    nums.delete(num)\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.map { |n| n.to_s.split('').map(&:to_i).reduce(:+)\
    \ }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    nums[i] = [nums[i], i]\n  end\n  nums\nend", "  nums.sort! { |a, b| a.to_i\
    \ + b.to_i }\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    sum\
    \ = 0\n    n.to_s.split('').each do |c|\n      sum += c.to_i\n    end\n    if\
    \ sum > 0\n      nums.insert(nums.index(n), n)\n    end\n  end\n  nums\nend",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    if nums.index?(num)\n\
    \      nums.insert(nums.index(num), num)\n    else\n      nums.push(num)\n   \
    \ end\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do\
    \ |num, i|\n    nums[i] = num if num.digits.sum < num.digits.max\n  end\nend\n\
    </code>\n<|/ a tags=ruby,sorting |>\n<| c |>\nThe `sort!` method modifies the\
    \ array in-place. `nums.sort!.reverse!` would be more idiomatic.\n<|/ c |>\n<|\
    \ c |>\nI agree, `nums.sort!.reverse!` would be more idiomatic. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| c |>\nI like this solution. One thing I noticed is that\
    \ it sorts negative numbers before positive numbers. Is there a way to sort them\
    \ in descending order?\n<|/ c |>\n<| c |>\nYes, just change `<` to `>`.\n<|/ c\
    \ |>\n<| c |>\nI added a solution that sorts in descending order.\n<|/ c |>\n\
    <| a tags=ruby,sorting |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    break if num.zero?\n    break if num.odd?\n    break if num.zero?\
    \ || num.odd? || num.zero? && num.odd?\n  end\n  nums\nend", "  nums.sort!\n \
    \ nums.reverse!\n  nums.each do |num|\n    break if num == -1\n    nums.each do\
    \ |num2|\n      break if num2 == -1\n      break if num2 == num\n      break if\
    \ num2 < num\n      nums.delete_at(nums.index(num2))\n    end\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n    break\
    \ if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n,i|\n    nums[i] = n if nums[i] + nums[i+1] > 0\n\
    \  end\n  nums\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if\
    \ there are two or more numbers with the same sum.\n<|/ c |>\n<| c |>\nYes, you\
    \ are right. My bad. I've edited my answer.\n<|/ c |>\n<| a tags=ruby |>\n<code>",
  "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = num.abs\n    break\
    \ if i == 0\n    j = num.div(i)\n    break if j == 0\n    num = j\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |num, i|\n   \
    \ nums[i] = num if num.zero?\n  end\n  nums\nend", "  nums.sort! do |a, b|\n \
    \   sum1 = sum2 = a\n    sum1 += b if a < b\n    sum2 += a if a > b\n    sum1\
    \ < sum2\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work\
    \ if there are two numbers with the same sum.\n<|/ c |>\n<| c |>\n, thanks for\
    \ pointing that out. I've updated my answer to include a note about that.\n<|/\
    \ c |>\n<| c |>\nThis doesn't work if there are two numbers with the same sum.\n\
    <|/ c |>\n<| c |>\n, thanks for pointing that out. I've updated my answer to include\
    \ a note about that.\n<|/ c |>\n<| c |>\nThis doesn't work if there are two numbers\
    \ with the same sum.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   break if nums.sum == num\n    nums.delete(num)\n  end\n  nums\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work if the list is empty or contains\
    \ only negative numbers. Try `order_by_points([])`.\n<|/ c |>\n<| c |>\nYes, I\
    \ missed that case. Thanks for pointing it out. I've updated my answer.\n<|/ c\
    \ |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  i = 0\n  while\
    \ i < nums.length\n    j = i + 1\n    while j < nums.length\n      break if nums[j].zero?\n\
    \      break if nums[j].zero? && nums[i].zero?\n      break if nums[j].zero? &&\
    \ nums[i].zero? && nums[j].to_i < nums[i].to_i\n      break if nums[j].zero? &&\
    \ nums[i].zero? && nums[j].to_i > nums[i].to_i\n      break if nums[j].zero? &&\
    \ nums[i].zero? && nums[j].to_i == nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i != nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i < nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i > nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i == nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i != nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i < nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i > nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i == nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i != nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i < nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i > nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i == nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i != nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i < nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i > nums[i].to_i\n      break if nums[j].zero?\
    \ && nums[i].zero? && nums[j].to_i == nums[i].to_i\n      break if nums[j].zero?\
    \ && ", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = -digits\
    \ if digits < 0\n    digits = -digits if digits > 9\n    nums.insert(nums.index(num),\
    \ digits)\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<|\
    \ c |>\nThis doesn't work if there are two or more items with the same sum.\n\
    <|/ c |>\n<| c |>\nYes, you are right. I've added a note to my answer. Thanks.\n\
    <|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each do |num|\n    i = num.abs\n    break if i == 0\n    i = i / 10\n\
    \    j = num.abs\n    break if j == 0\n    j = j / 10\n    break if i == j\n \
    \   break if i > j\n    nums.swap(i, j)\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |n, i|\n    break if nums[i] == n\n\
    \    nums[i] = n\n  end\n  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays\
    \ |>\n<| c |>\nThis doesn't work if there are two or more numbers with the same\
    \ sum.\n<|/ c |>\n<| c |>\n: It does. Try it out on `[1,1,2,2]`.\n<|/ c |>\n<|\
    \ c |>\n: It does. Try it out on `[1,1,2,2]`.\n<|/ c |>\n<| c |>\n: It does. Try\
    \ it out on `[1,1,2,2]`.\n<|/ c |>\n<| c |>\n: It does. Try it out on `[1,1,2,2]`.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    i = num.to_i\n    break if nums.count > 1\n    j = nums.index(i)\n\
    \    nums.delete_at(j)\n    nums.insert(j, i)\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.map { |n| n.to_s }\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do\
    \ |n,i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |n|\n    digits = n.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = 0\
    \ if digits < 0\n    digits = digits if digits > 9\n    digits = digits % 10\n\
    \    digits = 0 if digits < 0\n    digits = digits if digits > 9\n    digits =\
    \ digits % 10\n    digits = 0 if digits < 0\n    digits = digits if digits > 9\n\
    \    digits = digits % 10\n    digits = 0 if digits < 0\n    digits = digits if\
    \ digits > 9\n    digits = digits % 10\n    digits = 0 if digits < 0\n    digits\
    \ = digits if digits > 9\n    digits = digits % 10\n    digits = 0 if digits <\
    \ 0\n    digits = digits if digits > 9\n    digits = digits % 10\n    digits =\
    \ 0 if digits < 0\n    digits = digits if digits > 9\n    digits = digits % 10\n\
    \    digits = 0 if digits < 0\n    digits = digits if digits > 9\n    digits =\
    \ digits % 10\n    digits = 0 if digits < 0\n    digits = digits if digits > 9\n\
    \    digits = digits % 10\n    digits = 0 if digits < 0\n    digits = digits if\
    \ digits > 9\n    digits = digits % 10\n    digits = 0 if digits < 0\n    digits\
    \ = digits if digits > 9\n    digits = digits % 10\n    digits = 0 if digits <\
    \ 0\n    digits = digits if digits > 9\n    digits = digits % 10\n    digits =\
    \ 0 if digits < 0\n    digits = digits if digits > 9\n    digits = digits % 10\n\
    \    digits = 0 if digits < 0\n    digits = digits if digits > 9\n    digits =\
    \ digits % 10\n    digits = 0 if digits < 0\n    digits = digits if digits > 9\n\
    \    digits = digits % 10\n    digits = 0 if digits < 0\n    digits = digits if\
    \ digits > 9\n    digits = digits % 10\n    digits = 0 if digits < 0\n    digits\
    \ = digits if digits > 9\n    digits = digits % 10\n    digits = 0 if digits <\
    \ 0\n    digits = digits if digits > 9\n    digits = digits % 10\n    digits =\
    \ 0 if digits < 0\n    digits = digits if digits > 9\n    digits = digits % 10\n\
    \    digits = 0 if ", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n \
    \   sum = 0\n    i = num\n    while i > 0\n      sum += i % 10\n      i /= 10\n\
    \    end\n    nums.delete_at(i)\n    nums.insert(sum, num)\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend\n\
    </code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nI like your solution, but\
    \ I wonder if there is a way to do it without having to write an extra method.\
    \ I'm thinking about a way to do it with just one method call. Something like\
    \ `nums.sort_by { |n| n.digits.reduce(:+) }`\n<|/ c |>\n<| c |>\nI added a solution\
    \ which doesn't require an extra method.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to do it without having to write an extra method.\
    \ I'm thinking about a way to do it with just one method call. Something like\
    \ `nums.sort_by { |n| n.digits.reduce(:+) }`\n<|/ c |>\n<| c |>\nI added a solution\
    \ which doesn't require an extra method.\n<|/ c |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to do it without having to write an extra method.\
    \ I'm thinking about a way to do it with just one method call. Something like\
    \ `nums.sort_by { |n| n.digits.reduce(:+) }`\n<|/ c |>\n<| a |>\n<code>", "  nums.sort!\
    \ { |a,b| a.to_i + b.to_i }\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits_sum = digits.inject(:+)\n\
    \    if digits_sum > 0\n      nums[i] = n\n    end\n  end\n  nums\nend\n</code>\n\
    <|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThanks for your answer. Your solution\
    \ works well for small arrays, but for large arrays it takes too long to complete.\
    \ My arrays are about 500 elements long.\n<|/ c |>\n<| c |>\nI tested it on 500\
    \ elements and it took about 1 second. Are you sure that your array is really\
    \ big? Maybe you just have too much memory and your computer can't handle it?\
    \ Anyway, I added a solution which sorts the array in place, so it shouldn't take\
    \ too long.\n<|/ c |>\n<| c |>\nYes, my array is really big. Your solution works\
    \ perfectly for small arrays, but for large arrays it takes too long to complete.\
    \ My arrays are about 500 elements long.\n<|/ c |>\n<| c |>\nI tested it on 500\
    \ elements and it took about 1 second. Are you sure that your array is really\
    \ big? Maybe you just have too much memory and your computer can't handle it?\
    \ Anyway, I added a solution which sorts the array in place, so it shouldn't take\
    \ too long.\n<|/ c |>\n<| c |>\nI tested it on 500 elements and it took about\
    \ 1 second. Are you sure that your array is really big? Maybe you just have too\
    \ much memory and your computer can't handle it? Anyway, I added a solution which\
    \ sorts the array in place, so it shouldn't take too long.\n<|/ c |>\n<| a tags=ruby,sorting,arrays\
    \ |>\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n, i|\n\
    \    break if nums.sum - n == 0\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each_with_index do |num, i|\n    nums[i] = num if nums[i].to_s.chars.map(&:to_i).sum\
    \ == num.to_s.chars.map(&:to_i).sum\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n\
    \  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n   \
    \ break if n.to_s.chars.map(&:to_i).sum == n.to_s.chars.map(&:to_i).sum\n    break\
    \ if n.to_s.chars.map(&:to_i).sum > n.to_s.chars.map(&:to_i).sum\n    break if\
    \ n.to_s.chars.map(&:to_i).sum < n.to_s.chars.map(&:to_i).sum\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |num|\n    i = num.abs\n\
    \    j = num.abs\n    while i > 0 && j > 0\n      if i / j > 10\n        i /=\
    \ 10\n      else\n        j /= 10\n      end\n    end\n    nums[i] = num\n  end\n\
    \  nums\nend\n</code>\n<|/ a tags=ruby,sorting,arrays |>\n<| c |>\nThis doesn't\
    \ work if you have negative numbers. Try `order_by_points([-1, -10, -20, -30])`\n\
    <|/ c |>\n<| c |>\nIt doesn't work if you have negative numbers. Try `order_by_points([-1,\
    \ -10, -20, -30])`\n<|/ c |>\n<| c |>\nIt doesn't work if you have negative numbers.\
    \ Try `order_by_points([-1, -10, -20, -30])`\n<|/ c |>\n<| c |>\nIt doesn't work\
    \ if you have negative numbers. Try `order_by_points([-1, -10, -20, -30])`\n<|/\
    \ c |>\n<| c |>\nIt doesn't work if you have negative numbers. Try `order_by_points([-1,\
    \ -10, -20, -30])`\n<|/ c |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.chars.map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    if digits > num\n      nums.delete(num)\n\
    \      nums.insert(nums.index(num), num)\n    end\n  end\n  nums\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby,sorting,arrays |>\n<code>", "  nums.sort!\n\
    \  nums.reverse!\n  nums.each do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n\
    \    digits = digits.inject(:+).abs\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digits = digits.to_i\n\
    \    digits = digits.abs % 10\n    digits = digits.to_i\n    digits = digits.abs\
    \ % 10\n    digits = digits.to_i\n    digits = digits.abs % 10\n    digit", " \
    \ nums.sort!\n  nums.reverse!\n  nums.each_with_index do |n,i|\n    break if nums[i]\
    \ == n\n    nums[i] = n\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n\
    \  nums.each_with_index do |num, i|\n    break if num == 0 # avoid duplicates\n\
    \    break if nums.count(num) == 1 # avoid duplicates\n    nums[i] = num\n  end\n\
    \  nums\nend", "  nums.sort!\n  i = 0\n  while i < nums.length\n    sum = 0\n\
    \    j = i\n    while j < nums.length\n      sum += nums[j].to_i\n      j += 1\n\
    \    i += 1\n    sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    sum = 0\n    while num > 0\n      sum += num % 10\n      num /=\
    \ 10\n    end\n    sum\n  end\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    break if nums.sum == num\n    nums.delete(num)\n  end\n  nums\n\
    end", "  nums.sort!\n  nums.reverse!\n  nums.each do |n|\n    break if n.to_s.chars.map(&:to_i).sum\
    \ == n.to_s.chars.map(&:to_i).sum\n    break if n.to_s.chars.map(&:to_i).sum >\
    \ n.to_s.chars.map(&:to_i).sum\n  end\n  nums\nend\n</code>\n<|/ a |>\n<| c |>\n\
    This doesn't work if there are two numbers with the same sum, e.g. `order_by_points([1,\
    \ 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]`\n<|/ c |>\n<| c |>\nYes, I noticed\
    \ that and fixed it. I also added a note about that in the answer.\n<|/ c |>\n\
    <| c |>\nThanks for your answer. Your code works but it is too slow. My code takes\
    \ about 2 seconds to sort a list with 100000 elements. Your code takes about 4\
    \ seconds to sort a list with 100000 elements. I wonder if there is a faster way\
    \ to sort a list with 100000 elements.\n<|/ c |>\n<| c |>\nI tested it on a list\
    \ with 100000 elements and it took about 2 seconds. I guess it depends on the\
    \ number of elements in the list. Maybe you can try it on a list with 10000 elements\
    \ and see how long it takes.\n<|/ c |>\n<| c |>\nI tested it on a list with 10000\
    \ elements and it took about 2 seconds. I guess it depends on the number of elements\
    \ in the list. Maybe you can try it on a list with 1000 elements and see how long\
    \ it takes.\n<|/ c |>\n<| a tags=ruby,sorting,algorithm |>\nThis problem can be\
    \ solved using radix sort.\n<code>", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    digits = n.to_s.chars.map(&:to_i)\n    digits = digits.inject(:+).abs\n\
    \    digits = digits.to_i\n    if digits > nums[i]\n      nums[i], nums[i] = nums[i],\
    \ nums[i]\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each\
    \ do |num|\n    digits = num.to_s.split(//).map(&:to_i)\n    digits_sum = digits.inject(0)\
    \ {|sum, digit| sum + digit}\n    if num != 0 && digits_sum > 0\n      nums.insert(nums.index(num),\
    \ num)\n    end\n  end\n  nums\nend", "  nums.sort!\n  nums.reverse!\n  nums.each_with_index\
    \ do |n, i|\n    break if nums[i] == n\n    nums[i] = n\n  end\n  nums\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
