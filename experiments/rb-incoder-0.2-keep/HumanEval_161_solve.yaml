name: HumanEval_161_solve
language: ruby
prompt: "# You are given a string s.\n# if s[i] is a letter, reverse its case from\
  \ lower to upper or vise versa, \n# otherwise keep it as it is.\n# If the string\
  \ contains no letters, reverse the string.\n# The function should return the resulted\
  \ string.\n# Examples\n# solve(\"1234\") = \"4321\"\n# solve(\"ab\") = \"AB\"\n\
  # solve(\"#a@C\") = \"#A@c\"\ndef solve(s)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_solve\n\
  \    candidate = method(:solve)\n    assert_equal(\"aSdF\", candidate.call(\"AsDf\"\
  ))\n    assert_equal(\"4321\", candidate.call(\"1234\"))\n    assert_equal(\"AB\"\
  , candidate.call(\"ab\"))\n    assert_equal(\"#A@c\", candidate.call(\"#a@C\"))\n\
  \    assert_equal(\"#aSDFw^45\", candidate.call(\"#AsdfW^45\"))\n    assert_equal(\"\
  2@6#\", candidate.call(\"#6@2\"))\n    assert_equal(\"#$A^d\", candidate.call(\"\
  #$a^D\"))\n    assert_equal(\"#CCC\", candidate.call(\"#ccc\"))\n  end\nend\n"
completions: ["  s.chars.each do |char|\n    if char.upcase == char\n      s = s.gsub(/#{char}/i,\
    \ char.downcase)\n    elsif char.downcase == char\n      s = s.gsub(/#{char}/i,\
    \ char.upcase)\n    else\n      s = s.gsub(/#{char}/i, char)\n    end\n  end\n\
    \  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i,\
    \ '')\n  s.reverse!\n  s\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.chars.each do |char|\n    char.upcase if char.upcase == char\n\
    \    char.downcase if char.downcase == char\n  end\n  s\nend", "  s.chars.each\
    \ do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| c |>\nThis doesn't work. Try it with `solve(\"ab\")`.\n<|/ c |>\n<| c |>\n\
    It does work. `solve(\"ab\")` returns `\"AB\"`.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work. Try it with `solve(\"ab\")`.\n<|/ c |>\n<| c |>\nIt does work. `solve(\"\
    ab\")` returns `\"AB\"`.\n<|/ c |>\n<| c |>\nIt does work. `solve(\"ab\")` returns\
    \ `\"AB\"`.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s.chars.each do |char|\n\
    \    if char.upcase == char\n      s = s.gsub(/#{char}/i, char.downcase)\n   \
    \ elsif char.downcase == char\n      s = s.gsub(/#{char}/i, char.upcase)\n   \
    \ end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby\
    \ |>\n<code>", "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s\n\
    end\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,string |>\n<code>", "  s.gsub!(/[^A-Za-z]/,\
    \ '')\n  s.gsub!(/[a-z]/) { |s| s.upcase }\n  s.gsub!(/[A-Z]/) { |s| s.downcase\
    \ }\n  s\nend", "  s.chars.map { |c| c.upcase == c ? c.downcase : c }.join\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string |>\n<code>", "  s = s.downcase\n\
    \  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n\
    \  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.reverse!\n  s\nend\n</code>\n<|/ a\
    \ tags=ruby,string |>\n<| c |>\nThis doesn't work for \"#a@C\". It returns \"\
    #A@c\"\n<|/ c |>\n<| c |>\n, thanks for pointing out. I fixed the code accordingly.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n\
    \    next if c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n\
    \    next if c.upcase == c.downcase\n    next if c.upcase == c.downcase.upcase\n\
    \    next if c.downcase == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s = s.to_s\n  s.downcase!\n  s.gsub(/[^a-z]/i) { |x| x.upcase }\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a dscore=0 |>\n<code>", "  s.gsub!(/[^a-z]/i) {\
    \ |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each\
    \ do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work if there\
    \ are multiple letters in the string that need to be reversed.\n<|/ c |>\n<| c\
    \ |>\nIt does work if there are multiple letters in the string that need to be\
    \ reversed. Please try it out.\n<|/ c |>\n<| c |>\nIt doesn't work if there are\
    \ multiple letters in the string that need to be reversed.\n<|/ c |>\n<| c |>\n\
    It does work if there are multiple letters in the string that need to be reversed.\
    \ Please try it out.\n<|/ c |>\n<| c |>\nIt doesn't work if there are multiple\
    \ letters in the string that need to be reversed.\n<|/ c |>\n<| a |>\n<code>",
  "  s.downcase!\n  s.gsub(/[a-z]/) { |x| x.upcase }\n  s.gsub(/[^a-z]/) { |x| x.downcase\
    \ }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like this solution. One thing\
    \ I noticed is that `gsub` will replace all occurrences of `[a-z]` with its uppercase\
    \ version. `gsub(/[a-z]/) { |x| x.upcase }` will replace all occurrences of `[a-z]`\
    \ with its uppercase version. `gsub(/[^a-z]/) { |x| x.downcase }` will replace\
    \ all occurrences of `[^a-z]` with its downcase version. `gsub(/[a-z]/) { |x|\
    \ x.upcase }` will replace all occurrences of `[a-z]` with its uppercase version.\
    \ `gsub(/[^a-z]/) { |x| x.downcase }` will replace all occurrences of `[^a-z]`\
    \ with its downcase version. `gsub(/[a-z]/) { |x| x.upcase }` will replace all\
    \ occurrences of `[a-z]` with its uppercase version. `gsub(/[^a-z]/) { |x| x.downcase\
    \ }` will replace all occurrences of `[^a-z]` with its downcase version. `gsub(/[a-z]/)\
    \ { |x| x.upcase }` will replace all occurrences of `[a-z]` with its uppercase\
    \ version. `gsub(/[^a-z]/) { |x| x.downcase }` will replace all occurrences of\
    \ `[^a-z]` with its downcase version.\n<|/ c |>\n<| c |>\nYes, I noticed that\
    \ too. Thanks for pointing it out. I updated my answer accordingly.\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>", "  s = s.to_s.downcase\n  s.gsub!(/[^a-z]/,'')\n \
    \ s.gsub!(/[a-z]/){|s| s.upcase }\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ dscore=0 |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    next if\
    \ c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n    next if\
    \ c.upcase == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next\
    \ if c.downcase == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase.downcase == c.downcase.upcase.downcase.upcase\n\
    \    next if c.downcase.upcase.downcase.upcase.downcase == c\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.downcase.upcase.downcase.", "  s = s.to_s\n  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '')\n  s\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby,string |>\n<code>", "  s = s.chars.reverse.join\
    \ if s.chars.any? else s.chars.reverse\n  s.chars.map { |c| c.upcase }.join if\
    \ s.chars.any? else s\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\n<code>",
  "  s = s.to_s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.downcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=0\
    \ |>\n<code>", "  s.downcase!\n  s.gsub(/[^a-z]/i) { |s| s.upcase }\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work if the string contains numbers,\
    \ only letters.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before posting it.\
    \ `solve(\"1234\")` returns `\"4321\"`.\n<|/ c |>\n<| c |>\nYes, it does. I tested\
    \ it before posting it. `solve(\"1234\")` returns `\"4321\"`.\n<|/ c |>\n<| c\
    \ |>\nI tested it before posting it. `solve(\"1234\")` returns `\"4321\"`.\n<|/\
    \ c |>\n<| c |>\nI tested it before posting it. `solve(\"1234\")` returns `\"\
    4321\"`.\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  s.chars.each do |c|\n    if\
    \ c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s.chars.join\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't\
    \ work if there are multiple consecutive uppercase letters.\n<|/ c |>\n<| c |>\n\
    I didn't know that about Ruby, thanks for pointing that out. I've updated my answer\
    \ to account for that.\n<|/ c |>\n<| c |>\nI didn't know that about Ruby, thanks\
    \ for pointing that out. I've updated my answer to account for that.\n<|/ c |>\n\
    <| a tags=ruby,string |>\n<code>", "  s.chars.each_with_index do |char, i|\n \
    \   char.upcase if char.upcase == char\n    char.downcase if char.downcase ==\
    \ char\n  end\n  s.chars.join\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    This doesn't work if the string contains only letters.\n<|/ c |>\n<| c |>\nIt\
    \ does work. Try it yourself. It does exactly what OP asked for. `solve(\"ab\"\
    )` returns `\"AB\"`.\n<|/ c |>\n<| c |>\nIt doesn't work if the string contains\
    \ only letters. Try it yourself. It returns `\"A\"`.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if the string contains only letters. Try it yourself. It returns `\"A\"\
    `.\n<|/ c |>\n<| c |>\nIt doesn't work if the string contains only letters. Try\
    \ it yourself. It returns `\"A\"`.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>",
  "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.reverse!\n  s\nend",
  "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) {\
    \ |s| s.downcase }\n  s\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't\
    \ work if the string contains only lowercase letters.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work because `gsub!` doesn't modify the string in place. `s.gsub!(/[a-z]/i)\
    \ { |s| s.downcase }` will return the modified string but `s` will still be unchanged.\n\
    <|/ c |>\n<| c |>\nI didn't know that. Thanks for pointing that out.\n<|/ c |>\n\
    <| a tags=ruby |>\n<code>", "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |x| x.upcase\
    \ }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend", "  s = s.to_s\n  s.gsub!(/[^a-zA-Z]/,\
    \ '')\n  s.downcase!\n  s.gsub!(/[a-z]/) { |s| s.upcase }\n  s\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nI like your solution, but I think it would\
    \ be more efficient to just do `s.gsub(/[^a-zA-Z]/, '').downcase`\n<|/ c |>\n\
    <| c |>\nI agree, thank you. I was trying to keep my answer as close to OP's as\
    \ possible.\n<|/ c |>\n<| c |>\nI like your solution, but I think it would be\
    \ more efficient to just do `s.gsub(/[^a-zA-Z]/, '').downcase`\n<|/ c |>\n<| c\
    \ |>\nI like your solution, but I think it would be more efficient to just do\
    \ `s.gsub(/[^a-zA-Z]/, '').downcase`\n<|/ c |>\n<| a dscore=5 tags=ruby,string\
    \ |>\n<code>", "  s = s.to_s\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |x| x.downcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string,regex |>\n<| c\
    \ |>\nI like your solution, but I believe it can be simplified to `s.gsub(/[a-z]/i)\
    \ { |x| x.upcase }`.\n<|/ c |>\n<| c |>\nYes, you are right. Thanks for pointing\
    \ out. Updated the answer.\n<|/ c |>\n<| c |>\nI like your solution, but I believe\
    \ it can be simplified to `s.gsub(/[a-z]/i) { |x| x.upcase }`.\n<|/ c |>\n<| c\
    \ |>\nI like your solution, but I believe it can be simplified to `s.gsub(/[a-z]/i)\
    \ { |x| x.upcase }`.\n<|/ c |>\n<| c |>\nI like your solution, but I believe it\
    \ can be simplified to `s.gsub(/[a-z]/i) { |x| x.upcase }`.\n<|/ c |>\n<| a dscore=5\
    \ |>\n<code>", "  s.chars.map {|c| c.upcase == c ? c.downcase : c}.join\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s.gsub!(/[^a-z]/i) {\
    \ |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend", "  s.chars.each\
    \ do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n\
    \  end\n  s.chars.reverse!\n  s.chars.join\nend", "  s.chars.each do |c|\n   \
    \ if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "  s.chars.each_with_index do |char, i|\n   \
    \ next if char.nil?\n    char.upcase if char.downcase == char\n    char.downcase\
    \ if char.upcase == char\n  end\n  s.chars.join\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n\
    \    c.upcase if c.is_a? String\n    c.downcase if c.is_a? String\n  end\n  s.chars.join\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI believe that `s.chars.each do |c|`\
    \ should be `s.each_char` since `chars` returns an array. `each_char` returns\
    \ an enumerator, which can be used with `each`.\n<|/ c |>\n<| c |>\nYes, you are\
    \ right. Thanks for pointing it out. I've updated the answer.\n<|/ c |>\n<| a\
    \ dscore=2 |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    next if\
    \ c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n    next if\
    \ c.upcase == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next\
    \ if c.downcase == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n\
    \  end\n  s.chars.reverse!\n  s.chars.join\nend", "  s.chars.each do |c|\n   \
    \ if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.upcase)\n    else\n      s = c\n    end\n\
    \  end\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't work if the\
    \ string contains multiple letters.\n<|/ c |>\n<| c |>\nIt does work. Try it out\
    \ yourself. It works on multiple letters as well. Try it out on \"ab#a@C\".\n\
    <|/ c |>\n<| c |>\nIt doesn't work. Try it out on \"ab#a@C\".\n<|/ c |>\n<| c\
    \ |>\nIt does work. Try it out on \"ab#a@C\".\n<|/ c |>\n<| c |>\nIt does work.\
    \ Try it out on \"ab#a@C\".\n<|/ c |>\n<| a tags=ruby |>\n<code>", "  s.downcase!\n\
    \  s.gsub(/[^a-z]/i) { |x| x.upcase }\nend\n</code>\n<|/ a tags=ruby,string |>\n\
    <| a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n\
    \  s.gsub!(/[a-z]/i, '')\n  s\nend", "  s.chars.each do |c|\n    next if c.nil?\n\
    \    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.gsub(/[^a-zA-Z]/,\
    \ \"\")\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=0 |>\n<code>", " \
    \ s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) {\
    \ |s| s.downcase }\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.chars.each_with_index do |char, index|\n    if char.upcase\
    \ == char\n      s.chars[index] = char.downcase\n    elsif char.downcase == char\n\
    \      s.chars[index] = char.upcase\n    end\n  end\n  s\nend\n</code>\n<|/ a\
    \ tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n\
    \    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.reverse!\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '')\n  s.reverse!\n  s\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", "  s = s.downcase\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\n  s\nend", "  s.chars.reverse_each.with_index.reduce(:+)\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s.chars.each do\
    \ |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s.chars.join\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for strings\
    \ with multiple characters. For example: `solve(\"ab\")` returns `\"Ab\"`.\n<|/\
    \ c |>\n<| c |>\nI believe that `s.chars.join` should be `s.join`, otherwise it\
    \ returns `nil`.\n<|/ c |>\n<| c |>\nI believe that `s.chars.join` should be `s.join`,\
    \ otherwise it returns `nil`.\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.downcase == c.upcase\n    next if c.upcase == c.downcase.upcase\n    next\
    \ if c.downcase == c.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s = s.to_s\n  s.gsub!(/[a-z]/i) { |s| s.upcase }\n  s.gsub!(/[A-Z]/i) { |s| s.downcase\
    \ }\n  s.gsub!(/[^a-z]/i) { |s| s.reverse }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse }\n  s.gsub!(/[^a-z]/i) { |s| s.reverse\
    \ }\n  s.gsub!(/[^a-z]/i) { |s| s.reverse }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse\
    \ }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse }\n  s.gsub!(/[^A-Z]/i) { |s| s.reverse\
    \ }\n  s.g", "  s.chars.each do |c|\n    next if c.nil?\n    if c.upcase == c\n\
    \      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s =\
    \ s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n\
    </code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work if the string contains\
    \ any non-letters.\n<|/ c |>\n<| c |>\nI added a solution that doesn't require\
    \ any additional libraries.\n<|/ c |>\n<| c |>\nI added a solution that doesn't\
    \ require any additional libraries.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ doesn't require any additional libraries.\n<|/ c |>\n<| a tags=ruby,string |>\n\
    <code>", "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n  \
    \  next if c.upcase == c\n    next if c.downcase == c\n    next if c.upcase ==\
    \ c.downcase\n    next if c.upcase == c.downcase.upcase\n    next if c.downcase\
    \ == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n \
    \   next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.map {|c| c.upcase if c.is_a? String }.compact.join\nend", "  s = s.downcase\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis doesn't work. Try it with `solve(\"ab\")`.\n<|/ c |>\n<| c\
    \ |>\n, thanks for pointing that out. I've updated the answer.\n<|/ c |>\n<| c\
    \ |>\nI still don't think this works. Try it with `solve(\"ab\")`.\n<|/ c |>\n\
    <| c |>\n, thanks for pointing that out. I've updated the answer.\n<|/ c |>\n\
    <| c |>\nThis doesn't work. Try it with `solve(\"ab\")`.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  s.chars.reverse_each.with_index.with_object(\"\") do |(char,\
    \ index), result|\n    result << char if char.match?(/[a-z]/i)\n    result <<\
    \ char.upcase if char.match?(/[A-Z]/i)\n  end\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\n`s.chars.reverse_each.with_index.with_object(\"\")` can be written\
    \ `s.chars.reverse_each.with_index.with_object(\"\")`\n<|/ c |>\n<| c |>\nThanks,\
    \ I didn't know about that one. I've updated the answer.\n<|/ c |>\n<| c |>\n\
    `s.chars.reverse_each.with_index.with_object(\"\")` can be written `s.chars.reverse_each.with_index.with_object(\"\
    \")`\n<|/ c |>\n<| c |>\nThanks, I didn't know about that one. I've updated the\
    \ answer.\n<|/ c |>\n<| c |>\n`s.chars.reverse_each.with_index.with_object(\"\"\
    )` can be written `s.chars.reverse_each.with_index.with_object(\"\")`\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i) { |s| s.upcase }\n  s\nend", "  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s.gsub!(/[^A-Z]/i)\
    \ { |s| s.reverse }\n  s.gsub!(/[A-Z]/i) { |s| s.reverse }\n  s\nend", "  s =\
    \ s.to_s\n  s.gsub!(/[^a-zA-Z]/, '')\n  s.gsub!(/[a-z]/) do |letter|\n    letter\
    \ = letter.upcase if letter.downcase == letter\n    letter\n  end\n  s.gsub!(/[A-Z]/)\
    \ do |letter|\n    letter = letter.downcase if letter.upcase == letter\n    letter\n\
    \  end\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work\
    \ if the string contains numbers. Try `solve(\"123abc\")`\n<|/ c |>\n<| c |>\n\
    Yeah, I noticed that and fixed it.  Thanks for pointing it out.\n<|/ c |>\n<|\
    \ a tags=ruby,string |>\n<code>", "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s|\
    \ s.upcase }\n  s.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ doesn't work for `solve(\"ab\") = \"AB\"`\n<|/ c |>\n<| c |>\nThanks, I fixed\
    \ it.\n<|/ c |>\n<| c |>\nThis doesn't work for `solve(\"ab\") = \"AB\"`\n<|/\
    \ c |>\n<| c |>\nThanks, I fixed it.\n<|/ c |>\n<| a dscore=0 |>\n<code>", " \
    \ s.downcase!\n  s.gsub(/[^a-z]/i) { |c| c.upcase }\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\n`s.downcase!` will mutate the string in place. `s.gsub(/[^a-z]/i)\
    \ { |c| c.upcase }` will create a new string and leave the original untouched.\n\
    <|/ c |>\n<| c |>\nThanks, I didn't know that. I've updated the answer.\n<|/ c\
    \ |>\n<| c |>\n`s.gsub(/[^a-z]/i) { |c| c.upcase }` will create a new string and\
    \ leave the original untouched.\n<|/ c |>\n<| c |>\nThanks, I didn't know that.\
    \ I've updated the answer.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) {\
    \ |s| s.downcase }\n  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n\
    \      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s =\
    \ s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n\
    </code>\n<|/ a tags=ruby,string |>\n<| c |>\nI like this solution, but I wonder\
    \ if there is a way to do it without having to reverse the string. Perhaps some\
    \ kind of regex substitution?\n<|/ c |>\n<| c |>\nI guess you could do something\
    \ like `s.gsub(/[a-z]/) { |c| c.upcase == c ? c.downcase : c.upcase }`, but that\
    \ would be a lot less efficient than just reversing the string.\n<|/ c |>\n<|\
    \ c |>\nI like your solution, but I wonder if there is a way to do it without\
    \ having to reverse the string. Perhaps some kind of regex substitution?\n<|/\
    \ c |>\n<| c |>\nI guess you could do something like `s.gsub(/[a-z]/) { |c| c.upcase\
    \ == c ? c.downcase : c.upcase }`, but that would be a lot less efficient than\
    \ just reversing the string.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder\
    \ if there is a way to do it without having to reverse the string. Perhaps some\
    \ kind of regex substitution?\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", " \
    \ s.chars.each do |c|\n    next if c.nil? || c.empty?\n    next if c.upcase ==\
    \ c\n    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next\
    \ if c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.",
  "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) {\
    \ |s| s.downcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis\
    \ doesn't work for `solve(\"ab\")` which should return `\"AB\"`.\n<|/ c |>\n<|\
    \ c |>\nI agree with you, I have edited my answer to fix the problem.\n<|/ c |>\n\
    <| c |>\nThe OP wants to reverse the case of the letters within the string. Your\
    \ solution returns `\"AB\"` for `\"ab\"`.\n<|/ c |>\n<| c |>\nI agree with you,\
    \ I have edited my answer to fix the problem.\n<|/ c |>\n<| c |>\nI agree with\
    \ you, I have edited my answer to fix the problem.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s\n\
    end", "  s = s.to_s\n  s.gsub!(/[[:alpha:]]/) { |s| s.upcase }\n  s.gsub!(/[[:alpha:]]/)\
    \ { |s| s.downcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s = s.to_s\n  s.gsub!(/[^a-zA-Z]/, \"\")\n  s.gsub!(/[a-z]/)\
    \ { |s| s.upcase }\n  s.gsub!(/[A-Z]/) { |s| s.downcase }\n  s\nend", "  s.chars.each\
    \ do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.downcase)\n    end\n  end\n  s.gsub(/[^a-zA-Z]/, \"\")\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| a |>\n<code>", "  s.chars.each do |c|\n    if c.upcase ==\
    \ c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n     \
    \ s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.join\nend\n</code>\n\
    <|/ a tags=ruby |>\n<| c |>\n`s.chars.join` can be replaced with `s.reverse`\n\
    <|/ c |>\n<| c |>\n`s.chars.join` can be replaced with `s.reverse`\n<|/ c |>\n\
    <| c |>\n`s.chars.join` can be replaced with `s.reverse`\n<|/ c |>\n<| c |>\n\
    `s.chars.join` can be replaced with `s.reverse`\n<|/ c |>\n<| c |>\n`s.chars.join`\
    \ can be replaced with `s.reverse`\n<|/ c |>\n<| a dscore=5 |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '')\n  s.reverse!\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>",
  "  s.gsub!(/[^a-zA-Z]/,'')\n  s.gsub!(/[a-z]/){|s| s.upcase}\n  s.gsub!(/[A-Z]/){|s|\
    \ s.downcase}\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>",
  "  s = s.to_s\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x|\
    \ x.downcase }\n  s\nend", "  s.gsub!(/[^A-Za-z]/,'')\n  s.gsub!(/[A-Z]/){|s|\
    \ s.upcase}\n  s.gsub!(/[a-z]/){|s| s.downcase}\n  s\nend", "  s.chars.each do\
    \ |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n \
    \   next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if c.upcase\
    \ == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n    next\
    \ if c.downcase == c.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase.downcase\
    \ == c.downcase.upcase.downcase.upcase\n    next if c.upcase.downcase.upcase.downcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase\
    \ == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\
    \ == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\
    \ == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\
    \ == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.down",
  "  s.chars.each do |char|\n    if char.upcase == char\n      s = s.gsub(char, char.downcase)\n\
    \    elsif char.downcase == char\n      s = s.gsub(char, char.upcase)\n    end\n\
    \  end\n  s\nend\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>", "  s.chars.each\
    \ do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    else\n      s = c\n    end\n  end\n  s\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| c |>\nI like your solution, but I wonder if it can be done without `gsub`?\
    \ I mean, `gsub` will create a new string and copy the original string into it,\
    \ so I wonder if it can be done without it.\n<|/ c |>\n<| c |>\nI added another\
    \ solution that doesn't use `gsub`.\n<|/ c |>\n<| c |>\nI like your second solution,\
    \ too. Thank you!\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  s.chars.each_with_index\
    \ do |char, i|\n    char.upcase if char.upcase == char\n    char.downcase if char.downcase\
    \ == char\n  end\n  s.chars.join\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis\
    \ doesn't work. Try it with `solve(\"ab\")`.\n<|/ c |>\n<| c |>\nIt does work.\
    \ Try it with `solve(\"ab\")`.\n<|/ c |>\n<| c |>\nIt doesn't work. Try it with\
    \ `solve(\"ab\")`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `solve(\"ab\"\
    )`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `solve(\"ab\")`.\n<|/ c |>\n\
    <| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n\
    \    if c.upcase == c\n      s = c.downcase\n    elsif c.downcase == c\n     \
    \ s = c.upcase\n    end\n  end\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0\
    \ |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\n<code>", "  s = s.chars.reverse.join if s.chars.any? else s.reverse\n\
    \  s.chars.each do |c|\n    next if c.upcase == c\n    s = c.upcase + s\n  end\n\
    \  s\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work if the string\
    \ contains multiple letters.\n<|/ c |>\n<| c |>\n, thanks for pointing out. I've\
    \ fixed the code accordingly.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  s = s.to_s\n\
    \  s.gsub!(/[a-z]/){|s| s.upcase if s.is_a?(String)}\n  s.gsub!(/[A-Z]/){|s| s.downcase\
    \ if s.is_a?(String)}\n  s.gsub!(/[^a-zA-Z]/){|s| s.reverse}\n  s\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis does not provide an answer to the question. To\
    \ critique or request clarification from an author, leave a comment below their\
    \ post. - [From Review](/review/low-quality-posts/18009243)\n<|/ c |>\n<| c |>\n\
    This does provide an answer to the question. He asked how to reverse a string\
    \ in Ruby, and I provided a solution. He didn't ask for clarification.\n<|/ c\
    \ |>\n<| c |>\nThis does not provide an answer to the question. To critique or\
    \ request clarification from an author, leave a comment below their post. - [From\
    \ Review](/review/low-quality-posts/18009243)\n<|/ c |>\n<| c |>\nThis does not\
    \ provide an answer to the question. To critique or request clarification from\
    \ an author, leave a comment below their post. - [From Review](/review/low-quality-posts/18009243)\n\
    <|/ c |>\n<| c |>\nThis does not provide an answer to the question. To critique\
    \ or request clarification from an author, leave a comment below their post. -\
    \ [From Review](/review/low-quality-posts/18009243)\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s\n\
    end", "  s.gsub!(/[^a-zA-Z]/) do |x|\n    x.upcase if x.match?(/[a-z]/)\n    x.downcase\
    \ if x.match?(/[A-Z]/)\n    x\n  end\n  s.reverse!\nend\n</code>\n<|/ a |>\n<|\
    \ c |>\nThis doesn't work for \"#a@C\". It returns \"#A@c\".\n<|/ c |>\n<| c |>\n\
    It works for me in Ruby 2.4.  I added an example to the answer.\n<|/ c |>\n<|\
    \ c |>\nI added a solution that doesn't use gsub!\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.chars.each_with_index.map do |char,index|\n    if char.upcase\
    \ == char\n      s.chars[index] = char.downcase\n    else\n      s.chars[index]\
    \ = char\n    end\n  end.join\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    This doesn't work. Try it with `\"#a@C\"`.\n<|/ c |>\n<| c |>\nI tested it on\
    \ ruby 2.4.0 and it works. I updated the answer with another solution\n<|/ c |>\n\
    <| c |>\nI tested it on ruby 2.4.0 and it works. I updated the answer with another\
    \ solution\n<|/ c |>\n<| c |>\nI tested it on ruby 2.4.0 and it works. I updated\
    \ the answer with another solution\n<|/ c |>\n<| c |>\nI tested it on ruby 2.4.0\
    \ and it works. I updated the answer with another solution\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>", "  s.chars.reverse_each.with_index.reduce(:+).to_s\nend\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=ruby,string |>\n<code>", "  s.gsub(/[a-z]/i) do |letter|\n\
    \    letter.upcase if letter.is_a? String\n    letter\n  end\nend", "  s = s.to_s\n\
    \  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.gsub!(/[a-z]/i) { |c| c.downcase }\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThe `gsub!` method modifies\
    \ the string in place, so you don't need to assign the result to a variable.\n\
    <|/ c |>\n<| c |>\nThanks, I didn't know that. I've edited my answer.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if there are multiple consecutive letters.\n<|/ c |>\n\
    <| c |>\nIt doesn't work when there are multiple consecutive letters. Try `solve(\"\
    ab\")`\n<|/ c |>\n<| c |>\nIt doesn't work when there are multiple consecutive\
    \ letters. Try `solve(\"ab\")`\n<|/ c |>\n<| a |>\n<code>", "  s.chars.each do\
    \ |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a dscore=0 |>\n<code>", "  s = s.to_s\n  s.gsub!(/[^A-Za-z]/, '')\n  s.gsub!(/[A-Za-z]/)\
    \ { |s| s.upcase }\n  s.gsub!(/[A-Z]/) { |s| s.downcase }\n  s.reverse!\n  s\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s = s.to_s\n  s.gsub!(/[^a-z]/i)\
    \ { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n  s.reverse!\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| c |>\nThis doesn't work. Try it with `solve(\"ab\")`.\n<|/ c |>\n<| c\
    \ |>\nIt does work. Try it with `solve(\"ab\")`.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work. Try it with `solve(\"ab\")`.\n<|/ c |>\n<| c |>\nIt does work. Try it\
    \ with `solve(\"ab\")`.\n<|/ c |>\n<| c |>\nIt does work. Try it with `solve(\"\
    ab\")`.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s\
    \ = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a |>\n\
    <| c |>\nThis doesn't work if you have a string like \"#a@C\"\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work if you have a string like \"#a@C\" because \"#a@C\" doesn't\
    \ contain any letters.\n<|/ c |>\n<| c |>\nIt doesn't work if you have a string\
    \ like \"#a@C\" because \"#a@C\" doesn't contain any letters.\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work if you have a string like \"#a@C\" because \"#a@C\" doesn't\
    \ contain any letters.\n<|/ c |>\n<| c |>\nIt doesn't work if you have a string\
    \ like \"#a@C\" because \"#a@C\" doesn't contain any letters.\n<|/ c |>\n<| a\
    \ tags=ruby |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n    next\
    \ if c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n    next\
    \ if c.upcase == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next\
    \ if c.downcase == c.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n\
    \  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis\
    \ does not work if there are multiple letters in the string. For example, if `s\
    \ = \"#a@C\"`, then `s.chars.each do |c|` will iterate over `#`, `a`, `@`, `C`,\
    \ but `s.gsub(c.upcase, c.downcase)` will replace `#` with `#`, `a` with `a`,\
    \ `@` with `@`, `C` with `c`, which is not what we want.\n<|/ c |>\n<| c |>\n\
    I added a solution that doesn't require a loop\n<|/ c |>\n<| a dscore=1 |>\n<code>",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i) { |s| s.upcase }\n\
    \  s\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.downcase == c.upcase\n    next if c.upcase == c.downcase\n    next if c.downcase\
    \ == c.upcase\n    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n\
    \    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next\
    \ if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase\
    \ == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n\
    \    next if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n    next\
    \ if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n    next if c.downcase\
    \ == c.upcase\n    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n\
    \    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next\
    \ if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase\
    \ == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n\
    \    next if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n    next\
    \ if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n    next if c.downcase\
    \ == c.upcase\n    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n\
    \    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next\
    \ if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase\
    \ == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n\
    \    next if c.downcase == c.upcase\n    next if c.upcase == c.down", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.downcase ==\
    \ c\n    next if c.upcase == c\n    next if c.downcase == c.upcase\n    next if\
    \ c.upcase == c.downcase\n    next if c.upcase == c.downcase\n    next if c.downcase\
    \ == c.upcase\n    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n\
    \    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next\
    \ if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase\
    \ == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n\
    \    next if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n    next\
    \ if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n    next if c.downcase\
    \ == c.upcase\n    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n\
    \    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next\
    \ if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase\
    \ == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n\
    \    next if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n    next\
    \ if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n    next if c.downcase\
    \ == c.upcase\n    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n\
    \    next if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next\
    \ if c.upcase == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase\
    \ == c.downcase\n    next if c.downcase == c.upcase\n    next if c.upcase == c.downcase\n\
    \    next if c.downcase == c.upcase\n    next if c.upcase == c.down", "  s = s.downcase\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.downcase).gsub(c.upcase,\
    \ c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s.chars.join\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work if the string contains multiple\
    \ letters of the same case.\n<|/ c |>\n<| c |>\nIt doesn't work because `s.chars`\
    \ returns an array of characters, not a single string. `s.chars.join` converts\
    \ the array of characters to a string. `s.chars.join` doesn't change the original\
    \ string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)` doesn't change the\
    \ original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)` doesn't change\
    \ the original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)` doesn't\
    \ change the original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)`\
    \ doesn't change the original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)`\
    \ doesn't change the original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)`\
    \ doesn't change the original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)`\
    \ doesn't change the original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)`\
    \ doesn't change the original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)`\
    \ doesn't change the original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)`\
    \ doesn't change the original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)`\
    \ doesn't change the original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)`\
    \ doesn't change the original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)`\
    \ doesn't change the original string. `s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)`\
    \ doesn't change the original string. `s.gsub(c.upcase, c).gsub(c.down", "  s.chars.reverse_each.map\
    \ { |c| c.upcase if c.is_a?(String) }.join\nend\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=ruby,string |>\n<code>", "  s = s.downcase\n  s.gsub!(/[^a-z]/i, '')\n\
    \  s.gsub!(/[a-z]/i) { |s| s.upcase }\n  s\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| c |>\nThe OP said \"The function should return the resulted string.\"\n<|/\
    \ c |>\n<| c |>\nYes, I know, but I thought it would be useful to show a solution\
    \ that doesn't require a return statement.\n<|/ c |>\n<| c |>\nThe OP said \"\
    The function should return the resulted string.\" so I thought it was useful to\
    \ show a solution that doesn't require a return statement.\n<|/ c |>\n<| c |>\n\
    I agree with you, but I thought it would be useful to show a solution that doesn't\
    \ require a return statement.\n<|/ c |>\n<| c |>\nI agree with you, but I thought\
    \ it would be useful to show a solution that doesn't require a return statement.\n\
    <|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s = s.to_s.downcase\n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.gsub!(/[a-z]/i) { |s| s.upcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.reverse_each.map {|c| c.upcase\
    \ if c.is_a? String }.join\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby |>\n\
    <code>", "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.downcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=0\
    \ |>\n<code>", "  s.chars.each do |char|\n    if char.upcase == char\n      s\
    \ = char.downcase\n    elsif char.downcase == char\n      s = char.upcase\n  \
    \  end\n  end\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,string |>\n\
    <code>", "  s.chars.each do |c|\n    next if c.nil? || c.empty?\n    next if c.upcase\
    \ == c\n    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next\
    \ if c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n\
    \  end\n  s.chars.reverse!\n  s\nend", "  s.chars.each do |c|\n    next if c.nil?\n\
    \    c.upcase if c.is_a? String\n    c.downcase if c.is_a? String\n  end\n  s.chars.join\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work if the string contains\
    \ multiple letters.\n<|/ c |>\n<| c |>\nYes, I know. That's why I said \"The function\
    \ should return the resulted string.\" It should return the same string as in\
    \ the example. Anyway, I added a second solution that works with multiple letters.\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  s.chars.reverse_each.map { |c| c.upcase\
    \ if c.is_a?(String) }.join\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\n\
    <code>", "  s.gsub!(/[^A-Za-z]/,'')\n  s.gsub!(/[A-Z]/){|s| s.upcase}\n  s.gsub!(/[a-z]/){|s|\
    \ s.downcase}\n  s\nend", "  s.chars.each do |c|\n    next if c.nil?\n    next\
    \ if c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n    next\
    \ if c.upcase == c.downcase\n    next if c.upcase == c.downcase.upcase\n    next\
    \ if c.downcase == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase.downcase == c.downcase.upcase.downcase.upcase\n\
    \    next if c.downcase.upcase.downcase.upcase.downcase == c\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase\
    \ == c\n    next if c.downcase.upcase.downcase.", "  s.downcase!\n  s.gsub(/[^a-z]/i)\
    \ { |x| x.upcase }\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=0 |>\n\
    <code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c).gsub(c.downcase, c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.downcase).gsub(c.upcase, c.downcase)\n    end\n  end\n  s.gsub(/[^a-zA-Z]/,\
    \ '')\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '') \n  s\nend\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  s.chars.each do |c|\n\
    \    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase, c.upcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase).gsub(c.downcase,\
    \ c)\n    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a tags=ruby |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n   \
    \   s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    else\n      s = c\n    end\n  end\n  s\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i,\
    \ '')\n  s.reverse!\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't\
    \ work. Try it with `solve(\"ab\")`.\n<|/ c |>\n<| c |>\nIt works fine for me.\
    \ `solve(\"ab\")` returns `\"AB\"`.\n<|/ c |>\n<| c |>\nIt doesn't work for me\
    \ with Ruby 2.5.1. Try it with `solve(\"ab\")`.\n<|/ c |>\n<| c |>\nIt works for\
    \ me in Ruby 2.5.1. Try it with `solve(\"ab\")`.\n<|/ c |>\n<| c |>\nIt works\
    \ for me in Ruby 2.5.1. Try it with `solve(\"ab\")`.\n<|/ c |>\n<| a tags=ruby\
    \ |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c).gsub(c.downcase, c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase).gsub(c.downcase, c)\n    end\n  end\n  s.chars.join\nend\n</code>\n\
    <|/ a tags=ruby,string |>\n<| a dscore=0 |>\n<code>", "  s.gsub!(/[[:alpha:]]/)\
    \ { |s| s.upcase }\n  s.gsub!(/[[:alpha:]]/) { |s| s.downcase }\n  s.gsub!(/[^[:alpha:]]/)\
    \ { |s| s.reverse }\n  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n\
    \      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s =\
    \ s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.gsub(/[^a-zA-Z]/, \"\").reverse\n\
    end", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby |>\n<|\
    \ a dscore=0 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.upcase }\n  s\nend", "  s.chars.each do |c|\n    next if c.nil?\n  \
    \  if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase\
    \ == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if the string contains\
    \ multiple letters.\n<|/ c |>\n<| c |>\nI tested it and it works. I added a test\
    \ case to my answer.\n<|/ c |>\n<| c |>\nI tested it and it works. I added a test\
    \ case to my answer.\n<|/ c |>\n<| c |>\nI tested it and it works. I added a test\
    \ case to my answer.\n<|/ c |>\n<| c |>\nI tested it and it works. I added a test\
    \ case to my answer.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each\
    \ do |char|\n    if char.upcase == char\n      s.gsub!(char.upcase, char.downcase)\n\
    \    elsif char.downcase == char\n      s.gsub!(char.downcase, char.upcase)\n\
    \    else\n      s\n    end\n  end\n  s\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=ruby,string |>\n<code>", "  s = s.to_s\n  s.gsub!(/[^a-zA-Z]/, \"\").reverse!\n\
    \  s.gsub!(/[a-zA-Z]/, \"\")\n  s.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s\
    \ = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<|\
    \ c |>\nThanks for your answer. Your code works perfectly but i want to know why\
    \ my code is not working and what is the difference between my code and your code.\n\
    <|/ c |>\n<| c |>\nThe difference is that your code is iterating over each character\
    \ in the string and checking whether it is uppercase or lowercase. My code is\
    \ iterating over each character in the string and checking whether it is uppercase\
    \ or lowercase. Your code doesn't work because you were checking whether a character\
    \ was uppercase or lowercase and you were not checking whether it was a letter.\
    \ My code checks whether a character is a letter and then checks whether it is\
    \ uppercase or lowercase.\n<|/ c |>\n<| c |>\nThanks for your explanation. Now\
    \ i understand my mistake.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.gsub!(/[^A-Za-z]/,'')\n\
    \  s.gsub!(/[A-Z]/){|s| s.upcase}\n  s.gsub!(/[a-z]/){|s| s.downcase}\n  s\nend",
  "  s.chars.map { |c| c.upcase == c ? c.downcase : c }.join\nend\n</code>\n<|/ a\
    \ tags=ruby |>\n<| a tags=ruby |>\n<code>", "  s.chars.map { |c| c.upcase if c.is_a?(String)\
    \ }.compact.join.chars.map { |c| c.downcase if c.is_a?(String) }.compact.join\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=0 |>\n<code>", "  s.gsub!(/[^a-zA-Z]/,'')\n\
    \  s.gsub!(/[a-z]/){|s| s.upcase}\n  s.gsub!(/[A-Z]/){|s| s.downcase}\n  s\nend",
  "  s = s.to_s\n  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.gsub(/[^a-zA-Z]/, \"\").reverse\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n    next if c.nil?\n\
    \    next if c.empty?\n    next if c.upcase == c\n    next if c.downcase == c\n\
    \    next if c.upcase == c.downcase\n    next if c.upcase == c.downcase.upcase\n\
    \    next if c.downcase == c.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.",
  "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s\nend", "  s.downcase!\n\
    \  s.gsub(/[^a-z]/i) { |c| c.upcase }\n  s.gsub(/[a-z]/i) { |c| c.downcase }\n\
    \  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n   \
    \   s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.upcase)\n    end\n  end\n  s.gsub(/[^a-zA-Z]/, \"\")\nend\n</code>\n<|/ a\
    \ tags=ruby,string |>\n<| c |>\nThis doesn't work for \"#a@C\"\n<|/ c |>\n<| c\
    \ |>\nI tested it and it works fine for me. Can you give me an example where it\
    \ doesn't work?\n<|/ c |>\n<| c |>\nI tested it and it works fine for me. Can\
    \ you give me an example where it doesn't work?\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work for \"#a@C\" because `#` is an invalid character in a Ruby string. `#`\
    \ must be escaped.\n<|/ c |>\n<| c |>\nI tested it and it works fine for me. Can\
    \ you give me an example where it doesn't work?\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  s.chars.reverse_each.map {|c| c.upcase if c.is_a? String}.join\nend\n\
    </code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work. `'#a@C'.chars.reverse_each.map\
    \ {|c| c.upcase if c.is_a? String}.join` returns `\"#A@c\"`\n<|/ c |>\n<| c |>\n\
    I tested it on irb and it works. I guess you didn't copy the code correctly. Can\
    \ you please post the code you tried and what output you got?\n<|/ c |>\n<| c\
    \ |>\nI tested it on irb and it works. I guess you didn't copy the code correctly.\
    \ Can you please post the code you tried and what output you got?\n<|/ c |>\n\
    <| c |>\nI tested it on irb and it works. I guess you didn't copy the code correctly.\
    \ Can you please post the code you tried and what output you got?\n<|/ c |>\n\
    <| c |>\nI tested it on irb and it works. I guess you didn't copy the code correctly.\
    \ Can you please post the code you tried and what output you got?\n<|/ c |>\n\
    <| a tags=ruby,string |>\n<code>", "  s.chars.each do |c|\n    if c.upcase ==\
    \ c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n     \
    \ s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.join\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>", "  s.chars.each_with_index.map do\
    \ |char, i|\n    if char.upcase == char\n      char.downcase!\n    else\n    \
    \  char.upcase!\n    end\n  end.join\nend\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1\
    \ |>\n<code>", "  s.chars.reverse_each.map {|c| c.upcase if c.is_a? String}.join\n\
    end\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work for `\"#a@C\"`\n<|/ c |>\n\
    <| c |>\nI didn't know that `reverse_each` existed. Thanks for pointing that out.\n\
    <|/ c |>\n<| c |>\n`reverse_each` exists in Ruby 2.2+\n<|/ c |>\n<| c |>\n`reverse_each`\
    \ exists in Ruby 2.2+\n<|/ c |>\n<| c |>\n`reverse_each` exists in Ruby 2.2+\n\
    <|/ c |>\n<| a tags=ruby |>\n<code>", "  s.chars.reverse_each.map {|c| c.upcase\
    \ if c.is_a? String }.join\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like\
    \ the use of reverse_each and map here, but I think this can be simplified a bit.\
    \ `s.chars.reverse_each.map {|c| c.upcase if c.is_a? String }.join` should do\
    \ the same thing.\n<|/ c |>\n<| c |>\nYes, I agree. Thanks for pointing that out.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  s.chars.each do |c|\n    if c.upcase ==\
    \ c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif c.downcase == c\n     \
    \ s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n  s.chars.join\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work for `solve(\"\
    ab\") = \"AB\"`\n<|/ c |>\n<| c |>\nIt does, but you didn't specify that in your\
    \ question. I'll update my answer.\n<|/ c |>\n<| c |>\nI updated my answer. Thanks\
    \ for pointing that out.\n<|/ c |>\n<| c |>\nI updated my answer. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| c |>\nI updated my answer. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s = s.to_s\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend", "  s =\
    \ s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s|\
    \ s.downcase }\n  s\nend", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.reverse!\n  s\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.reverse!\n  s.chars.join\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis doesn't work for `solve(\"ab\") = \"AB\"`\n<|/ c |>\n<| c\
    \ |>\nI didn't downvote, but I suspect it's because you didn't explain what your\
    \ code does. You might want to add that to the answer.\n<|/ c |>\n<| c |>\nI added\
    \ a comment to the question. Thanks for your feedback.\n<|/ c |>\n<| c |>\nI added\
    \ a comment to the question. Thanks for your feedback.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i) {\
    \ |s| s.upcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n`s.gsub!(/[^a-z]/i,\
    \ '')` can be replaced with `s.downcase!`\n<|/ c |>\n<| c |>\n`s.gsub!(/[^a-z]/i,\
    \ '')` can be replaced with `s.downcase!`\n<|/ c |>\n<| a tags=ruby,string |>\n\
    <code>", "  s.chars.map { |c| c.upcase if c.is_a?(String) }.compact.join\nend",
  "  s.gsub!(/[a-z]/i) { |x| x.upcase }\n  s.gsub!(/[A-Z]/i) { |x| x.downcase }\n\
    \  s.gsub!(/[^A-Za-z]/i) { |x| x.reverse }\n  s\nend", "  s.downcase!\n  s.gsub(/[^a-z]/i)\
    \ { |x| x.upcase }\nend", "  s = s.to_s\n  s.gsub!(/[^a-z]/i) { |c| c.upcase }\n\
    \  s.gsub!(/[a-z]/i) { |c| c.downcase }\n  s\nend\n</code>\n<|/ a dscore=1 |>\n\
    <| a tags=ruby |>\n<code>", "  s = s.to_s\n  s.gsub!(/[^A-Za-z]/, '')\n  s.downcase!\n\
    \  s.reverse!\n  s\nend", "  s = s.to_s.gsub(/[[:alpha:]]/) { |s| s.upcase }\n\
    \  s = s.to_s.gsub(/[[:alpha:]]/) { |s| s.downcase }\n  s = s.to_s.gsub(/[[:alpha:]]/)\
    \ { |s| s.reverse }\n  s\nend", "  s.downcase!\n  s.gsub(/[^a-z]/i) { |c| c.upcase\
    \ }\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't work if you have\
    \ a string like \"#a@C\"\n<|/ c |>\n<| c |>\nIt works fine for me. `solve(\"#a@C\"\
    )` returns `\"#A@c\"`.\n<|/ c |>\n<| c |>\nIt works for me too. `solve(\"#a@C\"\
    )` returns `\"#A@c\"`\n<|/ c |>\n<| c |>\nI tested it on ruby 2.4.0 and it works.\
    \ I guess it depends on the ruby version you are using.\n<|/ c |>\n<| c |>\nI\
    \ tested it on ruby 2.4.0 and it works. I guess it depends on the ruby version\
    \ you are using.\n<|/ c |>\n<| a dscore=0 |>\n<code>", "  s.gsub!(/[^a-z]/i) {\
    \ |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend", "  s = s.downcase\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '')\n\
    \  s\nend", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c).gsub(c.downcase, c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase,\
    \ c.downcase).gsub(c.upcase, c.downcase)\n    end\n  end\n  s.chars.join\nend\n\
    </code>\n<|/ a |>\n<| c |>\nThis doesn't work if there are multiple letters in\
    \ the string that need to be reversed.\n<|/ c |>\n<| c |>\nIt does work, just\
    \ tested it. Try it out yourself.\n<|/ c |>\n<| c |>\nIt doesn't work if there\
    \ are multiple letters in the string that need to be reversed.\n<|/ c |>\n<| c\
    \ |>\nIt does work, just tested it. Try it out yourself.\n<|/ c |>\n<| c |>\n\
    It doesn't work if there are multiple letters in the string that need to be reversed.\n\
    <|/ c |>\n<| a dscore=4 |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i) { |s|\
    \ s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend", "  s = s.downcase\n\
    \  s.gsub!(/[^a-z]/i) { |s| s.upcase }\n  s\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis doesn't work if the string contains numbers. Try `solve(\"\
    12a34\")`.\n<|/ c |>\n<| c |>\nYes, I noticed that after I posted my answer. Thanks\
    \ for pointing it out.\n<|/ c |>\n<| c |>\nI didn't downvote, but I suspect it's\
    \ because your answer doesn't work. Try `solve(\"12a34\")`.\n<|/ c |>\n<| c |>\n\
    I didn't downvote, but I suspect it's because your answer doesn't work. Try `solve(\"\
    12a34\")`.\n<|/ c |>\n<| c |>\nI didn't downvote, but I suspect it's because your\
    \ answer doesn't work. Try `solve(\"12a34\")`.\n<|/ c |>\n<| a dscore=5 |>\n<code>",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n\
    \  end\n  s.chars.reverse!\n  s.chars.join\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis doesn't work. `solve(\"ab\")` returns `\"Ab\"`, not `\"AB\"\
    `.\n<|/ c |>\n<| c |>\nThanks for pointing out. I've fixed the code now.\n<|/\
    \ c |>\n<| a tags=ruby,string |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }\n  s.reverse!\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\n\
    This doesn't work for `solve(\"ab\") = \"AB\"`\n<|/ c |>\n<| c |>\nI believe this\
    \ does work. `s.gsub!(/[^a-z]/i) { |s| s.upcase }` replaces any character that\
    \ is not a letter with an uppercase version of that letter. `s.downcase!` converts\
    \ the string to all lowercase letters. `s.reverse!` reverses the string.\n<|/\
    \ c |>\n<| c |>\nI believe this does work. `s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }` replaces any character that is not a letter with an uppercase version of\
    \ that letter. `s.downcase!` converts the string to all lowercase letters. `s.reverse!`\
    \ reverses the string.\n<|/ c |>\n<| c |>\nI believe this does work. `s.gsub!(/[^a-z]/i)\
    \ { |s| s.upcase }` replaces any character that is not a letter with an uppercase\
    \ version of that letter. `s.downcase!` converts the string to all lowercase letters.\
    \ `s.reverse!` reverses the string.\n<|/ c |>\n<| c |>\nI believe this does work.\
    \ `s.gsub!(/[^a-z]/i) { |s| s.upcase }` replaces any character that is not a letter\
    \ with an uppercase version of that letter. `s.downcase!` converts the string\
    \ to all lowercase letters. `s.reverse!` reverses the string.\n<|/ c |>\n<| a\
    \ tags=ruby |>\n<code>", "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |x| x.upcase\
    \ }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend", "  s.chars.each do |char|\n\
    \    if char.upcase == char\n      s = s.gsub(/#{char}/, char.downcase)\n    elsif\
    \ char.downcase == char\n      s = s.gsub(/#{char}/, char.upcase)\n    end\n \
    \ end\n  s.gsub(/[^A-Z]/, \"\")\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby\
    \ |>\n<code>", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i) {\
    \ |s| s.upcase }\n  s\nend", "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s| s.upcase\
    \ }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend", "  s.chars.each do |c|\n\
    \    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n    next\
    \ if c.downcase == c\n    next if c.upcase == c.downcase\n    next if c.downcase\
    \ == c.upcase\n    next if c.upcase == c.downcase.upcase\n    next if c.downcase\
    \ == c.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase\n \
    \   next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.each do |c|\n    next if c.nil?\n    c.upcase if c.is_a?(String)\n  \
    \  c.downcase if c.is_a?(String)\n  end\n  s.chars.join\nend\n</code>\n<|/ a tags=ruby\
    \ |>\n<| c |>\nI like this solution. I'd like to see a benchmark test to compare\
    \ the performance of different solutions.\n<|/ c |>\n<| c |>\nI added a benchmark\
    \ test in my answer. Hope it helps.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.each do |char|\n    if char.upcase == char\n      s = s.gsub(char.upcase,\
    \ char.downcase)\n    elsif char.downcase == char\n      s = s.gsub(char.downcase,\
    \ char.upcase)\n    else\n      s = char\n    end\n  end\n  s.reverse!\n  s\n\
    end", "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i, '') \n  s.reverse!\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a dscore=0 |>\n<code>", "  s.chars.each\
    \ do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n    elsif\
    \ c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    end\n  end\n  s.chars.reverse!\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work if the\
    \ string contains any non-letters.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ doesn't require the letters to be in any particular order.\n<|/ c |>\n<| c |>\n\
    I added a solution that doesn't require the letters to be in any particular order.\n\
    <|/ c |>\n<| c |>\nI added a solution that doesn't require the letters to be in\
    \ any particular order.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>", "  s.chars.each\
    \ do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase == c\n\
    \    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next if\
    \ c.downcase == c.upcase\n    next if c.upcase == c.downcase.upcase\n    next\
    \ if c.downcase == c.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c).gsub(c.downcase,\
    \ c.upcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase).gsub(c.downcase,\
    \ c)\n    else\n      s = c\n    end\n  end\n  s\nend", "  s = s.to_s\n  s.downcase!\n\
    \  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '')\n  s.reverse!\n\
    \  s\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if the string contains\
    \ only letters.\n<|/ c |>\n<| c |>\nIt doesn't work if the string contains only\
    \ letters. Try it with `solve(\"aBcD\")`.\n<|/ c |>\n<| c |>\nIt doesn't work\
    \ if the string contains only letters. Try it with `solve(\"aBcD\")`.\n<|/ c |>\n\
    <| c |>\nIt doesn't work if the string contains only letters. Try it with `solve(\"\
    aBcD\")`.\n<|/ c |>\n<| c |>\nIt doesn't work if the string contains only letters.\
    \ Try it with `solve(\"aBcD\")`.\n<|/ c |>\n<| a tags=ruby,string |>\n<code>",
  "  s.downcase!\n  s.gsub!(/[^a-z]/i, '')\n  s.reverse!\n  s.gsub!(/[a-z]/i, '')\n\
    \  s.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase,\
    \ c.downcase)\n    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n\
    \    end\n  end\n  s.chars.join\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis\
    \ doesn't work. `solve(\"ab\")` returns `\"A@b\"` instead of `\"AB\"`.\n<|/ c\
    \ |>\n<| c |>\nI tested it and it works. I guess you didn't test it correctly.\n\
    <|/ c |>\n<| c |>\nYes, I tested it too. My mistake.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  s.downcase!\n  s.gsub(/[^a-z]/i) { |s| s.upcase }\nend\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis does not work. `solve(\"ab\")` returns `\"Ab\"\
    ` instead of `\"AB\"`.\n<|/ c |>\n<| c |>\nI fixed the problem with the `gsub`\
    \ call. Thanks.\n<|/ c |>\n<| a dscore=1 |>\n<code>", "  s.chars.reverse_each.map\
    \ { |c| c.upcase if c.is_a? String }.join\nend", "  s.gsub!(/[a-z]/){|x| x.upcase\
    \ if x.downcase == x }\n  s.gsub!(/[A-Z]/){|x| x.downcase if x.upcase == x }\n\
    \  s.gsub!(/[^a-zA-Z]/){|x| x.reverse }\n  s\nend", "  s.downcase!\n  s.gsub(/[^a-z]/)\
    \ do |x|\n    x.upcase if x.match?(/[a-z]/)\n    x.downcase if x.match?(/[A-Z]/)\n\
    \    x\n  end\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't\
    \ work. Try it with `solve(\"ab\") = \"AB\"`\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I've updated the answer.\n<|/ c |>\n<| c |>\n`x.upcase if x.match?(/[a-z]/)`\
    \ can be written as `x.upcase if x.match?(/[a-z]/i).to_i`\n<|/ c |>\n<| c |>\n\
    Thanks for pointing that out. I've updated the answer.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s = s.to_s.downcase\n  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n\
    \  s.gsub!(/[a-z]/i) { |x| x.downcase }\n  s\nend\n</code>\n<|/ a dscore=0 |>\n\
    <| a dscore=0 |>\n<code>", "  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i)\
    \ { |x| x.downcase }\n  s\nend", "  s.gsub(/[a-z]/i) do |x|\n    x.upcase if x.match?(/[a-z]/i)\n\
    \    x.downcase if x.match?(/[A-Z]/i)\n    x\n  end\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThanks for your answer. Your code works but I don't understand\
    \ why it works. Can you please explain it?\n<|/ c |>\n<| c |>\nI added some explanation.\
    \ Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your explanation. Your code works\
    \ but I don't understand why it works. Can you please explain it?\n<|/ c |>\n\
    <| c |>\nI added some explanation. Hope it helps.\n<|/ c |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  s = s.downcase\n  s.gsub!(/[^a-z]/i, '')\n  s.gsub!(/[a-z]/i)\
    \ { |s| s.upcase }\n  s\nend\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't\
    \ work for `solve(\"ab\")` which should return `\"AB\"`.\n<|/ c |>\n<| c |>\n\
    It does work for me. `solve(\"ab\")` returns `\"AB\"`.\n<|/ c |>\n<| c |>\nIt\
    \ doesn't work for `solve(\"ab\")` which should return `\"AB\"`.\n<|/ c |>\n<|\
    \ c |>\nIt does work for me. `solve(\"ab\")` returns `\"AB\"`.\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work for `solve(\"ab\")` which should return `\"AB\"`.\n<|/ c\
    \ |>\n<| a dscore=1 |>\n<code>", "  s = s.downcase\n  s.gsub!(/[^a-z]/i) { |s|\
    \ s.upcase }\n  s.reverse!\n  s\nend", "  s = s.to_s\n  s.gsub!(/[^a-z]/i) { |s|\
    \ s.upcase }\n  s.gsub!(/[a-z]/i) { |s| s.downcase }\n  s\nend\n</code>\n<|/ a\
    \ tags=ruby,string |>\n<| c |>\nThe OP said \"The function should return the resulted\
    \ string.\"\n<|/ c |>\n<| c |>\nI guess I missed that part. Thanks for pointing\
    \ it out.\n<|/ c |>\n<| c |>\nI added a more concise solution using `gsub!`\n\
    <|/ c |>\n<| c |>\nI like your solution, very concise. Thanks!\n<|/ c |>\n<| c\
    \ |>\nI added a more concise solution using `gsub!`\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>", "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n  \
    \  next if c.upcase == c\n    next if c.downcase == c\n    next if c.upcase ==\
    \ c.downcase\n    next if c.upcase == c.downcase.upcase\n    next if c.downcase\
    \ == c.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase\n \
    \   next if c.upcase == c.downcase.upcase.downcase\n    next if c.downcase ==\
    \ c.upcase.downcase.upcase.downcase\n    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n\
    \  s.gsub!(/[^A-Z]/i) { |x| x.upcase }\n  s.gsub!(/[A-Z]/i) { |x| x.downcase }\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work if there\
    \ are multiple uppercase letters in the string.\n<|/ c |>\n<| c |>\nI thought\
    \ that would be the case but when I tested it it worked fine.\n<|/ c |>\n<| c\
    \ |>\nIt doesn't work if there are multiple uppercase letters in the string. Try\
    \ it with `solve(\"AaBbCc\")`.\n<|/ c |>\n<| c |>\nI tested it and it works fine\
    \ for me. `solve(\"AaBbCc\")` returns `\"AbCc\"`\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works fine for me. `solve(\"AaBbCc\")` returns `\"AbCc\"`\n<|/ c |>\n\
    <| a tags=ruby,string |>\n<code>", "  s.gsub!(/[^A-Za-z]/,'')\n  s.gsub!(/[A-Z]/){|s|\
    \ s.upcase}\n  s.gsub!(/[a-z]/){|s| s.downcase}\n  s\nend", "  s.chars.each do\
    \ |char|\n    if char.upcase == char\n      s.gsub!(char, char.downcase)\n   \
    \ elsif char.downcase == char\n      s.gsub!(char, char.upcase)\n    end\n  end\n\
    \  s\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string |>\n<code>",
  "  s.chars.each do |c|\n    next if c.nil?\n    next if c.empty?\n    next if c.upcase\
    \ == c\n    next if c.downcase == c\n    next if c.upcase == c.downcase\n    next\
    \ if c.upcase == c.downcase.upcase\n    next if c.downcase == c.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase\n    next if c.upcase == c.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase\n    next if c.upcase\
    \ == c.downcase.upcase.downcase.upcase.downcase\n    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.downcase == c.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase\n\
    \    next if c.upcase == c.downcase.upcase.downcase.upcase.downcase.upcase.downcase.upcase.downcase.up",
  "  s.chars.each do |c|\n    if c.upcase == c\n      s = s.gsub(c.upcase, c.downcase)\n\
    \    elsif c.downcase == c\n      s = s.gsub(c.downcase, c.upcase)\n    else\n\
    \      s = c\n    end\n  end\n  s.reverse!\n  s\nend\n</code>\n<|/ a tags=ruby,string\
    \ |>\n<| c |>\nThis doesn't work if the string contains numbers. For example,\
    \ `solve(\"1234\")` returns `\"4321\"` instead of `\"1234\"`.\n<|/ c |>\n<| c\
    \ |>\nIt does work. `1234` is reversed as `\"4321\"`.\n<|/ c |>\n<| c |>\nYes,\
    \ it does. But it also returns `\"4321\"` for `\"1234\"`.\n<|/ c |>\n<| c |>\n\
    Yes, it does. But it also returns `\"4321\"` for `\"1234\"`.\n<|/ c |>\n<| c |>\n\
    It doesn't work. `solve(\"1234\")` returns `\"4321\"` instead of `\"1234\"`.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>", "  s.chars.reverse_each.with_index.reduce(:+).to_s\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  s.downcase!\n \
    \ s.gsub!(/[^a-z]/i) { |x| x.upcase }\n  s.gsub!(/[a-z]/i) { |x| x.downcase }\n\
    \  s\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer! I didn't\
    \ know about `downcase!` and `gsub!`. However, I still don't understand why my\
    \ code doesn't work. Could you please explain it to me?\n<|/ c |>\n<| c |>\nThe\
    \ `gsub!` method modifies the string in place. Since you didn't assign the result\
    \ of the `gsub!` method to a variable, the original string was modified. `downcase!`\
    \ modifies the string in place and returns the modified string. Since you didn't\
    \ assign the result of the `downcase!` method to a variable, the original string\
    \ was modified and returned.\n<|/ c |>\n<| c |>\nThanks for your explanation!\
    \ I understand now. :)\n<|/ c |>\n<| a dscore=1 |>\n<code>"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
