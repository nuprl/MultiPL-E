name: HumanEval_11_string_xor
language: ruby
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\n# >>> string_xor('010',\
  \ '110')\n# '100'\ndef string_xor(a, b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n\
  \    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"\
  111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n\
  \    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"
completions: ["  result = \"\"\n  a.each_byte { |c| result << c ^ b.shift }\n  result\n\
    end", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor_bin = a_bin ^ b_bin\n \
    \ xor_bin.to_s(2)\nend", "  result = \"\"\n  a.each_byte { |c| result << c ^ b.shift\
    \ }\n  result\nend", "  result = \"\"\n  a.each_byte do |x|\n    result << x ^\
    \ b.byte(0) if x != 0\n  end\n  result\nend", "  a = a.to_s\n  b = b.to_s\n  result\
    \ = ''\n  a.each_byte do |x|\n    result << x ^ b[a.index(x)]\n  end\n  result\n\
    end", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte do |char|\n  \
    \  result << char if char != b[a.index(char)]\n  end\n  result\nend", "  result\
    \ = ''\n  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", "  a.each_byte\
    \ { |c| c ^ b.shift }\n  a.join\nend", "  a.each_byte { |c| c ^ b.shift }\n  a.join\n\
    end", "  a_bin = a.to_s(2).split('')\n  b_bin = b.to_s(2).split('')\n  result\
    \ = a_bin.map { |e| e ^ b_bin[a.index(e.to_i)] }.join('')\n  result.to_s(2)\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nI like this solution, however it seems\
    \ to have some issues. I tested it on `string_xor('010', '110')` and it returns\
    \ `'100'` instead of `'110'`. Also, it seems to have some issues with strings\
    \ with leading zeros. For example, `string_xor('001', '101')` returns `'101'`\
    \ instead of `'010'`.\n<|/ c |>\n<| c |>\nI fixed the leading zeros issue by adding\
    \ `.reverse` before `map`. Thanks for pointing that out. Now it seems to work\
    \ fine on all test cases.\n<|/ c |>\n<| c |>\nI tested it on `string_xor('001',\
    \ '101')` and it returns `'101'` instead of `'010'`.\n<|/ c |>\n<| c |>\nI fixed\
    \ the leading zeros issue by adding `.reverse` before `map`. Thanks for pointing\
    \ that out. Now it seems to work fine on all test cases.\n<|/ c |>\n<| c |>\n\
    I tested it on `string_xor('001', '101')` and it returns `'101'` instead of `'010'`.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>", "  result = \"\"\n  a.each_byte { |c| result\
    \ << c ^ b.shift }\n  result\nend", "  a.each_byte { |c| b << c }\n  b.each_byte\
    \ { |c| a << c }\n  a.to_s\nend", "  a.each_byte { |c| c ^ b.shift }\n  a.to_s\n\
    end", "  result = \"\"\n  a.each_byte { |c| result << c ^ b.bytes[c] }\n  result\n\
    end", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\n  a.each_byte { |c| result\
    \ << c ^ b.shift }\n  result\nend\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\n\
    I like this solution, but I wonder how it compares to `String#unpack`.\n<|/ c\
    \ |>\n<| c |>\nI guess it depends on how you define \"compare\". The `unpack`\
    \ method will return a `String` object with the binary representation of your\
    \ input. `String#unpack` will return a `Fixnum` object with the binary representation\
    \ of your input. `String#unpack` will return a `Fixnum` object with the binary\
    \ representation of your input. `String#unpack` will return a `Fixnum` object\
    \ with the binary representation of your input. `String#unpack` will return a\
    \ `Fixnum` object with the binary representation of your input. `String#unpack`\
    \ will return a `Fixnum` object with the binary representation of your input.\
    \ `String#unpack` will return a `Fixnum` object with the binary representation\
    \ of your input. `String#unpack` will return a `Fixnum` object with the binary\
    \ representation of your input. `String#unpack` will return a `Fixnum` object\
    \ with the binary representation of your input. `String#unpack` will return a\
    \ `Fixnum` object with the binary representation of your input. `String#unpack`\
    \ will return a `Fixnum` object with the binary representation of your input.\
    \ `String#unpack` will return a `Fixnum` object with the binary representation\
    \ of your input. `String#unpack` will return a `Fixnum` object with the binary\
    \ representation of your input. `String#unpack` will return a `Fixnum` object\
    \ with the binary representation of your input. `String#unpack` will return a\
    \ `Fixnum` object with the binary representation of your input. `String#unpack`\
    \ will return a `Fixnum` object with the binary representation of your input.\
    \ `String#unpack` will return a `Fixnum` object with the binary representation\
    \ of your input. `String#unpack` will return a `Fixnum` object with the binary\
    \ representation of your input. `String#unpack` will return a `Fixnum` object\
    \ with the binary representation of your input. `String#unpack` will return a\
    \ `Fixnum` object with the binary representation of your input. `String#unpack`\
    \ will return a `Fixnum` object with the binary representation of your input.\
    \ `String#unpack` will return a `Fixnum` object with the binary representation\
    \ of your input. `String#unpack` will return a `Fixnum` object with the binary\
    \ representation of your input. `String#unpack` will return a `", "  a = a.to_s\n\
    \  b = b.to_s\n  result = ''\n  for i in 0...a.length\n    result << (a[i] ^ b[i])\n\
    \  end\n  return result\nend", "  a.each_byte { |c| b << c }\n  b.each_byte {\
    \ |c| a << c }\n  a.to_s\nend", "  a = a.to_s\n  b = b.to_s\n  result = ''\n \
    \ a.each_byte do |char|\n    result << char if char != b[a.index(char)]\n  end\n\
    \  result\nend", "  result = \"\"\n  a.each_byte { |b| result << b.chr if b ==\
    \ 0 }\n  b.each_byte { |b| result << b.chr if b == 0 }\n  result\nend", "  a =\
    \ a.to_s\n  b = b.to_s\n  result = ''\n  for i in 0...a.length\n    result <<\
    \ ((a[i] ^ b[i]) ? '1' : '0')\n  end\n  return result\nend", "  a.each_byte {\
    \ |c| b << c }\n  b.each_byte { |c| a << c }\n  a.join\nend", "  a_bin = a.to_s(2)\n\
    \  b_bin = b.to_s(2)\n  xor = a_bin ^ b_bin\n  xor.to_s(2)\nend", "  a.each_byte\
    \ { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.join\nend", "  a_bin = a.to_s(2).split('').reverse.join\n\
    \  b_bin = b.to_s(2).split('').reverse.join\n  xor = a_bin ^ b_bin\n  xor.to_s(2).split('').reverse.join\n\
    end", "  a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.join\n\
    end", "  a.each_byte { |c| c ^ b.shift }\n  a.join\nend", "  a.each_byte { |c|\
    \ b << c }\n  b.each_byte { |c| a << c }\n  a.to_s\nend", "  a_bin = a.to_s(2)\n\
    \  b_bin = b.to_s(2)\n  result = a_bin ^ b_bin\n  result.to_s(2)\nend", "  result\
    \ = \"\"\n  for i in 0..(b.length-1)\n    result << a[i] ^ b[i]\n  end\n  return\
    \ result\nend", "  result = \"\"\n  a.each_byte { |c| result << c ^ b.shift }\n\
    \  result\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor = a_bin ^ b_bin\n\
    \  xor.to_s(2)\nend", "  result = \"\"\n  a.each_byte { |c| result << c ^ b.shift\
    \ }\n  result\nend", "  a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c\
    \ }\n  a.to_s\nend", "  result = ''\n  a.each_byte { |c| result << c ^ b.shift\
    \ }\n  result\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  result = a_bin\
    \ ^ b_bin\n  result.to_s(2)\nend", "  a = a.to_s\n  b = b.to_s\n  result = ''\n\
    \  for i in 0...a.length\n    result << (a[i] ^ b[i])\n  end\n  return result\n\
    end", "  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte\
    \ { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n\
    \  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c|\
    \ b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte\
    \ { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n\
    \  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c|\
    \ b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte\
    \ { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n\
    \  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c|\
    \ b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte\
    \ { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n\
    \  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c|\
    \ b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte\
    \ { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c", "  a = a.to_s\n\
    \  b = b.to_s\n  result = ''\n  a.each_byte do |c|\n    result << c ^ b[a.index(c)]\n\
    \  end\n  result\nend", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  for i in\
    \ 0...a.length\n    result << (a[i] ^ b[i])\n  end\n  return result\nend", " \
    \ a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor_bin = a_bin ^ b_bin\n  xor_bin.to_s(2)\n\
    end", "  result = \"\"\n  a.each_byte { |b| result << b ^ b.to_s(2) }\n  b.each_byte\
    \ { |b| result << b ^ b.to_s(2) }\n  result\nend", "  a_bin = a.to_s(2)\n  b_bin\
    \ = b.to_s(2)\n  xor_bin = a_bin ^ b_bin\n  xor_str = xor_bin.to_s(2)\n  xor_str.to_s(2)\n\
    end", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  result = a_bin ^ b_bin\n  result.to_s(2)\n\
    end\n</cell>\n<code language=julia-1.5>", "  a.each_byte { |c| c ^ b.shift }\n\
    \  a.join\nend", "  a.each_byte { |x| b << x }\n  b.each_byte { |x| a << x }\n\
    \  a.join\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor_bin = a.to_s(2)\
    \ ^ b.to_s(2)\n  xor_bin.to_s(2)\nend", "  result = \"\"\n  a.each_byte { |c|\
    \ result << c ^ b.shift }\n  result\nend", "  a.each_byte { |c| c ^ b.shift }\n\
    \  a.join\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor_bin = a_bin\
    \ ^ b_bin\n  xor_str = xor_bin.to_s(2)\n  xor_str.to_s(2)\nend", "  result = ''\n\
    \  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", "  a_bin = a.to_s(2)\n\
    \  b_bin = b.to_s(2)\n  xor = a_bin ^ b_bin\n  xor.to_s(2)\nend", "  a_bin = a.to_s(2)\n\
    \  b_bin = b.to_s(2)\n  result = a_bin ^ b_bin\n  result.to_s(2)\nend", "  a.each_byte\
    \ { |x| b << x }\n  b.each_byte { |x| a << x }\n  a.to_s\nend", "  result = \"\
    \"\n  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", "  a_bin = a.to_s(2)\n\
    \  b_bin = b.to_s(2)\n  xor = a_bin ^ b_bin\n  xor_str = xor.to_s(2)\n  xor_str.to_s(2)\n\
    end", "  a.each_byte { |b| b ^= b }\n  a.join\nend", "  result = \"\"\n  a.each_byte\
    \ { |c| result << c ^ b.bytes[c] }\n  result\nend", "  result = \"\"\n  a.each_byte\
    \ { |c| result << c ^ b.bytes[c] }\n  result\nend", "  a.each_byte { |c| b <<\
    \ c }\n  b.each_byte { |c| a << c }\n  a.join\nend", "  a_bin = a.to_s(2)\n  b_bin\
    \ = b.to_s(2)\n  xor = a_bin ^ b_bin\n  xor.to_s(2)\nend", "  a = a.to_s\n  b\
    \ = b.to_s\n  result = ''\n  a.each_byte do |x|\n    result << x ^ b[a.index(x)]\n\
    \  end\n  result\nend", "  a.each_byte { |c| b << c }\n  b.each_byte { |c| a <<\
    \ c }\n  a.join\nend", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte\
    \ { |c| result << c ^ b.shift }\n  result\nend", "  a_bin = a.to_s(2)\n  b_bin\
    \ = b.to_s(2)\n  xor = a_bin ^ b_bin\n  xor_str = xor.to_s(2)\n  xor_str.to_s(2)\n\
    end\n</code>\n<|/ a tags=ruby,bit-manipulation,xor,string |>\n<| c |>\nThis doesn't\
    \ work for strings with more than 2 characters. For example, `string_xor('010',\
    \ '110')` returns `'100'` instead of `'110'`.\n<|/ c |>\n<| c |>\nIt works for\
    \ strings with more than 2 characters. `string_xor('010', '110')` returns `'100'`\
    \ because `'100'` is `'110'` XOR `'10'`. The XOR operation is commutative.\n<|/\
    \ c |>\n<| c |>\nYes, but `'100'` is `'110'` XOR `'10'` XOR `'0'` XOR `'1'` XOR\
    \ `'0'` XOR `'1'` XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'`\
    \ XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'`\
    \ XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'`\
    \ XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'`\
    \ XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'`\
    \ XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'` XOR `'0'` XOR `'1'`\
    \ XOR `'0'` XOR `'1'` XOR `'0'` XOR ", "  a = a.to_s\n  b = b.to_s\n  result =\
    \ ''\n  for i in 0...a.length\n    result << (a[i] ^ b[i])\n  end\n  result\n\
    end", "  a.each_char.with_index do |x, i|\n    b.each_char.with_index do |y, j|\n\
    \      x^y if i == j\n    end\n  end\nend", "  a.each_char.with_index do |x, i|\n\
    \    b.each_char.with_index do |y, j|\n      x == '0' ? x == '1' && y == '0' ?\
    \ x == '1' : x == '0' : x == '1' && y == '0' ? x == '0' : x == '1' : x == '0'\
    \ ? x == '0' : x == '1'\n    end\n  end\nend", "  a.each_byte { |c| b << c }\n\
    \  b.each_byte { |c| a << c }\n  a.join\nend", "  a.each_byte { |c| b << c }\n\
    \  b.each_byte { |c| a << c }\n  a.to_s\nend", "  result = ''\n  a.each_byte do\
    \ |x|\n    result << x ^ b.byte\n  end\n  result\nend", "  result = \"\"\n  a.each_byte\
    \ do |x|\n    b.each_byte do |y|\n      result << x ^ y\n    end\n  end\n  result\n\
    end", "  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a ^= c }\n  b.each_byte { |c| b ^= c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a ^= c }\n  b.each_byte { |c|\
    \ b ^= c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a ^= c }\n  b.each_byte { |c| b ^= c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a ^= c }\n  b.each_byte { |c|\
    \ b ^= c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a ^= c }\n  b.each_byte { |c| b ^= c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a ^= c }\n  b.each_byte { |c|\
    \ b ^= c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a ^= c }\n  b.each_byte { |c| b ^= c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a ^= c }\n  b.each_byte { |c|\
    \ b ^= c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a ^= c }\n  b.each_byte ", "  result = ''\n  a.each_byte { |c| result\
    \ << c ^ b.shift }\n  result\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n\
    \  xor = a_bin ^ b_bin\n  xor.to_s(2)\nend", "  a.each_char.with_index do |x,\
    \ i|\n    b.each_char.with_index do |y, j|\n      x == '0' and y == '0' and a[i\
    \ + j + 1] == '0' ? a[i + j + 1] = '1' : a[i + j + 1] = '0'\n    end\n  end\n\
    \  a\nend", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  while a && b\n    result\
    \ << ((a[0] ^ b[0]) ? '1' : '0')\n    a = a.slice(1, a.length)\n    b = b.slice(1,\
    \ b.length)\n  end\n  result\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n\
    \  xor = a_bin ^ b_bin\n  xor.to_s(2)\nend", "  result = \"\"\n  for i in 0..(b.length-1)\n\
    \    result << a[i] ^ b[i]\n  end\n  return result\nend", "  a = a.to_s\n  b =\
    \ b.to_s\n  result = ''\n  a.each_byte do |char|\n    result << char if char !=\
    \ b[a.index(char)]\n  end\n  result\nend", "  result = \"\"\n  a.each_byte { |c|\
    \ result << c ^ b.shift }\n  result\nend", "  result = \"\"\n  for i in 0..(b.length-1)\n\
    \    result << a[i] ^ b[i]\n  end\n  return result\nend", "  a = a.to_s\n  b =\
    \ b.to_s\n  result = ''\n  a.each_byte { |c| result << c ^ b.shift }\n  result\n\
    end", "  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a ^= c }\n  b.each_byte { |c| b ^= c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a ^= c }\n  b.each_byte { |c|\
    \ b ^= c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a ^= c }\n  b.each_byte { |c| b ^= c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a ^= c }\n  b.each_byte { |c|\
    \ b ^= c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a ^= c }\n  b.each_byte { |c| b ^= c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a ^= c }\n  b.each_byte { |c|\
    \ b ^= c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a ^= c }\n  b.each_byte { |c| b ^= c }\n  a.each_byte { |c| a << c }\n\
    \  b.each_byte { |c| b << c }\n  a.each_byte { |c| a ^= c }\n  b.each_byte { |c|\
    \ b ^= c }\n  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte\
    \ { |c| a ^= c }\n  b.each_byte ", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n\
    \  xor = a_bin ^ b_bin\n  xor.to_s(2)\nend\n</cell>\n<code language=julia-1.0>",
  "  result = ''\n  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", " \
    \ a = a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte { |c| result << c ^ b.shift\
    \ }\n  result\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  result = a_bin\
    \ ^ b_bin\n  result.to_s(2)\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis doesn't\
    \ work. `'010'` becomes `\"010\"`, which then becomes `\"010\"` when converted\
    \ to a binary string. `'110'` becomes `\"110\"`, which then becomes `\"110\"`\
    \ when converted to a binary string. `'100'` becomes `\"100\"`, which then becomes\
    \ `\"100\"` when converted to a binary string. `'010'` becomes `\"010\"`, which\
    \ then becomes `\"010\"` when converted to a binary string. `'110'` becomes `\"\
    110\"`, which then becomes `\"110\"` when converted to a binary string. `'100'`\
    \ becomes `\"100\"`, which then becomes `\"100\"` when converted to a binary string.\
    \ `'010'` becomes `\"010\"`, which then becomes `\"010\"` when converted to a\
    \ binary string. `'110'` becomes `\"110\"`, which then becomes `\"110\"` when\
    \ converted to a binary string. `'100'` becomes `\"100\"`, which then becomes\
    \ `\"100\"` when converted to a binary string. `'010'` becomes `\"010\"`, which\
    \ then becomes `\"010\"` when converted to a binary string. `'110'` becomes `\"\
    110\"`, which then becomes `\"110\"` when converted to a binary string. `'100'`\
    \ becomes `\"100\"`, which then becomes `\"100\"` when converted to a binary string.\
    \ `'010'` becomes `\"010\"`, which then becomes `\"010\"` when converted to a\
    \ binary string. `'110'` becomes `\"110\"`, which then becomes `\"110\"` when\
    \ converted to a binary string. `'100'` becomes `\"100\"`, which then becomes\
    \ `\"100\"` when converted to a binary string. `'010'` becomes `\"010\"`, which\
    \ then becomes `\"010\"` when converted to a binary string. `'110'` becomes `\"\
    110\"`, which then becomes `\"110\"` when converted to a binary string. `'100'`\
    \ becomes `\"100\"`, which then becomes `\"", "  a.each_byte { |c| b << c }\n\
    \  b.each_byte { |c| a << c }\n  a.join\nend", "  a.each_byte { |c| a << 1 }\n\
    \  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c|\
    \ b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte\
    \ { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n\
    \  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c|\
    \ b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte\
    \ { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n\
    \  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c|\
    \ b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte\
    \ { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n\
    \  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c|\
    \ b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte\
    \ { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n\
    \  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c|\
    \ b << 1 }\n  a.each_byte { |c", "  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c|\
    \ a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c|\
    \ a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c|\
    \ a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c|\
    \ a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor_bin = xor(a_bin,\
    \ b_bin)\n  xor_bin.to_s(2)\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n\
    \  xor_bin = a_bin ^ b_bin\n  xor_bin.to_s(2)\nend", "  a.each_byte { |c| a <<\
    \ c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c| a ^ c }\n  b.each_byte\
    \ { |c| b ^ c }\n  a.join\nend", "  a.each_byte { |x| b << x }\n  b.each_byte\
    \ { |x| a << x }\n  a.join\nend", "  a.each_char.with_index.map { |x, i| x ^ b[i]\
    \ }.join\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor = a_bin ^ b_bin\n\
    \  xor_str = xor.to_s(2)\n  xor_str.to_s(2)\nend", "  a.each_byte { |c| a << 1\
    \ }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c|\
    \ a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c|\
    \ a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c|\
    \ a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c|\
    \ a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n\
    \  xor_bin = a_bin ^ b_bin\n  xor_bin.to_s(2)\nend", "  a = a.to_s\n  b = b.to_s\n\
    \  result = ''\n  while a.length >= b.length\n    result << a.slice!(0, b.length)\n\
    \    a << b.slice!(0, a.length)\n  end\n  result << a\n  result\nend", "  a.each_char.with_index.inject(\"\
    \") do |s, (char, i)|\n    s << char if char != b[i]\n    s\n  end\nend\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThanks for your answer. Your code works fine for small\
    \ strings, but it takes too long for larger strings. I edited my question to include\
    \ a larger test case.\n<|/ c |>\n<| c |>\nI updated my answer to include a more\
    \ efficient solution.\n<|/ c |>\n<| c |>\nThanks for your answer. Your code works\
    \ fine for small strings, but it takes too long for larger strings. I edited my\
    \ question to include a larger test case.\n<|/ c |>\n<| c |>\nI updated my answer\
    \ to include a more efficient solution.\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ Your code works fine for small strings, but it takes too long for larger strings.\
    \ I edited my question to include a larger test case.\n<|/ c |>\n<| a dscore=0\
    \ |>\n<code>", "  a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c }\n \
    \ a.join\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor = a_bin ^ b_bin\n\
    \  xor_str = xor.to_s(2)\n  return xor_str\nend", "  a = a.to_s\n  b = b.to_s\n\
    \  result = ''\n  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", " \
    \ result = \"\"\n  a.each_byte { |b| result << b ^ b.to_s(2) }\n  b.each_byte\
    \ { |a| result << a ^ a.to_s(2) }\n  result\nend", "  a_bin = a.to_s(2)\n  b_bin\
    \ = b.to_s(2)\n  xor = a_bin ^ b_bin\n  xor.to_s(2)\nend\n</cell>\n<code language=julia-1.5>",
  "  a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.to_s\nend", " \
    \ a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor = a_bin ^ b_bin\n  xor.to_s(2)\n\
    end", "  result = \"\"\n  a.each_byte { |b| result << b.chr if b == 0 }\n  b.each_byte\
    \ { |a| result << a.chr if a == 0 }\n  result\nend", "  a.each_byte { |c| b <<\
    \ c }\n  b.each_byte { |c| a << c }\n  a.join\nend", "  a = a.to_s\n  b = b.to_s\n\
    \  result = ''\n  a.each_byte do |x|\n    result << x ^ b[a.index(x)]\n  end\n\
    \  return result\nend", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  while a\
    \ && b\n    result << (a ^ b)\n    a, b = a.next, b\n  end\n  result\nend", " \
    \ a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor = a_bin ^ b_bin\n  xor_str = xor.to_s(2)\n\
    \  return xor_str\nend", "  a.each_byte { |b| a << b }\n  b.each_byte { |a| a\
    \ << b }\n  a.join\nend", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte\
    \ do |c|\n    result << c ^ b[a.index(c)]\n  end\n  result\nend", "  a = a.to_s\n\
    \  b = b.to_s\n  result = ''\n  a.each_byte { |c| result << c ^ b.shift }\n  result\n\
    end\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer. I'm still trying\
    \ to understand how this works. I understand that `a` and `b` are strings and\
    \ that `a.each_byte { |c| result << c ^ b.shift }` iterates over each character\
    \ in each string and performs a bitwise XOR operation on them. How does this work?\
    \ What is `b.shift` doing? Why does `a` and `b` have to be strings?\n<|/ c |>\n\
    <| c |>\n`a` and `b` are strings. `a.each_byte { |c| result << c ^ b.shift }`\
    \ iterates over each character in each string and performs a bitwise XOR operation\
    \ on them. `b.shift` shifts the string `b` by one character and performs a bitwise\
    \ XOR operation on that shifted string. `a` and `b` have to be strings because\
    \ `a.each_byte { |c| result << c ^ b.shift }` iterates over each character in\
    \ each string and performs a bitwise XOR operation on them. `b.shift` shifts the\
    \ string `b` by one character and performs a bitwise XOR operation on that shifted\
    \ string.\n<|/ c |>\n<| c |>\nI understand that `a` and `b` are strings and that\
    \ `a.each_byte { |c| result << c ^ b.shift }` iterates over each character in\
    \ each string and performs a bitwise XOR operation on them. How does this work?\
    \ What is `b.shift` doing? Why does `a` and `b` have to be strings?\n<|/ c |>\n\
    <| c |>\n`a` and `b` are strings. `a.each_byte { |c| result << c ^ b.shift }`\
    \ iterates over each character in each string and performs a bitwise XOR operation\
    \ on them. `b.shift` shifts the string `b` by one character and performs a bitwise\
    \ XOR operation on that shifted string. `a` and `b` have to be strings because\
    \ `a.each_byte { |c| result << c ^ b.shift }` iterates over each character in\
    \ each string and performs a bitwise XOR operation on them. `b.shift` shifts the\
    \ string `b` by one character and performs a bitwise X", "  a.each_char.with_index\
    \ do |x, i|\n    b.each_char.with_index do |y, j|\n      xor =\n        if x ==\
    \ '0' and y == '0'\n          '0'\n        else\n          x == '1' ? y : '0'\n\
    \        end\n      a.slice!(i).concat(b.slice!(j)).concat(xor)\n    end\n  end\n\
    \  a\nend", "  a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.to_s\n\
    end", "  a_bin = a.to_s(2).reverse\n  b_bin = b.to_s(2).reverse\n  xor = a_bin\
    \ ^ b_bin\n  xor.to_s(2).reverse\nend", "  a = a.to_s\n  b = b.to_s\n  result\
    \ = ''\n  a.each_byte do |x|\n    result << x ^ b\n  end\n  result\nend", "  result\
    \ = \"\"\n  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", "  a.each_byte\
    \ { |b| a << b }\n  b.each_byte { |a| a << b }\n  a.to_s\nend", "  a.each_byte\
    \ { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.join\nend", "  a_bin = a.to_s(2)\n\
    \  b_bin = b.to_s(2)\n  result = a_bin ^ b_bin\n  result.to_s(2)\nend", "  a =\
    \ a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte do |c|\n    result << c ^\
    \ b[a.index(c)]\n  end\n  result\nend", "  result = \"\"\n  a.each_byte { |c|\
    \ result << c ^ b.bytes[c] }\n  result\nend", "  result = \"\"\n  a.each_byte\
    \ { |c| result << c ^ b.shift }\n  result\nend", "  a.each_byte { |c| c ^ b.shift\
    \ }\n  a.join\nend", "  result = ''\n  a.each_byte { |c| result << c ^ b.shift\
    \ }\n  result\nend", "  result = \"\"\n  a.each_byte { |c| result << c ^ b.shift\
    \ }\n  result\nend", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte\
    \ { |c| result << c ^ b.shift }\n  result\nend", "  result = \"\"\n  for i in\
    \ 0..(b.length-1)\n    result << a.chars[i] ^ b.chars[i]\n  end\n  return result\n\
    end", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  result = a_bin ^ b_bin\n  result.to_s(2)\n\
    end", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\n  a.each_byte { |c| result\
    \ << c ^ b.shift }\n  result\nend", "  a = a.to_s\n  b = b.to_s\n  result = ''\n\
    \  a.each_byte { |c| result << c ^ b.shift }\n  result\nend\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=ruby,string |>\n<code>", "  a = a.to_s\n  b = b.to_s\n  result\
    \ = ''\n  a.each_byte do |char|\n    result << char if char != b[a.index(char)]\n\
    \  end\n  result\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor_bin =\
    \ xor(a_bin, b_bin)\n  return xor_bin.to_s(2)\nend", "  a_bin = a.to_s(2)\n  b_bin\
    \ = b.to_s(2)\n  xor = a_bin ^ b_bin\n  xor.to_s(2)\nend", "  a = a.to_s\n  b\
    \ = b.to_s\n  result = ''\n  for i in 0..(a.length - 1)\n    result << (a[i] ^\
    \ b[i])\n  end\n  result\nend", "  result = \"\"\n  a.each_byte { |c| result <<\
    \ c ^ b.shift }\n  result\nend", "  result = \"\"\n  a.each_byte { |c| result\
    \ << c ^ b.shift }\n  result\nend", "  a = a.to_s\n  b = b.to_s\n  result = \"\
    \"\n  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", "  a.each_byte\
    \ { |c| c ^ b.shift }\n  a.join\nend\n</code>\n<|/ a tags=ruby,bit-manipulation,bitwise-operators\
    \ |>\n<| c |>\nI like your use of shift and join to convert a binary string to\
    \ a binary string. Very clever!\n<|/ c |>\n<| a dscore=4 |>\n<code>", "  a = a.to_s\n\
    \  b = b.to_s\n  result = ''\n  a.each_byte { |c| result << c ^ b.shift }\n  result\n\
    end\n</code>\n<|/ a tags=ruby,string |>\n<| c |>\nThis doesn't work. Try it with\
    \ `string_xor('010', '110')`\n<|/ c |>\n<| c |>\n: I tested it and it works. What\
    \ do you mean by \"doesn't work\"? It returns `\"100\"` as expected.\n<|/ c |>\n\
    <| c |>\n: I added a version that works with strings of any length.\n<|/ c |>\n\
    <| c |>\n: I added a version that works with strings of any length.\n<|/ c |>\n\
    <| c |>\n: I added a version that works with strings of any length.\n<|/ c |>\n\
    <| a dscore=1 |>\n<code>", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte\
    \ do |x|\n    result << x ^ b[a.index(x)]\n  end\n  result\nend", "  result =\
    \ \"\"\n  a.each_byte do |x|\n    result << x ^ b.byte(result.length)\n  end\n\
    \  result\nend", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte do\
    \ |char|\n    result << char if char != b[a.index(char)]\n  end\n  result\nend",
  "  a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.join\nend", " \
    \ a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a ^= c }\n  b.each_byte { |c| b ^= c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a ^= c }\n  b.each_byte { |c| b ^= c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a ^= c }\n  b.each_byte { |c| b ^= c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a ^= c }\n  b.each_byte { |c| b ^= c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a ^= c }\n  b.each_byte { |c| b ^= c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a ^= c }\n  b.each_byte { |c| b ^= c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a ^= c }\n  b.each_byte { |c| b ^= c }\n  a.each_byte { |c| a << c }\n  b.each_byte\
    \ { |c| b << c }\n  a.each_byte { |c| a ^= c }\n  b.each_byte { |c| b ^= c }\n\
    \  a.each_byte { |c| a << c }\n  b.each_byte { |c| b << c }\n  a.each_byte { |c|\
    \ a ^= c }\n  b.each_byte ", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte\
    \ do |x|\n    result << x ^ b[a.index(x)]\n  end\n  result\nend", "  a = a.to_s\n\
    \  b = b.to_s\n  result = ''\n  while a && b\n    result << ((a[0] ^ b[0]).to_s)\n\
    \    a = a.slice(1, a.length)\n    b = b.slice(1, b.length)\n  end\n  result\n\
    end", "  result = ''\n  a.each_byte { |c| result << c ^ b.shift }\n  result\n\
    end", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  while a && b\n    result <<\
    \ (a ^ b)\n    a, b = a.next, b\n  end\n  result\nend", "  a.each_byte { |c| c\
    \ ^ b.shift }\n  a.join\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor\
    \ = a_bin ^ b_bin\n  xor_str = xor.to_s(2)\n  xor_str.to_s(2)\nend\n</code>\n\
    <|/ a tags=ruby,bit-manipulation |>\n<| c |>\nThis doesn't work for me. `string_xor(\"\
    010\", \"110\")` returns `\"100\"` instead of `\"010\"`.\n<|/ c |>\n<| c |>\n\
    : It works for me in Ruby 2.4.1. What version are you using?\n<|/ c |>\n<| c |>\n\
    : I tested it on Ruby 2.4.1 on Windows. I suspect that your version of Ruby doesn't\
    \ support binary literals.\n<|/ c |>\n<| c |>\n: I tested it on Ruby 2.4.1 on\
    \ Linux and it works. I suspect that your version of Ruby doesn't support binary\
    \ literals.\n<|/ c |>\n<| c |>\n: I tested it on Ruby 2.4.1 on OS X and it works.\
    \ I suspect that your version of Ruby doesn't support binary literals.\n<|/ c\
    \ |>\n<| a dscore=2 |>\nI wrote a gem for this: bitwise-string.\nIt supports binary\
    \ strings and binary numbers, as well as hexadecimal strings and hexadecimal numbers.\
    \ It's also available on GitHub.\n<|/ a tags=ruby,bit-manipulation |>\n<| a dscore=2\
    \ |>\n<code>", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor_bin = xor(a_bin,\
    \ b_bin)\n  xor_bin.to_s(2)\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n\
    \  xor = a_bin ^ b_bin\n  xor_str = xor.to_s(2)\n  xor_str.to_s(2)\nend", "  result\
    \ = \"\"\n  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", "  result\
    \ = \"\"\n  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", "  a =\
    \ a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte do |x|\n    result << x ^\
    \ b[a.index(x)]\n  end\n  result\nend", "  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c|\
    \ a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c|\
    \ a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c|\
    \ a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c|\
    \ a << 1 }\n  b.each_byte { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte\
    \ { |c| b << 1 }\n  a.each_byte { |c| a << 1 }\n  b.each_byte { |c| b << 1 }\n\
    \  a.each_byte { |c", "  result = \"\"\n  a.each_byte { |c| result << c ^ b.shift\
    \ }\n  result\nend", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte\
    \ { |c| result << c ^ b.shift }\n  result\nend", "  a = a.to_s\n  b = b.to_s\n\
    \  result = ''\n  for i in 0..(a.length-1)\n    result << (a[i] ^ b[i])\n  end\n\
    \  return result\nend", "  result = \"\"\n  a.each_byte { |x| result << x ^ b.shift\
    \ }\n  result\nend", "  result = \"\"\n  a.each_byte { |c| result << c ^ b.shift\
    \ }\n  result\nend", "  a.each_byte { |x| b << x }\n  b.each_byte { |x| a << x\
    \ }\n  a.to_s\nend", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\n  a.each_byte\
    \ { |x| result << x ^ b.shift }\n  result\nend", "  a.each_byte { |x| b << x }\n\
    \  b.each_byte { |x| a << x }\n  a.join\nend", "  a.each_byte { |c| c ^ b.shift\
    \ }\n  a.join\nend\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like your solution,\
    \ but I wonder if there is a way to avoid the intermediate array and just return\
    \ the string directly?\n<|/ c |>\n<| c |>\n: I added a version that doesn't use\
    \ an intermediate array. Not sure if that would be any faster.\n<|/ c |>\n<| c\
    \ |>\n: I added a version that doesn't use an intermediate array. Not sure if\
    \ that would be any faster.\n<|/ c |>\n<| c |>\n: I added a version that doesn't\
    \ use an intermediate array. Not sure if that would be any faster.\n<|/ c |>\n\
    <| a |>\n<code>", "  a = a.to_s\n  b = b.to_s\n  result = ''\n  for i in 0...a.length\n\
    \    result << (a[i] ^ b[i])\n  end\n  return result\nend", "  a.each_byte { |b|\
    \ a ^= b }\n  a.each_byte { |b| a ^= b }\n  a\nend", "  a_bin = a.to_s(2)\n  b_bin\
    \ = b.to_s(2)\n  xor = a_bin ^ b_bin\n  xor.to_s(2)\nend", "  a_bin = a.to_s(2)\n\
    \  b_bin = b.to_s(2)\n  xor = a_bin ^ b_bin\n  xor.to_s(2)\nend", "  a_bin = a.to_s(2)\n\
    \  b_bin = b.to_s(2)\n  result = a_bin ^ b_bin\n  result.to_s(2)\nend", "  result\
    \ = \"\"\n  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", "  a =\
    \ a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte { |c| result << c ^ b.shift\
    \ }\n  result\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor = a_bin\
    \ ^ b_bin\n  xor.to_s(2)\nend\n</code>\n<|/ a tags=ruby,string |>\n<| a tags=ruby,string\
    \ |>\n<code>", "  result = \"\"\n  for i in 0..(b.length-1)\n    result += (b.charAt(i)\
    \ != a.charAt(i) ? b.charAt(i) : \"\")\n  end\n  return result\nend", "  a = a.to_s\n\
    \  b = b.to_s\n  result = ''\n  while a && b\n    result << ((a[0] ^ b[0]).chr)\n\
    \    a = a.succ\n    b = b.succ\n  end\n  result\nend", "  a_bin = a.to_s(2)\n\
    \  b_bin = b.to_s(2)\n  xor = Array.new(a.length)\n  a_bin.each_byte { |b| xor[a.index(b)]=1\
    \ }\n  b_bin.each_byte { |b| xor[b.index(a)]=1 }\n  xor.map { |b| b.to_s(2) }.join\n\
    end", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\n  for i in 0...a.length\n\
    \    result << a[i] ^ b[i]\n  end\n  return result\nend", "  a.each_byte { |c|\
    \ c ^ b.shift }\n  a.join\nend\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work\
    \ for me. `string_xor(\"010\", \"110\")` returns `\"010\"`.\n<|/ c |>\n<| c |>\n\
    : It works for me in Ruby 1.9.3. What version are you using?\n<|/ c |>\n<| c |>\n\
    : It works for me in Ruby 1.9.3 too. Which version are you using?\n<|/ c |>\n\
    <| c |>\n: I tested in 1.8.7 and 1.9.2. Works fine in both.\n<|/ c |>\n<| c |>\n\
    : I tested in 1.8.7 and 1.9.2. Works fine in both.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>", "  a.each_byte { |c| b << c }\n  b.each_byte { |c| a << c }\n  a.join\n\
    end", "  a.each_byte { |x| b << x }\n  b.each_byte { |x| a << x }\n  a.join\n\
    end", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor = a_bin ^ b_bin\n  xor_str\
    \ = xor.to_s(2)\n  xor_str.to_s(2)\nend", "  result = \"\"\n  a.each_byte do |x|\n\
    \    result << x ^ b.byte(x.to_i)\n  end\n  result\nend", "  result = \"\"\n \
    \ a.each_byte { |c| result << c ^ b.shift }\n  result\nend", "  a.each_byte {\
    \ |c| c ^ b.shift }\n  a.join\nend", "  a.each_byte { |c| b << c }\n  b.each_byte\
    \ { |c| a << c }\n  a.to_s\nend", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n\
    \  result = a_bin ^ b_bin\n  result.to_s(2)\nend", "  result = \"\"\n  a.each_byte\
    \ { |c| result << c ^ b.shift }\n  result\nend", "  result = \"\"\n  a.each_byte\
    \ { |c| result << c ^ b.shift }\n  result\nend", "  a.each_char.with_index do\
    \ |x, i|\n    b.each_char.with_index do |y, j|\n      xor =\n        if x == '0'\
    \ and y == '1'\n          '1'\n        elsif x == '1' and y == '0'\n         \
    \ '0'\n        else\n          nil\n        end\n      xor += xor << j if xor\n\
    \    end\n  end\n  xor\nend", "  a = a.to_s\n  b = b.to_s\n  result = \"\"\n \
    \ a.each_byte do |x|\n    result << x ^ b[a.index(x)]\n  end\n  result\nend",
  "  result = \"\"\n  a.each_byte { |x| result << x ^ b.byte(0) }\n  result\nend",
  "  result = \"\"\n  a.each_byte { |c| result << c ^ b.shift }\n  result\nend", " \
    \ a.each_byte { |x| b << x }\n  b.each_byte { |x| a << x }\n  a.to_s\nend", " \
    \ a = a.to_s\n  b = b.to_s\n  result = ''\n  a.each_byte do |x|\n    result <<\
    \ x ^ b[a.index(x)]\n  end\n  result\nend", "  a.each_byte { |x| b << x }\n  b.each_byte\
    \ { |x| a << x }\n  a.join\nend\n</code>\n<|/ a tags=ruby,bit-manipulation |>\n\
    <| c |>\nI like this solution, but I wonder if there is a way to do it without\
    \ looping through the strings. I suppose it would be possible by looping through\
    \ the bits, but that would be a lot of extra work.\n<|/ c |>\n<| c |>\n: I added\
    \ a solution without looping through the strings. It's not very elegant, though.\n\
    <|/ c |>\n<| c |>\nThanks, I appreciate the effort. I will probably end up using\
    \ your solution, but I wanted to see if there was a way to do it without looping\
    \ through the strings. I suppose it would be possible by looping through the bits,\
    \ but that would be a lot of extra work.\n<|/ c |>\n<| c |>\n: I added a solution\
    \ without looping through the strings. It's not very elegant, though.\n<|/ c |>\n\
    <| c |>\nThanks, I appreciate the effort. I will probably end up using your solution,\
    \ but I wanted to see if there was a way to do it without looping through the\
    \ strings. I suppose it would be possible by looping through the bits, but that\
    \ would be a lot of extra work.\n<|/ c |>\n<| a tags=ruby,bit-manipulation |>\n\
    <code>", "  a_bin = a.to_s(2)\n  b_bin = b.to_s(2)\n  xor_bin = xor(a_bin, b_bin)\n\
    \  xor_bin.to_s(2)\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
