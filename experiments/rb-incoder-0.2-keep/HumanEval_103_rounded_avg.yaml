name: HumanEval_103_rounded_avg
language: ruby
prompt: "# You are given two positive integers n and m, and your task is to compute\
  \ the\n# average of the integers from n through m (including n and m). \n# Round\
  \ the answer to the nearest integer and convert that to binary.\n# If n is greater\
  \ than m, return -1.\n# Example:\n# rounded_avg(1, 5) => \"0b11\"\n# rounded_avg(7,\
  \ 5) => -1\n# rounded_avg(10, 20) => \"0b1111\"\n# rounded_avg(20, 33) => \"0b11010\"\
  \ndef rounded_avg(n, m)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_rounded_avg\n\
  \    candidate = method(:rounded_avg)\n    assert_equal(\"0b11\", candidate.call(1,\
  \ 5))\n    assert_equal(\"0b1010\", candidate.call(7, 13))\n    assert_equal(\"\
  0b1111001010\", candidate.call(964, 977))\n    assert_equal(\"0b1111100100\", candidate.call(996,\
  \ 997))\n    assert_equal(\"0b1011000010\", candidate.call(560, 851))\n    assert_equal(\"\
  0b101101110\", candidate.call(185, 546))\n    assert_equal(\"0b110101101\", candidate.call(362,\
  \ 496))\n    assert_equal(\"0b1001110010\", candidate.call(350, 902))\n    assert_equal(\"\
  0b11010111\", candidate.call(197, 233))\n    assert_equal(-1, candidate.call(7,\
  \ 5))\n    assert_equal(-1, candidate.call(5, 1))\n    assert_equal(\"0b101\", candidate.call(5,\
  \ 5))\n  end\nend\n"
completions: ["  avg = ((n..m).to_a.reduce(:+) / 2).round\n  avg.zero? ? -1 : sprintf(\"\
    0b%b\", avg)\nend", "  avg = ((n..m).sum / 2).round\n  binary = []\n  while n\
    \ <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse.join\
    \ if binary.length >= 2\nend", "  sum = 0\n  for i in 0...m\n    sum += n\n  end\n\
    \  sum.to_s(2).reverse.rjust(8, \"0\")\nend", "  avg = ((n..m).sum.to_f / m).round\n\
    \  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n\
    \  binary.reverse.each_with_index do |digit, index|\n    digit = digit.next\n\
    \    digit = digit.to_s(2)\n    digit = digit.insert(index, \"0\")\n    digit\
    \ << binary[index]\n  end\n  binary.join\nend", "  ((n..m).to_a * -1).inject(:+)\
    \ / 2.0\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n  while\
    \ n <= m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.reverse.inject(:+).to_s(2)\n\
    end", "  sum = 0\n  n.upto(m) do |i|\n    sum += i\n  end\n  sum.round(0, 1).to_s(2)\n\
    end", "  \n  if m > n\n    return -1\n  \n  sum = 0\n  \n  for i in 0...m\n  \
    \  sum += n\n  end\n  \n  sum.to_s(2).reverse.gsub(/../) { |s| s.to_i(2) }\nend",
  "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.each_with_index do |digit, index|\n    digit\
    \ = digit.to_i(2).to_s(2)\n    digit = digit.insert(index, \"0\")\n    digit =\
    \ digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\")\n    digit\
    \ = digit.insert(index, \"", "  \n  avg = ((n..m).to_a.sum.to_f / m).round\n \
    \ \n  if avg < 0\n    -1\n  else\n    bin = avg.to_s(2).reverse\n    bin.insert(0,\
    \ '0b')\n    bin\n  end\nend\n</cell>\n<cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\n\
    rounded_avg(10, 20)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nroun", "  avg = ((n..m).to_a + (n..m).to_a).sum / 2.0\n\
    \  avg.round\n  avg.to_s(2).to_i(2).to_s(2)\nend", "  n = (n+m)/2\n  m = (m+n)/2\n\
    \  n = (n.to_s(2)).rjust(8, \"0\")\n  m = (m.to_s(2)).rjust(8, \"0\")\n  n = (n.to_i(2)).to_s(8)\n\
    \  m = (m.to_i(2)).to_s(8)\n  if n == m\n    return n\n  else\n    return -1\n\
    \  end\nend", "  \n  n = n.to_i\n  m = m.to_i\n  \n  avg = ((n..m).sum.to_f /\
    \ m).round\n  \n  if avg < 0\n    -1\n  else\n    avg.to_s(2).reverse.to_i(2)\n\
    \  end\nend\n</cell>\n<cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\nrounded_avg(10,\
    \ 20)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<text>\nThe sum of the first\
    \ n integers is given by:", "  n = n.to_i\n  m = m.to_i\n  \n  if n >= m\n   \
    \ return -1\n  \n  sum = 0\n  \n  while n <= m\n    sum += n\n    n += 1\n  end\n\
    \  \n  sum.to_s(2).reverse.rjust(8, '0')\nend", "  avg = ((n..m).sum.to_f / m).round\n\
    \  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n    n += 2\n  end\n\
    \  binary.reverse.join if avg > 0\n  binary.push(\"0b#{avg}\") if avg < 0\n  binary.join(\"\
    0b\")\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby |>\n<code>", "  sum = 0\n\
    \  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.rjust(8,\
    \ '0')\nend", "  avg = ((n..m).to_a + (n..m).to_a).sum / 2.0\n  avg.round\n  avg.to_s(2)\n\
    end", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n  while n <= m\n\
    \    binary.push((n..m).sum.to_s(2))\n    n += 1\n  end\n  binary.reverse.each_with_index\
    \ do |digit, index|\n    digit = digit.to_i(2).to_s(2)\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(", "  \n  # Write your code here.\n  return\
    \ -1\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n  while\
    \ n <= m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.reverse.join\
    \ if avg > 0\n  binary.reverse.join if avg < 0\n  binary.reverse.join if avg ==\
    \ 0\n  binary.reverse.join if avg < 1\n  binary.reverse.join if avg > 1\nend\n\
    </code>\n<|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>", "  sum = 0\n  for i in\
    \ 1..m\n    sum += i\n  end\n  sum.to_s(2).reverse.gsub(/../) { |s| s.to_i(2)\
    \ }\nend", "  n = n.to_s(2)\n  m = m.to_s(2)\n  \n  if n <= m\n    sum = 0\n \
    \   n.to_i(2).upto(m.to_i(2), 2) do |i|\n      sum += i\n    end\n    sum.to_s(2).to_i(2).to_s(2)\n\
    \  else\n    -1\n  end\nend", "  n = (n.to_s + m).to_i\n  m = (m.to_s + n).to_i\n\
    \  if m > n\n    -1\n  else\n    n.to_s(2).reverse.rjust(m, 0).to_i(2).to_s(2).reverse\n\
    \  end\nend\n</code>\n<|/ a tags=ruby,binary,math |>\n<| a tags=ruby,binary,math\
    \ |>\n<code>", "  avg = ((n..m).to_a.reduce(:+) / 2).round\n  avg.to_s(2).to_i(2)\
    \ if avg <= m && n <= m\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c\
    \ |>\nI like this solution, but I wonder if there is a way to do it without using\
    \ to_s(2). I'm thinking about something like `avg.to_s(2).to_i(2) if avg <= m\
    \ && n <= m`\n<|/ c |>\n<| c |>\nI added a solution without `to_s(2)`\n<|/ c |>\n\
    <| c |>\nI like your solution, but I wonder if there is a way to do it without\
    \ using to_s(2). I'm thinking about something like `avg.to_s(2).to_i(2) if avg\
    \ <= m && n <= m`\n<|/ c |>\n<| c |>\nI added a solution without `to_s(2)`\n<|/\
    \ c |>\n<| a |>\n<code>", "  n = (n..m).to_a\n  n.each do |n|\n    n.to_s(2).reverse.rjust(8,\
    \ \"0\")\n  end.join\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| a dscore=0\
    \ |>\n<code>", "  n = n.to_i\n  m = m.to_i\n  return \"0b\" + n.to_s(2).reverse.gsub(/(.{1})(?=\\\
    d)/, '0$1').to_i(2).to_s(2).reverse\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n\
    \  binary = []\n  while n <= m\n    binary.push((n.to_s(2))[-1,-1].to_i(2))\n\
    \    n += 1\n  end\n  binary.reverse.inject(:+).to_s(2)[-1,-1].to_i(2) if binary.size\
    \ > 0\nend", "  \n  if n <= m\n    \n    sum = 0\n    \n    while n <= m\n   \
    \   sum += n\n      n += 1\n    \n    sum.to_s(2).to_i(2).to_s(2)\n    \n  else\n\
    \    \n    sum = 0\n    \n    while n >= m\n      sum += m\n      m -= 1\n   \
    \ \n    sum.to_s(2).to_i(2).to_s(2)\n    \n  end\nend", "  sum = 0\n  while n\
    \ <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.rjust(8, \"0\"\
    )\nend", "  \n  # Write your code here.\n  \n  \nend", "  \n  avg = ((n..m).sum.to_f\
    \ / m).round\n  \n  if avg > m\n    -1\n  else\n    avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_",
  "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.rjust(8,\
    \ \"0\")\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.rjust(8,\
    \ \"0\")\nend", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n\
    \  sum.to_s(2).reverse.gsub(/../) { |s| s == '0' ? '1' : '0' }\nend", "  \n  avg\
    \ = n/m\n  \n  if m > n\n    avg *= -1\n  end\n  \n  avg = avg.round\n  \n  binary\
    \ = \"\"\n  \n  while avg <= m\n    binary += \"1\"\n    avg += 1\n  end\n  \n\
    \  binary += \"0\" * (m - avg)\n  \n  return binary\nend", "  sum = 0\n  while\
    \ n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.gsub(/../) {\
    \ |s| s.to_i(2) }\nend", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n\
    \  while n <= m\n    binary.push((n..m).to_a.sum.to_s(2).to_i(2))\n    n += 1\n\
    \  end\n  binary.reverse.join if avg > 0\n  binary.reverse.join if avg < 0\n \
    \ binary.reverse.join if avg == -1\nend", "  sum = 0\n  while n <= m\n    sum\
    \ += n\n    n += 1\n  end\n  sum.to_s(2).reverse.rjust(8, \"0\")\nend", "  n =\
    \ (n+m)/2\n  m = (m+n)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n  m =\
    \ (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  m = (m.to_s(2).length + n.to_s(2).length)/2\n  n = (n.to_s(2).length + m.to_s(2).length)/2\n\
    \  ", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n  while n <= m\n\
    \    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.reverse.each do |i|\n\
    \    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n   \
    \ i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n\
    \    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n\
    \    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n\
    \    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n\
    \    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n\
    \    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n\
    \    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n\
    \    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n\
    \    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n\
    \    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n\
    \    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n\
    \    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n\
    \    i = i.to_s(2)\n    i = i.to_i(2).to_s(2)\n    i = i.to_s(2)", "  sum = 0\n\
    \  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.gsub(/(.{1})/,\
    \ '0\\1').reverse\nend", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n\
    \  while n <= m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.reverse.join\
    \ if binary.length == 1\n  binary.join(\"\")\nend\n</code>\n<|/ a tags=ruby |>\n\
    <| a dscore=0 |>\n<code>", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n\
    \  while n <= m\n    binary.push((n..m).sum.to_s(2))\n    n += 1\n  end\n  binary.reverse.each_with_index\
    \ do |digit, index|\n    digit = digit.to_i(2).to_s(2)\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"", "  sum = 0\n  n.upto(m) do |i|\n\
    \    sum += i\n  end\n  sum.round\nend", "  \n  avg = ((n..m).to_a.sum.to_f /\
    \ m).round\n  \n  if avg < 0\n    -1\n  else\n    avg.to_s(2).reverse.to_i(2).to_s(2).reverse\n\
    \  end\nend\n</cell>\n<cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\nrounded_avg(7,\
    \ 10)\n</cell>\n<cell>\nrounded_avg(7, 20)\n</cell>\n<cell>\nrounded_avg(7, 33)\n\
    </cell>\n<cell>\nrounded_avg(7, 34)\n</cell>\n<cell>\nrounded_avg(7, 35)\n</cell>\n\
    <cell>\nrounded_avg(7, 36)\n</cell>\n<cell>\nrounded_avg(7, 37)\n</cell>\n<cell>\n\
    rounded_avg(7, 38)\n</cell>\n<cell>\nrounded_avg(7, 39)\n</cell>\n<cell>\nrounded_avg(7,\
    \ 40)\n</cell>\n<cell>\nrounded_avg(7, 41)\n</cell>\n<cell>\nrounded_avg(7, 42)\n\
    </cell>\n<cell>\nrounded_avg(7, 43)\n</cell>\n<cell>\nrounded_avg(7, 44)\n</cell>\n\
    <cell>\nrounded_avg(7, 45)\n</cell>\n<cell>\nrounded_avg(7, 46)\n</cell>\n<cell>\n\
    rounded_avg(7, 47)\n</cell>\n<cell>\nrounded_avg(7, 48)\n</cell>\n<cell>\nrounded_avg(7,\
    \ 49)\n</cell>\n<cell>\nrounded_avg(7, 50)\n</cell>\n<cell>\nrounded_avg(7, 51)\n\
    </cell>\n<cell>\nrounded_avg(7, 52)\n</cell>\n<cell>\nrounded_avg(7, 53)\n</cell>\n\
    <cell>\nrounded_avg(7, 54)\n</cell>\n<cell>\nrounded_avg(7, 55)\n</cell>\n<cell>\n\
    rounded_avg(7, 56)\n</cell>\n<cell>\nrounded_avg(7, 57)\n</cell>\n<cell>\nrounded_avg(7,\
    \ 58)\n</cell", "  n = n.to_i\n  m = m.to_i\n  return \"0b\" + n.to_s(2).reverse.rjust(m,\
    \ 0).reverse\nend", "  n = n.to_i\n  m = m.to_i\n  \n  if n <= m\n    sum = 0\n\
    \    n.upto(m) do |i|\n      sum += i\n    end\n    sum.round\n  else\n    -1\n\
    \  end\nend", "  n = n.to_i\n  m = m.to_i\n  return \"0b\" + n.to_s(2).reverse.gsub(/(.{1})(?=\\\
    d)/, '0$1').to_s(2)\nend", "  avg = ((n..m).to_a + (n..m).to_a).sum / 2.0\n  avg.round\n\
    \  avg.to_s(2)\nend", "  n = n.to_i\n  m = m.to_i\n  return \"0b\" + n.to_s(2).reverse.rjust(m,\
    \ 0).reverse\nend", "  n = n.to_i\n  m = m.to_i\n  return \"0b\" + n.to_s(2).reverse.gsub(/(.{1})\\\
    1+/, '\\1').to_i(2).to_s(2)\nend\n</code>\n<|/ a dscore=0 |>\n<| a tags=ruby,binary,math\
    \ |>\n<code>", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n \
    \ sum.to_s(2).reverse.gsub(/../) { |x| x.to_i(2) }\nend", "  n = n.to_i\n  m =\
    \ m.to_i\n  if n <= m\n    n.upto(m).each do |i|\n      puts \"0b\" + i.to_s(2).rjust(8,\
    \ \"0\")\n    end\n  else\n    -1\n  end\nend\n</code>\n<|/ a dscore=0 |>\n<|\
    \ a tags=ruby |>\n<code>", "  sum = 0\n  while n <= m\n    sum += n\n    n +=\
    \ 1\n  end\n  sum.to_s(2).reverse.rjust(8, '0')\nend", "  n = n.to_s(2)\n  m =\
    \ m.to_s(2)\n  \n  if m > n\n    -1\n  else\n    n.to_i(2).to_s(2).reverse.rjust(m,\
    \ 0).to_i(2).to_s(2)\n  end\nend", "  avg = ((n..m).to_a + (n..m).to_a).sum /\
    \ 2\n  avg.round\nend", "  n = n.to_i\n  m = m.to_i\n  if n < m\n    -1\n  else\n\
    \    n.upto(m).inject(:+).to_s(2).to_i(2).to_s(2)\n  end\nend\n</code>\n<|/ a\
    \ |>\n<| a dscore=0 |>\n<code>", "  sum = 0\n  for i in 0...m\n    sum += i\n\
    \  end\n  sum.to_s(2).reverse.gsub(/../) { |s| s.to_i(2) }\nend", "  ((n..m).to_a\
    \ * 2).sum.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\nend", "  avg\
    \ = ((n..m).to_a.sum.to_f / m).round\n  binary = []\n  while n <= m\n    binary.push((n\
    \ & m).to_s(2))\n    n += 1\n  end\n  binary.reverse.join if binary.length >=\
    \ 2\nend", "  avg = ((n..m).to_a.sum.to_f / m).round\n  binary = []\n  while n\
    \ <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse.join\
    \ # reverse the array and join it into a string\nend\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=ruby,bit-manipulation,algorithm |>\n<code>", "  sum = 0\n  while\
    \ n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.gsub(/../) {\
    \ |s| s.to_i(2) }\nend", "  n = n.to_i\n  m = m.to_i\n  if n <= m\n    sum = 0\n\
    \    n.upto(m) do |i|\n      sum += i\n    end\n    sum.to_s(2)\n  else\n    -1\n\
    \  end\nend", "  \n  # Write your code here.\n  \nend", "  \n  sum = 0\n  \n \
    \ n.upto(m) do |i|\n    sum += i\n  end\n  \n  sum.round\nend", "  avg = ((n..m).sum.to_f\
    \ / m.to_f).round\n  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.inject(:+).to_s(2).to_i(2).to_s(2)\nend",
  "  \n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  \n  if avg > m\n    -1\n  else\n\
    \    avg.to_s(2)\n  end\nend\n</cell>\n<cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\n\
    rounded_avg(10, 20)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<text>\nExercise\
    \ 3\nWrite a function that takes an integer and returns the first n prime numbers.\
    \ \nThe first n prime numbers are 2, 3, 5, 7, 11, and 13.\nThe function should\
    \ return an array of integers representing prime numbers.\nThe function should\
    \ return nil if the integer is less than 2.\nThe function should return nil if\
    \ the integer is greater than 100.\nThe function should return nil if n is less\
    \ than 2.", "  avg = ((n + m) / 2).round\n  binary = []\n  while n <= m\n    binary.push((n\
    \ & m).to_s(2))\n    n += 1\n    m -= 1\n  end\n  binary.reverse.join if binary.size\
    \ > 0\nend", "  ((n..m).to_a * 2).sum.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <= m\n  \
    \  binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse.join if binary.length\
    \ >= 2\nend\n</code>\n<|/ a tags=ruby,binary,math |>\n<| c |>\n`((n..m).sum.to_f\
    \ / m).round` can be written as `((n..m).sum.to_f / m).floor`\n<|/ c |>\n<| c\
    \ |>\n`((n..m).sum.to_f / m).floor` will give the wrong answer if n is greater\
    \ than m. `((n..m).sum.to_f / m).ceil` will give the correct answer if n is greater\
    \ than m\n<|/ c |>\n<| c |>\n`((n..m).sum.to_f / m).floor` will give the wrong\
    \ answer if n is greater than m. `((n..m).sum.to_f / m).ceil` will give the correct\
    \ answer if n is greater than m\n<|/ c |>\n<| c |>\n`((n..m).sum.to_f / m).floor`\
    \ will give the wrong answer if n is greater than m. `((n..m).sum.to_f / m).ceil`\
    \ will give the correct answer if n is greater than m\n<|/ c |>\n<| c |>\n`((n..m).sum.to_f\
    \ / m).floor` will give the wrong answer if n is greater than m. `((n..m).sum.to_f\
    \ / m).ceil` will give the correct answer if n is greater than m\n<|/ c |>\n<|\
    \ a |>\n<code>", "  sum = 0\n  for i in 0...m\n    sum += n\n  end\n  sum.to_s(2).reverse.gsub(/../)\
    \ { |s| s == '1' ? '0' : '1' }\nend", "  sum = 0\n  for i in 0...m\n    sum +=\
    \ n\n  end\n  sum.to_s(2).reverse.gsub(/../) { |x| x.to_i(2) }\nend", "  avg =\
    \ ((n..m).sum.to_f / m.to_f).round\n  \n  if avg < 0\n    -1\n  else\n    binary\
    \ = []\n    avg.times { |i| binary << ((avg % 2).zero? ? i : i.to_s(2)) }\n  \
    \  binary.join\n  end\nend\n</code>\n<|/ a tags=ruby,binary,math |>\n<| c |>\n\
    This doesn't work for `rounded_avg(7, 5)` which should return `-1`, but returns\
    \ `\"0b1111\"`.\n<|/ c |>\n<| c |>\nI fixed the bug. Thanks for pointing it out.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>", "  avg = ((n..m).to_a + (n..m).to_a).sum\
    \ / 2.0\n  avg.round\nend", "  sum = 0\n  for i in 0...m\n    sum += i\n  end\n\
    \  sum.to_s(2).reverse.rjust(8, '0')\nend", "  n = (n..m).to_a\n  n.each do |n|\n\
    \    n.to_s(2).to_i(2) if n.to_s(2).to_i(2) >= m\n  end\nend", "  avg = ((n..m).sum.to_f\
    \ / m).round\n  binary = []\n  while n <= m\n    binary.push((n & m).to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.join if binary.size > 0\nend\n</code>\n<|/\
    \ a tags=ruby,binary,math |>\n<| c |>\nThis doesn't work for `rounded_avg(7, 5)`\n\
    <|/ c |>\n<| c |>\nIt works for me. `rounded_avg(7, 5)` returns `\"0b1111\"`\n\
    <|/ c |>\n<| c |>\nIt works for me too. `rounded_avg(7, 5)` returns `\"0b1111\"\
    `\n<|/ c |>\n<| c |>\nIt works for me too. `rounded_avg(7, 5)` returns `\"0b1111\"\
    `\n<|/ c |>\n<| c |>\nIt works for me too. `rounded_avg(7, 5)` returns `\"0b1111\"\
    `\n<|/ c |>\n<| a tags=ruby,binary,math |>\n<code>", "  \n  avg = ((n..m).to_a\
    \ + (n..m).to_a).sum / 2.0\n  \n  if avg > m\n    -1\n  elsif avg < n\n    -1\n\
    \  else\n    avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(",
  "  avg = ((n..m).sum.to_f / m.to_f).round\n  \n  if m > n\n    -1\n  else\n    sprintf(\"\
    0b%b\", avg)\n  end\nend", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n\
    \  while n <= m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.reverse.each_with_index\
    \ do |digit, index|\n    digit = digit.to_i\n    digit = digit * 2\n    digit\
    \ = digit + 1 if digit < 10\n    digit = digit - 1 if digit > 9\n    digit = digit.to_s(2)\n\
    \    digit = digit.rjust(2, '0')\n    binary[index] = digit\n  end\n  binary.join('')\n\
    end", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.gsub(/(.{1})/,\
    \ '0&').reverse\nend", "  n = n.to_i\n  m = m.to_i\n  if n >= m\n    -1\n  else\n\
    \    n.upto(m).map { |x| x.to_s(2).to_i(2) }.inject(:+) / 2.0\n  end\nend", " \
    \ avg = ((n..m).to_a.reduce(:+) / 2).round\n  avg.zero? ? -1 : sprintf(\"0b%b\"\
    , avg)\nend", "  n = n.to_i\n  m = m.to_i\n  if n >= m\n    return -1\n  sum =\
    \ 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse\n\
    end", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.gsub(/../)\
    \ { |s| s == '1' ? '0' : '1' }\nend", "  avg = ((n..m).sum / 2).round\n  binary\
    \ = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n    n += 1\n  end\n\
    \  binary.reverse.each_with_index do |digit, index|\n    digit = digit.to_i(2).to_s(2)\n\
    \    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"0\"\
    )\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index, \"\
    0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while\
    \ n <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse.join\
    \ if binary.size > 0\nend\n</code>\n<|/ a tags=ruby,binary,math |>\n<| a tags=ruby,binary,math\
    \ |>\n<code>", "  avg = ((n..m).to_a.sum.to_f / m).round\n  binary = []\n  while\
    \ n <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse.join\
    \ if binary.length >= 2\nend\n</code>\n<|/ a tags=ruby,binary,math,algorithm |>\n\
    <| a |>\n<code>", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n\
    \  sum.to_s(2).reverse.gsub(/../) { |s| s == '0' ? '1' : '0' }\nend", "  \n  n\
    \ = n.to_i\n  m = m.to_i\n  \n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  \n\
    \  avg.to_s(2).to_i\nend", "  n = n.to_i\n  m = m.to_i\n  return \"0b\" + n.to_s(2).reverse.gsub(/(.{4})/,\
    \ '\\1').to_i(2).to_s(2).reverse\nend", "  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n\
    \  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n \
    \ n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m\
    \ = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n =\
    \ (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n\
    \  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n \
    \ m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n\
    \ = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m =\
    \ (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n\
    \  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n \
    \ n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m = (n+m)/2\n  n = (n+m)/2\n  m\
    \ = (n+m)/2\n  n = (n+m)/2", "  n = n.to_i\n  m = m.to_i\n  if n >= m\n    -1\n\
    \  else\n    n.upto(m).inject(:+).to_s(2).reverse.rjust(n, \"0\")\n  end\nend\n\
    </code>\n<|/ a tags=ruby |>\n<| c |>\nI like your solution, however it fails for\
    \ `rounded_avg(20, 33)` which should return `0b11010`.\n<|/ c |>\n<| c |>\nThanks,\
    \ I fixed it. I had a bug in the `upto` method.\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>", "  sum = 0\n  n.upto(m) do |i|\n    sum += i\n  end\n  sum.round(0, 1).to_s(2)\n\
    end", "  avg = ((n..m).sum.to_f / m.to_f).round\n  \n  if avg < 0\n    -1\n  else\n\
    \    avg.to_s(2).reverse.to_i(2).to_s(2).reverse\n  end\nend", "  avg = ((n..m).sum.to_f\
    \ / m).round\n  binary = []\n  while n <= m\n    binary.push((n & m).to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.join if binary.length >= 2\nend", "  n =\
    \ (n..m).to_a\n  n.each_with_index do |n, i|\n    if i < n.length\n      n[i]\
    \ = \"0b\" + n[i].to_s(2)\n    end\n  end\n  n.join\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=ruby |>\n<code>", "  avg = ((n..m).sum.to_f / m).round\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_",
  "  sum = 0\n  for i in 0...n\n    sum += i\n  end\n  sum = (sum / n).round\n  if\
    \ sum > m\n    sum = -1\n  end\n  return sum.to_s(2)\nend", "  avg = ((n..m).to_a\
    \ + (n..m).to_a).sum / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg =\
    \ ((n..m).to_a + (n..m).to_a).sum / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum\
    \ / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum\
    \ / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum\
    \ / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum\
    \ / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum\
    \ / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum\
    \ / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum\
    \ / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum\
    \ / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum\
    \ / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum\
    \ / 2\n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg = ((n..", "  n = (n.to_s\
    \ + n.to_i).to_i\n  m = (m.to_s + m.to_i).to_i\n  avg = ((n + m) / 2).to_i\n \
    \ \n  if avg > m\n    -1\n  else\n    avg.to_s(2).reverse\n  end\nend", "  sum\
    \ = 0\n  for i in 0...m\n    sum += n\n  end\n  sum.to_s(2).reverse.rjust(8, '0')\n\
    end", "  sum = 0\n  n.upto(m) do |i|\n    sum += i\n  end\n  sum.round\nend",
  "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <= m\n    binary.push((n\
    \ & m).to_s(2))\n    n += 1\n  end\n  binary.reverse.join # reverse the binary\
    \ array and join it together\nend", "  ((n..m).inject(:+) / 2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.rjust(8,\
    \ '0')\nend", "  n = n.to_i\n  m = m.to_i\n  \n  avg = ((n..m).sum.to_f / m).round\n\
    \  \n  if avg < 0\n    -1\n  else\n    avg.to_s(2).reverse.to_i(2).to_s(2).reverse\n\
    \  end\nend\n</cell>\n<cell>\nrounded_avg(7, 5)\n</cell>\n<cell>\nrounded_avg(10,\
    \ 20)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<cell>\nrounded_avg(20, 33)\n</cell>\n<cell>\nrounded_avg(20,\
    \ 33)\n</cell>\n<", "  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_",
  "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <= m\n    binary.push((n\
    \ & m).to_s(2))\n    n += 1\n  end\n  binary.reverse.join if binary.size > 0\n\
    end", "  \n  if n >= m\n    return -1\n  \n  sum = 0\n  \n  for i in 0...m\n \
    \   sum += n\n    n -= 1\n  end\n  \n  sum.to_s(2).reverse.gsub(/../) {|s| s ==\
    \ '0' ? '1' : '0'}\nend", "  n = n.to_i\n  m = m.to_i\n  return \"0b\" + n.to_s(2).reverse.rjust(m,\
    \ 0).reverse\nend", "  n = (n.to_s.to_i if n.to_s.to_i.to_s != \"0b0\" else n.to_i).to_s\n\
    \  m = (m.to_s.to_i if m.to_s.to_i.to_s != \"0b0\" else m.to_i).to_s\n  n = (n.to_s.to_i\
    \ if n.to_s.to_i.to_s != \"0b0\" else n.to_i).to_s\n  m = (m.to_s.to_i if m.to_s.to_i.to_s\
    \ != \"0b0\" else m.to_i).to_s\n  n = (n.to_s.to_i if n.to_s.to_i.to_s != \"0b0\"\
    \ else n.to_i).to_s\n  m = (m.to_s.to_i if m.to_s.to_i.to_s != \"0b0\" else m.to_i).to_s\n\
    \  n = (n.to_s.to_i if n.to_s.to_i.to_s != \"0b0\" else n.to_i).to_s\n  m = (m.to_s.to_i\
    \ if m.to_s.to_i.to_s != \"0b0\" else m.to_i).to_s\n  n = (n.to_s.to_i if n.to_s.to_i.to_s\
    \ != \"0b0\" else n.to_i).to_s\n  m = (m.to_s.to_i if m.to_s.to_i.to_s != \"0b0\"\
    \ else m.to_i).to_s\n  n = (n.to_s.to_i if n.to_s.to_i.to_s != \"0b0\" else n.to_i).to_s\n\
    \  m = (m.to_s.to_i if m.to_s.to_i.to_s != \"0b0\" else m.to_i).to_s\n  n = (n.to_s.to_i\
    \ if n.to_s.to_i.to_s != \"0b0\" else n.to_i).to_s\n  m = (m.to_s.to_i if m.to_s.to_i.to_s\
    \ != \"0b0\" else m.to_i).to_s\n  n = (n.to_s.to_i if n.to_s.to_i.to_s != \"0b0\"\
    \ else n.to_i).to_s\n  m = (m.to_s.to_i if m.to_s.to_i.to_s != \"0b0\" else m.to_i).to_s\n\
    \  n = (n.to_s.to_i if n.to_s.to_i.to_s != \"0b0\" else n.to_i).to_s\n  m = (m.to_s.to_i\
    \ if m.to_s.to_i.to_s != \"0b0\" else m.to_i).to_s\n  n = (n.to_s.to_i if n.to_s.to_i.to_s\
    \ != \"0b0\" else n.to_i).to_s", "  avg = ((n..m).sum.to_f / m.to_f).round\n \
    \ \n  if avg < 0\n    -1\n  else\n    avg.to_s(2).reverse.to_i(2).to_s(2).reverse\n\
    \  end\nend", "  avg = ((n..m).to_a.sum.to_f / m).round\n  binary = []\n  while\
    \ n <= m\n    binary.push n.to_s(2)\n    n += 1\n  end\n  binary.push m.to_s(2)\n\
    \  binary.push avg.to_s(2)\n  binary.join\nend", "  ((n..m).to_a * 2).sum.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "  avg = ((n..m).sum.to_f / m.to_f).round\n  binary = []\n  while n <= m\n\
    \    binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse.join if\
    \ binary.length == 1\n  binary.join\nend\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\n<code>", "  n = n.to_s(2)\n  m = m.to_s(2)\n  n.length == m.length ? n :\
    \ -1\nend", "  sum = 0\n  for i in 0...m\n    sum += n\n  end\n  sum.to_s(2).reverse.rjust(8,\
    \ '0')\nend", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <=\
    \ m\n    binary.push((n..m).sum.to_s(2))\n    n += 1\n  end\n  binary.reverse.each_with_index\
    \ do |digit, index|\n    digit = digit.to_i(2).to_s(2)\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"0\")\n    digit = digit.insert(index,\
    \ \"0\")\n    digit = digit.insert(index, \"", "  avg = ((n..m).to_a.sum.to_f\
    \ / m).round\n  binary = []\n  while n <= m\n    binary.push((n & m).to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.join if binary.size > 0\nend\n</code>\n<|/\
    \ a dscore=0 |>\n<| c |>\nThis doesn't work for `rounded_avg(20, 33) => \"0b11010\"\
    `\n<|/ c |>\n<| c |>\nYes, I noticed that after I posted my answer. Thanks for\
    \ pointing it out. I've updated my answer.\n<|/ c |>\n<| a tags=ruby,binary,math\
    \ |>\n<code>", "  avg = ((n..m).to_f / 2).round\n  binary = []\n  while n <= m\n\
    \    binary.push(\"#{n}b\")\n    n += 1\n  end\n  binary.push(\"#{m}b\")\n  binary.join\n\
    end", "  \n  # Write your code here\n  \nend", "  n = n.to_i\n  m = m.to_i\n \
    \ if n > m\n    -1\n  else\n    n.upto(m).inject(:+).to_s(2).reverse.rjust(8,\
    \ '0')\n  end\nend", "  avg = ((n..m).to_f / 2.0).ceil\n  binary = []\n  while\
    \ n <= m\n    binary.push((n.to_s(2))[-1,1])\n    n += 1\n  end\n  binary.reverse\n\
    \  binary.join\nend", "  avg = ((n + m) / 2).round\n  binary = []\n  while n <=\
    \ m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.push(m.to_s(2))\n\
    \  binary.push(avg.to_s(2))\n  binary.join(\"0b\")\nend", "  n = n.to_i\n  m =\
    \ m.to_i\n  if n > m\n    -1\n  else\n    n.upto(m).inject(:+) / m\n  end\nend",
  "  n = (n+m)/2\n  m = m+n\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n \
    \ m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n\
    \  m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n\
    \  m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n\
    \  m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n\
    \  m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n\
    \  m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n\
    \  m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n\
    \  m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n\
    \  m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n\
    \  m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n\
    \  m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n\
    \  m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (n.to_s(2).reverse.scan(/../).join.to_i(2))\n\
    \  m = (m.to_s(2).reverse.scan(/../).join.to_i(2))\n  n = (", "  sum = 0\n  while\
    \ n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.rjust(8, \"0\"\
    )\nend", "  avg = ((n..m).to_a.sum / 2).round\n  binary = []\n  while n <= m\n\
    \    binary.push((n / avg).to_s(2))\n    n += 1\n  end\n  binary.reverse.join\
    \ if binary.length >= 2\nend", "  sum = 0\n  for i in 0...m\n    sum += n\n  end\n\
    \  sum.to_s(2).reverse.rjust(8, \"0\")\nend", "  avg = ((n..m).sum.to_f / m).round\n\
    \  binary = []\n  while n <= m\n    binary.push((n..m).sum.to_s(2))\n    n +=\
    \ 1\n  end\n  binary.reverse.each_with_index do |digit, index|\n    digit = digit.to_i(2).to_s(2)\n\
    \    digit.insert(index, \"0\")\n  end\n  binary.join\nend\n</code>\n<|/ a dscore=0\
    \ |>\n<| a dscore=0 |>\n<code>", "  avg = ((n..m).sum.to_f / m).round\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "  \n  if n >= m\n    return -1\n  \n  sum = 0\n  \n  for i in 1..m\n  \
    \  sum += i\n  end\n  \n  sum.to_s(2).reverse.gsub(/../) { |s| s.to_i(2) }\nend",
  "  avg = ((n..m).sum / 2).round\n  binary = []\n  while n <= m\n    binary.push((n\
    \ & m).to_s(2))\n    n += 1\n  end\n  binary.reverse.join # reverse the array\
    \ and join it together\nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0 |>\n<code>",
  "  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg.round\nend", "  avg = ((n..m).to_a\
    \ + (n..m).to_a).sum / 2.0\n  \n  if avg < 0\n    -1\n  else\n    avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    \  end\nend", "  n = n.to_s(2)\n  m = m.to_s(2)\n  \n  if m > n\n    return -1\n\
    \  elsif m == 0\n    return \"0b0\"\n  elsif m == 1\n    return \"0b1\"\n  elsif\
    \ m == 2\n    return \"0b11\"\n  elsif m == 3\n    return \"0b111\"\n  elsif m\
    \ == 4\n    return \"0b1111\"\n  elsif m == 5\n    return \"0b11111\"\n  elsif\
    \ m == 6\n    return \"0b111111\"\n  elsif m == 7\n    return \"0b1111111\"\n\
    \  elsif m == 8\n    return \"0b11111110\"\n  elsif m == 9\n    return \"0b111111100\"\
    \n  elsif m == 10\n    return \"0b1111111000\"\n  elsif m == 11\n    return \"\
    0b11111110000\"\n  elsif m == 12\n    return \"0b111111100000\"\n  elsif m ==\
    \ 13\n    return \"0b1111111000000\"\n  elsif m == 14\n    return \"0b11111110000000\"\
    \n  elsif m == 15\n    return \"0b111111100000000\"\n  elsif m == 16\n    return\
    \ \"0b1111111000000000\"\n  elsif m == 17\n    return \"0b11111110000000000\"\n\
    \  elsif m == 18\n    return \"0b111111100000000000\"\n  elsif m == 19\n    return\
    \ \"0b1111111000000000000\"\n  elsif m == 20\n    return \"0b11111110000000000000\"\
    \n  elsif m == 21\n    return \"0b111111100000000000000\"\n  elsif m == 22\n \
    \   return \"0b1111111000000000000000\"\n  elsif m == 23\n    return \"0b11111110000000000000000\"\
    \n  elsif m == 24\n    return \"0b111111100000000000000000\"\n  elsif m == 25\n\
    \    return \"0b1111111000000000000000000\"\n  elsif m == 26\n    return \"0b11111110000000000000000000\"\
    \n  elsif m == 27\n    return \"0b111111100000000000000000000\"\n  elsif m ==\
    \ 28\n    return \"0b1111111000000000000000000000\"\n  elsif m == 29\n    return\
    \ \"0b11111110000000000000000000000\"\n  elsif m == 30\n    return \"0b111111100000000000000000000000\"\
    \n  elsif m == 31\n    return \"0b1111111000000000000000000", "  avg = ((n..m).sum\
    \ / 2).round\n  binary = []\n  while n <= m\n    binary.push((n & m).to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse\n  binary.join\nend", "  sum = 0\n  while\
    \ n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.gsub(/../) {\
    \ |s| s == '0' ? '1' : '0' }\nend", "  avg = ((n..m).sum.to_f / m.to_f).round\n\
    \  binary = []\n  while n <= m\n    binary.push((n..m).to_a.sum.to_s(2).to_i(2))\n\
    \    n += 1\n  end\n  binary.reverse.find { |x| x.to_i(2) >= avg }\nend", "  n\
    \ = n.to_i\n  m = m.to_i\n  \n  if m > n\n    -1\n  else\n    n.upto(m).inject(:+)\
    \ / m\n  end\nend", "  n = (n..m).to_a\n  n.each_with_index do |n,i|\n    n.to_s(2).rjust(8,\
    \ \"0\").scan(/../).join\n  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nThis\
    \ doesn't work if n is greater than m.\n<|/ c |>\n<| c |>\nYes, I missed that\
    \ case. Thanks for pointing it out.\n<|/ c |>\n<| a dscore=2 |>\n<code>", "  avg\
    \ = ((n..m).sum.to_f / m.to_f).round\n  avg.to_s(2).reverse.rjust(8, '0')\nend",
  "  avg = ((n..m).to_a + (n..m).to_a).sum / 2.0\n  avg.round\n  avg.to_s(2)\nend\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>", "  ((n..m).to_a * 2).sum.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end\n</code>\n<|/ a tags=ruby |>\n<| a |>\n<code>", "  n = n.to_i\n  m = m.to_i\n\
    \  if n > m\n    -1\n  else\n    n.upto(m).inject(:+).to_s(2).to_i(2).to_s(2)\n\
    \  end\nend\n</code>\n<|/ a tags=ruby |>\n<| c |>\nI like your use of inject and\
    \ upto. Thanks!\n<|/ c |>\n<| c |>\nI like your use of inject and upto. Thanks!\n\
    <|/ c |>\n<| c |>\nI like your use of inject and upto. Thanks!\n<|/ c |>\n<| a\
    \ tags=ruby |>\n<code>", "  avg = ((n..m).sum.to_f / m.to_f).round\n  \n  if avg\
    \ < 0\n    -1\n  else\n    binary = []\n    avg.times { |i| binary << i.to_s(2)\
    \ }\n    binary.join\n  end\nend\n</code>\n<|/ a dscore=1 |>\n<| a tags=ruby,binary,math,ruby-on-rails\
    \ |>\n<code>", "  avg = ((n..m).to_f / 2).round\n  bin = bin(avg).to_s(2)\n  bin.slice!(0...-1)\n\
    \  bin\nend", "  sum = 0\n  for i in 0...m\n    sum += n\n  end\n  sum.to_s(2).reverse.rjust(8,\
    \ '0')\nend", "  n = n.to_i\n  m = m.to_i\n  return \"0b\" + n.to_s(2).reverse.rjust(m,\
    \ 0).reverse\nend", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n\
    \  sum.to_s(2).reverse.rjust(8, '0')\nend", "  avg = ((n..m).to_a.sum.to_f / m).round\n\
    \  binary = []\n  while n <= m\n    binary.push(\"#{n}b\")\n    n += 1\n  end\n\
    \  binary.push(\"#{m}b\")\n  binary.join(\",\")\nend", "  sum = 0\n  while n <=\
    \ m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.gsub(/(.{1})/, '0&').reverse\n\
    end", "  \n  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  \n  if m > n\n    -1\n\
    \  else\n    sprintf(\"0b%b\", avg)\n  end\nend", "  \n  n.upto(m) do |n|\n  \
    \  i = n.to_i\n    \n    if i > m\n      return -1\n    end\n    \n    i = i +\
    \ (m - (i + 1))\n    \n    i = i.to_s(2)\n    \n    i = i.upto(m.to_s(2)) do |i|\n\
    \      i = i.to_s(2)\n      \n      i = i.upto(m.to_s(2)) do |i|\n        i =\
    \ i.to_s(2)\n        \n        i = i.upto(m.to_s(2)) do |i|\n          i = i.to_s(2)\n\
    \          \n          i = i.upto(m.to_s(2)) do |i|\n            i = i.to_s(2)\n\
    \            \n            i = i.upto(m.to_s(2)) do |i|\n              i = i.to_s(2)\n\
    \              \n              i = i.upto(m.to_s(2)) do |i|\n                i\
    \ = i.to_s(2)\n                \n                i = i.upto(m.to_s(2)) do |i|\n\
    \                  i = i.to_s(2)\n                  \n                  i = i.upto(m.to_s(2))\
    \ do |i|\n                    i = i.to_s(2)\n                    \n          \
    \          i = i.upto(m.to_s(2)) do |i|\n                      i = i.to_s(2)\n\
    \                      \n                      i = i.upto(m.to_s(2)) do |i|\n\
    \                        i = i.to_s(2)\n                        \n           \
    \             i = i.upto(m.to_s(2)) do |i|\n                          i = i.to_s(2)\n\
    \                          \n                          i = i.upto(m.to_s(2)) do\
    \ |i|\n                            i = i.to_s(2)\n                           \
    \ \n                            i = i.upto(m.to_s(2)) do |i|\n               \
    \               i = i.to_s(2)\n                              \n              \
    \                i = i.upto(m.to_s(2)) do |i|\n                              \
    \  i = i.to_s(2)\n                                \n                         \
    \       i = i.upto(m.to_s(2)) do |i|\n                                  i = i.to_s(2)\n\
    \                                  \n                                  i = i.upto(m.to_s(2))\
    \ do |i|\n                                    i = i.to_s(2)\n                \
    \                    \n                                    i = i.upto(m.to_s(2))\
    \ do |i|\n                                      i = i.to_s(2)\n              \
    \                        \n                                      i = i.upto(m.to_s(2))\
    \ do |i|\n                                        i = i.to_s(2)\n            \
    \                            \n                                        i = i.upto(m.to_s(2))\
    \ do |i|\n                                          i = i.to_s(2)\n          \
    \                                \n                                          i\
    \ = i.upto(m.to_s(2)) do |i|\n                                            i =\
    \ i.to_s(2)\n                                            \n                  \
    \                          i = i.", "  sum = 0\n  for i in 0...m\n    sum += n\n\
    \  end\n  sum.to_s(2).reverse.gsub(/../) { |s| s == '0' ? '1' : '0' }\nend", " \
    \ avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n\
    \    n += 1\n  end\n  binary.reverse.join # reverse the array and join it together\n\
    end\n</code>\n<|/ a |>\n<| a tags=ruby |>\n<code>", "  sum = 0\n  n.upto(m) do\
    \ |i|\n    sum += i\n  end\n  sum.round\nend", "  avg = ((n..m).sum.to_f / m).round\n\
    \  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\nend", "  n = n.to_i\n  m = m.to_i\n\
    \  if m > n\n    -1\n  else\n    n.upto(m).inject(:+) / m\n  end\nend", "  n =\
    \ n.to_i\n  m = m.to_i\n  if n > m\n    -1\n  else\n    n.upto(m).inject(:+).to_s(2).to_i(2).to_s(2)\n\
    \  end\nend", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <=\
    \ m\n    binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.reverse.join # reverse\
    \ the binary array and join it together\nend\n</code>\n<|/ a dscore=0 |>\n<| a\
    \ tags=ruby |>\n<code>", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n\
    \  end\n  sum.to_s(2).reverse.gsub(/../) { |s| s.to_i(2) }\nend", "  avg = ((n..m).sum.to_f\
    \ / m).round\n  binary = []\n  while n <= m\n    binary.push(n.to_s(2))\n    n\
    \ += 1\n  end\n  binary.reverse.join # reverse the binary array and join it together\n\
    end\n</code>\n<|/ a dscore=0 |>\n<| a |>\n<code>", "  sum = 0\n  while n <= m\n\
    \    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.gsub(/../) { |s| s.to_i(2)\
    \ }\nend", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.gsub(/../)\
    \ { |s| s == '0' ? '1' : '0' }\nend\n</code>\n<|/ a dscore=2 |>\n<| a tags=ruby,binary,math\
    \ |>\n<code>", "  n = n.to_s(2)\n  m = m.to_s(2)\n  \n  if m > n\n    -1\n  else\n\
    \    n.to_i(2).to_s(2).reverse.rjust(m, \"\")\n  end\nend", "  avg = ((n..m).to_a.sum\
    \ / 2).round\n  binary = []\n  while n <= m\n    binary.push((n..m).to_a.sum.to_s(2).rjust(8,\
    \ '0'))\n    n += 1\n  end\n  binary.reverse.each do |b|\n    b.slice!(0..1) if\
    \ b.length < 8\n  end\n  binary.join\nend\n</code>\n<|/ a tags=ruby,ruby-on-rails\
    \ |>\n<| c |>\nThis doesn't work if n is greater than m. Round will round up and\
    \ return -1\n<|/ c |>\n<| c |>\nYes, I missed that case. Thanks for pointing it\
    \ out. I've updated the answer.\n<|/ c |>\n<| a tags=ruby,ruby-on-rails |>\n<code>",
  "  \n  n = n.to_s(2)\n  m = m.to_s(2)\n  \n  n.length == m.length ? \n    n.length\
    \ == 0 ? \"0b0\" : \n    m.length == 0 ? \"0b1\" : \n    n.length < m.length ?\
    \ \n      n.length + m.length.to_s(2).length == n.length ? \"0b\" + n : \"0b\"\
    \ + m : \n      m.length < n.length ? \"0b\" + m : \"0b\" + n\n  \nend", "  sum\
    \ = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.gsub(/../)\
    \ { |x| x.to_i(2) }\nend", "  ((n..m).to_a * 2).sum.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "  avg = ((n..m).sum.to_f / m.to_f).round\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "  avg = ((n..m).sum.to_f / m).round\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_s(2).to_i(2).to_",
  "  avg = ((n..m).to_a.sum.to_f / m).round\n  avg.to_s(2).to_i(2).to_s(2).to_i(2).to_s(2)\n\
    end", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n <= m\n  \
    \  binary.push(n.to_s(2))\n    n += 1\n  end\n  binary.reverse.inject(:+).to_s(2)\n\
    end\n</code>\n<|/ a tags=ruby,binary,math |>\n<| a tags=ruby,binary,math |>\n\
    <code>", "  \n  n = (n.to_s.to_i(16)).to_s(2)\n  m = (m.to_s.to_i(16)).to_s(2)\n\
    \  \n  if n <= m\n    \n    sum = 0\n    \n    n.to_s.split(\"\").each_with_index\
    \ do |digit, index|\n      sum += (digit.to_i(16)).to_s(2)\n    end\n    \n  \
    \  sum.to_s.split(\"\").each_with_index do |digit, index|\n      sum += (digit.to_i(16)).to_s(2)\n\
    \    end\n    \n    sum.to_s.split(\"\").each_with_index do |digit, index|\n \
    \     sum += (digit.to_i(16)).to_s(2)\n    end\n    \n    sum.to_s.split(\"\"\
    ).each_with_index do |digit, index|\n      sum += (digit.to_i(16)).to_s(2)\n \
    \   end\n    \n    sum.to_s.split(\"\").each_with_index do |digit, index|\n  \
    \    sum += (digit.to_i(16)).to_s(2)\n    end\n    \n    sum.to_s.split(\"\").each_with_index\
    \ do |digit, index|\n      sum += (digit.to_i(16)).to_s(2)\n    end\n    \n  \
    \  sum.to_s.split(\"\").each_with_index do |digit, index|\n      sum += (digit.to_i(16)).to_s(2)\n\
    \    end\n    \n    sum.to_s.split(\"\").each_with_index do |digit, index|\n \
    \     sum += (digit.to_i(16)).to_s(2)\n    end\n    \n    sum.to_s.split(\"\"\
    ).each_with_index do |digit, index|\n      sum += (digit.to_i(16)).to_s(2)\n \
    \   end\n    \n    sum.to_s.split(\"\").each_with_index do |digit, index|\n  \
    \    sum += (digit.to_i(16)).to_s(2)\n    end\n    \n    sum.to_s.split(\"\").each_with_index\
    \ do |digit, index|\n      sum += (digit.to_i(16)).to_s(2)\n    end\n    \n  \
    \  sum.to_s.split(\"\").each_with_index do |digit, index|\n      sum += (digit.to_i(16)).to_s(2)\n\
    \    end\n    \n    sum.to_s.split(\"\").each_with_index do |digit, index|\n \
    \     sum += (digit.to_i(16)).to_s(2)\n    end\n    \n    sum.to_s.split(\"\"\
    ).each_with_index do |digit, index|\n      sum += (digit.to_i(16)).to_s(2)\n \
    \   end\n    \n    sum.to_s.split(", "  n = n.to_i\n  m = m.to_i\n  if n > m\n\
    \    -1\n  else\n    n.upto(m).inject(:+).to_s(2).to_i(2).to_s(2)\n  end\nend",
  "  n = n.to_i\n  m = m.to_i\n  if n <= m\n    sum = 0\n    n.upto(m) do |i|\n  \
    \    sum += i\n    end\n    sum.to_s(2).to_i(2).to_s(2)\n  else\n    -1\n  end\n\
    end\n</code>\n<|/ a tags=ruby,ruby-on-rails |>\n<| c |>\nThis doesn't work if\
    \ n is greater than m\n<|/ c |>\n<| c |>\nI added a test case for that case to\
    \ the answer\n<|/ c |>\n<| c |>\nThis doesn't work if n is greater than m\n<|/\
    \ c |>\n<| c |>\nI added a test case for that case to the answer\n<|/ c |>\n<|\
    \ c |>\nThis doesn't work if n is greater than m\n<|/ c |>\n<| a |>\n<code>",
  "  n = n.to_i\n  m = m.to_i\n  return \"0b\" + n.to_s(2).reverse.rjust(m, 0).reverse\n\
    end", "  avg = ((n..m).to_a + (n..m).to_a).sum / 2.0\n  avg.round\n  avg.to_s(2)\n\
    end", "  \n  # Write your code here.\n  \nend", "  avg = ((n..m).sum.to_f / m).round\n\
    \  avg.to_s(2).to_i(2).to_s(2)\nend", "  avg = ((n..m).to_a.reduce(:+) / 2).round\n\
    \  binary = []\n  while n <= m\n    binary.unshift(n % 2)\n    n /= 2\n  end\n\
    \  binary.unshift(avg)\n  binary.join\nend", "  sum = 0\n  for i in 0...m\n  \
    \  sum += n\n  end\n  sum.to_s(2).reverse.gsub(/../) { |s| s.to_i(2) }\nend",
  "  avg = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg.round(0, 8)\nend", "  avg =\
    \ ((n..m).to_a * -1).sum / 2\n  avg.to_s(2).to_i(2).to_s(2)\nend", "  sum = 0\n\
    \  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.rjust(8,\
    \ \"0\")\nend", "  avg = ((n..m).sum.to_f / m).round\n  binary = []\n  while n\
    \ <= m\n    binary.push((n & m).to_s(2))\n    n += 1\n  end\n  binary.reverse.join\
    \ if binary.length == 1\n  binary.join if binary.length == 2\n  binary.join if\
    \ binary.length == 3\n  binary.join if binary.length == 4\n  binary.join if binary.length\
    \ == 5\n  binary.join if binary.length == 6\n  binary.join if binary.length ==\
    \ 7\n  binary.join if binary.length == 8\n  binary.join if binary.length == 9\n\
    \  binary.join if binary.length == 10\n  binary.join if binary.length == 11\n\
    \  binary.join if binary.length == 12\n  binary.join if binary.length == 13\n\
    \  binary.join if binary.length == 14\n  binary.join if binary.length == 15\n\
    \  binary.join if binary.length == 16\n  binary.join if binary.length == 17\n\
    \  binary.join if binary.length == 18\n  binary.join if binary.length == 19\n\
    \  binary.join if binary.length == 20\n  binary.join if binary.length == 21\n\
    \  binary.join if binary.length == 22\n  binary.join if binary.length == 23\n\
    \  binary.join if binary.length == 24\n  binary.join if binary.length == 25\n\
    \  binary.join if binary.length == 26\n  binary.join if binary.length == 27\n\
    \  binary.join if binary.length == 28\n  binary.join if binary.length == 29\n\
    \  binary.join if binary.length == 30\n  binary.join if binary.length == 31\n\
    \  binary.join if binary.length == 32\n  binary.join if binary.length == 33\n\
    \  binary.join if binary.length == 34\n  binary.join if binary.length == 35\n\
    \  binary.join if binary.length == 36\n  binary.join if binary.length == 37\n\
    \  binary.join if binary.length == 38\n  binary.join if binary.length == 39\n\
    \  binary.join if binary.length == 40\n  binary.join if binary.length == 41\n\
    \  binary.join if binary.length == 42\n  binary.join if binary.length == 43\n\
    \  binary.join if binary.length", "  n = n.to_s(2)\n  m = m.to_s(2)\n  \n  if\
    \ m > n\n    -1\n  else\n    n.to_i(2) + m.to_i(2) / 2.0\n  end\nend", "  avg\
    \ = ((n..m).to_a + (n..m).to_a).sum / 2\n  avg.round(0, 8)\nend", "  ((n..m).to_a\
    \ * -1).inject(:+).to_s(2).to_i(2) \nend\n</code>\n<|/ a tags=ruby |>\n<| a dscore=0\
    \ |>\n<code>", "  \n  if n < m\n    -1\n  else\n    n.upto(m).inject(:+) / m\n\
    \  end\nend", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n  sum.to_s(2).reverse.rjust(8,\
    \ \"0\")\nend", "  \n  sum = 0\n  \n  while n <= m\n    sum += n\n    n += 1\n\
    \  end\n  \n  sum.to_s(2).reverse.rjust(8, '0')\nend", "  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n \
    \ \n  \n  \n  \n", "  sum = 0\n  while n <= m\n    sum += n\n    n += 1\n  end\n\
    \  sum.to_s(2).reverse.gsub(/../) { |s| s == '1' ? '0' : '1' }\nend", "  sum =\
    \ 0\n  n.upto(m) do |i|\n    sum += i\n  end\n  sum.round\nend", "  sum = 0\n\
    \  for i in 0...m\n    sum += i\n  end\n  sum = (sum / m).round\n  if sum < n\n\
    \    sum = -1\n  end\n  sum.to_s(2)\nend", "  sum = 0\n  for i in n.upto(m) do\n\
    \    sum += i\n  end\n  sum.to_s(2).reverse.rjust(8, \"0\")\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
