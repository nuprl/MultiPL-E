name: HumanEval_47_median
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return median of elements\
  \ in the vector l.\n// >>> median((std::vector<long>({(long)3, (long)1, (long)2,\
  \ (long)4, (long)5})))\n// (float(3))\n// >>> median((std::vector<long>({(long)-10,\
  \ (long)4, (long)6, (long)1000, (long)10, (long)20})))\n// (15.0)\nfloat median(std::vector<long>\
  \ l) {\n"
tests: "}\nint main() {\n    auto candidate = median;\n    assert(candidate((std::vector<long>({(long)3,\
  \ (long)1, (long)2, (long)4, (long)5}))) == (float(3)));\n    assert(candidate((std::vector<long>({(long)-10,\
  \ (long)4, (long)6, (long)1000, (long)10, (long)20}))) == (8.0));\n    assert(candidate((std::vector<long>({(long)5})))\
  \ == (float(5)));\n    assert(candidate((std::vector<long>({(long)6, (long)5})))\
  \ == (5.5));\n    assert(candidate((std::vector<long>({(long)8, (long)1, (long)3,\
  \ (long)9, (long)9, (long)2, (long)7}))) == (float(7)));\n}\n"
completions: ["    std::nth_element(l.begin(), l.begin() + l.size() / 2, l.end());\n\
    \    return l[l.size() / 2];", "    // Find median from both sides.\n    size_t\
    \ mid = l.size() / 2;\n    float x = l[mid];\n    float y = l[mid+1];\n    //\
    \ If even size, then median is mid-point.\n    if (l.size() % 2 == 0) {\n    \
    \    return mid;\n    }\n    // If odd size, then median is (mid+x)/2.0\n    return\
    \ (mid+x)/2;", "  std::sort(l.begin(), l.end());\n  long mid = l.size()/2;\n \
    \ if (l.size() % 2) return l[mid];\n  else if (l[mid]>l[mid-1]) return l[mid];\n\
    \  else return l[mid-1];", "    // Calculate median using two pivot elements.\n\
    \    float x = l[0];\n    float y = l[0];\n    for (long i = 1; i < l.size();\
    \ i++)\n    {\n        if (l[i] < x)\n            x = l[i];\n        else if (l[i]\
    \ > y)\n            y = l[i];\n    }\n    if (l.size() == 1)\n        return y;\n\
    \    else\n    {\n        float z = l[l.size() / 2];\n        return (x == z)\
    \ ? y : z;\n    }", "  // Check that the size of the vector is bigger than 2.\n\
    \  if (l.size() >= 2) {\n    // Sort vector\n    std::sort(l.begin(), l.end());\n\
    \    \n    // Compute midpoint\n    float mid = l[0] + l[l.size() / 2];\n\n  \
    \  // Compute midpoint\n    long mid2 = l[0] + l[l.size() / 2];\n\n    // Return\
    \ middle point\n    return mid;\n  }\n  \n  return float(l.size()); // Return\
    \ an empty vector if l has less than 2 elements.", "    assert(l.size() % 2 ==\
    \ 0);\n    float left, right;\n    left = (l[l.size() / 2] + l[l.size() / 2 -\
    \ 1]) / 2.0;\n    right = (l[l.size() / 2 - 1] + l[l.size() / 2]) / 2.0;\n   \
    \ return ((left + right) / 2.0);", "    sort(l.begin(), l.end());\n    float s\
    \ = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    for (std::vector<long>::size_type\
    \ i = 0; i < l.size(); ++i) {\n        s += l[i];\n        n += 1;\n    }\n  \
    \  s = (float)(s / n);\n    if (n % 2)\n        m = l[n / 2];\n    else\n    \
    \    m = l[n / 2 - 1];\n    return s;", "\tsort(l.begin(), l.end());\n\tsize_t\
    \ mid = l.size() / 2;\n\tif (l.size() % 2 == 0)\n\t\treturn l[mid];\n\telse\n\t\
    \treturn l[mid] + l[mid-1];", "    std::vector<long>::iterator it = std::max_element(l.begin(),\
    \ l.end());\n    long long val = *it;\n    l.erase(it);\n    if (l.size() == 0)\
    \ return 0.0f;\n    if (l.size() % 2 == 0) {\n        std::nth_element(l.begin(),\
    \ l.begin() + l.size() / 2, l.end());\n        return *(l.begin() + l.size() /\
    \ 2);\n    } else {\n        std::nth_element(l.begin(), l.begin(), l.end() -\
    \ 1);\n        return *(l.begin() + l.size() / 2);\n    }", "  // Find the largest\
    \ and smallest values in l\n  long long smallest = std::min_element(std::begin(l),\
    \ std::end(l));\n  long long largest = std::max_element(std::begin(l), std::end(l));\n\
    \  // Define an adaptive binary search to find index of middle element of l.\n\
    \  auto findIndex = [](std::vector<long> l, long long x) {\n    // return std::upper_bound(std::begin(l),\
    \ std::end(l), x) - std::begin(l);\n    return std::upper_bound(std::begin(l),\
    \ std::end(l), x);\n  };\n  // Define an adaptive binary search to find index\
    \ of middle element of l.\n  auto findMiddleIndex = [&smallest, &largest](int\
    \ n) {\n    if (n >= 0 && n < (int)l.size() - 1) {\n      // return findIndex(l,\
    \ l[n] + 0.5);\n      return findIndex(l, l[n] + 0.5);\n    } else {\n      return\
    \ -1;\n    }\n  };\n  // Find the median as the average of middle two elements.\n\
    \  int mid = findMiddleIndex(l.size() / 2);\n  if (mid >= 0) {\n    long long\
    \ m1 = findMiddleIndex(mid);\n    long long m2 = findMiddleIndex(mid);\n    float\
    \ m = (float)(m1 + m2) / 2.0f;\n    return m; // median\n  } else {\n    return\
    \ float(0);\n  }", "  assert(l.size() > 2);\n  float left_median = std::accumulate(l.begin(),\
    \ l.begin() + l.size() / 2, 0.0f) / l.size() / 2;\n  float right_median = std::accumulate(l.rbegin(),\
    \ l.rbegin() + l.size() / 2, 0.0f) / l.size() / 2;\n  return left_median + (right_median\
    \ - left_median) * (l.size() / 2);", "    long n = l.size();\n    assert(n >=\
    \ 3);\n    long l2 = n*(n+1)/2;\n    std::vector<long> l3(l2);\n    for (long\
    \ i = 0; i < n; i++) {\n        l3[i] = l[i];\n    }\n    // Sort the vector.\n\
    \    std::sort(l3.begin(), l3.end());\n    // Return middle element (0.5*n+1).\n\
    \    return l3[(n+1)/2];", "    long long n = l.size();\n    float result = n==0?\
    \ 0.0 : l[n/2] + (n%2?0.5:0.);\n    return result / (n*1.0f);", "    long n =\
    \ l.size();\n    if (n <= 1) return l[0];\n    long m = l[0] + l[n - 1];\n   \
    \ for (long i = 2; i < n; i++) m = l[i] + (l[i - 1] + l[i - 2]) / 2;\n    return\
    \ m;", "    // If any elements are non-positive, return (largest + smallest -\
    \ 1).\n    float smallest, largest;\n    smallest = std::numeric_limits<float>::max();\n\
    \    largest = -smallest;\n    for (long elem : l) {\n        smallest = std::min(elem,\
    \ smallest);\n        largest = std::max(elem, largest);\n    }\n    return (largest\
    \ + smallest - 1.0) / 2.0;", "    int N = l.size();\n    int m = (N + 1) / 2;\n\
    \    if (N % 2 == 1) m++;\n    assert(N % 2 == 0);\n    float avg = 0.0f;\n  \
    \  for (long i = 0; i <= N; i++) {\n        avg += l[i];\n    }\n    avg /= N;\n\
    \    if (N % 2 == 0) {\n        std::swap(avg, (avg + l[N - 1]));\n    }\n   \
    \ return avg;", "  float med = 0.0;\n  int l_n = l.size();\n  if (l_n % 2 == 1)\n\
    \    med = l[l_n / 2];\n  else {\n    long med1 = l[l_n / 2 - 1];\n    long med2\
    \ = l[l_n / 2];\n    if (med + med2 > 0) med = (med + med2) >> 1;\n    else med\
    \ = med1;\n  }\n  return med;", "  // Return median of elements in the vector\
    \ l.\n  assert(l.size() >= 2);\n\n  // Store the values into variables.\n  long\
    \ long int mid = l.size() / 2;\n  long long int left = l[mid];\n  long long int\
    \ right = l[mid + 1];\n\n  // If the right half is not even then return mid.\n\
    \  if (right % 2 == 0) {\n    return mid;\n  }\n\n  // If right half is odd, then\
    \ calculate median as right - left.\n  long long int mid2 = mid + 1;\n  long long\
    \ int left2 = l[mid2];\n  long long int right2 = l[mid2 + 1];\n  return ((right2\
    \ + left2) / 2.0);", "  int len = l.size();\n  assert(len > 1);\n  float res =\
    \ l[0] * (len - 1) / 2.0 + l[len - 1] * (len) / 2.0;\n  for (int i = 1; i < len;\
    \ i++) {\n    if (l[i] > res)\n      res = l[i];\n  }\n  return res;", "    assert(l.size()\
    \ > 0);\n    long long n1 = l.size();\n    long long n2 = (n1 / 2);\n    long\
    \ long n3 = n1 - n2;\n    if (n3 == 0) return l[0];\n    if (n3 == 1) return l[n2];\n\
    \    float lower = l[n2];\n    float upper = l[n3];\n    float median;\n    if\
    \ (lower < upper) median = lower;\n    else median = upper;\n    return median;",
  "  assert(l.size() > 0);\n  long half = l.size() / 2;\n  if (l.size() % 2 == 1)\
    \ {\n    return std::min({l[half], l[half + 1]}); // if odd length: min(l[half],\
    \ l[half + 1]).\n  }\n  return std::min({l[half], l[half - 1] + l[half], l[half\
    \ + 1]}); // if even length: min(l[half], l[half + 1]).", "    assert(l.size()\
    \ > 1);\n    float median = 0;\n    long long l = 0, r = l.size() - 1;\n    while\
    \ (l <= r) {\n        float mid = ((float)l+r)/2.0f;\n        if (l<r)\n     \
    \       median += (l<mid) ? l+r : r-mid;\n        if (l>r)\n            median\
    \ += (l<mid) ? mid : r-mid;\n        l += 1;\n        r -= 1;\n    }\n    return\
    \ median;", "    std::sort(l.begin(), l.end());\n    size_t mid = l.size() / 2;\n\
    \    if (l.size() % 2 == 1) {\n        // A[mid] <= A[mid+1]\n        if (l[mid]\
    \ <= l[mid+1]) {\n            return l[mid];\n        }\n        return l[mid+1];\n\
    \    }\n    // A[mid] >= A[mid+1]\n    return std::min(l[mid], l[mid+1]);", " \
    \   return static_cast<float>(std::nth_element(l.begin(), l.begin() + l.size()/2,\
    \ l.end()) -\n                            l.begin()) / l.size() / 2;", "    if\
    \ (l.size() % 2 == 1) {\n        return l[(l.size() / 2) - 1] + (l[(l.size() /\
    \ 2)]) / 2.0;\n    }\n    return l[(l.size() / 2)];", "    assert(l.size() > 0);\n\
    \    int index = (int)l.size()/2;\n    int lo = l[index];\n    int hi = l[index\
    \ ^ 1];\n    return 0.5 * (hi + lo);", "    int sz = l.size();\n    if (sz <=\
    \ 0)\n        return 0;\n    std::sort(l.begin(), l.end());\n    float mid = l[sz\
    \ / 2];\n    return (sz % 2) ? mid : mid + median(std::vector<long>(l.begin()\
    \ + sz / 2, l.end()));", "    long l = l.size();\n    if (l == 0) return 0.0f;\n\
    \    // Compute median:\n    long m = l / 2;\n    long count = 0;\n    for (long\
    \ i = 0; i < l; ++i) {\n        if (l[i] < m) count++;\n        else break;\n\
    \    }\n    if (l % 2 == 0)\n        return ((l[count / 2] + l[count / 2 - 1])\
    \ / 2.0f);\n    else return l[count / 2];", "  long mid = l.size() / 2;\n  if\
    \ (l.size() == 0 || mid % 2 == 0)\n    return (l[mid] + l[mid]) / 2;\n  else\n\
    \    return l[mid];", "  assert(l.size() > 1);\n  float mid = l.size() / 2.0;\n\
    \  std::vector<float> sorted;\n  sorted.reserve(l.size());\n  for (size_t i =\
    \ 0; i < l.size(); ++i) {\n    sorted.push_back(std::abs(l[i] - mid));\n  }\n\
    \  sort(sorted.begin(), sorted.end());\n  return sorted[sorted.size() / 2.0];",
  "    size_t size = l.size();\n    long mid = size/2;\n    if(size == 0) return 0.0f;\n\
    \    if(size % 2 == 0) {\n        if(l[mid] < l[mid + 1]) return l[mid];\n   \
    \     return l[mid + 1];\n    }\n    else {\n        if(l[mid] < l[mid-1]) return\
    \ l[mid];\n        return l[mid-1];\n    }", "  long n = l.size();\n  assert(n\
    \ % 2 == 1);\n  assert(n >= 1);\n  // Sort the vector\n  std::vector<long> temp(n);\n\
    \  std::iota(temp.begin(), temp.end(), 0);\n  std::sort(temp.begin(), temp.end(),\
    \ std::greater<long>());\n  // Calculate the midpoint\n  long m = n / 2;\n  float\
    \ x = 0;\n  for (long i = 0; i < n; i++)\n    if (i == m) x += l[i];\n    else\
    \ x += (2 * l[i] - l[m - 1]);\n  return x;", "    long n = l.size();\n    assert(n\
    \ > 0);\n    long mid = n / 2;\n    if (mid % 2 == 0) {\n        return std::pair<float,\
    \ long>((l[mid / 2] + l[mid / 2 - 1]) / 2.0,\n                               \
    \       l[mid]);\n    } else {\n        return std::pair<float, long>((l[mid]\
    \ + l[mid + 1]) / 2.0,\n                                      l[mid]);\n    }",
  "    float s = 0.0;\n    long size = l.size();\n    if (size == 0)\n        return\
    \ 0.0;\n    size_t mid = size / 2;\n    float midval;\n    if (size % 2 == 0)\
    \ {\n        midval = l[mid];\n        midval = (midval + l[mid-1]) / 2.0;\n \
    \       s = midval;\n    } else {\n        midval = l[mid];\n        midval =\
    \ (midval + l[mid+1]) / 2.0;\n        s = midval;\n    }\n    if (s == 0.0)\n\
    \        return 0.0;\n    float res = 0.0;\n    while (size > 1) {\n        if\
    \ (size > 3) {\n            midval = l[mid];\n            midval = (midval + l[mid-1])\
    \ / 2.0;\n            s = midval;\n        } else {\n            midval = l[mid];\n\
    \            s = midval;\n        }\n        res += s;\n        size -= 2;\n \
    \       mid += 1;\n    }\n    return res;", "  // find median with binary search\
    \ - O(log(n))\n  int m = std::ceil((float)l.size() / (float)2);\n  if (m.zero())\
    \ return l[0];\n  if (l.size() % 2 == 1) return l[m];\n  long mid = l.size() /\
    \ 2;\n  if (l[mid] == l[mid - 1]) mid++;\n  return l[mid];", "    assert(l.size()\
    \ >= 1);\n    float a = l.front();\n    for (std::vector<long>::iterator it =\
    \ l.begin() + 1; it != l.end(); it++)\n        a += *it;\n    return a / (l.size()\
    \ - 1);", "    long long ll = l.size();\n    if (ll <= 0) return 0.0;\n    float\
    \ median = ((float)(ll-1)/2.0f) + ((float)l/ll);\n    return median;", "  auto\
    \ it = l.begin();\n  float res = std::min(it+1, l.end()) - std::max(it, l.begin());\n\
    \  return res;", "  auto begin = l.begin();\n  auto end = l.end();\n  float midpoint\
    \ = (*begin + end) / 2.0f;\n\n  // If there are an odd number of elements, round\
    \ up.\n  if (end % 2) midpoint = midpoint + 1;\n\n  // If the first and last elements\
    \ are the same, return the middle element.\n  if (*begin == *end) return midpoint;\n\
    \n  // Find the middle element by iterating over the sorted elements.\n  long\
    \ mid = midpoint;\n  for (; begin != end; ++begin) {\n    if (*begin <= mid) mid\
    \ = *begin;\n  }\n\n  // Return the middle element.\n  return mid;", "    // Compute\
    \ range from vector.\n    long n = l.size();\n    long s = (n + 1.0) / 2.0; //\
    \ Sign of dividing n by 2.\n    long middle = l [s % n];\n    // Sort vector using\
    \ merge sort and compute median as middle of sorted vector.\n    std::vector<int>\
    \ l2;\n    for (long i = 0; i < n; ++i)\n        l2.push_back(l[i]);\n    sort(l2.begin(),\
    \ l2.end());\n    return (float)middle;", "    l.sort();\n    return l[l.size()/2];",
  "    std::vector<long>::iterator it;\n    long temp;\n    float median = 0;\n  \
    \  // Get middle element\n    it = l.begin() + l.size() / 2;\n    temp = *it;\n\
    \    // If there are at least two elements, return middle element\n    // If there\
    \ are only 1 elements, return middle element\n    if (l.size() >= 2) {\n     \
    \   median = temp;\n    } else {\n        median = *it;\n    }\n    return median;",
  "    assert(l.size() > 0);\n    assert(l.size() % 2 == 1);\n    assert(l.size()\
    \ <= 1000);\n    int center = l.size() / 2;\n    long l1 = l[center - 1];\n  \
    \  long l2 = l[center];\n    if (l2 > l1) {\n        std::swap(l1, l2);\n    \
    \    center = l.size() / 2;\n    }\n    if (l2 + 0.5f < l1) {\n        std::swap(l1,\
    \ l2);\n        center = l.size() / 2;\n    }\n    if (l1 == l2) {\n        return\
    \ 0.f;\n    }\n    return 0.5f * (l1 + l2) / 2;", "  // Sort vector\n  sort(l.begin(),\
    \ l.end());\n  // Middle element\n  size_t mid = l.size() / 2;\n  // Return if\
    \ vector is 1 element\n  if (l.size() <= 1) return l.front();\n  // Return if\
    \ vector is 2 elements\n  if (l.size() <= 2) return (l.front() + l.back()) / 2.0;\n\
    \  // Return if vector is even number of elements\n  if (l.size() % 2 == 0) return\
    \ (l.front() + l.back()) / 2.0;\n  // Find the middle element\n  float middle\
    \ = l[mid];\n  // Iterate through two vectors swapping two elements\n  for (size_t\
    \ i = 0; i < l.size(); i++) {\n    if (i != mid) {\n      std::swap(l[i], l[mid]);\n\
    \    }\n  }\n  // Find return middle element\n  return middle; // return (l.front()\
    \ + l.back()) / 2.0;", "  // Get number of elements\n  size_t n = l.size();\n\
    \  // Return average of median\n  return (float)(((n & 1) ? l[n / 2] : (l[n /\
    \ 2] + l[n / 2 - 1])) / 2.0);", "  std::sort(l.begin(), l.end());\n  return (l.size()\
    \ % 2) ? l[l.size()/2] : (l[l.size()/2-1] + l[l.size()/2]) / 2;", "\tassert (l.size()\
    \ > 0);\n\tfloat sum = 0;\n\tfloat size = l.size();\n\tfor (int i = 0; i < size;\
    \ i++) {\n\t\tsum += l[i];\n\t}\n\treturn sum / size;", "    sort(l.begin(), l.end());\n\
    \    size_t mid = l.size() / 2;\n    if (l.size() % 2 == 1) mid--;\n    float\
    \ result = (l[mid + 1] + l[mid]) / 2;\n    return result;", "  int n = l.size();\n\
    \  float mid = n/2.0f;\n  std::nth_element(l.begin(), l.begin() + mid, l.end());\n\
    \  return (*(l.begin() + mid)) / n;", "    std::nth_element(l.begin(), l.begin()\
    \ + l.size()/2, l.end());\n    return l[l.size()/2];", "    auto a = l.begin();\n\
    \    auto b = l.end();\n    long n = (b - a) / 2;\n    if (n & 1) return std::min(a\
    \ + n, b);\n    else return std::max(a, b);", "    long mid = l.size() / 2;\n\
    \    if (l.size() % 2 == 1) {\n        return l[mid];\n    } else {\n        return\
    \ (l[mid] + l[l.size() / 2]) / 2.0;\n    }", "\tif (l.size() % 2 == 0) return\
    \ static_cast<float>(l[l.size() / 2 - 1] + l[l.size() / 2]) / 2.0f;\n\telse return\
    \ static_cast<float>(l[l.size() / 2]) / 2.0f;", "    std::sort(l.begin(), l.end());\n\
    \    return l.size() >= 2 ? (l[l.size() - 1] + l[l.size() / 2 - 1]) / 2.0 : 0;",
  "    long long n = l.size();\n    assert(n != 0 && n != 1);\n    if (n % 2 == 0)\n\
    \        return l[n / 2 - 1] + (l[n / 2] + l[n / 2 - 1]) / 2.0;\n    else\n  \
    \      return l[n / 2];", "    float x = 0, y = 0;\n    long i = 0, n = l.size();\n\
    \    // Check if there are any even elements.\n    if (n % 2 == 0) {\n       \
    \ // If the number of elements is odd, find the average.\n        // >>> median((std::vector<long>({(long)3,\
    \ (long)1, (long)2, (long)4, (long)5})))\n        // float(3)\n        i += 1;\n\
    \        x += (double)l[i] / n;\n        // >>> median((std::vector<long>({(long)-10,\
    \ (long)4, (long)6, (long)1000, (long)10, (long)20})))\n        // float(15.0)\n\
    \        i += 1;\n        y += (double)l[i] / n;\n    } else {\n        // If\
    \ the number of elements is even, find the average.\n        // >>> median((std::vector<long>({(long)3,\
    \ (long)1, (long)2, (long)4, (long)5})))\n        // float(3)\n        i += 1;\n\
    \        x += (double)l[i] / n;\n        i += 1;\n        x += (double)l[i] /\
    \ n;\n        // >>> median((std::vector<long>({(long)-10, (long)4, (long)6, (long)1000,\
    \ (long)10, (long)20})))\n        // float(3)\n        i += 1;\n        y += (double)l[i]\
    \ / n;\n        i += 1;\n        y += (double)l[i] / n;\n    }\n    // Return\
    \ the median of x and y or x + y if x and y are equal.\n    return (x > y ? x\
    \ : y);", "  if (l.size() == 0) return 0;\n  long low = 0, high = l.size() - 1;\n\
    \  if (l.front() < l.back()) std::swap(low, high);\n  int mid = low + (high -\
    \ low) / 2;\n  if (m[mid] == 0) return l.front();\n  int pivot = m[mid];\n  if\
    \ (pivot != 0) return pivot; // median is not defined, return first element\n\
    \  int left = 0;\n  int right = (int)l.size();\n  while (left < right) {\n   \
    \ while (left < right && l[left] <= pivot) left++;\n    while (right > left &&\
    \ l[right] > pivot) right--;\n    if (left < right) {\n      std::swap(l[left],\
    \ l[right]);\n      left++;\n      right--;\n    }\n  }\n  float ret = l[left];\n\
    \  while (right >= left) {\n    m[right] = m[left];\n    right--;\n    left++;\n\
    \  }\n  m[left] = pivot;\n  return ret;", "    long long arr[n], temp = 0;\n \
    \   int k = 0;\n    bool flag = false;\n\n    arr.assign(n, 0);\n\n    for (auto\
    \ x : l) {\n        arr[k++] = x;\n    }\n\n    // Sort the array\n    std::sort(arr.begin(),\
    \ arr.end());\n\n    temp = arr[n/2];\n\n    // If count of element is odd then\
    \ median is middle element.\n    if (n % 2 == 1) {\n        return temp;\n   \
    \ }\n\n    if (arr[n/2] < arr[n/2 - 1]) {\n        temp = arr[n/2];\n    } else\
    \ {\n        temp = arr[n/2 - 1];\n    }\n\n    // If count of element is odd\
    \ then median is middle element.\n    if (n % 2 == 1) {\n        return temp;\n\
    \    }\n\n    if (arr[n/2] > arr[n/2 - 1]) {\n        temp = arr[n/2];\n    }\
    \ else {\n        temp = arr[n/2 - 1];\n    }\n\n    return temp;", "\t// Initialize\
    \ two pointers to the first and last elements, initialize count\n\t// to zero,\
    \ and set pointers to the first and last elements, while the\n\t// remaining elements\
    \ are less than the element with the smaller count.\n\t// The pointers may cross\
    \ at mid-points, and we will stop one element\n\t// before crossing into the next\
    \ element.\n\tlong *first = new long[l.size()], *last = first, *count = first;\n\
    \tstd::fill(first, first + l.size(), 0);\n\tbool found = false;\n\twhile (last\
    \ < first + l.size()) {\n\t\tif (*count + 1 > (last - first)) {\n\t\t\tlast =\
    \ first;\n\t\t\tstd::fill(first, first + l.size(), 0);\n\t\t\tcount = first;\n\
    \t\t} else {\n\t\t\tstd::fill(last, last + l.size(), 0);\n\t\t\tcount += 1;\n\t\
    \t}\n\t\t// Find the element with the smaller count.\n\t\tfor (long i = 0; !found\
    \ && i < l.size(); ++i) {\n\t\t\tif (l[i] < *count) {\n\t\t\t\t*count = l[i];\n\
    \t\t\t\tfirst[i] = last[i] = l[i];\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\
    }\n\tassert(found);\n\t// Find the average of the remaining elements.\n\tstd::sort(first,\
    \ last + l.size() - 1);\n\tfloat median = (last - first + 1) / 2.0;\n\tstd::fill(first,\
    \ first + l.size(), 0);\n\tstd::fill(last, last + l.size(), 0);\n\tfor (long i\
    \ = l.size() - 1; i > 0; --i) {\n\t\tfirst[i] = l[i];\n\t\tlast[i] = l[i - 1];\n\
    \t}\n\tfirst[0] += last[0];\n\tstd::fill(first, first + l.size(), 0);\n\tstd::fill(last,\
    \ last + l.size(), 0);\n\tstd::fill(count, count + l.size(), 0);\n\tfor (long\
    \ i = 0; !found && i < l.size(); ++i) {\n\t\tif (l[i] < *count) {\n\t\t\t*count\
    \ = l[i];\n\t\t\tfirst[i] = last[i] = l[i];\n\t\t\tfound = true;\n\t\t}\n\t}\n\
    \tassert(found);\n\treturn median;", "  if (l.empty()) return 0;\n  std::nth_element(l.begin(),\
    \ l.begin() + l.size() / 2, l.end());\n  return ((double)l[l.size() / 2] + l[l.size()\
    \ / 2 - 1]) / 2;", "    long low = 0, high = l.size() - 1;\n    // find mid-point\n\
    \    while (low < high) {\n        long mid = low + (high - low) / 2;\n      \
    \  if (l[mid] > l[high]) high = mid;\n        else if (l[mid] < l[low]) low =\
    \ mid;\n        else return l[mid];\n    }\n    return l[low];", "  long n = l.size();\n\
    \  assert(n % 2 == 0);\n  long middle = (n + 1) >> 1;\n  std::vector<long> v1\
    \ = l;\n  std::vector<long> v2 = std::move(v1);\n  v1[middle] = std::numeric_limits<long>::max();\n\
    \  v2[middle] = std::numeric_limits<long>::min();\n  auto vsum = std::inner_product(v1.begin(),\
    \ v1.end(), v2.begin(), 0.0);\n  float vmedian = (float)vsum / n;\n  return vmedian;",
  "  if (l.size() % 2 == 0)\n    return (l[l.size()/2 - 1] + l[l.size()/2-1])/2.0f;\n\
    \  return l[l.size()/2];", "    float med = -1;\n    for (long n : l) {\n    \
    \    if (med == -1 || n < med) {\n            med = n;\n        }\n    }\n   \
    \ return med;", "    if (l.size() == 0) return 0;\n    auto it = std::nth_element(l.begin(),\
    \ l.begin() + l.size() / 2, l.end());\n    return *std::next(it);", "  std::sort(l.begin(),\
    \ l.end());\n  return l.size() % 2 == 0 ? l[(l.size() / 2) - 1] + l[(l.size()\
    \ / 2)]\n                          : (l[(l.size() / 2)] + l[(l.size() / 2) - 1u])\
    \ / 2.0;", "    assert(l.size() > 0);\n    std::nth_element(l.begin(), l.begin()\
    \ + l.size() / 2, l.end());\n    return l[l.size() / 2];", "  // Sort vector l.\n\
    \  std::sort(l.begin(), l.end());\n  // Get the size from l.\n  long size = l.size();\n\
    \  // Return median of elements divided by size.\n  return static_cast<float>(l[size/2])\
    \ / size;", "    // Sort elements in vector l, if not already sorted.\n    auto\
    \ itr = l.begin();\n    for (; itr != l.end(); ++itr)\n        std::iter_swap(itr,\
    \ *(itr+1));\n    l.insert(l.begin(), 0);\n\n    // If size is even then median\
    \ is midpoint of first and last element.\n    if (l.size() % 2 == 0) {\n     \
    \   return l[l.size()/2];\n    }\n\n    // Otherwise sort elements in vector l,\
    \ which sorts by value.\n    // In C++11, we can use:\n    // std::nth_element(l.begin(),\
    \ l.end(), l.begin()+1);\n    // to sort vector l, which would also require changing\
    \ function call.\n    // Using C++03, we would have to write new function with\
    \ same name\n    // and slightly different arguments.\n    // The new function\
    \ can look like this:\n    // void nth_element( std::vector<long>::iterator first,\
    \ std::vector<long>::iterator nth, std::vector<long>::iterator last );\n    std::nth_element(l.begin(),\
    \ l.end()-1, l.begin()+1);\n\n    // Return median of first and last elements.\n\
    \    return l[l.size()/2];", "    // Sort the vector l on descending order.\n\
    \    std::sort(l.begin(), l.end(), std::greater<long>());\n    return l[(l.size()\
    \ / 2)];", "  long long ll = l.size();\n  int l1 = ll / 2, l2 = ll - l1, median;\n\
    \  if (l1 > l2) median = l[l1 % 2 == 0];\n  else median = l[l2 % 2 == 0];\n  return\
    \ (float(median));", "  float leftmost, rightmost, median;\n  leftmost = (l[0]\
    \ < 0)? l[0] : -l[0];\n  rightmost = (l[l-1] < 0)? l[l-1] : -l[l-1];\n  median\
    \ = (leftmost + rightmost)/2;\n  return median;", "    long largest = 0, largestIdx\
    \ = 0;\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (l[i] > largest)\n\
    \            largest = l[i];\n        largestIdx = i;\n    }\n    assert(largestIdx\
    \ != 0);\n    float mid = ((float)largestIdx + 1) / (float)l.size();\n    return\
    \ mid;", "    assert(l.size() > 0);\n    float ans = (float) l.size() / 2;\n \
    \   \n    for(std::vector<long>::iterator it=l.begin(); it!=l.end(); ++it) {\n\
    \        if(*it < ans)\n            ans = *it;\n    }\n    return ans;", "  std::vector<long>\
    \ sorted(l);\n  std::sort(sorted.begin(), sorted.end());\n  if (sorted.size()\
    \ % 2 == 0) {\n    return (sorted[sorted.size() / 2] + sorted[sorted.size() /\
    \ 2 - 1]) / 2.0;\n  }\n  else {\n    return (sorted[sorted.size() / 2 - 1] + sorted[sorted.size()\
    \ / 2]) / 2.0;\n  }", "    if (l.size() % 2 == 0)\n        return (l[(l.size()\
    \ / 2) - 1] + l[(l.size() / 2)]) / 2.0;\n    else\n        return l[(l.size()\
    \ / 2)];", "  // Sort the vector l.\n  std::sort(l.begin(), l.end());\n  // Return\
    \ median of l.\n  return l[l.size() / 2];", "    // Write your code here.\n  \
    \  std::vector<std::size_t> sizes;\n    for (auto& i : l) {\n        auto n =\
    \ sizes.size();\n        sizes.push_back(n);\n    }\n    std::vector<int> indexs(sizes.size());\n\
    \    for (size_t i = 0; i < sizes.size(); i++) {\n        indexs[i] = i;\n   \
    \ }\n    std::partial_sort(indexs.begin(), indexs.end(), indexs.begin() + sizes.size()\
    \ / 2);\n    int mid = (indexs.size() / 2) + 1;\n    std::vector<int>::iterator\
    \ it = indexs.begin();\n    std::vector<long>::iterator it_end = l.end();\n  \
    \  std::vector<long>::iterator it_middle = it_end - mid / 2;\n    int count =\
    \ 0;\n    while ((it < it_end) && (it < it_middle)) {\n        count += 1;\n \
    \       it = std::next(it, 1);\n    }\n    float average = static_cast<float>(count)\
    \ / static_cast<float>(l.size());\n    return average;", "\t// Find the length\
    \ of vector l.\n\tsize_t len = l.size();\n\t// Compute median from mid-points\
    \ (if len > 2) of l.\n\tfloat med = ((len - 1) / 2.0) + 1;\n\t// Return median\
    \ of elements of vector l.\n\treturn med;", "    assert(l.size() >= 2);\n    long\
    \ mid = l[0]/2;\n    long a = l[0];\n    long b = l[0];\n    for (long i : l)\
    \ {\n        a = b;\n        b = i;\n    }\n    if (b < mid) return (float)b;\n\
    \    return (float)a;", "  assert(l.size() > 0);\n  long long n = l.size();\n\
    \  assert(n % 2 == 0);\n\n  std::vector<long> even = l;\n  std::vector<long> odd\
    \ = l;\n  odd.push_back(0);\n  // Even median is element with middle index n/2\n\
    \  long long median_even = n / 2;\n  // Odd median is element with middle index\
    \ n/2 - 1\n  long long median_odd = median_even - 1;\n  if (median_even > median_odd)\
    \ {\n    // Swap even and odd median\n    std::swap(median_even, median_odd);\n\
    \  }\n  // Add middle element\n  even.push_back(median_even);\n  // Add other\
    \ elements to odd median\n  for (int i = (n / 2); i < n; i++) {\n    odd.push_back(even[i\
    \ - 1]);\n  }\n\n  return (float) median(even) + median(odd);", "  int n = l.size();\n\
    \  if (n % 2 == 1)\n    return l[n/2];\n  else\n    return (l[n-1] + l[n/2])/2;",
  "    // Sort the vector in ascending order\n    std::sort(l.begin(), l.end());\n\
    \    // return the middle element\n    return l[(l.size()-1)/2];", "    long mid\
    \ = l.size() / 2;\n    if (l.size() % 2 == 0) return 0.5 * (l[mid + 1] + l[mid]);\n\
    \    else return l[mid];", '  // Your code here', "    assert(!l.empty());\n \
    \   int mid = l.size() / 2;\n    if (l.size() % 2 == 0) {\n        return l[mid];\n\
    \    } else {\n        return (l[mid] + l[mid]) / 2;\n    }", "  std::sort(l.begin(),\
    \ l.end());\n  return std::count_if(l.begin(), l.end(), [&](long i) {\n    return\
    \ i % 2 == 0;\n  }) / (l.size() * 2);", "    assert(l.size() >= 2);\n    long\
    \ mid = l.size() / 2;\n    return float((l[mid] + ((l.size() - 1) / 2) - mid)\
    \ / 2);", "  std::nth_element(l.begin(), l.begin() + l.size() / 2, l.end());\n\
    \  return static_cast<float>(l.at(l.size() / 2)); // float cast to avoid overflow\
    \ of long float.", "    assert(l.size() % 2 == 0); // TODO: check that number\
    \ of elements is even.\n    std::vector<float> a;\n    int n = l.size() / 2;\n\
    \    for (int i = 0; i < n; ++i) {\n        a.push_back(l[2 * i]);\n        a.push_back(l[2\
    \ * i + 1]);\n    }\n    return *std::max_element(std::begin(a), std::end(a));",
  "  assert(l.size() > 0);\n  long length = l.size();\n  long mid = length / 2;\n\
    \  long left = 0;\n  long right = length;\n  if (length%2 == 1) {\n    left =\
    \ mid;\n    right = mid+1;\n  } else {\n    left = mid + 1;\n    right = mid +\
    \ 2;\n  }\n  float pivot = (float)(l[left] + l[right]);\n  long pivotIndex = left;\n\
    \  for (long i = left + 1; ; ++i) {\n    if (l[i] < pivot) {\n      swap(l[i],\
    \ l[pivotIndex]);\n      swap(l[pivotIndex], l[i]);\n      swap(l[i], l[pivotIndex]);\n\
    \      --i;\n      ++pivotIndex;\n      if (i == length) {\n        break;\n \
    \     }\n    }\n  }\n  if (length % 2 == 1) {\n    return l[pivotIndex];\n  }\
    \ else {\n    return pivot;\n  }", "  // Find median and sort vector\n  std::sort(l.begin(),\
    \ l.end());\n  \n  float s = l[0] + l[l.size() / 2];\n  \n  // Find which side\
    \ of the median is closer to 0\n  int i = (l.size() / 2) - 1;\n  \n  while (i\
    \ >= 0 && l[i] < s) {\n    \n    // Move i to right until it makes sense\n   \
    \ while (i < l.size() - 1 && l[i + 1] > s) {\n      i++;\n    }\n    \n    //\
    \ If median is closer to 0, move it to the left\n    if (l[i] < s) {\n      i++;\n\
    \    }\n  }\n  \n  // If all elements are less than median, return it\n  if (l.size()\
    \ % 2) {\n    return l[i];\n  }\n  \n  // If one element is less than median,\
    \ return it\n  else {\n    return l[i] - l[i - 1];\n  }", "  // Sort the vector\
    \ in ascending order.\n  std::sort(l.begin(), l.end());\n  // Compute the size\
    \ of the middle element.\n  size_t mid = l.size() / 2;\n  // Return the average\
    \ of the middle elements and the element next to it (median).\n  return l.at(mid)\
    \ + ((mid + 1 > l.size()) ? (l.at(mid)) : ((l.at(mid + 1)) + 0.5f));", "  // Find\
    \ size of vector and array index where element should be inserted.\n  int size\
    \ = l.size();\n  int mid = size % 2 == 0 ? size / 2: size / 2 - 1;\n  // Create\
    \ array for vector with size mid + 1\n  long *array = static_cast<long*>(malloc(mid\
    \ * sizeof(long)));\n  // Copy vector into array\n  for (int i = 0; i < mid; i++)\
    \ array[i] = l[i];\n  // Copy mid element into position specified by size when\
    \ size/2 was inserted.\n  array[mid] = l[mid];\n  // Copy size/2 element into\
    \ position 0 of array.\n  array[0] = l[size / 2];\n  // Sort array from low to\
    \ high.\n  sort(array, array + size);\n  // Return middle element of array.\n\
    \  return array[size / 2];", "    assert(l.size() > 1);\n    long n = l.size();\n\
    \    long div = n/2;\n    if (n % 2 == 0)\n        return ((l[div] + l[div+1])/2.0);\n\
    \    return l[div];", "  auto it = l.begin();\n  float res = std::numeric_limits<float>::max();\n\
    \  for (; it != l.end(); ++it) {\n    res = std::min(res, *it);\n  }\n  return\
    \ res;", "    // Sort the vector to get a sorted copy of the vector.\n    std::sort(l.begin(),\
    \ l.end());\n\n    // Find the middle element.\n    // Return middle element.\n\
    \    float mid = (float)l.size() / 2.0f;\n    if (l.size() % 2 == 1)\n       \
    \ return l[mid];\n    else\n        return (l[mid - 1] + l[mid]) / 2.0f;", " \
    \ long sizeOfArray = l.size();\n  // sort and find midpoint.\n  auto midpoint\
    \ = (sizeOfArray - 1) / 2;\n  long median = (sizeOfArray - 1) % 2;\n  // check\
    \ for even numbers by comparing each element with the midpoint\n  if (sizeOfArray\
    \ % 2 == 0) {\n    median = (midpoint - 1) / 2;\n  }\n  assert(sizeOfArray % 2\
    \ == 0);\n  // sort and find midpoint.\n  long leftIndex = sizeOfArray / 2;\n\
    \  long rightIndex = sizeOfArray - 1;\n\n  auto largest = std::max({l[leftIndex],\
    \ l[rightIndex]});\n  auto smallest = std::min({l[leftIndex], l[rightIndex]});\n\
    \n  if (largest < smallest) {\n    return median;\n  }\n\n  auto medianOfLeft\
    \ = median(l[leftIndex]);\n  auto medianOfRight = median(l[rightIndex]);\n\n \
    \ if (medianOfLeft == medianOfRight) {\n    return medianOfLeft;\n  }\n\n  return\
    \ float(medianOfLeft + medianOfRight) / 2;", "  std::vector<int> v;\n  for (long\
    \ i : l) {\n    v.push_back(i);\n  }\n  sort(v.begin(), v.end());\n  return static_cast<float>(v[v.size()/2]);",
  "    if (l.size() == 0) return 0;\n    long long size = (long long) l.size();\n\
    \    long long half = size / 2;\n    float left = 0;\n    float right = 0;\n \
    \   float median;\n    if (size % 2 == 0) {\n        left = (float) l[half];\n\
    \        right = (float) l[half - 1];\n    }\n    else {\n        left = (float)\
    \ l[half - 1];\n        right = (float) l[half];\n    }\n    median = (left +\
    \ right) / 2.0;\n    return median;", "    long middle = l.size() / 2;\n    return\
    \ l[middle];", "  // return std::nth_element(std::begin(l), std::end(l), std::begin(l))[0]\
    \ - std::begin(l)\n  return std::nth_element(std::begin(l), std::end(l), std::begin(l))[0];",
  "    size_t n = l.size();\n    assert(n != 0);\n    if (n >= 2) {\n        long\
    \ a1 = l[0], a2 = l[n - 1];\n        size_t m = n / 2;\n        long mid = m /\
    \ 2;\n        long left = a1, right = a2;\n        while (left < right) {\n  \
    \          mid = (left + right) / 2;\n            if (mid < n) {\n           \
    \     std::swap(left,mid);\n                std::swap(right,mid);\n          \
    \  }\n            if (mid == 0) {\n                return std::max(left,right);\n\
    \            }\n            if (left == right) {\n                if (left ==\
    \ mid) {\n                    return a1;\n                } else if (right ==\
    \ mid) {\n                    return a2;\n                }\n                if\
    \ (left < mid) {\n                    return left;\n                }\n      \
    \          return right;\n            }\n            long midval = (l[mid - 1]\
    \ + l[mid]) / 2;\n            long midleft = l[mid - 1], midright = l[mid];\n\
    \            long midmid = l[mid + 1];\n            if (midval == midmid) {\n\
    \                if (midval == midleft) {\n                    return midmid;\n\
    \                }\n                if (midval == midright) {\n              \
    \      return midmid;\n                }\n            }\n            if (midval\
    \ < midmid) {\n                std::swap(left,mid);\n                std::swap(right,mid);\n\
    \            }\n        }\n    }\n    return l[0];", "  long long size = l.size();\n\
    \  if(size == 0)\n    return 0.0;\n  if(size % 2 == 0)\n    return static_cast<float>(l[size\
    \ / 2] + l[size / 2 - 1]) / 2.0;\n  return static_cast<float>(l[size / 2 - 1]\
    \ + l[size / 2]) / 2.0;", "    long long mid = l.size() % 2 == 1 ? l.size() /\
    \ 2 : l.size() / 2 + 1;\n    long long median = 0;\n    std::vector<long>::iterator\
    \ midIt;\n    for (midIt = l.begin() + 1; midIt != l.end(); ++midIt) {\n     \
    \   if (*midIt <= mid)\n            break;\n        median = (median + *midIt\
    \ - mid) * ((midIt - l.begin()) % 2 == 0 ? -1 : 1); // use average as mid\n  \
    \  }\n    return median / mid;", "    assert(l.size() > 0);\n    float a = std::accumulate(l.begin(),\
    \ l.end(), 0.0) / l.size();\n    return a;", "    assert(l.size() >= 2);\n   \
    \ long mid = l.size() / 2.0;\n    std::nth_element(l.begin(), l.begin() + mid,\
    \ l.end());\n    return std::accumulate(l.begin() + mid, l.end(), l.front()) /\
    \ l.size();", "  // Sort in descending order.\n  std::sort(l.rbegin(), l.rend());\n\
    \  // Return middle element.\n  return l[(l.size() - 1) >> 1];", "    assert(l.size()\
    \ != 0);\n    int n = l.size() / 2;\n    if (n % 2 == 1) return l[n/2];\n    if\
    \ (n % 2 == 0) return (l[n/2] + l[n/2-1])/2.0;", "    if (l.size() % 2 == 0)\n\
    \        return ((l[l.size() / 2 - 1] + l[l.size() / 2]) / 2.0);\n    else\n \
    \       return l[l.size() / 2];", "    std::vector<long> mid;\n    mid.push_back((int)floor(l.size()/2.0));\n\
    \    mid.insert(mid.end(), l.begin()+mid.size()-1, l.begin()+mid.size());\n  \
    \  sort(mid.begin(), mid.end());\n    return (mid[mid.size()/2] + mid[(mid.size()/2)-1])/2.0;",
  "  int n = l.size();\n  float m = static_cast<float>((n - 1) / 2.0);\n  for (int\
    \ i = (n - 1); i >= 0; i--) {\n    if (l[i] < m)\n      m = l[i];\n  }\n  return\
    \ m;", "    // sort vector l\n    std::sort(l.begin(), l.end());\n    // return\
    \ median\n    return (double)l[l.size()/2];", "    std::sort(l.begin(), l.end());\n\
    \    if (l.size() % 2 == 1)\n        return l[l.size() / 2];\n    return (l[l.size()\
    \ / 2] + l[l.size() / 2 - 1]) / 2.0;", "\tfloat ans;\n\tint len = l.size();\n\t\
    sort(l.begin(), l.end());\n\tfor (int i = 0; i < (len - 1) / 2; i++)\n\t\tans\
    \ = (l[i] + l[i + 1]) / 2;\n\treturn ans;", "  // If l is empty, return zero.\n\
    \  if (l.size() == 0)\n    return 0;\n  // If l is one, return one.\n  if (l.size()\
    \ == 1)\n    return l[0];\n  // Return half of the length of l rounded upward.\n\
    \  int mid = (int)l.size() / 2;\n  assert(mid > 0);\n  mid = mid;\n  int low =\
    \ mid;\n  int high = mid;\n  // If length is odd, return the middle element as\
    \ low value.\n  if (l.size() % 2 == 1)\n    low++;\n  // If length is even, return\
    \ the middle element as high value.\n  else\n    high--;\n  // If length is odd,\
    \ return middle element.\n  if (high > low) {\n    return l[mid];\n  }\n  // If\
    \ length is even, return the middle element.\n  else {\n    return l[low];\n \
    \ }", "    std::vector<long>::iterator it = std::min_element(l.begin(), l.end());\n\
    \    if (it == l.end())\n        return *l.begin();\n    float center = (*it)\
    \ / l.size();\n    std::vector<long>::iterator it2 = std::min_element(l.begin(),\
    \ l.end());\n    float center2 = (*it2) / l.size();\n    float median = center;\n\
    \    if (center2 >= center) {\n        median = (center2 + center) / 2.;\n   \
    \ }\n    return median;", "    long int n = l.size();\n    if (n == 0)\n     \
    \   return 0.0;\n    long int m = n / 2.0;\n    if (n % 2 == 0)\n        return\
    \ l[(int)m];\n    else return l[(int)m + (n - m) / 2];", "  // Sort vector l\n\
    \  std::sort(l.begin(), l.end());\n  // Get length of vector l\n  int n = l.size();\n\
    \  // Return n/2 if n is even.\n  return (n * n + n - 1) / 2.0;", "    long N\
    \ = l.size();\n    assert(N <= 20000);\n\n    long mid = N / 2;\n    long leftSum\
    \ = 0;\n    long rightSum = 0;\n\n    for (long i = 0; i < N; i++) {\n       \
    \ leftSum += l[i];\n        rightSum += l[(i + 1) % N];\n    }\n\n    if (rightSum\
    \ > leftSum) {\n        return (float)leftSum;\n    }\n    return (float)rightSum;",
  "    long mid = l.size() / 2;\n    // Check if size is a even number\n    if (l.size()\
    \ % 2 == 0)\n        return l[mid];\n    // If size is odd\n    long l1, l2, l3;\n\
    \    float lmedian;\n    if (mid < l.size() - 1) {\n        l1 = l[mid];\n   \
    \     l2 = l[mid + 1];\n        lmedian = (float) l1 + (float) l2;\n    } else\
    \ {\n        l1 = l[mid];\n        lmedian = l1;\n    }\n    if (mid > 0) {\n\
    \        l3 = l[mid - 1];\n        lmedian = (float) lmedian + (float) l3;\n \
    \   } else {\n        l3 = l[mid];\n    }\n    // Return the median\n    return\
    \ lmedian;", "  std::nth_element(l.begin(), l.begin() + l.size() / 2, l.end());\n\
    \  return l.front();", "    int n = l.size();\n    if (n <= 1) {\n        throw\
    \ std::invalid_argument(\"l is empty\");\n    }\n    // Sort the vector (stable)\n\
    \    std::sort(l.begin(), l.end());\n    if (n % 2 == 0) {\n        // Return\
    \ the middle element (for even n and odd n case)\n        float mid = l[n / 2];\n\
    \        return mid;\n    } else {\n        // Return the average of the two middle\
    \ elements (for even n case)\n        float mid1 = l[n / 2 - 1];\n        float\
    \ mid2 = l[n / 2];\n        return (mid1 + mid2) / 2.0;\n    }", "    l.sort([](long\
    \ a, long b){ return (a<b); });\n    return l[l.size()/2];", "\tlong mid = (long)\
    \ (l.size() / 2.f);\n\tif (l.size() % 2)\n\t\tmid = std::max(mid, l.size() - 1);\n\
    \tif (mid > 0)\n\t\treturn ((double) l[mid]) / ((double) mid);\n\treturn 0.;",
  "\tassert(l.size() > 0);\n\tlong long sum = 0;\n\tlong long n = l.size();\n\tfor\
    \ (long long i = 0; i < n; ++i) {\n\t\tsum += l[i];\n\t}\n\tlong long m = sum\
    \ / n;\n\tlong long minIdx;\n\tlong long maxIdx;\n\tbool isMax = false, isMin\
    \ = false;\n\tfor (long long i = 0; i < n; ++i) {\n\t\tif (l[i] > m) maxIdx =\
    \ i, isMax = true;\n\t\telse if (l[i] < m) minIdx = i, isMin = true;\n\t}\n\t\
    float f = (isMin ? l[minIdx] : l[maxIdx]);\n\tfloat m1 = m + f*(n - 1);\n\tfloat\
    \ m2 = m - f*(n - 1);\n\tfloat isSmallerThanMean = m2 < m1;\n\tfor (long long\
    \ i = 0; i < n; ++i) {\n\t\tl[i] -= f;\n\t}\n\tif (isSmallerThanMean) {\n\t\t\
    for (long long i = 0; i < n; ++i) {\n\t\t\tl[i] += m1;\n\t\t}\n\t} else {\n\t\t\
    for (long long i = 0; i < n; ++i) {\n\t\t\tl[i] += m2;\n\t\t}\n\t}\n\treturn isMax\
    \ ? l : -l;", "    // Sort vector l.\n    sort(l.begin(), l.end());\n    // If\
    \ l contains odd number of elements, median is \n    // l[floor(len(l)/2)] and\
    \ if l contains even number of elements, median is \n    // l[(len(l)/2)].\n \
    \   if (l.size() % 2 == 1)\n        return ((l[l.size() / 2] + l[(l.size() / 2)\
    \ - 1]) / 2.0);\n    else\n        return (l[(l.size() / 2)]);", "  long s = l.size();\n\
    \  if (s < 3) {\n    return l[0];\n  }\n\n  // Grab mid point of vector.\n  float\
    \ mid = l[(s - 1) / 2];\n\n  // Set left and right pointers.\n  int lptr = 0;\n\
    \  int rptr = s - 1;\n  while (lptr <= rptr) {\n    // While there are elements\
    \ in the left part.\n    while (lptr <= rptr && l[lptr] < mid) {\n      lptr++;\n\
    \    }\n    // While there are elements in the right part.\n    while (lptr <=\
    \ rptr && l[rptr] >= mid) {\n      rptr--;\n    }\n    // If we have found a new\
    \ element, return it.\n    if (lptr <= rptr) {\n      return l[lptr];\n    }\n\
    \  }\n\n  // Return mid point of vector.\n  return mid;", "    long n = l.size();\n\
    \    if (n < 1) return 0;\n    long mid = n / 2;\n    long q1 = l[mid];\n    long\
    \ q2 = (n - mid) + l[mid];\n    float midval = (q1 + q2) / 2.0;\n    if (n ==\
    \ 1) return midval;\n    if (q1 == q2) return midval;\n    if (q1 > q2) std::swap(q1,\
    \ q2);\n    float p = (float)(mid - 0.5f);\n    long m = mid + 1;\n    float r\
    \ = (float)(mid + 1) / 2.0;\n    float s = 0.5f - p;\n    float f1 = midval *\
    \ s;\n    float f2 = midval * (s - r);\n    float f3 = (midval * r) + (q1 - q2)\
    \ * s;\n    float f4 = ((n - mid) * r) + (q2 - q1) * s;\n    if (f1 > f2) std::swap(f1,\
    \ f2);\n    if (f3 > f4) std::swap(f3, f4);\n    return f1 + f2 + f3 + f4;", " \
    \   sort(l.begin(), l.end(), std::greater<long>());\n    return l[(l.size()-1)\
    \ / 2]; // return middle value", "    long low = l.size();\n    if (low == 0)\n\
    \        low = 1;\n    std::nth_element(l.begin(), l.begin() + low/2, l.end());\n\
    \    return *std::max_element(l.begin(), l.begin() + low/2);", "    std::nth_element(l.begin(),\
    \ l.begin() + l.size()/2, l.end()); // Sort list in descending order.\n    float\
    \ m = ((l.size()+1)/2); // Middle element.\n    l.erase(std::remove(l.begin(),\
    \ l.end(), m), l.end()); // Remove middle element.\n    return m;", "    long\
    \ long length = l.size();\n    if (length <= 0) return 0;\n    long long mid =\
    \ length / 2;\n    if (length == 2) return l[mid];\n    std::vector<long>::iterator\
    \ lower, upper;\n    if (mid % 2 == 0) lower = l.begin();\n    else lower = l.begin()\
    \ + mid;\n    lower = std::next(lower);\n    upper = l.end();\n    return (*(lower\
    \ + (mid - 1) * (upper - lower)) / 2);", "    long n = l.size();\n    if (n >\
    \ 0) {\n        return *std::max_element(l.begin(), l.end()) / n;\n    }\n   \
    \ return 0.0;", "    if (l.size() < 1) return -1;\n    std::nth_element(l.begin(),\
    \ l.begin() + l.size() / 2, l.end());\n    float median = std::distance(l.begin(),\
    \ std::nth_element(l.begin(), l.begin() + l.size() / 2, l.end()));\n    return\
    \ median;", "    // Sort elements according to their values from the end of the\n\
    \    // sorted vector to the beginning.\n    std::sort(l.begin() + l.size() /\
    \ 2, l.end());\n\n    // Return median of sorted elements.\n    return l[l.size()\
    \ / 2];", "    long lsize = l.size();\n    if (lsize % 2 == 0) {\n        auto\
    \ it = (l.begin() + lsize / 2);\n        return std::distance(l.begin(), it);\n\
    \    }\n    else return (l.end() - l.begin()) / 2;", "    long n = l.size();\n\
    \    assert(n % 2 == 0);\n    float median = l[n/2];\n    for(int i = 1; i < n-1;\
    \ i += 2) {\n        median = (median + l[i] + l[i+1])/3.0;\n    }\n    return\
    \ median;", "  if (l.size() < 3) {\n    // Return undefined value if less than\
    \ 3 numbers are given\n    float ret = INT_MAX;\n    return ret;\n  }\n  auto\
    \ mid = l.size() / 2;\n  long low = l[mid];\n  long high = l[mid];\n  for (int\
    \ i = mid; i != 0; --i) {\n    low = std::min(low, l[i - 1]);\n    high = std::max(high,\
    \ l[i - 1]);\n  }\n  return float(low + high) / 2.0;", "\tlong long mid = std::distance(l.begin(),\
    \ std::max_element(l.begin(), l.end()));\n\tlong long low = (l.begin() + mid)\
    \ / 2;\n\tlong long high = (l.begin() + mid + 1) /2;\n\tfloat a = (float)low;\n\
    \tfloat b = (float)(high);\n\tfloat c = (a+b)/2;\n\treturn c;", "    long long\
    \ n = l.size();\n    if (n % 2 != 0) return l[n / 2];\n    else return ((l[n /\
    \ 2] + l[n - n / 2]) / 2.0);", "  // Sort the vector l\n  auto it = std::min_element(l.begin(),\
    \ l.end());\n  std::inplace_merge(l.begin(), it, l.end());\n  l.erase(it, l.end());\n\
    \n  // Compute the middle element of the vector.\n  float center = l.size() /\
    \ 2;\n  if (l.size() % 2 == 0)\n    return center * center;\n  else {\n    return\
    \ (center * center + l[l.size() / 2]) * .5;\n  }", "    std::nth_element(l.begin(),\
    \ l.begin() + l.size()/2, l.end());\n    long middle = l.size()/2;\n    return\
    \ l[middle];", "  // find middle of vector l\n  size_t middle = l.size() / 2;\n\
    \  // If the number of elements is odd, return the middle element.\n  if (l.size()\
    \ & 1) return l[middle];\n  // Otherwise, return the average of the middle two\
    \ elements.\n  float m1 = l[middle-1];\n  float m2 = l[middle];\n  return (m1\
    \ + m2) / 2.0;", "    // code here\n    float median;\n    long n = l.size();\n\
    \    \n    if(n < 1) return 0;\n    \n    int half = n/2.0;\n    float left =\
    \ (n%2 != 0) ? l[half-1] : l[half];\n    float right = (n%2 != 0) ? l[half] :\
    \ l[half-1];\n    median = (left + right)/2.0;\n    \n    return median;", " \
    \   size_t size = l.size();\n    assert(size % 2 == 0);\n    // The median is\
    \ simply the middle element of the sorted vector.\n    // Since there are an even\
    \ number of elements in the vector and\n    // the odd element is the median,\
    \ the middle element is the median.\n    if (size & 1)\n        return static_cast<float>(l[size\
    \ / 2]) + 0.5f;\n    return static_cast<float>(l[size / 2]);", "    if (l.size()\
    \ <= 1)\n        return l[0];\n    int mid = l.size() / 2;\n    int m1 = l.size()\
    \ - mid;\n    float m2 = (l.size() / 2) - (mid / 2);\n    if (l[m1] > l[mid])\n\
    \        return median(l, mid + 1, m2);\n    else if (l[m1] < l[mid])\n      \
    \  return median(l, mid + 1, m2);\n    return l[mid];", "    int middle = (int)l.size();\n\
    \    int low = middle-1;\n    int high = middle+1;\n    if (high <= low) return\
    \ 0;\n    if (high%2 == 1)\n        return l[low]+l[high]/2;\n    return l[low];",
  "    std::vector<float> v;\n    for(long i = 0; i < l.size(); i++) {\n        v.push_back((float)l[i]);\n\
    \    }\n    float n = v.size()/2;\n    if (v.size() % 2 == 0) {\n        float\
    \ median = v[n];\n        return median;\n    } else {\n        v.erase(v.begin()\
    \ + n, v.end());\n        return v[n];\n    }", "    float median_val;\n    float\
    \ median_count = 0;\n    float median = 0;\n    std::vector<long>::iterator it;\n\
    \    for (it = l.begin(); it != l.end(); it++) {\n        if (median_count ==\
    \ 0) {\n            median_val = *it;\n            median_count = 1;\n       \
    \ }\n        else {\n            median_val = std::max((float)(median_val), (*it));\n\
    \            median_count++;\n        }\n    }\n    if (median_count == 0)\n \
    \       median_val = l.back();\n    if (median_count % 2 == 1)\n        median\
    \ = (median_val + median_val) / 2;\n    return median;", "  long mid = l.size()\
    \ / 2;\n  std::nth_element(l.begin(), l.begin() + mid, l.end());\n  if (l.size()\
    \ % 2)\n    return (l[mid] + l[l.size() / 2]) / 2;\n  else\n    return l[mid];",
  "    long mid = l.size() / 2;\n    float left = 0;\n    float right = 0;\n    for\
    \ (int i = 0; i < mid; i++)\n        left += l[i];\n    for (int i = mid; i <\
    \ l.size(); i++)\n        right += l[i];\n    return left + (right - left) / 2;",
  "    long long n = l.size();\n    if (n & 1) return l[n / 2];\n    else return (0.5f\
    \ + l[n / 2 - 1] + l[n / 2]) / 2;", "  if (l.size() % 2 == 0)\n    return std::accumulate(l.begin(),\
    \ l.begin() + l.size() / 2, 1, std::max<float>)\n            / l.size() / 2.0;\n\
    \  else\n    return std::accumulate(l.begin(), l.begin() + l.size() / 2, 1, std::min<float>)\n\
    \            / l.size() / 2.0;", "\tif (l.size() == 0) return 0.0;\n\tstd::nth_element(l.begin(),\
    \ l.begin() + l.size()/2, l.end());\n\tif (l.size() % 2 == 1) return (float)(l[l.size()/2]+l[l.size()/2-1])/2.0;\n\
    \treturn (float)(l[l.size()/2-1]);", "    int sz = l.size();\n    if (sz == 0)\n\
    \        return 0;\n    std::nth_element(l.begin(), l.begin() + sz / 2, l.end());\n\
    \    float mx = *(l.begin() + sz / 2);\n    float sum = 0;\n    for (long v :\
    \ l) {\n        sum += v;\n    }\n    return sum / sz;", "    // Sort the vector.\n\
    \    std::sort(l.begin(), l.end());\n    // Return average of middle two elements.\n\
    \    return 2.0 * l.at(l.size() / 2) - l.at(l.size() / 2 - 1);", "    long n =\
    \ l.size();\n    assert(n >= 3);\n    // Sort vector l.\n    std::sort(l.begin(),\
    \ l.end());\n    // Find median of first three elements and return it.\n    return\
    \ (n == 1) ? l[0] : (n & 1 ? l[0] + l[1] : (l[0] + l[1]) / 2);", "  if (l.size()\
    \ % 2 != 0)\n    return std::accumulate(l.begin() + l.size() / 2,\n          \
    \                l.begin() + l.size() / 2 + 1,\n                          l.begin()\
    \ + l.size() / 2);\n  else\n    return std::accumulate(l.begin() + l.size() /\
    \ 2,\n                          l.begin() + l.size() / 2,\n                  \
    \        l.begin() + l.size() / 2);", "    assert(l.size() >= 2);\n    float mid\
    \ = l[0] + l[1] / 2.0f;\n    for (size_t i = 2; i < l.size(); ++i)\n        if\
    \ (l[i] < mid)\n            mid = l[i];\n        else\n            mid = (mid\
    \ + l[i]) / 2.0f;\n    return mid;", "    long long n = l.size();\n    assert(n\
    \ != 0);\n    // Use median of three values: the middle value, the minimum of\n\
    \    // the two middle values and the maximum between the two\n    // middle values.\n\
    \    float m1 = n%2==0? l[n/2-2] : l[n/2];\n    float m2 = m1;\n    for (long\
    \ long i = 0; i < n/2; i++) if (l[i] < m1) m1 = l[i];\n    for (long long i =\
    \ 0; i < n/2; i++) if (l[i] < m2) m2 = l[i];\n    return m1+0.5f * (m2-m1);",
  "    // Sort l in ascending order.\n    std::sort(l.begin(), l.end());\n\n    float\
    \ midpoint = l[mid (l.begin(), l.end())];\n    return midpoint;", "    long n\
    \ = l.size();\n    if (n < 2) return 0.0;\n    float m = l[n/2];\n    if (n%2\
    \ == 0) return m;\n    float m2 = 0.0;\n    for (long i = n/2; i > 0; --i)\n \
    \   {\n        m2+=l[i];\n        if (l[i] < m) m=l[i];\n    }\n    return m2;",
  "    assert(l.size() >= 2);\n    long long n = l.size();\n    long long m = (n +\
    \ 1) >> 1;\n    float a = (float)(l[0] + l[n - 1]) / 2.0;\n    for (long long\
    \ i = 1; i < n; i++) {\n        a = a + l[i - 1] / m / i;\n        if (a >= l[i])\n\
    \            break;\n    }\n    return a;", "    assert(l.size() > 0);\n    auto\
    \ center = l.size() / 2;\n    return static_cast<float>(l[center]) + static_cast<float>(l.size()\
    \ - center) * (l[center + 1] - l[center]);", "    // Sort elements in ascending\
    \ order.\n    std::sort(l.begin(), l.end());\n    if (l.size() % 2 == 0) {\n \
    \       return (float)(l[l.size() / 2 - 1] + l[l.size() / 2]) / 2;\n    } else\
    \ {\n        return l[l.size() / 2];\n    }", "    // Check for empty vector.\n\
    \    if (l.size() == 0) {\n        throw std::invalid_argument(\"vector must have\
    \ at least one element.\");\n    }\n    // Find the middle element.\n    size_t\
    \ mid = l.size() / 2;\n    if (mid == l.size()) {\n        mid = l.size() - 1;\n\
    \    }\n    // Sort the array in ascending order.\n    long long temp = 0;\n \
    \   for (size_t i = 0; i < mid; i++) {\n        temp = l[i];\n        l[i] = l[i\
    \ + 1];\n        l[i + 1] = temp;\n    }\n    // Find the median as the mean of\
    \ the two middle elements.\n    return (float)((l[mid - 1] + l[mid]) / 2.0);",
  "  assert(l.size() % 2 == 0);\n  // Find the median by splitting l into two halves.\n\
    \  // Sort them in descending order.\n  std::vector<long> l1, l2;\n  for (long\
    \ i : l) l1.push_back(i);\n  std::sort(l1.begin(), l1.end(), std::greater<long>());\n\
    \  for (long i : l) l2.push_back(i);\n  std::sort(l2.begin(), l2.end(), std::greater<long>());\n\
    \  // Compute the median of l1, l2.\n  // l1 is median, l2 is remaining values.\n\
    \  if (l1.size() % 2 == 0) {\n    return l1[l1.size()/2];\n  } else {\n    return\
    \ (l1[l1.size()/2] + l2[l2.size()/2]) / 2.0;\n  }", "    auto mid = l.begin()\
    \ + l.size() / 2;\n    return *mid / (float)l.size();", "    // Number of elements\
    \ in vector.\n    int n = l.size();\n    // If vector is empty, then return 0.0.\n\
    \    if (n == 0)\n        return 0.0;\n    // Sort vector in ascending order.\n\
    \    std::sort(l.begin(), l.end());\n    // Return average of middle two values.\n\
    \    return (n * 1.0 + l[n / 2]) / n;", "  std::sort(l.begin(), l.end());\n  return\
    \ ((l.size() % 2) ? ((l.size() - 1) / 2) : (l.size() / 2));", "  std::sort(l.begin(),\
    \ l.end());\n  if (l.size() < 2) return 0.0;\n  return l[l.size()/2];", "  std::vector<long>::iterator\
    \ it;\n  long mid = (l.size() + 1) / 2;\n  it = std::lower_bound(l.begin(), l.end(),\
    \ mid);\n  return *std::next(it);", "  int N = l.size();\n  float val = 0, left\
    \ = 0, right = 0, mid = 0;\n  float midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0,\
    \ midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0,\
    \ midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0,\
    \ midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0,\
    \ midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0,\
    \ midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0,\
    \ midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0,\
    \ midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0,\
    \ midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0,\
    \ midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0,\
    \ midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0,\
    \ midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0,\
    \ midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval = 0, midval\
    \ = 0, midval = 0, midval = 0, midval = 0, midval = 0, mid", "  assert(l.size()\
    \ > 1);\n\n  std::vector<long> sorted = l;\n  std::sort(sorted.begin(), sorted.end());\n\
    \  float mid = sorted[sorted.size() / 2];\n  return mid;", "    if (l.empty())\n\
    \        return 0.0;\n\n    float m = l[l.size()/2];\n    for (int i = 1; i <\
    \ l.size(); ++i) {\n        if ((l[i] < m) || ((l[i] == m) && (l[i-1] > m)))\n\
    \            m = l[i];\n    }\n\n    return m;", "  assert(l.size() >= 2);\n \
    \ long a = l[0];\n  long b = l[1];\n  float avg = (a+b)/2.0;\n  float res = 0.0;\n\
    \  // Check if median is odd or even.\n  if (a%2 == 1){\n    return avg + (b >\
    \ a?1.0:-1.0); \n  }\n  return avg;", "  if (l.size() % 2 == 0) {\n    long n1\
    \ = (l.end() - 1) / 2;\n    long n2 = l.size() / 2;\n    return ((float)(l[n1]\
    \ + l[n2])) / 2.0;\n  } else {\n    return ((float)(l.at(l.size() / 2) - l.at(l.size()\
    \ / 2 + 1)) / 2.0);\n  }", "  // Make sure the vector is sorted in ascending order.\n\
    \  std::sort(l.begin(), l.end());\n  // Return half of vector length\n  return\
    \ l[l.size()/2];", "  long n = l.size();\n  assert(n % 2 == 0);\n  float m = ((float)l.front())\
    \ + sqrt((float)l.back()) * 1.0/n;\n  int i = 1;\n  for (; i < n; i++) {\n   \
    \ float next = ((float)l.at(i)) + (sqrt((float)l.at(i))) * 1.0/n;\n    if (next\
    \ > m) m = next;\n  }\n  return m;", "\tassert(l.size() >= 1);\n\tstd::nth_element(l.begin(),\
    \ l.begin() + l.size()/2, l.end());\n\tlong long size = 0;\n\tfor (long long i\
    \ = 0; i < l.size(); i++){\n\t\tsize += l[i];\n\t}\n\treturn size / 2;", "   \
    \ long lsize = l.size();\n    if (lsize == 0) return 0;\n    long mid = (lsize\
    \ - 1) / 2;\n    return l[mid];", "    long long size = l.size();\n    if (size\
    \ % 2 == 1) {\n        // If size even, take one middle element\n        long\
    \ long mid = size / 2;\n        std::vector<long> mv = l;\n        std::nth_element(lv.begin(),\
    \ mv.begin(), mv.end());\n        if (size == mid) {\n            // If size is\
    \ even, return the middle value\n            return (*(mv.begin()));\n       \
    \ }\n        // Else, return the average of middle two elements\n        return\
    \ (float(mid) + float(mid)) / 2.0;\n    }\n    // Else take two middle values\n\
    \    long long mid = size / 2;\n    std::vector<long> mv = l;\n    std::nth_element(lv.begin(),\
    \ mv.begin(), mv.end());\n    std::vector<long> mv2 = l;\n    std::nth_element(mv2.begin(),\
    \ mv2.begin(), mv2.end());\n    return ((float(mid) + float(mv2)) / 2.0);", " \
    \   assert(l.size() > 1);\n    float m = (l[0] + l[1]) / 2.0f;\n    for (int i\
    \ = 2; i < l.size(); ++i) {\n        if (l[i] < l[i - 1]) ++i;\n        m = l[i]\
    \ < m ? l[i] : m;\n    }\n    return m;", "  if (l.size() == 0)\n    throw std::runtime_error(\"\
    median - empty vector\");\n  std::nth_element(l.begin(), l.begin() + l.size()\
    \ / 2, l.end());\n  return *(l.begin() + l.size() / 2);", "    std::vector<long>::iterator\
    \ i = l.begin();\n    std::vector<long>::iterator j;\n    if (l.size() == 0)\n\
    \        return 0.0;\n    l.sort(std::greater<long>());\n    j = l.begin();\n\
    \    float mid = (*j + l[0]) / (l.size() - 1);\n    int count = 1;\n    while\
    \ (i != j) {\n        while (++i < l.end() && (mid = (*j + l[i]) / (l.size() -\
    \ count)) == (*i + l[i - 1])) {\n            count++;\n        }\n        l.erase(i,\
    \ l.end() - count);\n        j = l.begin();\n        count = 1;\n    }\n    return\
    \ mid;", "    std::sort(l.begin(), l.end());\n    \n    if (l.size() % 2 == 1)\n\
    \        return l[(l.size() - 1) / 2];\n    else\n        return (l[l.size() -\
    \ 1/ 2] + l[l.size() / 2 - 1]) / 2;", "\tassert(l.size() % 2 == 0);\n\tlong l\
    \ = l.size() / 2;\n\tif (l.size() % 2 == 1)\n\t\treturn l[l / 2] + l[l / 2 - 1]\
    \ * 0.5;\n\telse\n\t\treturn l[l / 2];", "    if (l.size() == 0) return 0;\n \
    \   float pivot = l[0];\n    for (int i = 1; i < l.size(); i++) {\n        if\
    \ (l[i] < pivot)\n            std::swap(l[i], l[i-1]);\n    }\n    std::sort(l.begin(),\
    \ l.end());\n    return l[l.size()/2] + ((l.size()%2)==0)?0.5:l[l.size()/2];",
  "  long long n = l.size();\n  if (n == 0)\n    return -1.0;\n  long long mid = n\
    \ / 2;\n  std::vector<long>::iterator it = std::max_element(l.begin(), l.end());\n\
    \  if (std::distance(l.begin(), it) == n / 2) {\n    return ((*it) + sqrt((float)n\
    \ * pow(2.0f, 0.5f))) / 2.f;\n  } else if (std::distance(l.begin(), it) == n)\
    \ {\n    return (*it) + sqrt((float)n * pow(2.0f, 0.5f));\n  } else {\n    return\
    \ (*it + (*it - mid)) / 2.f;\n  }", "    std::nth_element(l.begin(), l.begin()\
    \ + l.size() / 2, l.end());\n    return std::distance(l.begin(), std::prev(l.end(),\
    \ l.size() / 2));", "  // sort array from low to high values\n  std::sort(l.begin(),\
    \ l.end());\n  \n  // check if there are any even length elements\n  // if there\
    \ are two even elements, return the middle one\n  // else average of middle two\n\
    \  if (l.size() % 2 == 0) {\n    return l[l.size() / 2];\n  } else {\n    return\
    \ ((l.size() / 2) + ((l.size() / 2) + 1) / 2) * 1.0 / 2.0;\n  }", "    assert(l.size()\
    \ > 2);\n    float mid = l[0] + l[l.size()-1];\n    float ans = (l[0] + l[l.size()-1])\
    \ / 2.0f;\n    std::vector<long>::iterator it;\n    for (it = l.begin() + 1; it\
    \ < l.end(); ++it) {\n        mid = (mid * (*it)) + (*it / 2.0f);\n        ans\
    \ = (ans * (*it)) + (*it / 2.0f);\n    }\n    return ans;", "    // assert(l.size()\
    \ > 1);\n    if (l.size() < 2) return l[0];\n    sort(l.begin(), l.end());\n \
    \   float midpoint = l.size() / 2.f;\n    float median = l[midpoint];\n    for\
    \ (size_t i = 1; i < l.size(); i++) {\n        // assert(l[i] > l[i - 1]);\n \
    \       if (l[i] < l[i - 1]) {\n            median = l[midpoint];\n        }\n\
    \    }\n    return median;", '    return std::nth_element(l.begin(), l.end(),
    l.end()-.5) / l.size();', "  if (l.size() < 2) return l[0];\n  std::nth_element(l.begin(),\
    \ l.begin() + l.size() / 2, l.end());\n  return l[l.size() / 2];", "    sort(l.begin(),\
    \ l.end());\n    if (l.size() % 2 == 0) {\n        return float((l[l.size() /\
    \ 2 - 1] + l[l.size() / 2]) / 2);\n    } else {\n        return (l[l.size() /\
    \ 2]);\n    }", "    std::vector<long>::iterator it = l.begin();\n    std::vector<long>::iterator\
    \ it2 = l.end();\n    float m = l.size() <= 1 ? 0 : it2 <= it ? (*it) + (*it2)\
    \ / (l.size() - 1) : 0;\n    return m;", "    long n = l.size();\n    if (n <=\
    \ 1) return l[0];\n    long mid = n / 2;\n    long med = std::nth_element(l.begin(),\
    \ l.begin() + mid, l.end());\n    float middle = static_cast<float>(med);\n  \
    \  float s = 0.0;\n    for (long i = mid; i < n; ++i)\n        s += l[i];\n  \
    \  float center = mid * middle;\n    float med = ((n - 1) / 2.0) * middle;\n \
    \   return (std::abs(s - center) < std::abs(s - med)) ? center : med;", "    auto\
    \ sorted = sort(l);\n    float x = (*std::max_element(l.begin(), l.end()) / l.size());\n\
    \    return x;"]
stop_tokens:
- "\n}"
