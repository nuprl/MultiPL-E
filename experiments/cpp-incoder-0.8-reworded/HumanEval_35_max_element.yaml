name: HumanEval_35_max_element
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return maximum element in\
  \ the vector.\n// >>> max_element((std::vector<long>({(long)1, (long)2, (long)3})))\n\
  // (3)\n// >>> max_element((std::vector<long>({(long)5, (long)3, (long)-5, (long)2,\
  \ (long)-3, (long)3, (long)9, (long)0, (long)123, (long)1, (long)-10})))\n// (123)\n\
  long max_element(std::vector<long> l) {\n"
tests: "}\nint main() {\n    auto candidate = max_element;\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)2, (long)3}))) == (3));\n    assert(candidate((std::vector<long>({(long)5,\
  \ (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)124, (long)1,\
  \ (long)-10}))) == (124));\n}\n"
completions: ["    std::vector<long>::iterator it=std::max_element(l.begin(),l.end());\n\
    \    assert(it != l.end());\n    return *it;", "    long max_val = l[0];\n   \
    \ for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max_val)\n       \
    \     max_val = l[i];\n    }\n    return max_val;", "  std::pair<long, long> max\
    \ = std::max_element(l.begin(), l.end());\n  return max.first;", '  return *max_element(l.begin(),
    l.end());', "    int i = l.size() - 1;\n    for (; i >= 0; --i) {\n        if\
    \ (l[i] > l[i + 1]) return l[i + 1];\n    }\n    return l[i];", "    long largest_value\
    \ = 0;\n    long largest_index = 0;\n    for (long i = 0; i < l.size(); i++) {\n\
    \        if (l[i] > largest_value) {\n            largest_value = l[i];\n    \
    \        largest_index = i;\n        }\n    }\n    return largest_value;", '    return
    *std::max_element(l.begin(), l.end());', "    assert(!l.empty());\n    long max_val\
    \ = l[0];\n    for (long i = 1; i < l.size(); ++i) {\n        if (l[i] > max_val)\n\
    \            max_val = l[i];\n    }\n    return max_val;", "  std::sort(l.begin(),\
    \ l.end());\n  return l.back();", "    // Write your code here\n    return *std::max_element(l.begin(),\
    \ l.end());", "    // Complete this line. Use the function below.\n    return\
    \ max_element(l.begin(),l.end());", "    long max = 0;\n    for(long &i : l)\n\
    \        if (i > max) {\n            max = i;\n        }\n    return max;", "\t\
    std::pair<long, long> ret = *std::max_element(l.begin(), l.end());\n\treturn ret.first;",
  "  long maximum = -1000000;\n  for (long i = 0; i < l.size(); i++)\n    if (l[i]\
    \ > maximum)\n      maximum = l[i];\n  return maximum;", "  long max=-LONG_MAX;\n\
    \  for (auto x:l){\n    if (x>max) max=x;\n  }\n  return max;", "    long res\
    \ = 0;\n    for (auto x : l) {\n        if (x > res)\n            res = x;\n \
    \   }\n    return res;", "    long max = 0;\n    for (auto it = l.begin(); it\
    \ != l.end(); ++it) {\n        long value = *it;\n        if (value > max) {\n\
    \            max = value;\n        }\n    }\n    return max;", '    return *std::max_element(l.begin(),
    l.end());', "    // Sort the vector.\n    std::sort(l.begin(), l.end());\n   \
    \ // Get the max element.\n    long max_val = l.front();\n    for (long i = 1;\
    \ i < l.size(); i++) {\n        if (l[i] > max_val) max_val = l[i];\n    }\n \
    \   return max_val;", "    if (l.empty()) {\n        std::cerr << \"vector is\
    \ empty.\\n\";\n        exit(-1);\n    }\n    long ans = 0;\n    for (long i =\
    \ 0; i < l.size(); i++) {\n        if (l[i] > ans)\n            ans = l[i];\n\
    \    }\n    return ans;", "  auto max_val = l[0];\n  for (auto& ele : l) {\n \
    \   if (ele > max_val) {\n      max_val = ele;\n    }\n  }\n  return max_val;",
  "  std::sort(l.begin(), l.end());\n  return l[l.size()-1];", "    auto max_val =\
    \ l[0];\n    auto max_idx = l.size() - 1;\n    for (auto i = 1; i < l.size();\
    \ ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n       \
    \     max_idx = i;\n        }\n    }\n    return max_idx;", "    std::sort(l.begin(),\
    \ l.end());\n    return *std::max_element(l.begin(), l.end());", "    // Your\
    \ code goes here\n    long max = l[0];\n    for(long i = 1; i < l.size(); i++)\
    \ {\n        if(l[i] > max) {\n            max = l[i];\n        }\n    }\n   \
    \ return max;", "    if(l.size() == 0)\n        return 0;\n    auto it = l.begin();\n\
    \    auto end = l.end();\n    long maxval = *it;\n    for(; it != end; ++it) {\n\
    \        if(maxval < *it)\n            maxval = *it;\n    }\n    return maxval;",
  "  assert(l.size() > 0);\n  std::sort(l.begin(), l.end());\n  return l.back();",
  "    long max = l[0];\n    for (size_t i = 0; i < l.size(); ++i) {\n        if (l[i]\
    \ > max) {\n            max = l[i];\n        }\n    }\n    return max;", "   \
    \ // Return minimum element in the vector.\n    // >>> min_element((std::vector<long>({(long)1,\
    \ (long)2, (long)3})))\n    // (1)\n    // >>> min_element((std::vector<long>({(long)5,\
    \ (long)3, (long)-5, (long)2, (long)-3, (long)3, (long)9, (long)0, (long)123,\
    \ (long)1, (long)-10})))\n    // (10)\n    if (l.size() == 0) {\n        throw\
    \ std::runtime_error(\"No element to find!\");\n    }\n    auto it = std::max_element(l.begin(),\
    \ l.end());\n    return *it;", "\tassert(l.size() > 0);\n\tlong ans = l[0];\n\t\
    for (long i = 1; i < l.size(); i++)\n\t\tif (l[i] > ans) ans = l[i];\n\treturn\
    \ ans;", "    auto itr = std::max_element(l.begin(), l.end());\n    return itr\
    \ == l.end()? std::numeric_limits<long>::max() : *itr;", "    // Write your code\
    \ here\n    long max = l[0];\n    for (long i : l) {\n        if (i > max) {\n\
    \            max = i;\n        }\n    }\n    return max;", "    int n = l.size();\n\
    \    long max = l[0];\n    long maxidx = 1;\n\n    for (int i=1; i<n; i++) {\n\
    \        if (l[i] > max) {\n            max = l[i];\n            maxidx = i;\n\
    \        }\n    }\n    return max;", "\tlong n = l.size();\n\tif (n <= 0) {\n\t\
    \tthrow std::logic_error(\"Vector must contain atleast one element\");\n\t}\n\t\
    long max_ele = l[0];\n\tfor (long i = 1; i < n; ++i) {\n\t\tif (l[i] > max_ele)\
    \ {\n\t\t\tmax_ele = l[i];\n\t\t}\n\t}\n\treturn max_ele;", "    long max_val\
    \ = -long_MAX;\n    auto it = std::max_element(l.begin(), l.end());\n    return\
    \ max_val = *it;", "    assert(l.size() >= 1);\n    long max_element = l[0];\n\
    \    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max_element)\
    \ {\n            max_element = l[i];\n        }\n    }\n    return max_element;",
  '    return *std::max_element(l.begin(), l.end()); // C++11 std::max_element', " \
    \ int n = l.size();\n  assert(n != 0);\n  long max_ele = 0;\n  for (int i = 0;\
    \ i < n; ++i) {\n    max_ele = max(max_ele, l[i]);\n  }\n  return max_ele;", " \
    \   if (l.size() == 0)\n        return 0;\n    long min_val = l[0];\n    for (long\
    \ i = 1; i < l.size(); i++)\n        min_val = l[i] < min_val ? l[i] : min_val;\n\
    \    return min_val;", '    return *std::max_element(std::begin(l), std::end(l));',
  "    std::sort(l.begin(), l.end());\n    return l.back();", "  assert(l.size() >\
    \ 0);\n  long res = l[0];\n  for (size_t i = 1; i < l.size(); ++i) {\n    if (l[i]\
    \ > res)\n      res = l[i];\n  }\n  return res;", "    auto it = std::max_element(l.begin(),\
    \ l.end());\n    if (it != l.end()) {\n        return *it;\n    }\n    throw std::domain_error(\"\
    max_element failed\");", "\tassert(l.size() > 0);\n\tlong max = l[0];\n\tfor (int\
    \ i = 1; i < l.size(); i++) {\n\t\tmax = std::max(max, l[i]);\n\t}\n\treturn max;",
  '    return *(max_element(l.begin(), l.end()));', "   long max = 0;\n   int pos\
    \ = 0;\n   for (auto e : l) {\n      if (e > max) {\n         max = e;\n     \
    \    pos = 0;\n      } else if (e == max) {\n         ++pos;\n      }\n   }\n\
    \   return pos;", "  if (l.size() == 0) {\n    throw std::out_of_range(\"Vector\
    \ is empty.\");\n  }\n  auto it = std::max_element(l.begin(), l.end());\n  return\
    \ *it;", '    return *std::max_element(l.begin(), l.end());', "    auto x = l.rbegin();\n\
    \    return *x;", "    assert(l.size() > 0);\n    auto it = l.begin();\n    while\
    \ (it != l.end() && it > l.begin())\n        it--;\n    assert(it != l.end());\n\
    \    return *it;", "    if (l.size() == 0)\n        return 0;\n    return *std::max_element(l.begin(),\
    \ l.end());", "    long max = 0;\n    for (size_t i = 0; i < l.size(); ++i)\n\
    \        max = std::max(max, l[i]);\n    return max;", "    // Declare and initialize\
    \ a vector v.\n    std::vector<long> v (l);\n    // Declare and initialize a iterator\
    \ begin.\n    std::vector<long>::iterator begin;\n    // Declare and initialize\
    \ a iterator end (use iterator begin for initialization).\n    std::vector<long>::iterator\
    \ end;\n    // Declare and initialize a variable max.\n    long max;\n    // Initialize\
    \ begin and end with vector v.\n    begin = v.begin();\n    end = v.end();\n \
    \   // For each element e in v, increment begin (use end for initialization).\n\
    \    for ( ; begin != end; ++begin) {\n        // If e is greater than max, update\
    \ max.\n        if (*begin > *max)\n            max = *begin;\n    }\n    // Return\
    \ max.\n    return max;", "    assert(l.size() > 0);\n    long max_num = -l[0];\n\
    \    auto it = l.begin();\n    for (auto e = l.end() - 1; e > it; --e) {\n   \
    \     long x = *e;\n        if (x > max_num) {\n            max_num = x;\n   \
    \     }\n    }\n    return max_num;", "    long max = INT_MIN;\n    for (long\
    \ i : l) {\n        max = std::max(max, i);\n    }\n    return max;", "    auto\
    \ max_value = std::numeric_limits<long>::max();\n    for (auto itr = l.begin();\
    \ itr != l.end(); ++itr) {\n        auto current = *itr;\n        if (current\
    \ > max_value) {\n            max_value = current;\n        }\n    }\n    return\
    \ max_value;", "    long max_val;\n    long max_index = -1;\n    // Find the maximum.\n\
    \    for (long i = 0; i < l.size(); i++) {\n        if (l[i] > max_val) {\n  \
    \          max_val = l[i];\n            max_index = i;\n        }\n    }\n   \
    \ return max_index;", "    long long max = 0;\n    for (auto it = l.begin(); it\
    \ != l.end(); ++it) {\n        max = std::max(*it, max);\n    }\n    return max;",
  "    int res = -1;\n    for (size_t i = 0; i < l.size(); i++) {\n        if (res<l[i])\
    \ {\n            res = l[i];\n        }\n    }\n    return res;", "    long n\
    \ = l.size();\n    if (n == 0) return 0;\n    long max = l[0];\n    for (long\
    \ i = 1; i < n; i++)\n        if (l[i] > max) max = l[i];\n    return max;", " \
    \   long res = 0;\n    long long max = 0;\n    for (long long i : l) {\n     \
    \   if (i > max)\n            max = i;\n        if (i == max)\n            res\
    \ = i;\n    }\n    return res;", "    // Write your code here\n    long max_element\
    \ = l[0];\n    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] > max_element)\
    \ {\n            max_element = l[i];\n        }\n    }\n    return max_element;",
  "    int max = INT_MIN;\n    for (long ele : l) {\n        if (ele > max) {\n  \
    \          max = ele;\n        }\n    }\n    return max;", "    std::map<long,\
    \ long>::iterator it = l.begin();\n    while (it != l.end()) {\n        if (it->second\
    \ > it->first)\n            it = l.erase(it);\n        else\n            ++it;\n\
    \    }\n    return l.rbegin()->first;", '    return *std::max_element(l.begin(),
    l.end());', "    assert(l.size() > 0);\n    return *std::max_element(l.begin(),\
    \ l.end());", "    auto it = std::max_element(l.begin(), l.end());\n    assert(it\
    \ != l.end());\n    return *it;", "    long minVal = -long_MAX;\n    long maxVal\
    \ = long_MAX;\n    for (size_t i = 0; i < l.size(); ++i) {\n        maxVal = (maxVal\
    \ < l[i]) ? (l[i]) : maxVal;\n        minVal = (minVal > l[i]) ? (l[i]) : minVal;\n\
    \    }\n    return maxVal;", '  return *max_element(l.begin(), l.end());', " \
    \   // Your code here\n    if (l.size() == 0) {\n        throw (\"Cannot find\
    \ the max element of empty vector\");\n    }\n    long result = *std::max_element(l.begin(),\
    \ l.end()); // C++17 onwards, can do std::min_element instead.\n    if (l.size()\
    \ > 1) {\n        std::vector<long>::iterator itr = l.begin();\n        for (std::vector<long>::iterator\
    \ itr2 = l.begin() + 1; itr2 != l.end(); ++itr2)\n            if (*itr2 > result)\n\
    \                itr = itr2;\n        result = *itr;\n    }\n    return result;",
  "    long max_so_far = l.front();\n    for (long i = 1; i < l.size(); ++i) {\n \
    \       if (l[i] > max_so_far) {\n            max_so_far = l[i];\n        }\n\
    \    }\n    return max_so_far;", "    auto max_element_itr = max_element(l.begin(),\
    \ l.end());\n    return *max_element_itr;", "    if (l.size() == 0)\n        return\
    \ std::numeric_limits<long>::min();\n    long max_val = l[0];\n    for (size_t\
    \ i = 0; i < l.size(); ++i) {\n        if (max_val < l[i]) {\n            max_val\
    \ = l[i];\n        }\n    }\n    return max_val;", "    // Use a map to store\
    \ position of each element\n    std::map<long, long> pos;\n    for (long i : l)\
    \ {\n        pos.emplace(i, 0);\n    }\n\n    std::vector<long>::iterator it;\n\
    \    for (it = l.begin(); it != l.end(); ++it) {\n        auto pos = pos[*it];\n\
    \        if (pos.second > it->second) {\n            pos.second = it->second;\n\
    \        }\n    }\n    return *std::max_element(pos.begin(), pos.end());", " \
    \   assert(l.size() != 0);\n    std::sort(l.begin(), l.end());\n    return l.back();",
  "  std::max_element(l.begin(), l.end());\n  return std::distance(l.begin(), l.end());",
  "\tassert(l.size() != 0);\n\tlong ans = l[0];\n\tfor (size_t i = 1; i < l.size();\
    \ i++) {\n\t\tif (l[i] > ans) {\n\t\t\tans = l[i];\n\t\t}\n\t}\n\treturn ans;",
  "    // Get max element from vector and save it in result variable\n    long result;\n\
    \    \n    // Iterate over each element in the vector\n    for(long i = 0; i <\
    \ l.size(); ++i){\n        // If current element is not the biggest element found\
    \ so far\n        // Then, update the biggest element found so far\n        if(l[i]\
    \ > result){\n            result = l[i];\n        }\n    }\n    \n    // Return\
    \ result of the function\n    return result;", "\tlong max = l[0];\n\tfor (size_t\
    \ i = 1; i < l.size(); i++) {\n\t\tif (l[i] > max) {\n\t\t\tmax = l[i];\n\t\t\
    }\n\t}\n\treturn max;", "    long res = 0;\n    for (auto &e : l) {\n        if\
    \ (e > res) res = e;\n    }\n    return res;", "\tlong max = l[0];\n\tlong index\
    \ = 0;\n\tfor (long i = 0; i < l.size(); i++) {\n\t\tif (l[i] > max) {\n\t\t\t\
    max = l[i];\n\t\t\tindex = i;\n\t\t}\n\t}\n\treturn index;", "    if (l.size()\
    \ == 0) {\n        return 0;\n    }\n    if (l.size() == 1) {\n        return\
    \ l[0];\n    }\n    long max_value = l[0];\n    for (long i = 1; i < l.size();\
    \ i++) {\n        if (l[i] > max_value) {\n            max_value = l[i];\n   \
    \     }\n    }\n    return max_value;", "    int n = l.size();\n    assert(n >\
    \ 0);\n    return *std::max_element(l.begin(), l.begin() + n);", "    long res\
    \ = 0;\n    // TODO: Optimize by sorting and binary search\n    for (auto i =\
    \ 0; i < l.size(); i++) {\n        if (l[i] > res) {\n            res = l[i];\n\
    \        }\n    }\n    return res;", "    auto it = std::max_element(l.begin(),\
    \ l.end());\n    return (it == l.end() ? 0 : *it);", "  // Initialize two indexes\
    \ for loop.\n  size_t i = 0;\n  size_t j = 0;\n  // Find the highest element among\
    \ the first i elements.\n  while (i < l.size()) {\n    if (l[i] > l[j]) {\n  \
    \    i = i + 1;\n    } else {\n      j = j + 1;\n    }\n  }\n  // Return the highest\
    \ element.\n  return l[j];", "    if (l.size() == 0) return l.size();\n    long\
    \ max = 0;\n    for (long i : l)\n        max = max(max, i);\n    return max;",
  "  long maxval = 0;\n  for (long i = 0; i < l.size(); i++)\n    maxval = max(maxval,\
    \ l[i]);\n  return maxval;", "    auto it = l.begin();\n    long maxval = *it;\n\
    \    ++it;\n    while (it != l.end()) {\n        if (*it > maxval)\n         \
    \   maxval = *it;\n        ++it;\n    }\n    return maxval;", '    return *std::max_element(l.begin(),
    l.end());', "  std::sort(l.begin(), l.end());\n  return l.front();", "    if(l.size()<1)\
    \ return 0;\n    long long maxV = std::accumulate(l.begin(), l.end(), 0);\n  \
    \  for(long long i = 0; i < l.size(); i++) {\n        if(maxV<l[i])\n        \
    \    maxV = l[i];\n    }\n    return maxV;", "    if (l.size() == 0) return 0;\n\
    \    long max = l[0];\n    for (size_t i = 1; i < l.size(); i++) {\n        if\
    \ (l[i] > max) max = l[i];\n    }\n    return max;", "    long max = INT_MIN;\n\
    \    for (long i = 0; i < l.size(); i++) {\n        if (l[i] > max)\n        \
    \    max = l[i];\n    }\n    return max;", "    int size = l.size();\n    assert(size\
    \ > 0); //to make sure it is initialized\n    long max = l[0];\n    for (int i\
    \ = 1; i < size; i++) {\n        if (l[i] > max)\n            max = l[i];\n  \
    \  }\n    return max;", "    assert(l.size() > 0);\n    auto result = l[0];\n\
    \    for (auto i : l) {\n        if (result > i) {\n            result = i;\n\
    \        }\n    }\n    return result;", "  if (l.empty())\n    return -1;\n  long\
    \ max = 0;\n  for (int i = 0; i < l.size(); i++)\n    if (l[i] > max)\n      max\
    \ = l[i];\n  return max;", "    long ans = -long_MAX;\n    auto it = l.begin();\n\
    \    while (it != l.end()) {\n        if (*it > ans) {\n            ans = *it;\n\
    \        }\n        ++it;\n    }\n    return ans;", "    int n = l.size();\n \
    \   assert(n > 0);\n    std::pair<long, long> max = l[0];\n    for (int i = 1;\
    \ i < n; ++i) {\n        if (l[i] > max.first) {\n            max = l[i];\n  \
    \      }\n    }\n    return max.first;", "    long ans = -INFINITY;\n    for (long\
    \ i : l) {\n        if (i > 0) {\n            ans = i;\n            break;\n \
    \       }\n    }\n    return ans;", "    std::sort(l.begin(), l.end());\n    return\
    \ *(std::max_element(l.begin(), l.end()));", "  // Initialize maximum to infinity\n\
    \  long mx = LONG_MAX;\n  // Initialize minimum to negative infinity\n  long mn\
    \ = 0;\n  // Check each value in the vector\n  for (int i = 0; i < l.size(); ++i)\
    \ {\n    // If current value is greater than maximum\n    if (l[i] > mx) {\n \
    \     // Update maximum\n      mx = l[i];\n    }\n    // If current value is less\
    \ than minimum\n    else if (l[i] < mn) {\n      // Update minimum\n      mn =\
    \ l[i];\n    }\n  }\n  // Return maximum\n  return mx;", "    long max = l[0];\n\
    \    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n      \
    \      max = l[i];\n        }\n    }\n    return max;", "    long max = 0;\n \
    \   for (auto e : l) {\n        if (e > max) {\n            max = e;\n       \
    \ }\n    }\n    return max;", "    auto it = l.begin();\n    auto last = l.end();\n\
    \    assert(it != last);\n    long max_element = *it;\n    auto i = ++it;\n  \
    \  for (; (i != last) && max_element < *i; ++i)\n        max_element = *i;\n \
    \   return max_element;", "    auto it = std::max_element(l.begin(), l.end());\n\
    \    assert(it != l.end()); // make sure it's sorted\n    return *it;", "    auto\
    \ it = std::max_element(l.begin(), l.end());\n    assert(it != l.end());\n   \
    \ return *it;", "    if (l.size() == 0)\n        return 0;\n\n    long cur = l[0];\n\
    \    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > cur) {\n      \
    \      cur = l[i];\n        }\n    }\n    return cur;", "    // initialize max\n\
    \    long max = l[0];\n    // iterate and update\n    for (long i : l) {\n   \
    \     if (i > max) {\n            max = i;\n        }\n    }\n    // return max\n\
    \    return max;", "    long max;\n    for (auto i = l.begin(); i != l.end();\
    \ ++i) {\n        if (*i == 0) continue;\n        if ((*i) > max) max = *i;\n\
    \    }\n    return max;", "  int res = std::numeric_limits<long>::min();\n  for\
    \ (int i = 0; i < l.size(); i++)\n    res = std::max(res, l[i]);\n  return res;",
  "    if (l.size() == 0) {\n        throw std::runtime_error(\"The given vector is\
    \ empty.\");\n    }\n    long maxv = l[0];\n    for (long i = 1, len = l.size();\
    \ i < len; i++) {\n        if (l[i] > maxv) {\n            maxv = l[i];\n    \
    \    }\n    }\n    return maxv;", "    assert(l.size() > 0);\n    long max_v =\
    \ *std::max_element(l.begin(), l.end());\n    assert(max_v == *std::max_element(l.begin(),\
    \ l.end()));\n    return max_v;", "    assert(!l.empty());\n    std::bitset<64>\
    \ bits = *std::max_element(l.begin(), l.end());\n    return bits.to_ulong();",
  "    auto max_val = l[0];\n    for (const auto &x : l) {\n        if (x>max_val)\
    \ {\n            max_val = x;\n        }\n    }\n    return max_val;", "  assert(l.size()\
    \ > 0);\n  std::stable_sort(l.begin(), l.end());\n  return l[l.size()-1];", " \
    \   std::vector<long>::iterator it;\n    it = std::max_element(l.begin(), l.end());\n\
    \    assert(it != l.end());\n    return *it;", "    auto max = std::numeric_limits<long>::max();\n\
    \    for (auto& i : l) {\n        if(i > max)\n            max = i;\n    }\n \
    \   return max;", "    auto iter = std::max_element(l.begin(), l.end());\n   \
    \ assert(iter != l.end());\n    return (long)std::distance(l.begin(), iter);",
  "  // Initialize max and min to first and second elements.\n  long min1 = l[0];\n\
    \  long min2 = l[1];\n  // Iterate through all the elements\n  for (long i = 2;\
    \ i < l.size(); i++) {\n    long cur1 = l[i];\n    long cur2 = l[i - 1];\n   \
    \ if (cur2 < cur1) {\n      min2 = cur2;\n    }\n    if (min1 < min2) {\n    \
    \  min1 = min2;\n    }\n  }\n  return min1;", "    long min = l[0];\n    long\
    \ max = l[0];\n\n    for (long elem : l) {\n        if (elem < min) min = elem;\n\
    \        if (elem > max) max = elem;\n    }\n\n    return max;", "    auto it\
    \ = std::max_element(l.begin(), l.end());\n    return std::distance(l.begin(),\
    \ it);", "    assert(l.size() > 0);\n    long largest = l[0];\n    for (auto i\
    \ : l) {\n        if (i > largest)\n            largest = i;\n    }\n    return\
    \ largest;", "    long maxVal = 0, i = l.size() - 1;\n    for (; i >= 0; i--)\
    \ {\n        if (l[i] > maxVal) maxVal = l[i];\n    }\n    return maxVal;", " \
    \   long min = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    for (auto el : l) {\n        if (el < min) min = el;\n        if (el > max)\
    \ max = el;\n    }\n    return max;", "    auto it = std::max_element(l.begin(),\
    \ l.end());\n    if (it == l.end()) {\n        return -1L;\n    }\n    return\
    \ *it;", "    if(l.size() == 0)\n        return 0;\n    if(l.size() == 1)\n  \
    \      return l[0];\n    long max = l[0];\n    for(long i = 1; i < l.size(); i++)\
    \ {\n        if(l[i] > max)\n            max = l[i];\n    }\n    return max;",
  '    return std::max_element(l.begin(), l.end()) - l.begin();', "    assert(l.size()\
    \ > 0);\n    long max = l[0];\n    for (int i = 1; i < l.size(); i++)\n      \
    \  if (max < l[i])\n            max = l[i];\n    return max;", "    long max =\
    \ (long)0;\n    for (auto e : l)\n        max = std::max(max, e);\n    return\
    \ max;", "    // Return largest element in the vector.\n    long res = INT_MIN;\n\
    \    for (long i : l) {\n        res = std::max(res, i);\n    }\n    return res;",
  "    auto it = std::max_element(l.begin(), l.end());\n    return *it;", "    auto\
    \ it = std::max_element(l.begin(), l.end());\n    assert(it != l.end());\n   \
    \ return *it;", "  auto max_value = [](auto a, auto b) { return (a > b) ? a :\
    \ b; };\n  return max_element(l.begin(), l.end(), max_value);", "  long max =\
    \ l[0];\n  for (long i = 0; i < l.size(); i++) {\n    if (l[i] > max) {\n    \
    \  max = l[i];\n    }\n  }\n  return max;", "    auto it = l.begin();\n    auto\
    \ end = l.end();\n    long res = 0;\n    while (it != end && *it > res)\n    \
    \    ++it;\n    if (it == end)\n        return res;\n    for (; it != end; ++it)\n\
    \        if (*it > res)\n            res = *it;\n    return res;", "    long max\
    \ = 0;\n    for (long i : l) {\n        if (i > max) {\n            max = i;\n\
    \        }\n    }\n    return max;", "    assert(l.size() <= 100000); // to avoid\
    \ runtime error for large inputs.\n    auto it = max_element(cbegin(l), cend(l));\n\
    \    return *it;", "    assert(l.size() > 0);\n    // Sort first.\n    std::sort(l.begin(),\
    \ l.end());\n\n    // Find maximum\n    long maximum = l.back();\n    for (long\
    \ &i : l)\n        if (i > maximum)\n            maximum = i;\n    return maximum;",
  "  std::sort(l.begin(), l.end());\n  return l.front();", "    auto it = std::max_element(l.begin(),\
    \ l.end());\n    if (it == l.end()) return 0;\n    return *it;", "    auto it\
    \ = std::max_element(l.begin(), l.end());\n    return *it;", "    long max = 0;\n\
    \    for (size_t i = 0; i < l.size(); ++i) {\n        max = std::max(max, l[i]);\n\
    \    }\n    return max;", "    long result = -99999999;\n    for (auto i : l)\n\
    \        if (result < i)\n            result = i;\n    return result;", "    auto\
    \ it = std::max_element(l.begin(), l.end());\n    return it == l.end()? it: it->second;",
  "    std::sort(l.begin(), l.end());\n    return l.back();", "    auto f = [](long\
    \ x, long y){return x >  y ? x : y;};\n    return *std::max_element(l.begin(),\
    \ l.end(), f);", "    int n = l.size();\n    assert(n != 0);\n    assert(n > 0);\n\
    \    long max_elem = l[0];\n    for (int i = 1; i < n; ++i) {\n        if (l[i]\
    \ > max_elem) {\n            max_elem = l[i];\n        }\n    }\n    return max_elem;",
  "    int size = l.size();\n    if (size > 0) {\n        long long maximum = l[0];\n\
    \        for (int i = 1; i < size; ++i) {\n            if (l[i] > maximum) {\n\
    \                maximum = l[i];\n            }\n        }\n        return maximum;\n\
    \    }", "    auto max_it=std::max_element(l.begin(),l.end());\n    return *max_it;",
  "  std::cout << \"max_element of \" << l.size() << \" elements\" << std::endl;\n\
    \  // return std::accumulate(l.begin(), l.end(), (long long int)0, [](long long\
    \ int a, long long int b) { return (a > b)? a : b; });\n  // return std::max(l.begin(),\
    \ l.end());\n  return l.back();", "    long max_element = 0;\n    for (long i\
    \ = 0; i < l.size(); i++) {\n        if (l[i] > max_element) {\n            max_element\
    \ = l[i];\n        }\n    }\n    return max_element;", "    for (long i = 0; i\
    \ < l.size(); i++)\n    {\n        if (l[i] > l[(i+1)%l.size()])\n        {\n\
    \            long temp = l[i];\n            l[i] = l[(i+1)%l.size()];\n      \
    \      l[(i+1)%l.size()] = temp;\n        }\n    }\n    return l[0];", "  auto\
    \ it = std::max_element(l.begin(), l.end());\n  return it == l.end() ? 0 : *it;",
  "    // Code here\n    long max_val = l[0];\n    for (long i : l) {\n        if\
    \ (i > max_val) {\n            max_val = i;\n        }\n    }\n    return max_val;",
  "    auto end = std::max_element(l.begin(), l.end()); \n    return *end;", "   \
    \ std::sort(l.begin(), l.end());\n    return l[l.size() - 1];", "  assert(l.size()\
    \ > 0);\n  // Find the maximum value of a long variable\n  long max_val = l.front();\n\
    \  long min_val = l.back();\n  for (long i : l) {\n    if (max_val < i) {\n  \
    \    max_val = i;\n    }\n    if (min_val > i) {\n      min_val = i;\n    }\n\
    \  }\n  return max_val;", "    long max = 0;\n    for(auto i : l) {\n        if(i\
    \ < max) {\n            max = i;\n        }\n    }\n    return max;", "    //\
    \ Create a map of input values\n    std::unordered_map<long, std::pair<int, bool>\
    \ > m;\n    // Add each value to the map\n    for (long x : l) {\n        m[x]\
    \ = std::make_pair(0, false); //std::pair<long, bool> m;\n    }\n    std::vector<long>\
    \ res;\n    // Sort the map and output the maximum value\n    for (auto it = m.begin();\
    \ it != m.end(); ++it) {\n        if (it->second.second) {\n            res.push_back(it->first);\n\
    \        }\n    }\n    return res[0];", "    long ans = -1;\n    for (long i =\
    \ 0; i < l.size(); i++) {\n        ans = std::max(ans, l[i]);\n    }\n    return\
    \ ans;", "    std::sort(l.begin(), l.end());\n    return *std::max_element(l.begin(),\
    \ l.end());", "  assert(l.size() != 0);\n  auto max_element = *std::max_element(l.begin(),\
    \ l.end());\n  return max_element;", "    std::sort(l.begin(), l.end());\n   \
    \ return l[l.size() - 1];", "    long max = l.back();\n    for (long i = 0; i\
    \ < l.size(); i++) {\n        if (max < l[i]) {\n            max = l[i];\n   \
    \     }\n    }\n    return max;", "  if (l.size() <= 1) return l.front();\n  long\
    \ m = l.front();\n  for (long i = 1; i < l.size(); ++i)\n    if (l[i] > m)\n \
    \     m = l[i];\n  return m;", "\tlong maximum = l[0];\n\tfor (std::vector<long>::size_type\
    \ i = 1; i < l.size(); i++)\n\t\tif (l[i] > maximum)\n\t\t\tmaximum = l[i];\n\t\
    return maximum;", "    long max = -(LONG_MAX);\n    long curr = 0;\n    long i\
    \ = 0;\n    for (i = 0; i < l.size(); i++) {\n        curr = curr > l[i] ? curr\
    \ : l[i];\n        if (max < curr) {\n            max = curr;\n        }\n   \
    \ }\n    return max;", "\tassert(!l.empty());\n\tstd::sort(l.begin(), l.end());\n\
    \tlong first = *l.begin();\n\treturn *std::max_element(l.begin(), l.end()) + first\
    \ - first > first ? first : *std::max_element(l.begin(), l.end()) - first - first;",
  "  long ans = l[0];\n  for (long i = 0; i < l.size(); ++i) {\n    if (l[i] > ans)\n\
    \      ans = l[i];\n  }\n  return ans;", "    // Write your code here.\n    long\
    \ max = l[0];\n    for (auto i : l) {\n        if (i > max)\n            max =\
    \ i;\n    }\n    return max;", '  std::max_element(l.begin(), l.end());', "  \
    \  assert(l.size() > 0);\n    if (l.size() == 1) return l[0];\n    long maxv =\
    \ l[0];\n    for (long i = 1, j = 1; i < l.size(); i++, j++) {\n        if (l[i]\
    \ > maxv) {\n            maxv = l[i];\n        }\n    }\n    return maxv;", " \
    \   assert(l.size() >= 1);\n    auto it = l.begin();\n    if (l.size() == 1) return\
    \ *it;\n    long max = *it;\n    for (++it; it != l.end(); ++it) {\n        if\
    \ (*it > max) max = *it;\n    }\n    return max;", "    long a = 0;\n    for (int\
    \ i = 0; i < l.size(); i++) {\n        if (l[i] > a) {\n            a = l[i];\n\
    \        }\n    }\n    return a;", "    std::sort(l.begin(), l.end());\n    return\
    \ l.back();", '    return *std::max_element(l.begin(), l.end());', "    assert(l.size()\
    \ >= 1);\n    long maxv = -l[0];\n    for (long i = 0; i < l.size(); ++i) {\n\
    \        if (l[i] > maxv)\n            maxv = l[i];\n    }\n    return maxv;",
  "  int n = l.size();\n  int mx = -1;\n  for (int i = 0; i < n; i++) {\n    long\
    \ elem = l[i];\n    if (elem > mx) {\n      mx = elem;\n    }\n  }\n  return mx;",
  "    // Initialize max value\n    long mx = INT_MIN;\n    // Search for the max\
    \ in the vector and update max if necessary\n    for (long i = 0; i < (int)l.size();\
    \ i++) {\n        if (l[i] > mx) {\n            mx = l[i];\n        }\n    }\n\
    \    return mx;", "    long mx = -1, mx2 = 0, mx3 = 0, mx = 0, mx2 = 0, mx3 =\
    \ 0, mx = 0, mx2 = 0;\n    long cnt = 0;\n    for (long i = 0; i < l.size(); i++)\
    \ {\n        if (l[i] > mx) {\n            mx = l[i];\n        }\n        if (l[i]\
    \ > mx2) {\n            mx2 = l[i];\n        }\n        if (l[i] > mx3) {\n  \
    \          mx3 = l[i];\n        }\n        cnt += 1;\n        if (mx > mx2) {\n\
    \            mx = mx2;\n        }\n        if (mx > mx3) {\n            mx = mx3;\n\
    \        }\n    }\n    return mx;", "    long m = 0;\n    for(int i = 0; i < l.size();\
    \ i++) {\n        if(l[i] > m)\n            m = l[i];\n    }\n    return m;",
  "    auto it = std::max_element(l.begin(), l.end());\n    assert(it != l.end());\n\
    \    return *it;", "  long max = 0;\n  for (long x : l)\n    if (x > max)\n  \
    \    max = x;\n  return max;", "    std::sort(l.begin(), l.end());\n    return\
    \ l.back();", "  std::sort(l.begin(), l.end());\n  return l.back();", "  long\
    \ min_element = LONG_MAX;\n  for (long i = 0; i < l.size(); i++)\n    if (l[i]\
    \ < min_element) {\n      min_element = l[i];\n    }\n  return min_element;",
  "    assert(l.size() != 0);\n    long res = l[0];\n    for (long i = 0; i < l.size();\
    \ ++i) {\n        if (l[i] > res)\n            res = l[i];\n    }\n    return\
    \ res;", "    auto it = std::max_element(l.begin(), l.end());\n    return it->second;",
  "    std::vector<long>::iterator it = std::max_element(l.begin(), l.end());\n  \
    \  return *(it);", "    assert(l.size() > 0);\n    long max = 0;\n    long index\
    \ = 0;\n    long max = l[0];\n    for (long i = 1, n = l.size(); i < n; i++) {\n\
    \        if (max < l[i]) {\n            max = l[i];\n            index = i;\n\
    \        }\n    }\n    return index;", "  assert(l.size() != 0);\n  long max_ele\
    \ = l[0];\n  for (int i = 1; i < l.size(); i++)\n    max_ele = std::max(max_ele,\
    \ l[i]);\n  return max_ele;", "   long result = -1L;\n   for(auto &x: l)\n   \
    \   if(x > result) result = x;\n   return result;", '    return *std::max_element(l.begin(),
    l.end());', "    assert(l.size() > 0);\n    auto begin = std::max_element(l.begin(),\
    \ l.end());\n    if (begin == l.end()) {\n        return l.back();\n    }\n  \
    \  else {\n        return *begin;\n    }", "    long long max_ele = l[0];\n  \
    \  for (long i = 1; i < l.size(); i++) {\n        max_ele = (max_ele > l[i]) ?\
    \ max_ele : l[i];\n    }\n    return max_ele;", "    // find index of max element\n\
    \    long max = 0;\n    for (long i = 0; i< l.size(); i++){\n        if (max<l[i]){\n\
    \            max = l[i];\n        }\n    }\n    return max;", "    std::sort(l.begin(),\
    \ l.end(), std::greater<long>());\n    return l.back();", "    auto it = std::max_element(l.begin(),\
    \ l.end());\n    long max_v = *it;\n    return max_v;", "    auto begin = l.begin();\n\
    \    auto end = l.end();\n    auto max_element = *begin;\n\n    for (auto it =\
    \ begin; it != end; ++it) {\n        if (*it > max_element) {\n            max_element\
    \ = *it;\n        }\n    }\n    return max_element;"]
stop_tokens:
- "\n}"
