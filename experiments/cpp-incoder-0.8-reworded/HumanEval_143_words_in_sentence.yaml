name: HumanEval_143_words_in_sentence
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a string representing\
  \ a sentence,\n// the sentence contains some words separated by a space,\n// and\
  \ you have to return a string that contains the words from the original sentence,\n\
  // whose lengths are prime numbers,\n// the order of the words in the new string\
  \ should be the same as the original one.\n// Example 1:\n// >>> words_in_sentence((\"\
  This is a test\"))\n// (\"is\")\n// Example 2:\n// >>> words_in_sentence((\"lets\
  \ go for swimming\"))\n// (\"go for\")\n// Constraints:\n// * 1 <= len(sentence)\
  \ <= 100\n// * sentence contains only letters\nstd::string words_in_sentence(std::string\
  \ sentence) {\n"
tests: "}\nint main() {\n    auto candidate = words_in_sentence;\n    assert(candidate((\"\
  This is a test\")) == (\"is\"));\n    assert(candidate((\"lets go for swimming\"\
  )) == (\"go for\"));\n    assert(candidate((\"there is no place available here\"\
  )) == (\"there is no place\"));\n    assert(candidate((\"Hi I am Hussein\")) ==\
  \ (\"Hi am Hussein\"));\n    assert(candidate((\"go for it\")) == (\"go for it\"\
  ));\n    assert(candidate((\"here\")) == (\"\"));\n    assert(candidate((\"here\
  \ is\")) == (\"is\"));\n}\n"
completions: ["    int flag = 0;\n    for(int i = 0; i < sentence.length(); i++) {\n\
    \        if(sentence[i] >= 65 && sentence[i] <= 90) {\n            flag++;\n \
    \       }\n    }\n    if(flag <= 0) return \"\";\n    std::stringstream ss;\n\
    \    for(int i = 0; i < sentence.length(); i++) {\n        if(sentence[i] >= 65\
    \ && sentence[i] <= 90) {\n            ss << sentence[i];\n            for(int\
    \ j = i + 1; j < sentence.length(); j++) {\n                if(sentence[j] >=\
    \ 65 && sentence[j] <= 90) {\n                    ss << \" \" << sentence[j];\n\
    \                }\n            }\n            ss.seekg(0);\n            for(int\
    \ j = i + 1; j < sentence.length(); j++) {\n                if(sentence[j] >=\
    \ 65 && sentence[j] <= 90) {\n                    ss << \" \" << sentence[j];\n\
    \                }\n            }\n        }\n    }\n    std::string result;\n\
    \    std::string word;\n    ss >> word;\n    while(ss >> word) {\n        if(is_prime(word.length())\
    \ == 1) {\n            result += \" \" + word;\n        }\n    }\n    return result;",
  "  assert(1 <= sentence.size() && sentence.size() <= 100 && \"Invalid sentence\"\
    );\n  std::stack<char> stack_word;\n  std::stack<int> stack_length(100);\n  std::queue<char>\
    \ queue_word;\n  std::queue<int> queue_length(100);\n  bool is_prime = false;\n\
    \  bool is_repeated = false;\n  int index = 0;\n  for (char c : sentence) {\n\
    \    if (c == '\\n') continue;\n    if (c != ' ') queue_word.push(c);\n    else\
    \ {\n      while (!queue_word.empty()) {\n        char c = queue_word.front();\n\
    \        queue_word.pop();\n        stack_word.push(c);\n      }\n      while\
    \ (!stack_word.empty()) {\n        char c = stack_word.top();\n        stack_word.pop();\n\
    \        stack_length.push(c);\n      }\n      queue_word.clear();\n      stack_word.clear();\n\
    \    }\n  }\n  while (!queue_word.empty()) {\n    char c = queue_word.front();\n\
    \    queue_word.pop();\n    stack_word.push(c);\n  }\n  while (!stack_word.empty())\
    \ {\n    char c = stack_word.top();\n    stack_word.pop();\n    stack_length.push(c);\n\
    \  }\n  while (!queue_length.empty()) {\n    int l = queue_length.front();\n \
    \   queue_length.pop();\n    for (int i = 2; i <= l; i++) {\n      if (l % i ==\
    \ 0) {\n        is_repeated = true;\n        break;\n      }\n    }\n    if (!is_repeated)\
    \ is_prime = true;\n  }\n  if (is_prime) {\n    std::string result;\n    while\
    \ (!stack_length.empty()) {\n      char c = stack_length.top();\n      stack_length.pop();\n\
    \      if (result.size() == 0) result += c;\n      if (is_repeated) result +=\
    \ \"\\n\" + c;\n      else result += \" \" + c;\n    }\n  }\n  return result;",
  "  // Split sentence in words.\n  auto words = sentence.split(' ');\n  // Initialize\
    \ a vector to store all prime numbers that need to be printed.\n  std::vector<int>\
    \ primes;\n  // Iterate over each word and keep track of the prime numbers that\
    \ are present in the word.\n  for (const auto &word : words) {\n    bool isPrime\
    \ = true;\n    // Iterate over each prime number from 2 to sqrt(word.size()) check\
    \ if word[i] == 0 or not. If it is 0, then the number is not prime and we should\
    \ skip this word.\n    for (int i = 2; i <= sqrt(word.size()); ++i) {\n      if\
    \ (word[i] == 0) {\n        isPrime = false;\n        break;\n      }\n    }\n\
    \    // If all prime numbers are present in this word, then we will add this word\
    \ to the vector and print it.\n    if (isPrime) {\n      primes.push_back(i);\n\
    \    }\n  }\n  // Print all prime numbers in descending order.\n  for (const auto\
    \ &prime : primes) {\n    std::cout << prime << \" \";\n  }\n  return \"\";",
  "    std::deque<std::string> words;\n    std::string result;\n    std::istringstream\
    \ iss(sentence);\n    std::copy(std::istream_iterator<std::string>(iss), std::istream_iterator<std::string>(),\
    \ std::back_inserter(words));\n    unsigned primes = 1;\n    for (auto &word :\
    \ words) {\n        if (word.length() == 0) continue;\n        if (std::find(std::begin(primes),\
    \ std::end(primes), word.length()) == std::end(primes)) {\n            std::deque<std::string>::iterator\
    \ it = std::find(std::begin(words), std::end(words), word);\n            std::size_t\
    \ pos = it - std::begin(words);\n            words.erase(it);\n            std::string\
    \ s;\n            for (unsigned i = 0; i < pos; i++) {\n                s += \"\
    \ \";\n            }\n            s += word;\n            words.push_back(s);\
    \ // push the word into the queue\n            primes = 1;\n            for (unsigned\
    \ i = 0; i < word.length(); i++) {\n                primes++;\n            }\n\
    \        }\n    }\n    std::reverse(std::begin(words), std::end(words));\n   \
    \ for (auto &word : words) {\n        result += \" \";\n        result += word;\n\
    \    }\n    return result;", "    \n    std::string ans;\n    \n    assert(sentence.size()>0);\n\
    \    \n    int lengths[100];\n    int count[100];\n    for(int i=0;i<=100;i++)\n\
    \    {\n        lengths[i]=sentence[i];\n        count[i]=0;\n    }\n    \n  \
    \  for(int i=0;i<sentence.size();i++)\n    {\n        if(count[sentence[i]]!=0)\n\
    \        {\n            count[sentence[i]]=count[sentence[i]]-1;\n        }\n\
    \        else\n        {\n            count[sentence[i]]=1;\n        }\n    }\n\
    \    \n    for(int i=0;i<=100;i++)\n    {\n        bool flag=true;\n        for(int\
    \ j=0;j<i;j++)\n        {\n            if(lengths[i]%lengths[j]==0)\n        \
    \    {\n                flag=false;\n                break;\n            }\n \
    \       }\n        if(flag)\n        {\n            ans.push_back(sentence[i]);\n\
    \        }\n    }\n    \n    \n    return ans;", "    // Your code here\n    bool\
    \ prime[100] = { false };\n    for (int i = 0; i < sentence.length(); i++)\n \
    \   {\n        int n = i;\n        while (n < sentence.length() && prime[n] ==\
    \ true)\n        {\n            n = n + 1;\n        }\n        prime[n] = true;\n\
    \    }\n    std::string result;\n    for (int i = 0; i < sentence.length(); i++)\n\
    \    {\n        if (sentence[i] != ' ' && sentence[i] != '\\n')\n        {\n \
    \           result += sentence[i];\n        }\n    }\n    return result;", " \
    \ std::vector<std::string> arr;\n  std::istringstream iss(sentence);\n  while\
    \ (std::getline(iss, sentence, '\\n')) {\n    std::string words;\n    std::istringstream\
    \ ss(sentence);\n    while (std::getline(ss, words, '\\t')) {\n      arr.push_back(words);\n\
    \    }\n  }\n  std::sort(arr.begin(), arr.end());\n  std::string res = \"\";\n\
    \  for (auto &it : arr) {\n    int l = it.length();\n    for (int i = 1; i <=\
    \ sqrt(l); i++) {\n      if (l % i == 0) {\n        return res;\n      }\n   \
    \ }\n    res += \" \" + it;\n  }\n  return res;", "    // Write your code here\n\
    \    int flag = 0;\n    int index = 0;\n    int index2 = 0;\n    std::string str\
    \ = \"\";\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i]\
    \ == '\\n') {\n            flag = 1;\n            index = 0;\n        }\n    \
    \    if (flag == 1) {\n            str += sentence[i];\n        }\n        if\
    \ ((flag == 1) && ((i + 1) % 2 == 0)) {\n            if (str.substr(index2, 1).compare(sentence[i])\
    \ == 0) {\n                str += \" \";\n            }\n            index2 =\
    \ i;\n        }\n    }\n    return str;", "    std::ostringstream os;\n    for\
    \ (auto &s : sentence)\n        os << std::setw(2) << s;\n    std::string s =\
    \ os.str();\n    std::map<char, int> mp;\n    size_t i = 0;\n    while (i + 1\
    \ < s.size()) {\n        mp[s[i]]++;\n        mp[s[i + 1]]--;\n        i += 2;\n\
    \    }\n    std::string r;\n    for (auto &i : mp)\n        r += i.first + ' ';\n\
    \    return r;", "    // Write your code here\n    std::vector<std::pair<int,\
    \ std::string>> v;\n    int n = sentence.length();\n    for (int i = 0; i < n;\
    \ i++) {\n        if (v.find(i) == v.end()) {\n            v.push_back(std::make_pair(i,\
    \ sentence.substr(i, 1)));\n        }\n    }\n\n    std::vector<std::string> s;\n\
    \    for (auto i : v) {\n        for (int j = 0; j < i.first; j++)\n         \
    \   s.push_back(i.second);\n    }\n    return s;", "  // Write your code here\n\
    \  std::vector<std::string> splitted = split(sentence, \" \");\n  std::sort(splitted.begin(),\
    \ splitted.end());\n  std::string new_sentence;\n  for (int i = 2; i < splitted.size();\
    \ i++) {\n    int flag = 1;\n    for (int j = 0; j < i; j++) {\n      if (splitted[i]\
    \ == splitted[j]) {\n        flag = 0;\n        break;\n      }\n    }\n    if\
    \ (flag == 1) {\n      new_sentence.push_back(splitted[i]);\n    }\n  }\n  return\
    \ new_sentence;", "    int n = sentence.length();\n    std::vector<std::string>\
    \ ans;\n    std::string str = \"\";\n    for (int i = 0; i <= n; i++) {\n    \
    \    if (std::isalpha(sentence[i])) {\n            str += sentence[i];\n     \
    \       while (std::isalpha(sentence[i + 1])) {\n                str += sentence[i\
    \ + 1];\n                i++;\n            }\n            ans.push_back(str);\n\
    \            str = \"\";\n        }\n    }\n    sort(ans.begin(), ans.end());\n\
    \    int k = 0;\n    for (auto i : ans) {\n        std::string tmp = i;\n    \
    \    for (int j = 0; j < k; j++) {\n            if (tmp[j] != ans[j][k]) {\n \
    \               k = j;\n                break;\n            }\n        }\n   \
    \     k++;\n    }\n    std::string result = \"\";\n    for (int i = 0; i < n;\
    \ i++) {\n        if (i < k)\n            result += ans[i];\n    }\n    return\
    \ result;", "    // Write your code here\n    // return an string that contains\
    \ the words from the original sentence,\n    // whose lengths are prime numbers,\n\
    \    // the order of the words in the new string should be the same as the original\
    \ one.\n    std::vector<std::string> words(sentence, sentence[sentence.size()-1]);\n\
    \    std::string output=\"\";\n    int prime=1;\n    for(int i=0;i<words.size();i++)\
    \ {\n        for(int j=i+1;j<words.size();j++) {\n            if(words[i].length()>words[j].length())\
    \ {\n                break;\n            }\n            if(words[i].length()==words[j].length())\
    \ {\n                prime=1;\n                for(int k=0;k<words[i].length();k++)\
    \ {\n                    if(words[i].at(k) != words[j].at(k)) {\n            \
    \            prime=0;\n                        break;\n                    }\n\
    \                }\n            }\n        }\n        if(prime==1) {\n       \
    \     output+=words[i]+\" \";\n        }\n    }\n    return output;", "    std::vector<std::string>\
    \ tokens;\n    std::string token;\n    size_t i = 0;\n    std::string result;\n\
    \    // split sentence into words\n    while (i < sentence.size()) {\n       \
    \ token = sentence.substr(i, 1);\n        if (token.empty()) {\n            tokens.push_back(token);\n\
    \            i++;\n        } else {\n            tokens.push_back(token);\n  \
    \      }\n    }\n    // find all prime numbers in the tokens\n    for (size_t\
    \ k = 0; k < tokens.size(); k++) {\n        if (tokens[k].length() > 1) {\n  \
    \          int temp = 1;\n            for (int j = k + 1; j < tokens.size(); j++)\
    \ {\n                for (int m = 2; m < temp; m++) {\n                    if\
    \ (temp % m == 0) {\n                        temp = temp - m;\n              \
    \          break;\n                    }\n                }\n            }\n \
    \           if (temp == tokens[k].length()) {\n                tokens.at(k) =\
    \ tokens[k];\n            }\n        }\n    }\n    // sort words in tokens\n \
    \   sort(tokens.begin(), tokens.end(), [](const std::string& a, const std::string&\
    \ b) {\n        return a.length() < b.length();\n    });\n    // add words from\
    \ tokens\n    for (size_t k = 0; k < tokens.size(); k++) {\n        if (tokens[k].length()\
    \ > 1) {\n            result += \" \" + tokens.at(k);\n        }\n    }\n    return\
    \ result;", "    std::vector<std::string> split_sentence(std::sregex_token_iterator(sentence.begin(),\
    \ sentence.end(), \" \"), std::sregex_token_iterator());\n    std::string word\
    \ = \"\";\n    for (auto& str : split_sentence) {\n        if (std::all_of(str.begin(),\
    \ str.end(), ::isspace)) {\n            std::replace(str.begin(), str.end(), '\
    \ ', '\\0');\n            word = word + str;\n        }\n    }\n    std::sort(word.begin(),\
    \ word.end());\n    std::string output;\n    for (int i = 0; i < word.length();\
    \ i++) {\n        if (prime_number(word.length()) == 1) {\n            output\
    \ += word;\n            break;\n        }\n    }\n    return output;", "    std::vector<std::string>\
    \ new_sentence;\n    std::string word;\n    std::string word_count;\n    int count\
    \ = 0;\n    for (int i = 0; i < sentence.length(); i++) {\n        word = sentence[i];\n\
    \        word_count = word + \" \";\n        for (int j = i + 1; j <= sentence.length();\
    \ j++) {\n            word += sentence[j];\n            word_count += word + \"\
    \ \";\n        }\n        new_sentence.push_back(word_count);\n        i += 1;\n\
    \    }\n    bool check_prime = true;\n    for (int j = 0; j < new_sentence.length();\
    \ j++) {\n        int num_new_words = stoi(new_sentence[j]);\n        for (int\
    \ k = 1; k < num_new_words / 2; k++) {\n            check_prime = false;\n   \
    \         if (num_new_words == (k * k)) {\n                for (int l = 0; l <\
    \ num_new_words / 2; l++) {\n                    if (!(pow(num_new_words, l) %\
    \ k)) {\n                        check_prime = true;\n                       \
    \ break;\n                    }\n                }\n            }\n        }\n\
    \        if (check_prime) {\n            count++;\n        }\n    }\n    return\
    \ new_sentence[count - 1];", "    sentence.erase(std::remove_if(sentence.begin(),\
    \ sentence.end(), ::isspace), sentence.end());\n    string word;\n    string result;\n\
    \    string::size_type size = sentence.size();\n    int primes[size] = {0};\n\
    \    for (unsigned i = 0; i < size; i++) {\n        int index = sentence[i] -\
    \ 'a';\n        if (!primes[index]) {\n            primes[index] = 1;\n      \
    \      while (index > 0 && primes[index] == 0) {\n                primes[index]\
    \ = primes[index - 1];\n                index--;\n            }\n            if\
    \ (index < 2 || (index > 2 && primes[index] != 1)) {\n                result.push_back(sentence[i]);\n\
    \            }\n        }\n    }\n    return result;", "    string result;\n \
    \   for (auto iter : words_in_sentence(sentence)) {\n        result += iter;\n\
    \    }\n    return result;", "    std::vector<std::string> new_words;\n    std::string\
    \ result{};\n    for (auto &word: sentence) {\n        if (is_prime_number(word.length()))\
    \ {\n            new_words.push_back(word);\n        }\n    }\n    for (auto &word:\
    \ new_words) {\n        result += \" \" + word;\n    }\n    return result;", " \
    \   std::vector<std::string> tokens;\n    std::string output;\n    std::string\
    \ word = \"\";\n\n    for (auto &ch: sentence) {\n        if (isspace(ch)) {\n\
    \            if (word.length() > 0) tokens.push_back(word);\n            word\
    \ = \"\";\n        } else {\n            word += ch;\n        }\n    }\n\n   \
    \ if (word.length() > 0) tokens.push_back(word);\n\n    for (auto &token: tokens)\
    \ {\n        std::cout << token << std::endl;\n    }\n    std::cout << \"=====\"\
    \ << std::endl;\n\n    return output;", "    // Your code goes here\n    std::sort(sentence.begin(),\
    \ sentence.end());\n    std::string results;\n    for(int i=0;i<sentence.size();i++)\
    \ {\n        results += sentence[i];\n    }\n    for(int i=0;i<sentence.size();i++)\
    \ {\n        if(i%2==0) {\n            if(!(std::ispunct(sentence[i])==true))\
    \ {\n                results += \" \";\n            }\n        }\n        for(int\
    \ j=i+1;j<sentence.size();j++) {\n            if(j%2==0) {\n                if(!(std::ispunct(sentence[j])==true))\
    \ {\n                    results += \" \";\n                }\n            }\n\
    \            if((int)sentence[i]%(int)sentence[j]==0) {\n                if(!(std::ispunct(sentence[j])==true))\
    \ {\n                    results += \" \";\n                }\n            }\n\
    \        }\n    }\n    return results;", "    // Do not write main() function.\n\
    \    // Do not read input, instead use the arguments to the function.\n    //\
    \ Do not print the output, instead return values as specified\n    // Still have\
    \ a doubt. Checkout www.interviewbit.com/pages/sample_codes/ for more details\n\
    \    int counter = 0;\n    std::string ans;\n    for (int i = 0; i < sentence.length();\
    \ i++) {\n        if (i == (sentence.length() - 1)) {\n            ans += sentence[i];\n\
    \            counter++;\n        }\n        else {\n            if (isPrime((int)sentence[i]))\
    \ {\n                ans += sentence[i];\n                counter++;\n       \
    \     }\n        }\n    }\n    return ans;", "    std::string words;\n    int\
    \ n = 1;\n    std::string temp;\n    for (auto itr : sentence) {\n        temp\
    \ = itr;\n        while (temp.length() % n) {\n            temp += \" \";\n  \
    \      }\n        temp = temp.substr(0, temp.length() / n) + \"\\n\";\n      \
    \  words += temp;\n        n++;\n    }\n    return words;", "    long long int\
    \ N;\n    cin>>N;\n    string ans = \"(NULL)\";\n    \n    for (int i=0;i<N;i++){\n\
    \        string s;\n        cin>>s;\n        ans = ans + \" \" + s;\n    }\n \
    \   \n    for (int i=0;i<N;i++){\n        long long int m = 1;\n        long long\
    \ int j = 1;\n        for(int k=0;k<N;k++){\n            if(ans[k] != \" \"){\n\
    \                string p = ans[k];\n                string s = \"\";\n      \
    \          for (int l = 0; l < N; l++) {\n                    if (l != k) {\n\
    \                        s = s + \" \" + p;\n                    }\n         \
    \       }\n                long long int N2 = s.size();\n                for (int\
    \ l = 0; l < N2; l++) {\n                    if (l == j || l != j) {\n       \
    \                 break;\n                    }\n                    m = m % l;\n\
    \                    j = j + 1;\n                }\n                if (j != N)\
    \ {\n                    ans = ans.replace(ans[k], m);\n                }\n  \
    \          }\n        }\n    }\n    return ans;", "  // Write your code here.\n\
    \  vector<string> vec;\n  string temp = \"\";\n  for (int i = 0; i < sentence.size();\
    \ i++) {\n    if (sentence[i] != ' ') {\n      temp = temp + sentence[i];\n  \
    \  } else {\n      vec.push_back(temp);\n      temp = \"\";\n    }\n  }\n  vec.push_back(temp);\n\
    \  string new_str = \"\";\n  for (int i = 0; i < vec.size(); i++) {\n    for (int\
    \ j = 0; j < vec.size(); j++) {\n      if (vec[j] == vec[i]) {\n        new_str\
    \ = new_str + vec[j];\n      }\n    }\n  }\n  return new_str;", "    std::string\
    \ result;\n    for (char word : sentence) {\n        int len = 1;\n        int\
    \ i = 1;\n        while (words[i] != ' ') {\n            len++;\n            i++;\n\
    \        }\n        std::cout << len << std::endl;\n        result += word;\n\
    \    }\n    return result;", "    // write your code here\n    bool prime[100];\n\
    \    for (int i = 0; i < 100; i++) {\n        prime[i] = false;\n    }\n    for\
    \ (int i = 0; i < sentence.length(); i++) {\n        for (int j = i + 1; j < sentence.length();\
    \ j++) {\n            int a = 1;\n            int b = 1;\n            for (int\
    \ k = 0; k < i; k++) {\n                a *= prime[k];\n            }\n      \
    \      for (int k = 0; k < j; k++) {\n                b *= prime[k];\n       \
    \     }\n            if (a == b) {\n                prime[i - 1] = prime[j] =\
    \ true;\n            }\n        }\n    }\n    std::string result = \"\";\n   \
    \ for (int i = 0; i < sentence.length(); i++) {\n        result += \" \";\n  \
    \  }\n    for (int i = 0; i < 100; i++) {\n        result += std::to_string(prime[i]);\n\
    \    }\n    result.erase(result.length() - 1);\n    result.erase(0, 1);\n    return\
    \ result;", "    std::string words[100];\n    int len = sentence.length();\n \
    \   for (int i = 0; i < len; i++)\n        words[i] = sentence.substr(i, (i +\
    \ 1) % len);\n    for (int i = 0; i < len; i++) {\n        for (int j = i + 1;\
    \ j < len; j++) {\n            int k = (i + j) / 2;\n            if (words[i].length()\
    \ > words[j].length() && (len % words[i].length() != 0) &&\n                 \
    \   !(words[i].length() == words[j].length() && (words[i].length() % words[j].length()\
    \ == 0))) {\n                int count = 0;\n                for (int ii = i +\
    \ 1; ii < k; ii++)\n                    if (words[i].length() > words[ii].length())\n\
    \                        count++;\n                for (int jj = j + 1; jj < len;\
    \ jj++)\n                    if (words[j].length() > words[jj].length())\n   \
    \                     count++;\n                for (int ii = k + 1; ii < len;\
    \ ii++)\n                    if (words[i].length() > words[ii].length())\n   \
    \                     count++;\n                for (int jj = i + 1; jj < k; jj++)\n\
    \                    if (words[j].length() > words[jj].length())\n           \
    \             count++;\n                for (int ii = k + 1; ii < len; ii++)\n\
    \                    if (words[i].length() > words[ii].length())\n           \
    \             count++;\n                for (int jj = j + 1; jj < len; jj++)\n\
    \                    if (words[j].length() > words[jj].length())\n           \
    \             count++;\n                if (count == 2)\n                    return\
    \ words[i].substr(0, i);\n                else if (count == 1 && i == k)\n   \
    \                 return words[j].substr(0, j);\n                else if (count\
    \ == 1 && j == k)\n                    return words[i].substr(0, i);\n       \
    \         else\n                    std::cout << count << std::endl;\n       \
    \     }\n        }\n    }\n    return std::string();", "\tassert(sentence.size()\
    \ > 0);\n\tstd::map<int, std::string> m;\n\tfor (char &c : sentence) {\n\t\tif\
    \ (isalpha(c)) {\n\t\t\tc = tolower(c);\n\t\t\tauto iter = m.find(c);\n\t\t\t\
    if (iter == m.end()) {\n\t\t\t\tm = std::map<int, std::string>{{c, c}};\n\t\t\t\
    } else {\n\t\t\t\titer->second = c;\n\t\t\t}\n\t\t}\n\t}\n\tstd::string res;\n\
    \tfor (const auto &itr : m) {\n\t\tres += (itr.second);\n\t}\n\treturn res;",
  "    // Your code here\n    string result = \"\";\n    for (int i = 0; i < sentence.size();\
    \ i++) {\n        result += (isPrime(sentence[i].size()) ? sentence[i] : \"\"\
    );\n    }\n    return result;", "    // Write your code here.\n    int len = 0;\n\
    \    int isPrime[100];\n    std::string words;\n    std::unordered_map<int,int>\
    \ map;\n    for(auto& word: sentence)\n    {\n        len++;\n    }\n    for(int\
    \ i=2; i<=len; i++)\n    {\n        if((len % i) == 0)\n        {\n          \
    \  map[len]=i;\n        }\n    }\n    for(int i = 0; i < len; i++)\n    {\n  \
    \      if(map.find(i) != map.end())\n        {\n            isPrime[map[len]]=true;\n\
    \        }\n        else\n        {\n            isPrime[map[len]]=false;\n  \
    \      }\n    }\n    for(int i = 0; i < len; i++)\n    {\n        if(isPrime[i])\n\
    \        {\n            words.push_back(i);\n        }\n    }\n    return words;",
  "    // code here\n    int n = sentence.size()-1;\n    bool flag = true;\n    int\
    \ count = 0;\n    int i = 0;\n    int j = 0;\n    std::string output;\n    while(i\
    \ < n){\n        if((n % i) == 0){\n            flag = false;\n            break;\n\
    \        }\n        i++;\n    }\n    if(flag){\n        while(j < n){\n      \
    \      if(sentence[j+1] != \" \"){\n                n = n;\n            }else{\n\
    \                n = n;\n            }\n            j++;\n        }\n        while(j\
    \ < n){\n            if(sentence[j] == \" \"){\n                n = n;\n     \
    \       }else{\n                n = n;\n            }\n            j++;\n    \
    \    }\n    }else{\n        while(j < n){\n            if(sentence[j] != \" \"\
    ){\n                n = n;\n            }else{\n                n = n;\n     \
    \       }\n            j++;\n        }\n    }\n    while(i < n){\n        while(j\
    \ < n){\n            if(sentence[j] != \" \" && sentence[j+1] == \" \"){\n   \
    \             n = n;\n            }else{\n                n = n;\n           \
    \ }\n            j++;\n        }\n        while(j < n){\n            if(sentence[j]\
    \ == \" \"){\n                n = n;\n            }else{\n                n =\
    \ n;\n            }\n            j++;\n        }\n        while(j < n){\n    \
    \        if(sentence[j] == \" \"){\n                n = n;\n            }else{\n\
    \                n = n;\n            }\n            j++;\n        }\n        while(j\
    \ < n){\n            if(sentence[j] != \" \"){\n                n = n;\n     \
    \       }else{\n                n = n;\n            }\n            j++;\n    \
    \    }\n        while(j < n){\n            if(sentence[j] == \" \"){\n       \
    \         n = n;\n            }else{\n                n = n;\n            }\n\
    \            j++;\n        }\n        while(j < n){\n            if(sentence[j]\
    \ == \" \"){\n                n = n;\n            }else{\n                n =\
    \ n;\n            }\n            j++;\n        }\n        while(j < n){\n    \
    \        if(sentence[j] != \" \"){\n                n = n;\n            }else{\n\
    \                n = n;\n            }\n            j++;\n        }\n        while(j\
    \ < n){\n            if(sentence[j] == \" \"){\n                n = n;\n     \
    \       }else{\n                n = n;\n            }\n            j++;\n    \
    \    }\n        while(j < n){\n            if(sentence[j] == \" \"){\n       \
    \         n = n;\n            }else{\n                n = n;\n            }\n\
    \            j++;\n        }\n        while(j < n){\n            if(sentence[j]\
    \ != \" \"){\n                n = n;\n            }else{\n                n =\
    \ n;\n            }\n            j++;\n        }\n        while(j < n){\n    \
    \        if(sentence[j] == \" \"){\n                n = n;\n            }else{\n\
    \                n = n;\n            }\n            j++;\n        }", "    std::string\
    \ res;\n    int primes[100] = {0};\n    std::string word;\n    for(auto it : sentence){\n\
    \        primes[it.size()]++;\n    }\n    for(int i = 0; i < 100; i++){\n    \
    \    if(primes[i] == 0){\n            primes[i] = 1;\n            res += i;\n\
    \        }\n    }\n    for(int i = 0; i < sentence.size(); i++){\n        if(primes[sentence.size()-i-1]\
    \ == 0){\n            primes[sentence.size()-i-1] = 1;\n            res += sentence.size()-i-1;\n\
    \        }\n    }\n    return res;", "  std::stack<int> st;\n  std::queue<int>\
    \ q;\n  st.push(0);\n  q.push(0);\n  while (!q.empty()) {\n    int k = q.front();\n\
    \    q.pop();\n    while (!st.empty() && st.top() % k == 0) {\n      st.pop();\n\
    \      q.pop();\n    }\n    st.push(k + 1);\n    q.push(k + 1);\n  }\n  std::string\
    \ ans = \"\";\n  while (!st.empty()) {\n    ans = ans + std::to_string(st.top());\n\
    \    st.pop();\n  }\n  return ans;", "    // Write your code here\n    \n    //\
    \ Code here\n    std::unordered_map<int, bool> m;\n    std::unordered_map<int,\
    \ bool>::iterator it;\n    for (int i = 0; i < sentence.length(); i++) {\n   \
    \     it = m.find(i);\n        if (it == m.end()) {\n            m[i] = true;\n\
    \        } else {\n            m[i] = false;\n        }\n    }\n    std::string\
    \ new_words;\n    for (auto itr : m) {\n        if ((itr.second == false) && (itr.first\
    \ % 2 == 1)) {\n            new_words += itr.first;\n        }\n    }\n    \n\
    \    return new_words;", "\tstd::stack<std::string> s;\n\tfor (auto &c: sentence){\n\
    \t\tif (c==' ' || c=='\\n' || c=='\\t')\n\t\t\tcontinue;\n\t\twhile (!s.empty()\
    \ && c==s.top())\n\t\t\ts.pop();\n\t\ts.push(c);\n\t}\n\tstd::string res;\n\t\
    while (!s.empty())\n\t\tres=s.top()+\" \"+res;\n\twhile (!s.empty())\n\t\ts.pop();\n\
    \treturn res;", "    std::sort(sentence.begin(), sentence.end());\n    std::string\
    \ new_str = sentence;\n    // Iterate through each word in the sentence,\n   \
    \ // if it is a prime number,\n    // add the word in the new string,\n    //\
    \ otherwise do nothing.\n    for (char &c : new_str) {\n        std::string word\
    \ = c;\n        if (is_prime(word.length())) {\n            if (new_str[new_str.length()\
    \ - 1] == '-') {\n                new_str.erase(new_str.length() - 1);\n     \
    \       }\n            new_str += \" \" + word;\n        } else {\n          \
    \  if (new_str[new_str.length() - 1] != '-') {\n                new_str += \"\
    \ \" + word;\n            }\n        }\n    }\n    return new_str;", "    int\
    \ N = sentence.length();\n    // find the first and last letter in sentence\n\
    \    char firstLetter = sentence[0];\n    char lastLetter = sentence[N-1];\n \
    \   int lengthOfWord = N;\n    // find the first and last word\n    for(int i\
    \ = 0; i < N; i++) {\n        char c = sentence[i];\n        if(c == ' ') {\n\
    \            lengthOfWord = i - 1;\n            break;\n        }\n    }\n   \
    \ // find the primes in range [firstLetter ... lastLetter]\n    for(int i = firstLetter;\
    \ i <= lastLetter; i++) {\n        int n = lengthOfWord;\n        int count =\
    \ 0;\n        while(n > 1) {\n            if((n % i) == 0) {\n               \
    \ count++;\n                n /= i;\n            }\n        }\n        if(count\
    \ == 1) {\n            primes.push_back(primes.size() + 1);\n            for(int\
    \ j = 0; j < primes.size(); j++) {\n                if(primes[j] == lengthOfWord)\
    \ {\n                    primes.erase(primes.begin() + j);\n                }\n\
    \            }\n        }\n    }\n    // create the new string\n    std::string\
    \ ans = \"\";\n    for(int i = 0; i < N; i++) {\n        char c = sentence[i];\n\
    \        if(primes.count(lengthOfWord - (int)i)) {\n            ans += \" \";\n\
    \        }\n        ans += c;\n    }\n    // remove the first word\n    if(ans.at(0)\
    \ != ' ') {\n        ans = ans.substr(1);\n    }\n    return ans;", "    // Your\
    \ code goes here\n    std::string result;\n    bool flag;\n    int n = sentence.size();\n\
    \    for (int i = 0; i <= n; i++) {\n        flag = true;\n        for (int j\
    \ = 0; j < n; j++) {\n            if (i % (j + 1) != 0) {\n                flag\
    \ = false;\n            }\n        }\n        if (flag == true) {\n          \
    \  result += sentence[i];\n        }\n    }\n    return result;", "    std::vector<int>\
    \ primes;\n    std::string answer;\n    for (auto i = sentence.begin(); i != sentence.end();\
    \ ++i) {\n        int n = 1;\n        for (int j = 0; j < i; j++)\n          \
    \  if (*i == *j)\n                n++;\n        if (n == 1)\n            primes.push_back(i);\n\
    \    }\n\n    for (auto i : primes) {\n        for (auto j = i; j < primes.size();\
    \ j += i)\n            primes.push_back(j);\n    }\n\n    for (auto i : primes)\
    \ {\n        for (auto j = i; j < primes.size(); j += i)\n            answer.append(sentence.substr(i,\
    \ j));\n    }\n    return answer;", "    // Write your code here\n    \n    std::string\
    \ output = \"(\";\n    for(auto it = sentence.begin(); it != sentence.end(); ++it){\n\
    \        auto n = *it;\n        for(auto i=1;i<=n;i++){\n            auto n =\
    \ n*i;\n            if(n <= n && (n % i == 0)){\n                n += i;\n   \
    \         }\n        }\n        output = output + \" \" + std::to_string(n);\n\
    \    }\n    return output + \")\";", "  // Write your code here\n  \n  std::string\
    \ result;\n  // std::unordered_set<std::string> hash_set(sentence.begin(), sentence.end());\n\
    \  // std::unordered_set<std::string> hash_set2(sentence.rbegin(), sentence.rend());\n\
    \  \n  int n = sentence.size();\n  int prime_num = 1;\n  for (int i = 1; i < n;\
    \ i++) {\n    if(!isPrime(prime_num)){\n      prime_num ++;\n    }\n  }\n  \n\
    \  for (int i = 1; i <= n; i++) {\n    std::string tmp = sentence.substr(0, i);\n\
    \    \n    // std::unordered_set<std::string> hash_set2(sentence.rbegin(), sentence.rend());\n\
    \    bool flag = false;\n    for (int j = 1; j <= n; j++) {\n      if (j > i)\
    \ {\n        if (tmp == sentence.substr(j, i - j)) {\n          flag = true;\n\
    \          break;\n        }\n      }\n    }\n    if (flag) {\n      continue;\n\
    \    }\n    \n    // std::unordered_set<std::string> hash_set(sentence.begin(),\
    \ sentence.end());\n    \n    if(isPrime(prime_num)){\n      prime_num ++;\n \
    \     result += tmp + \" \";\n    }\n    \n    \n  }\n  return result;", "   \
    \ // Your code here\n    int n = strlen(sentence.c_str());\n    int max_size =\
    \ n;\n    int ans[max_size];\n    for (int i = 0; i < n; i++)\n    {\n       \
    \ ans[i] = i;\n    }\n    ans[0] = 0;\n    for (int i = 1; i < n; i++)\n    {\n\
    \        for (int j = i + 1; j < n; j++)\n        {\n            if (strcmp(sentence.substr(i\
    \ - 1, 1), sentence.substr(j, 1)) == 0)\n            {\n                int temp\
    \ = ans[j];\n                ans[j] = ans[i];\n                ans[i] = temp;\n\
    \            }\n        }\n    }\n    int size = max_size;\n    std::string an\
    \ = \"\";\n    for (int i = 0; i < max_size; i++)\n    {\n        an += sentence.substr(ans[i],\
    \ 1);\n    }\n    return an;", "  // write your code here\n  std::string word\
    \ = \"\";\n  int length = sentence.length();\n  int prime = 1;\n  while (length\
    \ != 0) {\n    if (length % prime == 0) {\n      word += sentence[length - 1];\n\
    \      length = length / prime;\n    } else {\n      length--;\n    }\n    prime++;\n\
    \  }\n  return word;", "    // Write your code here\n    \n    // Declare and\
    \ initialize two string \n    // 1. original string\n    std::string original_string\
    \ = \"\";\n    // 2. new string \n    std::string new_string = \"\";\n    // 3.\
    \ prime string array\n    int prime_str[100];\n    // 3. prime string array counter\n\
    \    int prime_str_counter = 0;\n    // 4. prime string counter array\n    int\
    \ prime_str_counter[100];\n    // 5. prime string counter\n    int prime_str_counter_counter\
    \ = 0;\n    // 6. prime string counter\n    int prime_str_counter_counter[100];\n\
    \    \n    // Fill original_string variable with original string from user input\n\
    \    std::copy(sentence.begin(), sentence.end(), std::back_inserter(original_string));\n\
    \    \n    // Traverse original_string and add each character to prime_str array\n\
    \    for (int i = 0; i < original_string.size(); i++) {\n        // If original_string\
    \ is empty break;\n        if (original_string == \"\") break;\n        \n   \
    \     // Initialize new_string with original_string\n        new_string += original_string[i];\n\
    \        \n        // Get prime number for new string\n        prime_str[prime_str_counter]\
    \ = std::stoi(new_string);\n        // Increment prime string counter\n      \
    \  prime_str_counter++;\n        \n        // Reinitialize new_string with original_string\n\
    \        new_string = \"\";\n    }\n    \n    // Print prime_str\n    for (int\
    \ i = 0; i < prime_str_counter; i++) {\n        std::cout << prime_str[i] << std::endl;\n\
    \    }\n    \n    // If prime_str_counter != original_string.size() then return\
    \ empty string\n    if (prime_str_counter != original_string.size()) return \"\
    \";\n    \n    // Traverse original_string and add each character to prime_str_counter\
    \ array\n    for (int i = 0; i < original_string.size(); i++) {\n        // If\
    \ original_string is empty break;\n        if (original_string == \"\") break;\n\
    \        \n        // Initialize new_string with original_string\n        new_string\
    \ += original_string[i];\n        \n        // Get prime number for new string\n\
    \        prime_str_counter[prime_str_counter_counter] = std::stoi(new_string);\n\
    \        // Increment prime string counter \n        prime_str_counter_counter++;\n\
    \        \n        // Reinitialize new_string with original_string\n        new_string\
    \ = \"\";\n    }\n    \n    // Print prime_str_counter\n    for (int i = 0; i\
    \ < prime_str_counter_counter; i++) {\n        std::cout << prime_str_counter[i]\
    \ << std::endl;\n    }\n    \n    // If prime_str_counter_counter != original_string.size()\
    \ then return empty string\n    if (prime_str_counter_counter != original_string.size())\
    \ return \"\";\n    \n    // Iterate over prime_str_counter and prime_str_counter_counter\n\
    \    for (int i = 0; i < ", "    vector<string> split_sentence = split(sentence);\n\
    \    string results[10] = {0};\n    for (auto &s: split_sentence) {\n        bool\
    \ flag = false;\n        for (auto &r: results) {\n            if (r == s) {\n\
    \                flag = true;\n                break;\n            }\n       \
    \ }\n        if (!flag) {\n            results[10] = s;\n        }\n    }\n  \
    \  for (auto &r: results) {\n        if (r.length() > 2) {\n            sort(r.begin(),\
    \ r.end());\n        }\n    }\n    string new_sentence = \"\";\n    for (auto\
    \ &s: results) {\n        new_sentence += s;\n    }\n    return new_sentence;",
  "    std::string output = \"()\";\n    for (auto word : sentence) {\n        if\
    \ (isPrime(word.length())) {\n            output += \" \" + word;\n        }\n\
    \    }\n    std::size_t found = output.find_first_of(\"()\");\n    if (found !=\
    \ std::string::npos) {\n        output = output.substr(0, found);\n    }\n   \
    \ return output;", "    using namespace std;\n    \n    unordered_set<char> primes;\n\
    \    vector<int> primes_count(26);\n    \n    for(int i = 2; i < sentence.length();\
    \ i++){\n        if(primes_count[sentence[i] - 'a'] == 0){\n            primes.insert(sentence[i]);\n\
    \            primes_count[sentence[i] - 'a']++;\n        }\n    }\n    \n    for(int\
    \ i = 2; i < sentence.length(); i++){\n        if(primes[sentence[i] - 'a']){\n\
    \            for(int j = i; j < sentence.length(); j++){\n                if(primes[sentence[j]\
    \ - 'a']){\n                    for(int k = j + 1; k < sentence.length(); k++){\n\
    \                        if(primes[sentence[k] - 'a']){\n                    \
    \        for(int l = k + 1; l < sentence.length(); l++){\n                   \
    \             if(primes_count[sentence[l] - 'a']){\n                         \
    \           primes_count[sentence[l] - 'a']--;\n                             \
    \       break;\n                                }\n                          \
    \  }\n                        }\n                    }\n                }\n  \
    \          }\n        }\n    }\n    \n    string ans = \"\";\n    \n    for(int\
    \ i = 0; i < 26; i++)\n        if(primes_count[i])\n            ans += (char)\
    \ ('a' + i);\n    \n    return ans;", "  int n = ceil(sqrt(sentence.size()) +\
    \ 1);\n  // Initialize an empty string\n  std::string result = \"\";\n  for (int\
    \ i = 0; i < sentence.size(); i++)\n    // For each character in sentence,\n \
    \   if (n % (i + 1) != 0 && n % i != 0)\n      // If the character is non-prime\
    \ number\n      result += sentence[i];\n  return result;", "  // Your code here\n\
    \  int primes[100] = {0};\n  for (int i = 0; i < sentence.length(); i++) {\n \
    \   primes[sentence[i] - 'a']++;\n  }\n  std::sort(primes, primes + 100);\n  std::vector<std::string>\
    \ ret;\n  for (int i = 0; i < 100; i++) {\n    if (primes[i] == 0) continue;\n\
    \    for (int j = i + 1; j < 100; j++) {\n      if (primes[i] * primes[j] == sentence.length)\
    \ {\n        ret.push_back(i + 'a' + j);\n      }\n    }\n  }\n  return ret[0];",
  "    int n = sentence.length();\n    std::string ans = \"\";\n    for (int i = 0;\
    \ i < n; i++) {\n        std::size_t found = sentence.find(\" \", i);\n      \
    \  if (found != std::string::npos)\n            ans += sentence.substr(i, found\
    \ - i);\n        ans += \" \" + sentence.substr(i, found - i);\n    }\n    std::sort(ans.begin(),\
    \ ans.end());\n    ans.erase(std::unique(ans.begin(), ans.end()), ans.end());\n\
    \    std::sort(ans.begin(), ans.end());\n    return ans;", "    int n = strlen(sentence.c_str());\n\
    \    std::string result = \"\";\n    for(int i = 0; i < n; i++) {\n        int\
    \ flag = 1;\n        for(int j = i + 1; j < n; j++) {\n            if(sentence[i]\
    \ == ' ' && sentence[j] == ' ') {\n                flag = 0;\n               \
    \ break;\n            }\n            if(sentence[i] == sentence[j]) {\n      \
    \          flag = 0;\n                break;\n            }\n        }\n     \
    \   if(flag == 0) {\n            result += sentence[i];\n        }\n    }\n  \
    \  return result;", "    std::string result=\"\";\n    assert(sentence.size()>0);\n\
    \    for(int i=0;i<sentence.size();i++) {\n        assert(sentence[i]>=' ');\n\
    \        for(int j=i;j<sentence.size();j++) {\n            if((sentence[j]>='A'&&sentence[j]<='Z')||(sentence[j]>='a'&&sentence[j]<='z')){\n\
    \                break;\n            }\n        }\n        for(int j=i;j<sentence.size();j++)\
    \ {\n            if((sentence[j]==' ')||(sentence[j]=='\\0')||(sentence[j]=='\
    \ ')) {\n                break;\n            }\n        }\n        if((j-i)==2)\
    \ {\n            for(int j=i;j<sentence.size();j++) {\n                if((sentence[j]>='A'&&sentence[j]<='Z')||(sentence[j]>='a'&&sentence[j]<='z')){\n\
    \                    break;\n                }\n            }\n            for(int\
    \ j=i;j<sentence.size();j++) {\n                if((sentence[j]==' ')||(sentence[j]=='\\\
    0')||(sentence[j]==' ')) {\n                    break;\n                }\n  \
    \          }\n            if((j-i)==1) {\n                for(int j=i;j<sentence.size();j++)\
    \ {\n                    if((sentence[j]>='A'&&sentence[j]<='Z')||(sentence[j]>='a'&&sentence[j]<='z')){\n\
    \                        break;\n                    }\n                }\n  \
    \              for(int j=i;j<sentence.size();j++) {\n                    if((sentence[j]=='\
    \ ')||(sentence[j]=='\\0')||(sentence[j]==' ')) {\n                        break;\n\
    \                    }\n                }\n                for(int j=i;j<sentence.size();j++)\
    \ {\n                    if((sentence[j]!='\\0')&&(sentence[j]!=' '))\n      \
    \              {\n                        break;\n                    }\n    \
    \            }\n                assert(j<sentence.size()-1);\n               \
    \ result=result+sentence.substr(i,j-i);\n                break;\n            }\n\
    \        }\n    }\n    return result;", "    std::stack<int> s;\n    for (char\
    \ &i : sentence) {\n        i = tolower(i);\n        if (i.isalnum()) {\n    \
    \        s.push(i);\n        }\n    }\n    std::string ans = \"\\\"\";\n    while\
    \ (!s.empty()) {\n        int pop = s.top();\n        s.pop();\n        ans +=\
    \ pop;\n        if (ans.size() > 1) {\n            ans += \" \";\n        }\n\
    \    }\n    ans += \"\\\"\";\n    return ans;", "    std::vector<std::string>\
    \ v;\n    std::string s;\n    for (char c : sentence) {\n        if (!std::isalpha(c))\
    \ {\n            s += c;\n            v.emplace_back(s);\n            s = \"\"\
    ;\n        }\n    }\n    sort(v.begin(), v.end());\n    bool flag = true;\n  \
    \  for (auto i : v) {\n        if (flag) {\n            s += i;\n            flag\
    \ = false;\n        }\n    }\n    for (int i = 0; i < v.size(); i++) {\n     \
    \   int count = 0;\n        for (int j = 0; j < v.size(); j++) {\n           \
    \ if (v[i] == v[j]) {\n                count++;\n            }\n        }\n  \
    \      if (std::gcd(count, (int)v.size()) == 1) {\n            return v[i];\n\
    \        }\n    }\n    return s;", "    // write your code here\n    std::map<int,\
    \ std::set<int>> word_prime;\n    std::string ans = \"\";\n    std::string word;\n\
    \    for (int i = 0; i < sentence.size(); i++) {\n        word = sentence[i];\n\
    \        if (!word_prime.empty() && word_prime.count(word) == 0) {\n         \
    \   std::set<int> temp_set;\n            for (int j = 0; j < word_prime.size();\
    \ j++) {\n                temp_set.insert(word_prime[j]);\n            }\n   \
    \         word_prime[word] = temp_set;\n        }\n    }\n    for (auto it : word_prime)\
    \ {\n        if (it.second.size() == 1) {\n            ans += it.first;\n    \
    \    }\n    }\n    return ans;", "    std::string result;\n    for (int i = 0;\
    \ i <= sentence.length(); i++) {\n        if (i == sentence.length()) {\n    \
    \        result += sentence[i];\n        }\n        for (int j = i; j <= sentence.length();\
    \ j++) {\n            if (i % j == 0) {\n                result += \" \";\n  \
    \              break;\n            } else {\n                result += sentence[j];\n\
    \            }\n        }\n    }\n    std::sort(result.begin(), result.end());\n\
    \    return result;", "    std::vector<int> prime_lengths(\n        sentence.length(),\
    \ 0);\n    int n = 2;\n    while (n > 2) {\n        auto next = n * 2;\n     \
    \   while (next <= n) {\n            if (n%next == 0) {\n                prime_lengths[n]\
    \ = next;\n                break;\n            }\n            next = next + 1;\n\
    \        }\n        n = next;\n    }\n    std::vector<int> prime_index;\n    for\
    \ (int i = 0; i < prime_lengths.size(); i++) {\n        if (prime_lengths[i] ==\
    \ 0) {\n            prime_index.push_back(i);\n        }\n    }\n    std::vector<std::string>\
    \ res;\n    int index = 0;\n    while (index < sentence.length()) {\n        int\
    \ len = std::min(prime_lengths[index], sentence.length() - index);\n        for\
    \ (auto i : prime_index) {\n            std::string tmp(sentence.substr(index,\
    \ len));\n            tmp.insert(tmp.begin(), words[i]);\n            res.push_back(tmp);\n\
    \            index += len;\n        }\n    }\n    std::string res1 = \"\";\n \
    \   for (auto s : res) {\n        res1 += s;\n    }\n    return res1;", "    std::string\
    \ words;\n    int size = sentence.length();\n    for(int i = 0; i<size; i++)\n\
    \    {\n        char c = sentence[i];\n        if(!isalnum(c)) continue;\n   \
    \     int temp = tolower(c) - 'a' + 1;\n        assert(temp%2 == 0);\n       \
    \ if(temp > 1) words += ' ';\n        words += 'a' + temp;\n    }\n    std::reverse(words.begin(),\
    \ words.end());\n    return words;", "    std::unordered_set<char> primes;\n \
    \   for (int i = 0; i <= 100; i++) {\n        if (primes.find(i) != primes.end())\n\
    \            continue;\n        bool isPrime = true;\n        for (int j = i;\
    \ j < 100; j += i) {\n            if (i % j != 0) {\n                isPrime =\
    \ false;\n                break;\n            }\n        }\n        if (isPrime)\
    \ {\n            primes.insert(i);\n        }\n    }\n    std::string ans;\n \
    \   for (auto c : sentence) {\n        ans += \" \" + c;\n    }\n    std::transform(ans.begin(),\
    \ ans.end(), ans.begin(), ::tolower);\n    std::replace(ans.begin(), ans.end(),\
    \ ' ', '\\n');\n    std::istringstream iss(ans);\n    while (iss >> word) {\n\
    \        if (iss >> word) {\n            if (primes.find(word) == primes.end())\n\
    \                iss.put('\\n');\n        }\n    }\n    return ans;", "    //\
    \ Your code here\n    bool b[10001];\n    std::unordered_set<int> prime;\n   \
    \ int i = 0;\n    int index = 0;\n    bool found = false;\n    while (!found &&\
    \ i < 10001) {\n        std::unordered_set<int> temp;\n        auto itr = temp.begin();\n\
    \        auto itr2 = temp.end();\n        auto itr3 = temp.begin();\n        for\
    \ (int j = 0; j < i; j++) {\n            if (b[i] == false) {\n              \
    \  temp.insert(i * i);\n                itr = temp.begin();\n                itr2\
    \ = temp.end();\n                std::unordered_set<int> temp2;\n            \
    \    for (int k = 0; k < j; k++) {\n                    temp2.insert(j * j);\n\
    \                    itr3 = temp2.begin();\n                    for (int l = 0;\
    \ l < k; l++) {\n                        temp2.insert(k * k);\n              \
    \          itr3 = temp2.begin();\n                        for (auto m = itr; m\
    \ < itr2; ++m) {\n                            temp2.insert(m * m);\n         \
    \                   itr3 = temp2.begin();\n                        }\n       \
    \             }\n                }\n            }\n        }\n        prime[i]\
    \ = true;\n        bool temp = b[0];\n        for (int j = 1; j < i; j++) {\n\
    \            if (b[j] == true) {\n                std::unordered_set<int> temp2;\n\
    \                for (int k = 0; k < j; k++) {\n                    temp2.insert(k\
    \ * k);\n                }\n                for (int m = 0; m < itr2; ++m) {\n\
    \                    temp2.insert(m * m);\n                }\n               \
    \ prime[temp2.size()] = true;\n                bool temp3 = b[j];\n          \
    \      for (int l = 0; l < j; l++) {\n                    if (b[l] == true) {\n\
    \                        std::unordered_set<int> temp3;\n                    \
    \    for (int m = 0; m < l; m++) {\n                            temp3.insert(m\
    \ * m);\n                        }\n                        for (int m = 0; m\
    \ < itr2; ++m) {\n                            temp3.insert(m * m);\n         \
    \               }\n                        prime[temp3.size()] = true;\n     \
    \               }\n                }\n            }\n        }\n        if (!temp)\
    \ {\n            found = true;\n        }\n        ++i;\n    }\n    std::string\
    \ ans;\n    ans.clear();\n    for (int j = 0; j < i; j++) {\n        if (b[j]\
    \ == true) {\n            ans += sentence[j];\n        }\n    }\n    return ans;",
  "    assert(!sentence.empty());\n    // Your code here", "    // code here\n   \
    \ unordered_set<string> ans;\n    string result;\n    for (int i = 0; i < sentence.size();\
    \ i++) {\n        // check if current char is a space\n        if (sentence[i]\
    \ == ' ') {\n            // if not, check if char is in answer\n            if\
    \ (!ans.count(sentence[i])) {\n                // if not, add word to answer and\
    \ check if current char is not a space\n                ans.insert(sentence[i]);\n\
    \                // if it is, add space\n                if (!ans.count(sentence[i]))\n\
    \                    ans.insert(\" \");\n            }\n        }\n        else\
    \ {\n            // if not, add word\n            if (!ans.count(sentence[i]))\n\
    \                ans.insert(sentence[i]);\n        }\n    }\n    // print result\n\
    \    for (auto it = ans.begin(); it != ans.end(); it++) {\n        // remove char\
    \ and space\n        result += *it;\n        if (*it != ' ')\n            result\
    \ += \" \";\n    }\n    // remove last space\n    result.erase(result.end() -\
    \ 1);\n    return result;", "    std::sort(sentence.begin(), sentence.end());\n\
    \    std::reverse(sentence.begin(), sentence.end());\n    std::string ans;\n \
    \   for (auto it = sentence.begin(); it != sentence.end(); ++it) {\n        //\
    \ If it is a number, continue, else add it to the answer.\n        bool ok = false;\n\
    \        do {\n            ok = true;\n            int num = 0;\n            while\
    \ (std::isdigit(*it)) {\n                num = num * 10 + (*it) - '0';\n     \
    \           ++it;\n            }\n            ans.push_back(to_string(num));\n\
    \            ok = false;\n        } while (!ok);\n    }\n    return ans;", " \
    \   \n    std::string ans;\n    for(int i=0;i<sentence.length();i++){\n      \
    \  std::string word;\n        if(sentence[i]>='a' && sentence[i]<='z' || sentence[i]>='A'\
    \ && sentence[i]<='Z')\n            word+=sentence[i];\n        else{\n      \
    \      int n=pow(2,sentence.length()-i-1);\n            for(int j=1;j<=n;j++)\n\
    \            {\n                std::string temp(word);\n                bool\
    \ found=false;\n                for(int k=0;k<temp.size();k++){\n            \
    \        if(temp[k]==sentence[i])\n                        found=true;\n     \
    \           }\n                if(found){\n                    ans=ans+\" \"+word;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    \n    return ans;", "    std::string result;\n    // You can return any\
    \ data structure you want\n    vector<string> words;\n    // Split sentence into\
    \ words\n    vector<string>::iterator it;\n    for (it = sentence.begin(); it\
    \ != sentence.end(); ++it)\n    {\n        vector<string>::iterator it2 = words.begin();\n\
    \        for (it2 = words.begin(); it2 != words.end(); ++it2)\n        {\n   \
    \         // Check first if the current word matches the word we are looking for\n\
    \            if((*it) == (*it2))\n            {\n                // If it does,\
    \ skip the word\n                ++it2;\n                ++it2;\n            \
    \    // If current word is same as target word, then skip this word\n        \
    \        if(*it2 == (*it))\n                    ++it2;\n                // If\
    \ current word is greater than target word, then add it to the result\n      \
    \          else\n                {\n                    result += *it2;\n    \
    \            }\n                break;\n            }\n        }\n        // If\
    \ the current word does not match the target word, then add it to the result\n\
    \        if(words.empty())\n            result += *it;\n    }\n    return result;",
  "    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n", "    std::stack<std::string>\
    \ stack;\n    std::string result = \"\";\n    for(int i = 0; i < sentence.length();\
    \ i++) {\n        char curr = sentence[i];\n        while(!stack.empty() && curr\
    \ != ' ' && stack[stack.size()-1] != curr) {\n            result += stack[stack.size()-1];\n\
    \            stack.pop();\n        }\n        stack.push(curr);\n    }\n    while(!stack.empty())\
    \ {\n        result += stack.top();\n        stack.pop();\n    }\n    return result;",
  "    std::stack<std::string> st;\n    std::string result;\n    int len = sentence.length();\n\
    \    bool flag = false;\n    int counter = 1;\n    std::string temp;\n    for\
    \ (char ch : sentence) {\n        if (flag == false) {\n            if (ch ==\
    \ ' ') {\n                flag = true;\n                for (int i = 0; i < (len\
    \ - 1); i++) {\n                    st.push(temp);\n                    counter++;\n\
    \                }\n                temp = \"\";\n            } else {\n     \
    \           temp = temp + ch;\n            }\n        } else {\n            if\
    \ (ch == ' ') {\n                flag = false;\n                for (int i = 0;\
    \ i < (len - 1); i++) {\n                    st.push(temp);\n                \
    \    counter++;\n                }\n                temp = temp + ch;\n      \
    \      } else {\n                temp = temp + ch;\n            }\n        }\n\
    \    }\n\n    while (!st.empty()) {\n        if (flag == false) {\n          \
    \  result = result + st.top();\n        } else {\n            result = result\
    \ + \" \" + st.top();\n        }\n        st.pop();\n    }\n    return result;",
  "    // Write your code here\n    int len = 0;\n    int count = 0;\n    for (int\
    \ i = 0; i < sentence.length(); i++) {\n        if (sentence[i] == ' ') {\n  \
    \          count++;\n        }\n        len++;\n    }\n    bool isPrime = false;\n\
    \    for (int i = 1; i <= len; i++){\n        for (int j = 1; j <= i; j++){\n\
    \            if (i % j == 0){\n                isPrime = false;\n            \
    \    break;\n            }\n            else{\n                isPrime = true;\n\
    \                break;\n            }\n        }\n        if (isPrime)\n    \
    \        count++;\n    }\n    \n    std::string answer = \"\";\n    for (int i\
    \ = 0; i < sentence.length(); i++){\n        if (sentence[i] == ' ') {\n     \
    \       answer += sentence[i];\n        }\n    }\n    answer += std::to_string(count);\n\
    \    return answer;", "    std::string ans = \"\";\n    assert(std::all_of(sentence.begin(),\
    \ sentence.end(), isalpha));\n    std::vector<std::string> words;\n    std::istringstream\
    \ stream(sentence);\n    std::string word;\n    while (std::getline(stream, word,\
    \ ' ')) {\n        words.push_back(word);\n    }\n    for (auto &w : words) {\n\
    \        if (std::find(words.begin(), words.end(), w) != words.end()) {\n    \
    \        ans += \" \" + w;\n        }\n    }\n    std::sort(ans.begin(), ans.end());\n\
    \    for (auto &i : ans) {\n        auto j = (ans.end() - 1) - i;\n        for\
    \ (auto &i : ans) {\n            if (i != ans[j])\n                break;\n  \
    \      }\n        ans.erase(ans.begin() + j + 1, ans.end());\n    }\n    return\
    \ ans;", "    assert(std::all_of(sentence.begin(), sentence.end(), [](char c){return\
    \ std::isalpha(c);}));\n    std::vector<std::string> word_in_sentence(sentence.begin(),\
    \ sentence.end());\n    \n    for(int i = 0; i < word_in_sentence.size(); i++)\
    \ {\n        if(is_prime(word_in_sentence[i].size())) {\n            std::ostringstream\
    \ ss;\n            for(int j = i; j < word_in_sentence.size(); j++) {\n      \
    \          ss << word_in_sentence[j];\n            }\n            std::string\
    \ res = ss.str();\n            word_in_sentence[i] = res;\n        }\n    }\n\
    \    return std::string(word_in_sentence.begin(), word_in_sentence.end());", " \
    \   // code here\n    std::string new_sentence;\n    new_sentence.reserve(sentence.length());\n\
    \    for (int i = 0; i < sentence.length(); i++) {\n        if (std::next_permutation(sentence.begin(),\
    \ sentence.end()) != sentence.end()) {\n            new_sentence.push_back(sentence[i]);\n\
    \        }\n    }\n    return new_sentence;", "  std::sort(sentence.begin(), sentence.end());\n\
    \  std::string result{};\n  bool isPrime = true;\n  for (auto &it : sentence)\
    \ {\n    if (isPrime) {\n      isPrime = IsPrime(it);\n      if (!isPrime) {\n\
    \        result += it;\n      }\n    } else {\n      result += it;\n    }\n  }\n\
    \  return result;", "    // write your code here\n    \n    std::string result=\"\
    \";\n    for(int i=0;i<sentence.size();i++)\n    {\n        char c=sentence[i];\n\
    \        if ((i%2==0)&&(prime(i)==1))\n        {\n            result+=c;\n   \
    \     }\n    }\n    \n    return result;", "    std::map<std::string, int> temp;\n\
    \    std::string res;\n    for (auto const &w : sentence) {\n        auto it =\
    \ temp.find(w);\n        if (it == temp.end()) {\n            temp[w] = 1;\n \
    \       } else {\n            temp[w] += 1;\n        }\n    }\n    for (auto it\
    \ = temp.begin(); it != temp.end(); it++) {\n        auto val = it->second;\n\
    \        if (val == 2 || val == 3 || val == 5) {\n            res += it->first;\n\
    \        }\n    }\n    return res;", "    std::string output=\"\";\n    std::string\
    \ temp_str=\"\";\n    for (int i=0;i<sentence.length();i++) {\n        for (int\
    \ j=i+1;j<sentence.length();j++) {\n            if (isPrime(int(sentence[i]+sentence[j])))\
    \ {\n                temp_str=temp_str+\" \"+sentence[i];\n            }\n   \
    \     }\n    }\n    for (int i=0;i<temp_str.length();i++) {\n        output.push_back(temp_str[i]);\n\
    \    }\n    return output;", "    // write your code here\n    bool isPrime[100000];\n\
    \    for (int i=0;i<sentence.length();i++) {\n        int n=sentence[i]-'a';\n\
    \        assert(n>=0);\n        if (isPrime[n]==false) {\n            isPrime[n]=true;\n\
    \        }\n    }\n    std::vector<std::string> ans;\n    std::string temp=\"\"\
    ;\n    for (int i=0;i<sentence.length();i++) {\n        int n=sentence[i]-'a';\n\
    \        assert(n>=0);\n        if (isPrime[n]) {\n            ans.push_back(temp);\n\
    \            temp=\"\";\n        } else {\n            temp+=sentence[i];\n  \
    \      }\n    }\n    ans.push_back(temp);\n    return ans;", "        std::string\
    \ result;\n        int i = 0;\n        for (int j = 0; j < sentence.length();\
    \ j++) {\n                for (int k = i + 1; k < sentence.length(); k++) {\n\
    \                        char a = sentence[j];\n                        char b\
    \ = sentence[k];\n                        bool isPrime = true;\n             \
    \           for (int i2 = 1; i2 < i; i2++) {\n                               \
    \ if (i % i2 == 0) {\n                                        isPrime = false;\n\
    \                                        break;\n                            \
    \    }\n                        }\n                        if (isPrime) {\n  \
    \                              result += \" \";\n                            \
    \    result += a;\n                        }\n                }\n            \
    \    result += \" \";\n                result += sentence[i];\n              \
    \  i++;\n        }\n        return result;", "    std::stack<char> s;\n    std::string\
    \ ans;\n    for (auto c : sentence) {\n        if (s.empty()) {\n            s.push(c);\n\
    \        }\n        else if (c == s.top()) {\n            s.pop();\n        }\n\
    \        else if (c != ' ') {\n            s.push(c);\n        }\n        else\
    \ {\n            ans += s.top();\n            s.pop();\n        }\n    }\n   \
    \ return ans;", "  int n = 1, flag = 0, i, max = 1;\n  \n  // Your code goes here\n\
    \  for (i = 0; i <= sentence.size(); i++) {\n    if (flag == 1) {\n      int j\
    \ = 0, max = 1;\n      while (j <= max && j + i <= sentence.size()) {\n      \
    \  if (sentence[i + j] != ' ') {\n          max += 1;\n        } else {\n    \
    \      if (j + i > sentence.size()) {\n            flag = 0;\n            max\
    \ = j;\n          } else {\n            j += i;\n          }\n        }\n    \
    \  }\n      max += 1;\n    }\n  }\n  return sentence;", "  std::vector<std::string>\
    \ word_list(sentence.begin(), sentence.end());\n  std::sort(word_list.begin(),\
    \ word_list.end());\n  std::string ans = \"\";\n  for (int i = 0; i < word_list.size();\
    \ i++) {\n    for (int j = 2; j <= std::sqrt(static_cast<int>(word_list.size()));\
    \ j++) {\n      if (i % j == 0) {\n        ans += \" \" + word_list[i];\n    \
    \    break;\n      }\n    }\n  }\n  return ans.substr(0, ans.size() - 1);", " \
    \ std::stack<std::string> st;\n  std::string result;\n  std::istringstream iss(sentence);\n\
    \  std::string word;\n  while (iss >> word) {\n    st.push(word);\n  }\n  while\
    \ (!st.empty()) {\n    std::string cur = st.top();\n    if (std::next_permutation(cur.begin(),\
    \ cur.end())) {\n      result += cur;\n      st.pop();\n    } else {\n      result\
    \ += (result != \"\") ? \" \" : \"\";\n      result += cur;\n      st.pop();\n\
    \    }\n  }\n  return result;", "    // Write your code here.\n    std::string\
    \ s = sentence;\n    int lenght = s.size();\n    int max = 0;\n    int maxi =\
    \ 1;\n    for (int i = 0; i < lenght; i++)\n    {\n        if(!isPrime(max) &&\
    \ s[i] - 'a' > max)\n        {\n            max = s[i] - 'a';\n            maxi\
    \ = i;\n        }\n    }\n    while(lenght - maxi < maxi)\n    {\n        s +=\
    \ \" \";\n        lenght++;\n    }\n    std::string str = s;\n    while(maxi >\
    \ 0)\n    {\n        str = str.substr(0, maxi) + \" \" + str.substr(maxi, str.length()\
    \ - maxi);\n        maxi--;\n    }\n    return str;", '    // Write your code
    here.', "    // Your code here\n    \n    int N = sentence.length();\n    vector<int>\
    \ primes;\n    vector<int> prime_words;\n    for(int i = 2; i<=N; i++){\n    \
    \    if(N % i == 0){\n            primes.push_back(i);\n            if(N % (i*i)\
    \ == 0){\n                prime_words.push_back(i);\n            }\n        }\n\
    \    }\n    \n    vector<int> indices(N);\n    for(int i = 0; i < N; i++){\n \
    \       indices[i] = i;\n    }\n    sort(indices.begin(), indices.end(), [&](const\
    \ int& x, const int& y){return x > y;});\n    for(int i = 0; i < prime_words.size();\
    \ i++){\n        for(int j = N-1; j >= 0; j--){\n            if(primes[j] >= prime_words[i]){\n\
    \                for (int k = j+1; k < N; k++){\n                    if(indices[k]\
    \ > indices[j]){\n                        indices[k] = indices[j];\n         \
    \           }\n                    else{\n                        break;\n   \
    \                 }\n                }\n            }\n        }\n    }\n    \n\
    \    vector<string> ans;\n    for(int i = 0; i < N; i++){\n        if(indices[N-1-i]\
    \ > i){\n            ans.push_back(sentence.substr(indices[N-1-i], 1));\n    \
    \    }\n    }\n    \n    string res = \"\";\n    for(int i = 0; i < ans.size();\
    \ i++){\n        res += ans[i] + \" \";\n    }\n    return res;", "    std::stack<std::string>\
    \ st;\n    std::stack<bool> seen;\n    for (auto word: sentence) {\n        st.push(word);\n\
    \    }\n\n    while (!st.empty()) {\n        std::string word = st.top();\n  \
    \      st.pop();\n\n        if (seen.empty() || seen.front() == true)\n      \
    \      seen.push(true);\n\n        for (auto i : word) {\n            if (!seen.empty()\
    \ && seen.front() == true)\n                seen.pop();\n            if (i ==\
    \ ' ')\n                continue;\n\n            seen.push(false);\n         \
    \   st.push(i);\n        }\n    }\n    return st.top();", '    // Write your code
    here.', "    std::stringstream ss;\n    std::string ws;\n    int n;\n    bool\
    \ prime = false;\n\n    for (int i = 0; i < sentence.size(); i++) {\n        //\
    \ read current char\n        ss << sentence[i];\n\n        // check if prime\n\
    \        while (!(ss >> n)) {\n            // if number not prime\n          \
    \  if (!prime) {\n                ws = ss.str();\n                prime = true;\n\
    \            } else {\n                ws = ws + \" \" + ss.str();\n         \
    \   }\n            // clear stream\n            ss.str(\"\");\n        }\n\n \
    \       // read next char\n        ss >> n;\n    }\n    return ws;", "  std::vector<std::string>\
    \ word_to_position(sentence.length());\n  for (int i = 0; i < (int) word_to_position.size();\
    \ i++) {\n    word_to_position[i] = i;\n  }\n  std::vector<int> primes;\n  int\
    \ counter = 1;\n  std::string result = \"\";\n  for (int i = (int) sentence.length()\
    \ - 1; i >= 0; i--) {\n    primes.clear();\n    int prime = 1;\n    for (int j\
    \ = (int) word_to_position.size() - 1; j >= 0; j--) {\n      prime = prime * word_to_position[j];\n\
    \    }\n    for (int k = i - 1; k >= 0; k--) {\n      primes.push_back(prime);\n\
    \      prime = prime * word_to_position[k];\n    }\n    if (primes.size() == 0)\
    \ {\n      result += \" \";\n      continue;\n    }\n    for (int p = 0; p < (int)\
    \ primes.size(); p++) {\n      int k = primes[p];\n      if (k >= 0 && k <= i)\
    \ {\n        word_to_position[k] = word_to_position[i];\n        word_to_position[i]\
    \ = k;\n      }\n    }\n    for (int j = 0; j < primes.size(); j++) {\n      counter\
    \ *= primes[j];\n    }\n    std::string str = \"\";\n    for (int j = 0; j < word_to_position.size();\
    \ j++) {\n      str = str + sentence[word_to_position[j]];\n    }\n    if (counter\
    \ % 11 == 0) {\n      result += \"\\n\" + (j + 1);\n    }\n  }\n  return result;",
  "    std::string result=\"\";\n    for(int i=0;i<sentence.length();i++){\n     \
    \   int count1=0;\n        int count2=0;\n        for(int j=i;j<sentence.length();j++){\n\
    \            if((sentence[i]==sentence[j])&&(j!=i)){\n                count1++;\n\
    \            }\n        }\n        for(int k=i+1;k<sentence.length();k++){\n \
    \           if((sentence[i]==sentence[k])&&(k!=i)){\n                count2++;\n\
    \            }\n        }\n        if(count1==0){\n            if(count2==1){\n\
    \                result+=sentence[i]+\" \";\n            }\n        }\n    }\n\
    \    return result;", "    std::string ans;\n    std::string new_sentence = sentence;\n\
    \    std::string temp_sentence = sentence;\n\n    for (unsigned int i = 0; i <\
    \ new_sentence.length(); i++) {\n        if (new_sentence[i] == ' ') {\n     \
    \       temp_sentence = temp_sentence.substr(0, i - 1);\n            if (std::next_permutation(temp_sentence.begin(),\
    \ temp_sentence.end())) {\n                ans = temp_sentence;\n            }\n\
    \        }\n    }\n    return ans;", "    std::string result;\n    std::string\
    \ temp;\n    result.clear();\n    for(int i=0;i<sentence.length();i++){\n    \
    \    bool is_prime = true;\n        for(int j=2;j<i;j++){\n            if(i %\
    \ j == 0){\n                is_prime = false;\n            }\n        }\n    \
    \    if(is_prime){\n            result+=sentence[i];\n        }\n    }\n    return\
    \ result;", "    // code here\n    bool isPrime[100];\n    int len = sentence.size();\n\
    \    for (int i = 0; i < len; i++) {\n        char c = sentence[i];\n        int\
    \ i = c - 'A';\n        int count = 0;\n        while (isPrime[i]) {\n       \
    \     count++;\n            i++;\n        }\n        if (isPrime[i]) {\n     \
    \       isPrime[i] = false;\n        }\n        isPrime[i] = true;\n        if\
    \ (count > 1) {\n            int flag = 0;\n            for (int j = 0; j < count;\
    \ j++) {\n                if (count % j == 0) {\n                    flag = 1;\n\
    \                    break;\n                }\n            }\n            if\
    \ (flag == 1) {\n                isPrime[len] = false;\n            }\n      \
    \  }\n    }\n    std::string ans;\n    for (int i = 0; i < len; i++) {\n     \
    \   if (isPrime[i]) {\n            ans += sentence[i];\n        }\n    }\n   \
    \ return ans;", "    \n    // Write your code here.\n    \n    \n    return \"\
    \";", "    std::vector<int> prime;\n    // Your code goes here\n    sentence.erase(std::remove(sentence.begin(),\
    \ sentence.end(), '\\n'), sentence.end());\n    std::vector<std::string> words;\n\
    \    size_t i = 0;\n    size_t n = sentence.size();\n    for (size_t j = 0; j\
    \ < n; j++) {\n        if (sentence[j] == ' ') {\n            for (size_t k =\
    \ 0; k <= j; k++) {\n                std::cout << \" \" << words[k];\n       \
    \     }\n            std::cout << std::endl;\n            words.clear();\n   \
    \         prime.resize(n + 1);\n            j = 0;\n        }\n        if (!std::isalpha(sentence[j]))\
    \ {\n            words.push_back(sentence[j]);\n        } else {\n           \
    \ while (std::find(words.begin(), words.end(), sentence[j + 1]) != words.end())\
    \ {\n                j++;\n            }\n            words.push_back(sentence[j]);\n\
    \        }\n    }\n    for (size_t i = 0; i < n; i++) {\n        std::cout <<\
    \ words[i] << \" \";\n        if (prime[i] == 2) {\n            prime[i] = 2;\n\
    \        }\n        if (prime[i] == 3) {\n            prime[i] = 3;\n        }\n\
    \        if (prime[i] == 6) {\n            prime[i] = 3;\n        }\n        size_t\
    \ k = i - 1;\n        while (k > 0 && (prime[k] == 3 || prime[k] == 6 || prime[k]\
    \ == 9 || prime[k] == 12 || prime[k] == 15 || prime[k] == 18 || prime[k] == 21))\
    \ {\n            prime[k] = 4;\n            k--;\n        }\n        bool flag\
    \ = true;\n        for (int j = n - 1; j >= i; j--) {\n            if (prime[j]\
    \ != 4) {\n                flag = false;\n            }\n        }\n        if\
    \ (flag) {\n            prime[i] = 4;\n        }\n    }\n    for (size_t i = 0;\
    \ i < n; i++) {\n        std::cout << words[i] << \" \";\n        if (prime[i]\
    \ == 2) {\n            prime[i] = 2;\n        }\n        if (prime[i] == 3) {\n\
    \            prime[i] = 3;\n        }\n        if (prime[i] == 6) {\n        \
    \    prime[i] = 3;\n        }\n        size_t k = i - 1;\n        while (k > 0\
    \ && (prime[k] == 3 || prime[k] == 6 || prime[k] == 9 || prime[k] == 12 || prime[k]\
    \ == 15 || prime[k] == 18 || prime[k] == 21)) {\n            prime[k] = 4;\n \
    \           k--;\n        }\n        bool flag = true;\n        for (int j = n\
    \ - 1; j >= i; j--) {\n            if (prime[j] != 4) {\n                flag\
    \ = false;\n            }\n        }\n        if (flag) {\n            prime[i]\
    \ = 4;\n        }\n    }\n    std::vector<int> prime_number;\n    for (size_t\
    \ i = 0; i < prime.size(); i++) {\n        prime_number.push_back(prime[i]);\n\
    \    }\n    std::sort(prime_number.begin(), prime_number.end());\n    std::string\
    \ final_string;\n    for (size_t i = 0; i < prime_number.", "    if (sentence.empty())\n\
    \        return \"empty\";\n    \n    std::string result = \"\";\n    for (auto\
    \ &word: sentence)\n        if (is_prime(word.length()))\n            result +=\
    \ word;\n    \n    return result;", "    std::vector<std::string> vec;\n    std::string\
    \ final;\n    for (std::size_t i = 0; i < sentence.size(); ++i) {\n        if\
    \ (sentence[i] != ' ') {\n            vec.push_back(sentence[i]);\n        }\n\
    \    }\n    for (int i = 0; i < vec.size(); i++) {\n        for (int j = i + 1;\
    \ j < vec.size(); j++) {\n            if (vec[i] * vec[j] == vec[i] + vec[j])\
    \ {\n                final += vec[i];\n            }\n        }\n    }\n    return\
    \ final;", "    // Your code here\n    int n = sentence.size();\n    int primes\
    \ = 0, flag = 0;\n    std::string res;\n    for(int i = 0; i < n; i++){\n    \
    \    if(sentence[i] >= 'a' && sentence[i] <= 'z'){\n            flag++;\n    \
    \    }\n    }\n    if(flag == 0){\n        for(int i = 0; i < n; i++){\n     \
    \       if(sentence[i] >= 'a' && sentence[i] <= 'z'){\n                primes++;\n\
    \            }\n        }\n    }\n    for(int i = 0; i < n; i++){\n        if(sentence[i]\
    \ >= 'a' && sentence[i] <= 'z'){\n            for(int j = 1; j <= primes; j++){\n\
    \                if(i != 0 && j % i != 0){\n                    res += \" \" +\
    \ sentence[i];\n                }\n            }\n        }\n    }\n    return\
    \ res;", "    std::string ans;\n    bool flag = true;\n    while(sentence.length()\
    \ > 0){\n        if(flag){\n            for(int i = 0; i < sentence.length();\
    \ ++i){\n                flag = false;\n                for(int j = i; j < sentence.length();\
    \ ++j){\n                    if(sentence[i] == sentence[j]){\n               \
    \         flag = true;\n                        break;\n                    }\n\
    \                }\n            }\n            if(flag)\n                ans +=\
    \ sentence[i];\n            else\n                ans += \" \";\n        }\n \
    \       sentence = sentence.substr(1);\n    }\n    return ans;", "    std::vector<std::string>\
    \ word_list;\n    std::string new_sentence = sentence;\n\n    int n = new_sentence.length();\n\
    \    for (int i = 0; i < n; i++) {\n        std::string word = new_sentence.substr(i,\
    \ 1);\n        if (word_list.find(word) == word_list.end()) {\n            word_list.push_back(word);\n\
    \        }\n    }\n    for (int i = 0; i < word_list.size(); i++) {\n        std::cout\
    \ << word_list[i] << \" \";\n    }\n    return new_sentence;", "    string ret\
    \ = \"\";\n    vector<int> lengths(10000);\n    for (auto ch : sentence) {\n \
    \       lengths[ch]++;\n    }\n    for (int i = 1; i < 10000; i++) {\n       \
    \ if (lengths[i] == 1) {\n            ret += sentence[i];\n        }\n    }\n\
    \    return ret;", "    // Write your code here.\n    std::string result=sentence;\n\
    \    for(int i=0;i<sentence.length();i++){\n        for(int j=i+1;j<sentence.length();j++){\n\
    \            for(int k=0;k<sentence.length();k++){\n                for(int l=0;l<sentence.length();l++){\n\
    \                    int n=0;\n                    for(int x=0;x<sentence.length();x++){\n\
    \                        if((sentence.at(x)==sentence.at(k)&&sentence.at(x)==sentence.at(l)&&sentence.at(x)==sentence.at(j)))\n\
    \                            n++;\n                    }\n                   \
    \ if(n%2==0)\n                        result+=sentence.at(i);\n              \
    \  }\n            }\n        }\n    }\n    return result;", "    std::string ret;\n\
    \    int maxWordLen;\n    bool flag;\n    for (size_t i = 0; i < sentence.length();\
    \ i++) {\n        if (sentence[i] >= 'a' && sentence[i] <= 'z') {\n          \
    \  flag = false;\n            for (size_t j = i + 1; j < sentence.length(); j++)\
    \ {\n                if (sentence[i] >= 'a' && sentence[i] <= 'z' && sentence[j]\
    \ >= 'a' && sentence[j] <= 'z') {\n                    flag = true;\n        \
    \            break;\n                }\n            }\n            if (flag) {\n\
    \                ret.push_back(sentence[i]);\n                maxWordLen = i +\
    \ 1;\n            }\n        }\n    }\n    for (int i = 1; i < maxWordLen; i++)\
    \ {\n        for (int j = i + 1; j <= maxWordLen; j++) {\n            if (i !=\
    \ j && std::gcd(i, j) == 1) {\n                ret.push_back(i);\n           \
    \     ret.push_back(j);\n                maxWordLen = maxWordLen + 1;\n      \
    \      }\n        }\n    }\n    return ret;", "    //  Write your code here.\n\
    \    std::set<std::string> s;\n    std::string str = sentence;\n    for(char c:str)\n\
    \    {\n        s.add(c);\n    }\n    std::string ans=\"\";\n    for(auto it:s)\n\
    \    {\n        if(!(s.find(it+\" \")==s.end()&&s.find(it+\" \")+1!=s.end()&&s.find(it+\"\
    \ \")-1!=s.end()))\n        {\n            ans += it + \" \";\n        }\n   \
    \ }\n    return ans;", "    assert(sentence.find_first_of(\" \") == std::string::npos);\n\
    \    std::string result{};\n    // find how many chars are in the sentence\n \
    \   int chars_len = sentence.length();\n    // find the lengths of each prime\
    \ number\n    std::vector<int> prime_lengths;\n    int next_length = 2;\n    while\
    \ (next_length <= chars_len) {\n        if (chars_len % (next_length * next_length)\
    \ == 0) {\n            prime_lengths.push_back(next_length);\n            next_length\
    \ += 2;\n        }\n        next_length += 1;\n    }\n    assert(next_length <\
    \ chars_len);\n    int current_len = 0;\n    // go through the prime numbers backwards\n\
    \    while (current_len < prime_lengths.size()) {\n        int index = 0;\n  \
    \      // for each prime number, find the number of consecutive letters of that\
    \ number\n        // starting from the current position\n        while (index\
    \ < prime_lengths[current_len] && index < chars_len) {\n            if (sentence[index]\
    \ == ' ') {\n                index++;\n            }\n            index++;\n \
    \       }\n        // copy the words from the sentence\n        while (index <\
    \ chars_len && index < prime_lengths[current_len]) {\n            result += sentence[index];\n\
    \            index++;\n        }\n        // add the space\n        result +=\
    \ ' ';\n        // increment the current length\n        current_len++;\n    }\n\
    \    // if there are not spaces, append the last word\n    if (chars_len > 0 &&\
    \ sentence[chars_len - 1] != ' ') {\n        result += sentence[chars_len - 1];\n\
    \    }\n    return result;", "    char spaces[100];\n    std::string ret = \"\"\
    ;\n    int len = strlen(sentence);\n    for (int i = 0; i < len; i++) {\n    \
    \    spaces[i] = sentence[i];\n    }\n    for (int i = 2; i < len; i++) {\n  \
    \      if (!isPrime(len - i)) {\n            for (int j = 0; j < i; j++) {\n \
    \               spaces[j] = spaces[j + 1];\n            }\n            break;\n\
    \        }\n    }\n    for (int i = 0; i < len; i++) {\n        if (ret.length()\
    \ != 0 && ret != spaces[i]) {\n            ret += \" \";\n        }\n        ret\
    \ += spaces[i];\n    }\n    return ret;", "    // Write your code here\n    std::string\
    \ res;\n    std::string words = \"\";\n    for (auto it=sentence.begin();it!=sentence.end();it++)\
    \ {\n        if(isalpha(*it)) {\n            words += *it;\n        }\n      \
    \  else if(words.size() > 0) {\n            res += \" \" + words;\n          \
    \  words = \"\";\n        }\n    }\n    if(words.size() > 0) {\n        res +=\
    \ \" \" + words;\n    }\n    return res;", "    // write your code here\n    int\
    \ n = sentence.length();\n    vector<string> res;\n    int prime;\n    for(int\
    \ i=0;i<n;++i){\n        prime = 1;\n        int index = i;\n        while(index>0){\n\
    \            if(index%prime==0){\n                res.push_back(sentence.substr(i,prime));\n\
    \                break;\n            }\n            prime+=2;\n            index-=prime;\n\
    \        }\n    }\n    return res[0];\n    ", "    std::vector<std::string> words;\n\
    \    std::stringstream ss(sentence);\n    std::string item;\n    while (std::getline(ss,\
    \ item, ' ')) {\n        words.push_back(item);\n    }\n    sort(words.begin(),\
    \ words.end());\n    std::vector<size_t> primes;\n    for (size_t i = 0; i < words.size();\
    \ i++) {\n        if (primes.find(i) == primes.end()) {\n            primes.push_back(i);\n\
    \            bool flag = true;\n            for (size_t j = 0; j < primes.size()\
    \ - 1; j++) {\n                if (i % primes[j] == 0) {\n                   \
    \ flag = false;\n                    break;\n                }\n            }\n\
    \            if (flag == true) {\n                primes.insert(primes.begin()\
    \ + i, primes.begin() + i + 2);\n            }\n        }\n    }\n    std::string\
    \ result;\n    for (auto i : primes) {\n        result += words[i];\n    }\n \
    \   return result;", "    std::stack<std::string> s;\n    std::string word;\n\
    \    int n = 0, p = 1;\n    for (auto &c : sentence) {\n        if (c == '.')\
    \ {\n            while (s.empty() || (s.top() != word)) {\n                s.pop();\n\
    \            }\n            s.push(word);\n        }\n        else if (c != '\
    \ ') {\n            s.push(c);\n        }\n        else {\n            while (!s.empty()\
    \ && s.top() != word) {\n                s.pop();\n            }\n           \
    \ s.push(word);\n        }\n        ++p;\n        word = \"\";\n    }\n    while\
    \ (!s.empty()) {\n        word = s.top();\n        s.pop();\n        n = 1;\n\
    \        while (n % p == 0) {\n            ++n;\n        }\n        s.push(word);\n\
    \    }\n    return s;", "    // code here\n    return sentence;", "    // Your\
    \ code here\n    std::unordered_map<char,int> m;\n    int prime;\n    for(auto\
    \ c:sentence){\n        m[c]=m[c]+1;\n    }\n    prime=1;\n    for(auto c:m){\n\
    \        if(c[1]==0){\n            prime=1;\n            if(c[0]!=' ') prime=0;\n\
    \            break;\n        }\n        prime=2;\n        for(int i=2;i*i<c[1]&&prime<c[1];\
    \ ++i){\n            if(c[0]==' ') prime++;\n            if(c[i]==' ') prime++;\n\
    \        }\n        if(prime==c[1]) break;\n    }\n    std::string r=\"\";\n \
    \   for(auto c:sentence){\n        if(m[c]==1)\n            r+=c;\n    }\n   \
    \ return r;", "    int n = 0, k = 0;\n    std::string res = \"\";\n    for (int\
    \ i = 0; i < sentence.size(); i++) {\n        if (k == 0) {\n            res +=\
    \ sentence[i];\n        } else if (k % 2 == 0) {\n            res += \" \" + sentence[i];\n\
    \        } else {\n            res += sentence[i];\n        }\n        k++;\n\
    \        if (k == n) {\n            k = 0;\n            n++;\n        }\n    }\n\
    \    return res;", "    std::stack<char> s;\n    for (char c: sentence) s.push(c);\n\
    \    std::string newsentence;\n    while (!s.empty()) {\n        char c = s.top();\n\
    \        if (c != ' ') newsentence.push_back(c);\n        if (s.empty()) break;\n\
    \        s.pop();\n    }\n    return newsentence;", "    std::string temp;\n \
    \   std::sort(sentence.begin(), sentence.end());\n    for (auto i = sentence.begin();\
    \ i != sentence.end(); i++) {\n        temp.push_back(*i);\n    }\n    int temp2\
    \ = std::count(temp.begin(), temp.end(), ' ');\n    temp = temp.replace((temp2\
    \ - 1), temp2, \"\");\n    int temp3 = std::count(temp.begin(), temp.end(), '\
    \ ');\n    while (temp3 == temp2) {\n        temp += \" \";\n        temp2 +=\
    \ 2;\n    }\n    std::string res = temp;\n    std::sort(res.begin(), res.end());\n\
    \    return res;", "    std::string res;\n    for (auto c : sentence) {\n    \
    \    if (isalpha(c)) {\n            if (!res.empty()) {\n                std::cout\
    \ << \" \";\n            }\n            if (res.length() == 1) {\n           \
    \     res += c;\n            } else {\n                std::string tmp = (res\
    \ + \" \" + c);\n                bool isPrime = true;\n                for (int\
    \ i = 2; i <= (res.length() + 1) / 2; i++) {\n                    if (tmp.length()\
    \ % i == 0) {\n                        isPrime = false;\n                    \
    \    break;\n                    }\n                }\n                if (isPrime)\
    \ {\n                    res += c;\n                }\n            }\n       \
    \ } else {\n            std::cout << c;\n        }\n    }\n    std::cout << std::endl;\n\
    \    return res;", "    int n = sentence.length();\n    int ans = 1, counter =\
    \ 1;\n    // int flag = 1;\n    // for (int i = 0; i < n; i++) {\n    //     if\
    \ (sentence[i] == '(') {\n    //         // flag = 0;\n    //         counter\
    \ = 1;\n    //         if (ans == 1 && counter == 1) ans = n;\n    //        \
    \ if (counter == n - 1) ans = 1;\n    //         // flag = 1;\n    //     } else\
    \ if (sentence[i] == ')') {\n    //         if (flag == 1 && counter == 1) counter\
    \ = n;\n    //         if (counter == n - 1) counter = 1;\n    //     }\n    //\
    \ }\n    // for (int i = 0; i < n; i++) {\n    //     if (i == n - 1 || sentence[i]\
    \ == ' ') {\n    //         // flag = 1;\n    //         if (ans == 1 && counter\
    \ == 1) ans = n;\n    //         if (counter == n - 1) ans = 1;\n    //      \
    \   // flag = 1;\n    //     }\n    // }\n    for (int i = 0; i < n; i++) {\n\
    \        bool flag = true;\n        for (int j = 0; j < n; j++) {\n          \
    \  if (sentence[j] == ' ') {\n                flag = false;\n            }\n \
    \       }\n        if (flag == true) {\n            if (counter == 1 && ans ==\
    \ 1 && counter == n) ans = n;\n            if (counter == n - 1 && ans == 1 &&\
    \ counter == n) ans = 1;\n        }\n        counter++;\n    }\n    // for (int\
    \ i = 0; i < n; i++) {\n    //     if (sentence[i] == ' ') {\n    //         if\
    \ (ans == 1 && counter == 1) ans = n;\n    //         if (counter == n - 1) ans\
    \ = 1;\n    //     }\n    // }\n    return sentence;", "    // Write your code\
    \ here\n    // Complete the function\n    std::stringstream ss(sentence);\n  \
    \  std::string word;\n    int i = 0;\n    while(ss >> word)\n    {\n        std::cout\
    \ << i << std::endl;\n        std::cout << word << std::endl;\n        i++;\n\
    \    }\n    return word;", "    std::map<char,int> countmap;\n    std::string\
    \ ans;\n    for( int i = 0;i < sentence.size();++i){\n        countmap[sentence[i]]++;\n\
    \    }\n    for( std::map<char,int>::iterator itr = countmap.begin();itr != countmap.end();++itr){\n\
    \        if(!itr->second)\n            ans.push_back(itr->first);\n    }\n   \
    \ return ans;", "    std::string result;\n    int N = sentence.length();\n   \
    \ char buff[100];\n    memset(buff, 0, sizeof(buff));\n    for (int i = 0; i <\
    \ N; i++) {\n        char c = sentence[i];\n        if (c == ' ') {\n        \
    \    // Find prime number in buff\n            int index = 0;\n            while\
    \ (buff[index] != 0) {\n                index++;\n            }\n            if\
    \ (index != 0) {\n                result += buff;\n                memset(buff,\
    \ 0, sizeof(buff));\n            }\n        } else {\n            buff[strlen(buff)++]\
    \ = c;\n        }\n    }\n    if (buff[strlen(buff)] != 0) {\n        result +=\
    \ buff;\n    }\n    return result;", "    std::string new_sentence = \"\";\n \
    \   // Write your code here.\n    std::vector<std::string> words;\n    for (auto\
    \ &word: sentence){\n        words.push_back(word);\n    }\n    for (int i = 2;\
    \ i < 100; i++){\n        bool found = false;\n        for (auto &word: words){\n\
    \            int a = std::sqrt(word.size());\n            if (word.size() == i\
    \ && std::equal(word.begin(), word.end(), words.begin())){\n                new_sentence.append(\"\
    \ \"+word);\n                found = true;\n                break;\n         \
    \   }\n        }\n        if (!found){\n            std::cout << \"Found no string\
    \ with length \" << i << \" in the list\" << std::endl;\n            break;\n\
    \        }\n    }\n    return new_sentence;", "  int ans = 0, n = sentence.length();\n\
    \  unordered_set<string> data;\n  string an = \"\";\n  for (int i = 0; i < n;\
    \ i++) {\n    if (sentence.at(i) == ' ') {\n      data.insert(an);\n      an =\
    \ \"\";\n    } else {\n      an += sentence.at(i);\n    }\n  }\n  for (auto const\
    \ &word : data) {\n    if (word != \" \") {\n      ans++;\n    }\n  }\n  string\
    \ res;\n  for (auto const &word : data) {\n    if (word == \" \") {\n      ans\
    \ += 2;\n      an = word;\n    } else {\n      ans += word.length();\n    }\n\
    \  }\n  ans -= an.length();\n  if (ans % 2 == 0) {\n    res = \"even\";\n  } else\
    \ {\n    res = \"odd\";\n  }\n  return res;", "    vector<int> prime_numbers;\n\
    \    for (auto &word : sentence) {\n        auto it = std::find(prime_numbers.begin(),\
    \ prime_numbers.end(), word.size());\n        if (it == prime_numbers.end()) {\n\
    \            prime_numbers.push_back(word.size());\n        }\n    }\n    // sort\
    \ prime numbers from smallest to largest\n    std::sort(prime_numbers.begin(),\
    \ prime_numbers.end(), std::greater<int>());\n    // append first prime number\
    \ to the new string\n    prime_numbers[0] = \"is\";\n    return std::accumulate(prime_numbers.begin(),\
    \ prime_numbers.end(), std::string());", "    std::string result;\n    int n =\
    \ count_words(sentence);\n    prime_factors(n);\n    std::vector<int> nums(n);\n\
    \    for (int i = 0; i < n; ++i)\n    {\n        nums[i] = count_words(sentence\
    \ + \" \" + std::to_string(i));\n    }\n    for (int i = 0; i < n; ++i)\n    {\n\
    \        if (nums[i] > 0)\n        {\n            for (int j = i; j < n; ++j)\n\
    \            {\n                if (nums[j] % nums[i] == 0)\n                {\n\
    \                    std::swap(nums[i], nums[j]);\n                }\n       \
    \     }\n        }\n    }\n    std::sort(nums.begin(), nums.end());\n    for (int\
    \ i = 0; i < n; ++i)\n    {\n        result += \" \" + std::to_string(i);\n  \
    \  }\n    return result;", "    \n    std::string new_string;\n    // Write your\
    \ code here.\n    \n    new_string = sentence;\n    // String builder \n    std::stack<std::string>\
    \ stack_word;\n    // std::stack \n    std::string word;\n    // Stack word\n\
    \    \n    // For each word in the sentence\n    // Pop each word from the stack\n\
    \    // if there is a word popped from stack\n    // add it to the result and\
    \ push it back\n    // else push the word into stack\n    \n    // While there\
    \ is a word in the stack\n    // Keep popping each word from the stack\n    //\
    \ until there is no more word popped from the stack\n    // Add the word from\
    \ the stack to the result string\n    // push the result string back\n    \n \
    \   // While there is word in the string\n    // Keep popping each word from the\
    \ string\n    // until the word popped from the string is not\n    // the same\
    \ as the word popped from the stack\n    // push the word into the stack\n   \
    \ \n    // While the stack is not empty\n    // Keep popping each word from the\
    \ stack\n    // until the word popped from the stack is not\n    // the same as\
    \ the word popped from the string\n    // add the word popped from the stack to\
    \ the result\n    // push the result string back\n    \n    // While the string\
    \ is not empty\n    // Keep popping each word from the string\n    // until the\
    \ word popped from the string is not\n    // the same as the word popped from\
    \ the stack\n    // push the word into the stack\n    \n    while (!stack_word.empty())\
    \ {\n        // Pop each word from the stack \n        word = stack_word.top();\n\
    \        stack_word.pop();\n        // Push the word back\n        new_string\
    \ += \" \" + word;\n    }\n    while (!new_string.empty()) {\n        stack_word.push(new_string);\n\
    \        new_string.pop();\n    }\n    while (!stack_word.empty()) {\n       \
    \ word = stack_word.top();\n        stack_word.pop();\n        new_string += \"\
    \ \" + word;\n    }\n    \n    return new_string;", "    vector<std::string> temp_vec;\n\
    \    int temp;\n    int temp2;\n    // Your code goes here\n    \n    for(int\
    \ i=0;i<sentence.size();i++){\n        temp_vec.push_back(sentence.substr(i,1));\n\
    \    }\n    \n    for(int i=0;i<temp_vec.size();i++){\n        for(int j=i+1;j<temp_vec.size();j++){\n\
    \            for(int k=0;k<temp_vec.size();k++){\n                if(i==j||j==k){\n\
    \                    continue;\n                }\n                if(temp_vec[i]==temp_vec[j]&&temp_vec[i]==temp_vec[k]){\n\
    \                    if(temp==temp_vec[j].length()){\n                       \
    \ temp2=temp_vec[k].length();\n                        temp=temp2+temp;\n    \
    \                }\n                    else{\n                        temp2=temp_vec[j].length();\n\
    \                        temp=temp2+temp;\n                    }\n           \
    \     }\n            }\n        }\n    }\n    \n    for(int i=0;i<temp_vec.size();i++){\n\
    \        for(int j=i+1;j<temp_vec.size();j++){\n            for(int k=j+1;k<temp_vec.size();k++){\n\
    \                if(i==j||j==k||k==i){\n                    continue;\n      \
    \          }\n                if(temp_vec[i]==temp_vec[j]&&temp_vec[i]==temp_vec[k]){\n\
    \                    if(temp==temp_vec[j].length()){\n                       \
    \ temp2=temp_vec[k].length();\n                        temp=temp2+temp;\n    \
    \                }\n                    else{\n                        temp2=temp_vec[j].length();\n\
    \                        temp=temp2+temp;\n                    }\n           \
    \     }\n            }\n        }\n    }\n    \n    for(int i=0;i<temp_vec.size();i++){\n\
    \        if(temp==temp_vec[i].length()){\n            temp_vec.erase(temp_vec.begin()+i);\n\
    \        }\n    }\n    \n    temp_vec.erase(std::unique(temp_vec.begin(), temp_vec.end()),\
    \ temp_vec.end());\n    \n    return \" \";\n    \n    ", "    std::vector<std::string>\
    \ res;\n    auto temp = sentence.begin(), end = sentence.end();\n    auto it =\
    \ temp.begin();\n    while (it != end)\n    {\n        if (find(res.begin(), res.end(),\
    \ (*it)) != res.end())\n            continue;\n        for (int i = 2; i <= (*it\
    \ % 10); i++) {\n            int count = 0;\n            while (temp != end) {\n\
    \                if (*temp % i == 0) {\n                    temp++;\n        \
    \            count++;\n                    break;\n                }\n       \
    \         temp++;\n            }\n            if (count <= 1) {\n            \
    \    res.push_back(*it);\n            }\n        }\n        ++it;\n    }\n   \
    \ return res;", "  std::stack<bool> st;\n  for (const auto &c : sentence)\n  \
    \  if (c != ' ' && !st.empty() && st.top())\n      st.top() = false;\n    else\n\
    \      st.push(false);\n  std::stack<bool> tmp;\n  std::string res;\n  tmp.pop();\n\
    \  while (!st.empty()) {\n    res += tmp.top() ? st.top() : ' ';\n    tmp.pop();\n\
    \    while (!tmp.empty() && tmp.top() == false && !st.empty()) {\n      res +=\
    \ ' ';\n      tmp.pop();\n    }\n    st.pop();\n  }\n  reverse(std::begin(res),\
    \ std::end(res));\n  return res;", "  std::stack<std::pair<int, int> > st;\n \
    \ for (auto i : sentence) {\n    if (std::isalpha(i)) {\n      int l = i, len\
    \ = 2;\n      while (std::isalpha(l)) {\n        len++;\n        l = sentence[--i];\n\
    \      }\n      st.emplace(len, i);\n    }\n  }\n  std::stack<std::pair<int, int>\
    \ > new_st;\n  while (!st.empty()) {\n    st.top().second += 2;\n    if (new_st.empty()\
    \ || (st.top().first != new_st.top().first)) {\n      new_st.emplace(st.top().first,\
    \ st.top().second);\n    } else {\n      new_st.emplace(st.top().first, st.top().second\
    \ + st.top().first);\n    }\n    st.pop();\n  }\n  std::string res;\n  while (!new_st.empty())\
    \ {\n    res += new_st.top().second;\n    new_st.pop();\n  }\n  return res;",
  "    int N = sentence.size(); // size of the sentence\n    int p = 1; // prime factor\n\
    \    std::string ans = \"\"; // result string\n    int k = 0; // kth prime number\n\
    \    \n    for (int i = 0; i < N; i++) {\n        std::cout << i << \" : \" <<\
    \ sentence[i] << std::endl;\n        \n        for (int j = i + 1; j < N; j++)\n\
    \            if (p % sentence[i] == 0) {\n                k++;\n             \
    \   p = p / sentence[i];\n            }\n        \n        // if kth prime number\
    \ not yet found, add another number\n        if (k >= 2 * N) {\n            p++;\n\
    \            k = 0;\n        }\n        \n        ans += \" \" + sentence[i];\n\
    \    }\n    return ans.substr(2);", "  int n = std::count_if(sentence.begin(),\
    \ sentence.end(), [] (char c){return (c >= 'a' && c <= 'z') || (c >= 'A' && c\
    \ <= 'Z');});\n  std::string ans = \"\";\n  for(int i=2; i<=n; i++){\n    for(int\
    \ j=i*i; j<=n; j+=i){\n      if(j>n) break;\n      if(j == n) ans = ans + \" \"\
    ;\n      else\n        ans = ans + sentence[j];\n    }\n  }\n  return ans;", " \
    \   vector<string> temp;\n    for(int i = 0; i < sentence.size(); i++) {\n   \
    \     temp.push_back(sentence[i]);\n    }\n    for(int i = 1; i < temp.size()\
    \ - (temp.size() / i); i++) {\n        if(!is_prime(i)) {\n            temp.erase(temp.begin()\
    \ + i);\n            i += 2;\n        }\n    }\n    vector<string> ans;\n    for(auto\
    \ it = temp.begin(); it != temp.end(); ++it) {\n        if(is_prime(*it)) {\n\
    \            ans.push_back(*it);\n        }\n    }\n    \n    return \" \".join(ans);",
  "  std::set<char> prime_char_set;\n  for (const auto c : sentence) {\n    prime_char_set.insert(c);\n\
    \  }\n  std::string words;\n  std::string remaining = sentence;\n  for (auto it\
    \ = remaining.cbegin(); it != remaining.cend(); ++it) {\n    if (prime_char_set.find(*it)\
    \ == prime_char_set.end()) {\n      remaining.erase(remaining.begin(), remaining.begin()\
    \ + 1);\n    }\n  }\n  for (int i = 1; i <= 100; i++) {\n    if (remaining.find(i)\
    \ == remaining.cend()) {\n      words.push_back(i);\n    }\n  }\n  return words;",
  "    \n    vector<string> tokens;\n    \n    for (auto it = sentence.begin(); it\
    \ != sentence.end(); it++) {\n        if (*it == ' ' || (it - sentence.begin())\
    \ % 2 == 0) {\n            tokens.push_back(*it);\n        }\n    }\n    \n  \
    \  string res;\n    for (auto it = tokens.begin(); it != tokens.end(); it++) {\n\
    \        size_t size = 2;\n        \n        while (*it == '#') {\n          \
    \  size++;\n            it++;\n        }\n        \n        if (size % 2 != 0)\
    \ {\n            size++;\n        }\n        \n        bool is_prime = true;\n\
    \        int temp = size;\n        while (temp % 2 != 0) {\n            temp =\
    \ temp / 2;\n        }\n        \n        for (int i = 1; i <= temp; i++) {\n\
    \            if (size == i || size == i - 1 || size == i * i || size == i * i\
    \ - 1) {\n                is_prime = false;\n                break;\n        \
    \    }\n        }\n        \n        if (is_prime) {\n            res += *it;\n\
    \        }\n    }\n    \n    return res;", "  // write your code here\n  \n  std::unordered_set<int>\
    \ primes;\n  for (auto c : sentence)\n    primes.insert(c);\n\n  int n = sentence.size();\n\
    \  std::unordered_set<int> ans;\n\n  for (int i = 0; i <= n; i++) {\n    if (primes.find(i)\
    \ == primes.end()) {\n      ans.insert(i);\n    }\n  }\n\n  return std::to_string(ans.begin(),\
    \ ans.end());", "    \n    std::stack<std::string> s;\n    std::string result;\n\
    \    s.push(sentence);\n    while (!s.empty()) {\n        std::string x = s.top();\n\
    \        result.append(x);\n        s.pop();\n        for (auto c : x) {\n   \
    \         if (!isupper(c)) {\n                s.push(x);\n                s.emplace(x\
    \ + \" \" + c);\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + \" \");\n                s.emplace(x + \" \"\
    \ + c + \" \");\n                s.emplace(x + \" \" + c + \" \");\n         \
    \       s.emplace(x + \" \" + c + ", "  std::set<std::string> words;\n  std::string\
    \ temp = \"\";\n  for (auto it = sentence.begin(); it != sentence.end(); ++it)\
    \ {\n    std::string new_word = \"\";\n    for (auto it_it = it; it_it != sentence.end();\
    \ it_it++) {\n      new_word += *it_it;\n    }\n    new_word = new_word.substr(0,\
    \ new_word.size() - 1);\n    words.insert(new_word);\n  }\n  for (auto it = words.begin();\
    \ it != words.end(); ++it) {\n    temp = temp + \" \" + std::to_string(std::sqrt(std::inner_product(std::begin(sentence),\
    \ std::end(sentence), std::begin(*it), 0ll, std::multiplies<std::string>())) +\
    \ 1);\n  }\n  return temp;", "    \n    // your code goes here\n    std::string\
    \ ans = \"\";\n    std::set<int> primes;\n    for(int i = 0; i < sentence.length();\
    \ i++)\n    {\n        int x = sentence[i] - 'a';\n        while(!primes.find(x))\n\
    \        {\n            primes.insert(x);\n            x++;\n            if(x%2\
    \ != 0 && x%3 != 0 && x%5 != 0 && x%7 !=0 && x%11 !=0 && x%13 !=0 && x%17 !=0\
    \ && x%19 !=0 && x%23 !=0 && x%29 !=0)\n            {\n                ans+=x;\n\
    \            }\n        }\n    }\n    return ans;", "    std::vector<int> v;\n\
    \    v.push_back(1);\n    v.push_back(2);\n    v.push_back(3);\n    v.push_back(5);\n\
    \    v.push_back(7);\n    v.push_back(11);\n    v.push_back(13);\n    v.push_back(17);\n\
    \    v.push_back(19);\n    v.push_back(23);\n    v.push_back(29);\n    v.push_back(31);\n\
    \    v.push_back(37);\n    v.push_back(53);\n    v.push_back(59);\n    v.push_back(61);\n\
    \    v.push_back(67);\n    v.push_back(71);\n    v.push_back(73);\n    v.push_back(79);\n\
    \    v.push_back(83);\n    v.push_back(89);\n    v.push_back(97);\n    v.push_back(101);\n\
    \    v.push_back(103);\n    v.push_back(107);\n    v.push_back(109);\n    v.push_back(113);\n\
    \    v.push_back(127);\n    v.push_back(131);\n    v.push_back(137);\n    v.push_back(139);\n\
    \    v.push_back(143);\n    v.push_back(147);\n    v.push_back(151);\n    v.push_back(157);\n\
    \    v.push_back(163);\n    v.push_back(167);\n    v.push_back(173);\n    v.push_back(179);\n\
    \    v.push_back(181);\n    v.push_back(191);\n    v.push_back(193);\n    v.push_back(197);\n\
    \    v.push_back(199);\n    v.push_back(203);\n    v.push_back(211);\n    v.push_back(221);\n\
    \    v.push_back(223);\n    v.push_back(227);\n    v.push_back(229);\n    v.push_back(233);\n\
    \    v.push_back(239);\n    v.push_back(241);\n    v.push_back(251);\n    v.push_back(257);\n\
    \    v.push_back(263);\n    v.push_back(269);\n    v.push_back(271);\n    v.push_back(277);\n\
    \    v.push_back(281);\n    v.push_back(283);\n    v.push_back(293);\n    v.push_back(301);\n\
    \    v.push_back(307);\n    v.push_back(311);\n    v.push_back(313);\n    v.push_back(317);\n\
    \    v.push_back(331);\n    v.push_back(337);\n    v.push_back(347);\n    v.push_back(349);\n\
    \    v.push_back(353);\n    v.push_back(359);\n    v.push_back(367);\n    v.push_back(373);\n\
    \    v.push_back(379);\n    v.push_back(383);\n    v.push_back(389);\n    v.push_back(397);\n\
    \    v.push_back(401);\n    v.push_back(409);\n    v.push_back(419);\n    v.push_back(431);\n\
    \    v.push_back(433);\n    v.push_back(", "  std::unordered_map<std::string,\
    \ int> primes;\n  std::unordered_map<std::string, int> primes_reverse;\n  std::unordered_map<std::string,\
    \ int> reverse_primes;\n  std::unordered_map<std::string, int> reverse_primes_reverse;\n\
    \  // Write your code here.\n  for (int i = 0; i < sentence.length(); ++i) {\n\
    \    auto it = primes.find(sentence.substr(i, 1));\n    if (it != primes.end())\
    \ {\n      primes[sentence.substr(i, 1)] = it->second;\n      reverse_primes[it->second]\
    \ = sentence.substr(i, 1);\n    } else {\n      primes[sentence.substr(i, 1)]\
    \ = 1;\n      reverse_primes[1] = sentence.substr(i, 1);\n    }\n  }\n  for (int\
    \ i = 1; i < 100; ++i) {\n    auto it = primes_reverse.find(reverse_primes[i -\
    \ 1]);\n    if (it != primes_reverse.end()) {\n      primes_reverse[iter->second]\
    \ = i;\n      reverse_primes_reverse[i] = reverse_primes[i - 1];\n    } else {\n\
    \      primes_reverse[iter->second] = i;\n      reverse_primes_reverse[i] = reverse_primes[1];\n\
    \    }\n  }\n  std::vector<std::string> ret;\n  std::string word;\n  bool in =\
    \ false;\n  for (int i = 1; i < 100; ++i) {\n    if (primes[i] == 0) {\n     \
    \ in = true;\n    }\n    if (primes_reverse[i] == i) {\n      continue;\n    }\n\
    \    if (reverse_primes_reverse[i] == i) {\n      in = false;\n    }\n    if (!in)\
    \ {\n      continue;\n    }\n    ret.push_back(word);\n    word = \"\";\n  }\n\
    \  return ret;", "    std::string s;\n    for (char &i : sentence) {\n       \
    \ if (i.isupper()) {\n            s += \" \";\n        }\n        s += i;\n  \
    \  }\n    std::string ans = \"\";\n    ans = s.substr(1, s.length() - 1);\n  \
    \  int sum = 0;\n    for (int i = 0; i < ans.length(); i++) {\n        int k =\
    \ ans.find(\" \");\n        while (k != std::string::npos) {\n            int\
    \ l = ans.length() - 1;\n            k = ans.find(\" \", k + 1);\n           \
    \ if (l != k) {\n                ans = ans.substr(0, k) + \" \" + ans.substr(k\
    \ + 1, l);\n            }\n        }\n        sum += i;\n    }\n    while (sum\
    \ > 2) {\n        if (sum % 2 == 0) {\n            ans += \"1\";\n           \
    \ sum = sum / 2;\n        } else {\n            ans += \"0\";\n            sum\
    \ = 3 * sum + 1;\n        }\n    }\n    return ans;", "    std::vector<int> primeNumbers(10000,\
    \ 1);\n    primeNumbers[0] = 1;\n    primeNumbers[1] = 1;\n    for (auto &word:\
    \ sentence) {\n        int sum = 0;\n        for (auto &n: primeNumbers) {\n \
    \           sum += n;\n            if (sum > word.size()) {\n                break;\n\
    \            }\n            if (word > sum) {\n                sum = word;\n \
    \               break;\n            }\n        }\n        primeNumbers[sum]++;\n\
    \    }\n    std::vector<int> newV;\n    newV.reserve(primeNumbers.size());\n \
    \   for (auto &v: primeNumbers) {\n        newV.push_back(v);\n    }\n    std::reverse(newV.begin(),\
    \ newV.end());\n    std::string result;\n    int sum = 0;\n    for (auto &v: newV)\
    \ {\n        if (sum >= word.size()) {\n            break;\n        }\n      \
    \  sum += v;\n        result.push_back(word[sum - 1]);\n    }\n    return result;",
  "  int n = strlen(sentence.c_str());\n  int counter = 1;\n  std::string result =\
    \ \"\";\n  for (int i = 0; i < n; ++i) {\n    if (counter % i == 0) {\n      result\
    \ += sentence[i];\n    }\n    counter++;\n  }\n  return result;", "    std::vector<std::string>\
    \ words;\n    std::string word;\n    for (auto c : sentence) {\n        if (c\
    \ == ' ' || c == ',' || c == '.' || c == '!' || c == '?') {\n            word\
    \ = word + c;\n        }\n        else {\n            words.push_back(word);\n\
    \            word = \"\";\n        }\n    }\n    words.push_back(word);\n    std::string\
    \ ans;\n    for (int i = 0; i < words.size(); i++) {\n        std::sort(words.begin(),\
    \ words.end());\n        ans = ans + words[i];\n    }\n    std::sort(words.begin(),\
    \ words.end());\n    return ans;", "    // write your code here\n    \n    int\
    \ start = 0;\n    int end = 0;\n    \n    while(start < sentence.length()){\n\
    \        end = sentence.length();\n        while(start < end){\n            if(isPrime(end\
    \ - start)){\n                \n                std::string new_word(sentence.substr(start,end-start));\n\
    \                \n                std::cout << new_word;\n                \n\
    \                start = end + 1;\n                \n            }\n         \
    \   else{\n                end--;\n            }\n        }\n        start++;\n\
    \    }\n    \n    return \"\";\n    ", "    std::sort(sentence.begin(), sentence.end());\n\
    \    std::string ans = sentence;\n    bool flag = true;\n    for(int i = 0; i\
    \ < sentence.length(); i++) {\n        bool flag2 = true;\n        for(int j =\
    \ 0; j < ans.length(); j++) {\n            bool flag3 = true;\n            for(int\
    \ k = j + 1; k < ans.length(); k++) {\n                if(ans[j] != ans[k]) {\n\
    \                    flag3 = false;\n                }\n            }\n      \
    \      if(!flag3) {\n                flag2 = false;\n                break;\n\
    \            }\n        }\n        if(flag2) {\n            ans = ans.substr(0,\
    \ i);\n            break;\n        }\n    }\n    return ans;", "    assert(!sentence.empty());\n\
    \    std::string res;\n    for (int i = 0; i < sentence.length(); i++) {\n   \
    \     auto itr = find(sentence.begin(), sentence.end(), ' ');\n        if (itr\
    \ != sentence.end()) {\n            for (int j = 1; j <= itr - sentence.begin();\
    \ j++) {\n                char c = sentence[itr - j];\n                if (!isdigit(c))\
    \ {\n                    res.push_back(c);\n                }\n            }\n\
    \        }\n    }\n    return res;", "    // Write your code here\n    std::string\
    \ words = \"\\\\w\";\n    std::string result = \"\";\n    for (size_t i = 0; i\
    \ < sentence.length(); i++) {\n        if (isalpha(sentence[i])) {\n         \
    \   result += sentence[i];\n        }\n    }\n    for (size_t i = 0; i < result.length();\
    \ i++) {\n        std::string check;\n        for (size_t j = 0; j < words.length();\
    \ j++) {\n            check += words[j];\n        }\n        result += (result.length()\
    \ - check.length()) / words.length();\n    }\n    return result;", "    int n\
    \ = 1, res = 0;\n    // use string instead of array\n    std::string words = \"\
    a b c d e f g h i j k l m n o p q r s t u v w x y z\".split(\" \");\n    while\
    \ (n <= 100) {\n        std::set<int> s;\n        for (int i = 0; i < sentence.length();\
    \ i++) {\n            s.insert(words[sentence.at(i)-97]);\n        }\n       \
    \ for (int i = 0; i < s.length(); i++) {\n            if (s.count(i)) {\n    \
    \            res++;\n            }\n        }\n        if (res == n) {\n     \
    \       return words;\n        }\n        n++;\n    }\n    return \"No such solution\"\
    ;", "    int ans = 0, n = sentence.length();\n    for(int i = 0; i < n; ++i) {\n\
    \        int len = 1;\n        while(i < n && sentence[i] == ' ') ++i;\n     \
    \   while(i < n && sentence[i] != ' ') ++i;\n        len += i;\n        assert(len\
    \ > 0);\n        int prime = 1;\n        while(len > 2) {\n            if(len\
    \ % 2 != 0) break;\n            prime += 2;\n            len -= 1;\n        }\n\
    \        ans += prime;\n    }\n    return std::string(ans + 1, n).substr(0, n);",
  '  ', "    std::vector<std::string> strs;\n    int N = sentence.length();\n    int\
    \ max_len = 0, len = 0, cnt = 0;\n    for (char &s : sentence) {\n        len\
    \ = s.length();\n        if (len > max_len) {\n            max_len = len;\n  \
    \      }\n        if (++cnt > N) {\n            break;\n        }\n    }\n   \
    \ strs.clear();\n    for (int i = 0; i <= max_len; ++i) {\n        for (int j\
    \ = 2 * i; j < N - i; ++j) {\n            int curr = j;\n            while (curr\
    \ + i < N && sentence[curr + i] == sentence[curr + i + 1]) {\n               \
    \ ++curr;\n            }\n            if (curr - j > 2) {\n                strs.push_back(sentence.substr(j,\
    \ curr - j));\n                cnt = N;\n            }\n        }\n    }\n   \
    \ std::string res;\n    for (auto &s : strs) {\n        res += s + \"\\n\";\n\
    \    }\n    return res;", "    std::string ans = \"\";\n    std::string current_word\
    \ = \"\";\n    for (int i = 0; i < sentence.length(); i++) {\n        if (sentence[i]\
    \ == ' ') {\n            if (!current_word.empty()) {\n                ans +=\
    \ current_word;\n                current_word = \"\";\n            }\n       \
    \ } else {\n            current_word += sentence[i];\n        }\n    }\n    if\
    \ (!current_word.empty()) {\n        ans += current_word;\n    }\n    return ans;",
  "  if(sentence.empty()){\n    return sentence;\n  }\n  assert(sentence.size()>1);\n\
    \  \n  long long cnt = 0;\n  long long res = 1;\n  \n  for(int i=0;i<sentence.size();i++){\n\
    \    long long curr = i;\n    long long next = 1;\n    long long cur = 1;\n  \
    \  long long count = 1;\n    while(curr < sentence.size()){\n      next = cur*cur;\n\
    \      if(next+1 == sentence.size()){\n        break;\n      }\n      cur++;\n\
    \      count++;\n    }\n    if(count > 1){\n      cnt += count;\n    }\n    res\
    \ = res*cur;\n  }\n  \n  return sentence.substr(cnt,1);", "    \n    std::string\
    \ result=\"\";\n    for(int i=0;i<sentence.size();i++){\n        for(int j=0;j<sentence.size();j++){\n\
    \            if(i!=j){\n                if(isPrime(sentence.at(i)+sentence.at(j))){\n\
    \                    result+=sentence.at(i);\n                    result+=sentence.at(j);\n\
    \                }\n            }\n        }\n    }\n    return result;", "  \
    \  std::string res;\n    size_t count = 0;\n    size_t len = sentence.length();\n\
    \    // check all possible prime numbers\n    for (size_t i = 0; i <= sqrt(len);\
    \ i++) {\n        if (len % i == 0) {\n            count++;\n        }\n    }\n\
    \    for (size_t i = 0; i < count; i++) {\n        char c = sentence[i];\n   \
    \     std::string temp = sentence;\n        temp.replace(0, i + 1, \"\");\n  \
    \      std::string temp1 = temp;\n        temp1.replace(i + 1, temp1.length(),\
    \ \"\");\n        temp1.replace(0, temp1.length(), \"\");\n        std::string\
    \ temp2 = temp;\n        temp2.replace(i + 1, 1, \"\");\n        temp2.replace(0,\
    \ temp2.length(), \"\");\n        temp2 = temp1 + temp2;\n        temp2.replace(i\
    \ + 1, 0, \" \");\n        temp2 = temp2.substr(1) + c;\n        temp2 = temp2.replace(i\
    \ + 1, 1, \" \");\n        temp2 = temp2.substr(1) + c;\n        temp2 = temp2.replace(i\
    \ + 1, 1, \" \");\n        temp2 = temp2.substr(1) + c;\n        temp2 = temp2.replace(i\
    \ + 1, 1, \" \");\n        temp2 = temp2.substr(1) + c;\n        temp2 = temp2.replace(i\
    \ + 1, temp2.length(), \" \");\n        temp2 = temp2.substr(1) + c;\n       \
    \ temp2 = temp2.replace(i + 1, 1, \" \");\n        temp2 = temp2.substr(1) + c;\n\
    \        temp2 = temp2.replace(i + 1, 1, \" \");\n        temp2 = temp2.substr(1)\
    \ + c;\n        temp2 = temp2.replace(i + 1, 1, \" \");\n        temp2 = temp2.substr(1)\
    \ + c;\n        temp2 = temp2.replace(i + 1, temp2.length(), \" \");\n       \
    \ temp2 = temp2.substr(1) + c;\n        temp2 = temp2.replace(i + 1, temp2.length(),\
    \ \" \");\n        temp2 = temp2.substr(1) + c;\n        temp2 = temp2.replace(i\
    \ + 1, temp2.length(), \" \");\n        temp2 = temp2.substr(1) + c;\n       \
    \ temp2 = temp2.replace(i + 1, temp2.length(), \" \");\n        temp2 = temp2.substr(1)\
    \ + c;\n        temp2 = temp2.replace(i + 1, 1, \" \");\n        temp2 = temp2.substr(1)\
    \ + c;\n        temp2 = temp2.replace(i + 1, 1, \" \");\n        temp2 = temp2.substr(1)\
    \ + c;\n        temp2 = temp2.replace(i + 1, 1, \" \");\n        temp2 = temp2.substr(1)\
    \ + c;\n        temp2 = temp2.replace(i + 1, 1, \" \");\n        temp2 = temp2.substr(1)\
    \ + c;\n        temp2 = temp2.replace(i + 1, 1, \" \");\n        temp2 = temp2.substr(1)\
    \ + c;\n        temp2 = temp2.replace(i + 1, 1, \" \");\n        temp2 = temp2.substr(1)\
    \ + c;\n        temp2 = temp2.replace(i + 1, 1, \" \");\n        temp2 = temp2.substr(1)\
    \ + c;\n        temp2 = temp2.replace(i + ", "    std::map<int, int> word_freq;\n\
    \    for (std::size_t i = 0; i < sentence.length(); ++i) {\n        std::size_t\
    \ freq = 0;\n        while (i != sentence[i]) {\n            ++freq;\n       \
    \     ++i;\n        }\n        word_freq[freq]++;\n    }\n    std::string ans\
    \ = \"\";\n    for (auto it = word_freq.begin(); it != word_freq.end(); ++it)\
    \ {\n        bool is_prime = true;\n        for (int i = 1; i < it->first; ++i)\
    \ {\n            if (it->first % i == 0) {\n                is_prime = false;\n\
    \                break;\n            }\n        }\n        if (is_prime) {\n \
    \           ans += it->first + \" \";\n        }\n    }\n    return ans;", " \
    \   // Your code here\n    std::string answer;\n    for (int i = 0; i <= sentence.length();\
    \ i++) {\n        if (isprime(i)) {\n            answer.append(sentence.substr(0,\
    \ i));\n            answer.append(\" \");\n        }\n    }\n    return answer;",
  "    std::string ans = \"\";\n    \n    for(int i = 0; i < sentence.size(); i++)\
    \ {\n        char c = sentence[i];\n        int count = 0;\n        \n       \
    \ for(char ch : ans) {\n            if(ch == ' ') break;\n            if(ch ==\
    \ c) count++;\n        }\n        if(count == 0) {\n            ans += c;\n  \
    \      }\n    }\n    \n    return ans;", "    std::string result;\n    std::stack<char>\
    \ st;\n    st.push('\\0');\n    for(auto &c:sentence) {\n        if(!st.empty())\
    \ {\n            while(st.top() != '\\0' && std::tolower(c) != std::tolower(st.top()))\n\
    \                st.pop();\n        }\n        if(std::isalpha(c)) {\n       \
    \     result += c;\n            st.push(c);\n        }\n        while(!st.empty()\
    \ && std::tolower(c) == std::tolower(st.top())) {\n            result += (st.top()\
    \ + ' ');\n            st.pop();\n        }\n    }\n    if(!st.empty())\n    \
    \    while(st.top() != '\\0')\n            st.pop();\n    return result;", " \
    \   std::string ans = \"no word\";\n    std::string str = sentence;\n    for (int\
    \ i = str.length(); i > 0; i--) {\n        bool prime = true;\n        for (int\
    \ j = i; j > (i + 1); j--) {\n            if (i % j == 0) {\n                prime\
    \ = false;\n                break;\n            }\n        }\n        if (prime)\
    \ {\n            ans = ans + \" \" + str.substr(0, i);\n        }\n    }\n   \
    \ return ans;", "    \n    bool prime[100]={0};\n    int prime_flag[100]={0};\n\
    \    std::string result;\n    for(int i=0;i<sentence.size();i++){\n        for(int\
    \ j=i;j<sentence.size();j++){\n            prime_flag[i]=false;\n            prime_flag[j]=false;\n\
    \        }\n    }\n    for(int i=0;i<sentence.size();i++){\n        prime[i]=true;\n\
    \    }\n    for(int i=0;i<sentence.size();i++){\n        if(prime[i]==true){\n\
    \            for(int j=i;j<sentence.size();j++){\n                if(prime[j]==true){\n\
    \                    if(sentence[i]==sentence[j]){\n                        prime_flag[i]=true;\n\
    \                        prime_flag[j]=true;\n                    }\n        \
    \        }\n            }\n        }\n    }\n    for(int i=0;i<sentence.size();i++){\n\
    \        if(prime_flag[i]==true){\n            result+=sentence[i];\n        }\n\
    \    }\n    return result;", "    std::vector<std::string> words;\n    std::istringstream\
    \ iss(sentence);\n    std::string word;\n    while (std::getline(iss, word, '\
    \ ')) {\n        if (std::strlen(word) == 0 || std::strlen(word) == 1) {\n   \
    \         continue;\n        }\n        words.push_back(word);\n    }\n    std::sort(words.begin(),\
    \ words.end());\n    std::string result;\n    for (auto& word : words) {\n   \
    \     std::cout << word << \" \";\n        if (std::count_if(result.begin(), result.end(),\
    \ [&](char c) { return c == word[0]; }) > 0) {\n            std::cout << word\
    \ << \" \";\n        } else {\n            result += word;\n        }\n    }\n\
    \    return result;", "    \n    // Write your code here\n    int n = sentence.length();\n\
    \    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (isalpha(sentence[i])\
    \ == 0) {\n            count++;\n        }\n    }\n    int length = 0;\n    bool\
    \ flag = true;\n    for (int i = 0; i < n; i++) {\n        if (isalpha(sentence[i])\
    \ == 0) {\n            flag = false;\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        if (isalpha(sentence[i]) == 0 && flag == true) {\n    \
    \        length++;\n        }\n    }\n    if (flag) {\n        return sentence;\n\
    \    }\n    for (int i = n - 1; i >= 0; i--) {\n        if (isalpha(sentence[i])\
    \ == 0) {\n            flag = false;\n        }\n    }\n    for (int i = n - 1;\
    \ i >= 0; i--) {\n        if (isalpha(sentence[i]) == 0 && flag == true) {\n \
    \           length--;\n        }\n    }\n    for (int i = n - 1; i >= 0; i--)\
    \ {\n        if (isalpha(sentence[i]) == 0 && flag == false) {\n            length++;\n\
    \        }\n    }\n    std::string ans;\n    int p = 1;\n    for (int i = 0; i\
    \ < n; i++) {\n        if (isalpha(sentence[i]) == 0 && flag == false) {\n   \
    \         p *= 2;\n            if (p == length) {\n                ans.push_back(sentence[i]);\n\
    \            }\n        }\n    }\n    return ans;", "    // Split sentence into\
    \ words\n    // We use a map to keep the word with its length\n    std::map<char,int>\
    \ word_length_map;\n    for(auto ch : sentence) {\n        word_length_map[ch]++;\n\
    \    }\n    \n    // Sort the map\n    // std::sort can sort a map by its keys\n\
    \    std::map<char,int>::iterator word_iter = word_length_map.begin();\n    for(auto\
    \ &kv : word_length_map) {\n        kv.second = *word_iter;\n        ++word_iter;\n\
    \    }\n    \n    // Find the smallest prime number\n    int smallest_prime =\
    \ std::sqrt(word_length_map.size());\n    \n    // Iterate through the map\n \
    \   // Use std::find instead of std::lower_bound since we need the iterator to\
    \ check if there is a key with that value\n    for(auto &kv : word_length_map)\
    \ {\n        if(std::find(word_length_map.begin(), word_length_map.end(), kv.second)\
    \ == word_length_map.end()) {\n            if(kv.second != smallest_prime) {\n\
    \                // The word is not prime\n                return {};\n      \
    \      }\n        }\n    }\n    \n    // The word is prime\n    std::vector<std::string>\
    \ words;\n    for(auto &kv : word_length_map) {\n        if(kv.second == smallest_prime)\
    \ {\n            words.push_back(kv.first);\n        }\n    }\n    return words;",
  "    \n    std::string res = \"\";\n    int n = static_cast<int>(sqrt(sentence.size()+1));\n\
    \    for (int i=2; i*i<=n; i++)\n    {\n        if (sentence.length()%i == 0)\n\
    \        {\n            int count = 0;\n            for (int j = 0; j < sentence.size();\
    \ j++)\n            {\n                if (sentence[j] == ' ')\n             \
    \   {\n                    count++;\n                }\n            }\n      \
    \      \n            if (count == i)\n            {\n                res+=sentence[i];\n\
    \            }\n        }\n    }\n    return res;", "    std::string::size_type\
    \ first, last;\n    std::vector<int> primes;\n    first = 0;\n    last = sentence.size();\n\
    \    primes.push_back(2);\n    // find primes\n    while (last - first > 1) {\n\
    \        int mid = (last + first) / 2;\n        last = mid;\n        std::string\
    \ temp(sentence, first, mid);\n        primes.push_back(std::accumulate(temp.begin(),\
    \ temp.end(), 0));\n        first = mid;\n    }\n    last = sentence.size();\n\
    \    // remove common primes\n    for (int i = 2; i < primes.size(); i++) {\n\
    \        while (last - first > 1) {\n            if (primes[i] <= primes[i - 1])\
    \ {\n                primes.erase(primes.begin() + i);\n                last--;\n\
    \                break;\n            }\n        }\n    }\n    std::string ans(\"\
    \");\n    for (int i = first; i < last; i++) {\n        while (last - first >\
    \ 1) {\n            if (primes[i] > primes[last - 1]) {\n                ans.insert(ans.end(),\
    \ sentence[first], sentence[i]);\n                last -= 1;\n               \
    \ break;\n            }\n        }\n    }\n    return ans;", "    std::string\
    \ ans;\n    std::vector<int> primes;\n    // First make a list of all primes (not\
    \ including 2 itself)\n    for(int i=3; i<100000; i+=2)\n        if(primes.push_back(i)\
    \ && i%2 != 0)\n    }\n    // Now iterate through the sentence and remove all\
    \ non-prime characters\n    // and add all primes to the output\n    for(int i=0;\
    \ i<sentence.length(); i++)\n        if(primes.back()%(int)sentence[i] == 0)\n\
    \        ans.push_back(sentence[i]);\n    return ans;", "    if (sentence.empty())\
    \ return \"()\";\n    \n    unordered_set<char> hash;\n    for(auto i : sentence)\
    \ {\n        if (hash.find(i) == hash.end()) {\n            hash.add(i);\n   \
    \     }\n    }\n    int count = 1;\n    std::string ans;\n    for (auto i : hash)\
    \ {\n        for (int j = 2; j < i; j++) {\n            if (i % j == 0) {\n  \
    \              count++;\n            }\n        }\n        if (count == i) {\n\
    \            ans += \" \" + i;\n            count = 0;\n        }\n    }\n   \
    \ return ans;", "    std::vector<std::string> arr;\n    std::string result = \"\
    \";\n    std::string temp_str;\n    int prime_number = 0;\n    std::string word;\n\
    \    for (char c : sentence)\n    {\n        temp_str = c;\n        // cin >>\
    \ temp_str;\n        for (unsigned int i = 0; i < temp_str.length(); i++)\n  \
    \      {\n            word = temp_str.substr(i, 1);\n            arr.push_back(word);\n\
    \        }\n        sort(arr.begin(), arr.end());\n        prime_number = 0;\n\
    \        int size = 0;\n        for (unsigned int i = 0; i < arr.size(); i++)\n\
    \        {\n            if (arr[i].length() > size)\n            {\n         \
    \       size = arr[i].length();\n            }\n        }\n        int i = 0;\n\
    \        int j = size;\n        for (unsigned int i = 0; i < arr.size(); i++)\n\
    \        {\n            if (arr[i].length() == size)\n            {\n        \
    \        bool prime = true;\n                for (unsigned int j = 0; j < size;\
    \ j++)\n                {\n                    if (arr[i][j] == arr[i][size -\
    \ 1])\n                    {\n                        prime = false;\n       \
    \             }\n                }\n                if (prime)\n             \
    \   {\n                    prime_number++;\n                }\n              \
    \  else\n                {\n                    break;\n                }\n  \
    \          }\n        }\n        // cout << arr[i] << \" \" << size << endl;\n\
    \        if (prime_number == size)\n        {\n            result += arr[i];\n\
    \        }\n    }\n    return result;", "    // Your code goes here\n    std::set<std::string>\
    \ set;\n    for (int i = 0; i < sentence.length(); ++i) {\n        if (set[sentence.substr(i,\
    \ 1).rbegin()->c_str()].find(sentence.substr(i, 1).begin(), sentence.substr(i,\
    \ 1).end()) == std::end()) {\n            set.insert(sentence.substr(i, 1).begin(),\
    \ sentence.substr(i, 1).end());\n        }\n    }\n    std::string result;\n \
    \   for (auto &itr : set) {\n        result += itr;\n    }\n    return result;",
  "    // code here\n    \n    \n    // your code goes here\n    \n    return ret;",
  "    std::string res;\n    int n = sentence.size();\n    for (auto &i : sentence)\
    \ {\n        int prime = 1;\n        int flag = 0;\n        for (int j = n-1;\
    \ j >= 0; j--) {\n            prime *= j;\n            if (i == sentence[j] &&\
    \ flag == 1) {\n                flag = 0;\n                break;\n          \
    \  }\n            if (i == sentence[j] && flag == 0) {\n                flag =\
    \ 1;\n                prime = 1;\n                break;\n            }\n    \
    \    }\n        res.push_back(i);\n    }\n    return res;", "    // write your\
    \ code here\n    \n    // 1. Scan the first word\n    std::string word1 = sentence.substr(0,\
    \ sentence.find(\" \"));\n\n    // 2. Scan all words in the sentence\n    std::string\
    \ word2 = word1;\n    while (!word2.empty()) {\n        int n = 2;\n        while\
    \ (word2.length() % n != 0) {\n            ++n;\n        }\n        // n is a\
    \ prime number\n        // 3. Scan all words until you find a word with length\
    \ (n-1)\n        // that is a factor (a prime number) of the current word\n  \
    \      // 4. Append this factor to the word\n        // 5. Skip to the next word\n\
    \        // 6. Repeat steps 3-5 until you reach the end of the sentence\n    \
    \    word2 += word2.substr(0, word2.length() - n) + word2.substr(word2.length()\
    \ - n, word2.length());\n        word2 = word2.substr(0, word2.length() - n);\n\
    \    }\n\n    // return the second word\n    return word1;", "  std::istringstream\
    \ iss(sentence);\n  std::string token;\n  std::string new_sentence;\n  while (std::getline(iss,\
    \ token, ' ')) {\n    if (std::all_of(token.begin(), token.end(), ::isalpha))\
    \ {\n      if (is_prime_number_string(token.length())) {\n        new_sentence\
    \ += token + ' ';\n      }\n    }\n  }\n  return new_sentence.substr(0, new_sentence.length()\
    \ - 1);", "    assert(sentence.size()<=100);\n    int ans=0;\n    std::stack<int>\
    \ s;\n    std::string ans=\"\";\n    for(int i=0;i<sentence.size();i++)\n    {\n\
    \        if(!s.empty() && s.top()%10==0)\n        {\n            ans.push_back(sentence[i]);\n\
    \            s.pop();\n        }\n        else\n        {\n            s.push(sentence[i]);\n\
    \        }\n    }\n    while(!s.empty())\n    {\n        int len=s.top()/10;\n\
    \        if(!(s.top()%10==0 && len<ans.size() && ans[len]==' '))\n        {\n\
    \            ans.push_back(s[len]);\n        }\n        s.pop();\n    }\n    return\
    \ ans;", "    std::vector<int> primes{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,\
    \ 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n    std::string res\
    \ = \"\";\n    for (auto &item : sentence) {\n        auto it = std::find(primes.begin(),\
    \ primes.end(), item % 10);\n        if (it == primes.end()) {\n            res\
    \ += item;\n        }\n    }\n    return res;", "    // Fill this in.\n    int\
    \ ans = 0;\n    for (int i = 0; i < sentence.length(); i++) {\n        if (i !=\
    \ 0 && i % 3 == 0 && i + 1 != sentence.length() && i % 5 != 0) {\n           \
    \ ans = 1;\n            break;\n        }\n    }\n    std::string res = \"\";\n\
    \    for (int i = 0; i < sentence.length(); i++) {\n        if (i != 0 && i %\
    \ 3 == 0 && i + 1 != sentence.length() && i % 5 != 0) {\n            res += sentence.substr(i,\
    \ 3) + \" \";\n        }\n    }\n    if (ans == 1) {\n        return res;\n  \
    \  } else {\n        return \"\";\n    }", "  // write your code here\n  int n\
    \ = sentence.length();\n  std::string res[n + 1];\n  for (int i = 0; i < n; i++)\
    \ {\n    for (int j = i + 1; j < n; j++) {\n      assert(isPrime(static_cast<int>(sentence[i])));\n\
    \      assert(isPrime(static_cast<int>(sentence[j])));\n      if (sentence[i]\
    \ == sentence[j]) {\n        res[j] += \" \" + sentence[i];\n      }\n    }\n\
    \  }\n  return res;", "    // Your code here\n    \n    std::string res;\n   \
    \ for(int i=0;i<sentence.size()+1;i++){\n        for(int j=0;j<sentence.size()-i+1;j++){\n\
    \            if((i+j+1)==sentence.size()&&(i%j==0)){\n                res+=sentence.substr(i,j);\n\
    \            }\n        }\n    }\n    return res;", "    std::string ans = \"\
    a b c\";\n    int N = sentence.length();\n    bool primes[N];\n    for (int i\
    \ = 0; i < N; i++) {\n        primes[i] = true;\n        for (int j = i * i; j\
    \ < N; j += i) {\n            primes[j] = false;\n        }\n    }\n    std::string\
    \ ret = \"\";\n    int j = 0;\n    for (int i = 0; i < N; i++) {\n        for\
    \ (int k = 0; k < N; k++) {\n            if (k == i || k > i) {\n            \
    \    continue;\n            }\n            if (primes[k] == true) {\n        \
    \        while (j < N && j < i) {\n                    if (j % primes[k] == 0)\
    \ {\n                        ans += sentence[j];\n                        break;\n\
    \                    }\n                    j++;\n                }\n        \
    \    }\n        }\n    }\n    return ans;", "    std::vector<std::string> v;\n\
    \    std::string res;\n    \n    std::string::size_type pos = 0;\n    \n    for\
    \ (; pos < sentence.length(); pos++) {\n        v.push_back(sentence.substr(pos,\
    \ 1));\n    }\n    \n    bool flag = true;\n    \n    while (flag) {\n       \
    \ flag = false;\n        for (std::vector<std::string>::size_type i = 0; i < v.size();\
    \ i++) {\n            if (std::count(v.begin() + i, v.end(), 1L)) {\n        \
    \        flag = true;\n                for (std::vector<std::string>::size_type\
    \ j = 0; j < i; j++) {\n                    if (v[j] == v[j + 1]) {\n        \
    \                v[j] = v[j + 1];\n                        v[j + 1] = 0;\n   \
    \                     break;\n                    }\n                }\n     \
    \           break;\n            }\n        }\n    }\n    for (std::vector<std::string>::size_type\
    \ i = 0; i < v.size(); i++) {\n        for (std::vector<std::string>::size_type\
    \ j = 0; j < i; j++) {\n            if (v[j] == v[j + 1]) {\n                v.erase(v.begin()\
    \ + j);\n                j--;\n                break;\n            }\n       \
    \ }\n    }\n    \n    for (std::vector<std::string>::size_type i = 0; i < v.size();\
    \ i++) {\n        res += v[i] + \" \";\n    }\n    res.erase(res.end() - 1);\n\
    \    return res;", "  assert(sentence.size() > 0);\n  \n  // Create a trie map\
    \ to store all unique prime numbers \n  // (prime numbers represent the length\
    \ of the substring).\n  // Initially, the length of a substring is zero i.e. a\
    \ substring is\n  // \"empty\". \n  std::map<int, bool> primes;\n\n  // Create\
    \ a stack where we store the words in the string\n  std::stack<std::string> result;\n\
    \n  // Keep track of the current position in the string.\n  int i = 0;\n\n  while\
    \ (i < sentence.size()) {\n\n    // If we have not stored the substring for the\
    \ current length, then store\n    // it and increment the length. \n    if (!primes.count(sentence[i]\
    \ - ' ')) {\n      primes[sentence[i] - ' '] = true;\n      result.push(sentence[i]);\n\
    \    }\n\n    // If the current character is a space, add it to the stack.\n \
    \   // Otherwise increase the length of the substring. \n    if (sentence[i] ==\
    \ ' ') {\n      result.push(sentence[i]);\n      ++i;\n    }\n\n    // Increase\
    \ the position in the string.\n    ++i;\n  }\n\n  // Print the words present in\
    \ the stack.\n  std::vector<std::string> result = std::move(std::stack<std::string>::pop(result));\n\
    \  std::cout << result;\n\n  return result;", "    std::vector<std::string> words;\n\
    \    std::string word;\n    std::string new_sentence;\n    for (auto word : sentence)\
    \ {\n        std::string new_word;\n        if (word.length() == 1) {\n      \
    \      new_word += word;\n        }\n        bool prime = true;\n        for (int\
    \ i = 0; i < word.length(); i++) {\n            for (int j = i; j < word.length();\
    \ j++) {\n                if (word[i] != word[j]) {\n                    if (word.substr(i,\
    \ j) == word.substr(i + 1, j + 1)) {\n                        prime = false;\n\
    \                        break;\n                    }\n                }\n  \
    \          }\n            if (prime) {\n                new_word += word[i];\n\
    \            }\n            prime = true;\n        }\n        new_sentence.push_back(new_word);\n\
    \    }\n    for (auto word : new_sentence) {\n        std::sort(word.begin(),\
    \ word.end());\n        if (std::is_sorted(word.begin(), word.end())) {\n    \
    \        words.push_back(word);\n        }\n    }\n    std::sort(words.begin(),\
    \ words.end());\n    std::string ans;\n    for (auto word : words) {\n       \
    \ ans += \" \" + word;\n    }\n    return ans;", "    std::string ans;\n    std::stack<int>\
    \ primes;\n    int len = 0;\n    for (auto &ele : sentence)\n        ++len;\n\
    \    primes.push(len);\n    while (!primes.empty())\n    {\n        int len =\
    \ primes.top();\n        if (len < 2)\n        {\n            ans = ans + \" \"\
    ;\n            primes.pop();\n            continue;\n        }\n        if (len\
    \ == 2)\n        {\n            ans = ans + sentence[0];\n            primes.pop();\n\
    \            continue;\n        }\n        bool flag = true;\n        for (int\
    \ i = 1; i < len; ++i)\n        {\n            if (primes.top() % i == 0)\n  \
    \          {\n                flag = false;\n                break;\n        \
    \    }\n        }\n        if (flag)\n        {\n            ans = ans + sentence[0];\n\
    \            primes.pop();\n            int len2 = len;\n            while (flag\
    \ && len2 < 100)\n            {\n                ans = ans + \" \" + sentence[len2];\n\
    \                ++len2;\n                for (int i = len2; i < len; ++i)\n \
    \               {\n                    if (primes.top() % i == 0)\n          \
    \          {\n                        flag = false;\n                        break;\n\
    \                    }\n                }\n                if (flag)\n       \
    \         {\n                    ans = ans + \" \" + sentence[len2];\n       \
    \             primes.pop();\n                }\n            }\n        }\n   \
    \ }\n    return ans;", "  std::vector<std::string> words;\n  std::istringstream\
    \ iss(sentence);\n  while (iss >> word) {\n    words.push_back(word);\n  }\n \
    \ std::reverse(words.begin(), words.end());\n  std::string result;\n  for (auto\
    \ i = 0; i < words.size(); ++i) {\n    if (is_prime(i)) {\n      result += words[i];\n\
    \    }\n  }\n  return result;", "    // Your code here\n    std::string ans =\
    \ sentence;\n    for (size_t i = 0, n = sentence.length(); i < n; i++) {\n   \
    \     int len = 1;\n        while (len < n && sentence[i] != ' ' && sentence[i]\
    \ != '\\n' && sentence[i] != '.') {\n            len++;\n        }\n        if\
    \ (len == 1)\n            ans += sentence[i];\n        else if (len == 2 || len\
    \ == 3)\n            ans += sentence[i];\n        else if (len > 3) {\n      \
    \      ans = ans + sentence[i];\n            ans += \" \";\n            int j\
    \ = i + 1;\n            while (j < n && sentence[j] != ' ' && sentence[j] != '\\\
    n' && sentence[j] != '.') {\n                ans = ans + sentence[j];\n      \
    \          ans += \" \";\n                j++;\n            }\n            ans\
    \ = ans + sentence[j];\n        }\n    }\n    return ans;", "  assert(sentence.length()\
    \ <= 100);\n  std::string res;\n  std::string temp = sentence;\n  int len = 0;\n\
    \  while (!temp.empty()) {\n    if (temp.back() != ' ') {\n      res += temp.back();\n\
    \      temp.pop_back();\n    }\n    else {\n      temp.erase(temp.end() - 1);\n\
    \      len++;\n    }\n  }\n  for (int i = 2; i <= len; i++) {\n    temp = res\
    \ + \" \" + temp;\n  }\n  return res;", "    std::string s = sentence;\n    std::string\
    \ words;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == ' ') {\n\
    \            words = words + \" \";\n        } else {\n            int len = std::ceil(s.length()\
    \ / (double)i); //\u8FD9\u91CC\u4E3A\u4E86\u9650\u5236\u957F\u5EA6\u4E3Aprime\u7684\
    \u80FD\u529B\n            int count = 0;\n            while (count < len) {\n\
    \                if (isPrime(std::ceil(s.length() / (double)i))) {\n         \
    \           count++;\n                }\n            }\n            words = words\
    \ + std::string(s.begin() + (i * (std::ceil(s.length() / (double)i)), s.begin()\
    \ + (i * (std::ceil(s.length() / (double)i) + 1)));\n        }\n    }\n    return\
    \ words;", "    vector<int> primes;\n    for (int i = 0; i < 100; i++) {\n   \
    \     if (i >= 2 && i % 2 == 0) {\n            continue;\n        }\n        if\
    \ (i % 2 != 0) {\n            for (int j = i; j < 100; j += i) {\n           \
    \     if (j % i == 0) {\n                    break;\n                }\n     \
    \       }\n        }\n        bool flag = false;\n        for (int j = i; j <\
    \ 100; j += i) {\n            if (j % i == 0) {\n                flag = true;\n\
    \                break;\n            }\n        }\n        if (flag == false)\
    \ {\n            primes.push_back(i);\n        }\n    }\n    int n = primes.size();\n\
    \    vector<string> res;\n    for (int i = 0; i < n; i++) {\n        if (sentence.find(\"\
    \ \") != std::string::npos) {\n            int index = sentence.find(\" \");\n\
    \            int last = index;\n            for (; index != sentence.size(); last\
    \ = index) {\n                vector<int> temp;\n                for (int k =\
    \ i; k < n; k++) {\n                    if (k != i && primes[k] % index == 0)\
    \ {\n                        temp.push_back(primes[k]);\n                    }\n\
    \                }\n                res.push_back(sentence[index + 1]);\n    \
    \            for (int j = 0; j < temp.size(); j++) {\n                    res.push_back(sentence[last\
    \ - temp[j] - 1]);\n                }\n                index++;\n            }\n\
    \        } else {\n            vector<int> temp;\n            for (int k = i;\
    \ k < n; k++) {\n                if (k != i) {\n                    temp.push_back(primes[k]);\n\
    \                }\n            }\n            int last = temp.size();\n     \
    \       res.push_back(sentence[last - 1]);\n            for (int j = 0; j < temp.size();\
    \ j++) {\n                res.push_back(sentence[last - temp[j] - 1]);\n     \
    \       }\n        }\n    }\n    string res = \"\";\n    for (int i = 0; i < res.size();\
    \ i++) {\n        res += \" \" + res[i];\n    }\n    return res;", "    std::string\
    \ ans = \"\";\n    bool isPrime = false;\n    int len = 0;\n    \n    for(auto\
    \ c : sentence) {\n        len = c + 1;\n        isPrime = true;\n        \n \
    \       for(int i = 1; i < len; i++) {\n            bool isPrime = true;\n   \
    \         \n            for(int j = i; j < len; j++) {\n                if(i %\
    \ j == 0) {\n                    isPrime = false;\n                    break;\n\
    \                }\n            }\n            if(isPrime) {\n               \
    \ ans += \" \";\n                ans += i;\n            }\n        }\n    }\n\
    \    return ans;", "    // Write your code here\n    assert(sentence.size() <=\
    \ 100);\n    std::map<char,int> dic;\n    std::string res = \"\";\n    for(int\
    \ i = 0; i<sentence.size();i++){\n        if(dic.find(sentence[i]) == dic.end()){\n\
    \            dic[sentence[i]] = 1;\n            res += sentence[i]+\" \";\n  \
    \      }\n    }\n    for(int i=0;i<res.size();i++){\n        if(res[i]==' ') res.erase(i,1);\n\
    \    }\n    std::set<std::string> prime;\n    for(int i=2;i<res.size();i++){\n\
    \        if(!prime.insert(res[i]).second){\n            res += res[i]+\" \";\n\
    \        }\n    }\n    for(int i=0;i<res.size();i++){\n        if(res[i]==' ')\
    \ res.erase(i,1);\n    }\n    return res;", "    string res;\n    for(int i=0;i<sentence.size();++i){\n\
    \        if(isalpha(sentence[i])&&isalpha(sentence[i+1])){\n            string\
    \ str=sentence.substr(i,2);\n            for(int j=1;j<str.size();++j){\n    \
    \            if(isalpha(str[j])){\n                    if(is_prime(str.length())){\n\
    \                        res+=str;\n                    }\n                }\n\
    \            }\n        }\n    }\n    return res;", "  std::stack<std::string>\
    \ s;\n  for (auto s : sentence){\n      if (s.find_first_not_of(\"0123456789\"\
    ) == std::string::npos) {\n          s.push(s);\n      }\n  }\n\n  while (!s.empty()){\n\
    \      auto first = s.top();\n      s.pop();\n      auto last = s.top();\n   \
    \   s.pop();\n      \n      if (first.length() == last.length()){\n          std::string\
    \ temp(first);\n          temp.append(last);\n          s.push(temp);\n      }\n\
    \      else if (first.length() < last.length()){\n          std::string temp(last);\n\
    \          temp.append(first);\n          s.push(temp);\n      }\n      else{\n\
    \          std::string temp(first);\n          temp.append(first);\n         \
    \ temp.append(last);\n          s.push(temp);\n      }\n  }\n\n  return s.top();",
  "    // Your code here\n    std::string::iterator first = sentence.begin();\n  \
    \  std::string res = \"\";\n    while (first != sentence.end()) {\n        std::advance(first,\
    \ 2);\n        res.insert(res,(*first),(*first+1));\n    }\n    std::unordered_map<char,int>\
    \ wordMap;\n    std::unordered_map<char,int>::iterator it;\n    for (int i = 1\
    \ ; i <= 100 ; i++) {\n        it=wordMap.find(i);\n        if(it!=wordMap.end())\
    \ {\n            if(it->second==2) {\n                res=res.replace(it->first,it->first,1);\n\
    \            }\n            wordMap.erase(it);\n        }\n    }\n    return res;",
  "    std::set<int> primes;\n    int len = sentence.size();\n    std::string ans\
    \ = \"\";\n    for (int i = 0; i < len; i++) {\n        if (i % 2 == 0) primes.insert(i\
    \ / 2);\n        if (primes.count(i)) {\n            ans += sentence[i];\n   \
    \         primes.erase(i);\n        }\n    }\n    return ans;", "  // code here\n\
    \  std::stack<int> st;\n  std::queue<int> q;\n  for (int i = 0; i < sentence.length();\
    \ i++) {\n    int nxt = sentence[i] - 'a';\n    if (nxt >= 'A' && nxt <= 'Z')\
    \ {\n      if (st.empty())\n        st.push(i);\n      else\n        q.push(nxt);\n\
    \    } else if (st.empty() && q.empty())\n      q.push(i);\n  }\n  int j = 0;\n\
    \  while (!q.empty()) {\n    if (st.empty())\n      st.push(q.front());\n    q.pop();\n\
    \    ++j;\n    if (j == 2 || j == 5 || j == 8) {\n      std::string s;\n     \
    \ while (!q.empty()) {\n        s += std::to_string(q.front());\n        q.pop();\n\
    \      }\n      s = std::string(s.rbegin(), s.rend());\n      return s;\n    }\n\
    \  }\n  return \"\";", "    assert(sentence.size() != 0);\n    std::vector<int>\
    \ primes;\n    std::string ans = sentence;\n    int prime = 2;\n    // remove\
    \ all the spaces in the sentence\n    size_t n = ans.length();\n    size_t count\
    \ = 0;\n    while (count < n) {\n        if (ans[count] == ' ') {\n          \
    \  count++;\n        }\n        else {\n            primes.push_back(prime);\n\
    \            count++;\n        }\n    }\n    // check if all numbers are prime\n\
    \    for (size_t i = 0; i < primes.size(); i++) {\n        if (is_prime(primes[i])\
    \ == 0) {\n            primes.clear();\n            break;\n        }\n    }\n\
    \    // check if all numbers are prime\n    if (primes.size() == 0) {\n      \
    \  return \"\";\n    }\n    // sort the vector\n    std::sort(primes.begin(),\
    \ primes.end());\n    for (size_t i = 0; i < primes.size(); i++) {\n        ans\
    \ = ans.replace(primes[i], \" \");\n    }\n    // remove the leading space\n \
    \   ans = ans.substr(1);\n    return ans;", "    // Write your code here\n   \
    \ std::vector<std::string> ans;\n    std::string word = \" \";\n    for (size_t\
    \ i = 0; i < sentence.size(); i++) {\n        char c = sentence[i];\n        if\
    \ ((c == ' ') || (c == '.') || (c == '!') || (c == '?')) {\n            if (word\
    \ != \" \") {\n                ans.push_back(word);\n                word = \"\
    \ \";\n            }\n        } else {\n            word += c;\n        }\n  \
    \  }\n    if (word != \" \") {\n        ans.push_back(word);\n    }\n    return\
    \ ans;"]
stop_tokens:
- "\n}"
