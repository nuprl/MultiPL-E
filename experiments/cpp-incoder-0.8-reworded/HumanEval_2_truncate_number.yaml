name: HumanEval_2_truncate_number
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a positive floating\
  \ point number, it can be decomposed into\n// and integer part (largest integer\
  \ smaller than given number) and decimals\n// (leftover part always smaller than\
  \ 1).\n// Return the decimal part of the number.\n// >>> truncate_number((3.5))\n\
  // (0.5)\nfloat truncate_number(float number) {\n"
tests: "}\nint main() {\n    auto candidate = truncate_number;\n    assert(candidate((3.5))\
  \ == (0.5));\n    assert(candidate((1.25)) == (0.25));\n    assert(candidate((123.0))\
  \ == (0.0));\n}\n"
completions: ["    int decimals = 0;\n    float truncated = number;\n    while (truncated==0)\
    \ {\n        truncated = truncated*10;\n        decimals++;\n    }\n    int integer\
    \ = truncated/10;\n    truncated = truncated%10;\n    assert(integer==0);\n  \
    \  return truncated/decimals;", "\tint decimal = number % 1;\n\tnumber = number\
    \ / 1;\n\treturn number;", "    unsigned long long int decimals;\n    long double\
    \ frac;\n    double intpart;\n    bool isintpart;\n    frac = modf(number, &frac);\n\
    \    decimals = static_cast<unsigned long long>(frac * pow(10.0, ceil(log(frac))\
    \ / log(10.0)));\n    intpart = modf(number - decimals, &frac);\n    isintpart\
    \ = static_cast<bool>(frac);\n    if (isintpart && (intpart > 0.0)) {\n      \
    \  intpart -= 1.0;\n    }\n    return static_cast<float>(intpart);", "    float\
    \ temp = number;\n    int integer_part = floor(temp);\n    int decimal_part =\
    \ abs(temp - integer_part);\n    float result = integer_part;\n    if(decimal_part\
    \ > 0) {\n        result = result + decimal_part;\n    }\n    return result;",
  "    // TODO: Complete this function\n    return number;", "    long decimal_places\
    \ = 0;\n    while (number > 1) {\n        decimal_places++;\n        number /=\
    \ 10;\n    }\n    return float(number) / float(10 ** decimal_places);", "    assert(number\
    \ >= 0.0);\n    float a = number;\n    float dec = 0;\n    while (a >= 1.0) {\n\
    \        a = a - 1.0;\n        dec = dec + 1;\n    }\n    return dec;", "    assert(number\
    \ >= 0);\n    if (number == 0) {\n        return 0;\n    }\n\n    long int first_integer\
    \ = std::floor(number);\n    long int last_integer = number - first_integer;\n\
    \    long int decimals = last_integer % 1;\n\n    float int_part = (float)first_integer;\n\
    \    if (decimals % 2 == 0) {\n        int_part += 1.0;\n    }\n    return int_part\
    \ + decimals;", "  assert(number >= 0);\n  if (number == 0)\n    return number;\n\
    \  int integer = ceil(log10f(number));\n  float remainder = number - pow(10.0,\
    \ integer);\n  return float(integer) / float(10) * pow(remainder, 1.0 / 10.0);",
  "    float integer_part;\n    float decimal_part;\n    if (number < 0.0000001) {\n\
    \        integer_part = number;\n        decimal_part = 0.0000001;\n    } else\
    \ {\n        decimal_part = number * 10.0000001;\n        integer_part = number\
    \ - decimal_part;\n    }\n    return decimal_part;", "    float int_part_of_number\
    \ = (number * 100000000);\n    float decimal_part_of_number = number - (int_part_of_number);\n\
    \    return decimal_part_of_number;", "    int integer_part;\n    int decimal_part;\n\
    \    // Truncate the number to be in the range of integer numbers\n    if (number\
    \ < 0) {\n        integer_part = 0;\n        decimal_part = abs(number) - 1;\n\
    \    } else {\n        integer_part = number;\n        decimal_part = 1;\n   \
    \ }\n    // Get the remainder (least significan decimal part)\n    int remainder\
    \ = number % 1;\n    // Remove the decimal part from number\n    number = number\
    \ / 1;\n    // Divide number by 10\n    number = number / 10;\n    // Multiply\
    \ number by 10\n    number = number * 10;\n    // Add integer_part to the decimal\
    \ part\n    decimal_part += integer_part;\n    // Return the result\n    return\
    \ decimal_part + number;", "    long double a = static_cast<long double>(number);\n\
    \    long double a1 = a - (a / std::pow(2, 31));\n    long double a2 = a1 - (a1\
    \ / std::pow(2, 30));\n    long double a3 = a2 - (a2 / std::pow(2, 29));\n   \
    \ long double a4 = a3 - (a3 / std::pow(2, 28));\n    long double a5 = a4 - (a4\
    \ / std::pow(2, 27));\n    long double a6 = a5 - (a5 / std::pow(2, 26));\n   \
    \ long double a7 = a6 - (a6 / std::pow(2, 25));\n    long double a8 = a7 - (a7\
    \ / std::pow(2, 24));\n    long double a9 = a8 - (a8 / std::pow(2, 23));\n   \
    \ long double a10 = a9 - (a9 / std::pow(2, 22));\n    long double a11 = a10 -\
    \ (a10 / std::pow(2, 21));\n    long double a12 = a11 - (a11 / std::pow(2, 20));\n\
    \    long double a13 = a12 - (a12 / std::pow(2, 19));\n    long double a14 = a13\
    \ - (a13 / std::pow(2, 18));\n    long double a15 = a14 - (a14 / std::pow(2, 17));\n\
    \    long double a16 = a15 - (a15 / std::pow(2, 16));\n    long double a17 = a16\
    \ - (a16 / std::pow(2, 15));\n    long double a18 = a17 - (a17 / std::pow(2, 14));\n\
    \    long double a19 = a18 - (a18 / std::pow(2, 13));\n    long double a20 = a19\
    \ - (a19 / std::pow(2, 12));\n    long double a21 = a20 - (a20 / std::pow(2, 11));\n\
    \    long double a22 = a21 - (a21 / std::pow(2, 10));\n    long double a23 = a22\
    \ - (a22 / std::pow(2, 9));\n    long double a24 = a23 - (a23 / std::pow(2, 8));\n\
    \    long double a25 = a24 - (a24 / std::pow(2, 7));\n    long double a26 = a25\
    \ - (a25 / std::pow(2, 6));\n    long double a27 = a26 - (a26 / std::pow(2, 5));\n\
    \    long double a28 = a27 - (a27 / std::pow(2, 4));\n    long double a29 = a28\
    \ - (a28 / std::pow(2, 3));\n    long double a30 = a29 - (a29 / std::pow(2, 2));\n\
    \    long double a31 = a", "    int i = 0; // decimal part index\n    int n =\
    \ 0; // total number index\n    float decimal = number; // number as float variable\n\
    \    if (number > 0) // number is positive\n    {\n        n = 1;\n        while\
    \ (number > 0 && n > 0) // count decimals\n        {\n            decimal /= 10;\n\
    \            ++n;\n        }\n        ++i;\n    }\n    return number - decimal;",
  "    int32_t integer_part = static_cast<int32_t>(number);\n    float decimal_part\
    \ = number - integer_part;\n    return decimal_part;", "    long l = 0;\n    float\
    \ f = 0;\n    while (number > 0) f++;\n    float f1 = 1;\n    for (int i = 0;\
    \ i < f; i++) f1 = f1 * 10;\n    while (f1 > 0) {\n        l = l / 10;\n     \
    \   l += 1;\n        f1 = f1 / 10;\n    }\n    float f2 = 1;\n    for (int i =\
    \ 0; i < f; i++) f2 = f2 * 10;\n    while (f2 > 0) {\n        l = l / 10;\n  \
    \      l += 1;\n        f2 = f2 / 10;\n    }\n    return l;", "    float decimalPart\
    \ = number % 1;\n    number = number / 1;\n    return number;", "    unsigned\
    \ int i;\n    unsigned int integerPart = 0;\n    unsigned int decimalPart = 0;\n\
    \    float tmp;\n    float fnum = number;\n    unsigned int decimalsRemaining;\n\
    \n    tmp = fnum;\n    do {\n        decimalsRemaining = log10f(tmp);\n      \
    \  integerPart = integerPart * 10 + (decimalsRemaining - 1);\n        tmp = tmp\
    \ / 10.0;\n    } while (tmp != 0.0);\n\n    if (decimalsRemaining == 0) {\n  \
    \      return number;\n    } else {\n        tmp = fnum / pow(10.0, decimalsRemaining);\n\
    \        return tmp;\n    }", "    int integer_part;\n    float decimal_part =\
    \ number;\n    // Handle -ve number\n    if (number < 0) {\n        integer_part\
    \ = ~(-number);\n        decimal_part = -decimal_part;\n    }\n    // Handle zero\
    \ case\n    if (number == 0.0f) {\n        return decimal_part;\n    }\n    //\
    \ Handle positive numbers\n    if (number > 0) {\n        integer_part = number;\n\
    \        decimal_part = 0;\n    }\n    // Return decimal part\n    return decimal_part;",
  "    int int_part = floor(number);\n    float decimal_part = number - int_part;\n\
    \    return decimal_part;", "    long int integer_part, decimal_part = floor(number);\n\
    \    long int remainder = number - decimal_part;\n    return decimal_part + remainder;",
  "    auto integer = floorf(number);\n    auto decimals = number - integer;\n   \
    \ return integer + decimals;", "  assert(number > 0);\n  int int_part = 0;\n \
    \ float decimal_part = 0.0;\n  while (number > 0.0) {\n    decimal_part += number\
    \ % 1.0;\n    number /= 1.0;\n    int_part++;\n  }\n  if (int_part > 0)\n    return\
    \ decimal_part + pow(10.0, -int_part);\n  else\n    return decimal_part;", " \
    \   float remainder = number - floorf(number);\n    if (remainder >= 0.5f && remainder\
    \ < 1.0f) {\n        return number - remainder;\n    } else if (remainder < 0.5f)\
    \ {\n        return number - 1.0f;\n    } else {\n        return number;\n   \
    \ }", "    long decimal, whole;\n    float trunc_num, trunc_den;\n    whole =\
    \ (long) number;\n    decimal = (long) number - (whole % 1);\n    trunc_num =\
    \ (float) decimal;\n    trunc_den = 1.0;\n    while (decimal != 0.0) {\n     \
    \   trunc_num *= 10.0;\n        trunc_den *= 10.0;\n        decimal--;\n    }\n\
    \    return trunc_num / trunc_den;", "    // TODO: Complete this function.\n \
    \   float integer_part = floor(number);\n    float decimal_part = number - integer_part;\n\
    \    return decimal_part;", "    if (number < 0)\n        number *= -1;\n    int\
    \ decimals = static_cast<int>(\n            static_cast<long long>(number) + 0.5f);\n\
    \    float fraction = number - decimals;\n    return fraction;", "\tint int_part\
    \ = (int)(number);\n\tint decimal_part = number - (int)number;\n\treturn decimal_part\
    \ * 1.0f / 10f;", "    float integer_part;\n    float decimal_part;\n    if (number\
    \ < 0.5)\n        integer_part = 0.5f;\n    else\n        integer_part = number;\n\
    \    decimal_part = number - integer_part;\n    return decimal_part;", "\tdouble\
    \ int_part, decimals;\n\tassert(number >= 0.0);\n\tint_part = floor(number);\n\
    \tdecimals = number - int_part;\n\treturn static_cast<float>(int_part) + static_cast<float>(decimals);",
  "    int integerPart = floor(number);\n    return number - integerPart;", "  int\
    \ decimal_part = floorf(number);\n  float int_part;\n  if (number - decimal_part\
    \ < 0.5f)\n    return decimal_part;\n  else\n    return decimal_part + 0.5f;",
  "  assert (number > 0);\n  float integer_part;\n  float decimal_part = floor(number);\n\
    \  integer_part = number - decimal_part;\n  return integer_part;", "    int  \
    \   integer_part;\n    int     decimal_part;\n    int     factor;\n\n    factor\
    \ = log10(number) + 1;\n    integer_part = number/pow(10.0,factor);\n    decimal_part\
    \ = number-integer_part*pow(10.0,factor);\n\n    return (decimal_part/pow(10.0,factor));",
  "  int integer_part = floor(number);\n  float decimal = (number - integer_part);\n\
    \  return decimal;", "    int       digits = 1;\n    int       decimals = 0;\n\
    \n    do {\n        ++digits;\n        number /= 10;\n    } while (number > 1);\n\
    \n    if (number == 0.)\n        ++decimals;\n\n    return number / pow(10., digits);",
  "    long int_part = floor(number);\n    float decimal_part = number - int_part;\n\
    \    float truncated = decimal_part;\n    return truncated;", "    int decimalPart\
    \ = 0;\n    float truncated = 0.0;\n    while (number >= 1.0) {\n        truncated\
    \ = truncated + number/10.0;\n        number = number % 10.0;\n        decimalPart++;\n\
    \    }\n    truncated = truncated + number;\n    if (truncated == 0.0) decimalPart\
    \ = 0;\n    return truncated/pow(10.0, decimalPart);", "    long long int int_part;\n\
    \    int decimal_part = 0;\n    if (number < 0) {\n        int_part = abs(number);\n\
    \        decimal_part = -int_part;\n    }\n    else {\n        int_part = number;\n\
    \    }\n\n    float trunc_number = number - int_part;\n    return trunc_number\
    \ + decimal_part;", "    int integer = static_cast<int>(number);\n    float remainder\
    \ = number - integer;\n    if (integer % 1) remainder = remainder + 0.5;\n   \
    \ return remainder;", "    float result = number;\n    float fract = result -\
    \ floor(result);\n    long int integer_part = (long)fract;\n    if (integer_part\
    \ < 0.5) {\n        return integer_part;\n    }\n    else {\n        return integer_part\
    \ - 1;\n    }", "    float truncated;\n    truncated = number;\n    truncated\
    \ = truncated - truncated % 1;\n    return truncated;", "    float truncated =\
    \ 0.f;\n    int i = 0;\n    do {\n        truncated += 1.0f / (float)pow(10.0f,\
    \ i);\n        ++i;\n    } while (truncated >= number);\n    return truncated;",
  "    float int_part = (float)number;\n    float decimal_part = floor(number - int_part);\n\
    \    return (decimal_part);", "  assert(number >= 0);\n  // If number is too small\
    \ to represent as an int, return 0\n  if (number > INT_MAX) {\n    return 0;\n\
    \  }\n  // Divide number by 10\n  number = number / 10.0;\n  // If number is 0,\
    \ return 0\n  // If number is too small to fit into an int, return 0\n  if (number\
    \ > INT_MAX) {\n    return 0;\n  }\n  // If number has only one digit, return\
    \ number\n  if (number == 0.0) {\n    return number;\n  }\n  // If number is too\
    \ small to represent as an int, return 0\n  if (number > INT_MAX) {\n    return\
    \ 0;\n  }\n  // Return truncated number\n  return number;", "    int integer_part\
    \ = floor(number);\n    float decimal_part = number - integer_part;\n    return\
    \ decimal_part;", "  int decimal_places = 0;\n  float remainder = number;\n\n\
    \  while (remainder >= 1.0f) {\n    remainder -= 1.0f;\n    ++decimal_places;\n\
    \  }\n\n  return remainder + 0.5f;", "  assert(number > 0);\n  const int decimal_places\
    \ = (int)log10(number);\n  float remainder = number - floorf(number);\n  float\
    \ factor = powf(10.0, decimal_places);\n  return remainder * factor;", "    int\
    \ num_dec = std::count_if(number.begin(), number.end(), [](int c) {return c <\
    \ '9';});\n    float int_part = std::min(number, std::numeric_limits<float>::max());\n\
    \    float frac_part = number - int_part;\n    return std::max(std::min(frac_part,\
    \ 1.0f), 0.0f);", "    float remainder = number - (int) number;\n    float whole_part\
    \ = (float) number - remainder;\n    return whole_part;", "  // Check if number\
    \ is 0 or smaller.\n  // >>> truncate_number(-3.5)\n  // -3.5\n  assert(number\
    \ >= 0);\n  // If it is 0 or smaller, the number is already the decimal part.\n\
    \  // Return the number itself.\n  // >>> truncate_number(0)\n  // 0.0\n  if (number\
    \ == 0) {\n    return number;\n  }\n  // Initialize decimal part to 1 and integer\
    \ part to 0.\n  // >>> truncate_number(2.5)\n  // 2.5\n  float integer_part =\
    \ 1;\n  // If the number is bigger than 0, it is the decimal part with bigger\
    \ integer part.\n  // If it is smaller than 0, it is the decimal part with smaller\
    \ integer part.\n  // >>> truncate_number(2.5)\n  // 2.5\n  // >>> truncate_number(-2.5)\n\
    \  // -2.5\n  if (number < 0) {\n    integer_part = (float)(-number);\n  } else\
    \ {\n    integer_part = number;\n  }\n  // >>> truncate_number(3.5)\n  // 3\n\
    \  // >>> truncate_number(4.5)\n  // 4\n  // >>> truncate_number(-10)\n  // 0\n\
    \  float decimal_part = number - integer_part;\n  // If decimal_part is 1, the\
    \ number is bigger than 0.\n  // If decimal_part is -1, the number is smaller\
    \ than 0.\n  // If it is 0, it is a special case.\n  // >>> truncate_number(0.999)\n\
    \  // 0\n  if (decimal_part == 1.0) {\n    return 0;\n  }\n  // If the number\
    \ is bigger than 0, it is the decimal part with bigger integer part.\n  // If\
    \ it is smaller than 0, it is the decimal part with smaller integer part.\n  //\
    \ >>> truncate_number(0.999)\n  // 1\n  // >>> truncate_number(0.001)\n  // 0\n\
    \  if (decimal_part == -1.0) {\n    return 1;\n  }\n  // If the number is 0, it\
    \ is either a special case or the number is smaller than 0.\n  // >>> truncate_number(0.001)\n\
    \  // 1\n  // >>> truncate_number(-1)\n  // -1\n  if (decimal_part == 0) {\n \
    \   return -1;\n  }\n  // If the number is positive, it is the decimal part with\
    \ bigger integer part.\n  // If it is negative, it is the decimal part with smaller\
    \ integer part.\n  // >>> truncate_number(-1)\n  // -1\n  // >>> truncate_number(1)\n\
    \  // 1\n  // >>> truncate_number(-1)\n  // -1\n  if (decimal_part > 0) {\n  \
    \  return decimal_part;\n  }\n  // If the number is negative, it is the decimal\
    \ part with smaller integer part.\n  // If it is positive, it is the decimal part\
    \ with bigger integer part.\n  // >>> truncate_number(1)\n  // 1\n  // >>> truncate_number(1)\n\
    \  // 1\n  // >>> truncate_number(-1.0)\n  // -1\n  if (decimal_part < 0) {\n\
    \    return -decimal_", "  if (number > 0.) {\n    return number;\n  }\n  // number\
    \ < 0.\n  int integer = (long long) number;\n  // int can store integer part of\
    \ floating point number\n  int decimal_part = integer - integer;\n  // Decimal\
    \ part is always less than 1, so it can be safely cast to float.\n  return float(decimal_part);",
  '    return number - floor(number);', "    assert(number > 0);\n    long decimal_part\
    \ = number - floorf(number);\n    long factor = 1;\n    do {\n        decimal_part\
    \ *= factor;\n        factor *= 10;\n    } while (factor < 1e10 + fabs(decimal_part));\n\
    \    return number - decimal_part;", "\tint decimal_part = ceil(log10(number));\n\
    \treturn number - pow(10, decimal_part);", "  int i = 0;\n  while (number / 10\
    \ > (float)i) {\n    ++i;\n  }\n  return number / 10.0 - i;", "  // Round the\
    \ number to nearest integer.\n  float round = round(number);\n  // If there is\
    \ an integer part, the result is truncated.\n  if (number - round >= 0.5)\n  \
    \  return round(number);\n  // Round half to even.\n  if (round(number) == number)\n\
    \    return round(number);\n  // Round up to integer (round up)\n  return round(number)\
    \ + 1;", "    unsigned int int_part;\n    unsigned int decimal_part;\n    number\
    \ = std::floor(number);\n    int_part = static_cast<unsigned int>(number);\n \
    \   decimal_part = number - int_part;\n    return decimal_part;", "    assert(number\
    \ >= 0);\n    int decimal_part_index = static_cast<int>(std::fmod(number, 1.0));\n\
    \    return number - decimal_part_index; // 0.5", "    int decimal_part = floor(log10(number));\n\
    \    return number - pow(10.0, decimal_part);", "  int int_part;\n  float decimal_part\
    \ = number - truncate_number(number);\n  if (number >= 0.5f) {\n    int_part =\
    \ 0;\n  } else if (number < 0.5f) {\n    int_part = 1;\n  } else {\n    int exponent\
    \ = log2(truncate_number(0.5f));\n    int_part = truncate_number(0.5f ** exponent);\n\
    \  }\n  return (int_part * 10) + decimal_part;", "    float truncated = 0.f;\n\
    \    float div = number;\n    while (div > 0) {\n        truncated = truncated\
    \ * 10.f + div % 10.f;\n        div = div / 10.f;\n    }\n    return truncated;",
  "  assert(number > 0);\n  float integer = ceil(number);\n  float decimal = number\
    \ - integer;\n  return integer + decimal;", "  assert(number >= 0);\n  int int_part\
    \ = 0;\n  while (number >= 1.0) {\n    int_part++;\n    number /= 10;\n  }\n \
    \ int decimals = static_cast<int>(std::log10(number)) + 1;\n  return static_cast<float>(number\
    \ / std::pow(10.0, decimals)) + 0.5f;", "    int decimal_part = number % 1;\n\
    \    int whole_part = number / 1;\n    int floor_part = floor(number);\n\n   \
    \ if (floor_part > 0)\n        return floor_part;\n    else\n        return truncate_number(floor_part)\
    \ + decimal_part;", "  assert(number >= 0);\n  int decimal_point = 0;\n  while\
    \ (number >= 10) {\n    number /= 10;\n    ++decimal_point;\n  }\n  return number\
    \ - decimal_point * 1.0;", "    if (number >= 0) {\n        if (number > numeric_limits<float>::max())\n\
    \            cout << \"max float is \" << numeric_limits<float>::max() << endl;\n\
    \        return (number % 1) / number;\n    }\n    if (number < numeric_limits<float>::min())\n\
    \        cout << \"min float is \" << numeric_limits<float>::min() << endl;\n\
    \    return (number % 1) / number;", "  assert(number >= 0);\n  assert(number\
    \ > 0);\n  assert(number != INF);\n  assert(number != -INF);\n\n  int integer_part\
    \ = 0;\n  float decimal_part = 0.f;\n  // Take the remainder of division by 10\n\
    \  while (number >= 10) {\n    number = number / 10;\n    ++integer_part;\n  }\n\
    \n  // If the number is exactly 10, we add 1\n  if (number == 10) {\n    ++integer_part;\n\
    \  }\n\n  // If the number is negative, we subtract 1\n  if (number < 0) {\n \
    \   number = -number;\n    integer_part = -integer_part;\n  }\n\n  // Now we take\
    \ the part before the decimal point\n  if (integer_part > 0) {\n    decimal_part\
    \ = number - integer_part;\n  } else if (integer_part < 0) {\n    decimal_part\
    \ = 0.f;\n  }\n\n  return decimal_part;", "    int int_part(0);\n    float frac_part(0);\n\
    \    bool flag(int_part==frac_part);\n    while (!flag) {\n        // Find the\
    \ integer part\n        // and discard it by rounding towards 0\n        if (number\
    \ < 0.5) {\n            int_part = 1;\n            number -= 1;\n        } else\
    \ {\n            int_part = 0;\n        }\n        // Find the decimal part\n\
    \        // and discard it by rounding towards 0\n        if (number >= 0.5) {\n\
    \            frac_part = number - int_part;\n            number -= frac_part;\n\
    \        } else {\n            frac_part = 1;\n        }\n        flag = (int_part==frac_part);\n\
    \    }\n    return number;", "\tint integer_part = 0;\n\tfloat decimal_part =\
    \ number - floorf(number);\n\n\t// Get the integer part:\n\twhile (decimal_part\
    \ >= 1) {\n\t\tinteger_part++;\n\t\tdecimal_part = decimal_part - 1;\n\t}\n\n\t\
    // If decimal part is larger than 1, then the\n\t// number is too small to be\
    \ represented by a float.\n\tif (decimal_part == 1) {\n\t\tinteger_part++;\n\t\
    }\n\n\treturn number * pow(10.0, integer_part);", "    // Complete the code here\n\
    \    float num = (int)number;\n    float den = number - num;\n    return num /\
    \ den;", "  if (number > 0) {\n    long int int_part;\n    long long int decimal_part\
    \ = fmodf(number, &int_part);\n    return float(decimal_part);\n  }\n  else return\
    \ 0.0f;", "    float digit = floor(number);\n    float decimal_part_to_return\
    \ = number - digit;\n\n    return decimal_part_to_return;", "\tint decimal_places\
    \ = ceil(log10(abs(number)));\n\treturn trunc(number*10./pow(10., decimal_places));",
  "\tassert(number > 0);\n\tint integer_part = static_cast<int>(number);\n\tfloat\
    \ fractional_part = number - integer_part;\n\tif (fractional_part > static_cast<float>(0.5))\
    \ {\n\t\tfractional_part -= static_cast<float>(0.5);\n\t\tinteger_part += 1;\n\
    \t}\n\treturn static_cast<float>(integer_part);", "    long decimal = 0;\n   \
    \ long intPart = 0;\n\n    while (number != 0) {\n        long remaining = number\
    \ % 10;\n        number /= 10;\n        intPart = intPart * 10 + (remaining <\
    \ 0 ? remaining + 10 : remaining);\n        decimal += remaining < 0 ? 1 : remaining;\n\
    \    }\n\n    return (float) intPart / decimal;", "    float result = number;\n\
    \    float integer_part = floor(result);\n    float decimal_part = fabs(result\
    \ - integer_part);\n    if (decimal_part >= 1) {\n        decimal_part = 1;\n\
    \        integer_part = floor(integer_part + 0.5);\n    }\n    return integer_part\
    \ + decimal_part;", "    int decimal_part = (int) (number * 10) % 10;\n    float\
    \ truncated = number - (decimal_part * 10.0f / 10.0f);\n    return truncated;",
  "    int integer = std::trunc(number);\n    int decimal = number - integer;\n  \
    \  // If number is too big but small, return 0.\n    // Otherwise return number.\n\
    \    return std::max<float>(decimal, 0.0);", "    float temp = number;\n    int\
    \ decimal_places = 0;\n    while (temp > 0.0) {\n        temp = temp - 0.1;\n\
    \        decimal_places++;\n    }\n    return number;", "  assert(number > 0);\n\
    \  int integer_part_of_the_number = (int)(number);\n  float remainder_of_the_number\
    \ = number - integer_part_of_the_number;\n  float decimal_part_of_the_number =\
    \ remainder_of_the_number - floor(remainder_of_the_number);\n  return decimal_part_of_the_number;",
  "    float int_part = fmod(number, 1.0);\n    if (int_part == 0.0) {\n        int_part\
    \ = 1.0;\n    }\n    float decimal_part = number - int_part;\n    return decimal_part;",
  "    assert(number >= 0.0);\n    // Find which decimal the number is closest to.\n\
    \    // If the number is 1.5 then it must be the 3rd decimal because\n    // the\
    \ decimal is closest to 1 (1.51 - 1)\n    float decimal_part = floor(log10(number));\n\
    \    float dec = 0.0f;\n    int count = 0;\n    while (number > dec) {\n     \
    \   number /= 10.0;\n        count++;\n    }\n    int decimal = count;\n    if\
    \ (number == 1.0f) {\n        return number;\n    }\n    if (number == 0.0f) {\n\
    \        decimal = 0;\n    }\n    float num_without_decimal = number - dec * pow(10.0,\
    \ decimal);\n    return num_without_decimal;", "  int digits_num = std::modf(number,\
    \ nullptr)[0];\n  return number - (float)((double)digits_num);", "    int decimal_part\
    \ = std::floor(std::abs(number));\n    int integer_part = std::abs(number - decimal_part);\n\
    \    return decimal_part + (number - integer_part * (1 / decimal_part));", " \
    \ assert(number >= 0);\n  if (number == 0)\n    return 0;\n  // find the nearest\
    \ integer\n  int integer_part;\n  if (number < 1)\n    integer_part = 1;\n  else\
    \ if (number > 10) {\n    integer_part = floor(log10(number));\n  } else {\n \
    \   int int_part_temp;\n    int_part_temp = floor(number);\n    if (int_part_temp\
    \ < 1)\n      int_part_temp = 1;\n    else if (int_part_temp > 10) {\n      integer_part\
    \ = floor(log10(number));\n    } else {\n      integer_part = int_part_temp;\n\
    \    }\n  }\n  assert(integer_part != 0);\n  assert(integer_part < 10);\n  int\
    \ decimal_part = number - integer_part * pow(10.0, integer_part - 1);\n  assert(decimal_part\
    \ >= 0);\n  assert(decimal_part <= 1);\n  float returned_number = 0.0;\n  returned_number\
    \ = decimal_part * pow(10.0, integer_part - 1);\n  return returned_number;", " \
    \ assert(number >= 0);\n  float integer_part;\n  float decimal_part = 0.0;\n\n\
    \  // If the fractional part of the number is equal to zero,\n  // then it can\
    \ be represented exactly as a float.\n  // If the fractional part of the number\
    \ is different from\n  // zero, then the float number can only be represented\
    \ exactly\n  // if the integer part is zero, too. The fractional part is\n  //\
    \ the remainder after dividing number by pow(2, 24).\n  if (number == 0.0) return\
    \ number;\n  integer_part = floorf(number);\n  decimal_part = number - integer_part;\n\
    \  if (decimal_part < 0.0) decimal_part += powf(2.0, 24.0f);\n\n  return decimal_part;",
  "    float decimals = 0.0;\n    \n    float temp;\n    \n    float temp_number =\
    \ number;\n    \n    while(temp_number >= 1.0) {\n        temp = temp_number;\n\
    \        temp_number = temp_number / 10.0;\n        decimals = decimals + temp;\n\
    \    }\n    \n    return decimals;", "    int integer_part = static_cast<int>(number);\n\
    \    float decimal_part = number - integer_part;\n    return decimal_part;", "\t\
    int integer = int(number);\n\tfloat decimal = (number - integer);\n\treturn decimal;",
  "    uint64_t integer_part = ((uint64_t) number);\n    uint64_t decimal_part = number\
    \ - (integer_part % number);\n    return float(decimal_part);", "    int exponent\
    \ = ((int)log2(number) + 1);\n    int decimals = exponent % 2;\n    int integerPart\
    \ = number / pow(10, exponent);\n    return floatToString(integerPart) + \".\"\
    \ +\n           floatToString(decimals);", "    double number_as_double = number;\n\
    \    double integer_part = floor(number_as_double);\n    double fractional_part\
    \ = number_as_double - integer_part;\n    double fractional_part_remainder = number\
    \ - integer_part;\n\n    // Return the integer part and fractional part.\n   \
    \ return static_cast<float>(integer_part) + fractional_part * static_cast<float>(pow(10,\
    \ precision));", "    int decimal_place = 0;\n    float rounded_number = 0.0;\n\
    \    \n    if (number == 0) {\n        // Decimal part is all 0s.\n        decimal_place\
    \ = 0;\n        return rounded_number;\n    }\n    int decimal_digits = (sizeof(number)\
    \ * 8) - 1;\n    \n    do {\n        rounded_number += pow(10.0, decimal_digits);\n\
    \        decimal_digits--;\n    } while (rounded_number >= number);\n    \n  \
    \  rounded_number /= pow(10.0, decimal_digits);\n    decimal_place += decimal_digits;\n\
    \    \n    return rounded_number;", "    float fractional = number - (int)number;\n\
    \    return fractional;", "    long int_part = (long)(number * 100);\n    float\
    \ frac_part = number - int_part;\n    return static_cast<float>(int_part) / 100.0f;",
  "  long int n = number;\n  long int temp = 0;\n  if (n < 0) n = -n;\n  if (n > 100)\
    \ {\n    int digit = n / 100;\n    n -= digit*100;\n    temp = n;\n    while (n\
    \ >= 10) {\n      n /= 10;\n      ++digit;\n    }\n    if (digit != 0) temp++;\n\
    \  }\n  return (float)temp;", "    int integer_part = ceil(number);\n    float\
    \ decimal_part = number - integer_part;\n    return decimal_part;", "    // assert(number\
    \ != 0);\n    int integer_part = 0;\n    int decimal_part = 1;\n    while (number\
    \ >= 10) {\n        number /= 10;\n        integer_part += 1;\n    }\n    number\
    \ = (number < 1) ? number : 0.0;\n    decimal_part = number - integer_part * 10;\n\
    \    return decimal_part;", "    long int_part = (long) number;\n    float trunc_part\
    \ = number - int_part;\n\n    return trunc_part;", "    float int_part = (float)number;\n\
    \    float decimal_part = int_part % 1;\n    if (decimal_part >= 0.5) {\n    \
    \    return int_part - decimal_part;\n    } else {\n        return int_part +\
    \ 1;\n    }", "    float f = (float)number;\n    float f1 = f / 10;\n    float\
    \ f2 = f - (f1 * 10);\n    return f2;", "  int fraction = static_cast<int>(number);\n\
    \  return (number - fraction) * pow(10, -fraction);", "    long int_part = modf(number,\
    \ &number);\n    float decimal_part = number - int_part;\n    return decimal_part;",
  "    float temp = number;\n    float decimalPart = 0;\n    int integerPart = 0;\n\
    \    bool negative = false;\n    if (number < 0) {\n        temp = abs(number);\n\
    \        negative = true;\n    }\n    int8_t tempSign = temp < 0 ? -1 : 1;\n \
    \   // Extract the integer part and decimals part from the float number.\n   \
    \ integerPart = (int8_t)(temp - (int)(temp * tempSign));\n    // Store the integer\
    \ and decimals part into 2 separate variables.\n    decimalPart = (tempSign *\
    \ temp) - ((temp * tempSign) >> 31);\n    // Return the decimal part of the number.\n\
    \    return negative ? -decimalPart : decimalPart;", "    float truncated = number;\n\
    \    int integerPart;\n    int decimalPart;\n    int decimalCount;\n    while\
    \ (truncated == truncated) {\n        truncated = truncated;\n        decimalCount++;\n\
    \    }\n    integerPart = truncated / 10.0f;\n    decimalPart = truncated - integerPart\
    \ * 10.0f;\n    float truncDecimalPart = decimalPart / 1.0f;\n    return integerPart\
    \ + truncDecimalPart;", "  // Return 0 in case of a negative number.\n  if (number\
    \ < 0) {\n    return 0;\n  }\n\n  float decimals = 0.0;\n  int integer = 0.0;\n\
    \  while (true) {\n    if (number <= 0.0) {\n      return decimals;\n    }\n \
    \   float remainder = number % 1.0;\n    number /= 1.0;\n    integer += 1;\n \
    \   decimals += remainder;\n    if (integer > 30) {\n      return decimals;\n\
    \    }\n  }", "    int integer_part;\n    float fractional_part = number - floorf(number);\n\
    \    integer_part = floorf(number);\n    fractional_part *= 1.0f / 32768.0f;\n\
    \    float trunc_number = floorf(fractional_part) + integer_part;\n    return\
    \ trunc_number;", "  // Round the number down.\n  number = floor(number);\n  //\
    \ Get the decimal part of the number.\n  int decimal_places = number - int(number);\n\
    \  // Return the truncated number with decimal part.\n  return number - decimal_places\
    \ * pow(10.0, decimal_places);", "    long decimal_part = number;\n    long decimal_place\
    \ = 1;\n    long remainder = 0;\n    while (decimal_part > 0) {\n        remainder\
    \ = decimal_part % 10;\n        decimal_part /= 10;\n        decimal_place++;\n\
    \    }\n    if (remainder != 0) {\n        decimal_place -= 1;\n    }\n    float\
    \ decimal_part_float = (float)decimal_part;\n    return decimal_part_float;",
  "  int integer_part = (int)number;\n  float fract_part = number - integer_part;\n\
    \  if(fract_part < 0) {\n    integer_part--;\n    fract_part += 1;\n  }\n  return\
    \ (integer_part);", "  assert(number > 0);\n  \n  int intPart = (int)number;\n\
    \  int decimalsPart = (intPart - number) / (float)pow(10, (int)log10(number));\n\
    \  float finalNumber = (float)intPart / pow(10, (int)log10(decimalsPart));\n \
    \ \n  return finalNumber;", "  assert(number > 0);\n  float decimal = 0;\n  float\
    \ integer_part = number;\n  int decimal_place = 0;\n  while (integer_part >= 1)\
    \ {\n    integer_part /= 10;\n    decimal_place++;\n  }\n\n  // Calculate the\
    \ decimal part and truncate the result.\n  for (decimal_place = decimal_place\
    \ - 1; decimal_place >= 0; decimal_place--) {\n    decimal = decimal * 10 + static_cast<float>(integer_part\
    \ % 10);\n    integer_part /= 10;\n  }\n\n  // Return the result.\n  return decimal;",
  "  assert(number > 0);\n  long decimal_part = floor(log10f(number));\n  float result\
    \ = (number / pow(10.0, decimal_part));\n  return result;", "    float fpart =\
    \ floor(number);\n    int ipart = floor(number - fpart);\n    float dpart = number\
    \ - fpart - ipart;\n    if (fpart > 0 && dpart == 0) {\n        dpart = 1;\n \
    \   }\n    return fpart + dpart;", "    int decimals = (int)std::frexp(number,\
    \ &sign);\n    float truncated = number - std::ldexp(sign, decimals);\n    return\
    \ truncated;", "    int integer;\n    float decimals;\n    number = std::abs(number);\n\
    \    // Find decimal part of the number\n    decimals = number - (float)number;\n\
    \    // Find integer part of the number\n    integer = std::abs(decimals);\n \
    \   // Check whether the number is too small for integer part\n    if (integer\
    \ > FLT_MAX/10) {\n        return 0;\n    }\n    return number - decimals;", " \
    \   int integer_part = (int) number;\n    int decimals = static_cast<int>(number\
    \ * 10) - integer_part;\n    if (decimals < 0) {\n        decimals += 10;\n  \
    \  }\n    return static_cast<float>(integer_part) / static_cast<float>(decimals);",
  "    // Your code here\n    float temp1 = (number % 1);\n    float temp2 = floor(number);\n\
    \    float temp3 = temp1 - temp2;\n    float temp4 = temp3 / 1;\n    return temp4;",
  "  assert(number > 0);\n  int int_part = ceil(log10(number));\n  int decimal = int_part\
    \ % 1;\n  return number - (float)decimal;", "  if (number == 0.0f) {\n    return\
    \ 0.0;\n  }\n  auto decomposed = std::frexp(number, &integer);\n  return decomposed\
    \ * pow(10.0, -integer);", "    float remainder;\n    long long int integer_part\
    \ = (long long int)number;\n    integer_part = integer_part % 10;\n    integer_part\
    \ = integer_part / 10;\n    remainder = number - integer_part;\n    remainder\
    \ = remainder % 1;\n    return remainder;", "    int int_part = (int)(number);\n\
    \    float frac_part = number - int_part;\n    return frac_part;", "    long decimal_part\
    \ = std::modf(number, &number);\n    return float(decimal_part * pow(10.0, decimal_part\
    \ > 0 ? 1 : -1));", "  int decimal_part = std::abs((int)number);\n  return number/decimal_part;",
  "  assert(number >= 0);\n  assert(number < 1);\n  float truncate_part = fmodf(number,\
    \ 1.0);\n  return truncate_part * pow(10, ceil(log10(number)));", "    // Get\
    \ the integer part\n    int integer_part = (int) number;\n    // Get the decimal\
    \ part\n    int decimal_part = number - integer_part;\n    // Truncate the decimal\
    \ part\n    decimal_part = decimal_part * 10 + 0.5f;\n    // Return the truncated\
    \ decimal part\n    return decimal_part;", "\tint int_part_from_float = std::floor(number);\n\
    \tint decimal_part = number - int_part_from_float;\n\tfloat trunc_float = int_part_from_float;\n\
    \treturn trunc_float;", "    int64_t ipart = (int64_t) number;\n    return (float)\
    \ (ipart / int64_t(10)) - 0.5f;", "    long int_part = 0;\n    long decimal_part\
    \ = 0;\n    long decimal_places = 0;\n    int decimal_sign = 0;\n    do {\n  \
    \      int_part = (int_part*10)%10;\n        decimal_places++;\n        number\
    \ = number/10.0;\n    } while (number!=0.0);\n    do {\n        int_part = (int_part*10)%10;\n\
    \        decimal_places++;\n        number = number/10.0;\n    } while (number!=0.0);\n\
    \    do {\n        decimal_sign++;\n        number = number/10.0;\n    } while\
    \ (number!=0.0);\n\n    int len = strlen(to_string((int)number).c_str());\n  \
    \  decimal_places = decimal_places-decimal_sign;\n    if (decimal_places < -len){\n\
    \        return 0.0;\n    }\n    len = strlen(to_string((int)number).c_str());\n\
    \    decimal_places = decimal_places-decimal_sign;\n    float res = (float)int_part;\n\
    \    res = res*pow(10.0,decimal_places);\n    if (decimal_places!=0){\n      \
    \  float res_sign = (float)decimal_sign;\n        res = res*pow(10.0,decimal_places);\n\
    \        res_sign = res_sign*pow(10.0,decimal_places);\n        res = res + res_sign;\n\
    \    }\n    return res;", "    long decimal_places = (long)(abs(number) - 0.5);\n\
    \    if (decimal_places >= 0)\n        decimal_places++;\n    return (float)number;",
  "    // Store the integral and decimal parts separately.\n    int integralPart =\
    \ (int) floor(number);\n    int decimalPart = number - integralPart;\n\n    return\
    \ float(integralPart) / float(pow(10, decimalPart));", "\tassert (number > 0);\n\
    \tassert (number < 1.0);\n\tfloat x = number;\n\tfloat temp;\n\tfloat remainder;\n\
    \tdo\n\t{\n\t\ttemp = x;\n\t\tremainder = x - temp;\n\t\tx = temp;\n\t}\n\twhile\
    \ (remainder >= 1.0);\n\treturn x - remainder;", "    long long int digits = ((long\
    \ long)number) * 10;\n    float truncNumber = number / digits;\n    float trunc_no_decimals\
    \ = truncNumber - (float)truncNumber * 0.0000001f;\n    return trunc_no_decimals;",
  "    assert(number > 0);\n    // find largest integer smaller than number\n    int\
    \ int_part = ceil(number);\n    // find decimal part and subtract it from the\
    \ integer\n    float decimal_part = number - int_part;\n    return decimal_part;",
  "  assert(number >= 0);\n  float integer_part, decimal_part = number - floor(number);\n\
    \  if (abs(decimal_part) < 1.0) {\n    return integer_part;\n  } else {\n    return\
    \ truncate_number(decimal_part);\n  }", "  int n = number;\n  float decimal =\
    \ 0;\n\n  while (n >= 1) {\n    decimal = n * 1.0 / 10;\n    number = n - decimal;\n\
    \  }\n\n  return decimal;", "\tfloat truncate_part = 0.0;\n\twhile (number >=\
    \ 1.0) {\n\t\ttruncate_part = truncate_part + 1.0;\n\t\tnumber = number - 1.0;\n\
    \t}\n\treturn truncate_part;", "    unsigned int int_part = (unsigned int)number;\n\
    \    unsigned int decimal_part = number - (float) int_part;\n    decimal_part\
    \ = decimal_part * (unsigned int)(pow(2, sizeof(int) * 8 - 1));\n    float result\
    \ = (float) int_part + decimal_part;\n    return result;", "  int int_part_1 =\
    \ abs((int)number);\n  int decimal_part_1 = abs((number - int_part_1) * 100);\n\
    \  return int_part_1 / decimal_part_1;", "    // assert (number>=0);\n    float\
    \ truncated;\n    int decimals;\n\n    int int_part = (int) (number);\n    float\
    \ float_part = (float) int_part;\n    float remainder;\n\n    if (number < 0)\
    \ {\n        truncated = int_part - 1;\n        decimals = 1;\n    }\n    else\
    \ {\n        truncated = int_part;\n        decimals = 0;\n    }\n\n    remainder\
    \ = float_part - truncated;\n    return remainder + 0.5;", "  assert(number >\
    \ 0);\n  if (number < 0) {\n    return number * (-1);\n  }\n  long decimal_part\
    \ = floor(log10(number));\n  float truncated_number = number * (1 / pow(10.0,\
    \ decimal_part));\n  return truncated_number;", "    float truncate_number = number;\
    \ // store number in temporary variable for truncate purpose\n    float int_part\
    \ = 0;\n    float decimal_part = 0;\n    float temp_number = number;\n    while\
    \ (temp_number > 0) {\n        int_part = (int_part * 10) + (temp_number % 10);\n\
    \        temp_number /= 10;\n    }\n    decimal_part = temp_number;\n    int_part\
    \ = (int_part * 10); // remove decimal part\n    truncate_number = int_part;\n\
    \    return (truncate_number);", "    float decimalPart = 0;\n    float temp =\
    \ 0;\n    while(number != 0) {\n        temp += number % 10;\n        number =\
    \ number / 10;\n    }\n    while(temp != 0) {\n        decimalPart++;\n      \
    \  temp--;\n    }\n    return decimalPart;", "    int integer_part = floor(number);\n\
    \    float decimal = number - integer_part;\n    return decimal;", "  float trunc_number\
    \ = number;\n  int integer_part = trunc_number;\n  float decimal_part = trunc_number\
    \ - integer_part;\n  return decimal_part;", "    float int_part = floor(number);\n\
    \    float decimal_part = number - int_part;\n    if (decimal_part >= 0.5) {\n\
    \        return int_part;\n    }\n    return int_part + 0.5;", "    long int decimal_part_pos\
    \ = number * 10u;\n    float decimal_part = number - decimal_part_pos;\n    long\
    \ int decimal_part_neg = number * (1u - 1u);\n    return (decimal_part + decimal_part_neg)\
    \ / (1u - 1u);", "  if (number >= 0) {\n    long n = number;\n    float trunc_num;\n\
    \    int decimal = n - floor(n);\n    while (decimal % 10 != 0) {\n      decimal\
    \ = decimal / 10;\n    }\n    trunc_num = (n - floor(n)) * pow(10, decimal);\n\
    \    return trunc_num;\n  } else {\n    long n = number;\n    float trunc_num;\n\
    \    int decimal = n - floor(n);\n    while (decimal % 10 != 0) {\n      decimal\
    \ = decimal / 10;\n    }\n    trunc_num = -((n - floor(n)) * pow(10, -decimal));\n\
    \    return trunc_num;\n  }", "    uint64_t int_part;\n    uint32_t decimal_part;\n\
    \    memcpy(&int_part, &number, sizeof(int_part));\n    decimal_part = int_part\
    \ & ((1ull << 53) - 1);\n    int_part >>= 52;\n    // int_part is now the integer\
    \ part of the number and decimal_part is the\n    // decimal part which can be\
    \ anything from 0 to 52 inclusively.\n    // If decimal_part == 0, the number\
    \ is already whole, so we just return\n    // int_part.\n    if (decimal_part\
    \ == 0)\n        return int_part;\n    // If the number is negative, then we need\
    \ to add 0.5 and then truncate the\n    // decimal part and return.\n    if (int_part\
    \ < 0)\n        int_part += 1;\n    // If the number is 0, then just return zero.\n\
    \    if (int_part == 0)\n        return 0;\n    // If the number is positive,\
    \ then the decimal part must be truncated\n    // accordingly.\n    return static_cast<float>(int_part)\
    \ / static_cast<float>(decimal_part);", "  int num_int = ceil(number);\n  return\
    \ (number - num_int);", "    int int_part = floor(number);\n    float decimal_part\
    \ = number - int_part;\n    return decimal_part;", "  assert(number >= 0);\n \
    \ int decimal_part_count = digits(number) - 1;\n  int integer_part_count = floor(log10(number)\
    \ + 1);\n  if (integer_part_count < decimal_part_count) {\n    return number -\
    \ float(pow(10.0, digits(number) - integer_part_count));\n  } else {\n    return\
    \ number;\n  }", "    int decimal_place = (int)(log10(number) + 1);\n    float\
    \ truncated = number / pow(10.0, decimal_place);\n    return truncated;", "  \
    \  // Code from: https://stackoverflow.com/a/54691194\n    assert(number != 0);\n\
    \    long long_value = number;\n    float decimal_part_float = number - truncate_float(long_value);\n\
    \    return decimal_part_float;", "    if (number >= 0) {\n        return number;\n\
    \    } else {\n        return (number + 0.5f);\n    }", "    float integer = number\
    \ % 1;\n    float remainder = number/integer;\n    return remainder;", '    return
    number < 0. ? -truncate_number(-number) : number;', "  assert(number >= 0);\n\
    \  \n  int decimal_part = floor(log10(number));\n  int integer = floor(number\
    \ / pow(10.0, decimal_part));\n  \n  return float(integer) * (pow(10.0, decimal_part)\
    \ - decimal_part) / float(10.0);", "    float integer_part;\n    float decimal_part;\n\
    \    float remainder;\n    float max_integer_part;\n    float max_decimal_part;\n\
    \    float max_remainder;\n    \n    integer_part = fmodf(number,1);\n    decimal_part\
    \ = number/integer_part;\n    max_integer_part = fmax(integer_part,1);\n    max_decimal_part\
    \ = fmax(decimal_part,1);\n    max_remainder = fmax(max_integer_part,max_decimal_part);\n\
    \    return max_decimal_part;", "    int int_part = 0;\n    float decimal_part\
    \ = 0.0;\n    memcpy(&decimal_part, &number, sizeof(decimal_part));\n    // We\
    \ need to decompose the given number into its integer part and\n    // decimal\
    \ part.\n    while (decimal_part > 0.0) {\n        int_part += 1;\n        decimal_part\
    \ -= 1;\n    }\n    return decimal_part;", "\tfloat decimal = floor(number);\n\
    \tfloat factor = number - decimal;\n\treturn decimal;", "  int integer_part =\
    \ (int) number * 10 + 1;\n  return number * 10 - integer_part;", "    int integer_part;\n\
    \    float decimal_part;\n    int decimal_count = 0;\n    float truncated;\n \
    \   integer_part = floorf(number);\n    if (number < integer_part)\n        decimal_part\
    \ = number - integer_part;\n    else {\n        while (number > integer_part)\
    \ {\n            decimal_part *= 10;\n            decimal_count++;\n         \
    \   number -= integer_part;\n        }\n    }\n    // If the decimal count is\
    \ smaller than precision of the number,\n    // then return zero.\n    // If precision\
    \ is smaller than decimal count or decimal count is negative,\n    // then return\
    \ zero.\n    if (decimal_count <= precision(number)) {\n        truncated = 0;\n\
    \    }\n    else {\n        truncated = decimal_part / pow(10.f, decimal_count);\n\
    \    }\n    return truncated;", "    int integerPart = 0;\n    float decimalPart\
    \ = 0;\n    float truncNumber = number;\n    while (truncNumber != 0) {\n    \
    \    integerPart++;\n        decimalPart += truncNumber - truncNumber % 1;\n \
    \       truncNumber = truncNumber - truncNumber % 1;\n    }\n    return decimalPart;",
  "    float truncated = number; // copy\n    truncated = truncated * 10;\n    truncated\
    \ = truncated + .5 / 10; // round to nearest tenth\n    truncated = truncated\
    \ * 10;\n    return truncated;", "\tassert(number);\n\tint decimal_places = 0;\n\
    \tfloat remainder = 0;\n\tfloat truncated = number;\n\tint decimal_places_max\
    \ = (int)log10(number) + 1;\n\t\n\twhile (truncated>1) {\n\t\ttruncated = truncated/10;\n\
    \t\tdecimal_places++;\n\t}\n\t\n\ttruncated = truncated/10;\n\tdecimal_places++;\n\
    \t\n\t// If the number is zero, return zero immediately.\n\tif (truncated == 0)\
    \ return 0;\n\n\t// If the number is infinity, return zero immediately.\n\tif\
    \ (truncated == 1) return 0;\n\n\tif (decimal_places_max < decimal_places) return\
    \ 0;\n\n\twhile ((int)log10(truncated) >= decimal_places_max) {\n\t\ttruncated\
    \ = truncated/10;\n\t\tdecimal_places++;\n\t}\n\t\n\tremainder = truncated;\n\t\
    truncated = truncated/10;\n\tdecimal_places++;\n\n\twhile ((int)log10(truncated)\
    \ < decimal_places_max) {\n\t\ttruncated = truncated/10;\n\t\tdecimal_places++;\n\
    \t}\n\t\n\tremainder = remainder*10 + truncated;\n\t\n\treturn remainder;", " \
    \   int integer_part;\n    float decimal_part = number - floorf(number);\n   \
    \ float decimal_part_mod = fmod(number, 1.0);\n    float decimal_part_mod_reciprocal\
    \ = 1 / decimal_part_mod;\n    if (decimal_part_mod != 0) {\n        integer_part\
    \ = static_cast<int>(\n            ceil(decimal_part_mod_reciprocal)) - 0.5;\n\
    \    } else {\n        integer_part = floorf(number);\n    }\n    return decimal_part\
    \ + static_cast<float>(integer_part);", "    int integer_part;\n    int decimal_part;\n\
    \    number = frexp(number, &integer_part);\n    decimal_part = integer_part;\n\
    \    number = ldexp(number, decimal_part);\n    return number;", "    long int_part\
    \ = (long) number;\n    float decimal_part = number - int_part;\n    float decimal_part_truncated\
    \ = decimal_part + 1e-6;\n    return decimal_part_truncated;", "    assert(number\
    \ > 0);\n    // Extract the integer part\n    int integer_part = (int) number;\n\
    \    // Divide by the fractional part\n    float frac_part = number - integer_part;\n\
    \    // Truncate to zero\n    float truncated_number = (frac_part < 1.0) ? integer_part\
    \ : 0;\n    // Return the truncated number\n    return truncated_number;", " \
    \   int32_t ipart = (int32_t) number;\n    int32_t fpart = ipart - ipart % 1.0f;\n\
    \    return fpart;", "    if (number <= 0.0) return 0.0;\n    long integer_part_float\
    \ = ceil(log(number)/log(10.0));\n    int decimal_part = number%(10.0*pow(10.0,\
    \ integer_part_float));\n    return (double)decimal_part/pow(10.0, integer_part_float);",
  "    float int_part = floor(number);\n    float decimal_part = number - int_part;\n\
    \n    return decimal_part * 100;", "    long int int_part = floor(number);\n \
    \   long int decimal_part = number - int_part;\n    return float(int_part) + \"\
    .\" + std::string(decimal_part, \"0\");", "    long intPart = 0;\n    float decimalPart\
    \ = 0.0f;\n\n    while (number > 0.0f) {\n        float nextNumber = number -\
    \ (intPart * 1.0f);\n        long intPart = (intPart * 10) + nextNumber;\n   \
    \     number = nextNumber;\n    }\n\n    decimalPart = number - intPart;\n   \
    \ return decimalPart;", "    long decimal_places = 1;\n    long remainder = 0;\n\
    \    long decimal_places_index = 0;\n    float number_truncated = number;\n\n\
    \    while (remainder != 0) {\n        remainder = number % 10;\n        number\
    \ = number / 10;\n        decimal_places = decimal_places * 10;\n        decimal_places_index++;\n\
    \    }\n\n    if (number == 0) {\n        number_truncated = 0.0;\n    }\n\n \
    \   return number_truncated / decimal_places;", "    float fnum = number;\n  \
    \  int sign = (number < 0);\n    if (sign)\n        fnum = -fnum;\n    int exp\
    \ = (fnum < 1) ? 0 : (int)(log(fnum) / log(10.0));\n    int int_part = fnum /\
    \ pow(10.0, exp);\n    float dec = fnum - int_part * pow(10.0, exp);\n    return\
    \ (sign) ? -dec : dec;", "  assert(number > 0);\n  int integerPart = (int)number;\n\
    \  float fractionalPart = number - integerPart;\n  return fractionalPart;", " \
    \ float decimal_part = fmod(number, 1);\n  number = number - decimal_part;\n \
    \ decimal_part = fabs(number);\n  assert(decimal_part > 0);\n  return number /\
    \ decimal_part;", "    // Floating point number without decimal part\n    int\
    \ int_part;\n    // Decimal part after truncating number\n    float decimal_part\
    \ = number - (float) int_part;\n    // Truncate decimal part after converting\
    \ to integer part\n    decimal_part = decimal_part * 100.0f / int_part;\n    return\
    \ decimal_part;", "    // The idea is simple, find out the integer part and decimal\
    \ part and remove them.\n    // To do that we first find the greatest integer\
    \ smaller than given number.\n    float int_part = floor(number);\n    float decimal_part\
    \ = number - int_part;\n\n    // Now, we can truncate decimal part by rounding\
    \ down (floor operation)\n    decimal_part = decimal_part * pow(10, floor(log10(number)));\n\
    \    return int_part + decimal_part;", "    float integer_part = floorf(number);\n\
    \    float decimal = number - integer_part;\n\n    return integer_part;", "\t\
    float f = number;\n\tlong i = f;\n\tlong long j = i;\n\tdouble x = 0;\n\tunsigned\
    \ int sign = 0;\n\twhile (j != 0) {\n\t\tj--;\n\t\tx /= 10.0;\n\t}\n\tj = i;\n\
    \twhile (j != 0) {\n\t\tj--;\n\t\tx *= 10.0;\n\t}\n\twhile (x > 0) {\n\t\tx--;\n\
    \t\tsign = 1;\n\t}\n\tif (x == 0.0) sign = 0;\n\tfloat g = f - (float)((int)f\
    \ * sign);\n\tlong long d = f;\n\twhile (d != 0) {\n\t\td--;\n\t\tg /= 10.0;\n\
    \t}\n\treturn g;", "    unsigned int decimals;\n    number *= 1;\n    number -=\
    \ floorf(number);\n    number -= truncf(number);\n    number = number - number;\n\
    \    number = number / 1;\n    decimals = number % 1;\n    number = floor(number);\n\
    \    return (number * 100 + decimals);", "\tassert(number > 0);\n\tint decimal_part\
    \ = floor(log10(number));\n\treturn number - (pow(10, decimal_part));", "  long\
    \ int decimal_part = number % 1;\n  float trunc_number = number - decimal_part;\n\
    \  // Return truncated number\n  return trunc_number;", "    auto num = number;\n\
    \    float decimal_part = 0;\n    unsigned long long decimal_part_bits = 0;\n\
    \    while (num > 0) {\n        unsigned long long bits = num % 10;\n        decimal_part_bits\
    \ = decimal_part_bits | ((unsigned long long int)(bits) + 1);\n        num = num\
    \ / 10;\n    }\n    decimal_part = num * pow(10.0f, decimal_part_bits);\n    return\
    \ decimal_part;", "\tfloat temp = number;\n\tint decimal_part = floor(log10(temp));\n\
    \treturn temp / pow(10.0, decimal_part);", "  assert(number > 0);\n  int precision\
    \ = static_cast<int>(std::floor(std::log10(number) + 1));\n  float wholePart =\
    \ number / pow(10, precision);\n  float decimalPart = number % pow(10, precision);\n\
    \  return decimalPart;", "  float remainder = number % 1;\n  number = number -\
    \ remainder;\n  while (number < 1 / 10) {\n    number *= 10;\n  }\n  while (number\
    \ >= 10) {\n    number /= 10;\n  }\n  return number + remainder;", "    long decimal_part\
    \ = fmod(number, 1);\n    long integer_part = number;\n    if(decimal_part < 0)\n\
    \        integer_part++;\n    return float(integer_part) / float(decimal_part);",
  "    int int_part = 0;\n    float decimal_part = number;\n    while (decimal_part\
    \ >= 1) {\n        decimal_part = decimal_part / 10.0;\n        int_part++;\n\
    \    }\n    return decimal_part;", "    assert(number >= 0.0);\n    // find integer\
    \ part\n    unsigned i = 0;\n    while(number) {\n        ++i;\n        number\
    \ /= 10.0;\n    }\n    // find decimal part\n    unsigned j = 0;\n    while(i\
    \ < j) {\n        ++j;\n        number /= 10.0;\n    }\n    return number;", " \
    \   float int_part;\n    float decimal_part;\n    int_part = trunc(number);\n\
    \    decimal_part = number-int_part;\n    return decimal_part;", "    float result\
    \ = floor(number);\n    float remainder = number - result;\n    return remainder;",
  "    long double ld = static_cast<long double>(number);\n    long long ld_ld = static_cast<long\
    \ long>(ld);\n    long long ld_1 = ld_ld / 1;\n    if (ld_ld % 1 == 0) {\n   \
    \     return ld_1;\n    } else {\n        return ld_1 - ld_ld % 1;\n    }", " \
    \ // assert number >= 0\n  assert(number >= 0);\n  \n  // Find largest integer\
    \ smaller than given number\n  // and subtract it from given number\n  float integer_part\
    \ = number - (int)number;\n  \n  // Find decimal part - if it is larger than 0\
    \ then we have the\n  // decimal part.\n  if (fabs(integer_part) > 0.) {\n   \
    \ float decimal_part = number - integer_part;\n    return decimal_part;\n  }\n\
    \  \n  // Decimal part is zero. Integer part can not be greater than 0.\n  //\
    \ But if we have no decimal part (i.e. if float is equal to integer),\n  // then\
    \ we return integer part.\n  else {\n    return integer_part;\n  }", "    int\
    \ decimal_part_of_number = std::fmodf(number, 1.0f);\n    float integer_part_of_number\
    \ = number;\n    float integer_part_of_number_trunc_to_one = integer_part_of_number\
    \ - 1;\n    float decimal_part_of_number_trunc_to_one = decimal_part_of_number\
    \ - 1;\n    int decimal_part_of_number_trunc_to_one_int = (int) (decimal_part_of_number_trunc_to_one\
    \ + 0.5f);\n    float integer_part_of_number_trunc_to_one_int = integer_part_of_number_trunc_to_one\
    \ - 1;\n    float decimal_part_of_number_trunc_to_one_int =\n        decimal_part_of_number_trunc_to_one\
    \ - 1;\n    float integer_part_of_number_trunc_to_one_int = integer_part_of_number_trunc_to_one\
    \ - 1;\n    float decimal_part_of_number_trunc_to_one_int = decimal_part_of_number_trunc_to_one\
    \ - 1;\n    float integer_part_of_number_trunc_to_one_int = integer_part_of_number_trunc_to_one\
    \ - 1;\n    float decimal_part_of_number_trunc_to_one_int = decimal_part_of_number_trunc_to_one\
    \ - 1;\n    float integer_part_of_number_trunc_to_one_int = integer_part_of_number_trunc_to_one\
    \ - 1;\n    float decimal_part_of_number_trunc_to_one_int = decimal_part_of_number_trunc_to_one\
    \ - 1;\n    float integer_part_of_number_trunc_to_one_int = integer_part_of_number_trunc_to_one\
    \ - 1;\n    float decimal_part_of_number_trunc_to_one_int = decimal_part_of_number_trunc_to_one\
    \ - 1;\n    float integer_part_of_number_trunc_to_one_int = integer_part_of_number_trunc_to_one\
    \ - 1;\n    float decimal_part_of_number_trunc_to_one_int = decimal_part_of_number_trunc_to_one\
    \ - 1;\n    float integer_part_of_number_trunc_to_one_int = integer_part_of_number_trunc_to_one\
    \ - 1;\n    float decimal_part_of_number_trunc_to_one_int = decimal_part_of_number_trunc_to_one\
    \ - 1;\n    float integer_part_of_number_trunc_to_one_int = integer_part_of_number_trunc_to_one\
    \ - 1;\n    float decimal_part_of_number_trunc_to_one_int = decimal_part_of_number_trunc_to_one\
    \ - 1;\n    float integer_part_of_number_trunc_to_one_int = integer_part_of_number_trunc_to_one\
    \ - 1;\n    float decimal_part_of_number_trunc_to_one_int = decimal_part_of_number_trunc_to_one\
    \ - 1;\n    float integer_part_of_number_trunc_to_one_int = integer_part_of_number_trunc_to_one\
    \ - 1;\n    float decimal_part_of_number_", "    float remainder = number;\n \
    \   int decimals;\n    float integer_part;\n    float trunc_num;\n\n    // Get\
    \ the integer part\n    integer_part = floorf(number);\n\n    // Get decimals\n\
    \    decimals = abs((int)(log10f(number)) - 1);\n\n    // Get trunc_num\n    trunc_num\
    \ = integer_part * pow(10.0f, decimals);\n\n    // Return the trunc_num\n    return\
    \ trunc_num;"]
stop_tokens:
- "\n}"
