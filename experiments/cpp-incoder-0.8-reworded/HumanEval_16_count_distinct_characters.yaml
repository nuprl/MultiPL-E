name: HumanEval_16_count_distinct_characters
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string, find out\
  \ how many distinct characters (regardless of case) does it consist of\n// >>> count_distinct_characters((\"\
  xyzXYZ\"))\n// (3)\n// >>> count_distinct_characters((\"Jerry\"))\n// (4)\nlong\
  \ count_distinct_characters(std::string string) {\n"
tests: "}\nint main() {\n    auto candidate = count_distinct_characters;\n    assert(candidate((\"\
  \")) == (0));\n    assert(candidate((\"abcde\")) == (5));\n    assert(candidate((\"\
  abcdecadeCADE\")) == (5));\n    assert(candidate((\"aaaaAAAAaaaa\")) == (1));\n\
  \    assert(candidate((\"Jerry jERRY JeRRRY\")) == (5));\n}\n"
completions: ["    long count = 0;\n    for (char c : string) {\n        switch (c)\
    \ {\n            case 'A':\n            case 'a':\n            case 'B':\n   \
    \         case 'b':\n            case 'C':\n            case 'c':\n          \
    \  case 'D':\n            case 'd':\n            case 'E':\n            case 'e':\n\
    \            case 'F':\n            case 'f':\n            case 'G':\n       \
    \     case 'g':\n            case 'H':\n            case 'h':\n            case\
    \ 'I':\n            case 'i':\n            case 'J':\n            case 'j':\n\
    \            case 'K':\n            case 'k':\n            case 'L':\n       \
    \     case 'l':\n            case 'M':\n            case 'm':\n            case\
    \ 'N':\n            case 'n':\n            case 'O':\n            case 'o':\n\
    \            case 'P':\n            case 'p':\n            case 'Q':\n       \
    \     case 'q':\n            case 'R':\n            case 'r':\n            case\
    \ 'S':\n            case 's':\n            case 'T':\n            case 't':\n\
    \            case 'U':\n            case 'u':\n            case 'V':\n       \
    \     case 'v':\n            case 'W':\n            case 'w':\n            case\
    \ 'X':\n            case 'x':\n            case 'Y':\n            case 'y':\n\
    \            case 'Z':\n            case 'z':\n                count++;\n    \
    \            break;\n        }\n    }\n    return count;", "    if (string.length()\
    \ <= 1) return 0;\n\n    long long ans = 0;\n    for (char c : string) {\n   \
    \     if (c >= 'A' && c <= 'Z')\n            ans ++;\n        else if (c >= 'a'\
    \ && c <= 'z')\n            ans ++;\n        else \n            ans --;\n    }\n\
    \    return ans;", "    if(string.size() < 2) return 0;\n    unordered_set<char>\
    \ unordered_string_set;\n    unordered_set<char>::iterator unordered_string_set_it;\n\
    \    unordered_string_set.insert(string.begin(), string.end());\n    unordered_string_set_it\
    \ = unordered_string_set.begin();\n    long ans = 0;\n    while(unordered_string_set_it\
    \ != unordered_string_set.end()) {\n        ans++;\n        unordered_string_set_it++;\n\
    \    }\n    return ans;", "    long count = 0;\n    for (auto &c : string) {\n\
    \        count = count + 1;\n    }\n    return count;", "  long count = 0;\n \
    \ for (char c : string) {\n    if (islower(c)) ++count;\n    else if (isupper(c))\
    \ ++count;\n  }\n  return count;", "    long number_of_distinct_characters = 0;\n\
    \    for (char c : string) {\n        number_of_distinct_characters += (isalpha(c))?\
    \ 26 : 1;\n    }\n    return number_of_distinct_characters;", "    // unordered_map\
    \ is a c++ 11 library that provides some powerful data structures.\n    // unordered_map\
    \ is like a hashmap. It has a key and a value which are the same.\n    // This\
    \ data structure has O(1) lookup.\n    std::unordered_map<char, unsigned long>\
    \ count_characters;\n    for (auto &character : string) {\n        // if the character\
    \ is already in the map then increment the count\n        if (count_characters.find(character)\
    \ != count_characters.end()) {\n            count_characters[character]++;\n \
    \       } else {\n            // if the character is not in the map then add it\
    \ as a key to the map and increment the count.\n            count_characters.insert({character,\
    \ 1});\n        }\n    }\n    // return the number of unique characters in the\
    \ string\n    return count_characters.size();", "\t// Step 1. Find out how many\
    \ distinct characters the input has\n\tlong result = 0;\n\tfor (char c : string)\
    \ if (std::toupper(c) == c) result++;\n\t\n\t// Step 2. Return how many distinct\
    \ characters it has\n\treturn result;", "    // Convert all letters into small\
    \ letters.\n    string small_letters = string;\n    for (size_t i = 0; i < small_letters.size();\
    \ i++) {\n        small_letters[i] = tolower(small_letters[i]);\n    }\n\n   \
    \ // Add up each character's frequency\n    long total_num_of_characters = 0;\n\
    \    for (size_t i = 0; i < small_letters.size(); i++) {\n        total_num_of_characters\
    \ += freq(small_letters[i]);\n    }\n\n    return total_num_of_characters;", " \
    \ int count=0, index=0;\n  for (int i=0; i<string.length(); i++){\n      if (string.at(i)\
    \ == string.at(i)){\n          count++;\n      }\n      else{\n          count\
    \ = 1;\n      }\n      string[index++] = string.at(i);\n  }\n  return count;",
  "    std::string lowerCaseString = std::string(string);\n    std::sort(lowerCaseString.begin(),\
    \ lowerCaseString.end());\n    long count = 0;\n    std::string lastChar = lowerCaseString[0];\n\
    \    for (auto c : lowerCaseString)\n        if (c != lastChar)\n            ++count;\n\
    \        lastChar = c;\n    return count;", "    long count = 0;\n    for (auto\
    \ c: string) {\n        count++;\n    }\n    return count;", "    long count =\
    \ 0;\n    for (char c : string) \n        if (std::tolower(c) == c) count++;\n\
    \    return count;", "    int distinctCharacters = 0;\n    for (size_t i = 0;\
    \ i < string.length(); ++i) {\n        char ch = string[i];\n        int currentDistinctCharacters\
    \ = 0;\n        while (i != string.length() - 1) {\n            ++i;\n       \
    \     currentDistinctCharacters++;\n            if (string[i] != string[i + 1])\
    \ {\n                break;\n            }\n        }\n        if (ch != string[i])\
    \ {\n            distinctCharacters++;\n        }\n        distinctCharacters\
    \ += currentDistinctCharacters;\n    }\n    return distinctCharacters;", "   \
    \ int n = string.length();\n    long ans = 0;\n    for (int i = 0; i < n; i++)\
    \ {\n        int cnt = 0;\n        for (int j = i; j < n; j++) {\n           \
    \ if (string[i] == string[j])\n                cnt++;\n        }\n        if (cnt)\n\
    \            ans++;\n    }\n    return ans;", "    long count = 0;\n    for (int\
    \ i = 0; i < string.size(); i++) {\n        int ch = string[i];\n        ch =\
    \ ch - 'a';\n        count = (count + ch) % 26;\n    }\n    return count;", " \
    \ // Your code goes here\n  long answer = 0;\n  for (int i = 0; i < string.size();\
    \ i++) {\n    long prev = answer;\n    answer = answer + i;\n    answer = answer\
    \ + ((prev - i) * (prev - i));\n  }\n  return answer;", "    // Step 1: Count\
    \ the number of occurrence of each character in the string\n    int count = 0;\n\
    \    for (int i = 0; i < string.length(); i++)\n        ++count[string[i]];\n\n\
    \    // Step 2: Find the sum of all occurrences of each character in the string\n\
    \    long long sum = 0;\n    for (char c : string)\n        sum += count[c];\n\
    \n    return sum;", "\tlong counter = 0;\n\tfor (auto c : string)\n\t\tcounter++;\
    \ // count the distinct character and add one to it\n\treturn counter;", "  int\
    \ n = 0;\n  for (int i = 0; i < string.length(); i++) {\n    char c = string[i];\n\
    \    if (i != 0) {\n      if (c != string[i - 1]) n++;\n    } else {\n      if\
    \ (c != string[0]) n++;\n    }\n  }\n  return n;", "    // Initialize a map to\
    \ store all the distinct characters.\n    std::unordered_map<char, std::size_t>\
    \ charMap;\n    for (auto itr = string.cbegin(); itr != string.cend(); ++itr)\
    \ {\n        charMap[*itr] = charMap.size();\n    }\n\n    // Iterate over the\
    \ map, and count distinct characters for each unique character.\n    long count\
    \ = 0;\n    for (auto itr = charMap.begin(); itr != charMap.end(); ++itr) {\n\
    \        count += itr->second;\n    }\n\n    return count;", "  int number_of_characters\
    \ = 0;\n  for (int i = 0; i < string.size(); i++) {\n    if (string[i] >= 'A'\
    \ && string[i] <= 'Z') {\n      number_of_characters++;\n    } else if (string[i]\
    \ >= 'a' && string[i] <= 'z') {\n      number_of_characters++;\n    }\n  }\n \
    \ return number_of_characters;", "\t// The first element of each character in\
    \ the string is the ASCII code point\n\tstd::map<char, int> counter;\n\tfor (char\
    \ c: string) {\n\t\tcounter[c]++;\n\t}\n\n\tlong ans = 0;\n\tfor (std::map<char,\
    \ int>::iterator it = counter.begin(); it != counter.end(); ++it)\n\t\tans +=\
    \ it->second;\n\treturn ans;", "    int n = string.size();\n    long ans = 0;\n\
    \    for (int i = 0; i < n; i++) {\n        char c = string[i];\n        if (i\
    \ > 0 && isupper(c)) continue;\n        if (i > 0 && islower(c)) continue;\n \
    \       ans ++;\n    }\n    return ans;", "    // Write your code here\n    long\
    \ size = 1;\n    for(char ch : string)\n    {\n        if(ch == 'A' || ch == 'B'\
    \ || ch == 'C' || ch == 'D' || ch == 'E' || ch == 'F' || ch == 'G' || ch == 'H'\
    \ || ch == 'I' || ch == 'J' || ch == 'K' || ch == 'L' || ch == 'M' || ch == 'N'\
    \ || ch == 'O' || ch == 'P' || ch == 'Q' || ch == 'R' || ch == 'S' || ch == 'T'\
    \ || ch == 'U' || ch == 'V' || ch == 'W' || ch == 'X' || ch == 'Y' || ch == 'Z')\n\
    \        {\n            size++;\n        }\n    }\n    return size;", "    //\
    \ O(n) solution O(n * n) worst case O(n^2)\n    int char_arr[26] = {0};\n    for\
    \ (int i = 0; i < string.length(); i++)\n        char_arr[static_cast<int>(string[i])\
    \ - 'a']++;\n\n    long ans = 0;\n    for (int i = 0; i < 26; i++)\n        if\
    \ (char_arr[i] != 0)\n            ans++;\n    return ans;", "  long n = 1;\n \
    \ string s(string);\n  for (size_t i = 0; i < s.length(); i++) {\n    s += s[i];\n\
    \  }\n  for (size_t i = 0; i < s.length(); i++) {\n    char c = s[i];\n    n =\
    \ n * 26 + c - 'a' + 1;\n  }\n  return n;", "    if (string.length() == 0) return\
    \ 0;\n    long ans = 0;\n    for (long i = 0; i < string.length(); ++i) {\n  \
    \      bool char_repeats = false;\n        for (long j = i; j < string.length();\
    \ ++j) {\n            if (string[i] == string[j]) char_repeats = true;\n     \
    \   }\n        if (char_repeats) continue;\n        ans += 1;\n    }\n    return\
    \ ans;", "    // Your code here\n    long count = 1;\n    for (auto c : string)\n\
    \        count += (c == string[0]) ? 1 : 0;\n    return count;", "    // initialize\
    \ a vector to hold the distinct characters\n    std::set<std::string::value_type>\
    \ chars;\n    // initialize a counter\n    long count = 0;\n    // iterate through\
    \ the string and put each character into a set\n    for (char c : string) {\n\
    \        if (chars.find(c) == chars.end()) {\n            // if character is not\
    \ in the set, add it\n            chars.insert(c);\n            // increment the\
    \ counter\n            ++count;\n        }\n    }\n    // return the result\n\
    \    return count;", "    int n = string.length();\n    long answer = 0;\n   \
    \ for (int i = 0; i < n; i++) {\n        answer += string[i] == 'x' ? 1 : 0;\n\
    \    }\n    return answer;", "  long cnt = 0;\n  for (int i = 0; i < string.size();\
    \ i++)\n    cnt += (string.at(i) == string.at(i).to_upper() ? 0 : 1);\n  return\
    \ cnt;", '    return std::count(string.begin(), string.end(), 0);', "    // Create\
    \ a set of all distinct characters\n    std::string all_distinct_characters(string);\n\
    \    std::sort(all_distinct_characters.begin(), all_distinct_characters.end());\n\
    \    long n = all_distinct_characters.size();\n\n    // Sort the characters in\
    \ all distinct characters\n    std::sort(all_distinct_characters.begin(), all_distinct_characters.end());\n\
    \n    // Set up the map to record the count of each distinct character\n    long\
    \ cnt = 0;\n    for (std::string c: string) {\n        // Iterate through every\
    \ character\n        for (long k = 0; k < n; k++) {\n            // If the character\
    \ is equal to the current character\n            if (all_distinct_characters[k]\
    \ == c) {\n                cnt++;\n                break;\n            }\n   \
    \     }\n    }\n\n    return cnt;", "    int res = 0;\n    for (auto c : string)\n\
    \        res = res + c;\n    return res;", "    long ans = 0;\n    for (auto i\
    \ : string) {\n        ans += !isalpha(i);\n    }\n    return ans;", "    long\
    \ long ans = 1;\n    for (char c: string) {\n        if (c == '\\0')\n       \
    \     break;\n        if (c == string[0]) {\n            ans *= 2;\n        }\
    \ else {\n            ans *= (unsigned long long)((int)c + 1);\n        }\n  \
    \  }\n    return ans;", "    assert(string.size() > 0);\n    int count = 0;\n\
    \    for (char c : string) {\n        if (c >= 'a' && c <= 'z') {\n          \
    \  count += 2; // since 'a' is 'a' and 'z' is 'z', so 2 distinct characters.\n\
    \        } else if (c >= 'A' && c <= 'Z') {\n            count += 2; // since\
    \ 'A' is 'A' and 'Z' is 'Z', so 2 distinct characters.\n        } else {\n   \
    \         count++;\n        }\n    }\n    return count;", "  long number_of_distinct_characters\
    \ = 0;\n  for(int i = 0; i != string.length(); ++i) {\n    number_of_distinct_characters\
    \ += (isupper(string[i])+islower(string[i]))/2;\n  }\n  return number_of_distinct_characters;",
  "  int count = 0;\n  for (int i = 0; i < string.length(); i++) {\n    string lowercase\
    \ = string[i].to_lower();\n    string uppercase = string[i].to_upper();\n    string\
    \ digit = string[i].to_digit();\n    string specialcharacter = string[i].to_special_character();\n\
    \n    if (lowercase != string[i]) {\n      count++;\n    }\n\n    if (uppercase\
    \ != string[i]) {\n      count++;\n    }\n\n    if (digit != string[i]) {\n  \
    \    count++;\n    }\n\n    if (specialcharacter != string[i]) {\n      count++;\n\
    \    }\n  }\n  return count;", "    long count = 0;\n    for(char &c: string)\
    \ {\n        long current_count = string.find_first_not_of(c) - string.find_first_of(c);\n\
    \        if(current_count > count)\n            count = current_count;\n    }\n\
    \    return count;", "  std::sort(string.begin(), string.end());\n  std::unordered_map<char,\
    \ int> freq;\n  for (int i = 0; i != string.size(); i++) {\n    char c = string[i];\n\
    \    if (freq.find(c) == freq.end()) {\n      freq[c] = 1;\n    } else {\n   \
    \   freq[c]++;\n    }\n  }\n  return freq.size();", "    long len = 0;\n    long\
    \ curr = 0;\n    long counter = 0;\n    for (long i = 0; i < string.length();\
    \ i++) {\n        if (string[i] >= 'a' && string[i] <= 'z') {\n            len++;\n\
    \        } else if (string[i] >= 'A' && string[i] <= 'Z') {\n            len++;\n\
    \        } else if (string[i] >= '0' && string[i] <= '9') {\n            len++;\n\
    \        }\n        if (string[i] != ' ') {\n            counter++;\n        \
    \    curr++;\n        } else {\n            if (len == 0) {\n                counter++;\n\
    \                curr++;\n            }\n            len = 0;\n        }\n   \
    \ }\n    return counter;", "  long ans = 0, i = 0;\n  while (i < string.size())\
    \ {\n    long count = 0;\n    for (; i < (string).size() && isalpha(string[i]);\
    \ ++i) ++count;\n    if (i == (string).size()) break;\n    ++i;\n    if (count\
    \ > ans) ans = count;\n  }\n  return ans;", "  // code here\n  \n  for (int i\
    \ = 0; i < string.size(); i++) {\n    int counter = 0;\n    for (int j = i; j\
    \ < string.size(); j++) {\n      if (string[i] == string[j])\n        counter++;\n\
    \    }\n    cout << counter << endl;\n  }\n", "    long ret = 0;\n    for (auto\
    \ c : string) {\n        char lower = tolower(c);\n        char upper = toupper(c);\n\
    \        ret += (lower == upper) ? 1 : 0;\n    }\n    return ret;", "    long\
    \ count{0};\n    for (char c : string) {\n        count = count + ((c >= 'A' &&\
    \ c <= 'Z') || (c >= 'a' && c <= 'z') ? 1 : 0);\n    }\n    return count;", " \
    \   // Write your code here\n    int length = string.length();\n    long answer\
    \ = 0;\n    for (int i = 0; i < length; i++) {\n        long count = 1;\n    \
    \    for (int j = i + 1; j < length; j++) {\n            if (string[i] == string[j])\
    \ {\n                count++;\n            }\n        }\n        answer += count;\n\
    \    }\n    return answer;", "    long count = 0; \n    \n    for(char c:string)\
    \ {\n        if(std::toupper(c) == c)\n            count++;\n    }\n    return\
    \ count;", "  // Complete this function\n  long count = 0;\n  for (int i = 0;\
    \ i < string.length(); ++i) {\n    // Complete this line\n    if (string.at(i)\
    \ == string.at(i)) {\n      ++count;\n    }\n  }\n  return count;", "    long\
    \ count = 0;\n    for (char c : string)\n        if (c == tolower(c))\n      \
    \      count++;\n        else if (c == toupper(c))\n            count++;\n   \
    \     else\n            count = 0;\n    return count;", "    long long ans = 0;\n\
    \    // convert every character in string to lowercase\n    std::transform(string.begin(),\
    \ string.end(), string.begin(), ::tolower);\n    // count each character in the\
    \ string and add it to the final result\n    for (auto &c : string) {\n      \
    \  ++ans;\n    }\n    return ans;", "    long count = 0;\n    int len = string.size();\n\
    \n    for (auto c: string) {\n        int i = toupper(c) - 'A';\n        assert(i\
    \ >= 0 && i < (int) 'A' && (int) 'A' < (int) 'Z');\n        count += 1;\n    }\n\
    \n    return count;", "  long result = 1;\n  for (char c : string) {\n    long\
    \ temp = 0;\n    for (int i = c; i >= 'a' && i <= 'z'; i++) temp += 2;\n    for\
    \ (int i = c; i >= 'A' && i <= 'Z'; i++) temp += 2;\n    for (int i = c; i >=\
    \ '0' && i <= '9'; i++) temp += 1;\n    result += temp;\n  }\n  return result;",
  "  int ans = 0;\n  for (int i = 0; i < string.length(); i++) {\n    ans += string[i]\
    \ >= 'a' && string[i] <= 'z' ? (string[i] - 'a' + 1) : 1;\n  }\n  return ans;",
  "    long count = 0;\n    for (char c: string) {\n        if (toupper(c) != c)\n\
    \            ++count;\n    }\n    return count;", "    long n = 0;\n    long long\
    \ i = 1;\n    string s;\n    s.assign(string);\n    for (char c : s) {\n     \
    \   while (i + c <= s.length()) {\n            i += c;\n            ++n;\n   \
    \     }\n    }\n    return n;", "    long result = 1;\n    int pos = 0;\n    while\
    \ (pos < string.size()) {\n        if (string[pos] == string[pos])\n         \
    \   ++result;\n        ++pos;\n    }\n    return result;", "    long count = 0;\n\
    \    string tolower(string);\n    for (auto &c: tolower) {\n        if (c == tolower(c))\
    \ {\n            count++;\n        }\n    }\n    return count;", "    // Use set\
    \ to keep track of unique characters in string and count their occurrences.\n\
    \    std::set<char> unique;\n    for (char c: string) unique.insert(c);\n    return\
    \ unique.size();", "  long characters = 0;\n  // Count the characters and assign\
    \ the character to the integer and increment the character\n  for (int i = 0;\
    \ i < string.size(); i++) {\n    if (string[i] >= 'a' && string[i] <= 'z') {\n\
    \      characters ++;\n      string[i] = string[i] - 32;\n    }\n  }\n  return\
    \ characters;", "    long ans = 0;\n    for (int i = 0; i < string.length(); i++)\
    \ {\n        int flag = 0;\n        for (int j = 0; j < string.length(); j++)\
    \ {\n            if (i == j)\n                continue;\n            else if (string[i]\
    \ == string[j]) {\n                flag = 1;\n                break;\n       \
    \     }\n        }\n        if (flag == 1) {\n            ans++;\n        }\n\
    \    }\n    return ans;", "  if (string.empty())\n    return 0L;\n  long count\
    \ = 0L;\n  for (char c: string)\n    count += std::tolower(c) == c ? 1L : 0L;\n\
    \  return count;", "    long count = 0;\n    for (char c: string) {\n        ++count;\n\
    \        // TODO: Add case-insensitivity logic here\n    }\n    return count;",
  "\tlong length = 0;\n\tstd::string character;\n\tfor (char character : string) {\n\
    \t\tif (character.size() > length)\n\t\t\tlength = character.size();\n\t}\n\t\
    std::sort(string.begin(), string.end(), [length](char a, char b) -> bool {\n\t\
    \treturn a == b || a.size() < b.size();\n\t});\n\tlong number_of_distinct_characters\
    \ = 0;\n\tfor (char character : string) {\n\t\tif (character != string[length\
    \ - 1]) {\n\t\t\tnumber_of_distinct_characters += 1;\n\t\t}\n\t}\n\treturn number_of_distinct_characters;",
  "    long count = 0;\n    int index = 0;\n    while (index < string.length()) {\n\
    \        if (string[index] == string[index + 1]) {\n            ++index;\n   \
    \         ++count;\n        } else {\n            count = 0;\n        }\n    \
    \    ++index;\n    }\n    return count;", "    long res = 0;\n    for (char c:\
    \ string) {\n        string lower_c = std::tolower(c);\n        string upper_c\
    \ =  std::toupper(c);\n        long count_distinct_chars = std::count(lower_c.begin(),\
    \ lower_c.end(), c) + std::count(upper_c.begin(), upper_c.end(), c);\n       \
    \ res += count_distinct_chars;\n    }\n    return res;", "  // Use unordered_map\
    \ to find out how many distinct characters (regardless of case) does it consist\
    \ of\n  std::unordered_map<char, int> count_chars;\n  for (char c : string)\n\
    \    count_chars[c]++;\n  long ans = 0;\n  for (int i = 0; i < 26; i++)\n    ans\
    \ += count_chars[static_cast<char>('A' + i)];\n  return ans;", "    // Use unordered_map\
    \ to record how many each character appears\n    unordered_map<char, long> unique_characters;\n\
    \    // Loop through string\n    for (char c: string) {\n        // Increment\
    \ count of character in hashmap\n        unique_characters[c] += 1;\n    }\n \
    \   // Return result\n    return unique_characters.size();", "    // Write your\
    \ code here\n    long count = 0;\n    for(int i = 0; i < string.size(); i++)\n\
    \        for(int j = 0; j < string.size(); j++)\n            if((string[i] ==\
    \ string[j]) && (i != j))\n                count++;\n    return count;", "  //\
    \ Write your code here\n  return 0;", "    long count = 0;\n    for (long i =\
    \ 0; i < (long) string.length(); i++) {\n        char current = string[i];\n \
    \       // if we already encountered this char, then the count of distinct characters\
    \ increases\n        // by 1. Otherwise - 0, because we've never encountered it\
    \ before\n        if (string[i - 1] == current)\n            count++;\n      \
    \  else\n            count = 0;\n    }\n    return count;", "    long count =\
    \ 0;\n    for(long i=0; i<string.length(); i++)\n    {\n        if (string[i]>='A'\
    \ && string[i]<='Z')\n            count++;\n        else if (string[i]>='a' &&\
    \ string[i]<='z')\n            count++;\n        else\n            count++;\n\
    \    }\n    return count;", "    long size = 0;\n    for (auto c : string) {\n\
    \        size += string::count(c, 'X') + string::count(c, 'z') + string::count(c,\
    \ 'Y');\n    }\n    return size;", "    long count = 0;\n    for (size_t i = 0;\
    \ i < string.size(); ++i) {\n        bool present = false;\n        for (size_t\
    \ j = 0; j < count; ++j) {\n            if (string[i] == string[j]) present =\
    \ true;\n        }\n        if (!present) count++;\n    }\n    return count;",
  "    long number_of_distinct_characters = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == string[i + 1])\n            number_of_distinct_characters++;\n\
    \    }\n    return number_of_distinct_characters;", "    std::sort(string.begin(),\
    \ string.end());\n    long ans = 0;\n    for (auto it=string.begin(); it != string.end();\
    \ ++it) {\n        ans += std::toupper(*it);\n        ans += std::tolower(*it);\n\
    \        ans += std::isalpha(*it);\n    }\n    return ans;", "    std::map<char,\
    \ long> unique;\n    for (char c : string)\n        unique[c]++;\n    for (auto\
    \ p : unique)\n        if (p.second > 1)\n            return p.second;\n    return\
    \ unique.size();", "  long uniqueChars = 0;\n  for (char c : string)\n    if (toupper(c)\
    \ != c)\n      uniqueChars++;\n\n  return uniqueChars;", "    long ans = 0;\n\
    \    for (char c : string) {\n        bool found = std::find(string.begin(), string.end(),\
    \ c) != string.end();\n        ans += found ? 1 : 0;\n    }\n    return ans;",
  "    long count = 0;\n    for (char c : string)\n        if (tolower(c) == tolower(c))\n\
    \            count += 1;\n    return count;", '    // Your code here', "    if\
    \ (string.length() == 0)\n        return 0;\n    if (string.length() == 1)\n \
    \       return 1;\n\n    long result = 0;\n\n    // for each char in string, check\
    \ whether it's same or not in the next character\n    for (int i = 0; i < string.length();\
    \ i++) {\n        // initialize a boolean array for storing if current char is\
    \ same as the next\n        bool same = true;\n\n        // check whether there\
    \ are any following chars\n        for (int j = i + 1; j < string.length(); j++)\
    \ {\n            // if the current char is same as the next char, mark the array\
    \ as false\n            bool same = !same;\n        }\n\n        // if all array\
    \ values are true, then this char will be distinct\n        if (same)\n      \
    \      result++;\n    }\n\n    return result;", "    long answer = 0;\n    string\
    \ temp = string;\n    for (int i = 0; i < temp.length(); i++) {\n        for (int\
    \ j = i + 1; j < temp.length(); j++) {\n            if (temp[i] == temp[j]) {\n\
    \                answer++;\n            }\n        }\n    }\n    return answer;",
  "    // Initialize count\n    long count = 0;\n    // Iterate over all characters\
    \ in the string\n    for (char &c : string) {\n        // If character is lowercase\n\
    \        if (islower(c)) {\n            // Increment count by 1\n            count++;\n\
    \        } else {\n            // If character is uppercase\n            if (isupper(c))\
    \ {\n                // Decrement count by 1\n                count--;\n     \
    \       }\n        }\n    }\n    return count;", "  int count = 1;\n  for (int\
    \ i = 0; i < string.length(); i++) {\n    char c = string[i];\n    for (int j\
    \ = i + 1; j <= string.length(); j++) {\n      if (string[i] == string[j]) count++;\n\
    \    }\n  }\n  return count;", "    int length = string.length();\n    int counter[26];\n\
    \n    for (int i = 0; i < length; i++) {\n        counter[static_cast<int>(string[i])]++;\n\
    \    }\n    int max_value = -1;\n    for (int i = 0; i < 26; i++) {\n        if\
    \ (counter[i] > max_value) {\n            max_value = counter[i];\n        }\n\
    \    }\n    return max_value;", "    assert(string.size() > 1);\n    long n =\
    \ 0;\n    for (auto c : string) n = std::count_if(string.begin(), string.end(),\
    \ [&c](int i){return i == c;});\n    return n;", "    if(string.length() == 0)\n\
    \        return 0;\n    unordered_set<char> char_hash;\n    unordered_set<char>::iterator\
    \ it;\n    it=char_hash.insert(string[0]).first;\n    long count=1;\n    for(;it!=char_hash.end();it++)\n\
    \        count++;\n    return count;", '    return count_distinct_characters(string,
    string::npos);', "    long result = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        char current = string[i];\n        int previous_index = i;\n\
    \        while (previous_index != 0) {\n            previous_index = string[previous_index-1];\n\
    \        }\n        if (current == string[i]) {\n            result++;\n     \
    \   } else {\n            previous_index = string[i-1];\n            while (previous_index\
    \ != 0) {\n                previous_index = string[previous_index-1];\n      \
    \      }\n            if (current != previous_index) {\n                result++;\n\
    \            }\n        }\n    }\n    return result;", '    return std::count_if(string.begin(),
    string.end(), [](char c) { return std::tolower(c) != c; });', "    long count\
    \ = 0;\n    for (int i = 0; i < string.length(); i++)\n        count += (string.at(i)\
    \ == string.at(string.size() - 1 - i)) ? 0 : 1;\n    return count;", "    std::unordered_map<char,\
    \ long> freq;\n\n    for (char ch : string) {\n        freq[ch]++;\n    }\n  \
    \  return freq.size();", "  long count = 0;\n  for (int i = 0; i < string.length();\
    \ i++) {\n    const char ch = string[i];\n    if (ch >= 'a' && ch <= 'z') {\n\
    \      count += 1;\n    } else if (ch >= 'A' && ch <= 'Z') {\n      count += 1;\n\
    \    } else if (ch >= '0' && ch <= '9') {\n      count += 1;\n    }\n  }\n  return\
    \ count;", "    long count = 0;\n    char c;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        c = string[i];\n        if (isupper(c)) {\n            count++;\n\
    \        }\n        if (islower(c)) {\n            count++;\n        }\n    }\n\
    \    return count;", "  long result = 0;\n  long size = string.length();\n  for\
    \ (long i = 0; i < size; i++) {\n    long current_char = string[i];\n    long\
    \ temp_result = 1;\n    for (long j = i; j < size; j++) {\n      if (string[j]\
    \ != current_char) {\n        temp_result++;\n      }\n    }\n    result += temp_result;\n\
    \  }\n  return result;", "  int count_distinct = 0;\n  for (int i = 0; i < string.length();\
    \ i++)\n    if (string[i] == string[i])\n      count_distinct++;\n  return count_distinct;",
  "    long num_characters = string.size();\n    long distinct_char_count = 0;\n \
    \   for (int i = 0; i < num_characters; i++) {\n        bool isdistinct_char =\
    \ false;\n        for (int j = i; j < num_characters; j++) {\n            if (string[i]\
    \ == string[j] && i != j) {\n                isdistinct_char = true;\n       \
    \     }\n        }\n        if (isdistinct_char) {\n            distinct_char_count++;\n\
    \        }\n    }\n    return distinct_char_count;", "  long count = 1;\n  for\
    \ (auto letter : string) {\n    ++count;\n    count += (letter >= 'A' && letter\
    \ <= 'Z') ? 26 : (letter >= 'a' && letter <= 'z') ? 26 : letter - 'a' + 1;\n \
    \ }\n  return count;", "    long count = 0;\n    for (auto ch : string) {\n  \
    \      switch (ch) {\n            case 'A': count++; break;\n            case\
    \ 'B': count++; break;\n            case 'C': count++; break;\n            case\
    \ 'D': count++; break;\n            case 'E': count++; break;\n            case\
    \ 'F': count++; break;\n            case 'G': count++; break;\n            case\
    \ 'H': count++; break;\n            case 'I': count++; break;\n            case\
    \ 'J': count++; break;\n            case 'K': count++; break;\n            case\
    \ 'L': count++; break;\n            case 'M': count++; break;\n            case\
    \ 'N': count++; break;\n            case 'O': count++; break;\n            case\
    \ 'P': count++; break;\n            case 'Q': count++; break;\n            case\
    \ 'R': count++; break;\n            case 'S': count++; break;\n            case\
    \ 'T': count++; break;\n            case 'U': count++; break;\n            case\
    \ 'V': count++; break;\n            case 'W': count++; break;\n            case\
    \ 'X': count++; break;\n            case 'Y': count++; break;\n            case\
    \ 'Z': count++; break;\n            case 'a': case 'b': count++; break;\n    \
    \        case 'c': case 'd': count++; break;\n            case 'e': case 'f':\
    \ count++; break;\n            case 'g': case 'h': count++; break;\n         \
    \   case 'i': case 'j': count++; break;\n            case 'k': case 'l': count++;\
    \ break;\n            case 'm': case 'n': count++; break;\n            case 'o':\
    \ case 'p': count++; break;\n            case 'q': case 'r': count++; break;\n\
    \            case 's': case 't': count++; break;\n            case 'u': case 'v':\
    \ count++; break;\n            case 'w': case 'x': count++; break;\n         \
    \   case 'y': case 'z': count++; break;\n            default: count++;\n     \
    \   }\n    }\n    return count;", '    return count_distinct_characters(string.begin(),
    string.end());', "    long count = 0;\n    for (char ch : string) {\n        if\
    \ (islower(ch)) count++;\n        else if (isupper(ch)) count++;\n        else\
    \ count++;\n    }\n    return count;", "    long lenght = string.size();\n   \
    \ long res = 0;\n    for (int i = 0; i < lenght; i++) {\n        std::unordered_set<char>\
    \ uset;\n        uset.insert(string[i]);\n        if (uset.count(string[i]) >\
    \ 0)\n            res += 1;\n    }\n    return res;", "  int counter = 0;\n  for\
    \ (auto c : string) {\n    counter = (counter + 32) ^ tolower(c);\n  }\n  return\
    \ counter;", "    long counter = 0;\n    for (char &i : string)\n        if (std::tolower(i)\
    \ != i)\n            counter++;\n    return counter;", "  long count = 0;\n  for\
    \ (int i = 0; i < string.length(); i++) {\n    if (string[i] >= 'a' && string[i]\
    \ <= 'z') {\n      count++;\n    } else if (string[i] >= 'A' && string[i] <= 'Z')\
    \ {\n      count++;\n    }\n  }\n  return count;", "  int distinct_characters\
    \ = 0;\n  for (int i = 0; i < string.size(); ++i) {\n    distinct_characters +=\
    \ (int)string[i] - (int)string[i] + 32;\n  }\n  return distinct_characters;",
  "    long n = 1;\n    for (auto c : string) n += ((c >= 'A') ? ((c >= 'Z') ? ((c\
    \ >= 'a') ? (((c >= 'm') ? ((c >= 'p') ? (((c >= 'R') ? ((c >= 'Y') ? ((c >= 'u')\
    \ ? ((c >= 'E') ? (n += 6) : (n += 4)) : (n += 2)) : (n += 3)) : (n += 2)) : (n\
    \ += 3)) : (n += 2)) : (n += 2)) : (n += 2)) : (n += 2)) : (n + 1));\n    return\
    \ n;", "  assert(string);\n  long count = 1;\n  for (auto &c : string) {\n   \
    \ count = (count + 1) * (c + 1);\n  }\n  return count;", "    return count(string.begin(),\
    \ string.end(), [](char c){return c > 'Z'; });", "    long count = 0;\n    long\
    \ index = 0;\n    long size = string.length();\n    while(index < size) {\n  \
    \      long value = string[index];\n        index++;\n        count += 1;\n  \
    \      while (index < size && string[index] == value)\n            index++;\n\
    \    }\n    return count;", "  int n = string.size();\n  int sum = 0;\n\n  for\
    \ (int i = 0; i < n; i++) {\n    int charcode = string[i];\n    sum += charcode\
    \ - 'A' + 1;\n  }\n\n  return sum;", "    long count = 0;\n    for (int i = 0;\
    \ i < string.size(); ++i) {\n        if (string[i] != string[i].tolower() && string[i]\
    \ != string[i].toupper()) {\n            count++;\n        }\n    }\n    return\
    \ count;", "    long count = 1;\n    for (int i = 0; i < string.length(); ++i)\
    \ {\n        for (int j = i; j < string.length(); ++j) {\n            if (string[i]\
    \ == string[j])\n                ++count;\n        }\n    }\n    return count;",
  "    long distinct_chars = 1;\n    for(auto it = string.cbegin(); it != string.cend();\
    \ ++it) {\n        distinct_chars *= (std::toupper(*it) == *it)? 2: 1;\n    }\n\
    \    return distinct_chars;", "    long count{0};\n    for (char c : string)\n\
    \        if (std::tolower(c) != c) count++;\n    return count;", "  if (string.length()\
    \ <= 1) return 1;\n  // Keep track of how many distinct characters we encounter\n\
    \  long unique_chars_so_far = 0;\n  // Go through the string from left to right\n\
    \  for (int i = 0; i < string.length(); ++i) {\n    // If we've already encountered\
    \ a character that matches, add one to the unique chars so far\n    if (string.at(i)\
    \ == string.at(i - 1)) unique_chars_so_far++;\n    // If we haven't encountered\
    \ a character that matches, add one to the unique chars so far\n    else unique_chars_so_far\
    \ = 1;\n  }\n  return unique_chars_so_far;", "    // Find out the number of unique\
    \ characters in the string\n    long ans = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        int flag = 0;\n        for (int j = 0; j < string.length();\
    \ j++) {\n            if (string[i] == string[j])\n                flag = 1;\n\
    \        }\n        if (flag == 1)\n            ans++;\n    }\n    return ans;",
  "    long n = 0;\n    for (auto c : string)\n        if ((c >= 'a' && c <= 'z')\
    \ || (c >= 'A' && c <= 'Z'))\n            ++n;\n    return n;", "    long count\
    \ = 0; // initialize count\n    long temp = 0; // initialize temp\n    // Iterate\
    \ through string, adding count to temp if characters are distinct\n    for (char\
    \ &str : string) {\n        temp = temp + ((str >= 'A' && str <= 'Z') || (str\
    \ >= 'a' && str <= 'z')); // add character to temp\n    }\n    // increment count\
    \ by temp value\n    count = temp;\n    // return count\n    return count;", " \
    \   long count = 0;\n    for (char &c: string) {\n        if (std::tolower(c)\
    \ == c) ++count;\n    }\n    return count;", "    long answer = 0;\n    for (char\
    \ &letter : string) {\n        answer += tolower(letter) - 'a' + 1;\n    }\n \
    \   return answer;", "  if (string.length() == 0) return 0;\n  std::unordered_set<char>\
    \ uniqueChars;\n  for (char c : string) {\n    uniqueChars.insert(c);\n  }\n \
    \ return uniqueChars.size();", "    long count = 0;\n    for (auto c : string)\n\
    \        if (std::toupper(c) < 'A')\n            ++count;\n    return count;",
  "    if (string.empty()) {\n        return 0;\n    }\n    long result = 0;\n   \
    \ std::unordered_set<char> char_set;\n    for (char c : string) {\n        if\
    \ (c == 'A' || c == 'a') {\n            result++;\n        } else if (c >= 'B'\
    \ && c <= 'Z') {\n            result += (26 - 26 + c - 'B');\n        } else if\
    \ (c >= 'a' && c <= 'z') {\n            result += (26 - 26 + c - 'a');\n     \
    \   }\n        char_set.insert(c);\n    }\n    for (char c : string) {\n     \
    \   if (char_set.find(c) != char_set.end()) {\n            result++;\n       \
    \ }\n    }\n    return result;", "  long ans = 0;\n  for (int i = 0; i < string.length();\
    \ ++i) {\n    if (string[i] == string[0]) {\n      ans = ans + 1;\n    } else\
    \ {\n      ans = ans + (string[i] >= 'a' ? 26 : string[i] >= 'A' ? 26 : string[i]\
    \ >= '0' ? 10 : 0);\n    }\n  }\n  return ans;", "  if (string.empty())\n    return\
    \ 0;\n  // Keep track of how many times each character appears\n  std::unordered_map<char,\
    \ long> char_count_map;\n  for (int i = 0; i < (int)string.size(); i++) {\n  \
    \  auto it = char_count_map.find(string[i]);\n    if (it == char_count_map.end())\
    \ {\n      char_count_map.insert({string[i], 1});\n    } else {\n      it->second++;\n\
    \    }\n  }\n  // Now, for each character in our string, add up the number of\
    \ times it appears.\n  long count = 0, current_char_count;\n  for (auto it = char_count_map.begin();\
    \ it != char_count_map.end(); ++it) {\n    current_char_count = it->second;\n\
    \    count += current_char_count;\n  }\n  return count;", "    long n = 0;\n \
    \   for (char c : string)\n        if (std::tolower(c) == c)\n            n++;\n\
    \    return n;", "    // Your code here\n    long count = 0;\n    long size =\
    \ string.size();\n    vector<long> vstring;\n    string temp;\n    vstring.reserve(size);\n\
    \    for (int i = 0; i < size; i++) {\n        vstring.push_back(string.at(i));\n\
    \    }\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j <\
    \ size; j++) {\n            if (vstring[i] == vstring[j]) {\n                temp.push_back(vstring[i]);\n\
    \            }\n        }\n    }\n    for (int i = 0; i < temp.size(); i++) {\n\
    \        count += (temp[i] == vstring[0]);\n    }\n    return count;", "    std::sort(string.begin(),\
    \ string.end());\n    long counter = 0;\n    for (int i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == string[i + 1]) counter++;\n    }\n    return\
    \ counter;", "    if (string == \"\") {\n        return 0;\n    }\n    std::unordered_map<char,\
    \ int> characters;\n    for (auto character : string) {\n        auto it = characters.find(character);\n\
    \        if (it == characters.end()) {\n            characters[character] = 1;\n\
    \        } else {\n            it->second++;\n        }\n    }\n    return characters.size();",
  "    long answer = 0;\n    string lower_case = string;\n    string upper_case =\
    \ \"\";\n    string mixed_case = \"\";\n\n    std::transform(string.begin(), string.end(),\
    \ lower_case.begin(), ::tolower);\n    std::transform(lower_case.begin(), lower_case.end(),\
    \ upper_case.begin(), ::toupper);\n    std::transform(upper_case.begin(), upper_case.end(),\
    \ mixed_case.begin(), ::tolower);\n    \n    for(int i = 0; i < string.length();\
    \ i++){\n        answer += string[i] == 'x' ? 2 : 1;\n        answer += string[i]\
    \ == 'y' ? 2 : 1;\n        answer += string[i] == 'z' ? 2 : 1;\n    }\n\n    std::transform(mixed_case.begin(),\
    \ mixed_case.end(), mixed_case.begin(), ::toupper);\n    for(int i = 0; i < string.length();\
    \ i++){\n        answer += string[i] == 'x' ? 2 : 0;\n        answer += string[i]\
    \ == 'y' ? 2 : 0;\n        answer += string[i] == 'z' ? 2 : 0;\n    }\n    return\
    \ answer;", "    if (string.length() == 0) return 0;\n    long result = 0;\n \
    \   // Loop through each character\n    for (char c : string) {\n        // If\
    \ the character is a letter, add it to the count\n        if (std::isalpha(c))\
    \ {\n            result++;\n        }\n    }\n    // Return the result\n    return\
    \ result;", "  long count = 0;\n  for (auto &character : string) {\n    if (std::tolower(character)\
    \ == character) ++count;\n  }\n  return count;", "  long count=0, i= 0, flag =\
    \ 0;\n  while (string[i] != '\\0') {\n    if(string[i] != tolower(string[i]) &&\
    \ string[i] != toupper(string[i])) flag = 1;\n    else count++;\n    i++;\n  }\n\
    \  return count;", "    int count = 0;\n    for (char i : string) {\n        std::toupper(i);\n\
    \        ++count;\n    }\n    return count;", "  std::unordered_map<char, int>\
    \ charCount;\n  for (auto &character : string) {\n    if (!charCount.count(character))\
    \ {\n      charCount[character] = 1;\n    } else {\n      charCount[character]\
    \ += 1;\n    }\n  }\n  long count = 0;\n  for (auto &character : charCount) {\n\
    \    count += character.second;\n  }\n  return count;", "    long distinct_chars\
    \ = 0;\n    for (char ch : string)\n        if (std::tolower(ch) != ch)\n    \
    \        distinct_chars++;\n    return distinct_chars;", "    std::map<char, long>\
    \ char_to_index;\n    for (char c : string) {\n        if (char_to_index.find(c)\
    \ == char_to_index.end()) {\n            char_to_index[c] = string.size();\n \
    \       } else {\n            char_to_index[c] += 1;\n        }\n    }\n    long\
    \ count = 0;\n    for (auto it: char_to_index) {\n        count += it.second;\n\
    \    }\n    return count;", "  long answer = 0;\n  long last_char = 0;\n  for\
    \ (int i = 0; i < string.length(); i++) {\n    long current = string[i];\n   \
    \ last_char = current;\n    answer++;\n    if (current != last_char) {\n     \
    \ answer = answer - 1;\n      break;\n    }\n  }\n  return answer;", "    long\
    \ distinctCharacters = 0;\n    long pos = 0;\n    while (string[pos] != '\\0')\
    \ {\n        if (string[pos] >= 'a' && string[pos] <= 'z') {\n            distinctCharacters++;\n\
    \        }\n        if (string[pos] >= 'A' && string[pos] <= 'Z') {\n        \
    \    distinctCharacters++;\n        }\n        if (string[pos] >= '0' && string[pos]\
    \ <= '9') {\n            distinctCharacters++;\n        }\n        pos++;\n  \
    \  }\n    return distinctCharacters;", "    long count = 0;\n    for (char ch\
    \ : string)\n        if (std::tolower(ch) != ch)\n            count++;\n    return\
    \ count;", "    // Your code goes here\n    long long ans=0;\n    for (char c:\
    \ string){\n        ans = ans+1;\n    }\n    return ans;", "\t// TODO:\n\t// We\
    \ can do this in two ways:\n\t// 1. We can use a map to keep track of how many\
    \ times each character occurs, and then compute the answer\n\t// 2. We can use\
    \ a hashtable to keep track of how many times a given character occurs\n\t// In\
    \ either case, we can use unordered_map since unordered_map has constant time\
    \ complexity.\n\t// 1. Using unordered_map\n\t// unordered_map<char, long> char_count_map;\n\
    \tstd::unordered_map<char, long> char_count_map;\n\n\tfor (auto c: string) {\n\
    \t\tchar_count_map[c]++;\n\t}\n\n\treturn char_count_map.size();", "    std::map<char,\
    \ int> charCount;\n    for (char c : string)\n        if (charCount.find(c) ==\
    \ charCount.end())\n            charCount[c] = 1;\n        else\n            charCount[c]\
    \ = charCount[c] + 1;\n    int count = 1;\n    for (auto it = charCount.begin();\
    \ it != charCount.end(); ++it)\n        count *= (1 << (*it).second);\n    return\
    \ count;", "    if (string.empty())\n        return 0;\n    long result = 0;\n\
    \    for (char &c : string) {\n        c = toupper(c);\n        ++result;\n  \
    \  }\n    return result;", "  long ans = 0;\n  for (auto i : string)\n    ans\
    \ += i != '\\0' ? 1 : 0;\n  return ans;", "    // TODO: Add more optimizations\
    \ if needed\n    long result = 0;\n    long size = string.length();\n    for (int\
    \ i = 0; i < size; i++) {\n        long count = 0;\n        for (int j = 0; j\
    \ < size; j++) {\n            if (string[i] == string[j]) count++;\n        }\n\
    \        if (count > result) result = count;\n    }\n    return result;", "  std::unordered_map<char,\
    \ long> counter;\n  for (char c : string) {\n    counter[c]++;\n  }\n  return\
    \ counter.size();", "    long count = 0;\n    for (auto c : string) {\n      \
    \  if (std::tolower(c) == std::tolower(c)) {\n            ++count;\n        }\n\
    \    }\n    return count;", "  if (string.size() == 0) {\n    return 0;\n  }\n\
    \  // Create a unordered_map to record the count of each character\n  unordered_map<char,\
    \ int> char_count_map;\n  for (int i = 0; i < string.size(); ++i) {\n    // If\
    \ the key does not exist in the map, add it to the map and set its count to 1\n\
    \    char_count_map[string[i]]++;\n  }\n  // Return the count of distinct characters\n\
    \  return char_count_map.size();", "    int n = string.length();\n    long count\
    \ = 0;\n    unordered_set<char> unique_chars;\n    for (int i = 0; i < n; i++)\
    \ {\n        if (unique_chars.find(string[i]) != unique_chars.end()) {\n     \
    \       count++;\n        } else {\n            unique_chars.insert(string[i]);\n\
    \        }\n    }\n    return count;", "   long count = 1;\n   for (char c : string)\n\
    \   {\n      assert(c != '\\0');\n      count += (tolower(c) != c);\n   }\n  \
    \ return count;", "    int count_distinct_chars = 0;\n    for (char c : string)\
    \ {\n        if (c == toupper(c))\n            count_distinct_chars++;\n     \
    \   else\n            count_distinct_chars++;\n    }\n    return count_distinct_chars;",
  "  long count = 0;\n  for (int i = 0; i < string.length(); i++) {\n    long count\
    \ = count + string[i] >= 'A' ? string[i] >= 'a' ? string[i] - 'A' + 1 : string[i]\
    \ - 'a' + 1 : 1;\n  }\n  return count;", "  // Initializing count\n  int count\
    \ = 0, len = string.length();\n  while (len > 0) {\n    if (string.at(0) == string.at(len\
    \ - 1)) {\n      count += 1;\n      len -= 1;\n    }\n    else {\n      count\
    \ += 2;\n      len -= 2;\n    }\n  }\n  return count;", "  // Initialize count\
    \ to 0\n  long count = 0;\n  // Iterate through string\n  for (char ch : string)\
    \ {\n    // For each character, get ASCII value of that character, and increment\
    \ count if different\n    // This could be done in one line using '+=', but I\
    \ want to make it clear.\n    count += (ch - 'a') + 1;\n  }\n  // Return count\n\
    \  return count;", "    long len = 0;\n    for (char c : string) {\n        switch\
    \ (c) {\n            case 'a':\n            case 'b':\n            case 'c':\n\
    \            case 'd':\n            case 'e':\n            case 'f':\n       \
    \     case 'g':\n            case 'h':\n            case 'i':\n            case\
    \ 'j':\n            case 'k':\n            case 'l':\n            case 'm':\n\
    \            case 'n':\n            case 'o':\n            case 'p':\n       \
    \     case 'q':\n            case 'r':\n            case 's':\n            case\
    \ 't':\n            case 'u':\n            case 'v':\n            case 'w':\n\
    \            case 'x':\n            case 'y':\n            case 'z':\n       \
    \         len++;\n                break;\n            case 'A':\n            case\
    \ 'B':\n            case 'C':\n            case 'D':\n            case 'E':\n\
    \            case 'F':\n            case 'G':\n            case 'H':\n       \
    \     case 'I':\n            case 'J':\n            case 'K':\n            case\
    \ 'L':\n            case 'M':\n            case 'N':\n            case 'O':\n\
    \            case 'P':\n            case 'Q':\n            case 'R':\n       \
    \     case 'S':\n            case 'T':\n            case 'U':\n            case\
    \ 'V':\n            case 'W':\n            case 'X':\n            case 'Y':\n\
    \            case 'Z':\n                len++;\n                break;\n     \
    \       default:\n                break;\n        }\n    }\n    return len;",
  "    int n = 0, sum = 0;\n    for (char c : string) {\n        if (tolower(c) ==\
    \ c) {\n            sum++;\n        }\n        n++;\n    }\n    return sum;",
  "\tlong answer = 0;\n\tfor (char &i: string) {\n\t\tassert ((i >= 'A') && (i <=\
    \ 'Z'));\n\t\tanswer += tolower(i) - 'a' + 1;\n\t}\n\tanswer = (answer * 26) /\
    \ 27 + 1;\n\treturn answer;", "    assert(string.size() > 0);\n    long n = 1;\n\
    \    for (int i = 0; i < string.size(); i++) {\n        char c = string[i];\n\
    \        for (int j = i + 1; j <= string.size(); j++) {\n            char d =\
    \ string[j];\n            if (c == d) n++;\n        }\n    }\n    return n;",
  "    long long result = 0;\n    for (long i = 0; i < string.length(); i++) {\n \
    \       result += string.at(i) - 'A' + 1;\n    }\n    return result;", "    long\
    \ count = 0;\n    long len = string.length();\n    for (int i = 0; i < len; i++)\
    \ {\n        long current = 1;\n        char current = string[i];\n        for\
    \ (int j = i + 1; j < len; j++) {\n            char next = string[j];\n      \
    \      if (current != next) {\n                break;\n            }\n       \
    \     current++;\n        }\n        count += current;\n    }\n    return count;",
  "    long count = 0;\n    unordered_set<char> haystack;\n    for(char c : string)\n\
    \        haystack.insert(c);\n    for(char c : haystack)\n        count++;\n \
    \   return count;", "    long num_of_distinct_chars = 1;\n    for (int i = 0;\
    \ i < string.size(); ++i) {\n        char ch = string[i];\n        for (int j\
    \ = i+1; j < string.size(); ++j) {\n            if (string[i] != string[j]) {\n\
    \                num_of_distinct_chars++;\n                break;\n          \
    \  }\n        }\n    }\n    return num_of_distinct_chars;", "    std::unordered_set<char>\
    \ s;\n    for (char &it : string) {\n        s.insert(it);\n    }\n    return\
    \ s.size();", "    std::set<char> charSet;\n    for (auto& character : string)\n\
    \        charSet.insert(character);\n    return static_cast<long>(charSet.size());\
    \ // Set size would return number of unique characters in the given string", "\t\
    long count = 0; // to keep track of how many unique characters does string consist\
    \ of\n\tfor (char c : string) { \n\t\tif (std::toupper(c) == c) { // this will\
    \ be true only if string contains only uppercase\n\t\t\t++count; // increment\
    \ the count\n\t\t}\n\t}\n\treturn count;", "  std::unordered_map<char, int> char_map;\n\
    \  for (auto i : string) {\n    if (char_map.count(i) == 0)\n      char_map[i]\
    \ = 1;\n    else\n      char_map[i] += 1;\n  }\n  // There could be more than\
    \ one character in the string\n  // >>> count_distinct_characters((\"Abc\"))\n\
    \  // Traceback (most recent call last):\n  //   File \"<stdin>\", line 1, in\
    \ <module>\n  //   File \"<stdin>\", line 2, in count_distinct_characters\n  //\
    \   File \"/usr/include/c++/8/bits/unordered_map.h\", line 93, in count\n  //\
    \   __x.count(__k))\n  // TypeError: unhashable type: 'std::__cxx11::string'\n\
    \  return char_map.size();", "    long count = 0;\n    for (long i = 1; i < string.length();\
    \ i++) {\n        if (string[i - 1] == string[i]) {\n            count++;\n  \
    \      }\n    }\n    return count;", "    long count = 0;\n    for (auto const\
    \ &c : string)\n        if (c == '\\0' || c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u')\n            count++;\n    return count;", "    long count\
    \ = 0;\n    for (char &i : string) {\n        if (i != ' ')\n            count++;\n\
    \    }\n    return count;", "    // Write your code here\n    long result = 0;\n\
    \    for (int i = 0; i < string.size(); i++)\n        result += tolower(string[i])\
    \ - 'a';\n    return result;", "    long ans = 0;\n    for (char i : string) {\n\
    \        if (i == tolower(i)) {\n            ans += 1;\n        }\n        if\
    \ (i == toupper(i)) {\n            ans += 1;\n        }\n    }\n    return ans;",
  "  // A character is defined as \"[any character] except for spaces, letters and\
    \ digits\".\n  // (1)\n  long count = 0;\n  for (char c : string)\n    if (std::toupper(c)\
    \ != std::toupper(c))\n      if (std::isdigit(c))\n        count += 1;\n     \
    \ else\n        count += 2;\n    else\n      count += 3;\n  return count;", " \
    \   long ans = 0;\n    for (char c : string) {\n        long count = 0;\n    \
    \    for (char d : string) {\n            if (c == d)\n                ++count;\n\
    \        }\n        ans += count;\n    }\n    return ans;", "    long result =\
    \ 0;\n    long index = 0;\n    for (long i = 0; i < string.length(); ++i) {\n\
    \        long j = string.at(i);\n        if (!(index ^ j)) {\n            ++result;\n\
    \        }\n        index ^= j;\n    }\n    return result;", "    int counter\
    \ = 0;\n    std::string temp_string = string;\n    std::string temp_char;\n\n\
    \    while (temp_string.size() > 0) {\n        temp_char = temp_string.substr(0,\
    \ 1);\n        counter++;\n        temp_string = temp_string.substr(1, temp_string.size());\n\
    \    }\n    return counter;", "    long count = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        bool isUpper = true;\n        bool isLower = true;\n       \
    \ for (int j = 0; j < i; j++) {\n            if (isUpper && isLower)\n       \
    \         break;\n            if (string[i] == string[j]) {\n                isUpper\
    \ = false;\n                isLower = true;\n            } else {\n          \
    \      isLower = false;\n            }\n        }\n        if (isUpper && isLower)\n\
    \            break;\n        count++;\n    }\n    return count;", "    std::unordered_set<char>\
    \ chars;\n    for(char &c:string) {\n        chars.insert(c);\n    }\n    return\
    \ chars.size();", "    unordered_map<char, int> char_counter;\n    unordered_map<int,\
    \ char> int_to_char;\n    for(auto c : string) {\n        char_counter[c]++;\n\
    \        if(int_to_char.find(char_counter[c]) == int_to_char.end()) {\n      \
    \      int_to_char[char_counter[c]] = c;\n        }\n    }\n    return int_to_char.size();",
  "    // your code here\n    string upper = string;\n    transform(upper.begin(),\
    \ upper.end(), upper.begin(), ::toupper);\n    sort(upper.begin(), upper.end());\n\
    \    long count = 0, i = 0;\n    while(i < upper.size()) {\n        while(i <\
    \ upper.size() && upper[i] == upper[(i + 1) % upper.size()])\n            i++;\n\
    \        count++;\n        i = (i + 1) % upper.size();\n    }\n    return count;",
  "    std::sort(string.begin(), string.end(), [&string](int a, int b) {\n       \
    \ return a < b;\n    });\n    long count = 0;\n    while (!string.empty()) {\n\
    \        ++count;\n        string = std::remove(string.begin(), string.end(),\
    \ string[0]);\n    }\n    return count;", "    std::unordered_map<char, int> m;\n\
    \    std::unordered_map<char, int>::iterator itr;\n    for (auto it = string.begin();\
    \ it != string.end(); it++) {\n        auto insert = m.insert(std::pair<char,\
    \ int>(toupper(*it), m.size()));\n        auto itr = insert.first;\n        it->insert(itr.second\
    \ + 1);\n    }\n    return m.size();", "    // Initialize a map with an empty\
    \ string\n    std::map<char, std::string> char_count_map;\n\n    // Iterate over\
    \ all characters in the string\n    for (char c : string) {\n        // If not\
    \ in the map, add it with the count of one (counting the new character as a new\
    \ character)\n        if (char_count_map.find(c) == char_count_map.end()) {\n\
    \            char_count_map[c] = 1;\n        }\n        // Else add 1 to the existing\
    \ count of the character\n        else {\n            char_count_map[c] += 1;\n\
    \        }\n    }\n\n    // Return the total count of distinct characters in the\
    \ given string\n    return char_count_map.size();", "    long ans = 0;\n    for\
    \ (int i = 0; i < string.length(); i++) {\n        int count = 0;\n        for\
    \ (int j = 0; j < string.length(); j++) {\n            if (string.at(i) == string.at(j))\
    \ count++;\n        }\n        if (count == string.length()) ans++;\n    }\n \
    \   return ans;", "    if (string.empty())\n        return 0;\n    int count_unique\
    \ = string[string.size()-1];\n    for (int i = 0; i < string.size()-1; ++i) {\n\
    \        if (string[i] != string[i+1])\n            ++count_unique;\n    }\n \
    \   return count_unique;", "    long count = 1;\n    for(int i=0; i<string.length();\
    \ i++){\n        if(string.at(i) == string.at(i+1)){\n            count++;\n \
    \       }\n    }\n    return count;", "  long answer = 0;\n  for (char &c : string)\
    \ {\n    char upper = std::toupper(c);\n    char lower = std::tolower(c);\n  \
    \  long diff = upper - lower;\n    answer += diff;\n  }\n  return answer;", " \
    \   long count = 0;\n    for(char c: string) {\n        if(count++ == 0) break;\n\
    \        count += islower(c) + isupper(c);\n    }\n    return count;", "    long\
    \ long ans = 0;\n    string str = string;\n    for (size_t i = 0; i < str.size();\
    \ ++i) {\n        if (std::tolower(str[i]) != str[i]) {\n            ++ans;\n\
    \        }\n    }\n    return ans;", "  if (string.empty()) {\n    return 0;\n\
    \  }\n  int size = string.size();\n  std::vector<int> frequency(size);\n  for\
    \ (int i = 0; i < size; i++) {\n    frequency[string[i]]++;\n  }\n  long answer\
    \ = 0;\n  for (int i = 1; i < size; i++) {\n    answer += frequency[i];\n  }\n\
    \  return answer;", "    long count = 0;\n    for (size_t i = 0; i < string.size();\
    \ i++)\n        count += static_cast<long>(tolower(string[i]));\n    return count;",
  "  // Declare variable\n  long distinctCharacters = 0;\n  // Iterate over each character\
    \ in the string\n  for (char c : string) {\n    // Check if the character is already\
    \ in the string\n    if (string.find(c) == std::string::npos) {\n      // If the\
    \ character is not present, then increment the counter\n      distinctCharacters++;\n\
    \    }\n  }\n  // Return the number of distinct characters\n  return distinctCharacters;",
  "\tlong ans = 0;\n\tfor (auto c : string) {\n\t\tassert(std::toupper(c) == c);\n\
    \t\tif (std::toupper(c) != c) {\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;", " \
    \ int count = 0;\n  for (int i = 0; i < string.size(); i++) {\n    count += string[i]\
    \ == 'X' ^ string[i] == 'y' ^ string[i] == 'Z' ^ string[i] == 'Y';\n  }\n  return\
    \ count;", "    // your code goes here\n    // Solution: \n    long ans = 0;\n\
    \    int c = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string[i]\
    \ >= 65 && string[i] <= 90) {\n            c += 1;\n        } else if (string[i]\
    \ >= 97 && string[i] <= 122) {\n            c += 2;\n        }\n    }\n    ans\
    \ = c;\n    return ans;", "  long distinct_chars = 0;\n  for (int i = 0; i < string.length();\
    \ ++i) {\n    char c = string[i];\n    bool found_new_char = false;\n    for (int\
    \ j = i; j < string.length(); ++j) {\n      char c2 = string[j];\n      if (c\
    \ == c2 && c != ' ') {\n        ++distinct_chars;\n        found_new_char = true;\n\
    \        break;\n      }\n    }\n    if (!found_new_char) distinct_chars++;\n\
    \  }\n  return distinct_chars;", "  long result = 0;\n  for (int i = 0; i < string.size();\
    \ i++) {\n    int count = 0;\n    for (int j = 0; j < string.size(); j++) {\n\
    \      if (string[i] == string[j]) {\n        count++;\n      }\n    }\n    if\
    \ (count > result) {\n      result = count;\n    }\n  }\n  return result;"]
stop_tokens:
- "\n}"
