name: HumanEval_65_circular_shift
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Circular shift the digits\
  \ of the integer x, shift the digits right by shift\n// and return the result as\
  \ a string.\n// If shift > number of digits, return digits reversed.\n// >>> circular_shift((12),\
  \ (1))\n// (\"21\")\n// >>> circular_shift((12), (2))\n// (\"12\")\nstd::string\
  \ circular_shift(long x, long shift) {\n"
tests: "}\nint main() {\n    auto candidate = circular_shift;\n    assert(candidate((100),\
  \ (2)) == (\"001\"));\n    assert(candidate((12), (2)) == (\"12\"));\n    assert(candidate((97),\
  \ (8)) == (\"79\"));\n    assert(candidate((12), (1)) == (\"21\"));\n    assert(candidate((11),\
  \ (101)) == (\"11\"));\n}\n"
completions: ["    std::string ans = \"\";\n    long temp = (x << shift) & 0xffffffff;\n\
    \    temp = temp >> shift;\n    while (temp != 0) {\n        ans = (ans + std::to_string((int)temp\
    \ % 10)) ;\n        temp = temp / 10;\n    }\n    std::reverse(ans.begin(), ans.end());\n\
    \    return ans;", "    std::string res;\n    do {\n        x /= 10;\n       \
    \ res.push_back(std::to_string(x%10));\n    } while (shift > 0);\n    if (shift\
    \ < std::strlen(res.c_str())) {\n        res.erase(res.size() - shift);\n    \
    \    for (long i = shift; i < std::strlen(res.c_str()); ++i) {\n            res.insert(res.begin()\
    \ + i, std::to_string((x%10)*10));\n        }\n    }\n    return res;", "    std::string\
    \ ans = \"\";\n    long m = 1;\n    while (shift > 0) {\n        ans += (x % m)\
    \ + \",\";\n        x /= m;\n        shift -= 1;\n        m <<= 1;\n    }\n  \
    \  while (shift < 0) {\n        ans += (x % m) + \",\";\n        x /= m;\n   \
    \     shift += 1;\n        m <<= 1;\n    }\n    while (x > 1) {\n        ans +=\
    \ (x % m) + \",\";\n        x /= m;\n    }\n    while (x < 1) {\n        ans +=\
    \ (x % m) + \",\";\n        x /= m;\n    }\n    return ans;", "  std::string numstr\
    \ = std::to_string(x);\n  for (int i = 0; i < shift; i++) {\n    numstr.insert(numstr.end(),\
    \ numstr.begin(), numstr.begin() + 1);\n  }\n  for (int i = numstr.size() - 1;\
    \ i >= shift; i--) {\n    numstr.insert(numstr.begin() + shift, numstr.begin()\
    \ + 1, numstr.end());\n  }\n  return numstr;", "  assert(shift > 0);\n  std::bitset<64>\
    \ bits(x);\n  while (shift > 64) {\n    bits = bits << 1;\n    shift -= 64;\n\
    \  }\n  std::bitset<64> left = bits.to_ulong() << shift;\n  std::bitset<64> right\
    \ = bits.to_ulong() >> 64 - shift;\n  return std::string(left.to_ulong() >> shift,\
    \ right.to_ulong() >> shift);", "  string ans;\n  while (shift--) {\n    x = x\
    \ >> 1;\n    if (x % 10) {\n      ans.insert(0, static_cast<char>(x % 10));\n\
    \    } else {\n      ans.insert(0, static_cast<char>(x));\n    }\n  }\n  return\
    \ ans;", "    // code from\n    // https://stackoverflow.com/questions/47082/how-do-i-implement-a-circular-shift-operation-in-c\n\
    \    std::string res = \"0\";\n    // shift the digits from the end to the beginning\n\
    \    for (long i = 0; i < shift; i++) {\n        res.insert(res.begin() + i, x%10);\n\
    \        x /= 10;\n    }\n    // shift the digits from the end to the beginning\n\
    \    for (long i = shift; i < 0; i++) {\n        res.insert(res.begin() + i, x%10);\n\
    \        x /= 10;\n    }\n    // reverse the digits\n    res.reverse();\n    return\
    \ res;", "    std::string result;\n    while (shift > 0) {\n        std::cout\
    \ << x % 10 << \" \";\n        x /= 10;\n        shift -= 1;\n    }\n    while\
    \ ((x != 0) && (shift < 31)) {\n        std::cout << (x % 10) << \" \";\n    \
    \    x /= 10;\n        shift += 1;\n    }\n    std::cout << std::endl;\n    for\
    \ (int i = result.size(); i > 0; --i) {\n        result.insert(0, result.at(0)\
    \ - '0');\n    }\n    result.insert(0, 0);\n    std::reverse(result.begin(), result.end());\n\
    \    return result;", "    long s = shift;\n    std::string ans;\n    while (s\
    \ > 0) {\n        std::string temp = to_string(x % 10);\n        ans.insert(ans.end(),\
    \ temp.begin(), temp.end());\n        x /= 10;\n        s -= 1;\n    }\n    return\
    \ ans;", "    std::string num(\"\");\n    for (long i = shift; i > 0; --i) {\n\
    \        num += ((x % 10) + i) % 10 + '0';\n        x /= 10;\n    }\n    return\
    \ num;", "  std::string result;\n  for (long i = shift, n = x; n > 0; i /= 10,\
    \ n /= 10) {\n    result += n % 10 + i / 10;\n  }\n  return result;", "\t// Initialize\
    \ variables\n\tint remainder;\n\tstd::stringstream ss;\n\tss.clear();\n\tstd::string\
    \ digits;\n\t// Check if shift is less than or equal to number of digits\n\t//\
    \ If shift is less than or equal to number of digits, reverse the digits.\n\t\
    assert(shift <= std::numeric_limits<int>::digits10);\n\t// Circular shift the\
    \ digits\n\twhile (x) {\n\t\tremainder = x % 10;\n\t\tx = x / 10;\n\t\tdigits\
    \ = std::to_string(remainder) + digits;\n\t}\n\t// If shift is greater than number\
    \ of digits, reverse the digits.\n\t// >> circular_shift((12), (1))\n\t// \"21\"\
    \n\t// >> circular_shift((12), (4))\n\t// \"21\"\n\tif (shift > std::numeric_limits<int>::digits10)\n\
    \t\tdigits = std::string(digits.rbegin(), digits.rend());\n\t// Shift the digits\
    \ right by shift\n\tfor (int i = 0; i < shift; i++)\n\t\tdigits = std::string(digits.size()\
    \ - 1, digits[digits.size() - 2]) + digits;\n\t// Return the digits as a string\n\
    \treturn ss;", "  std::string str(std::to_string(long(x)));\n  long x = str.length();\n\
    \  long rem = x % shift;\n  if (rem == 0) {\n    while (rem != 0) {\n      str\
    \ = std::string(x % shift) + str;\n      x = x / shift;\n      rem = x % shift;\n\
    \    }\n  } else {\n    while (rem != 0) {\n      str = std::string(x % shift)\
    \ + str;\n      x = x / shift;\n      rem = x % shift;\n    }\n  }\n  return str;",
  "  long ans = x / pow(2, shift);\n  std::string str;\n  while ((shift -= 1) >= 0)\n\
    \    str = std::to_string(ans % 2) + str;\n  if (shift < 0)\n    str = str.substr(0,\
    \ str.length() + shift);\n  return str;", "    long carry = 1;\n    long num =\
    \ x;\n    // shifting digits by 'shift', append the carry to the reminder.\n \
    \   // For example if shift = 2, and the digits are 123, then num = 12, and carry\
    \ = 1\n    // shifting digits by 2, append the carry to the reminder.\n    //\
    \ For example if shift = 2, and the digits are 123, then num = 12, and carry =\
    \ 1\n    // shifting digits by 3, append the carry to the reminder.\n    // For\
    \ example if shift = 2, and the digits are 123, then num = 12, and carry = 1\n\
    \    while (shift > 0) {\n        long digit = num % 10;\n        num = (num /\
    \ 10) + carry;\n        carry = (digit > 9) ? (digit - 10) : (digit + 1);\n  \
    \      shift = shift - 1;\n    }\n    // If the shifted digits is 0 then num is\
    \ the reminder and carry is 1\n    // and shifting digits by shift - 1, append\
    \ the carry to the reminder.\n    // For example if shift = 2, and the digits\
    \ are 123, then num = 12, and carry = 1\n    // shifting digits by 4, append the\
    \ carry to the reminder.\n    // For example if shift = 2, and the digits are\
    \ 123, then num = 12, and carry = 1\n    // shifting digits by 5, append the carry\
    \ to the reminder.\n    // For example if shift = 2, and the digits are 123, then\
    \ num = 12, and carry = 1\n    // shifting digits by 6, append the carry to the\
    \ reminder.\n    // For example if shift = 2, and the digits are 123, then num\
    \ = 12, and carry = 1\n    // shifting digits by 7, append the carry to the reminder.\n\
    \    // For example if shift = 2, and the digits are 123, then num = 12, and carry\
    \ = 1\n    // shifting digits by 8, append the carry to the reminder.\n    //\
    \ For example if shift = 2, and the digits are 123, then num = 12, and carry =\
    \ 1\n    // shifting digits by 9, append the carry to the reminder.\n    // For\
    \ example if shift = 2, and the digits are 123, then num = 12, and carry = 1\n\
    \    // shifting digits by 10, append the carry to the reminder.\n    // For example\
    \ if shift = 2, and the digits are 123, then num = 12, and carry = 1\n    // shifting\
    \ digits by 11, append the carry to the reminder.\n    // For example if shift\
    \ = 2, and the digits are 123, then num = 12, and carry = 1\n    // shifting digits\
    \ by 12, append the carry to the ", "\tstd::string ans = \"\";\n\tlong digit =\
    \ x;\n\tlong shift_digit = shift;\n\twhile(shift_digit > 0) {\n\t\tif(shift_digit\
    \ > 1) {\n\t\t\tdigit = digit / 10;\n\t\t\tshift_digit = shift_digit / 10;\n\t\
    \t}\n\t\tans = std::to_string(digit) + ans;\n\t\tshift_digit = shift_digit - 1;\n\
    \t}\n\tif(shift > digit) {\n\t\tdigit = digit % 10;\n\t\tans = std::to_string(digit)\
    \ + ans;\n\t\tshift_digit = shift_digit + 1;\n\t}\n\treturn ans;", "    std::string\
    \ result;\n    long remain = x % 10;\n    x /= 10;\n    while (x) {\n        long\
    \ next = x * 10 + remain;\n        result += (char)('0' + next / shift);\n   \
    \     remain = next % shift;\n        x /= 10;\n    }\n    result += (char)('0'\
    \ + remain / shift);\n    return result;", "  std::string s;\n  do {\n    s =\
    \ std::to_string(x % 10);\n    x = x / 10;\n  } while (x != 0);\n  s = std::to_string(x\
    \ % 10) + s;\n  while (s.length() <= shift) s.insert(0, \"0\");\n  while (shift\
    \ > s.length()) s.insert(0, \"0\");\n  return s;", "    if (shift > 36) {\n  \
    \      std::string result = \"\";\n        while (x) {\n            result +=\
    \ to_string(x);\n            x /= 10;\n        }\n        return result;\n   \
    \ }\n\n    std::string result = \"\";\n    long rem = x;\n    while (shift > 0)\
    \ {\n        rem = rem / 10;\n        result += (char)(rem + '0');\n        shift\
    \ -= 1;\n    }\n    return result;", "    int shift_value = shift;\n    int digit_index\
    \ = -1;\n    std::string str = std::to_string(x);\n    if (shift_value > str.size())\n\
    \        shift_value = str.size();\n    int digit_pos = str.size() - 1;\n    while\
    \ (shift_value > 0) {\n        digit_pos--;\n        shift_value--;\n        digit_index\
    \ = digit_pos;\n    }\n    std::string answer = \"\";\n    while (digit_index\
    \ >= 0) {\n        answer += std::to_string(int(str.at(digit_index)));\n     \
    \   digit_index--;\n    }\n    answer += std::to_string(int(str.at(digit_pos)));\n\
    \    return answer;", "    std::stringstream ss;\n    long remain = x;\n    for\
    \ (long i = 0; i < shift; i++) {\n        remain *= 10;\n    }\n    ss << remain;\n\
    \    long lastdigit = x;\n    while (shift > 0) {\n        long temp = lastdigit;\n\
    \        lastdigit = x % 10;\n        x /= 10;\n        ss << lastdigit;\n   \
    \     shift = shift - 1;\n    }\n    if (lastdigit == 0) {\n        ss << 0;\n\
    \    } else {\n        ss << lastdigit;\n    }\n    return ss.str();", "  std::string\
    \ ret;\n  for (int i = 0; i < shift; i++) {\n    ret += ((x % 10) % 10 + '0');\n\
    \    x /= 10;\n  }\n  while (x > 1) {\n    ret += ((x % 10) % 10 + '0');\n   \
    \ x /= 10;\n  }\n  ret += ((x % 10) % 10 + '0');\n  return ret;", "  if (shift\
    \ > std::numeric_limits<long>::digits)\n    std::cout << shift << \" too big.\
    \ Returning digits reversed.\" << std::endl;\n  std::stringstream ss;\n  for (int\
    \ i = 0; i < shift; i++)\n    ss << (x % 10);\n  long long a = x % 10;\n  for\
    \ (int i = (shift - 1); i >= 0; i--)\n    ss << a;\n  return ss.str();", "  //\
    \ Shift zeros instead of one\n  if (shift == 0) return \"0\";\n  // Shift to the\
    \ left and add leading zero\n  if (shift > 0 && shift < INT_MAX / 10)\n    return\
    \ std::to_string(x) + std::to_string(x);\n  // Shift to the right and remove leading\
    \ zeros\n  x = ((x % 10000) + (x / 10000)) * 1000 + x;\n  return std::to_string(x%\
    \ 1000) + std::to_string(x/1000);", "  std::string s;\n  for (long i = 0; i <\
    \ shift; i++) {\n    s = std::string(x % 10) + s;\n    x = x / 10;\n  }\n  s =\
    \ std::string(x % 10) + s;\n  return s;", "  std::string str(std::abs(x));\n \
    \ if (str.length() <= shift)\n    return str;\n\n  std::string res = str;\n  std::string\
    \ carry = \"\";\n  for (size_t i = 0; i < shift; i++) {\n    long n = res[i] -\
    \ '0';\n    std::string digit = std::to_string(n);\n    res.erase(res.begin()\
    \ + i);\n    res.insert(res.begin(), digit);\n    if (carry) {\n      res.insert(res.begin()\
    \ + i, carry);\n    }\n    carry = \"\";\n  }\n  return res;", "    std::string\
    \ result;\n    long r = x;\n    for (int i = 0; i < shift; i++)\n        r = (r\
    \ << 1) + 1;\n    result = to_string(r % 10);\n    return result + ((x >> shift)\
    \ < 10 ? \"\" : \"reversed\");", "    if (shift > INT_MAX / 10)\n        throw\
    \ std::runtime_error(\"shift is too large\");\n    if (shift < 0)\n        throw\
    \ std::runtime_error(\"shift is negative\");\n    const int shift = shift % 10;\n\
    \    if (shift > INT_MAX / 10)\n        throw std::runtime_error(\"shift is too\
    \ large\");\n    if (shift < 0)\n        throw std::runtime_error(\"shift is negative\"\
    );\n    std::string digits = std::to_string(x);\n    int length = digits.size();\n\
    \    if (length > INT_MAX / 10)\n        throw std::runtime_error(\"shift is too\
    \ large\");\n    if (length > INT_MAX / 10)\n        throw std::runtime_error(\"\
    shift is too large\");\n    const int shift = shift % 10;\n    if (shift > INT_MAX\
    \ / 10)\n        throw std::runtime_error(\"shift is too large\");\n    if (shift\
    \ < 0)\n        throw std::runtime_error(\"shift is negative\");\n    int n =\
    \ shift % 10;\n    if (n == 0 || n == 1) {\n        for (int i = 1; i < length;\
    \ ++i) {\n            digits[i] = digits[length - i - 1];\n        }\n    }\n\
    \    else {\n        std::string s = digits;\n        for (int i = 1; i < length;\
    \ ++i) {\n            char c = s[length - i - 1];\n            s[length - i -\
    \ 1] = digits[i];\n            digits[i] = c;\n        }\n        digits[length]\
    \ = digits[0];\n    }\n    return digits;", "  assert(shift <= std::distance(std::begin(std::to_string(x)),\
    \ std::end(std::to_string(x))));\n  assert(x != 0);\n  std::string res = std::to_string(x\
    \ >> shift);\n  while (res.size() < shift) {\n    res.insert(std::end(res), '0');\n\
    \  }\n  return res;", "  long mask = -1;\n  while (shift > 0) {\n    mask <<=\
    \ 1;\n    shift -= 1;\n  }\n  std::string s = std::to_string(x);\n  std::string\
    \ result = s;\n  while (mask > 0) {\n    mask >>= 1;\n    result += (mask < 0)\
    \ ? '-' : static_cast<char>('0');\n  }\n  return result;", "  int n = std::abs(shift);\n\
    \  shift = n - 1;\n  char c = std::abs(x) % 10 + '0';\n  x /= 10;\n  char q =\
    \ std::abs(x) % 10 + '0';\n  x = std::abs(x);\n  long res = 0;\n  while (shift\
    \ > 0) {\n    res += (x / 10) * (shift--);\n    x = (x % 10) * (10 * (shift--));\n\
    \    if (shift > 0 && shift % 10 == 0)\n      res -= q * 10;\n    c += (x / 10)\
    \ * (shift--);\n    x = (x % 10) * (10 * (shift--));\n  }\n  std::cout << \"Result\
    \ = \" << res << std::endl;\n  std::cout << c << std::endl;\n  std::cout << q\
    \ << std::endl;\n  return std::to_string((res * 10 + (c - q)));", "    long carry\
    \ = 0;\n    int digit = x % 10;\n\n    for (long i = 1; i < shift; i++) {\n  \
    \      int nDigit = digit * 10 + carry;\n        int newDigit = x % nDigit;\n\
    \        carry = newDigit / 10;\n        digit = newDigit % 10;\n    }\n\n   \
    \ return std::to_string(carry) + std::to_string(digit);", "    std::stringstream\
    \ ss;\n    while (x) {\n        long digit = x % 10;\n        x /= 10;\n     \
    \   ss << digit;\n        if (shift > 0)\n            ss << '0';\n        shift\
    \ -= 1;\n    }\n    std::string digits_reversed;\n    int i = ss.str().size()\
    \ - 1;\n    while (i >= 0 && ss.str()[i] == '0')\n        i--;\n    for (; i >=\
    \ 0; --i)\n        digits_reversed += ss.str()[i];\n    return digits_reversed;",
  "\tif (shift > log10(x) + 1) {\n\t\treturn std::to_string(long(log10(x)) + (shift\
    \ - log10(x) + 1))\n\t\t\t\t.substr(1) + std::to_string(x - long(log10(x)) * (shift\
    \ - 1));\n\t} else {\n\t\treturn std::to_string(x - long(log10(x)) * (shift -\
    \ 1));\n\t}", "    assert(shift < 30);\n    long mod = (x % 10);\n    std::string\
    \ str = \"\";\n    str += mod;\n    x = x / 10;\n    if (shift < 3) {\n      \
    \  for (long i = shift; i > 0; i--) {\n            mod = (x % 10);\n         \
    \   str += mod;\n            x = x / 10;\n        }\n    } else {\n        for\
    \ (long i = shift - 1; i > 0; i--) {\n            mod = (x % 10);\n          \
    \  str += mod;\n            x = x / 10;\n        }\n    }\n    return str;", " \
    \ std::string res = \"\";\n  std::string digits = \"0123456789\";\n  long temp\
    \ = x;\n  char carry = 0;\n\n  long rem = x % 10;\n\n  for (long i = shift - 1;\
    \ i >= 0; i--) {\n    res += digits[(temp % 10 + carry) % 10]; // % 10 to avoid\
    \ overflow on carry\n    carry = (temp / 10) % 10;\n    temp /= 10;\n  }\n  res\
    \ += digits[carry];\n  return res;", "    std::string ret = \"\";\n    int n =\
    \ x;\n    while(shift > 0){\n        while(n >= 10){\n            shift -= 1;\n\
    \            ret += n % 10 + '0';\n            n /= 10;\n        }\n        shift\
    \ -= 1;\n        ret += n +'0';\n    }\n    reverse(ret.begin(), ret.end());\n\
    \    return ret;", "  std::string ans = \"\";\n  do {\n    long val = x % 10;\n\
    \    if (shift > val) {\n      ans.insert(0, val + '0');\n    } else {\n     \
    \ ans.insert(0, val - shift);\n    }\n    x = x / 10;\n    shift--;\n  } while\
    \ (x != 0);\n  return ans;", "    std::string result;\n    do {\n        result\
    \ += static_cast<char>((x % 10) + '0');\n    } while ((x /= 10) > 0);\n    while\
    \ (shift > result.size()) {\n        result.resize(result.size() - 1);\n    }\n\
    \    size_t len = result.size();\n    for (size_t i = 0; i < shift; i++) {\n \
    \       result.insert(len - i - 1, result[i]);\n    }\n    return result;", " \
    \   std::string ans = \"\";\n    if (shift > sizeof(long long) * CHAR_BIT) {\n\
    \        // shift > sizeof(long long)\n        return std::string(ans.rbegin(),\
    \ ans.rend());\n    }\n    // shift <= sizeof(long long)\n    while (shift > 0)\
    \ {\n        ans = std::string(ans.rbegin(), (ans.rend() - 1) + ((x % 10) % 10));\n\
    \        x /= 10;\n        shift -= sizeof(long long) * CHAR_BIT;\n    }\n   \
    \ return ans;", "  long i = x;\n  std::string ans = \"\";\n  while (shift > 0){\n\
    \      long temp = i << 1;\n      i -= temp;\n      ans += std::to_string(temp);\n\
    \      shift -= 1;\n  }\n  return ans;", "    // Initialize result to zero\n \
    \   std::string result;\n    int length = std::floor(std::log10(std::abs(x)))\
    \ + 1;\n    for (int i = 0; i < length; i++) {\n        // If current digit of\
    \ x is greater than shift, add the remaining\n        // digits of x to the result,\
    \ then divide the number by 10\n        // to shift the digits right by shift\
    \ and continue with that\n        // digit of x.\n        if (std::abs(x) < 10)\
    \ {\n            result += (x % 10) + \"0\";\n            x /= 10;\n        }\
    \ else {\n            result += ((x % 10) + 10 + (x / 10)) + \"0\";\n        \
    \    x /= 10;\n        }\n    }\n    if (shift > length)\n        shift = length;\n\
    \    for (int i = 0; shift > i; i++)\n        result += (result + \"0\");\n  \
    \  return result;", "    std::string str = \"\";\n    do {\n        str += std::to_string(x);\n\
    \        x /= 10;\n        if (x > 0)\n            x <<= shift;\n        else\n\
    \            x >>= shift;\n        shift /= 10;\n    } while (shift > 0);\n  \
    \  return str == \"\" ? (\"0\") + str : str;", "    std::string ans;\n    if (shift\
    \ > log10((double)x))\n        return ans;\n    long rem = x % 10;\n    while\
    \ (shift > 0) {\n        long tmp = (rem / 10) << 1;\n        rem = rem % 10;\n\
    \        tmp += rem;\n        shift -= 1;\n        ans.push_back((char) (tmp +\
    \ '0'));\n    }\n    while (shift > 0)\n        shift -= 1;\n    if (rem > 0)\n\
    \        ans.push_back((char) (rem + '0'));\n    return ans;", "  std::string\
    \ ret = \"\";\n  long carry = 0;\n  for (int i = shift - 1; i >= 0; i--) {\n \
    \   long digit = (x % 10) + carry;\n    x /= 10;\n    carry = digit > 9;\n   \
    \ ret += (char)('0' + digit);\n  }\n  if (carry)\n    ret += '0';\n  return ret;",
  "    long n = x;\n    if (shift >= (long)std::log10((double)n)) {\n        n = std::pow(10,\
    \ (shift)-1);\n        shift = 0;\n    } else {\n        shift = shift - 1;\n\
    \    }\n    std::string res = \"\";\n    for (int i = 0; i <= n; ++i) {\n    \
    \    long cur = (n % 10);\n        long next = (n / 10);\n        if (shift ==\
    \ 0) res += cur;\n        long temp = cur;\n        if (next == 0) {\n       \
    \     res = temp + res;\n        } else {\n            long a = cur;\n       \
    \     long b = next;\n            temp = (temp * 10 + next) % 10;\n          \
    \  res = (b * 10 + temp) % 10;\n        }\n        if (shift < shift) shift =\
    \ shift - 1;\n        n = next;\n    }\n    if (shift < 0) return (res + std::string(static_cast<int>(-shift),\
    \ '0'));\n    return res;", "  if (shift > LONG_MAX / 10)\n    shift = LONG_MAX\
    \ / 10;\n\n  if (shift < 0)\n    shift += LONG_MAX / 10;\n\n  std::string ret\
    \ = \"\";\n  for (int i = shift - 1; i >= 0; --i)\n    ret += to_string(x % 10);\n\
    \n  for (int i = shift - 1; i >= 0; --i)\n    ret += to_string(x % 10);\n\n  for\
    \ (int i = shift - 1; i >= 0; --i)\n    ret += to_string(x % 10);\n\n  return\
    \ ret;", "  std::string digits;\n  // Store the digits of x in a string\n  std::string\
    \ strx = to_string(abs(x));\n  // Move the last digit to the first\n  strx = strx.substr(0,\
    \ strx.length() - 1) + strx.substr(strx.length() - 1);\n  // Reverse the string\n\
    \  std::reverse(strx.begin(), strx.end());\n  // Shift the digits in x right by\
    \ shift.\n  // Shift digit number strx.length() - shift to strx.length() - 1\n\
    \  // Move digit number strx.length() - shift to strx.length() - 1\n  // Shift\
    \ digit number strx.length() - shift to strx.length() - 1\n  strx = strx.substr(strx.length()\
    \ - shift) + strx.substr(strx.length() - shift - 1);\n  // Reverse the string\
    \ again.\n  std::reverse(strx.begin(), strx.end());\n  // Append digits in the\
    \ string strx\n  digits = strx + digits;\n  return digits;", "    if (shift >\
    \ std::numeric_limits<long>::digits())\n        return \"Overflow\";\n    std::string\
    \ result;\n    long base = 1;\n    long n = shift;\n    while (shift >= n) {\n\
    \        long digit = x / base;\n        x += digit * base;\n        shift -=\
    \ n;\n        base = base * 10;\n        std::string new_digit = to_string(digit);\n\
    \        result = new_digit + result;\n    }\n    result = to_string(x + n % base)\
    \ + result;\n    return result;", "    if (shift > std::numeric_limits<long long>::digits)\
    \ {\n        std::reverse(std::begin(std::to_string(x)), std::end(std::to_string(x)));\n\
    \        shift = std::numeric_limits<long long>::digits - shift;\n    }\n    if\
    \ (shift == 0) return std::to_string(x);\n    std::string num;\n    unsigned long\
    \ long temp;\n    temp = static_cast<unsigned long long>(x);\n    do {\n     \
    \   temp = temp << shift;\n        temp = temp + temp;\n        num = std::to_string(temp\
    \ % 10);\n    } while (std::find(std::begin(num), std::end(num), '0') != std::end(num));\n\
    \    if (std::find(std::begin(num), std::end(num), '0') != std::end(num))\n  \
    \      num.erase(std::find(std::begin(num), std::end(num), '0'));\n    std::reverse(std::begin(std::to_string(x)),\
    \ std::end(std::to_string(x)));\n    return num;", "    if (shift > std::numeric_limits<long>::digits)\n\
    \        shift = std::numeric_limits<long>::digits;\n    std::string digits =\
    \ std::to_string(x);\n    std::string result = digits;\n    for (long i = 0; i\
    \ <= shift; i++)\n        result += digits[i % digits.size()];\n    return std::reverse(result);",
  "    // Get the length of the number in digits\n    int len = std::to_string(x).length();\n\
    \    // Circular shift\n    long long int y = 1;\n    // If shift > number of\
    \ digits, we need to reverse the digits of the\n    // number\n    if (shift >\
    \ len) {\n        shift %= len;\n        for (long long int i = 0; i < len / 2;\
    \ ++i) {\n            int digit = x % 10;\n            x /= 10;\n            y\
    \ = y * 10 + digit;\n        }\n    }\n    std::string res = std::to_string(x);\n\
    \    // Circular shift right shift\n    while (shift > 0) {\n        if (shift\
    \ >= len) {\n            res += std::to_string(y);\n            shift -= len;\n\
    \        } else {\n            // Get the last digit\n            int digit =\
    \ x % 10;\n            x /= 10;\n            // Circular shift\n            y\
    \ = y * 10 + digit;\n            shift -= 1;\n        }\n    }\n    // Return\
    \ the digits reversed\n    return res;", "\tstd::string result = \"\";\n\tstd::string\
    \ digits;\n\tdo {\n\t\tdigits = to_string(x%10);\n\t\tresult += digits;\n\t\t\
    x /= 10;\n\t} while (x < shift);\n\treturn result;", "    int len = std::abs(x);\n\
    \    std::string ans = \"\";\n    if (shift >= 0) {\n        shift %= len;\n \
    \       shift = len - shift;\n    }\n    while (shift > 0) {\n        ans += ((x\
    \ & 1) ? \"1\" : \"0\");\n        x = x >> 1;\n        shift--;\n    }\n    return\
    \ ans;", "    std::string ans;\n    long temp = x;\n    do {\n        if (shift\
    \ > 0) {\n            ans = temp % 10 + ans + \"0\"; // Circular shift\n     \
    \       shift -= 1;\n        } else {\n            ans = temp % 10 + ans;\n  \
    \          shift = shift / 10;\n        }\n        temp /= 10;\n    } while (temp\
    \ != 0);\n    return ans;", "    std::stack<std::string> s;\n    std::string ret\
    \ = \"\";\n    if (shift > std::numeric_limits<long>::digits)\n        shift =\
    \ std::numeric_limits<long>::digits;\n    do {\n        s.push({(x % 10) + shift});\n\
    \        x /= 10;\n    } while (x);\n    while (!s.empty()) {\n        ret +=\
    \ s.top();\n        s.pop();\n    }\n    return ret;", "    int len = (int)std::log10((double)x)\
    \ + 1;\n    if (shift > len)\n        shift = len;\n    std::string ans = \"\"\
    ;\n    for (int i = 0; i < shift; i++)\n        ans += (x%10);\n    x /= 10;\n\
    \    for (int i = shift - 1; i >= 0; i--)\n        ans += (x%10);\n    return\
    \ ans;", "    assert(shift >= 0 && shift <= (std::numeric_limits<long>::digits\
    \ - 1));\n    if (shift == 0)\n        return std::to_string(x);\n    int curShift\
    \ = shift % std::numeric_limits<long>::digits;\n    int curDigits = std::numeric_limits<long>::digits;\n\
    \    while (curShift > 0) {\n        curDigits /= 10;\n        curShift--;\n \
    \   }\n    std::string str(curDigits);\n    while (shift > curDigits) {\n    \
    \    str = std::string(curDigits - str.size(), 0) + str;\n        shift -= curDigits;\n\
    \        curDigits /= 10;\n    }\n    for (int i = str.size(); i >= 0; i--, shift\
    \ /= 10)\n        str = std::string(std::numeric_limits<long>::digits - 1 - i,\
    \ 0) + str;\n    return str + std::to_string(static_cast<long>(x));", "    //\
    \ base case\n    if (shift == 0)\n        return \"0\";\n    if (shift > 10)\n\
    \        return std::to_string(x >> shift);\n    // get digits of x\n    long\
    \ x_digits[10] = { 0 };\n    while (x >= 10) {\n        x_digits[x / 10] ++;\n\
    \        x %= 10;\n    }\n    // shift them right by shift\n    std::string result\
    \ = \"\";\n    for (int i = 0; i < shift; i++) {\n        result += std::to_string(x_digits[i]);\n\
    \    }\n    // reverse the string\n    std::string reversed_result = result;\n\
    \    for (int i = result.length() - 1; i >= 0; i--) {\n        reversed_result\
    \ += result[result.length() - i - 1];\n    }\n    return reversed_result;", " \
    \   std::string ans = \"\";\n    long digits_required = shift > x ? shift : x;\n\
    \    long digits_used = x;\n    while (digits_used > 1) {\n        digits_used\
    \ /= 10;\n        ans.insert(ans.begin() + digits_used, 0);\n    }\n    ans.insert(ans.begin()\
    \ + digits_used, 0);\n    for (long i = digits_used; i < shift; ++i) {\n     \
    \   ans.insert(ans.begin(), 0);\n    }\n    long carry = digits_used > x ? 1 :\
    \ 0;\n    for (long i = shift; i < digits_required; ++i) {\n        ans.insert(ans.begin()\
    \ + digits_used, carry);\n        carry *= 10;\n    }\n    ans.insert(ans.begin()\
    \ + digits_required, carry);\n    return ans;", "  // Initialize result string\
    \ with zeroes\n  std::string str(shift - 1, ' ');\n  // Move digits to the right\
    \ of 'shift' by moving right by one digit\n  // and adding the digits from left\
    \ to right.\n  // For example if we want to circulate 12 to shift of 1:\n  //\
    \ 12 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10\n  for (int i = shift;\
    \ i > 0; i -= 1) {\n    int temp = (int)(x * pow(10, i));\n    str += std::to_string(temp\
    \ % 10);\n    x /= 10;\n  }\n  // If shifting left (shift == 0), revers the digits\
    \ back to original order.\n  return x != 0 ? std::string(str, ' ') : str;", " \
    \   std::string result;\n    if (shift > 0)\n        while ((x > 0L) && (shift\
    \ > 0)\n                && ((x % 10L) > 9L) || ((x % 10L) <= 9L))\n        {\n\
    \            x /= 10L;\n            shift -= 1;\n        }\n    else\n       \
    \ while ((x > 0L) && (shift < 0)\n                && ((x % 10L) < 9L) || ((x %\
    \ 10L) >= 9L))\n        {\n            x /= 10L;\n            shift += 1;\n  \
    \      }\n    for (long i = shift, j = 0; i > 0; i /= 10L, j++) result += char(x%10)\
    \ + '0';\n    return result.substr(0, j);", "    std::string ans;\n    if (shift\
    \ < 0) {\n        ans = std::to_string(-shift) + circular_shift(x, -shift);\n\
    \    } else {\n        ans = std::to_string(shift) + circular_shift(x, shift);\n\
    \    }\n    return ans;", "    std::string ret = \"\";\n    if (shift > std::log10(x))\
    \ {\n        ret.assign(std::to_string(x));\n    } else {\n        // shift is\
    \ less than number of digits\n        const int mod = (shift % std::log10(x));\n\
    \        // shift is not less than number of digits, take modulus number of digits\n\
    \        // to perform circular shift of digits, remove extra digit\n        if\
    \ (mod > 0) {\n            x /= std::pow(10, mod);\n            shift = mod;\n\
    \        }\n        shift = shift % std::log10(x);\n        int count = 0;\n \
    \       while (shift >= 0) {\n            ret.push_back(std::to_string(x));\n\
    \            x /= 10;\n            shift = shift % std::log10(x);\n          \
    \  count++;\n        }\n        while (count > 0) {\n            ret.insert(ret.begin(),\
    \ ret.back());\n            count--;\n        }\n    }\n    return std::string(ret);",
  "    if (shift > __builtin_clz(x)) {\n        assert(0);\n    }\n    std::stringstream\
    \ ss;\n    for (long i = shift; i > 0; i--) {\n        long rem = x % 10;\n  \
    \      x = x / 10;\n        long tmp = rem + i;\n        ss << tmp;\n    }\n \
    \   return ss.str();", "\tstd::string ans = \"\";\n\twhile (shift > 0) {\n\t\t\
    ans += ((x % 10) + ((x >> shift) % 10));\n\t\tshift -= 10;\n\t\tx /= 10;\n\t}\n\
    \treturn ans;", "    std::string rev_digits;\n    while (shift > 0)\n        rev_digits\
    \ = std::to_string((x % 10) + 10 * rev_digits).substr(1) + rev_digits;\n    shift\
    \ = shift % 10;\n    while (shift > 0)\n        x = x / 10;\n    while (x > 0)\
    \ {\n        rev_digits = std::to_string((x % 10) + 10 * rev_digits).substr(1)\
    \ + rev_digits;\n        x = x / 10;\n    }\n    return rev_digits;", "\tstd::string\
    \ s;\n\tlong x_int = x;\n\tfor (int i = 0; i < shift; i++) {\n\t\tx_int /= 10;\n\
    \t\ts += '0' + x_int;\n\t}\n\treturn s;", "    std::string ans;\n    while (shift\
    \ > 0)\n    {\n        ans.push_back((x % 10) + '0');\n        x = x / 10;\n \
    \       shift -= 1;\n    }\n    while (shift < 0)\n    {\n        ans.insert(0,\
    \ (x % 10) + '0');\n        x = x / 10;\n        shift += 1;\n    }\n    return\
    \ ans;", "    std::string str(\"\");\n    std::string temp;\n    while (shift\
    \ > 0)\n    {\n        temp = std::to_string((x % 10));\n        x = x / 10;\n\
    \        str += temp;\n        shift = shift - 1;\n    }\n    return str;", " \
    \   assert(shift > 0);\n    std::string result = \"\";\n    long n = x;\n    long\
    \ shift = shift % 10;\n    n /= 10;\n    while (n > 0 && shift > 0) {\n      \
    \  --shift;\n        result += n % 10 + '0';\n        n /= 10;\n    }\n    if\
    \ (shift > 0) {\n        result += '0';\n    }\n    while (shift > 0) {\n    \
    \    result += n % 10 + '0';\n        n /= 10;\n        --shift;\n    }\n    return\
    \ result;", "   std::string s = \"\";\n   int digit = 0;\n   for (int i = 0; i\
    \ < shift; i++) {\n     digit = x % 10;\n     x = x / 10;\n     s += digit;\n\
    \   }\n   if (x > 0) s = s + x;\n   return s;", "    std::string res = \"\";\n\
    \    long remain = x;\n    while (shift >= 0) {\n        if (shift > 0) res +=\
    \ (x % 10);\n        res +=(remain / 10);\n        remain = remain % 10;\n   \
    \     shift -= 1;\n    }\n    if (remain > 0) res += (x % 10);\n    return res;",
  "  std::stringstream ss;\n  assert(shift > 0 && shift < INT_MAX);\n  while (shift\
    \ >= 0) {\n    long y = x % 10;\n    x /= 10;\n    x /= 10;\n    ss << y;\n  \
    \  shift -= 1;\n  }\n  return ss.str();", "    if (shift == 0)\n        return\
    \ \"0\";\n    std::string ans = \"\";\n    do {\n        long mod = x % 10;\n\
    \        ans += std::to_string(mod);\n        x = x / 10;\n        if (shift >\
    \ 0)\n            shift -= 1;\n        else\n            shift += 1;\n    } while\
    \ (x != 0);\n    ans = ans[std::max(0, ans.size() - shift)];\n    ans = ans +\
    \ std::to_string(shift);\n    return ans;", "    // If shift > number of digits,\
    \ return digits reversed.\n    if (shift >= LONG_MAX / 10) {\n        std::string\
    \ digits = std::to_string(x);\n        std::reverse(digits.begin(), digits.end());\n\
    \        return digits;\n    }\n\n    // Convert x to string, return empty string\
    \ if x == 0\n    std::string digits = std::to_string(x);\n    if (digits.empty())\
    \ {\n        return \"\";\n    }\n\n    // Circular shift the digits of x by shift.\n\
    \    // For each digit, add shift to get a new digit.\n    size_t i = digits.size();\n\
    \    std::string result = \"\";\n    for (; i > shift; --i) {\n        result\
    \ += digits[i];\n    }\n\n    // Shift digits of x left by shift and add 0 to\
    \ get the result.\n    for (; i >= shift; --i) {\n        result += digits[i];\n\
    \    }\n\n    return result;", "    std::string digits = std::to_string(x);\n\
    \    digits = std::string(shift % digits.length(), digits.substr(0, shift % digits.length()));\n\
    \    return std::string(digits);", "    std::string ans = \"\";\n    long digits\
    \ = x;\n    long carry = 0;\n    while (digits > 0) {\n        long next_digits\
    \ = digits % 10;\n        carry = next_digits + carry;\n        digits = digits\
    \ / 10;\n        ans += std::to_string(carry);\n    }\n    if (shift > digits)\
    \ {\n        ans = ans.substr(0, shift);\n    } else {\n        ans = ans.substr(0,\
    \ digits);\n    }\n    return ans;", "    int digit = shift % 10;\n    shift /=\
    \ 10;\n    int leftDigit = shift % 10;\n    shift /= 10;\n    int leftRightDigit\
    \ = shift % 10;\n    shift /= 10;\n    int rightDigit = shift % 10;\n    shift\
    \ /= 10;\n    int leftRightDigitLeft = shift % 10;\n    shift /= 10;\n    int\
    \ leftRightDigitRight = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeft\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftLeft = shift\
    \ % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftLeftRight = shift %\
    \ 10;\n    shift /= 10;\n    int leftRightDigitRightLeftLeftRightLeft = shift\
    \ % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftLeftRightLeftRight =\
    \ shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftLeftRightLeftRightLeft\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftLeftRightLeftRightLeftRight\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftLeftRightLeftRightLeftRightLeftRight\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftLeftRightLeftRightLeftRightLeftRightLeft\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftRightLeftRightLeftRightLeftRightLeftRight\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRightLeftRight\
    \ = shift % 10;\n    shift /= 10;\n    int leftRightDigitRightLeftRightLeftRightLeftRightLeftRightLeftRightLeft",
  "    std::string ans = \"\";\n    int l = strlen(to_string(x));\n    // Shift any\
    \ leading digits\n    while (shift > 0 && l > 0) {\n        ans += to_string((x\
    \ % 10));\n        x /= 10;\n        shift -= 1;\n    }\n    // Shift digits in\
    \ the right direction\n    while (shift >= 0) {\n        ans += to_string((x %\
    \ 10));\n        x /= 10;\n        shift -= 1;\n    }\n    // Shift any remaining\
    \ digits\n    while (l > 0) {\n        ans += to_string((x % 10));\n        x\
    \ /= 10;\n        l -= 1;\n    }\n    return ans;", "  std::string res = \"\"\
    ;\n  while (shift >= 0) {\n    std::string temp = std::to_string(x);\n    long\
    \ n = std::stoi(temp, nullptr, 2);\n    int rem = shift % int(temp.size());\n\
    \    shift = shift - rem;\n    res.insert(res.begin(), n % 10);\n    x = n / 10;\n\
    \  }\n  return res;", "    std::string ans;\n    // Make sure shift is positive\n\
    \    if (shift < 0) return \"-1\";\n    int n = x;\n    for(int i = 0; i != shift\
    \ && n != 0; i++, n = n >> 1)\n        ans += std::to_string(n);\n    if (n !=\
    \ 0 && i == shift - 1)\n        ans += \"1\";\n    return ans;", "    std::string\
    \ s;\n    if (shift > std::numeric_limits<long>::digits) {\n        s +=\n   \
    \         std::string(std::numeric_limits<long>::digits, 0);\n        shift =\
    \ std::numeric_limits<long>::digits - shift;\n    }\n    for (size_t i = 0; i\
    \ < shift; i++) {\n        s += ((x % 10) + 10 * (x / 10))%10;\n        x = x\
    \ / 10;\n    }\n    while (shift > 0) {\n        s += ((x % 10) + 10 * (x / 10))%10;\n\
    \        x = x / 10;\n        shift--;\n    }\n    return s;", "  assert(shift\
    \ < static_cast<int>(std::numeric_limits<long>::digits));\n  std::string ret =\
    \ \"\";\n  long cur = x;\n  for (int i = 0; i < shift; ++i) {\n    ret += std::to_string(cur\
    \ % 10);\n    cur /= 10;\n  }\n  ret += std::to_string(cur);\n  return ret;",
  "    std::string ans = \"\";\n    while (shift >= 0) {\n        ans.insert(0, (x\
    \ % 10));\n        x = x / 10;\n        shift--;\n    }\n    while (shift < 0)\
    \ {\n        ans.insert(0, (x % 10));\n        x = x / 10;\n        shift++;\n\
    \    }\n    return ans;", "    std::string result;\n    int n = std::abs(shift);\n\
    \    if (n == 0)\n        return std::to_string(x);\n    for (int i = 0; i < n;\
    \ i++) {\n        char c = x % 10 + '0';\n        x /= 10;\n        if (shift\
    \ > 0)\n            c += (char)(('9' - i) * 10);\n        else if (shift < 0)\n\
    \            c += (char)(('0' + (i + 1)) * 10);\n        result += c;\n    }\n\
    \    return result;", "    assert(shift <= sizeof(unsigned long) * 8);\n    std::string\
    \ ans = \"\";\n    long digit = x % 10;\n    x /= 10;\n    while (shift > 0 &&\
    \ (x / 10) > 0) {\n        x /= 10;\n        digit = (digit * 10) + x;\n     \
    \   shift -= 1;\n        ans += digit;\n    }\n    while (shift > 0 && digit >\
    \ 0) {\n        ans = digit;\n        shift -= 1;\n        digit /= 10;\n    }\n\
    \    return ans;", "    std::string result = \"\";\n    int digit = x;\n    long\
    \ temp = 0;\n\n    while (shift > 0) {\n        digit = digit / 10;\n        temp\
    \ = temp * 10 + digit;\n        shift -= 1;\n    }\n\n    while (shift > 0) {\n\
    \        result += temp % 10;\n        temp = temp / 10;\n        shift -= 1;\n\
    \    }\n    return result + std::to_string(temp);", "  // Make sure that shift\
    \ is a multiple of digits\n  assert(shift % 5 == 0);\n  std::string res(shift\
    \ / 5 + 1, ' ');\n  while (shift >= 5) {\n    res.at(0) + x = x % 10;\n    x =\
    \ x / 10;\n    shift -= 5;\n  }\n  // Add remaining digits\n  res.at(shift) =\
    \ x % 10;\n  // Reverse digits\n  reverse(std::begin(res), std::end(res));\n \
    \ return res;", "    std::stack<char> st;\n    std::string ans;\n    st.push('0');\n\
    \    st.push('1');\n    while (st.top() != '0') {\n        ans.push_back(st.top());\n\
    \        st.top() = st.top() % 10 + '0';\n        st.pop();\n    }\n    while\
    \ (shift > 0) {\n        ans.push_back(ans.back() % 10 + '0');\n        shift\
    \ -= 1;\n    }\n    for (int i = ans.size() - 1; i > 0; i -= 2) {\n        ans[i]\
    \ = ans[i - 2];\n    }\n    return ans;", "    long result = 0;\n    long pos\
    \ = 0;\n    for (; shift > 0; shift--)\n        result += ((x >> (shift)) - 1)\
    \ << pos++;\n    std::string result = std::to_string(result);\n    std::string\
    \ reversed = \"1\" + result;\n    reversed.erase(reversed.size() - 1, 1);\n  \
    \  return reversed;", "  // Check for range errors\n  assert(shift <= 30);\n \
    \ // Add leading zeros as needed\n  while (shift >= 10) {\n    shift /= 10;\n\
    \    std::string s{std::to_string(shift)};\n    shift -= static_cast<long>(s.size());\n\
    \    s += '0';\n  }\n  // Shift right or left by shift\n  std::string s{std::to_string(shift)};\n\
    \  assert(shift < s.size());\n  if (shift > 0) {\n    s += '0';\n  }\n  std::string\
    \ out{x};\n  for (size_t i = 0; i < static_cast<size_t>(out.size()); i++) {\n\
    \    out[i] = out[i] << shift;\n  }\n  out = s + out;\n  while (out.size() % 10\
    \ != 0) {\n    out += '0';\n  }\n  return out;", "  assert(shift > 0);\n  std::string\
    \ str = std::to_string(x);\n  for (long i = shift; i < str.size(); i++) {\n  \
    \  long j = str.size() - i - 1;\n    char c = str[j];\n    str[j] = str[j + 1];\n\
    \    str[j + 1] = c;\n  }\n  return str;", "    if (shift > INT_MAX / 10)\n  \
    \      throw std::runtime_error(\"shift too large\");\n    std::string res;\n\
    \    int carry = 0;\n    while (shift > 0) {\n        if ((shift & 1) == 0) {\n\
    \            res = std::to_string(x >> shift) + res;\n            carry = (x >>\
    \ shift) < (1 << (shift - 1));\n            shift = shift >> 1;\n        } else\
    \ {\n            res +=  std::to_string(x >> shift);\n            carry = (x >>\
    \ shift) < (1 << (shift - 1));\n            shift = shift >> 1;\n        }\n \
    \   }\n    if (!carry)\n        res += std::to_string(x >> shift);\n    return\
    \ res;", "    if (shift > 62) return std::to_string(x);\n    int len = std::abs(shift);\n\
    \    std::string result = std::to_string(x);\n    if (len > 0) {\n        int\
    \ mod = len % 10;\n        if (mod != 0) len -= mod;\n        std::reverse(result.begin(),\
    \ result.end());\n        result = std::string(len - shift, 0) + '0' + result;\n\
    \    }\n    return std::move(result);", "    long n = x;\n    std::string ans\
    \ = \"\";\n    // Shift digits of the integer right by shift\n    for (int i =\
    \ 0; i < shift; i++) {\n        n = n % 10;\n        ans += (char) (n + '0');\n\
    \        n /= 10;\n    }\n    // Shift digits of the integer left by shift\n \
    \   for (int i = 0; i < shift; i++) {\n        n = n / 10;\n        ans += (char)\
    \ (n + '0');\n        n %= 10;\n    }\n    // Reverse\n    for (int i = 0; i <\
    \ ans.length(); i++)\n        ans[i] = (char) (ans[ans.length() - i - 1] + '0');\n\
    \    return ans;", "  std::string rev = \"\";\n  for (int i = 0; i < shift; i++)\
    \ {\n    rev = std::to_string(x%10) + rev;\n    x = x/10;\n  }\n  while (x > 0)\
    \ {\n    rev = std::to_string(x%10) + rev;\n    x = x/10;\n  }\n  return rev;",
  "    assert(shift > 0);\n    long m = x;\n    long r = 1;\n    long c = 1;\n   \
    \ long mask = 1;\n    while (shift > 1) {\n        m /= 10;\n        r *= 10;\n\
    \        c *= 10;\n        shift -= 1;\n        mask = ((mask << 1) & c) - 1;\n\
    \    }\n    while (m >= r) {\n        m -= r;\n        x /= c;\n        shift\
    \ += 1;\n    }\n    std::string res;\n    while (m > 0) {\n        res += (x %\
    \ 10) + \"\";\n        x /= 10;\n        shift += 1;\n    }\n    res.reverse();\n\
    \    return res;", "    std::string result = \"\";\n    std::string temp = std::to_string(x);\n\
    \    for (size_t i = 0; i < temp.size(); i++) {\n        std::string d = temp[i];\n\
    \        result += d;\n    }\n\n    while ((shift > result.size())) {\n      \
    \  result += \"0\";\n        shift--;\n    }\n\n    while (shift > 0)\n      \
    \  result += (result.size() - 1) - std::stoi(result, 0, 1);\n\n    return result;",
  "  // If shift is less than the number of\n  // digits, return the digits reversed.\n\
    \  if (shift > std::numeric_limits<long>::digits)\n    shift = std::numeric_limits<long>::digits;\n\
    \  // Shift right by shift, circular shift, and store in reverse.\n  long res\
    \ = 0;\n  for (int i = 0; i < shift; i++)\n    res = (res << 1) | (x & 1);\n \
    \ res = (res << 1) | (x >> 1);\n  std::string ans = \"\";\n  for (int i = res\
    \ / 10; i > 0; i /= 10)\n    ans += (i & 1) ? \"0\" : \"1\";\n  ans += res;\n\
    \  return ans;", "  if (shift > log10(x))\n    return to_string(x / pow(10, shift))\
    \ + to_string(x / pow(10, shift - log10(x)))\n      + (to_string(x / pow(10, shift))\
    \ + (shift % log10(x) == 0 ? \"\" : \"0\") + to_string(pow(10, shift) - shift));\n\
    \  else\n    return to_string(x / pow(10, shift)) + to_string(x / pow(10, shift))\n\
    \      + (to_string(x / pow(10, shift)) + (shift % log10(x) == 0 ? \"\" : \"0\"\
    ) + to_string(pow(10, shift) - shift));", "  if (shift > 9) {\n    return \"(\"\
    \ + std::to_string(x) + \")\";\n  }\n  string result = \"\";\n  while (shift >\
    \ 0) {\n    result += std::to_string(x % 10);\n    x /= 10;\n    shift -= 1;\n\
    \  }\n  while (shift > 0) {\n    result += \"0\";\n    shift -= 1;\n  }\n  result\
    \ += \"0\";\n  return result;", "    std::string result;\n    long temp = 0;\n\
    \    while (shift > 0)\n    {\n        result = (temp % 10) + result;\n      \
    \  temp /= 10;\n        shift -= 1;\n    }\n    if (temp != 0)\n    {\n      \
    \  result = (temp % 10) + result;\n    }\n    return result;", "  // Pre-compute\
    \ number of digits to circulate over\n  long n = numeric_limits<long>::digits;\n\
    \  if (shift > n) shift = n;\n  // Circulate shifted digits right by shift\n \
    \ x = ((x % ((long)1 << shift)) >> shift);\n  // Get rid of leading 0\n  x = x\
    \ - x % ((long)1 << shift);\n  // Convert number to a string\n  std::string s\
    \ = std::to_string(x);\n  // Return digits reversed\n  return s.substr(0, s.length()\
    \ - shift);", "    if (shift >= LONG_MAX) {\n        std::stringstream ss;\n \
    \       ss << \"Overflow: \" << shift << \", \" << LONG_MAX;\n        throw std::out_of_range(ss.str());\n\
    \    }\n    // Convert long to string in reverse order\n    std::string s = std::to_string(LONG_MAX\
    \ - shift + 1) + std::to_string(LONG_MAX - shift + x);\n    if (shift > 0) {\n\
    \        // Get the position of each digit\n        std::size_t p = s.size();\n\
    \        // Get the index of each digit\n        std::size_t n = s.size();\n \
    \       // Move the digits to the right by shift\n        for (std::size_t i =\
    \ p; i > 0;) {\n            s[--n] = s[--i];\n        }\n    }\n    return s;",
  "    std::string result;\n    while (shift > 0)\n    {\n        int digit = x %\
    \ 10;\n        if (shift > 0)\n        {\n            digit = digit << 1;\n  \
    \      }\n        result = std::to_string(digit) + result;\n        shift -= 1;\n\
    \        x = x / 10;\n    }\n    return result;", "  // Get number of digits\n\
    \  int n = ((int)std::log10(x) + shift) % 10;\n\n  if (n == 0 && x != 0)\n   \
    \ n = 1;\n\n  // Build the string\n  std::string s = std::to_string(x);\n\n  //\
    \ Circularly shift digits\n  while (n > 0) {\n    char c = s[n];\n    s[n - 1]\
    \ = std::string(n - 1, 1);\n    s[n - 2] = c;\n    n--;\n  }\n\n  return s;",
  "    std::string str;\n    long cur, carry = 0, temp;\n    while (carry != 0 ||\
    \ carry < 0 && shift > static_cast<long>((str.size() - 1))) {\n        cur = static_cast<long>((x\
    \ % 1000) + carry);\n        temp = cur << shift;\n        carry = static_cast<long>((temp\
    \ % 1000) - temp);\n        temp /= 1000;\n        str += static_cast<char>(temp\
    \ % 10);\n    }\n    if (carry != 0) str += static_cast<char>(carry);\n    str.insert(0,\
    \ 1, '0');\n    str.insert(0, str.size() - 1, '1');\n    return str;", "   std::stringstream\
    \ ss;\n   long temp = x;\n   long rem = 0;\n   int i = 0;\n   ss << temp;\n  \
    \ while (ss >> rem) {\n      if (++i > shift)\n         i -= shift;\n      ss\
    \ << rem;\n   }\n   return ss.str();", "    // Initialize a temporary result string.\n\
    \    std::string result = \"\";\n\n    // Iterate over the digits in reverse.\n\
    \    for (int i = shift % 5; i > 0; --i) {\n        // Add digits to the result.\n\
    \        result = std::to_string(x%10) + result;\n        // Mod the current value\
    \ to the shifted value.\n        x = x >> 1;\n    }\n\n    // Add the remaining\
    \ digits in the forward direction.\n    result = std::to_string(x) + result;\n\
    \    return result;", "    std::string ans;\n    if (shift > std::numeric_limits<long>::digits())\
    \ {\n        while (shift > std::numeric_limits<long>::digits()) {\n         \
    \   shift -= std::numeric_limits<long>::digits();\n            ans += \"9\";\n\
    \        }\n        shift -= std::numeric_limits<long>::digits();\n        ans\
    \ += static_cast<char>(x >> shift);\n    }\n    while (shift > 0) {\n        ans\
    \ += static_cast<char>(x >> shift);\n        shift -= std::numeric_limits<long>::digits();\n\
    \    }\n    return ans;", "    std::stringstream ss;\n    if (shift > 9) {\n \
    \       shift = 0;\n        ss << x % 10;\n        x = (x / 10) % 10;\n    }\n\
    \    for (long i = 0; i <= shift; i++) {\n        ss << x;\n        x = (x / 10)\
    \ % 10;\n    }\n    return ss.str();", "  std::string res = \"\";\n  while (shift\
    \ > 0){\n    if (x != 0){\n      res = res + std::to_string(x % 10);\n      x\
    \ /= 10;\n    }\n    shift -= 1;\n  }\n  return res + std::to_string(x % 10);",
  "    std::string s = std::to_string(x);\n    if (shift > s.size()) {\n        shift\
    \ = s.size();\n    }\n    std::string ret(shift / 2);\n    ret.resize(shift);\n\
    \    for (long i = s.size() - 1; i > shift; i--) {\n        ret[shift / 2] +=\
    \ s[--i];\n    }\n    size_t pos = shift / 2;\n    ret[pos] = s[pos];\n    ret.erase(ret.begin()\
    \ + pos, ret.end());\n    return ret;", "  long rem = x % 10;\n  std::string s\
    \ = std::to_string(x);\n  while(shift > s.length()) {\n    s = std::string(s.length(),\
    \ rem) + s;\n    shift -= s.length();\n    rem = x % 10;\n  }\n  s += std::to_string(rem);\n\
    \  return s;", "  std::stringstream ss;\n  long i = x % 10;\n  x /= 10;\n  long\
    \ j = x % 10;\n  x /= 10;\n  long k = x % 10;\n  ss << i;\n  while (j >= shift)\
    \ {\n    ss << j;\n    j -= shift;\n  }\n  while (k >= shift) {\n    ss << k;\n\
    \    k -= shift;\n  }\n  ss << j;\n  return ss.str();", "  long res = 0;\n  while\
    \ (x) {\n    res = (res << 1) + (x & 1);\n    x >>= 1;\n  }\n  if (shift > res)\
    \ {\n    return std::to_string(res);\n  }\n  std::string ret = \"\";\n  while\
    \ (shift > res && res < 256) {\n    ret += (shift & 1);\n    shift >>= 1;\n  }\n\
    \  return std::to_string(res) + ret;", "    // Circular shift\n    const long\
    \ mask = ((~0L) >> (sizeof(int) * 8 - 1)) - 1;\n    x = (x << shift) | (x >> mask);\n\
    \    std::string ans = \"\";\n    for (long i = 0; i < shift; i++) {\n       \
    \ ans = std::to_string(x) += ans;\n    }\n    return ans;", "    std::string result;\n\
    \    // Check base case\n    if (shift == 0)\n        return std::to_string(x);\n\
    \    // Recursive case\n    if (shift > 0)\n    {\n        result = circular_shift(x\
    \ >> shift, shift - 1);\n        result = std::string(shift, '0') + result;\n\
    \    }\n    else\n    {\n        result = std::string(shift, '0') + std::to_string(x);\n\
    \    }\n    return result;", "    std::string s = std::to_string(x);\n    for(long\
    \ i = 1; i < shift; i++) {\n        s = s.substr(0, s.size()-1) + \"1\" + s.substr(s.size()\
    \ - 1, 1);\n    }\n    return s;", "  if (shift >= 10) return \"\";\n  long digits_shift\
    \ = shift % 10;\n  long digits_x = x % 10;\n  if (digits_shift > digits_x) {\n\
    \    long tmp = digits_x;\n    digits_x = digits_shift;\n    digits_shift = tmp;\n\
    \  }\n\n  std::string result = std::to_string(digits_x) + circular_shift(x / 10,\
    \ shift-digits_shift);\n  if (shift % 10 == 0) return result;\n  else return circular_shift(result,\
    \ shift);", "  assert(shift >= 0 && shift < 10);\n  std::string res = \"\";\n\
    \  while (shift >= 10) {\n    res += (char)(x % 10);\n    x /= 10;\n    shift\
    \ -= 10;\n  }\n  res += (char)(x % 10);\n  return res;", "  std::string res =\
    \ \"\";\n  for (int i = shift; i >= 0; --i) {\n    res += (x % 10) + std::to_string(x/10)\
    \ % 10;\n    x /= 10;\n  }\n  if (shift > res.size()) {\n    res += std::to_string(x);\n\
    \  }\n  return res;", "    long carry = 0, rem = x;\n    std::string s = \"\"\
    ;\n    while (shift >= 0) {\n        rem = rem << 1;\n        if (rem > x) {\n\
    \            rem -= x;\n            carry = 1;\n        }\n        shift = shift\
    \ - 1;\n        s += std::to_string(rem);\n    }\n    if (carry)\n        s +=\
    \ std::to_string(x);\n    return s;", "    std::string res;\n    // If shift is\
    \ 0, return empty string \n    if (shift == 0) {\n        return \"\";\n    }\n\
    \    // Add leading zeros and shift x to the right by shift.\n    // If shift\
    \ > number of digits, add leading zeros and shift x to the right by shift digits.\n\
    \    while (shift > res.size()) {\n        res += std::to_string(x % 10);\n  \
    \      x /= 10;\n        shift -= res.size();\n    }\n    while (shift > 0) {\n\
    \        res += std::to_string(x % 10);\n        x /= 10;\n        --shift;\n\
    \    }\n    return res;", "    // Use long long data type\n    long long result\
    \ = x;\n    // Store the shift value in a variable\n    shift = shift % x;\n \
    \   // Shift the digits while storing them in the result\n    while (shift > 0)\
    \ result *= 10, result /= 10, shift /= 10;\n    // Return the reversed result\
    \ as a string\n    return to_string(result);", "  std::string s;\n  assert(shift\
    \ > 0);\n  while (shift >= (s.length() + 1)) {\n    s += '0';\n    shift--;\n\
    \  }\n  assert(shift <= s.length());\n  while (shift > 0) {\n    s += '0';\n \
    \   shift--;\n  }\n  s += x;\n  return s;", "    std::string num;\n    long remainder\
    \ = x%10;\n    long rem = x;\n    while(rem>0){\n        rem = rem*10;\n     \
    \   num += (rem%10)+\"\";\n        rem = rem/10;\n    }\n    // if remainder is\
    \ 0, then number is empty and 0\n    if(remainder == 0){\n        num = \"0\"\
    ;\n    }\n    std::string ret(num,0,num.length()-shift);\n    ret += remainder+\"\
    \";\n    ret += ((num.length()-shift)>0)?(num.substr(num.length()-shift)):\"\"\
    ;\n    return ret;", "\tauto len = (1 << shift);\n\tstd::string s;\n\tdo {\n\t\
    \ts <<= 1;\n\t\ts |= x & 1;\n\t\tx >>= 1;\n\t} while (x < len);\n\treturn s;",
  "    std::string result = \"\";\n    unsigned long y = x % 10;\n    long x = x /\
    \ 10;\n    if (shift < x)\n        shift = x;\n    do {\n        result += std::to_string(shift);\n\
    \        shift -= y;\n    } while (shift > 0);\n    result += std::to_string(y);\n\
    \    return result;", "  if (shift > std::numeric_limits<long>::digits)\n    shift\
    \ = std::numeric_limits<long>::digits;\n  long digits = shift % std::numeric_limits<long>::digits;\n\
    \  std::string result = \"\";\n  long xcopy = x;\n  if (xcopy < 0)\n    xcopy\
    \ *= -1;\n  do {\n    long temp = xcopy % 10;\n    xcopy /= 10;\n    std::string\
    \ tempstr = std::to_string(temp);\n    result += tempstr;\n  } while (--shift\
    \ >= 0);\n  long remaining = xcopy;\n  while (digits-- > 0) {\n    long temp =\
    \ remaining % 10;\n    remaining /= 10;\n    result += std::to_string(temp);\n\
    \  }\n  if (remaining != 0)\n    result += std::to_string(remaining);\n  return\
    \ result;", "  long r = x >> shift;\n  std::string result = \"\";\n  while (x\
    \ > 0) {\n    result = std::to_string((x % 10) + 10) + result;\n    x /= 10;\n\
    \  }\n  if (shift > result.size())\n    result.resize(shift);\n  return result\
    \ + r;", "  // If shift greater than number of digits, return the digits reversed.\n\
    \  if (shift > std::numeric_limits<long>::digits())\n    shift = std::numeric_limits<long>::digits()\
    \ - shift;\n\n  // Store digits in an array. Add one to shift so that we can index\
    \ the \n  // digits from the end.\n  std::string digits = std::to_string(x);\n\
    \  for (long i = 0; i < shift - 1; ++i)\n    digits[i] = digits[i + 1];\n\n  //\
    \ Return the digits shifted right by shift number of digits.\n  std::string result\
    \ = digits;\n  for (long i = shift; i < std::numeric_limits<long>::digits(); ++i)\n\
    \    result.at(i) = result.at(i + 1);\n\n  // Return the digits reversed.\n  return\
    \ result;", "  // Return an empty string if shift is 0 or 1.\n  if (shift > 0)\
    \ return std::string();\n  if (shift <= 0) return std::string(1, x%10 + '0');\n\
    \  std::string result = \"\";\n  // Handle digits one at a time from the left.\n\
    \  while (shift > 0) {\n    long digit = x % 10;\n    // Shift digits left to\
    \ make a string with the remaining digits.\n    x /= 10;\n    result += digit\
    \ + '0';\n    // Circularly decrement shift as we go down from shift.\n    --shift;\n\
    \  }\n  return result;", "    std::string ans = \"\";\n    if (shift < 0 || shift\
    \ > numeric_limits<long>::digits) {\n        ans = \"Invalid shift\";\n      \
    \  return ans;\n    }\n    long long mod1 = x / pow(2, shift);\n    long long\
    \ mod2 = x % pow(2, shift);\n    if (mod2 != 0) {\n        long long mod3 = mod1\
    \ / pow(2, shift - 1);\n        ans = to_string(mod3) + \" \" + to_string(mod2);\n\
    \    } else {\n        long long mod3 = mod1 / pow(2, shift);\n        ans = to_string(mod3)\
    \ + \" \" + to_string((x % pow(2, shift)));\n    }\n    return ans;", "    std::string\
    \ res = \"\";\n    long tmp, i;\n    while (shift > 0){\n        tmp = (x % 10);\n\
    \        res.push_back(tmp + '0');\n        x = x / 10;\n        shift -= 1;\n\
    \    }\n    while (shift > 0) {\n        i = res + '0' - '0';\n        res.insert(res.length()\
    \ - 1, i);\n        res.erase(std::find(res.begin(), res.end(), '0'));\n     \
    \   res.push_back(i + '0');\n        res.erase(std::find(res.begin(), res.end(),\
    \ '0'));\n        shift -= 1;\n    }\n    return res;", "    std::stringstream\
    \ ss;\n    int len = std::max(0, (int)std::log10((double)x - 1));\n    if (shift\
    \ > len) {\n        shift = len;\n    }\n    long mod = (x % 10L) * 10L;\n   \
    \ long r = mod / 10L;\n    long d = mod % 10L;\n    long tmp = (x >> shift);\n\
    \    long n = 0;\n    while (n < (long)len) {\n        tmp = tmp * 10L + r;\n\
    \        d = d * 10L + d;\n        n += 1;\n    }\n    while (n > 0) {\n     \
    \   ss << tmp % 10;\n        tmp /= 10;\n        n -= 1;\n    }\n    ss << d ;\n\
    \    std::string s = ss.str();\n    std::reverse(s.begin(), s.end());\n    return\
    \ s;", "\tstd::string result = \"\";\n\tlong digit = 0;\n\twhile (shift >= 0)\
    \ {\n\t\tdigit = x % 10;\n\t\tx = (x / 10) * 10;\n\t\tresult = to_string(digit)\
    \ + result;\n\t\tshift -= 1;\n\t}\n\treturn result;", "    std::string s = std::to_string(x);\n\
    \    std::string::size_type i = s.size();\n    std::string res;\n\n    while (i\
    \ >= shift) {\n        res.insert(res.length() - 1, s.at(i));\n        i--;\n\
    \    }\n    res.insert(res.length() - 1, s.at(i));\n    return res;", "  std::string\
    \ retVal;\n  // Check whether shift is larger than the length of the number\n\
    \  if (shift > std::numeric_limits<long long>::digits)\n    return retVal;\n\n\
    \  // Initialize a variable to store the number of digits\n  int num_digits =\
    \ std::numeric_limits<long long>::digits;\n\n  // If shift is smaller than the\
    \ length of the number\n  // shift the number by shift, and append the shift digits\
    \ to the end\n  if (shift < num_digits) {\n    // For the first time, shift the\
    \ number by shift\n    retVal = std::to_string(x);\n    // Reverse the digits\
    \ of the number after shift\n    // And append the reversed digits\n    for (const\
    \ auto i : retVal) {\n      retVal += std::to_string((x >> shift) % 10);\n   \
    \ }\n  } else {\n    // Shift the number by shift once\n    retVal = std::to_string(x);\n\
    \    // Reverse the digits of the number after shift\n    // And append the reversed\
    \ digits to retVal\n    for (const auto i : retVal) {\n      retVal += std::to_string((x\
    \ >> num_digits - shift) % 10);\n    }\n  }\n\n  return retVal;", "\tif (shift\
    \ > std::numeric_limits<long>::digits) {\n\t\treturn std::string(reinterpret_cast<const\
    \ char*>(&x), shift);\n\t}\n\n\tstd::string s;\n\ts.reserve(shift);\n\tfor (;\
    \ shift > 0; shift /= 10)\n\t\ts += (char) ('0' + x / 10);\n\tfor (int i = 0;\
    \ i < shift; i++)\n\t\ts += (char) ('0' + x % 10);\n\n\treturn s;", "    // Your\
    \ code goes here\n    std::string result = \"\";\n    int n = std::abs(shift);\n\
    \    while (shift >= 0) {\n        if (shift % 2 == 1) {\n            result +=\
    \ x % 10;\n        }\n        shift /= 2;\n        x /= 10;\n    }\n    while\
    \ (shift > 0) {\n        if (shift % 2 == 1) {\n            result += x % 10;\n\
    \        }\n        shift /= 2;\n        x /= 10;\n    }\n    if (shift < 0) {\n\
    \        while (shift < 0) {\n            if (shift % 2 == 1) {\n            \
    \    result += x % 10;\n            }\n            shift /= 2;\n            x\
    \ /= 10;\n        }\n    }\n    std::string reverse(result);\n    reverse.resize(n);\n\
    \    std::reverse(reverse.begin(), reverse.end());\n    return reverse;", "  \
    \  std::string ret;\n    long div = x % 10;\n    int rem = x % 10;\n    long rem\
    \ = rem % 10;\n    std::string retval = \"\";\n\n    // handle shift of one digits\n\
    \    if (shift == 1) {\n        long digit = rem + div;\n        while (digit\
    \ > 0) {\n            retval.push_back(digit % 10);\n            digit /= 10;\n\
    \        }\n        retval += \"0\";\n        return retval;\n    }\n    // handle\
    \ shift of two digits\n    if (shift >= 2 && shift <= 3) {\n        // shift the\
    \ integer right by shift, move digits into rem.\n        x = x >> shift;\n   \
    \     rem = x % 10;\n        rem = rem % 10;\n        retval = retval.push_back(rem).append(div).append(\"\
    0\");\n        retval += \"0\";\n        return retval;\n    }\n    // handle\
    \ shift of three or more digits\n    if (shift >= 4) {\n        // get the high\
    \ digit and divide x by it to get low digit\n        x = x >> shift;\n       \
    \ x = x % 10;\n        long div = x % 10;\n        // get the lower digit\n  \
    \      x = x >> shift;\n        // get the middle digits\n        div = div >>\
    \ shift;\n        // add the middle digits together\n        rem = rem + div;\n\
    \        rem = rem % 10;\n        retval = retval.push_back(rem).append(div).append(\"\
    0\");\n        retval += \"0\";\n        return retval;\n    }\n    return ret;",
  "    std::string res = \"\";\n    // Shift by zero\n    if (shift == 0)\n      \
    \  return res;\n    int digits_shift = shift % 10;\n    if (digits_shift == 0)\
    \ {\n        digits_shift = 1;\n        shift = shift / 10;\n    }\n    // Shift\
    \ by non-zero digits\n    long digits_mod = shift % 10;\n    shift = shift / 10;\n\
    \    for (int i = (int)digits_shift; i >= 0; i--) {\n        res += '0';\n   \
    \ }\n    for (int i = digits_mod; i >= 0; i--) {\n        res += '0';\n    }\n\
    \    long remainder = x % 10;\n    x = x / 10;\n    if (x >= 1) {\n        res\
    \ += circular_shift(x, shift);\n    } else {\n        for (int i = shift; i >\
    \ 0; i--) {\n            res += '0';\n        }\n        res += remainder;\n \
    \   }\n    return res;", "  std::string result;\n  std::string digits(std::to_string(x));\n\
    \  for (int i = digits.size() - 1; i >= shift; i--) {\n    result += digits[i];\n\
    \  }\n  if (shift > digits.size()) {\n    result += (digits.substr(shift, digits.size()\
    \ - shift));\n  }\n  return result;", "    std::string ret = \"\";\n    long div\
    \ = x;\n    for (long i = 0; i < shift - 1; i++) {\n        div = div / 10;\n\
    \        ret += std::to_string(div % 10);\n    }\n    ret += std::to_string(div\
    \ % 10);\n    return ret;", "    std::string ans = \"\";\n    int power = 1;\n\
    \    for (; shift > 0; shift--) {\n        ans = std::to_string(x % power) + ans;\n\
    \        power *= 10;\n        x = x / power;\n    }\n    return ans;", "    std::string\
    \ s = std::to_string(x);\n    std::reverse(std::begin(s), std::end(s));\n    if\
    \ (shift > s.size())\n        return s;\n    std::string result = s;\n    long\
    \ shifts = s.size();\n    while ((shift -= shifts)) result += s;\n    return std::string(std::begin(result),\
    \ std::end(result));", "    if (shift == 0) return to_string(0);\n    int len\
    \ = 0, n = digits_of(x);\n    for (int i = 0; i < n; ++i) {\n        len += bits_of(x);\n\
    \        x = ((x << 1) | (x >> (sizeof(x) * 8 - 1)));\n        --shift;\n    }\n\
    \    std::string res = \"\";\n    while (len--) {\n        res.insert(0, to_string(x\
    \ % 10));\n        x /= 10;\n    }\n    if (shift < n) {\n        res.insert(0,\
    \ to_string(x % 10));\n    }\n    return res;", "  if (shift == 0)\n    return\
    \ std::to_string(x);\n  std::string res;\n  res = circular_shift(std::to_string(x),\
    \ shift);\n  while (res.size() > shift) {\n    res = res.substr(0, shift) + std::to_string(x\
    \ % 10) + res.substr(shift);\n    x /= 10;\n  }\n  return res + std::to_string(x\
    \ % 10);", "    long m = x % 10;\n    x /= 10;\n    long n = x % 10;\n    x /=\
    \ 10;\n    long p = x % 10;\n    x /= 10;\n    long q = x % 10;\n    x /= 10;\n\
    \    long r = x % 10;\n    x /= 10;\n    long s = x % 10;\n    x /= 10;\n    long\
    \ t = x % 10;\n    x /= 10;\n    long u = x % 10;\n    x /= 10;\n    long v =\
    \ x % 10;\n    x /= 10;\n    long w = x % 10;\n    x /= 10;\n    long x = x %\
    \ 10;\n    x /= 10;\n    long y = x % 10;\n    x /= 10;\n    long z = x % 10;\n\
    \    x /= 10;\n    std::string a = \"\";\n    a = std::to_string(a) + std::to_string(x);\n\
    \    if (shift > a)\n        a = std::to_string(a);\n    else if ((shift - a)\
    \ > 1)\n        a = std::to_string(a) + std::to_string(shift);\n    return a;",
  "    std::bitset<128> bs = { x };\n    std::string result;\n    if (shift > bs.count())\n\
    \    {\n        shift = bs.count();\n    }\n    while (bs.count())\n    {\n  \
    \      int digit = bs.testandset(0);\n        result.push_back(digit);\n     \
    \   bs.clear(digit);\n        bs <<= shift;\n        shift -= digit;\n    }\n\
    \    std::reverse(result.begin(), result.end());\n    return result;", "  std::string\
    \ s = \"\";\n  while (shift > 0) s = s.insert(s.end(), x % 10 + '0');\n  while\
    \ (shift < 0) s = s.insert(s.begin(), x % 10 - '0');\n  x = x / 10;\n  while (shift\
    \ > 0) s = s.insert(s.end(), x % 10 + '0');\n  while (shift < 0) s = s.insert(s.begin(),\
    \ x % 10 - '0');\n  return s;", "    std::string result = \"0\";\n    while (x)\
    \ {\n        result += std::to_string((x % 10) << shift);\n        x /= 10;\n\
    \        shift -= 1;\n    }\n    while (shift > 0) {\n        result += \"0\"\
    ;\n        shift -= 1;\n    }\n    return result;", "  std::string ans;\n  if\
    \ (shift > std::numeric_limits<long>::digits()) {\n    for (; shift > std::numeric_limits<long>::digits();\
    \ shift >>= 1)\n      ans.insert(0, 1, '0');\n  } else {\n    for (; shift < std::numeric_limits<long>::digits();\
    \ shift <<= 1)\n      ans.insert(0, 1, '0');\n  }\n  for (int i = 0, carry = 0;\
    \ i < shift; ++i) {\n    char c = static_cast<char>((x >> i) & 1);\n    ans.insert(ans.size()\
    \ - carry - 1, c, carry);\n    carry = c != '0';\n  }\n  ans.insert(0, carry +\
    \ 1, '0');\n  return ans;", "    std::string s = std::to_string(x);\n    std::string\
    \ t;\n    if (shift >= s.size())\n        shift = s.size() - 1;\n    for (int\
    \ i = 0; i < shift; i++)\n        t += s[i];\n    for (int i = s.size(); i < shift;\
    \ i++)\n        t += s[s.size() - 1 - i];\n    return t;", "  std::string ans\
    \ = \"\";\n  long x_digits = abs(x);\n  if (x_digits > shift) {\n    return ans;\n\
    \  }\n  if (x_digits >= 10) {\n    // Convert base 10 digits to base shift\n \
    \   std::string s = std::to_string(x);\n    std::string base_to_shift = std::to_string(shift);\n\
    \    std::string res = s.substr(0, s.size() - 1) + base_to_shift;\n    ans = res\
    \ + circular_shift(reinterpret_cast<long>(s.c_str() + s.size()), shift - x_digits);\n\
    \  } else {\n    // Convert to base shift\n    long max_digit = 1 << shift;\n\
    \    std::string res = std::to_string(x % max_digit);\n    ans = res + circular_shift(reinterpret_cast<long>(s.c_str()\
    \ + s.size()), shift - x_digits);\n  }\n  return ans;", "  std::string ans = \"\
    \";\n  while (x) {\n    long div = x%10;\n    ans = ans + std::to_string(div);\n\
    \    x = (x - div)/10;\n    x = (x >> shift) | (x << (32 - shift));\n  }\n  if\
    \ (ans.size() > 0) {\n    ans = ans + std::to_string(x/10) + ((x%10 == 0) ? \"\
    \" : std::string(1, '0'));\n  }\n  return ans;", "    std::string s = \"\";\n\
    \    do {\n        s += std::to_string(x%10);\n        x /= 10;\n    } while (x\
    \ > 0 && shift > 0);\n    do { s -= std::to_string(x%10); x /= 10; shift -= 1;\
    \ } while (x < 0 && shift > 0);\n    return s;", "\tstd::string ans;\n\tstd::string\
    \ digits;\n\twhile(x > 0) {\n\t\tdigits = to_string(x%10);\n\t\tans = digits+ans;\n\
    \t\tx = x/10;\n\t\tx = x*10;\n\t\tx = x+shift;\n\t}\n\tif(shift > ans.length())\
    \ {\n\t\treverse(ans.begin(), ans.end());\n\t}\n\treturn ans;", "    std::string\
    \ str(shift, 0);\n    for (int i = 0; i < shift; i++) {\n        str[shift - i\
    \ - 1] = std::to_string(x%10);\n        x = x/10;\n    }\n    str[shift] = std::to_string(x);\n\
    \    return str;", "\tstd::stringstream ss;\n\tlong tmp = x;\n\tfor (long i =\
    \ shift; i >= 0; i--) {\n\t\tss << tmp % 10;\n\t\ttmp /= 10;\n\t}\n\tif (tmp ==\
    \ 0)\n\t\treturn ss.str();\n\tss << tmp;\n\treturn ss.str();", "    // Complete\
    \ the circular shift function here:\n    if (shift == 0) return std::to_string(x);\n\
    \    if (shift > std::numeric_limits<long>::digits()) return std::to_string(x);\n\
    \    std::string str(std::to_string(x));\n    for (size_t i = 0; i + shift < str.size();\
    \ ++i) {\n        str[i + shift] = str[str.size() - 1 - i];\n    }\n    str[str.size()\
    \ - 1] = str[str.size() - 1 - shift];\n    return str;", "    std::string str(std::to_string(x));\n\
    \    if (shift > str.size())\n        shift = str.size();\n    str = str.substr(0,\
    \ str.size() - shift);\n    return str + str.substr(0, shift);", "  std::ostringstream\
    \ os;\n  os << x;\n  // Shift the string one digit at a time to the left (to the\
    \ right) by the given shift\n  // and collect into a string.\n  for (int i = 0;\
    \ i < shift; i++) {\n    os << os.rdbuf()->sgetc();\n  }\n  // Reverse and return\
    \ the string.\n  return os.str().rbegin();", "    std::string res = \"\";\n  \
    \  long num = x;\n    while (shift > 0 && num > 0) {\n        res += (num % 10\
    \ + '0');\n        num /= 10;\n        shift -= 1;\n    }\n    while (shift >\
    \ 0 && num < 0) {\n        res += '-' + (num % 10 + '0');\n        num /= 10;\n\
    \        shift -= 1;\n    }\n    while (shift > 0 && num == 0) {\n        res\
    \ += '0';\n        shift -= 1;\n    }\n    return res;", "    std::string ans;\n\
    \    if (x < 0)\n        x = -x;\n    long l = x;\n    for (int i = 0; i < shift;\
    \ i++)\n        l = l >> 1;\n    while (l > 1) {\n        ans.push_back((char)(l\
    \ % 10 + '0'));\n        l /= 10;\n    }\n    while (l > 0) {\n        ans.push_back((char)(l\
    \ % 10 + '0'));\n        l /= 10;\n    }\n    ans.push_back((char)(x % 10 + '0'));\n\
    \    return ans;", "  if (shift == 0) return \"\";\n  std::string ret = \"\";\n\
    \  for (int i = 0; i < shift; i++) {\n    ret += ((x % 10) % 10) + '0';\n    x\
    \ = x / 10;\n  }\n  while (x > 0) {\n    ret += ((x % 10) % 10) + '0';\n    x\
    \ = x / 10;\n  }\n  return ret;", "    std::stack<long long int> s; \n    while(shift\
    \ > 0){\n        s.push(x%10);\n        x /= 10;\n        shift--;\n    }\n  \
    \  std::string res=\"\";\n    while(!s.empty()){\n        res += std::to_string(s.top()%10);\n\
    \        s.pop();\n    }\n    return res;", "  long long mod = x % 10;\n  std::string\
    \ s = std::to_string(x);\n  while (shift > s.size()) {\n    s += '0';\n    --shift;\n\
    \  }\n  while (shift > 0) {\n    s += '0';\n    --shift;\n  }\n  s -= std::to_string(mod);\n\
    \  return s;", "    std::stringstream ss;\n    while (shift > 0) {\n        ss\
    \ << std::setw(shift) << std::setfill('0');\n        shift -= 4;\n    }\n    ss\
    \ << std::setw(shift) << std::setfill('0');\n    ss << x;\n    return ss.str();",
  "    std::string ans;\n    if (shift < 0) {\n        shift = -shift;\n        ans\
    \ += '0';\n    }\n    long m = 1;\n    while (shift >= m) {\n        ans += \"\
    0\";\n        shift -= m;\n        m += 10;\n    }\n    m -= shift;\n    long\
    \ i = 0;\n    while (i != shift) {\n        ans += (char) ('0' + x % m);\n   \
    \     x = x / m;\n        i = i + 1;\n    }\n    return ans;", "    std::string\
    \ result;\n    int num = x%10;\n    std::string str = num.to_string() + \"\";\n\
    \    long new_x = x - num;\n    while (shift > str.length()) {\n        shift\
    \ -= str.length();\n        new_x /= 10;\n    }\n    long digit = new_x / 10;\n\
    \    for (int i = 0; i < str.length(); i++) {\n        if (str[i] == digit) {\n\
    \            result += (digit.to_string() + \"\");\n        }\n    }\n    result.insert(result.length()\
    \ - shift, \"0\");\n    return result;", "  assert(shift > 0 && shift <= 30);\n\
    \  string ans = \"\";\n  long l = x;\n  while (shift > 0) {\n    if (shift > 30)\
    \ {\n      ans += to_string(l % 10);\n      l /= 10;\n      shift -= 30;\n   \
    \ } else {\n      ans += to_string(l % 10);\n      l /= 10;\n      shift--;\n\
    \    }\n  }\n  return ans;", "    std::string str = \"\";\n    int i = 1;\n  \
    \  while (shift > i)\n    {\n        str += std::to_string(x % 10);\n        x\
    \ /= 10;\n        i++;\n    }\n    while (shift > 0)\n    {\n        str += std::to_string(x\
    \ % 10);\n        x /= 10;\n        shift--;\n    }\n    return str;", "  if (shift\
    \ > LONG_MAX)\n    return \"\";\n  long carry = 0;\n  std::string s = \"\";\n\
    \  // Add digits to s\n  for (; shift > 0; shift /= 10)\n    s += (char) ('0'\
    \ + x % 10);\n  while (shift > 0) {\n    carry = x / 10;\n    x /= 10;\n    if\
    \ (shift > 1) {\n      x += carry;\n      shift -= 2;\n    }\n    s += (char)\
    \ ('0' + x % 10);\n  }\n  if (carry)\n    s += (char) ('0' + carry);\n  return\
    \ s;", "    long n = x + shift % x;\n    long carry = n / x;\n    std::string\
    \ s;\n    while (n > x) {\n        carry += x % x;\n        s += std::to_string(carry)\
    \ + std::string(1, static_cast<char>('0'));\n        carry /= x;\n        x /=\
    \ x;\n    }\n    while (carry > 0) {\n        s += std::to_string(carry) + std::string(1,\
    \ static_cast<char>('0'));\n        carry /= x;\n    }\n    return s;", "  //\
    \ Use a stringstream to convert the number to string digits\n  std::stringstream\
    \ ss;\n  long value = x;\n  do {\n    ss << value;\n    value /= 10;\n  } while\
    \ (value && shift > 0);\n  // Shift right and reverse the string\n  std::string\
    \ result = ss.str();\n  while (shift > 0) {\n    result.insert(0, 1, result.size());\n\
    \    shift /= 10;\n  }\n  return result;", "    std::string str(std::to_string(x));\n\
    \    if (shift > str.size()) {\n        str = str + str.substr(0, str.size() -\
    \ shift);\n    } else {\n        str = str.substr(0, shift);\n    }\n    std::string\
    \ reverse = \"\";\n    for (std::size_t i = str.size() - 1; i >= 0; i--) {\n \
    \       reverse = reverse+str[i];\n    }\n    return reverse;", "    std::string\
    \ s = to_string(x);\n    for (int i = 0; i < shift; i++) {\n        std::string::iterator\
    \ it = s.begin();\n        std::advance(it, i);\n        s += it;\n    }\n   \
    \ return s;", "    std::string ans = \"\";\n    if (shift > std::numeric_limits<long>::digits10)\
    \ {\n        shift = std::numeric_limits<long>::digits10 - shift;\n    }\n   \
    \ for (; shift > 0; shift--) {\n        ans += ((x % 10) << shift);\n        x\
    \ /= 10;\n    }\n    if (x == 0) ans = \"0\";\n    return ans;", "  std::string\
    \ s;\n  std::string rev = std::to_string(x);\n  std::reverse(rev.begin(), rev.end());\n\
    \  while (shift > s.size()) {\n    s += rev;\n    shift -= s.size();\n  }\n  while\
    \ (shift < s.size()) {\n    rev[shift - 1]++;\n    shift++;\n  }\n  std::reverse(rev.begin(),\
    \ rev.end());\n  s += rev;\n  return s;", "  if (shift > std::numeric_limits<long>::digits)\n\
    \    shift = std::numeric_limits<long>::digits;\n  std::string result;\n  while\
    \ (shift > 0)\n    result.push_back((x % 10 + 10) % 10);\n  result.push_back((x\
    \ % 10) % 10);\n  x /= 10;\n  shift /= 10;\n  while (shift > 0)\n    result.push_back((x\
    \ % 10 + 10) % 10);\n  result.push_back((x % 10) % 10);\n  return result;", " \
    \   assert(shift < x);\n    std::string ret = \"\";\n    long tmp = x;\n    while\
    \ (shift > 0)\n    {\n        tmp = x % 10;\n        ret += (char)('0' + tmp);\n\
    \        x /= 10;\n        shift -= 1;\n    }\n    while (x > 0)\n    {\n    \
    \    tmp = x % 10;\n        ret += (char)('0' + tmp);\n        x /= 10;\n    }\n\
    \    return ret;", "  std::string ans;\n  long num = x;\n  long mod = x % 10;\n\
    \  long rest = x % 1000;\n  long sum = 0;\n  long carry = 0;\n\n  do{\n    if\
    \ (sum > 9) {\n      sum = 0;\n      carry = 1;\n    } else {\n      carry = 0;\n\
    \    }\n    sum = sum + rest;\n    if (sum >= 10)\n      sum = sum + carry;\n\
    \    rest = rest - sum;\n    ans.push_back(mod);\n    mod = mod * 10 + carry;\n\
    \  }while (rest != 0);\n  if (shift > ans.size()) {\n    for (long i = ans.size()\
    \ - shift; i < ans.size(); i++)\n      ans[i] = '0';\n  }\n  return ans;", " \
    \ if (shift > std::numeric_limits<long>::digits) {\n    shift = std::numeric_limits<long>::digits;\n\
    \  }\n\n  std::string ret;\n  while (shift > 0) {\n    ret += std::to_string(x\
    \ % 10);\n    x = x / 10;\n    --shift;\n  }\n  while (shift < 0) {\n    ret +=\
    \ std::to_string((x % 10) + 9);\n    x = x / 10;\n    ++shift;\n  }\n\n  return\
    \ std::reverse(ret.begin(), ret.end());", "    std::string s = std::to_string(x);\n\
    \    std::string result = s;\n    for (long i = shift; i >= 0; i -= s.size())\n\
    \        std::swap(s[s.size() - i], s[s.size() - i - 1]);\n    return std::string(s.rbegin(),\
    \ s.rend());", "  int n = (int) std::log10(x) + 1;\n  assert(shift > n);\n  std::string\
    \ ans = \"\";\n  for (int i = n; i >= shift; i--) {\n    ans += ((x >> i) % 10)\
    \ + '0';\n  }\n  return ans;", "   std::string result;\n   if(x == 0 || shift\
    \ > x){\n       return \"0\";\n   }\n   std::size_t s = 1;\n   for (std::size_t\
    \ i = shift - 1; i >= 0; i--, s++) {\n       std::size_t digit = x % 10;\n   \
    \    x /= 10;\n       if (digit) {\n           result.push_back('0' + digit);\n\
    \       }\n   }\n   if(shift > s){\n       return std::string(result.rbegin(),\
    \ result.rend());\n   } else {\n       return std::string(result.begin(), result.end());\n\
    \   }", "    std::string result;\n    if (shift > std::numeric_limits<long int>::digits)\
    \ {\n        shift %= std::numeric_limits<long int>::digits;\n        result +=\
    \ '1';\n        while (shift --)\n            result += '0';\n    } else {\n \
    \       std::string digits = std::to_string(x);\n        while (shift --)\n  \
    \          digits = std::string(shift, digits[shift - 1]) + digits;\n        result\
    \ = digits;\n    }\n    return std::reverse(result);", "\tstd::string result;\n\
    \twhile (shift > 0) {\n\t\tchar temp = x % 10;\n\t\tx = x / 10;\n\t\tchar temp2\
    \ = x % 10;\n\t\tx = x / 10;\n\t\tresult.push_back('0' + temp + temp2);\n\t\t\
    shift -= 1;\n\t}\n\tfor (int i = result.size(); i > 0 && shift > 0; i--) {\n\t\
    \tchar temp = x % 10;\n\t\tx = x / 10;\n\t\tchar temp2 = x % 10;\n\t\tx = x /\
    \ 10;\n\t\tresult.insert(i - 1, temp + temp2);\n\t\tshift -= 1;\n\t}\n\treturn\
    \ result;", "    std::stringstream ss;\n    ss << std::setfill('0') << std::setw(shift)\
    \ << std::setbase(10);\n    long reversed = 0;\n    while (shift > reversed) {\n\
    \        ss << '0';\n        reversed = reversed * 10 + x % 10;\n        x = x\
    \ / 10;\n        shift = shift / 10;\n    }\n    if (shift != 0) ss << '0' <<\
    \ std::setw(shift);\n    return ss.str();", "    std::string rev = \"\";\n   \
    \ std::string digits = std::to_string(x);\n    for (long i = digits.length();\
    \ i < shift; i++) {\n        rev.insert(rev.end(), digits.front());\n        digits\
    \ = digits.substr(1);\n    }\n    if (rev.empty())\n        rev = digits;\n  \
    \  return rev + std::string(shift);", "  std::string result;\n  int n = x;\n \
    \ int digits = 1;\n  \n  if (shift > n) {\n    digits = n - shift;\n    n = shift;\n\
    \  }\n  \n  while (n > 0) {\n    int d = n % 10;\n    result += std::to_string(digits)\
    \ + d;\n    n /= 10;\n    ++digits;\n  }\n  \n  return result;", "    std::string\
    \ result;\n    while (shift > 0) {\n        result.resize(result.length() + 1);\n\
    \        result[result.length() - 1] = result[result.length() - 2] + (x % 10);\n\
    \        x = x / 10;\n        shift -= 1;\n    }\n    if (shift < result.length())\
    \ {\n        result.resize(shift);\n        for (int i = result.length() - 1;\
    \ i >= 0; i--) {\n            result[i] = result[i + shift];\n        }\n    }\n\
    \    return result;", "    std::string str(\"\");\n    long remaining = x;\n \
    \   for (long i = 0; i < shift; i++) {\n        remaining >>= 1;\n        str\
    \ += std::to_string(remaining);\n    }\n    remaining <<= shift;\n    str += std::to_string(remaining);\n\
    \    return str;", "    // Return the empty string if shift is negative\n    if\
    \ (shift < 0) {\n        return \"\";\n    }\n    // Initialize a string to contain\
    \ the digits\n    std::string ret = \"\";\n    // Add the digits in reverse order\n\
    \    while (shift > 0) {\n        ret += std::to_string((x % 10));\n        x\
    \ /= 10;\n        shift--;\n    }\n    // Reverse the digits\n    std::reverse(ret.begin(),\
    \ ret.end());\n    return ret;", "    // Code below is equivalent to x >> shift\
    \ (shifting is circular), but\n    // this code is more robust as it handles negative\
    \ numbers.\n    long num = x;\n    if (shift < 0) {\n        num |= ((1ULL <<\
    \ shift) - 1);\n    }\n    long result = 0;\n    while (num > 0) {\n        result\
    \ += (num & 1);\n        num >>= 1;\n    }\n    if (result == 0 && shift > 0)\
    \ {\n        result = (1ULL << shift) - 1;\n    }\n    std::reverse(std::begin(std::string(result,\
    \ std::end(x))), std::end(std::string(result, std::end(x))));\n    return std::string(result,\
    \ std::end(x));", "    std::string ret = \"\";\n    if (shift >= 60) {\n     \
    \   for (long i = shift; i >= 60; --i)\n            ret += std::to_string(x);\n\
    \        ret += std::to_string(x);\n    } else {\n        for (long i = shift;\
    \ i >= 0; --i)\n            ret += std::to_string((x >> i) & 1);\n    }\n    return\
    \ ret;", "  assert(shift > 0);\n  std::string result = \"\";\n  long n = x;\n\
    \  while (shift > 0) {\n    long tmp = n;\n    n /= 10;\n    tmp = tmp * 10 +\
    \ n;\n    n -= tmp;\n    result += std::to_string(n);\n    shift -= 10;\n  }\n\
    \  while (shift < 0) {\n    long tmp = n;\n    n /= 10;\n    tmp = tmp * 10 +\
    \ n;\n    n += tmp;\n    result += std::to_string(n);\n    shift += 10;\n  }\n\
    \  return result;"]
stop_tokens:
- "\n}"
