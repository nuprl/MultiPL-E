language: cpp
name: HumanEval_117_select_words
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    if (s.empty())\n        return res;\n    \n    auto first = s.begin();\n\
    \    auto last = s.end();\n    \n    auto first_vowels = [&first] { auto it =\
    \ first; while (it != last && !isalpha(*it)) { ++it; }; return it; };\n    auto\
    \ vowels = [&first] { auto it = first; while (it != last && !isspace(*it)) { ++it;\
    \ }; return it; };\n    \n    auto first_consonants = [&first] { auto it = first;\
    \ while (it != last && !isalpha(*it)) { ++it; }; return it; };\n    auto consonants\
    \ = [&first] { auto it = first; while (it != last && !isspace(*it)) { ++it; };\
    \ return it; };\n    \n    auto first_digits = [&first] { auto it = first; while\
    \ (it != last && !isdigit(*it)) { ++it; }; return it; };\n    auto digits = [&first]\
    \ { auto it = first; while (it != last && !isspace(*it)) { ++it; }; return it;\
    \ };\n    \n    auto first_space = [&first] { auto it = first; while (it != last\
    \ && !isspace(*it)) { ++it; }; return it; };\n    auto space = [&first] { auto\
    \ it = first; while (it != last && !isspace(*it)) { ++it; }; return it; };\n \
    \   \n    auto first_punctuation = [&first] { auto it = first; while (it != last\
    \ && !ispunct(*it)) { ++it; }; return it; };\n    auto punctuation = [&first]\
    \ { auto it = first; while (it != last && !ispunct(*it)) { ++it; }; return it;\
    \ };\n    \n    auto first_letters = [&first] { auto it = first; while (it !=\
    \ last && !isalpha(*it)) { ++it; }; return it; };\n    auto letters = [&first]\
    \ { auto it = first; while (it != last && !isspace(*it)) { ++it; }; return it;\
    \ };\n    \n    std::vector<char> v;\n    v.push_back(*first);\n    \n    for\
    \ (auto it = first; it != last; ++it) {\n        if (!isalpha(*it) && !isspace(*it)\
    \ && !ispunct(*it)) {\n            v.push_back(*it);\n        }\n    }\n    \n\
    \    std::string tmp;\n    \n    for (auto it = first; it != last; ++it) {\n \
    \       if (!isalpha(*it) && !\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq8f_s2_2.cpp: In lambda function:\n/tmp/tmpq8f_s2_2.cpp:27:66:\
    \ error: \u2018last\u2019 is not captured\n   27 |     auto first_vowels = [&first]\
    \ { auto it = first; while (it != last && !isalpha(*it)) { ++it; }; return it;\
    \ };\n      |                                                                \
    \  ^~~~\n/tmp/tmpq8f_s2_2.cpp:27:32: note: the lambda has no capture-default\n\
    \   27 |     auto first_vowels = [&first] { auto it = first; while (it != last\
    \ && !isalpha(*it)) { ++it; }; return it; };\n      |                        \
    \        ^\n/tmp/tmpq8f_s2_2.cpp:25:10: note: \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > last\u2019 declared here\n   25 |     auto\
    \ last = s.end();\n      |          ^~~~\n/tmp/tmpq8f_s2_2.cpp: In lambda function:\n\
    /tmp/tmpq8f_s2_2.cpp:28:60: error: \u2018last\u2019 is not captured\n   28 | \
    \    auto vowels = [&first] { auto it = first; while (it != last && !isspace(*it))\
    \ { ++it; }; return it; };\n      |                                          \
    \                  ^~~~\n/tmp/tmpq8f_s2_2.cpp:28:26: note: the lambda has no capture-default\n\
    \   28 |     auto vowels = [&first] { auto it = first; while (it != last && !isspace(*it))\
    \ { ++it; }; return it; };\n      |                          ^\n/tmp/tmpq8f_s2_2.cpp:25:10:\
    \ note: \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > last\u2019 declared here\n   25 |     auto last = s.end();\n      |      \
    \    ^~~~\n/tmp/tmpq8f_s2_2.cpp: In lambda function:\n/tmp/tmpq8f_s2_2.cpp:30:70:\
    \ error: \u2018last\u2019 is not captured\n   30 |     auto first_consonants =\
    \ [&first] { auto it = first; while (it != last && !isalpha(*it)) { ++it; }; return\
    \ it; };\n      |                                                            \
    \          ^~~~\n/tmp/tmpq8f_s2_2.cpp:30:36: note: the lambda has no capture-default\n\
    \   30 |     auto first_consonants = [&first] { auto it = first; while (it !=\
    \ last && !isalpha(*it)) { ++it; }; return it; };\n      |                   \
    \                 ^\n/tmp/tmpq8f_s2_2.cpp:25:10: note: \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::"
  stdout: ''
  timestamp: 1660141057
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  if(s.size() == 0)\n    return v;\n  for(long i = 0; i < s.size(); i++)\
    \ {\n    if(s.at(i) == ' ')\n      continue;\n    for(long j = 0; j < n; j++)\
    \ {\n      if(s.at(i) == s.at(i + (j+1)))\n        v.emplace_back(s.substr(0,\
    \ i));\n    }\n  }\n  return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::at: __n (which is 22) >= this->size() (which is 22)\n"
  stdout: ''
  timestamp: 1660141058
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ result;\n  \n  \n  // Your code here\n  for (int i=0; i< s.length(); i++) {\n\
    \    std::string current = s[i];\n    bool found = false;\n    \n    for (int\
    \ j=0; j<current.length(); j++) {\n      if (current.at(j) != 'a' && current.at(j)\
    \ != 'e' && current.at(j) != 'i'\n        && current.at(j) != 'o' && current.at(j)\
    \ != 'u' && current.at(j) != 'y') {\n        found = true;\n        break;\n \
    \     }\n    }\n    \n    if (!found) {\n      result.push_back(current);\n  \
    \  }\n  }\n  \n  if (result.size() == 0) return result;\n  \n  if (n<result.size())\
    \ return result;\n  else return result;\n}\nint main() {\n    auto candidate =\
    \ select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbkx2w4bs.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpbkx2w4bs.cpp:25:30: error:\
    \ conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} requested\n   25 |     std::string current\
    \ = s[i];\n      |                              ^\n"
  stdout: ''
  timestamp: 1660141057
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    // Write your code here\n    return res;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpwgprw7p3: /tmp/tmpwgprw7p3.cpp:26: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    \n    std::vector<std::string>\
    \ res;\n    // Write your code here\n    // std::unordered_map<std::string,int>\
    \ vowels;\n    \n    // for(auto &it: s)\n    // {\n    //     if(isspace(it))\n\
    \    //     {\n    //         continue;\n    //     }\n    //     if(isalpha(it))\n\
    \    //     {\n    //         if(it.find_first_of('a') == 0 || it.find_first_of('e')\
    \ == 0 || it.find_first_of('i') == 0 || it.find_first_of('o') == 0 || it.find_first_of('u')\
    \ == 0)\n    //         {\n    //             if(vowels.find(it) != vowels.end())\n\
    \    //             {\n    //                 continue;\n    //             }\n\
    \    //             else\n    //             {\n    //                 if(vowels.size()\
    \ == 0)\n    //                 {\n    //                     res.push_back(it);\n\
    \    //                 }\n    //                 else\n    //               \
    \  {\n    //                     res.push_back(it);\n    //                  \
    \   vowels.insert(it);\n    //                 }\n    //             }\n    //\
    \         }\n    //         else if(it.find_first_of('a') == 0 || it.find_first_of('e')\
    \ == 0 || it.find_first_of('i') == 0 || it.find_first_of('o') == 0 || it.find_first_of('u')\
    \ == 0)\n    //         {\n    //             if(vowels.find(it) != vowels.end())\n\
    \    //             {\n    //                 continue;\n    //             }\n\
    \    //             else\n    //             {\n    //                 if(vowels.size()\
    \ == 0)\n    //                 {\n    //                     res.push_back(it);\n\
    \    //                 }\n    //                 else\n    //               \
    \  {\n    //                     res.push_back(it);\n    //                 }\n\
    \    //             }\n    //         }\n    //         else\n    //         {\n\
    \    //             if(vowels.find(it) != vowels.end())\n    //             {\n\
    \    //                 continue;\n    //             }\n    //             else\n\
    \    //             {\n    //                 if(vowels.size() == 0)\n    // \
    \                {\n    //                     res.push_back(it);\n    //    \
    \             }\n    //                 else\n    //                 {\n    //\
    \                     res.push_back(it);\n    //                 }\n    //   \
    \          }\n    //         }\n    //     }\n    // }\n    \n    if(!s.empty())\n\
    \    {\n        \n        \n    }\n    \n    return res;\n}\nint main() {\n  \
    \  auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpdenlj2yv: /tmp/tmpdenlj2yv.cpp:101: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    for (size_t i = 0; i != s.length(); ++i) {\n        if (s.at(i) == '\
    \ ') continue;\n        if (s.at(i) == ' '){\n            v.emplace_back(s.substr(0,i+1));\n\
    \            if (i == s.length()-1) {\n                v.emplace_back(s.substr(0,i+1));\n\
    \            }\n            continue;\n        }\n        if (s.at(i) == '-')\
    \ {\n            v.emplace_back(s.substr(0,i+1));\n            if (i == s.length()-1)\
    \ {\n                v.emplace_back(s.substr(0,i+1));\n            }\n       \
    \     continue;\n        }\n        if (s.at(i) == '[') {\n            v.emplace_back(s.substr(0,i+1));\n\
    \            if (i == s.length()-1) {\n                v.emplace_back(s.substr(0,i+1));\n\
    \            }\n            continue;\n        }\n        if (s.at(i) == ']')\
    \ {\n            v.emplace_back(s.substr(0,i+1));\n            if (i == s.length()-1)\
    \ {\n                v.emplace_back(s.substr(0,i+1));\n            }\n       \
    \     continue;\n        }\n        if (s.at(i) == '.') {\n            v.emplace_back(s.substr(0,i+1));\n\
    \            if (i == s.length()-1) {\n                v.emplace_back(s.substr(0,i+1));\n\
    \            }\n            continue;\n        }\n        if (s.at(i) == '(')\
    \ {\n            v.emplace_back(s.substr(0,i+1));\n            if (i == s.length()-1)\
    \ {\n                v.emplace_back(s.substr(0,i+1));\n            }\n       \
    \     continue;\n        }\n        if (s.at(i) == ')') {\n            v.emplace_back(s.substr(0,i+1));\n\
    \            if (i == s.length()-1) {\n                v.emplace_back(s.substr(0,i+1));\n\
    \            }\n            continue;\n        }\n        v.emplace_back(s.substr(0,i+1));\n\
    \        if (i == s.length()-1) {\n            v.emplace_back(s.substr(0,i+1));\n\
    \        }\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp4n8ku8wu: /tmp/tmp4n8ku8wu.cpp:81: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141059
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    if (s.size() == 0)\n        return v;\n    unordered_set<std::string>\
    \ u;\n    unordered_set<std::string> v;\n    // insert all the characters and\
    \ count the number of characters\n    for (char c : s) {\n        u.insert(c);\n\
    \        v.insert(std::to_string(c));\n    }\n    // create all combinations of\
    \ n characters\n    for (long i = 0; i < n; i++) {\n        v.insert(u.begin(),\
    \ u.end());\n    }\n    // create all combinations of n characters\n    for (long\
    \ i = 0; i < s.size(); i++) {\n        for (long j = 0; j < n; j++) {\n      \
    \      if (s[i] == v[j]) {\n                u.erase(s[i]);\n                break;\n\
    \            }\n        }\n        if (u.empty())\n            break;\n    }\n\
    \    // sort and reverse to make the words in order\n    v.insert(v.begin(), v.end());\n\
    \    sort(v.begin(), v.end());\n    v.resize(v.size() - 1);\n    // convert to\
    \ the string vector\n    for (auto it = v.begin(); it != v.end(); ++it)\n    \
    \    v.push_back(*it);\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpocfnfyow.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpocfnfyow.cpp:23:5: error:\
    \ \u2018unordered_set\u2019 was not declared in this scope\n   23 |     unordered_set<std::string>\
    \ u;\n      |     ^~~~~~~~~~~~~\n/tmp/tmpocfnfyow.cpp:23:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/unordered_set:47,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n                 from\
    \ /tmp/tmpocfnfyow.cpp:2:\n/usr/include/c++/9/bits/unordered_set.h:97:11: note:\
    \   \u2018std::unordered_set\u2019\n   97 |     class unordered_set\n      | \
    \          ^~~~~~~~~~~~~\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:118,\n\
    \                 from /tmp/tmpocfnfyow.cpp:2:\n/usr/include/c++/9/unordered_set:68:13:\
    \ note:   \u2018std::pmr::unordered_set\u2019\n   68 |       using unordered_set\n\
    \      |             ^~~~~~~~~~~~~\n/tmp/tmpocfnfyow.cpp:23:30: error: expected\
    \ primary-expression before \u2018>\u2019 token\n   23 |     unordered_set<std::string>\
    \ u;\n      |                              ^\n/tmp/tmpocfnfyow.cpp:23:32: error:\
    \ \u2018u\u2019 was not declared in this scope\n   23 |     unordered_set<std::string>\
    \ u;\n      |                                ^\n/tmp/tmpocfnfyow.cpp:24:30: error:\
    \ expected primary-expression before \u2018>\u2019 token\n   24 |     unordered_set<std::string>\
    \ v;\n      |                              ^\n/tmp/tmpocfnfyow.cpp:28:35: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::insert(std::string)\u2019\n   28 |         v.insert(std::to_string(c));\n\
    \      |                                   ^\nIn file included from /usr/include/c++/9/vector:72,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpocfnfyow.cpp:2:\n/usr/include/c++/9/bits/vector.tcc:130:5:\
    \ no"
  stdout: ''
  timestamp: 1660141057
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.empty())\
    \ {\n        return std::vector<std::string>();\n    }\n\n    // Your code here\n\
    \    std::vector<std::string> words;\n    long size = (long) s.size();\n    long\
    \ c = 0;\n    while (c < (size - n)) {\n        std::string word = s.substr(c,\
    \ n);\n        words.push_back(word);\n        c++;\n    }\n    return words;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp7tbuxua3: /tmp/tmp7tbuxua3.cpp:37: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    int count\
    \ = 0;\n    std::vector<std::string> res;\n    for (int i = 0; i <= s.length();\
    \ i++) {\n        if (s[i] == ' ') {\n            if (count == n) {\n        \
    \        res.push_back(s.substr(0, i + 1));\n            }\n            count\
    \ = 0;\n        } else {\n            count++;\n        }\n    }\n    if (count\
    \ != n) {\n        res.push_back(s.substr(0, s.size() - 1));\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpn0wam3zw: /tmp/tmpn0wam3zw.cpp:39: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (n == 0)\n\
    \        return {};\n    std::vector<std::string> ans;\n    if (s.size() <= n)\
    \ {\n        if (s.empty())\n            return ans;\n        else\n         \
    \   return {s};\n    }\n\n    // for each consonant of the string\n    std::vector<std::string>\
    \ vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n    for (auto c : s) {\n    \
    \    if (c == \" \") {\n            for (int i = 0; i < vowels.size(); i++)\n\
    \                ans.push_back(vowels[i]);\n            return ans;\n        }\n\
    \        bool match = false;\n        for (auto v : vowels) {\n            if\
    \ (v == c) {\n                match = true;\n                break;\n        \
    \    }\n        }\n        if (!match)\n            continue;\n        ans.push_back(c);\n\
    \        ans.push_back(\" \");\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppi5qlnxt.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmppi5qlnxt.cpp:33:18: error:\
    \ ISO C++ forbids comparison between pointer and integer [-fpermissive]\n   33\
    \ |         if (c == \" \") {\n      |                  ^~~\n/tmp/tmppi5qlnxt.cpp:40:19:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   40 |             if (v == c) {\n      |          \
    \       ~ ^~ ~\n      |                 |    |\n      |                 |    char\n\
    \      |                 std::__cxx11::basic_string<char>\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmppi5qlnxt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmppi5qlnxt.cpp:40:22:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   40 |             if (v == c)\
    \ {\n      |                      ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmppi5qlnxt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp"
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    vector<string> temp;\n    int i = 0;\n    while (i < s.size()) {\n \
    \       int j = i + 1;\n        while (j < s.size() && s[j] == s[i]) {\n     \
    \       j++;\n        }\n        if (j - i == n) {\n            temp.emplace_back(s.substr(i,\
    \ j - i));\n            i = j;\n        }\n        else {\n            i = j;\n\
    \        }\n    }\n    if (temp.empty()) return v;\n    v.emplace_back(temp);\n\
    \    return v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjmu4el86.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpjmu4el86.cpp:21:5: error:\
    \ \u2018vector\u2019 was not declared in this scope\n   21 |     vector<string>\
    \ temp;\n      |     ^~~~~~\n/tmp/tmpjmu4el86.cpp:21:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjmu4el86.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjmu4el86.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmpjmu4el86.cpp:21:12:\
    \ error: \u2018string\u2019 was not declared in this scope\n   21 |     vector<string>\
    \ temp;\n      |            ^~~~~~\n/tmp/tmpjmu4el86.cpp:21:12: note: suggested\
    \ alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n       \
    \          from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpjmu4el86.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n "
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  // Write your\
    \ code here\n  assert(!s.empty());\n  std::string temp(s);\n  std::set<std::string>\
    \ res;\n  while (temp.size() > 0) {\n    if (temp.find_first_not_of(\"aeiou\"\
    ) == std::string::npos) {\n      res.insert(temp);\n    }\n    temp.erase(0, temp.find_first_not_of(\"\
    aeiou\") + 1);\n  }\n  std::vector<std::string> ans;\n  std::set_intersection(res.begin(),\
    \ res.end(), s.begin(), s.end(), std::back_inserter(ans));\n  return ans;\n}\n\
    int main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary\
    \ had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n    \
    \             from /usr/include/c++/9/bits/specfun.h:45,\n                 from\
    \ /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpbbkag9o9.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:\
    \ In instantiation of \u2018constexpr bool __gnu_cxx::__ops::_Iter_less_iter::operator()(_Iterator1,\
    \ _Iterator2) const [with _Iterator1 = std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char>\
    \ >; _Iterator2 = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >]\u2019:\n/usr/include/c++/9/bits/stl_algo.h:5258:12:   required from \u2018\
    _OutputIterator std::__set_intersection(_InputIterator1, _InputIterator1, _InputIterator2,\
    \ _InputIterator2, _OutputIterator, _Compare) [with _InputIterator1 = std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char>\
    \ >; _InputIterator2 = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _OutputIterator = std::back_insert_iterator<std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Compare = __gnu_cxx::__ops::_Iter_less_iter]\u2019\n/usr/include/c++/9/bits/stl_algo.h:5313:48:\
    \   required from \u2018_OIter std::set_intersection(_IIter1, _IIter1, _IIter2,\
    \ _IIter2, _OIter) [with _IIter1 = std::_Rb_tree_const_iterator<std::__cxx11::basic_string<char>\
    \ >; _IIter2 = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _OIter = std::back_insert_iterator<std::vector<std::__cxx11::basic_string<char>\
    \ > >]\u2019\n/tmp/tmpbbkag9o9.cpp:31:92:   required from here\n/usr/include/c++/9/bits/predefined_ops.h:43:23:\
    \ error: no match for \u2018operator<\u2019 (operand types are \u2018const std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   43 |       { return *__it1 < *__it2; }\n      |  \
    \              ~~~~~~~^~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_6"
  stdout: ''
  timestamp: 1660141057
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // TODO: Write\
    \ your function here\n}\nint main() {\n    auto candidate = select_words;\n  \
    \  assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp4y7xwhjy: /tmp/tmp4y7xwhjy.cpp:24: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    for(auto &w : s) {\n        if(w.length() == n) {\n            res.push_back(std::move(w));\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu6_k_d0c.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpu6_k_d0c.cpp:22:14: error:\
    \ request for member \u2018length\u2019 in \u2018w\u2019, which is of non-class\
    \ type \u2018char\u2019\n   22 |         if(w.length() == n) {\n      |      \
    \        ^~~~~~\n/tmp/tmpu6_k_d0c.cpp:23:39: error: no matching function for call\
    \ to \u2018std::vector<std::__cxx11::basic_string<char> >::push_back(std::remove_reference<char&>::type)\u2019\
    \n   23 |             res.push_back(std::move(w));\n      |                  \
    \                     ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu6_k_d0c.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::remove_reference<char&>::type\u2019\
    \ {aka \u2018char\u2019} to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits"
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  for(auto it = std::begin(s); *it != ' '; ++it){\n    for(auto it2 = std::begin(s);\
    \ *it2 != ' '; ++it2){\n      if(*it == *it2){\n        v.push_back((std::string(it)\
    \ + std::string(it2)));\n      }\n    }\n  }\n  for(auto it = std::begin(s); *it\
    \ != ' '; ++it){\n    for(auto it2 = std::begin(s); *it2 != ' '; ++it2){\n   \
    \   if(n-- <= 0){\n        break;\n      }\n      if(*it == *it2){\n        v.push_back((std::string(it)\
    \ + std::string(it2)));\n      }\n    }\n  }\n  return v;\n}\nint main() {\n \
    \   auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplpw1fcqy.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmplpw1fcqy.cpp:24:36: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >&)\u2019\n   24 |         v.push_back((std::string(it)\
    \ + std::string(it2)));\n      |                                    ^\nIn file\
    \ included from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmplpw1fcqy.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2: note:\
    \ candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/move.h:55,\n                 from /usr/include/c++/9/bits/stl_pair.h:59,\n\
    \                 from /usr/include/c++/9/bits/stl_algobase.h:64,\n          \
    \       from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmplpw1fcqy.cpp:2:\n/usr/include/c++/9/type_traits:\
    \ In substitution of \u2018template<bool _Cond, class _Tp> using enable_if_t =\
    \ typename std::enable_if::type [with bool _Cond = std::integral_constant<bool,\
    \ false>::value; _Tp = void]\u2019:\n/usr/include/c++/9/bits/basic_string.h:"
  stdout: ''
  timestamp: 1660141057
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  assert(n >=\
    \ 0 && n <= s.size());\n  std::vector<std::string> v;\n  bool flag = false;\n\
    \  for (int i = 0; i < s.size(); i++) {\n    char c = s[i];\n    if (flag) {\n\
    \      if (c == 'h' || c == 'e' || c == 'l' || c == 'l' || c == 'o' || c == 's')\n\
    \        flag = false;\n      else\n        v.push_back(\"Hell\");\n    } else\
    \ if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n      flag\
    \ = true;\n      v.push_back(\"\");\n    } else if (c == ' ') {\n      if (flag)\n\
    \        v.push_back(\"\");\n    } else if (c == '.' || c == '-' || c == '_' ||\
    \ c == '*' || c == '(' || c == ')' || c == '[' || c == ']' || c == ':' || c ==\
    \ ';' || c == '\"' || c == '\\\\') {\n      flag = false;\n      v.push_back(\"\
    Hell\");\n    } else if (n > 0) {\n      if (c == 'y' || c == 'e' || c == 'a')\n\
    \        v.push_back(\"yes\");\n      else if (c == 't' || c == 'e' || c == 'a')\n\
    \        v.push_back(\"ye\");\n      else if (c == 's' || c == 'e' || c == 'a')\n\
    \        v.push_back(\"y\");\n      else if (c == 'n' || c == 'e' || c == 'a')\n\
    \        v.push_back(\"no\");\n      else if (c == 'd' || c == 'e' || c == 'a')\n\
    \        v.push_back(\"does\");\n      else if (c == 'w' || c == 'e' || c == 'a')\n\
    \        v.push_back(\"will\");\n      else if (c == 'n' || c == 'e' || c == 'a')\n\
    \        v.push_back(\"can't\");\n      else\n        v.push_back(\"Hell\");\n\
    \    }\n  }\n  return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp7ws53n55: /tmp/tmp7ws53n55.cpp:62: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    // Write your code here\n    std::stack<std::string> s;\n    while(s.size()!=0){\n\
    \        if(s.top()==s){\n            s.pop();\n        }else{\n            std::string\
    \ ss=s.top();\n            s.pop();\n            if(ss==s){\n                v.emplace_back(ss);\n\
    \            }else{\n                std::string temp=ss;\n                while(temp!=s){\n\
    \                    temp=temp+\" \"+s.top();\n                    s.pop();\n\
    \                }\n                v.emplace_back(temp);\n            }\n   \
    \     }\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppdfkyt02.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmppdfkyt02.cpp:22:29: error:\
    \ declaration of \u2018std::stack<std::__cxx11::basic_string<char> > s\u2019 shadows\
    \ a parameter\n   22 |     std::stack<std::string> s;\n      |               \
    \              ^\n/tmp/tmppdfkyt02.cpp:24:19: error: no match for \u2018operator==\u2019\
    \ (operand types are \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018std::stack<std::__cxx11::basic_string<char> >\u2019)\n   24 |    \
    \     if(s.top()==s){\n      |            ~~~~~~~^~~\n      |                \
    \ |   |\n      |                 |   std::stack<std::__cxx11::basic_string<char>\
    \ >\n      |                 __gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmppdfkyt02.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmppdfkyt02.cpp:24:21:\
    \ note:   \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   24\
    \ |         if(s.top()==s){\n      |                     ^\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \        "
  stdout: ''
  timestamp: 1660141057
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ word_list;\n  if(s.length()==0){\n    return word_list;\n  }\n  std::set<std::string>\
    \ used_words;\n  for(std::string word: word_list){\n    if(word.size()>n){\n \
    \     continue;\n    }\n    if(used_words.find(word)==used_words.end()){\n   \
    \   word_list.push_back(word);\n      used_words.insert(word);\n    }\n  }\n \
    \ return word_list;\n}\nint main() {\n    auto candidate = select_words;\n   \
    \ assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpnpme3ej1: /tmp/tmpnpme3ej1.cpp:38: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ words;\n    // Write your code here\n    long l = 0;\n    int a = 0, b = 0;\n\
    \    while(a<s.size()){\n        b = 0;\n        while(b<s.size()-a && s[b]==s[b+a]){\n\
    \            b++;\n        }\n        l++;\n        if(n==l){\n            words.push_back((s.substr(a,b)));\n\
    \        }\n        a++;\n    }\n    return words;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpmoler5sh: /tmp/tmpmoler5sh.cpp:39: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ results;\n  if (s.empty()) {\n    return results;\n  }\n\n  std::string substring;\n\
    \  long nConsonants;\n  long nSpaces = 0;\n  // find the first space in s\n  for\
    \ (std::string::iterator it = s.begin(); it != s.end(); ++it) {\n    if (*it ==\
    \ ' ') {\n      ++nSpaces;\n    }\n  }\n  if (nSpaces > n) {\n    return select_words(s.substr(0,\
    \ nSpaces), n);\n  }\n\n  // get the first word that has at least n consonants\
    \ and split it\n  auto it = s.begin();\n  while ((it != s.end()) && (nConsonants\
    \ < n)) {\n    if (*it == ' ') {\n      ++it;\n      continue;\n    }\n    if\
    \ (*it == 'a' || *it == 'e' || *it == 'i' || *it == 'o' || *it == 'u') {\n   \
    \   ++it;\n      continue;\n    }\n    substring = std::string(it, n);\n    results.push_back(substring);\n\
    \    ++nConsonants;\n    ++it;\n  }\n  return results;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2q_riwew.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp2q_riwew.cpp:49:34: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >&, long int&)\u2019\n   49 |     substring\
    \ = std::string(it, n);\n      |                                  ^\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp2q_riwew.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2: note:\
    \ candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/move.h:55,\n                 from /usr/include/c++/9/bits/stl_pair.h:59,\n\
    \                 from /usr/include/c++/9/bits/stl_algobase.h:64,\n          \
    \       from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp2q_riwew.cpp:2:\n/usr/include/c++/9/type_traits:\
    \ In substitution of \u2018template<bool _Cond, class _Tp> using enable_if_t =\
    \ typename std::enable_if::type [with bool _Cond = std::integral_constant<bool,\
    \ false>::value; _Tp = void]\u2019:\n/usr/include/c++/9/bits/basic_string.h:121:8:\
    \   requi"
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Do not\
    \ write main() function.\n    // Do not read input, instead use the arguments\
    \ to the function.\n    // Do not print the output, instead return values as specified\n\
    \    // Still have a doubt. Checkout www.interviewbit.com/pages/sample_codes/\
    \ for more details\n    std::vector<std::string> arr;\n    int cnt = 0;\n    std::string\
    \ x;\n    for(int i=0;i<s.size();i++){\n        x = s[i];\n        if(std::tolower(x)=='a'||std::tolower(x)=='e'||std::tolower(x)=='i'||std::tolower(x)=='o'||std::tolower(x)=='u'){\n\
    \            arr.push_back(x);\n            cnt ++;\n        }\n    }\n    std::vector<std::string>::iterator\
    \ it;\n    for(it = arr.begin(); it != arr.end(); it++){\n        if(cnt == n){\n\
    \            return arr;\n        }\n        cnt = 0;\n    }\n    return arr;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzvg9kibg.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpzvg9kibg.cpp:29:26: error:\
    \ no matching function for call to \u2018tolower(std::string&)\u2019\n   29 |\
    \         if(std::tolower(x)=='a'||std::tolower(x)=='e'||std::tolower(x)=='i'||std::tolower(x)=='o'||std::tolower(x)=='u'){\n\
    \      |                          ^\nIn file included from /usr/include/c++/9/cctype:42,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:35,\n\
    \                 from /tmp/tmpzvg9kibg.cpp:2:\n/usr/include/ctype.h:122:12: note:\
    \ candidate: \u2018int tolower(int)\u2019\n  122 | extern int tolower (int __c)\
    \ __THROW;\n      |            ^~~~~~~\n/usr/include/ctype.h:122:25: note:   no\
    \ known conversion for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018int\u2019\n  122 | extern int tolower (int __c) __THROW;\n      | \
    \                    ~~~~^~~\nIn file included from /usr/include/c++/9/bits/basic_ios.h:37,\n\
    \                 from /usr/include/c++/9/ios:44,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpzvg9kibg.cpp:2:\n/usr/include/c++/9/bits/locale_facets.h:2649:5: note:\
    \ candidate: \u2018template<class _CharT> _CharT std::tolower(_CharT, const std::locale&)\u2019\
    \n 2649 |     tolower(_CharT __c, const locale& __loc)\n      |     ^~~~~~~\n\
    /usr/include/c++/9/bits/locale_facets.h:2649:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpzvg9kibg.cpp:29:26: note:   candidate expects 2 arguments,\
    \ 1 provided\n   29 |         if(std::tolower(x)=='a'||std::tolower(x)=='e'||std::tolower(x)=='i'||std::tolower(x)=='o'||std::tolower(x)=='u'){\n\
    \      |                          ^\n/tmp/tmpzvg9kibg.cpp:29:48: error: no matching\
    \ function for call to \u2018tolower(std::string&)\u2019\n   29 |"
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.empty())\
    \ {\n        return {};\n    }\n    std::vector<std::string> words;\n    for (auto\
    \ &p : s) {\n        auto i = find_char(p.c_str(), 'a');\n        if (i == std::string::npos)\
    \ {\n            i = find_char(p.c_str(), 'e');\n            if (i == std::string::npos)\
    \ {\n                i = find_char(p.c_str(), 'i');\n                if (i ==\
    \ std::string::npos) {\n                    i = find_char(p.c_str(), 'o');\n \
    \                   if (i == std::string::npos) {\n                        i =\
    \ find_char(p.c_str(), 'u');\n                    }\n                }\n     \
    \       }\n        }\n        if (i != std::string::npos) {\n            words.push_back(std::string(p.begin(),\
    \ i));\n        }\n    }\n    std::sort(words.begin(), words.end());\n    std::vector<std::string>::iterator\
    \ last = std::unique(words.begin(), words.end());\n    words.erase(last, words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \    words.erase(std::unique(words.begin(), words.end()) - words.begin(), words.end());\n\
    \n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1la4jy2u.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp1la4jy2u.cpp:25:30: error:\
    \ request for member \u2018c_str\u2019 in \u2018p\u2019, which is of non-class\
    \ type \u2018char\u2019\n   25 |         auto i = find_char(p.c_str(), 'a');\n\
    \      |                              ^~~~~\n/tmp/tmp1la4jy2u.cpp:25:18: error:\
    \ \u2018find_char\u2019 was not declared in this scope\n   25 |         auto i\
    \ = find_char(p.c_str(), 'a');\n      |                  ^~~~~~~~~\n/tmp/tmp1la4jy2u.cpp:27:29:\
    \ error: request for member \u2018c_str\u2019 in \u2018p\u2019, which is of non-class\
    \ type \u2018char\u2019\n   27 |             i = find_char(p.c_str(), 'e');\n\
    \      |                             ^~~~~\n/tmp/tmp1la4jy2u.cpp:29:33: error:\
    \ request for member \u2018c_str\u2019 in \u2018p\u2019, which is of non-class\
    \ type \u2018char\u2019\n   29 |                 i = find_char(p.c_str(), 'i');\n\
    \      |                                 ^~~~~\n/tmp/tmp1la4jy2u.cpp:31:37: error:\
    \ request for member \u2018c_str\u2019 in \u2018p\u2019, which is of non-class\
    \ type \u2018char\u2019\n   31 |                     i = find_char(p.c_str(),\
    \ 'o');\n      |                                     ^~~~~\n/tmp/tmp1la4jy2u.cpp:33:41:\
    \ error: request for member \u2018c_str\u2019 in \u2018p\u2019, which is of non-class\
    \ type \u2018char\u2019\n   33 |                         i = find_char(p.c_str(),\
    \ 'u');\n      |                                         ^~~~~\n/tmp/tmp1la4jy2u.cpp:39:43:\
    \ error: request for member \u2018begin\u2019 in \u2018p\u2019, which is of non-class\
    \ type \u2018char\u2019\n   39 |             words.push_back(std::string(p.begin(),\
    \ i));\n      |                                           ^~~~~\n/tmp/tmp1la4jy2u.cpp:45:85:\
    \ error: no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::erase(__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >::difference_type, std::vector<std::__cxx11::basic_string<char> >::iterator)\u2019\
    \n   45 |     words.erase(std::unique(words.begin(), words.end()) - words.begin(),\
    \ words.end());\n      |     "
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ ret;\n  ret.push_back(\"\");\n  if(s.empty())\n    return ret;\n  while(s.size()\
    \ >= 2) {\n    if(s.substr(0, 2) == \"c\") {\n      ret.push_back(s.substr(0,\
    \ 3));\n    }\n    else if(s.substr(0, 2) == \"ch\") {\n      ret.push_back(s.substr(0,\
    \ 4));\n    }\n    else if(s.substr(0, 2) == \"h\") {\n      ret.push_back(s.substr(0,\
    \ 2));\n    }\n    else if(s.substr(0, 2) == \"he\") {\n      ret.push_back(s.substr(0,\
    \ 5));\n    }\n    else if(s.substr(0, 2) == \"l\") {\n      ret.push_back(s.substr(0,\
    \ 4));\n    }\n    else if(s.substr(0, 2) == \"ll\") {\n      ret.push_back(s.substr(0,\
    \ 7));\n    }\n    else if(s.substr(0, 2) == \"n\") {\n      ret.push_back(s.substr(0,\
    \ 2));\n    }\n    else if(s.substr(0, 2) == \"ng\") {\n      ret.push_back(s.substr(0,\
    \ 3));\n    }\n    else if(s.substr(0, 2) == \"r\") {\n      ret.push_back(s.substr(0,\
    \ 3));\n    }\n    else if(s.substr(0, 2) == \"th\") {\n      ret.push_back(s.substr(0,\
    \ 4));\n    }\n    else if(s.substr(0, 2) == \"v\") {\n      ret.push_back(s.substr(0,\
    \ 2));\n    }\n    else if(s.substr(0, 2) == \"y\") {\n      ret.push_back(s.substr(0,\
    \ 2));\n    }\n    else if(s.substr(0, 2) == \"z\") {\n      ret.push_back(s.substr(0,\
    \ 3));\n    }\n    else if(s.substr(0, 2) == \"ch\") {\n      ret.push_back(s.substr(0,\
    \ 4));\n    }\n    else if(s.substr(0, 2) == \"s\") {\n      ret.push_back(s.substr(0,\
    \ 3));\n    }\n    else if(s.substr(0, 2) == \"sh\") {\n      ret.push_back(s.substr(0,\
    \ 4));\n    }\n    else if(s.substr(0, 2) == \"shh\") {\n      ret.push_back(s.substr(0,\
    \ 6));\n    }\n    else if(s.substr(0, 2) == \"ss\") {\n      ret.push_back(s.substr(0,\
    \ 3));\n    }\n    else if(s.substr(0, 2) == \"chs\") {\n      ret.push_back(s.substr(0,\
    \ 4));\n    }\n    else if(s.substr(0, 2) == \"x\") {\n      ret.push_back(s.substr(0,\
    \ 2));\n    }\n    else if(s.substr(0, 2) == \"y\") { \n      ret.push_back(s.substr(0,\
    \ 2));\n    }\n    else if(s.substr(0, 2) == \"zz\") {\n      ret.push_back(s.substr(0,\
    \ 3));\n    }\n    else if(s.substr(0, 2) == \"z\") {\n      ret.push_back(s.substr(0,\
    \ 3));\n    }\n    else if(s.substr(0, 2) == \"ch\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn0v3fdyr.cpp:94:31: warning: missing terminating \" character\n\
    \   94 |     else if(s.substr(0, 2) == \"ch\n      |                         \
    \      ^\n/tmp/tmpn0v3fdyr.cpp:94:31: error: missing terminating \" character\n\
    \   94 |     else if(s.substr(0, 2) == \"ch\n      |                         \
    \      ^~~\n/tmp/tmpn0v3fdyr.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpn0v3fdyr.cpp:95:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n   95 | }\n      | ^\n\
    /tmp/tmpn0v3fdyr.cpp:94:30: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   94 |     else if(s.substr(0, 2) == \"ch\n      |            ~    \
    \             ^\n      |                              )\n   95 | }\n      | ~\
    \                             \n/tmp/tmpn0v3fdyr.cpp:95:1: error: expected primary-expression\
    \ before \u2018}\u2019 token\n   95 | }\n      | ^\n/tmp/tmpn0v3fdyr.cpp:96:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   96 | int main() {\n      |            ^\n/tmp/tmpn0v3fdyr.cpp:105:1: error:\
    \ expected \u2018}\u2019 at end of input\n  105 | }\n      | ^\n/tmp/tmpn0v3fdyr.cpp:19:62:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> select_words(std::string\
    \ s, long n) {\n      |                                                      \
    \        ^\n/tmp/tmpn0v3fdyr.cpp:105:1: warning: control reaches end of non-void\
    \ function [-Wreturn-type]\n  105 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141057
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Write your\
    \ code here\n    \n    std::vector<std::string> v;\n    int len = s.length();\n\
    \    int cnt = 0;\n    \n    for (int i = 0; i < len; i++) {\n        if (isalpha(s[i])\
    \ && s[i] != '@') {\n            if (cnt <= n) {\n                v.push_back((std::string(s,\
    \ i, len)));\n                cnt++;\n            }\n        }\n    }\n    return\
    \ v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp9h4ah09t: /tmp/tmp9h4ah09t.cpp:38: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141059
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ result;\n  if (s.empty()) return result;\n  std::vector<std::string> words;\n\
    \  if (n <= 0) return result;\n  \n  std::string word = s;\n  // use \"c++'s range\
    \ based for loop\" to iterate through s \n  // and add each word that has exactly\
    \ n consonants \n  for (auto it = s.begin(); it != s.end(); ++it) {\n    // check\
    \ if the current character is a consonant\n    if (!isalpha(*it)) continue;\n\
    \    // if current character is a consonant, check if the preceding \n    // consonant\
    \ is the same as current consonant\n    if (word == \"\") {\n      words.push_back(*it);\n\
    \      continue;\n    }\n    // if the current character is not same as the previous\
    \ \n    // character, push it to result vector\n    if (word[word.size()-1] !=\
    \ *it) words.push_back(*it);\n  }\n\n  result = words;\n  return result;\n}\n\
    int main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary\
    \ had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp71xv50n0.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp71xv50n0.cpp:34:26: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   34 |       words.push_back(*it);\n      |    \
    \                      ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp71xv50n0.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^~~\n\
    /tm"
  stdout: ''
  timestamp: 1660141057
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ result;\n  // Write your code here\n  return result;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmptun0ae9r: /tmp/tmptun0ae9r.cpp:26: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    int size = (int) s.size();\n    if (size == 0) {\n        return v;\n\
    \    }\n    if (n >= s.size()) {\n        n = s.size() - 1;\n    }\n    \n   \
    \ for (int i = 0; i < size; i++) {\n        char ch = s[i];\n        if (ch ==\
    \ ' ') {\n            continue;\n        }\n        \n        int count = 0;\n\
    \        int start = 1;\n        for (int j = i; j < i + n; j++) {\n         \
    \   if (s[j] == ch) {\n                count++;\n                if (count ==\
    \ n) {\n                    v.push_back(s.substr(start, i - start));\n       \
    \             start = j + 1;\n                    count = 0;\n               \
    \ }\n            }\n        }\n        \n        if (count > n) {\n          \
    \  v.push_back(s.substr(start, i - start));\n        }\n    }\n    \n    return\
    \ v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpjlroc2uu: /tmp/tmpjlroc2uu.cpp:57: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::set<std::string>\
    \ words;\n    if(s == \"\") return {};\n    long long count = 1;\n    for(auto\
    \ &c : s) {\n        if(!std::isalpha(c)) {\n            std::cout << \"Warning:\
    \ \" << c << \" is not a letter: \" << s.c_str() << std::endl;\n            continue;\n\
    \        }\n        std::string word = to_upper(c);\n        if(words.find(word)\
    \ == words.end()) words.insert(word);\n        ++count;\n    }\n    // Add all\
    \ the words that contains more than n consonants\n    for(auto &w : words) {\n\
    \        long long c = countConsonants(w);\n        if(c == n) words.push_back(w);\n\
    \    }\n    // If all words from input string contain more than n consonants,\
    \ add empty string.\n    if(words.size() == 0) words.push_back(\"empty\");\n \
    \   return words;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqo5rdgbk.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpqo5rdgbk.cpp:28:28: error:\
    \ \u2018to_upper\u2019 was not declared in this scope; did you mean \u2018towupper\u2019\
    ?\n   28 |         std::string word = to_upper(c);\n      |                  \
    \          ^~~~~~~~\n      |                            towupper\n/tmp/tmpqo5rdgbk.cpp:34:23:\
    \ error: \u2018countConsonants\u2019 was not declared in this scope\n   34 | \
    \        long long c = countConsonants(w);\n      |                       ^~~~~~~~~~~~~~~\n\
    /tmp/tmpqo5rdgbk.cpp:35:26: error: \u2018class std::set<std::__cxx11::basic_string<char>\
    \ >\u2019 has no member named \u2018push_back\u2019\n   35 |         if(c == n)\
    \ words.push_back(w);\n      |                          ^~~~~~~~~\n/tmp/tmpqo5rdgbk.cpp:38:33:\
    \ error: \u2018class std::set<std::__cxx11::basic_string<char> >\u2019 has no\
    \ member named \u2018push_back\u2019\n   38 |     if(words.size() == 0) words.push_back(\"\
    empty\");\n      |                                 ^~~~~~~~~\n/tmp/tmpqo5rdgbk.cpp:39:12:\
    \ error: could not convert \u2018words\u2019 from \u2018std::set<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n   39\
    \ |     return words;\n      |            ^~~~~\n      |            |\n      |\
    \            std::set<std::__cxx11::basic_string<char> >\n"
  stdout: ''
  timestamp: 1660141057
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ result;\n    \n    for(std::size_t i = 0; i < s.length(); i++)\n        if(s[i]\
    \ != '\\0') result.push_back((std::string)s.substr(i, i+n));\n    \n    return\
    \ result;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpiqdkwnwm: /tmp/tmpiqdkwnwm.cpp:29: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  assert(n > 0);\n\
    \  if (s.empty()) {\n    return {};\n  }\n  std::vector<std::string> res;\n  int\
    \ cnt = 0;\n  for (char c : s) {\n    if (c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u') {\n      res.push_back((std::string)s.substr(cnt, (cnt\
    \ + n) - cnt));\n      cnt = cnt + n;\n    }\n  }\n  res.push_back((std::string)s.substr(cnt,\
    \ s.length() - cnt));\n  return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 24) > this->size() (which is 22)\n"
  stdout: ''
  timestamp: 1660141058
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  if(s.empty())\n    return v;\n  v.push_back(s);\n  for(int i = 0; i <\
    \ n; i++) {\n    std::string new_word = s.substr(0, i);\n    if(new_word.empty())\n\
    \      continue;\n    v.push_back(new_word);\n  }\n  return v;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmps2gxggfw: /tmp/tmps2gxggfw.cpp:34: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  if (s.size() == 0) {\n    return v;\n  }\n  \n  long m = s.size();\n \
    \ long n = std::min(m, n);\n  \n  if (n < 0 || n >= m) {\n    return v;\n  }\n\
    \  \n  // count vowel occurrences \n  long nw = std::count_if(s.begin(), s.end(),\
    \ [](char c){return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >=\
    \ '0' && c <= '9');});\n  \n  // get words\n  std::string word = s.substr(0, n);\n\
    \  \n  // check whether it has m consonants in total\n  if (m == n + nw) {\n \
    \   v.push_back(word);\n  }\n  \n  // find first space\n  std::string::size_type\
    \ end = s.find_first_of(\" \", n);\n  if (end == std::string::npos) {\n    return\
    \ v;\n  }\n  \n  // get words\n  word = s.substr(n, end - n);\n  \n  // check\
    \ whether it has m consonants in total\n  if (m == n + nw) {\n    v.push_back(word);\n\
    \  }\n  \n  // find next space\n  end = s.find_first_of(\" \", end + 1);\n  if\
    \ (end == std::string::npos) {\n    return v;\n  }\n  \n  // get words\n  word\
    \ = s.substr(end + 1, m - end - 1);\n  \n  // check whether it has m consonants\
    \ in total\n  if (m == n + nw) {\n    v.push_back(word);\n  }\n  \n  return v;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_eea1ajr.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp_eea1ajr.cpp:26:8: error:\
    \ declaration of \u2018long int n\u2019 shadows a parameter\n   26 |   long n\
    \ = std::min(m, n);\n      |        ^\n"
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    for (auto &x: s) {\n        if (x.find('a') != std::string::npos ||\
    \ x.find('e') != std::string::npos || x.find('i') != std::string::npos || x.find('o')\
    \ != std::string::npos || x.find('u') != std::string::npos) {\n            v.push_back(x);\n\
    \        }\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpt3mafcdq.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpt3mafcdq.cpp:22:15: error:\
    \ request for member \u2018find\u2019 in \u2018x\u2019, which is of non-class\
    \ type \u2018char\u2019\n   22 |         if (x.find('a') != std::string::npos\
    \ || x.find('e') != std::string::npos || x.find('i') != std::string::npos || x.find('o')\
    \ != std::string::npos || x.find('u') != std::string::npos) {\n      |       \
    \        ^~~~\n/tmp/tmpt3mafcdq.cpp:22:51: error: request for member \u2018find\u2019\
    \ in \u2018x\u2019, which is of non-class type \u2018char\u2019\n   22 |     \
    \    if (x.find('a') != std::string::npos || x.find('e') != std::string::npos\
    \ || x.find('i') != std::string::npos || x.find('o') != std::string::npos || x.find('u')\
    \ != std::string::npos) {\n      |                                           \
    \        ^~~~\n/tmp/tmpt3mafcdq.cpp:22:87: error: request for member \u2018find\u2019\
    \ in \u2018x\u2019, which is of non-class type \u2018char\u2019\n   22 |     \
    \    if (x.find('a') != std::string::npos || x.find('e') != std::string::npos\
    \ || x.find('i') != std::string::npos || x.find('o') != std::string::npos || x.find('u')\
    \ != std::string::npos) {\n      |                                           \
    \                                            ^~~~\n/tmp/tmpt3mafcdq.cpp:22:123:\
    \ error: request for member \u2018find\u2019 in \u2018x\u2019, which is of non-class\
    \ type \u2018char\u2019\n   22 |         if (x.find('a') != std::string::npos\
    \ || x.find('e') != std::string::npos || x.find('i') != std::string::npos || x.find('o')\
    \ != std::string::npos || x.find('u') != std::string::npos) {\n      |       \
    \                                                                            \
    \                                        ^~~~\n/tmp/tmpt3mafcdq.cpp:22:159: error:\
    \ request for member \u2018find\u2019 in \u2018x\u2019, which is of non-class\
    \ type \u2018char\u2019\n   22 |         if (x.find('a') != std::string::npos\
    \ || x.find('e') != std::string::npos || x.find('i') != std::string::npos || x.find('o')\
    \ != std::string::npos || x.find('u') != std::string::npos) {\n      |       \
    \         "
  stdout: ''
  timestamp: 1660141057
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Complete\
    \ this function\n    // Feel free to write your solution here\n    // You may\
    \ assume that the input string is non-empty and contains only letters and spaces.\n\
    \    if (s.empty()) return {};\n    \n    std::vector<std::string> result;\n \
    \   // use two pointers to check whether the string contains n letters, \n   \
    \ // and find the start index\n    size_t start_idx = 0;\n    size_t end_idx =\
    \ s.size();\n    // while start < end\n    while (start_idx < end_idx) {\n   \
    \     size_t count = 0;\n        // increment start idx by one \n        start_idx++;\n\
    \        \n        // if current char is not space\n        while (s[start_idx]\
    \ != '\\0') {\n            // if current char is consonant\n            if (s[start_idx]\
    \ >= 'a' && s[start_idx] <= 'z' \n                || s[start_idx] >= 'A' && s[start_idx]\
    \ <= 'Z') {\n                // check if current char has n consonants\n     \
    \           if (count + 1 ==n) {\n                    // if all consonants n are\
    \ found, add to result vector\n                    result.emplace_back(std::to_string(start_idx));\n\
    \                }\n                count++;\n            } else {\n         \
    \       // break\n                break;\n            }\n        }\n        \n\
    \        // check if there exist at least n more consecutive consonants, \n  \
    \      // if so, then increase end idx, otherwise reset start idx\n        if\
    \ (count + 1 < n) {\n            end_idx++;\n        } else {\n            start_idx\
    \ = 0;\n            end_idx = s.size();\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660141063
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    std::vector<std::string>::iterator itr;\n    std::string::iterator\
    \ it;\n    it = s.begin();\n    long count = 0;\n    \n    while(it != s.end())\
    \ {\n        // Find the first space\n        while (it != s.end() && std::isspace(*it))\n\
    \            ++it;\n        \n        // Find the first letter of the word\n \
    \       while (it != s.end() && !std::isalpha(*it))\n            ++it;\n     \
    \   \n        // Find the first consonant\n        while (it != s.end() && std::islower(*it))\n\
    \            ++it;\n        \n        // Find the last consonant\n        while\
    \ (it != s.end() && std::isupper(*it))\n            ++it;\n        \n        //\
    \ Find the first letter of the word\n        while (it != s.end() && !std::isalpha(*it))\n\
    \            ++it;\n        \n        \n        // if there are enough letters\
    \ to find the word length\n        if (count + n - 1 <= it - s.begin()) {\n  \
    \          \n            // find the word length\n            int len = it - s.begin();\n\
    \            \n            // if there are enough letters to find the word length\n\
    \            if (len >= n) {\n                \n                // store it\n\
    \                res.push_back((std::string(s, s.begin(), s.begin() + len)));\n\
    \                \n                // move the it\n                it = s.begin()\
    \ + len;\n                \n                // increase the count\n          \
    \      count += len;\n            }\n        }\n        \n        // if there\
    \ aren't enough letters to find the word length\n        else {\n            \n\
    \            // move the it\n            it = s.end();\n            \n       \
    \     // increase the count\n            count += it - s.end();\n        }\n \
    \   }\n    \n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzif50b_z.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpzif50b_z.cpp:58:73: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(std::string&,\
    \ std::__cxx11::basic_string<char>::iterator, __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >)\u2019\n   58 |                 res.push_back((std::string(s,\
    \ s.begin(), s.begin() + len)));\n      |                                    \
    \                                     ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpzif50b_z.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note: candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpzif50b_z.cpp:58:73:\
    \ note:   candidate expects 2 arguments, 3 provided\n   58 |                 res.push_back((std::string(s,\
    \ s.begin(), s.begin() + len)));\n      |                                    \
    \                                     ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/includ"
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ words;\n    std::vector<char> v;\n    for(char c: s)\n        v.push_back(c);\n\
    \    for(size_t i = 0; i < v.size(); ++i)\n        v.at(i) = tolower(v.at(i));\n\
    \    for(size_t i = 0; i != v.size(); ++i)\n        if(v.at(i) == 'y')\n     \
    \       v.erase(v.begin() + i);\n    for(size_t i = 0; i != v.size(); ++i) {\n\
    \        if(v.at(i) == 'e')\n            v.erase(v.begin() + i);\n    }\n    for(size_t\
    \ i = 0; i != v.size(); ++i) {\n        if(v.at(i) == ' ')\n            v.erase(v.begin()\
    \ + i);\n    }\n    for(size_t i = 0; i != v.size(); ++i) {\n        if(v.at(i)\
    \ == '.')\n            v.erase(v.begin() + i);\n    }\n    for(size_t i = 0; i\
    \ != v.size(); ++i) {\n        if(v.at(i) == 't')\n            v.erase(v.begin()\
    \ + i);\n    }\n    for(size_t i = 0; i != v.size(); ++i) {\n        if(v.at(i)\
    \ == 'a')\n            v.erase(v.begin() + i);\n    }\n    for(size_t i = 0; i\
    \ != v.size(); ++i) {\n        if(v.at(i) == 'p')\n            v.erase(v.begin()\
    \ + i);\n    }\n    for(size_t i = 0; i != v.size(); ++i) {\n        if(v.at(i)\
    \ == 'o')\n            v.erase(v.begin() + i);\n    }\n    for(size_t i = 0; i\
    \ != v.size(); ++i) {\n        if(v.at(i) == ' ')\n            v.erase(v.begin()\
    \ + i);\n    }\n    for(size_t i = 0; i != v.size(); ++i) {\n        if(v.at(i)\
    \ == 'n')\n            v.erase(v.begin() + i);\n    }\n    for(size_t i = 0; i\
    \ != v.size(); ++i) {\n        if(v.at(i) == 'l')\n            v.erase(v.begin()\
    \ + i);\n    }\n    for(size_t i = 0; i != v.size(); ++i) {\n        if(v.at(i)\
    \ == 'a')\n            v.erase(v.begin() + i);\n    }\n    for(size_t i = 0; i\
    \ != v.size(); ++i) {\n        if(v.at(i) == 'm')\n            v.erase(v.begin()\
    \ + i);\n    }\n    for(size_t i = 0; i != v.size(); ++i) {\n        if(v.at(i)\
    \ == 'y')\n            v.erase(v.begin() + i);\n    }\n    for(size_t i = 0; i\
    \ != v.size(); ++i) {\n        if(v.at(i) == 'a')\n            v.erase(v.begin()\
    \ + i);\n    }\n    for(size_t i = 0; i != v.size(); ++i) {\n        if(v.at(i)\
    \ == ' ')\n            v.erase(v.begin() + i);\n    }\n    for(size_t i = 0; i\
    \ != v.size(); ++i) {\n        if(v.at\n}\nint main() {\n    auto candidate =\
    \ select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp67vavqci.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp67vavqci.cpp:90:16: error:\
    \ expected \u2018)\u2019 before \u2018}\u2019 token\n   90 |         if(v.at\n\
    \      |           ~    ^\n      |                )\n   91 | }\n      | ~    \
    \           \n/tmp/tmp67vavqci.cpp:91:1: error: cannot resolve overloaded function\
    \ \u2018at\u2019 based on conversion to type \u2018bool\u2019\n   91 | }\n   \
    \   | ^\n/tmp/tmp67vavqci.cpp:91:1: error: expected primary-expression before\
    \ \u2018}\u2019 token\n/tmp/tmp67vavqci.cpp:92:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   92 | int main() {\n     \
    \ |            ^\n/tmp/tmp67vavqci.cpp:101:1: error: expected \u2018}\u2019 at\
    \ end of input\n  101 | }\n      | ^\n/tmp/tmp67vavqci.cpp:19:62: note: to match\
    \ this \u2018{\u2019\n   19 | std::vector<std::string> select_words(std::string\
    \ s, long n) {\n      |                                                      \
    \        ^\n/tmp/tmp67vavqci.cpp:101:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n  101 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141057
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ result;\n    result.push_back(\"\");\n    // your code here\n    std::cerr <<\
    \ s << std::endl;\n    if (s.empty())\n    {\n        return result;\n    }\n\
    \    if (s.front() == ' ')\n    {\n        return result;\n    }\n    for (int\
    \ i = 0; i < s.length(); i++)\n    {\n        bool found = false;\n        for\
    \ (int j = i; j < s.length(); j++)\n        {\n            if (s[j] == 'C' ||\
    \ s[j] == 'S' || s[j] == 'C' || s[j] == 'K' || s[j] == 'P' || s[j] == 'H')\n \
    \           {\n                found = true;\n                break;\n       \
    \     }\n        }\n        if (!found)\n        {\n            std::cerr << s\
    \ << std::endl;\n            return result;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'Mary had a little lamb

    Mary had a little lamb

    tmp4kkkcl3f: /tmp/tmp4kkkcl3f.cpp:53: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  assert(!s.empty());\n\
    \  std::vector<std::string> v;\n  if (n <= 0) {\n    return v;\n  }\n  auto it\
    \ = s.cbegin(), e = s.cend(); \n  v.push_back(std::string(it));\n  for (++it;\
    \ it != e; ++it) {\n    if (*it != ' ' && n <= 1) {\n      break;\n    }\n   \
    \ v.push_back(std::string(it));\n    n--;\n  }\n  return v;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9_f7rtyd.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp9_f7rtyd.cpp:26:29: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(__gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >&)\u2019\n   26 |   v.push_back(std::string(it));\n\
    \      |                             ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp9_f7rtyd.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note: candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/move.h:55,\n                 from /usr/include/c++/9/bits/stl_pair.h:59,\n\
    \                 from /usr/include/c++/9/bits/stl_algobase.h:64,\n          \
    \       from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp9_f7rtyd.cpp:2:\n/usr/include/c++/9/type_traits:\
    \ In substitution of \u2018template<bool _Cond, class _Tp> using enable_if_t =\
    \ typename std::enable_if::type [with bool _Cond = std::integral_constant<bool,\
    \ false>::value; _Tp = void]\u2019:\n/usr/include/c++/9/bits/basic_string.h:121:8:\
    \   required by substit"
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  int n = n;\n  int i = 0;\n  int count = 0;\n  while(i < s.length()) {\n\
    \    if (s[i] == ' ') {\n      if (n == count) {\n        v.push_back((std::string)\"\
    \ \");\n      }\n      count++;\n      i++;\n    } else {\n      if (s[i] == '\
    \ ') {\n        v.push_back((std::string)\" \");\n        count++;\n        i++;\n\
    \      } else {\n        if (s[i] == s[0]) {\n          if (n == count) {\n  \
    \          v.push_back((std::string)\" \");\n          }\n          count++;\n\
    \          i++;\n        } else {\n          if (s == \"\") {\n            return\
    \ v;\n          } else {\n            if (n == count) {\n              v.push_back((std::string)\"\
    \ \");\n            }\n            count++;\n            i++;\n          }\n \
    \       }\n      }\n    }\n  }\n  return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn1y931us.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpn1y931us.cpp:21:7: error:\
    \ declaration of \u2018int n\u2019 shadows a parameter\n   21 |   int n = n;\n\
    \      |       ^\n"
  stdout: ''
  timestamp: 1660141057
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ ans;\n    std::vector<std::string> v;\n    \n    if(n == 0 || s == \"\"){\n\
    \        return ans;\n    }\n    \n    int count[26];\n    for (char ch : s){\n\
    \        if(ch>='a'&& ch<='z'){\n            count[(int)ch-'a']++;\n        }\n\
    \    }\n    \n    for (int i = 0; i < 26; i++){\n        if (count[i] >= n){\n\
    \            v.push_back(std::to_string(i + 'a'));\n        }\n    }\n    ans\
    \ = v;\n    \n    return ans;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpv2d0boyn: /tmp/tmpv2d0boyn.cpp:45: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ retval;\n    if (s.empty()) retval.push_back(\"\");\n    else {\n        for\
    \ (int i = 0; i < s.size(); i++) {\n            for (int j = 0; j < i; j++) {\n\
    \                if (s[i] == s[j] && i != j)\n                    retval.push_back((s.substr(i,\
    \ j)));\n            }\n        }\n    }\n    return retval;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpj91aiggv: /tmp/tmpj91aiggv.cpp:34: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ words;\n    // Write your code here\n    return words;\n}\nint main() {\n  \
    \  auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp_jipugzp: /tmp/tmp_jipugzp.cpp:26: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141059
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    for (auto &i : s) {\n        if ((int)i == (int)' ') continue;\n   \
    \     int count = 0;\n        for (auto &j : i) {\n            if (j == (char)('a'))\
    \ count++;\n            if (j == (char)('e')) count++;\n            if (j == (char)('i'))\
    \ count++;\n            if (j == (char)('o')) count++;\n            if (j == (char)('u'))\
    \ count++;\n        }\n        if (n == count) v.push_back((std::string)i);\n\
    \    }\n    if (v.empty()) return {};\n    return v;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoyzpbzed.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpoyzpbzed.cpp:24:24: error:\
    \ \u2018begin\u2019 was not declared in this scope\n   24 |         for (auto\
    \ &j : i) {\n      |                        ^\n/tmp/tmpoyzpbzed.cpp:24:24: note:\
    \ suggested alternatives:\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpoyzpbzed.cpp:2:\n/usr/include/c++/9/valarray:1224:5:\
    \ note:   \u2018std::begin\u2019\n 1224 |     begin(const valarray<_Tp>& __va)\n\
    \      |     ^~~~~\nIn file included from /usr/include/c++/9/filesystem:38,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n\
    \                 from /tmp/tmpoyzpbzed.cpp:2:\n/usr/include/c++/9/bits/fs_dir.h:516:3:\
    \ note:   \u2018std::filesystem::__cxx11::begin\u2019\n  516 |   begin(recursive_directory_iterator\
    \ __iter) noexcept\n      |   ^~~~~\n/tmp/tmpoyzpbzed.cpp:24:24: error: \u2018\
    end\u2019 was not declared in this scope\n   24 |         for (auto &j : i) {\n\
    \      |                        ^\n/tmp/tmpoyzpbzed.cpp:24:24: note: suggested\
    \ alternatives:\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpoyzpbzed.cpp:2:\n/usr/include/c++/9/valarray:1244:5:\
    \ note:   \u2018std::end\u2019\n 1244 |     end(const valarray<_Tp>& __va)\n \
    \     |     ^~~\nIn file included from /usr/include/c++/9/filesystem:38,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n \
    \                from /tmp/tmpoyzpbzed.cpp:2:\n/usr/include/c++/9/bits/fs_dir.h:520:3:\
    \ note:   \u2018std::filesystem::__cxx11::end\u2019\n  520 |   end(recursive_directory_iterator)\
    \ noexcept\n      |   ^~~\n/tmp/tmpoyzpbzed.cpp:31:50: error: no matching function\
    \ for call to \u2018std::__cxx11::basic_string<char>::basic_string(char&)\u2019\
    \n   31 |         if (n == count) v.push_back((std::string)i);\n      |      \
    \                                            ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_clas"
  stdout: ''
  timestamp: 1660141056
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ vs;\n  if (s.empty()) {\n    return vs;\n  }\n  // Write your code here\n  long\
    \ i = 0;\n  while (i < s.size()) {\n    if (s.at(i) != 'a') {\n      if (s.at(i)\
    \ != 'e') {\n        if (s.at(i) != 'i') {\n          if (s.at(i) != 'o') {\n\
    \            if (s.at(i) != 'u') {\n              vs.push_back(s.substr(i, i +\
    \ n));\n              i = i + n;\n            }\n          }\n        }\n    \
    \  }\n    }\n    i = i + 1;\n  }\n  return vs;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpto1i1_mz: /tmp/tmpto1i1_mz.cpp:45: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    v.push_back((std::string)s);\n    while(n != 0) {\n        std::vector<std::string>\
    \ v1;\n        for (std::string word: v) {\n            bool found = false;\n\
    \            for(int i=0; i < word.length(); i++) {\n                if(word[i]\
    \ != ' ') {\n                    if(word[i] == word[n]) {\n                  \
    \      v1.push_back(word);\n                        found = true;\n          \
    \              break;\n                    }\n                }\n            }\n\
    \            if(found == false) {\n                break;\n            }\n   \
    \     }\n        if (v1.size() > 0) {\n            v = v1;\n        }\n      \
    \  n--;\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpf0bggv2t: /tmp/tmpf0bggv2t.cpp:48: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141058
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    for(int i = 0; i <= s.size(); i++) {\n        if(s[i] == ' ') {\n  \
    \          v.push_back(s.substr(i, s.size() - i));\n            v.push_back(s.substr(i,\
    \ s.size() - i));\n        }\n        if(i > s.size()) break;\n        if(isupper(s[i]))\
    \ {\n            v.push_back(s.substr(i, s.size() - i));\n            v.push_back(s.substr(i,\
    \ s.size() - i));\n        }\n        for(int j = 0; j <= s[i]; j++) {\n     \
    \       if(s[j] == ' ') {\n                v.push_back(s.substr(i, j - i));\n\
    \                v.push_back(s.substr(i, j - i));\n            }\n           \
    \ if(j > s[i]) break;\n            if(islower(s[j])) {\n                v.push_back(s.substr(i,\
    \ s.size() - i));\n                v.push_back(s.substr(i, s.size() - i));\n \
    \           }\n            v.push_back(s.substr(i, j - i));\n        }\n    }\n\
    \    for(int i = 0; i <= s.size(); i++) {\n        if(s[i] == ' ') {\n       \
    \     v.push_back(s.substr(i, s.size() - i));\n            v.push_back(s.substr(i,\
    \ s.size() - i));\n        }\n        if(i > s.size()) break;\n        if(isupper(s[i]))\
    \ {\n            v.push_back(s.substr(i, s.size() - i));\n            v.push_back(s.substr(i,\
    \ s.size() - i));\n        }\n        for(int j = 0; j <= s[i]; j++) {\n     \
    \       if(s[j] == ' ') {\n                v.push_back(s.substr(i, j - i));\n\
    \                v.push_back(s.substr(i, j - i));\n            }\n           \
    \ if(j > s[i]) break;\n            if(islower(s[j])) {\n                v.push_back(s.substr(i,\
    \ s.size() - i));\n                v.push_back(s.substr(i, s.size() - i));\n \
    \           }\n            v.push_back(s.substr(i, j - i));\n        }\n    }\n\
    \    return v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpj9u4m904: /tmp/tmpj9u4m904.cpp:71: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141057
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    int count\
    \ = 0;\n    bool flag = true;\n    std::vector<std::string> ans;\n    for (auto\
    \ it = s.begin(); it != s.end(); ++it) {\n        if (*it == ' ') {\n        \
    \    flag = false;\n        } else {\n            if (flag) {\n              \
    \  ans.push_back(*it);\n                count++;\n            } else {\n     \
    \           if (count == n) {\n                    flag = true;\n            \
    \        count = 0;\n                    ans.push_back(*it);\n               \
    \ }\n            }\n        }\n    }\n    if (flag) {\n        return ans;\n \
    \   }\n    return {};\n}\nint main() {\n    auto candidate = select_words;\n \
    \   assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp26kql84e.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp26kql84e.cpp:28:34: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   28 |                 ans.push_back(*it);\n   \
    \   |                                  ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp26kql84e.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~"
  stdout: ''
  timestamp: 1660141060
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ result;\n    if (s.empty())\n        return result;\n    auto first_char = s.front();\n\
    \    if (first_char == '.')\n        return result;\n    auto last_char = s.back();\n\
    \    char cur_char = 0;\n    bool first_char_found = false;\n    bool last_char_found\
    \ = false;\n    for (auto c : s) {\n        if (c == first_char) {\n         \
    \   if (last_char == '.' || (c == ' ' && cur_char == '.')) {\n               \
    \ first_char_found = true;\n                cur_char = c;\n            } else\
    \ {\n                if (!first_char_found)\n                    result.emplace_back(std::to_string(c));\n\
    \                first_char_found = false;\n            }\n        } else if (c\
    \ == last_char) {\n            if (cur_char == '.') {\n                last_char_found\
    \ = true;\n                cur_char = c;\n            } else {\n             \
    \   if (!last_char_found)\n                    result.emplace_back(std::to_string(c));\n\
    \                last_char_found = false;\n            }\n        }\n        cur_char\
    \ = c;\n    }\n    if (!first_char_found)\n        result.emplace_back(std::to_string(last_char));\n\
    \    if (!last_char_found)\n        result.emplace_back(std::to_string(first_char));\n\
    \    return result;\n}\nint main() {\n    auto candidate = select_words;\n   \
    \ assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpfijtcttb: /tmp/tmpfijtcttb.cpp:60: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141061
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Write your\
    \ code here.\n    std::vector<std::vector<std::string>> words;\n    std::vector<std::string>\
    \ word;\n    std::vector<std::string> res;\n    res.push_back((std::string)\"\"\
    );\n    words.push_back(res);\n    auto ii = s.begin();\n    while(ii != s.end())\
    \ {\n        if(ii+n <= s.end()) {\n            word = s.substr(ii, n);\n    \
    \        if(words.find(word) == words.end()) {\n                words.push_back(word);\n\
    \                res.push_back(word);\n            }\n        }\n        ++ii;\n\
    \    }\n    return words;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0g7l6el7.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp0g7l6el7.cpp:29:29: error:\
    \ cannot convert \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018\
    long unsigned int\u2019}\n   29 |             word = s.substr(ii, n);\n      |\
    \                             ^~\n      |                             |\n    \
    \  |                             __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\nIn file included from /usr/include/c++/9/string:55,\n                 from\
    \ /usr/include/c++/9/bits/locale_classes.h:40,\n                 from /usr/include/c++/9/bits/ios_base.h:41,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0g7l6el7.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2838:24: note:\
    \   initializing argument 1 of \u2018std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::substr(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2838 |       substr(size_type __pos = 0, size_type __n = npos)\
    \ const\n      |              ~~~~~~~~~~^~~~~~~~~\n/tmp/tmp0g7l6el7.cpp:30:22:\
    \ error: \u2018class std::vector<std::vector<std::__cxx11::basic_string<char>\
    \ > >\u2019 has no member named \u2018find\u2019\n   30 |             if(words.find(word)\
    \ == words.end()) {\n      |                      ^~~~\n/tmp/tmp0g7l6el7.cpp:32:35:\
    \ error: no matching function for call to \u2018std:"
  stdout: ''
  timestamp: 1660141060
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.empty())\n\
    \        return std::vector<std::string>();\n    std::vector<std::string> ans;\n\
    \    std::string sub;\n    for (size_t i = 0; i < s.size(); ++i)\n        if (s[i]\
    \ == ' ') {\n            ans.push_back(sub);\n            sub = \"\";\n      \
    \  } else if (isalnum(s[i]) || s[i] == '_') {\n            sub += s[i];\n    \
    \    } else {\n            ans.push_back(sub);\n            sub = s[i];\n    \
    \    }\n    ans.push_back(sub);\n    if (n <= ans.size())\n        return ans;\n\
    \    return ans;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpnigufj99: /tmp/tmpnigufj99.cpp:41: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141062
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    std::vector<std::string> temp;\n    for(int i = 0; i < s.size(); i++)\
    \ {\n        if(s[i] == 'a') {\n            temp.clear();\n            temp.push_back((std::string)s.substr(i,\
    \ (n - 1)));\n            res.push_back(temp);\n            break;\n        }\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphnfsrq0t.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmphnfsrq0t.cpp:26:31: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(std::vector<std::__cxx11::basic_string<char> >&)\u2019\n   26 |\
    \             res.push_back(temp);\n      |                               ^\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphnfsrq0t.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >::value_type&&"
  stdout: ''
  timestamp: 1660141060
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ ret;\n    long i=0;\n    while(i < s.size()) {\n        long j=0;\n        while(j\
    \ < n){\n            if((s[i] >= 65 && s[i] <= 90) || (s[i] >= 97 && s[i] <= 122)){\n\
    \                i++;\n            }\n            else {\n                j++;\n\
    \            }\n        }\n        if(j == n) {\n            ret.push_back(std::string(s.substr(0,i)));\n\
    \            s.erase(0, i);\n        }\n    }\n    while(s.size()) {\n       \
    \ ret.push_back(std::string(s.substr(0,s.length())));\n        s.erase(0, s.length());\n\
    \    }\n    return ret;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpchbnknfv: /tmp/tmpchbnknfv.cpp:45: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141062
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ result;\n    // write your code here\n    for(auto it = s.begin(); it != s.end();\
    \ it++) {\n        for(auto j = n; j < s.size(); j++) {\n            if(*it ==\
    \ s[j] && std::isalpha(*it)) {\n                result.emplace_back(std::string{it});\n\
    \                break;\n            }\n        }\n        if(j == s.size()) {\n\
    \            result.emplace_back(std::string{it});\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmz994b4j.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpmz994b4j.cpp:25:51: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(<brace-enclosed\
    \ initializer list>)\u2019\n   25 |                 result.emplace_back(std::string{it});\n\
    \      |                                                   ^\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpmz994b4j.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2: note:\
    \ candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/move.h:55,\n                 from /usr/include/c++/9/bits/stl_pair.h:59,\n\
    \                 from /usr/include/c++/9/bits/stl_algobase.h:64,\n          \
    \       from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpmz994b4j.cpp:2:\n/usr/include/c++/9/type_traits:\
    \ In substitution of \u2018template<bool _Cond, class _Tp> using enable_if_t =\
    \ typename std::enable_if::type [with bool _Cond = std::integral_constant<bool,\
    \ false>::value; _Tp = void]\u2019:\n/usr/include/c++/9/bits/basic_string.h:121:8:\
    \   required by substit"
  stdout: ''
  timestamp: 1660141060
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n\tstd::vector<std::string>\
    \ words;\n\t\n\t// Your code here\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\
    \t\tif (s.at(i) == 'a' || s.at(i) == 'e' || s.at(i) == 'i' || s.at(i) == 'o' ||\
    \ s.at(i) == 'u' || s.at(i) == 'y')\n\t\t{\n\t\t\tif (s.at(i + 1) == 'a' || s.at(i\
    \ + 1) == 'e' || s.at(i + 1) == 'i' || s.at(i + 1) == 'o' || s.at(i + 1) == 'u'\
    \ || s.at(i + 1) == 'y')\n\t\t\t{\n\t\t\t\tif (s.at(i + 2) == 'a' || s.at(i +\
    \ 2) == 'e' || s.at(i + 2) == 'i' || s.at(i + 2) == 'o' || s.at(i + 2) == 'u'\
    \ || s.at(i + 2) == 'y')\n\t\t\t\t{\n\t\t\t\t\tif (s.at(i + 3) == 'a' || s.at(i\
    \ + 3) == 'e' || s.at(i + 3) == 'i' || s.at(i + 3) == 'o' || s.at(i + 3) == 'u'\
    \ || s.at(i + 3) == 'y')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s.at(i + 4) == 'a' || s.at(i\
    \ + 4) == 'e' || s.at(i + 4) == 'i' || s.at(i + 4) == 'o' || s.at(i + 4) == 'u'\
    \ || s.at(i + 4) == 'y')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (s.at(i + 5) == 'a'\
    \ || s.at(i + 5) == 'e' || s.at(i + 5) == 'i' || s.at(i + 5) == 'o' || s.at(i\
    \ + 5) == 'u' || s.at(i + 5) == 'y')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (s.at(i\
    \ + 6) == 'a' || s.at(i + 6) == 'e' || s.at(i + 6) == 'i' || s.at(i + 6) == 'o'\
    \ || s.at(i + 6) == 'u' || s.at(i + 6) == 'y')\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\
    \t\t\tif (s.at(i + 7) == 'a' || s.at(i + 7) == 'e' || s.at(i + 7) == 'i' || s.at(i\
    \ + 7) == 'o' || s.at(i + 7) == 'u' || s.at(i + 7) == 'y')\n\t\t\t\t\t\t\t\t\t\
    {\n\t\t\t\t\t\t\t\t\t\tif (s.at(i + 8) == 'a' || s.at(i + 8) == 'e' || s.at(i\
    \ + 8) == 'i' || s.at(i + 8) == 'o' || s.at(i + 8) == 'u' || s.at(i + 8) == 'y')\n\
    \t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (s.at(i + 9) == 'a' || s.at(i\
    \ + 9) == 'e' || s.at(i + 9) == 'i' || s.at(i + 9) == 'o' || s.at(i + 9) == '\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwsuyznwo.cpp:43:119: warning: missing terminating ' character\n\
    \   43 |            if (s.at(i + 9) == 'a' || s.at(i + 9) == 'e' || s.at(i + 9)\
    \ == 'i' || s.at(i + 9) == 'o' || s.at(i + 9) == '\n      |                  \
    \                                                                            \
    \                         ^\n/tmp/tmpwsuyznwo.cpp:43:119: error: missing terminating\
    \ ' character\n/tmp/tmpwsuyznwo.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpwsuyznwo.cpp:44:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n   44 | }\n      | ^\n\
    /tmp/tmpwsuyznwo.cpp:43:118: error: expected \u2018)\u2019 before \u2018}\u2019\
    \ token\n   43 |            if (s.at(i + 9) == 'a' || s.at(i + 9) == 'e' || s.at(i\
    \ + 9) == 'i' || s.at(i + 9) == 'o' || s.at(i + 9) == '\n      |             \
    \  ~                                                                         \
    \                             ^\n      |                                     \
    \                                                                            \
    \     )\n   44 | }\n      | ~                                                \
    \                                                                     \n/tmp/tmpwsuyznwo.cpp:44:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   44 | }\n \
    \     | ^\n/tmp/tmpwsuyznwo.cpp:45:12: error: a function-definition is not allowed\
    \ here before \u2018{\u2019 token\n   45 | int main() {\n      |            ^\n\
    /tmp/tmpwsuyznwo.cpp:54:1: error: expected \u2018}\u2019 at end of input\n   54\
    \ | }\n      | ^\n/tmp/tmpwsuyznwo.cpp:40:10: note: to match this \u2018{\u2019\
    \n   40 |          {\n      |          ^\n/tmp/tmpwsuyznwo.cpp:54:1: error: expected\
    \ \u2018}\u2019 at end of input\n   54 | }\n      | ^\n/tmp/tmpwsuyznwo.cpp:38:9:\
    \ note: to match this \u2018{\u2019\n   38 |         {\n      |         ^\n/tmp/tmpwsuyznwo.cpp:54:1:\
    \ error: expected \u2018}\u2019 at end of input\n   54 | }\n      | ^\n/tmp/tmpwsuyznwo.cpp:36:8:\
    \ note: to match this \u2018{\u2019\n   36 |        {\n      |        ^\n/tmp/tmpwsuyznwo.cpp:54:1:\
    \ error: expected \u2018}\u2019 at en"
  stdout: ''
  timestamp: 1660141060
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector\
    \ < std::pair <std::string,int> > v;\n    for(size_t i = 0; i < s.length(); i++)\
    \ {\n        for(int j = 0; j < s.length(); j++) {\n            if(s.at(i) ==\
    \ s.at(j)) {\n                v.push_back({s.substr(0, i), 1});\n            }\n\
    \        }\n    }\n    sort(v.begin(), v.end(), [] (std::pair <std::string,int>\
    \ p1, std::pair <std::string,int> p2) {\n        return p1.second < p2.second;\n\
    \    });\n    long count = 0;\n    for(size_t i = 0; i < v.size(); i++) {\n  \
    \      if(v[i].second == n) {\n            count++;\n        }\n    }\n    if(s.empty())\
    \ {\n        return {};\n    }\n    std::vector<std::string> ans;\n    for(int\
    \ i = 0; i < count; i++) {\n        std::string t;\n        for(size_t j = 0;\
    \ j < s.length(); j++) {\n            if(s.at(j) == v[i].first.at(0)) {\n    \
    \            t += s.substr(0, j);\n            }\n        }\n        if(!t.empty())\
    \ {\n            ans.push_back(t);\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp5in9yy_b: /tmp/tmp5in9yy_b.cpp:56: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141063
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  for(char c: s)\n    if(c=='a' || c=='e' || c=='i' || c=='o' || c=='u'\
    \ || c==' ')\n      v.push_back(std::to_string(c));\n  sort(v.begin(),v.end());\n\
    \  for(auto it=v.begin();it!=v.end();it++)\n    for(long i=0;i<n;i++)\n      if(std::find(*it,*it+i)!=std::find(*it,*it+i+1))\n\
    \        v.erase(it);\n  return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3xbb3hdr.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp3xbb3hdr.cpp:27:27: error:\
    \ no match for \u2018operator+\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018long int\u2019)\n   27 |       if(std::find(*it,*it+i)!=std::find(*it,*it+i+1))\n\
    \      |                        ~~~^~\n      |                        |   |\n\
    \      |                        |   long int\n      |                        std::__cxx11::basic_string<char>\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp3xbb3hdr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp3xbb3hdr.cpp:27:28:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018long int\u2019\n   27 |       if(std::find(*it,*it+i)!=std::find(*it,*it+i+1))\n\
    \      |                            ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp3xbb3hdr.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1216:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::move_iterator<_IteratorL>\
    \ std::operator+(typename std::move_iterator<_IteratorL>::difference_type, const\
    \ std::move_iterator<_IteratorL>&)\u2019\n 1216 |     "
  stdout: ''
  timestamp: 1660141060
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  // Fill this in.\n  return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp__ouovtg: /tmp/tmp__ouovtg.cpp:26: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141062
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Fill this\
    \ in.\n    std::vector<std::string> ans;\n    std::map<long, std::set<std::string>\
    \ > word_set;\n    for ( auto &c : s ) {\n        word_set.emplace( std::hash<std::string>{}(\
    \ c ), {} );\n    }\n    for ( auto &kv : word_set ) {\n        if ( n-- > 0 )\
    \ {\n            continue;\n        }\n        if ( kv.second.size() == 0 ) {\n\
    \            ans.emplace_back( std::move(kv.first) );\n        }\n        for\
    \ ( auto &c : kv.second ) {\n            kv.second.erase( c );\n        }\n  \
    \  }\n    return ans;\n}\nint main() {\n    auto candidate = select_words;\n \
    \   assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyzlncbfk.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpyzlncbfk.cpp:24:55: error:\
    \ no match for call to \u2018(std::hash<std::__cxx11::basic_string<char> >) (char&)\u2019\
    \n   24 |         word_set.emplace( std::hash<std::string>{}( c ), {} );\n   \
    \   |                                                       ^\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpyzlncbfk.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6737:7: note:\
    \ candidate: \u2018std::size_t std::hash<std::__cxx11::basic_string<char> >::operator()(const\
    \ string&) const\u2019\n 6737 |       operator()(const string& __s) const noexcept\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:6737:32: note:\
    \   no known conversion for argument 1 from \u2018char\u2019 to \u2018const string&\u2019\
    \ {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 6737 |       operator()(const\
    \ string& __s) const noexcept\n      |                  ~~~~~~~~~~~~~~^~~\nIn\
    \ file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:"
  stdout: ''
  timestamp: 1660141061
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::sort(s.begin(),\
    \ s.end());\n    std::vector<std::string> v;\n    v.emplace_back(\"\");\n    for(long\
    \ i = std::min(s.length(), n); i > 0; i--){\n        if(s[i - 1] == ' ' || s[i\
    \ - 1] == '\\0' || s[i - 1] == '\\t' || s[i - 1] == '\\n' || s[i - 1] == '\\r')\
    \ {\n            v.emplace_back(s[i - 1]);\n        } else {\n            for(char\
    \ ch : s) {\n                if(ch != ' ' && ch != '\\t' && ch != '\\n' && ch\
    \ != '\\r') {\n                    if(ch == s[i - 1])\n                      \
    \  v.emplace_back(s[i - 1]);\n                    break;\n                }\n\
    \            }\n        }\n    }\n    return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmz72c3bp.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpmz72c3bp.cpp:23:40: error:\
    \ no matching function for call to \u2018min(std::__cxx11::basic_string<char>::size_type,\
    \ long int&)\u2019\n   23 |     for(long i = std::min(s.length(), n); i > 0; i--){\n\
    \      |                                        ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpmz72c3bp.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:198:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpmz72c3bp.cpp:23:40: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long unsigned\
    \ int\u2019 and \u2018long int\u2019)\n   23 |     for(long i = std::min(s.length(),\
    \ n); i > 0; i--){\n      |                                        ^\nIn file\
    \ included from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpmz72c3bp.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpmz72c3bp.cpp:23:40:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long unsigned int\u2019 and \u2018long int\u2019)\n   23 |     for(long i = std::min(s.length(),\
    \ n); i > 0; i--){\n      |                                        ^\nIn file\
    \ included from /usr/include/c++/9/algori"
  stdout: ''
  timestamp: 1660141060
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.empty())\
    \ {\n        return {};\n    }\n    std::vector<std::string> res;\n    auto begin\
    \ = s.begin();\n    auto end = s.end();\n    for (; begin != end && n != 0; n--)\
    \ {\n        if (std::isalpha(*begin)) {\n            auto pos = find(begin, end,\
    \ ' ');\n            if (pos != end) {\n                res.emplace_back(std::string(begin,\
    \ pos));\n                begin = pos + 1;\n            } else {\n           \
    \     res.emplace_back(std::string(begin, pos));\n                begin = pos\
    \ + 1;\n            }\n        }\n    }\n    return res;\n}\nint main() {\n  \
    \  auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmptbvammjv: /tmp/tmptbvammjv.cpp:42: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141062
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n\t// Write your\
    \ code here\n\t// code here\n\t// code here\n\t// code here\n\treturn {};\n}\n\
    int main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary\
    \ had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp_hznhuhh: /tmp/tmp_hznhuhh.cpp:28: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141062
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    if (s.length() == 0) {\n        return v;\n    }\n    // Write your\
    \ code here.\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp6xdf4yqp: /tmp/tmp6xdf4yqp.cpp:29: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141062
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  // Your code here\n  \n  return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpg5o8xcmm: /tmp/tmpg5o8xcmm.cpp:27: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141062
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::set<std::string>\
    \ words;\n    std::string word = \"\";\n    while(!s.empty()) {\n        word\
    \ = s.substr(0, s.size() - 1);\n        if(word.find_first_of(\"aeiou\") == std::string::npos)\
    \ {\n            words.insert(word);\n        }\n        s = s.substr(0, s.size()\
    \ - 1);\n    }\n    std::vector<std::string> ans;\n    for(std::string word :\
    \ words) {\n        if(word.size() == n) {\n            ans.push_back(word);\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp7jqhoe02: /tmp/tmp7jqhoe02.cpp:39: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141062
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ ret;\n    assert(s.size() > 0);\n    // TODO : your code goes here\n    return\
    \ ret;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpu52hr7sg: /tmp/tmpu52hr7sg.cpp:27: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141061
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    if (s.empty()) {\n        return v;\n    }\n    std::string vowels =\
    \ \"aeiou\";\n    std::string consonants = \"bcdfghjklmnpqrstvwxyz\";\n    \n\
    \    // Iterate through all the characters in s\n    for (char c: s) {\n     \
    \   // Check if current char is a consonant\n        if (std::find(consonants.begin(),\
    \ consonants.end(), c) == consonants.end()) {\n            // Check if current\
    \ char is vowel\n            if (std::find(vowels.begin(), vowels.end(), c) ==\
    \ vowels.end()) {\n                v.push_back((std::string)s);\n            \
    \    break;\n            }\n        }\n    }\n    // Remove consonants \n    while\
    \ (v.size() > n) {\n        v.pop_back();\n    }\n    return v;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmphx1f_7dx: /tmp/tmphx1f_7dx.cpp:46: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141061
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ ans;\n  assert(!s.empty());\n  // Initialize a boolean array for each of characters\
    \ in the string\n  // Initialize all values to false, for initialization of arrays\n\
    \  bool b[26] = { false };\n  // Traverse the string and populate the boolean\
    \ array b accordingly\n  for (size_t i = 0; i != s.size(); ++i) {\n    int c =\
    \ s[i];\n    // If b[s[i]] was false then it must have been a vowel so increment\
    \ i\n    if (!b[c]) {\n      i = i + 1;\n    }\n    // If b[s[i]] was true, it\
    \ must have been a consonant so decrement i\n    if (b[c]) {\n      i = i - 1;\n\
    \    }\n    // If we've reached the vowel count or we reached the consonant count,\
    \ \n    // increment the array at index c by 1\n    if (c == 0 || c == 26 - 1)\
    \ {\n      b[c] = true;\n    }\n  }\n  // Return only the elements of the array\
    \ that correspond to consonants\n  for (int i = 0; i != 26; ++i) {\n    if (b[i])\
    \ {\n      ans.push_back(std::to_string(i));\n    }\n  }\n  // Return an empty\
    \ vector if nothing is found\n  return ans;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpb5r_kc1r: /tmp/tmpb5r_kc1r.cpp:53: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141063
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n\tassert(n >=\
    \ 0 && n <= s.size());\n\tstd::vector<std::string> res;\n\tstd::string temp;\n\
    \tlong index = -1;\n\twhile (s.size() > 0) {\n\t\ttemp = s.substr(0, 1);\n\t\t\
    if (temp == \"a\") {\n\t\t\tres.push_back(s.substr(1, n));\n\t\t\tbreak;\n\t\t\
    }\n\t\tif (temp == \" \")\n\t\t\tindex = -1;\n\t\ts = std::string(s.begin() +\
    \ index + 1, s.end());\n\t}\n\treturn res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660141066
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ words;\n  if (s == \"\") {\n    return words;\n  }\n\n  unordered_map<char,\
    \ bool> char_count;\n  char_count.set_max_size(s.size());\n  char* buffer = s.c_str();\n\
    \  char* current = buffer;\n  while (current < buffer + s.size()) {\n    current\
    \ = strchr(current, ' ');\n    if (current == nullptr) {\n      current = (char*)nullptr;\n\
    \    }\n    assert(current != nullptr);\n    (*char_count)[*(current)] = true;\n\
    \    ++current;\n  }\n  char* next_word = buffer;\n  std::string word;\n  while\
    \ (next_word != buffer + s.size()) {\n    if (*char_count.find(*next_word) ==\
    \ char_count[*next_word]) {\n      word.assign(next_word, next_word + strlen(next_word));\n\
    \      words.push_back(word);\n    }\n    ++next_word;\n  }\n  if (n > 0) {\n\
    \    std::vector<std::string> sub_words;\n    for (auto iter = words.begin();\
    \ iter != words.end(); ++iter) {\n      if (n--) {\n        sub_words.push_back(*iter);\n\
    \      }\n    }\n    return sub_words;\n  }\n  return words;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpalsk3xvo.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpalsk3xvo.cpp:25:3: error:\
    \ \u2018unordered_map\u2019 was not declared in this scope\n   25 |   unordered_map<char,\
    \ bool> char_count;\n      |   ^~~~~~~~~~~~~\n/tmp/tmpalsk3xvo.cpp:25:3: note:\
    \ suggested alternatives:\nIn file included from /usr/include/c++/9/unordered_map:47,\n\
    \                 from /usr/include/c++/9/functional:61,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpalsk3xvo.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:102:11:\
    \ note:   \u2018std::unordered_map\u2019\n  102 |     class unordered_map\n  \
    \    |           ^~~~~~~~~~~~~\nIn file included from /usr/include/c++/9/functional:61,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpalsk3xvo.cpp:2:\n/usr/include/c++/9/unordered_map:68:13:\
    \ note:   \u2018std::pmr::unordered_map\u2019\n   68 |       using unordered_map\n\
    \      |             ^~~~~~~~~~~~~\n/tmp/tmpalsk3xvo.cpp:25:17: error: expected\
    \ primary-expression before \u2018char\u2019\n   25 |   unordered_map<char, bool>\
    \ char_count;\n      |                 ^~~~\n/tmp/tmpalsk3xvo.cpp:26:3: error:\
    \ \u2018char_count\u2019 was not declared in this scope\n   26 |   char_count.set_max_size(s.size());\n\
    \      |   ^~~~~~~~~~\n/tmp/tmpalsk3xvo.cpp:27:25: error: invalid conversion from\
    \ \u2018const char*\u2019 to \u2018char*\u2019 [-fpermissive]\n   27 |   char*\
    \ buffer = s.c_str();\n      |                  ~~~~~~~^~\n      |           \
    \              |\n      |                         const char*\n"
  stdout: ''
  timestamp: 1660141061
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    if(s.empty()) return v;\n    \n    for(auto it = s.begin(); it != s.end();\
    \ it++) {\n        for(long i = 0; i < n; i++) {\n            if((*it) == ' ')\
    \ break;\n            else (*it) = ' ';\n        }\n        v.push_back(*it);\n\
    \    }\n    \n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5xe7uzyc.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp5xe7uzyc.cpp:28:24: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   28 |         v.push_back(*it);\n      |      \
    \                  ^\nIn file included from /usr/include/c++/9/vector:67,\n  \
    \               from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5xe7uzyc.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660141060
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    for(auto i : s){\n        if( isalpha(i) || isspace(i)){\n         \
    \   v.push_back(i);\n        }\n    }\n    return v;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgrhgc4a7.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpgrhgc4a7.cpp:23:26: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   23 |             v.push_back(i);\n      |    \
    \                      ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgrhgc4a7.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660141061
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  \n  // Write your code here\n  if(s.size() == 0) {\n    return v;\n  }\n\
    \  \n  std::vector<std::string>::iterator iter;\n  std::string word;\n  \n  for(iter\
    \ = s.begin(); iter != s.end(); iter++) {\n    word = *iter;\n    if(n == 1) {\n\
    \      v.push_back((std::move(word)));\n    }\n    \n    bool found = false;\n\
    \    for(int i = word.size() - 1; i >= 0; i--) {\n      char ch = word[i];\n \
    \     \n      if(isalpha(ch)) {\n        if(isupper(ch)) {\n          continue;\n\
    \        }\n      }\n      \n      if(ch == ' ') {\n        if(found == true)\
    \ {\n          break;\n        }\n        else {\n          found = true;\n  \
    \      }\n      }\n      \n      else {\n        found = true;\n        break;\n\
    \      }\n    }\n  }\n  \n  return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7q3gp55u.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp7q3gp55u.cpp:30:22: error:\
    \ no match for \u2018operator=\u2019 (operand types are \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019} and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   30 |   for(iter = s.begin(); iter != s.end(); iter++) {\n    \
    \  |                      ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp7q3gp55u.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:784:11:\
    \ note: candidate: \u2018constexpr __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >& __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >::operator=(const __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&)\u2019\n  784 |     class\
    \ __normal_iterator\n      |           ^~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:784:11:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019} to \u2018const __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >&\u2019\n/usr/include/c++/9/bits/stl_iterator.h:784:11:\
    \ note: candidate: \u2018constexpr __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >& __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std:"
  stdout: ''
  timestamp: 1660141061
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    if (s.empty()) {\n        return v;\n    }\n    string word;\n    for\
    \ (size_t i = 0; i < s.size(); i++) {\n        word = s.substr(i, 1);\n      \
    \  v.push_back(word);\n        if (word.size() == n) {\n            break;\n \
    \       }\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk5p5lev4.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpk5p5lev4.cpp:24:5: error:\
    \ \u2018string\u2019 was not declared in this scope\n   24 |     string word;\n\
    \      |     ^~~~~~\n/tmp/tmpk5p5lev4.cpp:24:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpk5p5lev4.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpk5p5lev4.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmpk5p5lev4.cpp:26:9: error: \u2018word\u2019 was not declared in this scope\n\
    \   26 |         word = s.substr(i, 1);\n      |         ^~~~\n"
  stdout: ''
  timestamp: 1660141061
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // code goes\
    \ here\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpqmzt3w5f: /tmp/tmpqmzt3w5f.cpp:24: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141063
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ result;\n  for(long i=0; i< s.size(); i++) {\n    if(s[i] != 'a' && s[i] !=\
    \ 'e' && s[i] != 'i' &&  s[i] != 'o' && s[i] != 'u' && s[i] != 'y' && s[i] !=\
    \ 'h')\n      continue;\n    result.push_back(s.substr(0, i+1));\n    result.push_back(s.substr(i+1));\n\
    \  }\n  for(long i=0; i< s.size(); i++) {\n    if(s[i] != 'a' && s[i] != 'e' &&\
    \ s[i] != 'i' &&  s[i] != 'o' && s[i] != 'u' && s[i] != 'y' && s[i] != 'h')\n\
    \      continue;\n    if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] ==\
    \ 'o' || s[i] == 'u' || s[i] == 'y' || s[i] == 'h')\n      continue;\n    if(s[i]\
    \ == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' || s[i] ==\
    \ 'y' || s[i] == 'h') {\n      continue;\n    }\n    if((n-1)==0) {\n      result.push_back(s.substr(0,\
    \ i+1));\n      result.push_back(s.substr(i+1));\n    }\n  }\n  if(s.size()==0)\
    \ {\n    result.push_back(s);\n  }\n  return result;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpfdbpj1sv: /tmp/tmpfdbpj1sv.cpp:47: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141062
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    // ++itr; \n    for (std::string::iterator itr = s.begin(); itr != s.end();\
    \ ++itr) {\n        // ++itr; \n        if ((*itr)[0] == (*itr)[1] && (*itr)[1]\
    \ == (*itr)[2] && (*itr)[2] == (*itr)[3]) {\n            v.push_back(std::string(s,\
    \ itr));\n        }\n    }\n    return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm0z_o46g.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpm0z_o46g.cpp:24:21: error:\
    \ invalid types \u2018char[int]\u2019 for array subscript\n   24 |         if\
    \ ((*itr)[0] == (*itr)[1] && (*itr)[1] == (*itr)[2] && (*itr)[2] == (*itr)[3])\
    \ {\n      |                     ^\n/tmp/tmpm0z_o46g.cpp:24:34: error: invalid\
    \ types \u2018char[int]\u2019 for array subscript\n   24 |         if ((*itr)[0]\
    \ == (*itr)[1] && (*itr)[1] == (*itr)[2] && (*itr)[2] == (*itr)[3]) {\n      |\
    \                                  ^\n/tmp/tmpm0z_o46g.cpp:24:47: error: invalid\
    \ types \u2018char[int]\u2019 for array subscript\n   24 |         if ((*itr)[0]\
    \ == (*itr)[1] && (*itr)[1] == (*itr)[2] && (*itr)[2] == (*itr)[3]) {\n      |\
    \                                               ^\n/tmp/tmpm0z_o46g.cpp:24:60:\
    \ error: invalid types \u2018char[int]\u2019 for array subscript\n   24 |    \
    \     if ((*itr)[0] == (*itr)[1] && (*itr)[1] == (*itr)[2] && (*itr)[2] == (*itr)[3])\
    \ {\n      |                                                            ^\n/tmp/tmpm0z_o46g.cpp:24:73:\
    \ error: invalid types \u2018char[int]\u2019 for array subscript\n   24 |    \
    \     if ((*itr)[0] == (*itr)[1] && (*itr)[1] == (*itr)[2] && (*itr)[2] == (*itr)[3])\
    \ {\n      |                                                                 \
    \        ^\n/tmp/tmpm0z_o46g.cpp:24:86: error: invalid types \u2018char[int]\u2019\
    \ for array subscript\n   24 |         if ((*itr)[0] == (*itr)[1] && (*itr)[1]\
    \ == (*itr)[2] && (*itr)[2] == (*itr)[3]) {\n      |                         \
    \                                                             ^\n/tmp/tmpm0z_o46g.cpp:25:43:\
    \ error: no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(std::string&,\
    \ std::__cxx11::basic_string<char>::iterator&)\u2019\n   25 |             v.push_back(std::string(s,\
    \ itr));\n      |                                           ^\nIn file included\
    \ from /usr/include/c++/9/string:55,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/"
  stdout: ''
  timestamp: 1660141061
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    \n    std::vector<std::string>\
    \ ret;\n    if (s.size() == 0)\n    {\n        return ret;\n    }\n    \n    std::string::size_type\
    \ len = s.size();\n    std::vector<std::string> curr;\n    \n    for (std::string::size_type\
    \ i = 0; i < len; i++)\n    {\n        std::string::size_type found = -1;\n  \
    \      for (std::string::size_type j = 0; j < n; j++)\n        {\n           \
    \ found = s.find_first_of(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\", found);\n\
    \            if (found != std::string::npos)\n            {\n                curr.push_back((std::string(s.begin()\
    \ + found, s.end())));\n                break;\n            }\n        }\n   \
    \     if (found != std::string::npos)\n        {\n            ret.push_back(curr);\n\
    \            curr.resize(0);\n        }\n    }\n    \n    return ret;\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcvnyxzju.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpcvnyxzju.cpp:44:31: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(std::vector<std::__cxx11::basic_string<char> >&)\u2019\n   44 |\
    \             ret.push_back(curr);\n      |                               ^\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcvnyxzju.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >::value_type&&"
  stdout: ''
  timestamp: 1660141061
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ vs;\n    std::string word = \"\";\n    for (char ch : s) {\n        if (ch ==\
    \ ' ') continue;\n        if ((ch.isupper() || ch.isdigit()) && n > 0) {\n   \
    \         word += ch;\n        } else {\n            if (word.length() == 0) {\n\
    \                v.push_back(word);\n                word = \"\";\n          \
    \  } else {\n                if (word.length() == n) {\n                    vs.push_back(word);\n\
    \                    word = \"\";\n                }\n            }\n        }\n\
    \    }\n    if (word.length() > 0) {\n        vs.push_back(word);\n    }\n   \
    \ return vs;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6qqpq6nt.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp6qqpq6nt.cpp:24:17: error:\
    \ request for member \u2018isupper\u2019 in \u2018ch\u2019, which is of non-class\
    \ type \u2018char\u2019\n   24 |         if ((ch.isupper() || ch.isdigit()) &&\
    \ n > 0) {\n      |                 ^~~~~~~\n/tmp/tmp6qqpq6nt.cpp:24:33: error:\
    \ request for member \u2018isdigit\u2019 in \u2018ch\u2019, which is of non-class\
    \ type \u2018char\u2019\n   24 |         if ((ch.isupper() || ch.isdigit()) &&\
    \ n > 0) {\n      |                                 ^~~~~~~\n/tmp/tmp6qqpq6nt.cpp:28:17:\
    \ error: \u2018v\u2019 was not declared in this scope; did you mean \u2018vs\u2019\
    ?\n   28 |                 v.push_back(word);\n      |                 ^\n   \
    \   |                 vs\n"
  stdout: ''
  timestamp: 1660141061
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ words;\n    \n    if(s.length() == 0) {\n        words.emplace_back(\"\");\n\
    \    }\n    \n    for(int i = 0; i < s.length(); ++i) {\n        if(s.at(i) ==\
    \ 'a' ||\n           s.at(i) == 'e' ||\n           s.at(i) == 'i' ||\n       \
    \    s.at(i) == 'o' ||\n           s.at(i) == 'u') {\n            words.emplace_back(s.substr(i,\
    \ 1));\n        }\n    }\n    \n    return words;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp4r98n4ty: /tmp/tmp4r98n4ty.cpp:40: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141062
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ word_set;\n  // Your code goes here\n  if(s.empty())\n    return word_set;\n\
    \  for (size_t i = 0; i < s.size(); i++) {\n    if(s[i] == 'a' || s[i] == 'e'\
    \ || s[i] == 'i' || s[i] == 'o' || s[i] == 'u')\n    {\n      if(s[i] == ' ' ||\
    \ s[i] == '.')\n      {\n        word_set.push_back(\"$\");\n      }\n      else\
    \ if(n == 1)\n      {\n        word_set.push_back(s.substr(0, i));\n      }\n\
    \      else\n      {\n        word_set.push_back(i);\n      }\n    }\n  }\n  return\
    \ word_set;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppuzs61xm.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmppuzs61xm.cpp:37:29: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(size_t&)\u2019\n   37 |         word_set.push_back(i);\n      |\
    \                             ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppuzs61xm.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018size_t\u2019 {aka \u2018\
    long unsigned int\u2019} to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018size_t\u2019 {aka \u2018\
    long unsigned int\u2019} to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       "
  stdout: ''
  timestamp: 1660141061
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    if (s.size() == 0) return v;\n    // Step 1: count the number of consonants\
    \ in s\n    int count[26];\n    for (char c : s) {\n        count[c -'a']++;\n\
    \    }\n    // Step 2: copy string s with n consonants removed\n    for (int i=0;i<s.size();i++)\
    \ {\n        if (count[s[i] - 'a'] == n) v.push_back(s.substr(i, i - 1));\n  \
    \  }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n   \
    \ assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660141063
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.empty())\n\
    \        return std::vector<std::string>();\n    // your code goes here\n    std::vector<std::string>\
    \ s;\n    \n    for (std::size_t i = 0; i != s.size() - n; i++) {\n        std::size_t\
    \ count = 0;\n        for (std::size_t j = 0; j != s.size(); j++) {\n        \
    \    if (s[j] == s[i + n]) {\n                count++;\n                if (count\
    \ == n) {\n                    s.push_back(s.substr(i, j + 1 - i));\n        \
    \        }\n            }\n        }\n    }\n    return s;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpko5fsf8h.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpko5fsf8h.cpp:23:30: error:\
    \ declaration of \u2018std::vector<std::__cxx11::basic_string<char> > s\u2019\
    \ shadows a parameter\n   23 |     std::vector<std::string> s;\n      |      \
    \                        ^\n/tmp/tmpko5fsf8h.cpp:31:35: error: \u2018class std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 has no member named \u2018substr\u2019\n   31 |                    \
    \ s.push_back(s.substr(i, j + 1 - i));\n      |                              \
    \     ^~~~~~\n"
  stdout: ''
  timestamp: 1660141060
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n// Define an auxiliary\
    \ function that is true if a letter is a consonant, otherwise false.\nbool isConsonant(char\
    \ c){\nreturn ((c>='A' && c<='Z') || (c>='a' && c<='z') || (c>='0' && c<='9')\
    \ || c==' ');\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzi04s_pm.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpzi04s_pm.cpp:21:25: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   21\
    \ | bool isConsonant(char c){\n      |                         ^\n/tmp/tmpzi04s_pm.cpp:24:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   24 | int main() {\n      |            ^\n/tmp/tmpzi04s_pm.cpp:33:1: error:\
    \ expected \u2018}\u2019 at end of input\n   33 | }\n      | ^\n/tmp/tmpzi04s_pm.cpp:19:62:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> select_words(std::string\
    \ s, long n) {\n      |                                                      \
    \        ^\n/tmp/tmpzi04s_pm.cpp:33:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   33 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141061
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Write your\
    \ code here\n    std::vector<std::string> word_to_select;\n    for(size_t i =\
    \ 0; i < s.length(); i++) {\n        for(int k = 0; k < s.size(); k++) {\n   \
    \         if(s[i] ==s[k] && s[i] !=' ' && !isprint(s[i]) && !isspace(s[i])) {\n\
    \                if(s.size() - i > n) {\n                    word_to_select.push_back(s.substr(i,\
    \ s.size() - i));\n                }\n                \n            }\n      \
    \  }\n    }\n    return word_to_select;\n}\nint main() {\n    auto candidate =\
    \ select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpsqx4l2xr: /tmp/tmpsqx4l2xr.cpp:36: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141062
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  assert(!s.empty());\n\
    \  std::vector<std::string> v;\n  int n = s.size();\n  char c;\n  for(int i=0;\
    \ i<n; i++) {\n    c = s[i];\n    // Check if the current letter is in consonants\n\
    \    if(isalpha(c)) {\n      if(isupper(c)) {\n        // If current letter is\
    \ upper case, then the letter is not a consonant\n        continue;\n      }\n\
    \      // The current letter is consonant, check if it is the last letter of the\
    \ word\n      if(i == n-1) {\n        // If the letter is the last letter, then\
    \ it is a consonant word\n        v.push_back((std::string)s.substr(i, i+1));\n\
    \      } else {\n        // Else, the letter is not a consonant word\n       \
    \ v.push_back((std::string)s.substr(i, i+1));\n      }\n    } else {\n      //\
    \ If current letter is not a consonant, then it is a vowel\n      continue;\n\
    \    }\n  }\n  return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5pzyc_z0.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp5pzyc_z0.cpp:22:7: error:\
    \ declaration of \u2018int n\u2019 shadows a parameter\n   22 |   int n = s.size();\n\
    \      |       ^\n"
  stdout: ''
  timestamp: 1660141061
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ results;\n    std::string::size_type start = 0;\n    std::string::size_type\
    \ end = 0;\n    std::string word = \"\";\n    while (n-- != 0) {\n        end\
    \ = s.find(\" \", start);\n        if (end == std::string::npos) {\n         \
    \   end = s.size();\n        }\n        word = s.substr(start, end - start);\n\
    \        results.push_back(word);\n        start = end + 1;\n    }\n    return\
    \ results;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp7iskej4j: /tmp/tmp7iskej4j.cpp:37: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141063
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.empty())\n\
    \        return std::vector< std::string >();\n    \n    std::vector<std::string>\
    \ v;\n    \n    for (int i = 0; i < s.size() && n > 0; i++) {\n        if (s[i]\
    \ >= 'a' && s[i] <= 'z') {\n            if (s[i] - 'a' == n)\n               \
    \ v.push_back(s.substr(i, i - n));\n            if (s[i] - 'a' > n)\n        \
    \        n = s[i] - 'a';\n        }\n    }\n    \n    return v;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp1p5c2c6q: /tmp/tmp1p5c2c6q.cpp:38: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141063
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  long count =\
    \ 0;\n  vector<string> ans;\n  long temp;\n  for (int i = 0; i < s.size(); i++)\
    \ {\n    if (s[i] == ' ')\n      continue;\n    for (int j = 0; j < n; j++) {\n\
    \      temp++;\n      if (s[i] == s[j]) {\n        count++;\n        ans.push_back(string(1,\
    \ s[i]));\n      }\n    }\n  }\n  if (count == 0)\n    return ans;\n  else\n \
    \   return ans;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5y9u5cp8.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp5y9u5cp8.cpp:21:3: error:\
    \ \u2018vector\u2019 was not declared in this scope\n   21 |   vector<string>\
    \ ans;\n      |   ^~~~~~\n/tmp/tmp5y9u5cp8.cpp:21:3: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5y9u5cp8.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5y9u5cp8.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp5y9u5cp8.cpp:21:10:\
    \ error: \u2018string\u2019 was not declared in this scope\n   21 |   vector<string>\
    \ ans;\n      |          ^~~~~~\n/tmp/tmp5y9u5cp8.cpp:21:10: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp5y9u5cp8.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |    "
  stdout: ''
  timestamp: 1660141062
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Write your\
    \ code here\n    std::vector<std::string> v;\n    for(size_t i = 0;i<s.size();++i)\n\
    \    {\n        for(size_t j = 0;j<s.size();++j)\n        {\n            if((s[i]==s[j])&&!(s[i]==\"\
    \ \"))\n            {\n                if(s[j-1]==' ')\n                {\n  \
    \                  v.push_back(s.substr(i,n));\n                }\n          \
    \      else if(s[j]==' ')\n                {\n                    v.push_back(s.substr(i,n));\n\
    \                }\n            }\n        }\n    }\n    return v;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcibpn1_8.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpcibpn1_8.cpp:26:38: error:\
    \ ISO C++ forbids comparison between pointer and integer [-fpermissive]\n   26\
    \ |             if((s[i]==s[j])&&!(s[i]==\" \"))\n      |                    \
    \                  ^~~\n"
  stdout: ''
  timestamp: 1660141062
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  v.push_back(s);\n  \n  for(long i = 0; i < s.size(); i++) {\n    v.push_back(\
    \ s[i].begin(), s[i].end() );\n  }\n  return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0mqw12ew.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp0mqw12ew.cpp:24:23: error:\
    \ request for member \u2018begin\u2019 in \u2018s.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |     v.push_back( s[i].begin(),\
    \ s[i].end() );\n      |                       ^~~~~\n/tmp/tmp0mqw12ew.cpp:24:37:\
    \ error: request for member \u2018end\u2019 in \u2018s.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   24 |     v.push_back( s[i].begin(),\
    \ s[i].end() );\n      |                                     ^~~\n"
  stdout: ''
  timestamp: 1660141062
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    if(s.empty())\n        return v;\n    \n    int i = 0;\n    \n    while(i\
    \ != s.size()) {\n        // count how many times consonant i occurs \n      \
    \  int c = count(s.begin(), s.end(), s[i]);\n        // add all words that contains\
    \ exactly n consonants\n        if(c >= n)\n            v.push_back(s.substr(i,\
    \ c - i));\n        \n        i += 1;\n    }\n    \n    return v;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpbi1f1nom: /tmp/tmpbi1f1nom.cpp:40: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141063
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    if (s.empty()) \n        return v;\n    long pos = 0;\n    while (pos\
    \ < s.length()) {\n        if ( s[pos] != \"a\" && s[pos] != \"e\" && s[pos] !=\
    \ \"i\" && s[pos] != \"o\" && \n            s[pos] != \"u\" && s[pos] != \"y\"\
    \ && s[pos] !=\"y\" && s[pos] != \"s\" && \n            s[pos] != \"a\" && s[pos]\
    \ != \"e\" && s[pos] != \"i\" && s[pos] != \"o\" && \n            s[pos] != \"\
    u\" && s[pos] != \"y\" && s[pos] !=\"y\" && s[pos] != \"s\" && \n            s[pos]\
    \ != \"a\" && s[pos] != \"e\" && s[pos] != \"i\" && s[pos] != \"o\" && \n    \
    \        s[pos] != \"u\" && s[pos] != \"y\" && s[pos] !=\"y\" && s[pos] != \"\
    s\" ) {\n            v.push_back((std::string)s.substr(pos, 1));\n           \
    \ pos += 1;\n            while (pos < s.length() && s[pos] != \"a\" && s[pos]\
    \ != \"e\" && \n                s[pos] != \"i\" && s[pos] != \"o\" && s[pos] !=\
    \ \"u\" && s[pos] != \"y\" && \n                s[pos] !=\"y\" && s[pos] != \"\
    s\" && s[pos] != \"a\" && s[pos] != \"e\" && \n                s[pos] != \"i\"\
    \ && s[pos] != \"o\" && s[pos] != \"u\" && s[pos] != \"y\" && \n             \
    \   s[pos] !=\"y\" && s[pos] != \"s\" && s[pos] != \"a\" && s[pos] != \"e\" &&\
    \ \n                s[pos] != \"i\" && s[pos] != \"o\" && s[pos] != \"u\" && s[pos]\
    \ != \"y\" && \n                s[pos] !=\"y\" && s[pos] != \"s\" ) {\n      \
    \          pos += 1;\n            }\n            if (pos == s.length() && n ==\
    \ 1) \n                v.push_back((std::string)s.substr(pos, 1));\n        }\
    \ else {\n            pos += 1;\n        }\n    }\n    return v;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkj3nixjc.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpkj3nixjc.cpp:25:24: error:\
    \ ISO C++ forbids comparison between pointer and integer [-fpermissive]\n   25\
    \ |         if ( s[pos] != \"a\" && s[pos] != \"e\" && s[pos] != \"i\" && s[pos]\
    \ != \"o\" &&\n      |                        ^~~\n/tmp/tmpkj3nixjc.cpp:25:41:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   25 |         if ( s[pos] != \"a\" && s[pos] != \"e\" && s[pos] != \"i\" &&\
    \ s[pos] != \"o\" &&\n      |                                         ^~~\n/tmp/tmpkj3nixjc.cpp:25:58:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   25 |         if ( s[pos] != \"a\" && s[pos] != \"e\" && s[pos] != \"i\" &&\
    \ s[pos] != \"o\" &&\n      |                                                \
    \          ^~~\n/tmp/tmpkj3nixjc.cpp:25:75: error: ISO C++ forbids comparison\
    \ between pointer and integer [-fpermissive]\n   25 |         if ( s[pos] != \"\
    a\" && s[pos] != \"e\" && s[pos] != \"i\" && s[pos] != \"o\" &&\n      |     \
    \                                                                      ^~~\n/tmp/tmpkj3nixjc.cpp:26:23:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   26 |             s[pos] != \"u\" && s[pos] != \"y\" && s[pos] !=\"y\" && s[pos]\
    \ != \"s\" &&\n      |                       ^~~\n/tmp/tmpkj3nixjc.cpp:26:40:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   26 |             s[pos] != \"u\" && s[pos] != \"y\" && s[pos] !=\"y\" && s[pos]\
    \ != \"s\" &&\n      |                                        ^~~\n/tmp/tmpkj3nixjc.cpp:26:56:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   26 |             s[pos] != \"u\" && s[pos] != \"y\" && s[pos] !=\"y\" && s[pos]\
    \ != \"s\" &&\n      |                                                       \
    \ ^~~\n/tmp/tmpkj3nixjc.cpp:26:73: error: ISO C++ forbids comparison between pointer\
    \ and integer [-fpermissive]\n   26 |             s[pos] != \"u\" && s[pos] !=\
    \ \"y\" && s[pos] !=\"y\" && s[p"
  stdout: ''
  timestamp: 1660141063
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    if (s.size() == 0) return v;\n    v.push_back(s);\n    size_t count\
    \ = s.size();\n    std::vector<std::string> results;\n    for (size_t i = 0; i\
    \ < count; i++) {\n        std::string word = s.substr(0, i);\n        int letterCount\
    \ = 0;\n        for (const char& letter : word) {\n            if (letter == '\
    \ ' || letter == '.') continue;\n            if (letter == 'a' || letter == 'e'\
    \ || letter == 'i' || \n                letter == 'o' || letter == 'u' || letter\
    \ == 'A' || \n                letter == 'E' || letter == 'I' || letter == 'O'\
    \ || \n                letter == 'U') {\n                if (letterCount > n)\
    \ break;\n                v.push_back(word + letter);\n                letterCount++;\n\
    \            }\n        }\n        if (v.size() == n) {\n            results.push_back(v);\n\
    \            v.clear();\n        }\n    }\n    return results;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5a7zgjd7.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp5a7zgjd7.cpp:40:32: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(std::vector<std::__cxx11::basic_string<char> >&)\u2019\n   40 |\
    \             results.push_back(v);\n      |                                ^\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5a7zgjd7.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::vector<std::__cxx11::basic_string<char> >::value_type&"
  stdout: ''
  timestamp: 1660141063
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ res;\n  std::string word;\n  for (size_t i = 0; i < s.size(); i++) {\n    if\
    \ (s[i] == ' ') {\n      if (word != \"\" && res.size() >= n) {\n        res.push_back(word);\n\
    \      }\n      word = s[i] == ' ' ? \" \" : \"\";\n    } else {\n      word +=\
    \ s[i];\n    }\n  }\n  if (word != \"\" && res.size() >= n) {\n    res.push_back(word);\n\
    \  }\n  if (res.size() == 0) {\n    return std::vector<std::string>();\n  }\n\
    \  return res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp951mqbnb: /tmp/tmp951mqbnb.cpp:42: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141065
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  if (n == 0) {\n    v.push_back(\"\");\n  } else if (s[0] == ' ') {\n \
    \   v.push_back(s.substr(0, s.size() - 1));\n  } else if (s[0] == '\\0') {\n \
    \   v.push_back(\"\");\n  } else {\n    for (auto i = s.size(); i != 0; --i) {\n\
    \      auto c = s[i - 1];\n      if (c == ' ' || c == '\\0') {\n        v.push_back(s.substr(0,\
    \ i));\n        break;\n      }\n      if (c == 'a') {\n        if (i == s.size()\
    \ - 1) {\n          v.push_back(\"\");\n          break;\n        }\n        auto\
    \ j = i + 1;\n        while ((j < s.size()) && (s[j] != 'a'))\n          ++j;\n\
    \        if (j == s.size() - 1) {\n          v.push_back(s.substr(0, i));\n  \
    \        break;\n        }\n        if (s[i] != s[j])\n          break;\n    \
    \    v.push_back(s.substr(i, j));\n        i += j - i + 1;\n        break;\n \
    \     }\n      if (c == 'b' || c == 'c' || c == 'd' || c == 'e' || c == 'f' ||\
    \ \n          c == 'g' || c == 'h' || c == 'i' || c == 'j' || c == 'k' || \n \
    \         c == 'l' || c == 'm' || c == 'n' || c == 'o' || c == 'p' || \n     \
    \     c == 'q' || c == 'r' || c == 's' || c == 't' || c == 'u' || \n         \
    \ c == 'v' || c == 'w' || c == 'x' || c == 'y' || c == 'z')\n        v.push_back(s.substr(0,\
    \ i));\n    }\n  }\n  return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpkwj2_hzl: /tmp/tmpkwj2_hzl.cpp:64: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141064
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.empty())\
    \ {\n        return {};\n    }\n    std::vector<std::string> v;\n    std::string\
    \ word = \"\";\n    for (auto &c : s) {\n        if (c == 'a' || c == 'e' || c\
    \ == 'i' || c == 'o' || c == 'u') {\n            if (word == \"\") {\n       \
    \         v.push_back({word});\n                word = c;\n            } else\
    \ {\n                word += c;\n            }\n        } else {\n           \
    \ word += c;\n        }\n        if (word.size() == n) {\n            v.push_back({word});\n\
    \            word = \"\";\n        }\n    }\n    return v;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmphd5dkwee: /tmp/tmphd5dkwee.cpp:45: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141064
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ vs;\n    for (size_t i = 0; i < s.length(); ++i) {\n        if (!is_consonant(s.at(i)))\
    \ {\n            if (n == 0 || s.at(i) != s.at(i-1)) {\n                vs.emplace_back(s.substr(i,\
    \ 1));\n            }\n        }\n    }\n    return vs;\n}\nint main() {\n   \
    \ auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpssarbex7.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpssarbex7.cpp:22:14: error:\
    \ \u2018is_consonant\u2019 was not declared in this scope\n   22 |         if\
    \ (!is_consonant(s.at(i))) {\n      |              ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660141063
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    // Your code here\n    res.push_back(s);\n    return res;\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpfgipq95a: /tmp/tmpfgipq95a.cpp:27: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141065
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    // write your code here\n    v.emplace_back(s);\n    for(int i=0;i<s.length();i++){\n\
    \        if(s[i]=='a' || s[i]=='e' || s[i]=='i' || s[i]=='o' || s[i]=='u'){\n\
    \            for(int j=i+1;j<s.length();j++){\n                if(s[j] == 'a'\
    \ || s[j] == 'e' || s[j] == 'i' || s[j] == 'o' || s[j] == 'u'){\n            \
    \        v.emplace_back(s.substr(i,j-i+1));\n                }\n            }\n\
    \        }\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmps7ml8yn4: /tmp/tmps7ml8yn4.cpp:36: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141065
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    // your code here\n    for (auto &e : s) {\n        if (e == 'a' ||\
    \ e == 'e' || e == 'i' || e == 'o' || e == 'u') {\n            for (int i = 0;\
    \ i < (n - 1); i++) {\n                res.push_back(s.substr(i, n));\n      \
    \      }\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpmhljko3r: /tmp/tmpmhljko3r.cpp:33: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141065
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::sort(s.begin(),\
    \ s.end()); //sorting alphabetically\n    if (s.empty()) return {}; //returning\
    \ empty vector if string is empty\n    \n    std::vector<std::string> ans;\n \
    \   \n    for (auto i = s.cbegin(), j = s.cend(); i <= j; ++i)\n    {\n      \
    \  for (auto k = i; k <= j; ++k)\n        {\n            if (k - i != n)\n   \
    \         {\n                ans.emplace_back(s.substr(k, i-k));\n           \
    \     \n                break;\n            }\n        }\n    }\n    \n    return\
    \ ans;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx762sfxz.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpx762sfxz.cpp:31:43: error:\
    \ cannot convert \u2018__gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018\
    long unsigned int\u2019}\n   31 |                 ans.emplace_back(s.substr(k,\
    \ i-k));\n      |                                           ^\n      |       \
    \                                    |\n      |                              \
    \             __gnu_cxx::__normal_iterator<const char*, std::__cxx11::basic_string<char>\
    \ >\nIn file included from /usr/include/c++/9/string:55,\n                 from\
    \ /usr/include/c++/9/bits/locale_classes.h:40,\n                 from /usr/include/c++/9/bits/ios_base.h:41,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx762sfxz.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2838:24: note:\
    \   initializing argument 1 of \u2018std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::substr(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2838 |       substr(size_type __pos = 0, size_type __n = npos)\
    \ const\n      |              ~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660141064
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  assert(s.length()\
    \ > 0);\n  std::vector<std::string> result;\n  std::string word = \"\";\n  \n\
    \  for (int i = 0; i < s.length(); ++i) {\n    if (s[i] == 'a') {\n      if (!word.empty())\
    \ {\n        result.push_back(word);\n        word = \"\";\n      }\n    }\n \
    \   else if (s[i] == 'u' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i]\
    \ == 'u') {\n      if (!word.empty()) result.push_back(word);\n      word = s[i];\n\
    \    }\n    else {\n      if (!word.empty()) result.push_back(word);\n      word\
    \ += s[i];\n    }\n  }\n  \n  if (!word.empty()) result.push_back(word);\n  return\
    \ result;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpo1ndpb09: /tmp/tmpo1ndpb09.cpp:46: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141066
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  if (s.empty())\n\
    \    return {};\n  // your implementation here\n  return std::vector<std::string>{};\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp9by6zyey: /tmp/tmp9by6zyey.cpp:27: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141066
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if(s.length()\
    \ == 0 || n == 0)\n        return {};\n    std::string ans;\n    for(std::string\
    \ word: split(s))\n        if(count(word, {'a', 'e', 'i', 'o', 'u', 'y'}) == n)\n\
    \            ans.push_back(word);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyetr2hgz.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpyetr2hgz.cpp:23:27: error:\
    \ \u2018split\u2019 was not declared in this scope\n   23 |     for(std::string\
    \ word: split(s))\n      |                           ^~~~~\n/tmp/tmpyetr2hgz.cpp:24:54:\
    \ error: no matching function for call to \u2018count(std::string&, <brace-enclosed\
    \ initializer list>)\u2019\n   24 |         if(count(word, {'a', 'e', 'i', 'o',\
    \ 'u', 'y'}) == n)\n      |                                                  \
    \    ^\nIn file included from /usr/include/c++/9/algorithm:62,\n             \
    \    from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n            \
    \     from /tmp/tmpyetr2hgz.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:4113:5:\
    \ note: candidate: \u2018template<class _IIter, class _Tp> typename std::iterator_traits<_Iterator>::difference_type\
    \ std::count(_IIter, _IIter, const _Tp&)\u2019\n 4113 |     count(_InputIterator\
    \ __first, _InputIterator __last, const _Tp& __value)\n      |     ^~~~~\n/usr/include/c++/9/bits/stl_algo.h:4113:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpyetr2hgz.cpp:24:54:\
    \ note:   candidate expects 3 arguments, 2 provided\n   24 |         if(count(word,\
    \ {'a', 'e', 'i', 'o', 'u', 'y'}) == n)\n      |                             \
    \                         ^\nIn file included from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyetr2hgz.cpp:2:\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:101:1:\
    \ note: candidate: \u2018template<class _ExecutionPolicy, class _ForwardIterator,\
    \ class _Tp> __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,\
    \ typename std::iterator_traits<_II>::difference_type> std::count(_ExecutionPolicy&&,\
    \ _ForwardIterator, _ForwardIterator, const _Tp&)\u2019\n  101 | count(_ExecutionPolicy&&\
    \ __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);\n\
    \      | ^~~~~\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:101:1: note:   templa"
  stdout: ''
  timestamp: 1660141064
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ words;\n    if (s.empty()) {\n        return words;\n    }\n    \n    for (char\
    \ c : s) {\n        if (c == ' ' || c == '\\t' || c == '\\n') {\n            continue;\n\
    \        }\n        if (count_consonants(c) == n) {\n            words.push_back((std::string)c);\n\
    \        }\n    }\n    return words;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn6bsyn2r.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpn6bsyn2r.cpp:29:13: error:\
    \ \u2018count_consonants\u2019 was not declared in this scope\n   29 |       \
    \  if (count_consonants(c) == n) {\n      |             ^~~~~~~~~~~~~~~~\n/tmp/tmpn6bsyn2r.cpp:30:42:\
    \ error: no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(char&)\u2019\
    \n   30 |             words.push_back((std::string)c);\n      |              \
    \                            ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpn6bsyn2r.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note: candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/move.h:55,\n                 from /usr/include/c++/9/bits/stl_pair.h:59,\n\
    \                 from /usr/include/c++/9/bits/stl_algobase.h:64,\n          \
    \       from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpn6bsyn2r.cpp:2:\n/usr/include/c++/9/type_traits:\
    \ In substitution of \u2018template<bool _Cond, class _Tp> using enable_if_t =\
    \ typename std::enable_if::type [with bool _Cond ="
  stdout: ''
  timestamp: 1660141065
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  v.reserve(s.size());\n  std::string word = \"\";\n  if(s.size() > 0){\n\
    \    word = s.substr(0,n);\n    // Find words that contain n consonants\n    int\
    \ n = s.size() - word.length();\n    int i = 0;\n    for(std::size_t i = 0; i\
    \ < (int)word.length(); i++)\n      if(word[i] != 'a'){\n        if(word[i] ==\
    \ 'u' || word[i] == 'U'){\n          if(word[i + 1] == 'l' || word[i + 1] == 'L'){\n\
    \            if(word[i + 2] == 'a' || word[i + 2] == 'A'){\n              if(word[i\
    \ + 3] == 't' || word[i + 3] == 'T'){\n                if(word[i + 4] == 'e' ||\
    \ word[i + 4] == 'E'){\n                  if(word[i + 5] == 'r' || word[i + 5]\
    \ == 'R'){\n                    if(word[i + 6] == 's' || word[i + 6] == 'S'){\n\
    \                      if(word[i + 7] == 'm' || word[i + 7] == 'M'){\n       \
    \                 if(word[i + 8] == 'a' || word[i + 8] == 'A'){\n            \
    \              if(word[i + 9] == 't' || word[i + 9] == 'T'){\n               \
    \             if(word[i + 10] == 'h' || word[i + 10] == 'H'){\n              \
    \                if(word[i + 11] == 'w' || word[i + 11] == 'W'){\n           \
    \                     if(word[i + 12] == 'd' || word[i + 12] == 'D'){\n      \
    \                            if(word[i + 13] == 'l' || word[i + 13] == 'L'){\n\
    \                                    if(word[i + 14] == 'e' || word[i + 14] ==\
    \ 'E'){\n                                      if(word[i + 15] == 'r' || word[i\
    \ + 15] == 'R'){\n                                        if(word[i + 16] == 'e'\
    \ || word[i + 16] == 'E'){\n                                          if(word[i\
    \ + 17] == 's' || word[i + 17] == 'S'){\n                                    \
    \        if(word[i + 18] == 'a' || word[i + 18] == 'A'){\n                   \
    \                           if(word[i + 19] == 'l' || word[i + 19] == 'L'){\n\
    \                                                if(word[i + 20] == 'c' || word[i\
    \ + 20] == 'C'){\n                                                  if(word[i\
    \ + 21] == 'h' || word[i + 21] == 'H'){\n                                    \
    \                if(word[i + 22] == 'w' || word[i + 22] == 'W'){\n           \
    \                                           if(word[i + 23] == 'o' || word[i +\
    \ 23] == 'O'){\n                                                        if(word[i\
    \ + 24] == 'd' || word[i + 24] == 'D'){\n                                    \
    \                      if(word[i + 25] == 'n' || word[i + 25] == 'N'){\n     \
    \                                                       if(word[i + 26] == 'e'\
    \ || word[i + 26] == 'E'){\n                                                 \
    \             if(word[i + 27] == 'r' || word[i + 27\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa9pp4jmo.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpa9pp4jmo.cpp:57:100: error:\
    \ expected \u2018]\u2019 before \u2018}\u2019 token\n   57 |                 \
    \                                              if(word[i + 27] == 'r' || word[i\
    \ + 27\n      |                                                              \
    \                                      ^\n      |                            \
    \                                                                        ]\n \
    \  58 | }\n      | ~                                                         \
    \                                          \n/tmp/tmpa9pp4jmo.cpp:57:100: error:\
    \ expected \u2018)\u2019 before \u2018}\u2019 token\n   57 |                 \
    \                                              if(word[i + 27] == 'r' || word[i\
    \ + 27\n      |                                                              \
    \   ~                                  ^\n      |                            \
    \                                                                        )\n \
    \  58 | }\n      | ~                                                         \
    \                                          \n/tmp/tmpa9pp4jmo.cpp:58:1: error:\
    \ expected primary-expression before \u2018}\u2019 token\n   58 | }\n      | ^\n\
    /tmp/tmpa9pp4jmo.cpp:59:12: error: a function-definition is not allowed here before\
    \ \u2018{\u2019 token\n   59 | int main() {\n      |            ^\n/tmp/tmpa9pp4jmo.cpp:68:1:\
    \ error: expected \u2018}\u2019 at end of input\n   68 | }\n      | ^\n/tmp/tmpa9pp4jmo.cpp:55:105:\
    \ note: to match this \u2018{\u2019\n   55 |                                 \
    \                          if(word[i + 25] == 'n' || word[i + 25] == 'N'){\n \
    \     |                                                                      \
    \                                   ^\n/tmp/tmpa9pp4jmo.cpp:68:1: error: expected\
    \ \u2018}\u2019 at end of input\n   68 | }\n      | ^\n/tmp/tmpa9pp4jmo.cpp:54:103:\
    \ note: to match this \u2018{\u2019\n   54 |                                 \
    \                        if(word[i + 24] == 'd' || word[i + 24] == 'D'){\n   \
    \   |        "
  stdout: ''
  timestamp: 1660141064
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    if(s == \"\") return res;\n    \n    std::vector<bool> ans(s.size(),\
    \ 0);\n    for(size_t i = 0; i < s.size(); ++i){\n        for(size_t j = 0; j\
    \ < s.size(); ++j){\n            if(ans[j] && s.at(i) == s.at(j)){\n         \
    \       ans[j] = !ans[j];\n            }\n        }\n    }\n    \n    if(ans.at(n)\
    \ == false){\n        return res;\n    }\n    \n    for(size_t i = 0; i < s.size();\
    \ ++i){\n        if(ans.at(i) == true && s.at(i) == s.at(n)){\n            res.push_back(s.substr(0,\
    \ i));\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp26gj43m7: /tmp/tmp26gj43m7.cpp:45: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141066
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ result;\n    for(int i = 0; i < s.size(); i++) {\n        if(s.at(i) == '_')\
    \ {\n            if(!result.empty()) {\n                result.clear();\n    \
    \        }\n            continue;\n        }\n        for(int j = 0; j < n; j++)\
    \ {\n            if(s.at(i) == s[j]) {\n                result.push_back((std::string)s.substr(0,\
    \ i+1));\n                break;\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp5x01if4y: /tmp/tmp5x01if4y.cpp:39: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141066
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    // write your code here\n    return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmptqehqf81: /tmp/tmptqehqf81.cpp:26: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141066
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    // insert your code here\n    return 0;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuve0o2fb.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpuve0o2fb.cpp:22:12: error:\
    \ could not convert \u20180\u2019 from \u2018int\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019\n   22 |     return 0;\n      |            ^\n      |            |\n\
    \      |            int\n"
  stdout: ''
  timestamp: 1660141065
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ words;\n    // write your code here\n    return words;\n}\nint main() {\n  \
    \  auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp_dsg275l: /tmp/tmp_dsg275l.cpp:26: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141067
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.length()\
    \ == 0)\n        return std::vector<std::string>();\n    long count = 0;\n   \
    \ for (auto const &c: s)\n        if (c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n            count++;\n    std::vector<std::string> res;\n\
    \    long last_index = -1;\n    for (auto const &c: s) {\n        if (last_index\
    \ < 0 && c == 'a')\n            last_index = count;\n        if (last_index >\
    \ 0 && last_index == count + 1) {\n            if (n == count)\n             \
    \   res.push_back(c);\n        } else {\n            if (n-- > 0)\n          \
    \      res.push_back(c);\n        }\n    }\n    return res;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2yud0659.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp2yud0659.cpp:33:32: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(const char&)\u2019\n   33 |                 res.push_back(c);\n\
    \      |                                ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2yud0659.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018const char\u2019 to \u2018\
    const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018const char\u2019 to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::value_type&&\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>&&\u2019}\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       "
  stdout: ''
  timestamp: 1660141065
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    //code here\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpn5suh8pb: /tmp/tmpn5suh8pb.cpp:24: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141067
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ result;\n  if (s.empty()) {\n    return result;\n  }\n  std::vector<std::string>\
    \ result1(s.begin(), s.end());\n  result1.erase(std::remove(result1.begin(), result1.end(),\
    \ ' '), result1.end()); // remove space\n  std::string newstr;\n  bool flag =\
    \ true;\n  while (result1.size() > n) {\n    newstr.clear();\n    flag = true;\n\
    \    for (std::string temp : result1) {\n      newstr += temp;\n      if (std::count(newstr.begin(),\
    \ newstr.end(), ' ')) flag = false;\n    }\n    if (flag == true) {\n      result.push_back(newstr);\n\
    \    }\n    result1.erase(std::remove(result1.begin(), result1.end(), ' '), result1.end());\
    \ // remove space\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n    \
    \             from /usr/include/c++/9/bits/specfun.h:45,\n                 from\
    \ /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmplwshhmdj.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_equals_val<_Value>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >; _Value = const char]\u2019\
    :\n/usr/include/c++/9/bits/stl_algo.h:875:13:   required from \u2018_ForwardIterator\
    \ std::__remove_if(_ForwardIterator, _ForwardIterator, _Predicate) [with _ForwardIterator\
    \ = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Predicate = __gnu_cxx::__ops::_Iter_equals_val<const char>]\u2019\n/usr/include/c++/9/bits/stl_algo.h:912:30:\
    \   required from \u2018_FIter std::remove(_FIter, _FIter, const _Tp&) [with _FIter\
    \ = __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*, std::vector<std::__cxx11::basic_string<char>\
    \ > >; _Tp = char]\u2019\n/tmp/tmplwshhmdj.cpp:25:64:   required from here\n/usr/include/c++/9/bits/predefined_ops.h:241:17:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018const char\u2019)\n  241 |  { return *__it == _M_value; }\n      |\
    \           ~~~~~~^~~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmplwshhmdj.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _"
  stdout: ''
  timestamp: 1660141065
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    assert(n >=\
    \ 0 && n < s.size());\n    // Your code here\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp33qldyu_: /tmp/tmp33qldyu_.cpp:25: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141067
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    \n    if (s.empty()) return v;\n    \n    std::string w;\n    std::stack<std::string>\
    \ st;\n    st.push(s);\n    \n    while (!st.empty()) {\n        w = st.top();\n\
    \        if (w.size() == n) v.push_back(w);\n        if (w.size() > n) st.pop();\n\
    \        else std::cout << w << \" \";\n        \n        while (w.size() != n)\
    \ {\n            if (w.size() > n) st.pop();\n            else std::cout << w\
    \ << \" \";\n            if (w.size() == n) v.push_back(w);\n            w = st.top();\n\
    \            if (w.size() == n) st.push(w);\n            std::cout << w << \"\
    \ \";\n        }\n    }\n    \n    return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660141067
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  std::string word = \"\";\n  for (int i = 0; i < n; ++i) {\n    word =\
    \ word + s[i];\n  }\n  v.push_back(word);\n  if (s.size() > 0) {\n    for (int\
    \ j = 0; j < n; ++j) {\n      v.push_back(\"(\" + word + \")\");\n    }\n  }\n\
    \  return v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp_xqfkxg5: /tmp/tmp_xqfkxg5.cpp:35: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141067
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  assert(s.size()\
    \ > 0);\n  assert(n >= 0 && n <= s.size());\n  if(s.size() == 0) {\n    return\
    \ std::vector<std::string>();\n  }\n  \n  if(n <= 1) {\n    std::vector<std::string>\
    \ res;\n    res.push_back(s);\n    return res;\n  }\n  std::vector<std::string>\
    \ res;\n  \n  // Step 1: Create a hash map and store all the words in string s.\n\
    \  std::unordered_map<std::string,int> map;\n  for(char c : s) {\n    map[c]++;\n\
    \  }\n  \n  // Step 2: Iterate over all the words in map and compare the value\
    \ with the required n.\n  for(auto &kv : map) {\n    if(kv.second == n) {\n  \
    \    res.push_back(kv.first);\n    }\n  }\n  \n  return res;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn4dp68l4.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpn4dp68l4.cpp:36:8: error:\
    \ no match for \u2018operator[]\u2019 (operand types are \u2018std::unordered_map<std::__cxx11::basic_string<char>,\
    \ int>\u2019 and \u2018char\u2019)\n   36 |     map[c]++;\n      |        ^\n\
    In file included from /usr/include/c++/9/unordered_map:47,\n                 from\
    \ /usr/include/c++/9/functional:61,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpn4dp68l4.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:985:7: note:\
    \ candidate: \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::mapped_type&\
    \ std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type&)\
    \ [with _Key = std::__cxx11::basic_string<char>; _Tp = int; _Hash = std::hash<std::__cxx11::basic_string<char>\
    \ >; _Pred = std::equal_to<std::__cxx11::basic_string<char> >; _Alloc = std::allocator<std::pair<const\
    \ std::__cxx11::basic_string<char>, int> >; std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>::mapped_type = int; std::unordered_map<_Key, _Tp, _Hash, _Pred,\
    \ _Alloc>::key_type = std::__cxx11::basic_string<char>]\u2019\n  985 |       operator[](const\
    \ key_type& __k)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/unordered_map.h:985:34:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ key_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \  985 |       operator[](const key_type& __k)\n      |                  ~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/unordered_map.h:989:7: note: candidate: \u2018std::unordered_map<_Key,\
    \ _Tp, _Hash, _Pred, _Alloc>::mapped_type& std::unordered_map<_Key, _Tp, _Hash,\
    \ _Pred, _Alloc>::operator[](std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::key_type&&)\
    \ [with _Key = std::__cxx11::basic_string<char>; _Tp = int; _Hash = std::hash<std::__cxx11::basic_string<char>\
    \ >; _"
  stdout: ''
  timestamp: 1660141066
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.empty())\
    \ {\n        return std::vector<std::string>();\n    }\n    std::vector<std::string>\
    \ result;\n    for (auto &c: s) {\n        if (n-- == 0) {\n            c.swap(s.back());\n\
    \            s.pop_back();\n            result.emplace_back(std::move(c));\n \
    \           break;\n        }\n        if (c.at(0) == '\\'') {\n            n--;\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy9ge_34k.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpy9ge_34k.cpp:26:15: error:\
    \ request for member \u2018swap\u2019 in \u2018c\u2019, which is of non-class\
    \ type \u2018char\u2019\n   26 |             c.swap(s.back());\n      |      \
    \         ^~~~\n/tmp/tmpy9ge_34k.cpp:31:15: error: request for member \u2018at\u2019\
    \ in \u2018c\u2019, which is of non-class type \u2018char\u2019\n   31 |     \
    \    if (c.at(0) == '\\'') {\n      |               ^~\nIn file included from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n              \
    \   from /usr/include/c++/9/bits/allocator.h:46,\n                 from /usr/include/c++/9/string:41,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpy9ge_34k.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h:\
    \ In instantiation of \u2018void __gnu_cxx::new_allocator<_Tp>::construct(_Up*,\
    \ _Args&& ...) [with _Up = std::__cxx11::basic_string<char>; _Args = {char}; _Tp\
    \ = std::__cxx11::basic_string<char>]\u2019:\n/usr/include/c++/9/bits/alloc_traits.h:483:4:\
    \   required from \u2018static void std::allocator_traits<std::allocator<_CharT>\
    \ >::construct(std::allocator_traits<std::allocator<_CharT> >::allocator_type&,\
    \ _Up*, _Args&& ...) [with _Up = std::__cxx11::basic_string<char>; _Args = {char};\
    \ _Tp = std::__cxx11::basic_string<char>; std::allocator_traits<std::allocator<_CharT>\
    \ >::allocator_type = std::allocator<std::__cxx11::basic_string<char> >]\u2019\
    \n/usr/include/c++/9/bits/vector.tcc:115:30:   required from \u2018std::vector<_Tp,\
    \ _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with\
    \ _Args = {char}; _Tp = std::__"
  stdout: ''
  timestamp: 1660141065
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ words;\n    for (auto &word : s) {\n        if (std::count_if(word.begin(),\
    \ word.end(), std::isspace) == n)\n            words.push_back(std::move(word));\n\
    \    }\n    return words;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpf7vkgghc.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpf7vkgghc.cpp:22:32: error:\
    \ request for member \u2018begin\u2019 in \u2018word\u2019, which is of non-class\
    \ type \u2018char\u2019\n   22 |         if (std::count_if(word.begin(), word.end(),\
    \ std::isspace) == n)\n      |                                ^~~~~\n/tmp/tmpf7vkgghc.cpp:22:46:\
    \ error: request for member \u2018end\u2019 in \u2018word\u2019, which is of non-class\
    \ type \u2018char\u2019\n   22 |         if (std::count_if(word.begin(), word.end(),\
    \ std::isspace) == n)\n      |                                              ^~~\n\
    /tmp/tmpf7vkgghc.cpp:23:44: error: no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(std::remove_reference<char&>::type)\u2019\n   23 |            \
    \ words.push_back(std::move(word));\n      |                                 \
    \           ^\nIn file included from /usr/include/c++/9/vector:67,\n         \
    \        from /usr/include/c++/9/functional:62,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpf7vkgghc.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7: note:\
    \ candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018std::remove_reference<char&>::type\u2019\
    \ {aka \u2018char\u2019} to \u2018const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Allo"
  stdout: ''
  timestamp: 1660141065
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // write your\
    \ code here\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpf8czg99q: /tmp/tmpf8czg99q.cpp:24: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141067
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    // Write your code here\n    for (auto &i: s)\n        for (auto &j:\
    \ i)\n            if (j != ' ')\n                v.push_back(i+j);\n        if\
    \ (v.size() < n)\n            return v;\n    \n    return v;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_wg22p8.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpq_wg22p8.cpp:23:23: error:\
    \ \u2018begin\u2019 was not declared in this scope\n   23 |         for (auto\
    \ &j: i)\n      |                       ^\n/tmp/tmpq_wg22p8.cpp:23:23: note: suggested\
    \ alternatives:\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpq_wg22p8.cpp:2:\n/usr/include/c++/9/valarray:1224:5:\
    \ note:   \u2018std::begin\u2019\n 1224 |     begin(const valarray<_Tp>& __va)\n\
    \      |     ^~~~~\nIn file included from /usr/include/c++/9/filesystem:38,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n\
    \                 from /tmp/tmpq_wg22p8.cpp:2:\n/usr/include/c++/9/bits/fs_dir.h:516:3:\
    \ note:   \u2018std::filesystem::__cxx11::begin\u2019\n  516 |   begin(recursive_directory_iterator\
    \ __iter) noexcept\n      |   ^~~~~\n/tmp/tmpq_wg22p8.cpp:23:23: error: \u2018\
    end\u2019 was not declared in this scope\n   23 |         for (auto &j: i)\n \
    \     |                       ^\n/tmp/tmpq_wg22p8.cpp:23:23: note: suggested alternatives:\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmpq_wg22p8.cpp:2:\n/usr/include/c++/9/valarray:1244:5:\
    \ note:   \u2018std::end\u2019\n 1244 |     end(const valarray<_Tp>& __va)\n \
    \     |     ^~~\nIn file included from /usr/include/c++/9/filesystem:38,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n \
    \                from /tmp/tmpq_wg22p8.cpp:2:\n/usr/include/c++/9/bits/fs_dir.h:520:3:\
    \ note:   \u2018std::filesystem::__cxx11::end\u2019\n  520 |   end(recursive_directory_iterator)\
    \ noexcept\n      |   ^~~\n"
  stdout: ''
  timestamp: 1660141066
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    \n    std::vector<std::string>\
    \ v;\n    if (s.empty()) {\n        return v;\n    }\n    for (auto &it : s) {\n\
    \        if (std::count(it.begin(), it.end(), \n                       n) == n)\
    \ v.push_back({it});\n    }\n    return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphl9pre39.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmphl9pre39.cpp:26:27: error:\
    \ request for member \u2018begin\u2019 in \u2018it\u2019, which is of non-class\
    \ type \u2018char\u2019\n   26 |         if (std::count(it.begin(), it.end(),\n\
    \      |                           ^~~~~\n/tmp/tmphl9pre39.cpp:26:39: error: request\
    \ for member \u2018end\u2019 in \u2018it\u2019, which is of non-class type \u2018\
    char\u2019\n   26 |         if (std::count(it.begin(), it.end(),\n      |    \
    \                                   ^~~\n"
  stdout: ''
  timestamp: 1660141066
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ ans;\n    if(s.empty())\n        return ans;\n    std::string word = s.substr(0,\
    \ n);\n    long index = 1;\n    for(char c : word){\n        ans.push_back((std::string)word);\n\
    \        index = index * c + 1;\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpua9siw4w: /tmp/tmpua9siw4w.cpp:33: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141068
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Write your\
    \ code here\n    return {};\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpr20o9j5n: /tmp/tmpr20o9j5n.cpp:25: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141068
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    // write your logic here\n    int i = 0;\n    for (char ch: s) {\n\
    \        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ||\
    \ ch == 'y') {\n            ++i;\n        }\n    }\n    std::vector<std::string>\
    \ v;\n    if (i > 0) {\n        for (i; i< s.length(); i++) {\n            v.push_back(s.substr(0,\
    \ i));\n        }\n        v.push_back(s);\n    }\n    if (v.empty())\n      \
    \  return res;\n    if (v[0].size() == n) {\n        res.push_back(v[0]);\n  \
    \  }\n    for (int i = 0; i < v.size(); i++) {\n        std::vector<std::string>\
    \ v2 = select_words(v[i], n);\n        for (auto &it: v2)\n            res.push_back(it);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660141068
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  if (s.empty())\n    return v;\n  for (char c: s) {\n    if (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y') {\n      v.push_back((std::string)c);\n\
    \    } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' || c\
    \ == 'Y') {\n      v.push_back((std::string)c);\n    } else if (c == 'm' || c\
    \ == 'n' || c == 'h' || c == 'l' || c == 's' || c == 'w') {\n      v.push_back((std::string)c);\n\
    \    } else if (c == 'M' || c == 'N' || c == 'H' || c == 'L' || c == 'S' || c\
    \ == 'W') {\n      v.push_back((std::string)c);\n    } else if (c == ' ') {\n\
    \      v.push_back((std::string)c);\n    }\n  }\n  return v;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq6e3u8lq.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpq6e3u8lq.cpp:25:32: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(char&)\u2019\
    \n   25 |       v.push_back((std::string)c);\n      |                        \
    \        ^\nIn file included from /usr/include/c++/9/string:55,\n            \
    \     from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpq6e3u8lq.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note: candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/move.h:55,\n                 from /usr/include/c++/9/bits/stl_pair.h:59,\n\
    \                 from /usr/include/c++/9/bits/stl_algobase.h:64,\n          \
    \       from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpq6e3u8lq.cpp:2:\n/usr/include/c++/9/type_traits:\
    \ In substitution of \u2018template<bool _Cond, class _Tp> using enable_if_t =\
    \ typename std::enable_if::type [with bool _Cond = std::integral_constant<bool,\
    \ false>::value; _Tp = void]\u2019:\n/usr/include/c++/9/bits/basic_string.h:121:8:\
    \   required by substitution of \u2018template<class _CharT, class _Traits, class\
    \ _Alloc> te"
  stdout: ''
  timestamp: 1660141066
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Write your\
    \ code here\n    std::vector<std::string> v;\n    if(s.length() == 0){\n     \
    \   return v;\n    }\n    std::string vowels = \"aeiou\";\n    for(int i = 0;\
    \ i<s.length(); i++){\n        for(int j = 0; j < vowels.length(); j++){\n   \
    \         if(s[i] == vowels[j]){\n                break;\n            }\n    \
    \    }\n        if(j < vowels.length()){\n            v.push_back((std::string)s[i]);\n\
    \        }\n    }\n    for(int i = 0; i<s.length(); i++){\n        for(int j =\
    \ 0; j < n; j++){\n            if(s[i] == vowels[j]){\n                break;\n\
    \            }\n        }\n        if(j < n){\n            v.push_back((std::string)s[i]);\n\
    \        }\n    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5pwyl6nq.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp5pwyl6nq.cpp:32:12: error:\
    \ \u2018j\u2019 was not declared in this scope\n   32 |         if(j < vowels.length()){\n\
    \      |            ^\n/tmp/tmp5pwyl6nq.cpp:33:41: error: no matching function\
    \ for call to \u2018std::__cxx11::basic_string<char>::basic_string(__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type&)\u2019\n   33 |             v.push_back((std::string)s[i]);\n\
    \      |                                         ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp5pwyl6nq.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note: candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/move.h:55,\n                 from /usr/include/c++/9/bits/stl_pair.h:59,\n\
    \                 from /usr/include/c++/9/bits/stl_algobase.h:64,\n          \
    \       from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp5pwyl6nq.cpp:2:\n/usr/include/c++/9/type_traits:\
    \ In substitution of \u2018template<bool _Cond, class _Tp> using enable_if_t =\
    \ typename std::enable_if::ty"
  stdout: ''
  timestamp: 1660141066
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Your code\
    \ here\n    std::vector<std::string> v;\n    for(int i=0;i<s.size();i++){\n  \
    \      for(int j=0;j<s.at(i);j++){\n            if(s.at(i)==s.at(j)){\n      \
    \          v.push_back(s.substr(i,j));\n            }\n        }\n    }\n    return\
    \ v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::at: __n (which is 22) >= this->size() (which is 22)\n"
  stdout: ''
  timestamp: 1660141068
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    auto it = s.begin();\n    while (it != s.end() && n > 0) {\n       \
    \ if (*it == 'a' || *it == 'e' || *it == 'i' || *it == 'o' || *it == 'u') {\n\
    \            v.push_back(std::string(it++));\n            n--;\n        }\n  \
    \      else if (*it == 'y' || *it == 'h' || *it == 'o' || *it == 'r') {\n    \
    \        v.push_back(std::string(it++));\n            n--;\n        }\n      \
    \  else if (*it == 'w') {\n            v.push_back(std::string(it++));\n     \
    \       n--;\n        }\n        else if (*it == ' ') {\n            v.push_back(std::string(it++));\n\
    \            n--;\n        }\n        else {\n            ++it;\n        }\n \
    \   }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n  \
    \  assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1wrtpf7m.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp1wrtpf7m.cpp:24:41: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >)\u2019\n   24 |             v.push_back(std::string(it++));\n\
    \      |                                         ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp1wrtpf7m.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note: candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/move.h:55,\n                 from /usr/include/c++/9/bits/stl_pair.h:59,\n\
    \                 from /usr/include/c++/9/bits/stl_algobase.h:64,\n          \
    \       from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp1wrtpf7m.cpp:2:\n/usr/include/c++/9/type_traits:\
    \ In substitution of \u2018template<bool _Cond, class _Tp> using enable_if_t =\
    \ typename std::enable_if::type [with bool _Cond = std::integral_constant<bool,\
    \ false>::value; _Tp = void]\u2019:\n/usr/include/c++/9/bits/basic_string.h:121:8:\
    \   re"
  stdout: ''
  timestamp: 1660141066
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ result;\n    long counter = 0;\n    for (auto &char : s)\n        if (char ==\
    \ '#')\n            counter++;\n    if (counter > n)\n        return result;\n\
    \    result.emplace_back(s);\n    for (auto &char : s)\n        if (char == '#')\n\
    \            counter--;\n    if (counter < n)\n        return result;\n    result.emplace_back(s);\n\
    \    return result;\n}\nint main() {\n    auto candidate = select_words;\n   \
    \ assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc1yk3xwk.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpc1yk3xwk.cpp:22:16: error:\
    \ expected unqualified-id before \u2018char\u2019\n   22 |     for (auto &char\
    \ : s)\n      |                ^~~~\n/tmp/tmpc1yk3xwk.cpp:22:16: error: expected\
    \ \u2018;\u2019 before \u2018char\u2019\n   22 |     for (auto &char : s)\n  \
    \    |                ^~~~\n      |                ;\n/tmp/tmpc1yk3xwk.cpp:22:21:\
    \ error: expected unqualified-id before \u2018:\u2019 token\n   22 |     for (auto\
    \ &char : s)\n      |                     ^\n/tmp/tmpc1yk3xwk.cpp:22:24: error:\
    \ expected \u2018;\u2019 before \u2018)\u2019 token\n   22 |     for (auto &char\
    \ : s)\n      |                        ^\n      |                        ;\n/tmp/tmpc1yk3xwk.cpp:23:18:\
    \ error: expected unqualified-id before \u2018==\u2019 token\n   23 |        \
    \ if (char == '#')\n      |                  ^~\n/tmp/tmpc1yk3xwk.cpp:28:16: error:\
    \ expected unqualified-id before \u2018char\u2019\n   28 |     for (auto &char\
    \ : s)\n      |                ^~~~\n/tmp/tmpc1yk3xwk.cpp:28:16: error: expected\
    \ \u2018;\u2019 before \u2018char\u2019\n   28 |     for (auto &char : s)\n  \
    \    |                ^~~~\n      |                ;\n/tmp/tmpc1yk3xwk.cpp:28:21:\
    \ error: expected unqualified-id before \u2018:\u2019 token\n   28 |     for (auto\
    \ &char : s)\n      |                     ^\n/tmp/tmpc1yk3xwk.cpp:28:24: error:\
    \ expected \u2018;\u2019 before \u2018)\u2019 token\n   28 |     for (auto &char\
    \ : s)\n      |                        ^\n      |                        ;\n/tmp/tmpc1yk3xwk.cpp:29:18:\
    \ error: expected unqualified-id before \u2018==\u2019 token\n   29 |        \
    \ if (char == '#')\n      |                  ^~\n"
  stdout: ''
  timestamp: 1660141066
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ ans;\n    // Write your code here\n    for(auto &word: words){\n        if(count(word.begin(),\
    \ word.end(), n) == n)\n        {\n            ans.push_back(word);\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpeb5b16_h.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpeb5b16_h.cpp:22:21: error:\
    \ \u2018words\u2019 was not declared in this scope; did you mean \u2018word\u2019\
    ?\n   22 |     for(auto &word: words){\n      |                     ^~~~~\n  \
    \    |                     word\n/tmp/tmpeb5b16_h.cpp:23:12: error: \u2018count\u2019\
    \ was not declared in this scope; did you mean \u2018std::count\u2019?\n   23\
    \ |         if(count(word.begin(), word.end(), n) == n)\n      |            ^~~~~\n\
    \      |            std::count\nIn file included from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpeb5b16_h.cpp:2:\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:101:1:\
    \ note: \u2018std::count\u2019 declared here\n  101 | count(_ExecutionPolicy&&\
    \ __exec, _ForwardIterator __first, _ForwardIterator __last, const _Tp& __value);\n\
    \      | ^~~~~\n"
  stdout: ''
  timestamp: 1660141067
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    if(s.empty())\n        return res;\n    \n    for(int i=0; i<s.size();\
    \ i++) {\n        char c = s[i];\n        if((i+1)==s.size()) {\n            if(std::count_if(c\
    \ == ' ', c) == n) {\n                res.push_back((std::string)s);\n       \
    \     }\n        }\n        else {\n            char c2 = s[i+1];\n          \
    \  if(c == c2) {\n                if(std::count_if(c == ' ', c) == n) {\n    \
    \                res.push_back((std::string)s);\n                }\n         \
    \   }\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8z5u06pe.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp8z5u06pe.cpp:27:41: error:\
    \ no matching function for call to \u2018count_if(bool, char&)\u2019\n   27 |\
    \             if(std::count_if(c == ' ', c) == n) {\n      |                 \
    \                        ^\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8z5u06pe.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:4136:5:\
    \ note: candidate: \u2018template<class _IIter, class _Predicate> typename std::iterator_traits<_Iterator>::difference_type\
    \ std::count_if(_IIter, _IIter, _Predicate)\u2019\n 4136 |     count_if(_InputIterator\
    \ __first, _InputIterator __last, _Predicate __pred)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_algo.h:4136:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp8z5u06pe.cpp:27:41:\
    \ note:   deduced conflicting types for parameter \u2018_IIter\u2019 (\u2018bool\u2019\
    \ and \u2018char\u2019)\n   27 |             if(std::count_if(c == ' ', c) ==\
    \ n) {\n      |                                         ^\nIn file included from\
    \ /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8z5u06pe.cpp:2:\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:106:1:\
    \ note: candidate: \u2018template<class _ExecutionPolicy, class _ForwardIterator,\
    \ class _Predicate> __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy,\
    \ typename std::iterator_traits<_II>::difference_type> std::count_if(_ExecutionPolicy&&,\
    \ _ForwardIterator, _ForwardIterator, _Predicate)\u2019\n  106 | count_if(_ExecutionPolicy&&\
    \ __exec, _ForwardIterator __first, _ForwardIterator __last, _Predicate __pred);\n\
    \      | ^~~~~~~~\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:106:1: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp8z5u06pe.cpp:27:41:\
    \ note:   candidate expects 4 arguments, 2 provided\n   27 |             if(std::count_if(c\
    \ == ' ', c) == "
  stdout: ''
  timestamp: 1660141067
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s == \"\
    \") {\n        return std::vector<std::string>();\n    }\n    std::vector<std::string>\
    \ v;\n    auto i = s.begin(), j = s.end();\n    while (*i != ' ' && *j != ' ')\n\
    \        i++, j--;\n    bool first_word = true;\n    while (j < s.end()) {\n \
    \       // skip space\n        while (*j == ' ' || *j == '\\t' || *j == '\\n')\n\
    \            j++;\n        // search consonants\n        for (int k = 0; k < n;\
    \ k++) {\n            while (k < n && *i == *j++)\n                k++;\n    \
    \        if (k == n)\n                break;\n        }\n        // push word\n\
    \        if (first_word) {\n            v.push_back({(std::string)s.substr(i,\
    \ j)});\n            first_word = false;\n        }\n        i = s.find(\" \"\
    , j);\n        if (i == s.end())\n            break;\n    }\n    return v;\n}\n\
    int main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary\
    \ had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpw0vd1eeb.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpw0vd1eeb.cpp:41:48: error:\
    \ cannot convert \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018\
    long unsigned int\u2019}\n   41 |             v.push_back({(std::string)s.substr(i,\
    \ j)});\n      |                                                ^\n      |   \
    \                                             |\n      |                     \
    \                           __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\nIn file included from /usr/include/c++/9/string:55,\n                 from\
    \ /usr/include/c++/9/bits/locale_classes.h:40,\n                 from /usr/include/c++/9/bits/ios_base.h:41,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpw0vd1eeb.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2838:24: note:\
    \   initializing argument 1 of \u2018std::__cxx11::basic_string<_CharT, _Traits,\
    \ _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::substr(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2838 |       substr(size_type __pos = 0, size_type __n = npos)\
    \ const\n      |              ~~~~~~~~~~^~~~~~~~~\n/tmp/tmpw0vd1eeb.cpp:41:54:\
    \ error: no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(<brace-enclosed initializer list>)\u2019\n   41 |             v.push_back({(std::string)s.substr(i,\
    \ j)});"
  stdout: ''
  timestamp: 1660141067
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ ans;\n    std::string::size_type pos = 0;\n    while(pos < s.size()) {\n   \
    \     // find consonant\n        char c = s[pos];\n        int index = n - 1;\n\
    \        if(c >= 'a' && c <= 'z') {\n            index -= (c - 'a') + 2; // convert\
    \ 'a' to 'z', then 'a'-'a'\n        } else if(c >= 'A' && c <= 'Z') {\n      \
    \      index -= (c - 'A') + 2; // convert 'A' to 'Z', then 'A'-'A'\n        }\n\
    \        if(index < 0) {\n            index = n + index;\n        }\n        while(index\
    \ >= 0) {\n            ans.push_back(s.substr(pos, index));\n            pos +=\
    \ index;\n            index -= 1;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660141072
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.empty())\
    \ {\n        return {};\n    }\n    if (n <= 0) {\n        return {};\n    }\n\
    \    std::vector<std::string> res;\n    auto start = std::find(s.begin(), s.end(),\
    \ 'a');\n    auto end = std::find(s.begin(), s.end(), 'z');\n    if (end != s.end())\
    \ {\n        if (start != s.begin() && end != s.end()) {\n            auto firstWord\
    \ = s.substr(0, (end - start));\n            if (firstWord.size() > n) {\n   \
    \             res = select_words(firstWord, n);\n            } else {\n      \
    \          res.push_back(firstWord);\n            }\n        }\n    }\n    auto\
    \ start = std::find(s.begin(), s.end(), 'A');\n    auto end = std::find(s.begin(),\
    \ s.end(), 'Z');\n    if (end != s.end()) {\n        if (start != s.begin() &&\
    \ end != s.end()) {\n            auto firstWord = s.substr(0, (end - start));\n\
    \            if (firstWord.size() > n) {\n                res = select_words(firstWord,\
    \ n);\n            } else {\n                res.push_back(firstWord);\n     \
    \       }\n        }\n    }\n    auto start = std::find(s.begin(), s.end(), '1');\n\
    \    auto end = std::find(s.begin(), s.end(), '9');\n    if (end != s.end()) {\n\
    \        if (start != s.begin() && end != s.end()) {\n            auto firstWord\
    \ = s.substr(0, (end - start));\n            if (firstWord.size() > n) {\n   \
    \             res = select_words(firstWord, n);\n            } else {\n      \
    \          res.push_back(firstWord);\n            }\n        }\n    }\n    auto\
    \ start = std::find(s.begin(), s.end(), ' ');\n    auto end = std::find(s.begin(),\
    \ s.end(), '\\t');\n    if (end != s.end()) {\n        if (start != s.begin()\
    \ && end != s.end()) {\n            auto firstWord = s.substr(0, (end - start));\n\
    \            if (firstWord.size() > n) {\n                res = select_words(firstWord,\
    \ n);\n            } else {\n                res.push_back(firstWord);\n     \
    \       }\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppjx9ud6d.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmppjx9ud6d.cpp:39:10: error:\
    \ conflicting declaration \u2018auto start\u2019\n   39 |     auto start = std::find(s.begin(),\
    \ s.end(), 'A');\n      |          ^~~~~\n/tmp/tmppjx9ud6d.cpp:27:10: note: previous\
    \ declaration as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > start\u2019\n   27 |     auto start = std::find(s.begin(), s.end(), 'a');\n\
    \      |          ^~~~~\n/tmp/tmppjx9ud6d.cpp:40:10: error: conflicting declaration\
    \ \u2018auto end\u2019\n   40 |     auto end = std::find(s.begin(), s.end(), 'Z');\n\
    \      |          ^~~\n/tmp/tmppjx9ud6d.cpp:28:10: note: previous declaration\
    \ as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > end\u2019\n   28 |     auto end = std::find(s.begin(), s.end(), 'z');\n  \
    \    |          ^~~\n/tmp/tmppjx9ud6d.cpp:51:10: error: conflicting declaration\
    \ \u2018auto start\u2019\n   51 |     auto start = std::find(s.begin(), s.end(),\
    \ '1');\n      |          ^~~~~\n/tmp/tmppjx9ud6d.cpp:27:10: note: previous declaration\
    \ as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > start\u2019\n   27 |     auto start = std::find(s.begin(), s.end(), 'a');\n\
    \      |          ^~~~~\n/tmp/tmppjx9ud6d.cpp:52:10: error: conflicting declaration\
    \ \u2018auto end\u2019\n   52 |     auto end = std::find(s.begin(), s.end(), '9');\n\
    \      |          ^~~\n/tmp/tmppjx9ud6d.cpp:28:10: note: previous declaration\
    \ as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > end\u2019\n   28 |     auto end = std::find(s.begin(), s.end(), 'z');\n  \
    \    |          ^~~\n/tmp/tmppjx9ud6d.cpp:63:10: error: conflicting declaration\
    \ \u2018auto start\u2019\n   63 |     auto start = std::find(s.begin(), s.end(),\
    \ ' ');\n      |          ^~~~~\n/tmp/tmppjx9ud6d.cpp:27:10: note: previous declaration\
    \ as \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > start\u2019\n   27 |     auto start = std::find(s.begin(), s.end(), 'a');\n\
    \      |          ^~~~~\n/tmp/tmppjx9ud6d.cpp:64"
  stdout: ''
  timestamp: 1660141067
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  for(std::string s: s)\n  for(int i=0; i<s.length(); i++)\n  if(s[i]!='a')\n\
    \  if(s[i]!='e')\n  if(s[i]!='i')\n  if(s[i]!='o')\n  if(s[i]!='u')\n  if(s[i]!='e')\n\
    \  if(s[i]!='a')\n  if(s[i]!='u')\n  if(s[i]!='o')\n  if(s[i]!='e')\n  if(s[i]!='i')\n\
    \  if(s[i]!='o')\n  if(s[i]!='i')\n  if(s[i]!='o')\n  if(s[i]!='u')\n  if(s[i]!='e')\n\
    \  if(s[i]!='a')\n  if(s[i]!='u')\n  if(s[i]!='e')\n  if(s[i]!='i')\n  if(s[i]!='o')\n\
    \  if(s[i]!='i')\n  if(s[i]!='o')\n  if(s[i]!='u')\n  if(s[i]!='e')\n  if(s[i]!='a')\n\
    \  if(s[i]!='u')\n  if(s[i]!='e')\n  if(s[i]!='i')\n  if(s[i]!='o')\n  if(s[i]!='i')\n\
    \  if(s[i]!='o')\n  if(s[i]!='u')\n  if(s[i]!='e')\n  if(s[i]!='a')\n  if(s[i]!='u')\n\
    \  if(s[i]!='e')\n  if(s[i]!='i')\n  if(s[i]!='o')\n  if(s[i]!='i')\n  if(s[i]!='o')\n\
    \  if(s[i]!='u')\n  if(s[i]!='e')\n  if(s[i]!='a')\n  if(s[i]!='u')\n  if(s[i]!='e')\n\
    \  if(s[i]!='i')\n  if(s[i]!='o')\n  if(s[i]!='i')\n  if(s[i]!='o')\n  if(s[i]!='u')\n\
    \  if(s[i]!='e')\n  if(s[i]!='a')\n  if(s[i]!='u')\n  if(s[i]!='e')\n  if(s[i]!='i')\n\
    \  if(s[i]!='o')\n  if(s[i]!='i')\n  if(s[i]!='o')\n  if(s[i]!='u')\n  if(s[i]!='e')\n\
    \  if(s[i]!='a')\n  if(s[i]!='u\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn3_donne.cpp:85:12: warning: missing terminating ' character\n\
    \   85 |   if(s[i]!='u\n      |            ^\n/tmp/tmpn3_donne.cpp:85:12: error:\
    \ missing terminating ' character\n   85 |   if(s[i]!='u\n      |            ^~\n\
    /tmp/tmpn3_donne.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpn3_donne.cpp:21:22: error:\
    \ conversion from \u2018char\u2019 to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   21 |   for(std::string\
    \ s: s)\n      |                      ^\n/tmp/tmpn3_donne.cpp:86:1: error: expected\
    \ primary-expression before \u2018}\u2019 token\n   86 | }\n      | ^\n/tmp/tmpn3_donne.cpp:85:12:\
    \ error: expected \u2018)\u2019 before \u2018}\u2019 token\n   85 |   if(s[i]!='u\n\
    \      |     ~      ^\n      |            )\n   86 | }\n      | ~           \n\
    /tmp/tmpn3_donne.cpp:86:1: error: expected primary-expression before \u2018}\u2019\
    \ token\n   86 | }\n      | ^\n/tmp/tmpn3_donne.cpp:86:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141067
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Your code\
    \ here\n    std::vector<std::string> v;\n    for(std::string::const_iterator i\
    \ = s.begin(); i != s.end(); ++i){\n        if((*i).length() == n)\n         \
    \   v.push_back((*i));\n    }\n    return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pw7mpru.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp6pw7mpru.cpp:23:17: error:\
    \ request for member \u2018length\u2019 in \u2018i.__gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >::operator*()\u2019, which is of non-class\
    \ type \u2018const char\u2019\n   23 |         if((*i).length() == n)\n      |\
    \                 ^~~~~~\n/tmp/tmp6pw7mpru.cpp:24:29: error: no matching function\
    \ for call to \u2018std::vector<std::__cxx11::basic_string<char> >::push_back(const\
    \ char&)\u2019\n   24 |             v.push_back((*i));\n      |              \
    \               ^\nIn file included from /usr/include/c++/9/vector:67,\n     \
    \            from /usr/include/c++/9/functional:62,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmp6pw7mpru.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7: note:\
    \ candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018const char\u2019 to \u2018\
    const value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019\
    }\n 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/in"
  stdout: ''
  timestamp: 1660141067
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ words;\n    std::string word = \"\";\n    // Write your code here\n    for (size_t\
    \ i = 0; i < s.size(); i++) {\n        if (s[i] == 'a') {\n            word =\
    \ word + \"a\";\n        } else if (s[i] == 'e') {\n            word = word +\
    \ \"e\";\n        } else if (s[i] == 'i') {\n            word = word + \"i\";\n\
    \        } else if (s[i] == 'o') {\n            word = word + \"o\";\n       \
    \ } else if (s[i] == 'u') {\n            word = word + \"u\";\n        } else\
    \ if (s[i] == 'y') {\n            word = word + \"y\";\n        } else {\n   \
    \         words.push_back(word);\n            word = s[i];\n        }\n    }\n\
    \    if (word.size() > 0) {\n        words.push_back(word);\n    }\n    return\
    \ words;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp8zahxdy4: /tmp/tmp8zahxdy4.cpp:48: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141068
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  assert(!s.empty());\n\
    \  std::vector<std::string> words;\n  std::set<char> letters;\n  for (int i=0;\
    \ i<s.size(); i++) {\n    if (std::isalpha(s[i])) letters.insert(s[i]);\n  }\n\
    \  for (char c : letters) {\n    if (n==1) {\n      words.push_back((std::string)s.substr(0,\
    \ i));\n      return words;\n    }\n    else if (n>1) {\n      long count = 0;\n\
    \      std::string curWord;\n      for (int j=0; j<s.size(); j++) {\n        if\
    \ (letters.find(s[j])!=letters.end()) count++;\n        else if ((s[j]==c)&&(count==n))\
    \ {\n          curWord = s.substr(0, j);\n          words.push_back((std::string)curWord);\n\
    \        }\n      }\n    }\n  }\n  return words;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0nt5wz2a.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp0nt5wz2a.cpp:28:48: error:\
    \ \u2018i\u2019 was not declared in this scope\n   28 |       words.push_back((std::string)s.substr(0,\
    \ i));\n      |                                                ^\n"
  stdout: ''
  timestamp: 1660141068
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ result;\n    long count = 0;\n    for (char c : s) {\n        if (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n    \
    \    }\n    }\n    if (count == n) {\n        result.push_back((std::string)(s));\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpomx0a4jc: /tmp/tmpomx0a4jc.cpp:34: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141069
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  // Write your\
    \ code here\n  return s;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp83xqx1w4.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp83xqx1w4.cpp:21:10: error:\
    \ could not convert \u2018s\u2019 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n   21 |   return\
    \ s;\n      |          ^\n      |          |\n      |          std::string {aka\
    \ std::__cxx11::basic_string<char>}\n"
  stdout: ''
  timestamp: 1660141068
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n\t// Write your\
    \ code here\n\treturn s;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2q6u3zcx.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp2q6u3zcx.cpp:21:9: error:\
    \ could not convert \u2018s\u2019 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n   21 |  return\
    \ s;\n      |         ^\n      |         |\n      |         std::string {aka std::__cxx11::basic_string<char>}\n"
  stdout: ''
  timestamp: 1660141068
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    if (s.empty())\n        return v;\n\n    v.push_back((std::string)s);\n\
    \    \n    for (auto i = s.rbegin(); i != s.rend(); ++i)\n    {\n        if (n--\
    \ == 0)\n            break;\n        \n        // if the current char is a consonant,\
    \ add it to the current vector \n        if (*i == 'a')\n            v.push_back((std::string)s.substr(0,\
    \ i+1));\n    }\n\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2i4e2t6c.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp2i4e2t6c.cpp:33:51: error:\
    \ cannot convert \u2018std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n   33 |             v.push_back((std::string)s.substr(0,\
    \ i+1));\n      |                                                  ~^~\n     \
    \ |                                                   |\n      |             \
    \                                      std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp2i4e2t6c.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2838:45:\
    \ note:   initializing argument 2 of \u2018std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::substr(std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2838 |       substr(size_type __pos = 0, size_type __n = npos)\
    \ const\n      |                                   ~~~~~~~~~~^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660141068
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::sort(s.begin(),\
    \ s.end());\n    std::vector<std::string> res;\n    std::string::size_type begin\
    \ = 0, end;\n    long count = 0;\n    for (auto it = s.cbegin(); it != s.cend();\
    \ ++it) {\n        if (*it == '\\'') {\n            begin = s.find_first_of(it,\
    \ s.end());\n        } else if (begin != s.end() && *it == s[begin]) {\n     \
    \       begin = s.find_first_not_of(it, s.end());\n        } else if (begin !=\
    \ s.end() && *it != s[begin]) {\n            count++;\n        }\n        end\
    \ = s.find_first_of(begin + 2, s.end());\n        if (end != s.end()) {\n    \
    \        if (count >= n) {\n                res.push_back({s.substr(begin + 1,\
    \ end - begin - 1)});\n                count = 0;\n            }\n        }\n\
    \        begin = end;\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoptua0n3.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpoptua0n3.cpp:26:48: error:\
    \ no matching function for call to \u2018std::__cxx11::basic_string<char>::find_first_of(__gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >&, std::__cxx11::basic_string<char>::iterator)\u2019\
    \n   26 |             begin = s.find_first_of(it, s.end());\n      |         \
    \                                       ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpoptua0n3.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2506:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find_first_of(const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2506 |       find_first_of(const basic_string& __str, size_type\
    \ __pos = 0) const\n      |       ^~~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2506:41:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> >\u2019 to \u2018const std::__cxx11::basic_string<char>&\u2019\
    \n 2506 |       find_first_of(const basic_string& __str, size_type __pos = 0)\
    \ const\n      |                     ~~~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/bits/ba"
  stdout: ''
  timestamp: 1660141068
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  if(!s.empty()) {\n    for(int i = 0; i < s.length(); i++) {\n      if(s[i]\
    \ != 'a' && s[i] != 'e' && s[i] != 'i' && s[i] != 'o' && s[i] != 'u' && s[i] !=\
    \ 'y' && s[i] != '\\0') {\n        v.push_back((s + \" \" + std::to_string(i)));\n\
    \      }\n    }\n  }\n  return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp4m8oboy3: /tmp/tmp4m8oboy3.cpp:32: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141070
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    if (n == 1) {\n        return v;\n    }\n    char c = s[0][0];\n   \
    \ for (size_t i = 1; i < s.size(); i++) {\n        if (s[i] != c) {\n        \
    \    break;\n        }\n    }\n    for (size_t i = 0; i < i; i += n) {\n     \
    \   v.push_back(s.substr(i, n));\n    }\n    return v;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp09ay9vbq.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp09ay9vbq.cpp:24:20: error:\
    \ invalid types \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\
    \ {aka char}[int]\u2019 for array subscript\n   24 |     char c = s[0][0];\n \
    \     |                    ^\n"
  stdout: ''
  timestamp: 1660141068
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  assert(s.size()\
    \ > 0);\n  std::vector<std::string> v;\n  long start = 0, end = 0;\n  // Count\
    \ how many words in string s contains n consonants\n  for (int i = 0; i < s.size();\
    \ ++i) {\n    if (s[i] == 'a') {\n      start++;\n    }\n    if (s[i] == 'e')\
    \ {\n      end++;\n    }\n  }\n  // Iterate through all consonants in s until\
    \ we find an consonant \n  // that matches with start\n  end = s.size()-1;\n \
    \ for (int i = 0; i < s.size(); ++i) {\n    if (s[i] == 'a' || s[i] == 'e') {\n\
    \      if (start == end) {\n        v = (end - start > n) ? v : v + {s.substr(start,\
    \ end - start)};\n        start = i - 1;\n      }\n    }\n  }\n  return v;\n}\n\
    int main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary\
    \ had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp12trc6rh.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp12trc6rh.cpp:38:41: error:\
    \ expected primary-expression before \u2018{\u2019 token\n   38 |         v =\
    \ (end - start > n) ? v : v + {s.substr(start, end - start)};\n      |       \
    \                                  ^\n"
  stdout: ''
  timestamp: 1660141068
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // write your\
    \ code in C++14 or C++17\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpis9b9vjc: /tmp/tmpis9b9vjc.cpp:24: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141069
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ ans;\n    // your code here\n    if (s.size() == 0) {\n        ans.clear();\n\
    \        return ans;\n    }\n    std::vector<std::pair<long, int>> counts;\n \
    \   for (char c : s) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u') {\n            counts[c - 'a']++;\n        }\n    }\n    for (long\
    \ i = 0; i < 26; i++) {\n        if (counts[i].second == n) {\n            ans.push_back(std::to_string(i));\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsi78aqkk.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpsi78aqkk.cpp:29:28: error:\
    \ no \u2018operator++(int)\u2019 declared for postfix \u2018++\u2019 [-fpermissive]\n\
    \   29 |             counts[c - 'a']++;\n"
  stdout: ''
  timestamp: 1660141069
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ result;\n  if (s.empty()) {\n    return result;\n  }\n  std::stack<char> st;\n\
    \  st.push(s[0]);\n  for (char c : s) {\n    if (st.empty()) {\n      st.push(c);\n\
    \      continue;\n    }\n    if (c == st.top()) {\n      st.pop();\n    } else\
    \ {\n      if (st.size() == n) {\n        result.push_back(st.top());\n      \
    \  st.pop();\n      } else {\n        st.push(c);\n      }\n    }\n  }\n  return\
    \ result;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprzjsnwv9.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmprzjsnwv9.cpp:35:34: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type&)\u2019\
    \n   35 |         result.push_back(st.top());\n      |                       \
    \           ^\nIn file included from /usr/include/c++/9/vector:67,\n         \
    \        from /usr/include/c++/9/functional:62,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmprzjsnwv9.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7: note:\
    \ candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to \u2018const value_type&\u2019\
    \ {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 1184 |       push_back(const\
    \ value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::v"
  stdout: ''
  timestamp: 1660141069
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::vector<std::string>\
    \ > ret;\n    if (s.empty()) {\n        return ret;\n    }\n    std::string curr\
    \ = s[0];\n    std::vector<std::string> words;\n    for (auto it = s.begin() +\
    \ 1; it < s.end(); it++) {\n        if (it[0] == curr) {\n            if (s.size()\
    \ - it == n) {\n                words.push_back(s);\n                words.push_back(s.substr(it,\
    \ 1));\n                ret.push_back(words);\n            }\n        }\n    \
    \    else if (s.find(curr) == s.end()) {\n            words.push_back(s);\n  \
    \          words.push_back(curr);\n            ret.push_back(words);\n       \
    \ }\n        curr = *it;\n    }\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzkc80_1v.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpzkc80_1v.cpp:22:16: error:\
    \ could not convert \u2018ret\u2019 from \u2018vector<std::vector<std::__cxx11::basic_string<char>\
    \ >>\u2019 to \u2018vector<std::__cxx11::basic_string<char>>\u2019\n   22 |  \
    \       return ret;\n      |                ^~~\n      |                |\n  \
    \    |                vector<std::vector<std::__cxx11::basic_string<char> >>\n\
    /tmp/tmpzkc80_1v.cpp:24:27: error: conversion from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to non-scalar type \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} requested\n   24 |     std::string\
    \ curr = s[0];\n      |                           ^\n/tmp/tmpzkc80_1v.cpp:27:19:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018char\u2019\
    \ and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   27 |         if (it[0] == curr) {\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpzkc80_1v.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpzkc80_1v.cpp:27:22:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   27 |         if (it[0] == curr) {\n      |        \
    \              ^~~~\nIn file included from /usr/include/c++/9/regex:62,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n  \
    \               from /tmp/tmpzkc80_1v.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::opera"
  stdout: ''
  timestamp: 1660141069
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  // Pre-condition:\
    \ 0 < n <= s.size()\n  assert(n <= s.size());\n  // If the string s is empty then\
    \ return an empty vector\n  if (s.empty()) {\n    return std::vector<std::string>();\n\
    \  }\n  // If the string s is already a vector of strings, return it\n  if (std::all_of(s.begin(),\
    \ s.end(), [](const std::string& s) {\n                  return std::all_of(s.begin(),\
    \ s.end(), \n                                    [](const char c) {\n        \
    \                              return std::isalpha(c);\n                     \
    \               });\n                })) {\n    return s;\n  }\n  // We will store\
    \ the vector here\n  std::vector<std::string> words;\n  // We will store the index\
    \ of the first letter here\n  size_t first = 0;\n  // We will store the number\
    \ of consonants found here \n  size_t count = 0;\n  // We will loop through s\
    \ and find all consonants \n  for (int i = 0; i < s.size(); i++) {\n    // We\
    \ need to skip spaces and letters so add them to the word only if\n    // they\
    \ are a space or letter\n    if (std::isalpha(s[i]) || std::isspace(s[i])) {\n\
    \      if (count == n) {\n        // We have enough consonants so store the word\n\
    \        words.push_back(s.substr(first, i - first));\n        // Move the index\
    \ forward\n        first = i + 1;\n        // Increment the number of consonants\
    \ found\n        count = 1;\n      } else {\n        // We have not enough consonants\
    \ so we just increment the index\n        first = i + 1;\n        count = 1;\n\
    \      }\n    }\n  }\n  // Return the words we found\n  return words;\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3ax9ytv_.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp3ax9ytv_.cpp:33:12: error:\
    \ could not convert \u2018s\u2019 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018std::vector<std::__cxx11::basic_string<char> >\u2019\n   33 |     return\
    \ s;\n      |            ^\n      |            |\n      |            std::string\
    \ {aka std::__cxx11::basic_string<char>}\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp3ax9ytv_.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_negate<_Predicate>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Predicate = select_words(std::string, long int)::<lambda(const string&)>]\u2019\
    :\n/usr/include/c++/9/bits/stl_algo.h:120:14:   required from \u2018_RandomAccessIterator\
    \ std::__find_if(_RandomAccessIterator, _RandomAccessIterator, _Predicate, std::random_access_iterator_tag)\
    \ [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Predicate = __gnu_cxx::__ops::_Iter_negate<select_words(std::string, long\
    \ int)::<lambda(const string&)> >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:171:28:\
    \   required from \u2018_InputIterator std::__find_if_not(_InputIterator, _InputIterator,\
    \ _Predicate) [with _InputIterator = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Predicate = __gnu_cxx::__ops::_Iter_pred<select_words(std::string, long\
    \ int)::<lambda(const string&)> >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:566:32:\
    \   required from \u2018_IIter std::find_if_not(_IIter, _IIter, _Predicate) [with\
    \ _IIter = __gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >; _Predicate = select_words(std::string, long int)::<l"
  stdout: ''
  timestamp: 1660141069
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    int start\
    \ = 0;\n    std::vector<std::string> result;\n    while (start < s.size()) {\n\
    \        if (s[start] == 'a' && s[start+1] == 'l' && s[start+2] == 'm' && s[start+3]\
    \ == 'a' && s[start+4] == 'l' && s[start+5] == 'a' && s[start+6] == 'l') {\n \
    \           result.emplace_back(s.substr(start, (start+7)));\n            start\
    \ += 8;\n        }\n        else if (s[start] == 'p' && s[start+1] == 'a' && s[start+2]\
    \ == 'l' && s[start+3] == 'e') {\n            result.emplace_back(s.substr(start,\
    \ (start+4)));\n            start += 5;\n        }\n        else if (s[start]\
    \ == 's' && s[start+1] == 'p' && s[start+2] == 'i' && s[start+3] == 't') {\n \
    \           result.emplace_back(s.substr(start, (start+4)));\n            start\
    \ += 4;\n        }\n        else if (s[start] == 't' && s[start+1] == 'h' && s[start+2]\
    \ == 'i' && s[start+3] == 's') {\n            result.emplace_back(s.substr(start,\
    \ (start+4)));\n            start += 4;\n        }\n        else if (s[start]\
    \ == 'w' && s[start+1] == 'o' && s[start+2] == 'd' && s[start+3] == 'a') {\n \
    \           result.emplace_back(s.substr(start, (start+4)));\n            start\
    \ += 5;\n        }\n        else if (s[start] == 'w' && s[start+1] == 'o' && s[start+2]\
    \ == 'd' && s[start+3] == 'a' && s[start+4] == 'l' && s[start+5] == 'l' && s[start+6]\
    \ == 'e') {\n            result.emplace_back(s.substr(start, (start+7)));\n  \
    \          start += 8;\n        }\n        else if (s[start] == 'c' && s[start+1]\
    \ == 'o' && s[start+2] == 's' && s[start+3] == 'e') {\n            result.emplace_back(s.substr(start,\
    \ (start+4)));\n            start += 5;\n        }\n        else if (s[start]\
    \ == 'c' && s[start+1] == 'o' && s[start+2] == 's' && s[start+3] == 'e' && s[start+4]\
    \ == 'd') {\n            result.emplace_back(s.substr(start, (start+5)));\n  \
    \          start += 6;\n        }\n        else if (s[start] == 't' && s[start+1]\
    \ == 'e' && s[start+2] == 'c' && s[start+3] == 'h' && s[start+4] == 'e') {\n \
    \           result.emplace_back(s.substr(start, (start+5)));\n            start\
    \ += 6;\n        }\n\n}\nint main() {\n    auto candidate = select_words;\n  \
    \  assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgl4jw3ez.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpgl4jw3ez.cpp:61:12: error:\
    \ a function-definition is not allowed here before \u2018{\u2019 token\n   61\
    \ | int main() {\n      |            ^\n/tmp/tmpgl4jw3ez.cpp:70:1: error: expected\
    \ \u2018}\u2019 at end of input\n   70 | }\n      | ^\n/tmp/tmpgl4jw3ez.cpp:19:62:\
    \ note: to match this \u2018{\u2019\n   19 | std::vector<std::string> select_words(std::string\
    \ s, long n) {\n      |                                                      \
    \        ^\n/tmp/tmpgl4jw3ez.cpp:70:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   70 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141069
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v; \n    if (s.empty()) {\n        return v;\n    }\n    \n    // Implement\
    \ your algorithm here\n}\nint main() {\n    auto candidate = select_words;\n \
    \   assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpl3hjr_v7: /tmp/tmpl3hjr_v7.cpp:29: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141070
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.empty())\
    \ return {std::string(\"\")};\n    std::vector<std::tuple<std::string, std::string,\
    \ std::string>> res;\n    std::string word;\n    for (size_t i = 0, n = s.length();\
    \ i < n; i++) {\n        word = s.substr(i, 1);\n        if (std::count_if(s.begin(),\
    \ s.end(), [&](char c) { return c == 'a'; }) >= n ||\n            std::count_if(s.begin(),\
    \ s.end(), [&](char c) { return c == 'e'; }) >= n ||\n            std::count_if(s.begin(),\
    \ s.end(), [&](char c) { return c == 'i'; }) >= n ||\n            std::count_if(s.begin(),\
    \ s.end(), [&](char c) { return c == 'o'; }) >= n ||\n            std::count_if(s.begin(),\
    \ s.end(), [&](char c) { return c == 'u'; }) >= n) {\n            res.push_back({std::string(word)});\n\
    \        }\n    }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptwz6j3sg.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmptwz6j3sg.cpp:30:46: error:\
    \ no matching function for call to \u2018std::vector<std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > > >::push_back(<brace-enclosed\
    \ initializer list>)\u2019\n   30 |             res.push_back({std::string(word)});\n\
    \      |                                              ^\nIn file included from\
    \ /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptwz6j3sg.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> >, std::__cxx11::basic_string<char, std::char_traits<char>,\
    \ std::allocator<char> > >; _Alloc = std::allocator<std::tuple<std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> >, std::__cxx11::basic_string<char,\
    \ std::char_traits<char>, std::allocator<char> > > >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::tuple<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ >, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>\
    \ > >]\u2019\n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n\
    /usr/include/c++/9/bits"
  stdout: ''
  timestamp: 1660141069
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // write your\
    \ code here\n    std::vector<std::string> vs;\n    if (s.empty()) return vs;\n\
    \    stack<char> s;\n    for (size_t i = 0; s[i]; ++i){\n        s.push( s[i]\
    \ );\n    }\n    while(s.size() >= n) {\n        s.push(s.pop());\n    }\n   \
    \ if (s.size() == n) return vs;\n    \n    for (size_t i = 0; i < s.size(); i++){\n\
    \        if (s.top() == s[i]) s.pop();\n        else vs.push_back((std::string)(s.top()));\n\
    \        s.push( s[i] );\n    }\n    return vs;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcp95qhe1.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpcp95qhe1.cpp:23:5: error:\
    \ \u2018stack\u2019 was not declared in this scope; did you mean \u2018std::stack\u2019\
    ?\n   23 |     stack<char> s;\n      |     ^~~~~\n      |     std::stack\nIn file\
    \ included from /usr/include/c++/9/stack:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpcp95qhe1.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpcp95qhe1.cpp:23:11: error: expected primary-expression\
    \ before \u2018char\u2019\n   23 |     stack<char> s;\n      |           ^~~~\n\
    /tmp/tmpcp95qhe1.cpp:25:11: error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018push\u2019\n   25 |         s.push( s[i] );\n    \
    \  |           ^~~~\n/tmp/tmpcp95qhe1.cpp:28:11: error: \u2018std::string\u2019\
    \ {aka \u2018class std::__cxx11::basic_string<char>\u2019} has no member named\
    \ \u2018push\u2019\n   28 |         s.push(s.pop());\n      |           ^~~~\n\
    /tmp/tmpcp95qhe1.cpp:28:18: error: \u2018std::string\u2019 {aka \u2018class std::__cxx11::basic_string<char>\u2019\
    } has no member named \u2018pop\u2019\n   28 |         s.push(s.pop());\n    \
    \  |                  ^~~\n/tmp/tmpcp95qhe1.cpp:33:15: error: \u2018std::string\u2019\
    \ {aka \u2018class std::__cxx11::basic_string<char>\u2019} has no member named\
    \ \u2018top\u2019\n   33 |         if (s.top() == s[i]) s.pop();\n      |    \
    \           ^~~\n/tmp/tmpcp95qhe1.cpp:33:32: error: \u2018std::string\u2019 {aka\
    \ \u2018class std::__cxx11::basic_string<char>\u2019} has no member named \u2018\
    pop\u2019\n   33 |         if (s.top() == s[i]) s.pop();\n      |            \
    \                    ^~~\n/tmp/tmpcp95qhe1.cpp:34:43: error: \u2018std::string\u2019\
    \ {aka \u2018class std::__cxx11::basic_string<char>\u2019} has no member named\
    \ \u2018top\u2019\n   34 |         else vs.push_back((std::string)(s.top()));\n\
    \      |                                           ^~~\n/tmp/tmpcp95qhe1.cpp:35:11:\
    \ error: \u2018std::string\u2019 {aka \u2018c"
  stdout: ''
  timestamp: 1660141069
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Write your\
    \ code here\n    std::vector<std::string> v;\n    \n    long count = 1;\n    for\
    \ (auto c : s){\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n      \
    \      count += 1;\n        else if (c == 'b' || c == 'c' || c == 'd' || c ==\
    \ 'f' || c == 'g' || c == 'B' || c == 'C' || c == 'D' || c == 'F' || c == 'G')\n\
    \            count += 2;\n        else if (c == 'h' || c == 'j' || c == 'k' ||\
    \ c == 'l' || c == 'm' || c == 'H' || c == 'J' || c == 'K' || c == 'L' || c ==\
    \ 'M')\n            count += 3;\n        else if (c == 'n' || c == 'p' || c ==\
    \ 'q' || c == 'r' || c == 's' || c == 'N' || c == 'P' || c == 'Q' || c == 'R'\
    \ || c == 'S')\n            count += 4;\n        else if (c == 't' || c == 'v'\
    \ || c == 'x' || c == 'z')\n            count += 5;\n        else if (c == '1')\n\
    \            count += 6;\n        else if (c == '2')\n            count += 7;\n\
    \        else if (c == '3')\n            count += 8;\n        else if (c == '4')\n\
    \            count += 9;\n        else if (c == '5')\n            count += 10;\n\
    \        else if (c == '6')\n            count += 11;\n        else if (c == '7')\n\
    \            count += 12;\n        else if (c == '8')\n            count += 13;\n\
    \        else if (c == '9')\n            count += 14;\n        else if (c == '0')\n\
    \            count += 15;\n        else if (c == ' ')\n            count += 16;\n\
    \        else\n        {\n            v.push_back(s);\n            count = 1;\n\
    \        }\n        if (count == n)\n            break;\n    }\n    return v;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp590mdtnk: /tmp/tmp590mdtnk.cpp:69: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141070
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Your code\
    \ here\n    std::vector<std::string> result;\n    for (auto &c : s) {\n      \
    \  if (std::isalpha(c)) {\n            if (n == 1) {\n                result.emplace_back(s);\n\
    \            } else {\n                result.emplace_back(c);\n            }\n\
    \        } else if (std::isspace(c)) {\n            if (result.size() == 0) {\n\
    \                result.emplace_back(s);\n            } else {\n             \
    \   if (result.size() >= n - 1) {\n                    result.emplace_back(s);\n\
    \                }\n            }\n        } else {\n            if (result.size()\
    \ == 0) {\n                result.emplace_back(s);\n            } else {\n   \
    \             if (result.size() >= n - 1) {\n                    result.emplace_back(s);\n\
    \                }\n            }\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/c++allocator.h:33,\n\
    \                 from /usr/include/c++/9/bits/allocator.h:46,\n             \
    \    from /usr/include/c++/9/string:41,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpmoqoyitf.cpp:2:\n/usr/include/c++/9/ext/new_allocator.h: In instantiation\
    \ of \u2018void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with\
    \ _Up = std::__cxx11::basic_string<char>; _Args = {char&}; _Tp = std::__cxx11::basic_string<char>]\u2019\
    :\n/usr/include/c++/9/bits/alloc_traits.h:483:4:   required from \u2018static\
    \ void std::allocator_traits<std::allocator<_CharT> >::construct(std::allocator_traits<std::allocator<_CharT>\
    \ >::allocator_type&, _Up*, _Args&& ...) [with _Up = std::__cxx11::basic_string<char>;\
    \ _Args = {char&}; _Tp = std::__cxx11::basic_string<char>; std::allocator_traits<std::allocator<_CharT>\
    \ >::allocator_type = std::allocator<std::__cxx11::basic_string<char> >]\u2019\
    \n/usr/include/c++/9/bits/vector.tcc:115:30:   required from \u2018std::vector<_Tp,\
    \ _Alloc>::reference std::vector<_Tp, _Alloc>::emplace_back(_Args&& ...) [with\
    \ _Args = {char&}; _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::reference = std::__cxx11::basic_string<char>&]\u2019\
    \n/tmp/tmpmoqoyitf.cpp:27:38:   required from here\n/usr/include/c++/9/ext/new_allocator.h:146:4:\
    \ error: no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(char&)\u2019\
    \n  146 |  { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }\n     \
    \ |    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660141069
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ ans;\n    while(true) {\n        std::unordered_set<char> words;\n        int\
    \ word_len = 0;\n        for(int i=0;i<s.size();i++) {\n            if(isalpha(s[i])\
    \ || s[i]==' ') \n                words.insert(s[i]);\n        }\n        std::vector<std::string>\
    \ word_vector;\n        for(int i=0;i<s.size();i++) {\n            if(words.size()\
    \ <= word_len && isalpha(s[i])) \n                word_vector.push_back(s[i]);\n\
    \            if(s[i]==' ' || s[i]=='\\n' || s[i]=='\\t' || s[i]=='.' || s[i]=='!')\
    \ \n                word_len++;\n        }\n        if(n==word_len || word_vector.size()==n)\
    \ \n            ans.push_back(word_vector);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3gnv74e1.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp3gnv74e1.cpp:31:43: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type&)\u2019\
    \n   31 |                 word_vector.push_back(s[i]);\n      |              \
    \                             ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3gnv74e1.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to \u2018const value_type&\u2019\
    \ {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 1184 |       push_back(const\
    \ value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(value_type&&\
    \ __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocat"
  stdout: ''
  timestamp: 1660141069
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ result;\n  for(long i = 0; i < s.length(); ++i) {\n    if(s[i] == ' ') {\n \
    \     result.emplace_back(s.substr(0, i + 1));\n    }\n    else if((s[i] == 'a'\
    \ || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u')\n        && (s[i\
    \ + 1] == ' ' || s[i + 1] == 'a' || s[i + 1] == 'e' || s[i + 1] == 'i' || s[i\
    \ + 1] == 'o' || s[i + 1] == 'u') &&\n        (i + 2 < s.length() && (s[i + 2]\
    \ == 'a' || s[i + 2] == 'e' || s[i + 2] == 'i' || s[i + 2] == 'o' || s[i + 2]\
    \ == 'u'))) {\n      result.emplace_back(s.substr(0, i));\n      result.emplace_back(s.substr(i\
    \ + 1));\n      result.emplace_back(s.substr(i + 2));\n    }\n    else if(i +\
    \ 1 == s.length() && s[i] == ' ') {\n      result.emplace_back(s.substr(0, i +\
    \ 1));\n    }\n    else if(s[i] == ' ' && s[i + 1] == 'a' && s[i + 2] == ' ')\
    \ {\n      result.emplace_back(s.substr(0, i));\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp_zludwl7: /tmp/tmp_zludwl7.cpp:43: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141070
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  for (int i = 0; i < s.length(); i++) {\n    int count = 0;\n    for (int\
    \ j = i; j < s.length(); j++) {\n      if (s[i] == s[j]) {\n        count++;\n\
    \      }\n    }\n    if (count == n) {\n      v.push_back(s.substr(i, i - n));\n\
    \    }\n  }\n  return v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp2upak4u1: /tmp/tmp2upak4u1.cpp:36: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    if(!s || n <= 0){\n        return res;\n    }\n    // Write your code\
    \ here\n    res.reserve(s.size());\n    auto it = s.begin();\n    auto itr = find(s.begin(),\
    \ s.end(), ' ');\n    while(itr != s.end()){\n        if(n == 1){\n          \
    \  res.emplace_back(std::string(it, itr));\n            return res;\n        }\n\
    \        it = std::search(itr, s.end(), 'a', std::cend(), \n            [&](char\
    \ c){return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') && \n \
    \               --n > 0;});\n        if(it != s.end()){\n            res.emplace_back(std::string(it,\
    \ s.end()));\n        }\n        itr = std::search(itr, s.end(), ' ', std::cend(),\
    \ \n            [&](char c){return (c == ' ' || c == ',') && --n > 0;});\n   \
    \ }\n    return res;\n}\nint main() {\n    auto candidate = select_words;\n  \
    \  assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx08n4io_.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpx08n4io_.cpp:21:8: error:\
    \ no match for \u2018operator!\u2019 (operand type is \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019})\n   21 |     if(!s || n\
    \ <= 0){\n      |        ^~\n/tmp/tmpx08n4io_.cpp:21:8: note: candidate: \u2018\
    operator!(bool)\u2019 <built-in>\n/tmp/tmpx08n4io_.cpp:21:8: note:   no known\
    \ conversion for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018bool\u2019\n/tmp/tmpx08n4io_.cpp:33:55: error: no matching function\
    \ for call to \u2018cend()\u2019\n   33 |         it = std::search(itr, s.end(),\
    \ 'a', std::cend(),\n      |                                                 \
    \      ^\nIn file included from /usr/include/c++/9/string:54,\n              \
    \   from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from /usr/include/c++/9/bits/ios_base.h:41,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpx08n4io_.cpp:2:\n/usr/include/c++/9/bits/range_access.h:127:5: note:\
    \ candidate: \u2018template<class _Container> constexpr decltype (std::end(__cont))\
    \ std::cend(const _Container&)\u2019\n  127 |     cend(const _Container& __cont)\
    \ noexcept(noexcept(std::end(__cont)))\n      |     ^~~~\n/usr/include/c++/9/bits/range_access.h:127:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpx08n4io_.cpp:33:55:\
    \ note:   candidate expects 1 argument, 0 provided\n   33 |         it = std::search(itr,\
    \ s.end(), 'a', std::cend(),\n      |                                        \
    \               ^\n/tmp/tmpx08n4io_.cpp:39:56: error: no matching function for\
    \ call to \u2018cend()\u2019\n   39 |         itr = std::search(itr, s.end(),\
    \ ' ', std::cend(),\n      |      "
  stdout: ''
  timestamp: 1660141069
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n   std::vector<std::string>\
    \ res;\n   if (s.size() == 0) {\n      return res;\n   }\n   vector<string> words;\n\
    \   string word = \"\";\n   for (string::iterator it = s.begin(); it != s.end();\
    \ ++it) {\n      if (*it != ' ') {\n         word += *it;\n      }\n   }\n   for\
    \ (string::iterator it = word.begin(); it != word.end(); ++it) {\n      vector<string>\
    \ candidates;\n      for (string::iterator it2 = s.begin(); it2 != s.end(); ++it2)\
    \ {\n         if (*it2 == *it) {\n            candidates.push_back(word + it2);\n\
    \         }\n      }\n      if (candidates.size() == n) {\n         res.push_back(candidates);\n\
    \      }\n   }\n   return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplyidu7ud.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmplyidu7ud.cpp:24:4: error:\
    \ \u2018vector\u2019 was not declared in this scope\n   24 |    vector<string>\
    \ words;\n      |    ^~~~~~\n/tmp/tmplyidu7ud.cpp:24:4: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplyidu7ud.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplyidu7ud.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmplyidu7ud.cpp:24:11:\
    \ error: \u2018string\u2019 was not declared in this scope\n   24 |    vector<string>\
    \ words;\n      |           ^~~~~~\n/tmp/tmplyidu7ud.cpp:24:11: note: suggested\
    \ alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n       \
    \          from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmplyidu7ud.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n \
    \  "
  stdout: ''
  timestamp: 1660141070
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n\tstd::vector<std::string>\
    \ word_list;\n\tstd::map<std::string, int> counts;\n\tint word_size = 0;\n\tstd::string\
    \ word = \"\";\n\tbool first_word = true;\n\tfor (auto c : s) {\n\t\tif (c ==\
    \ ' ' || c == '\\t' || c == '\\n') continue;\n\t\tcounts[c]++;\n\t\tword_size\
    \ += std::to_string(c).length();\n\t}\n\t// count words that need n\n\tfor (auto\
    \ c : counts) {\n\t\tif (c->second >= n) {\n\t\t\tif (first_word) {\n\t\t\t\t\
    word_list.push_back(word);\n\t\t\t\tfirst_word = false;\n\t\t\t\tcounts[c]--;\n\
    \t\t\t\tword_size -= word.length();\n\t\t\t} else {\n\t\t\t\tword_list.push_back(word);\n\
    \t\t\t\tcounts[c]--;\n\t\t\t}\n\t\t}\n\t}\n\t// add the last word if needed\n\t\
    if (first_word) {\n\t\tword_list.push_back(word);\n\t}\n\treturn word_list;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmz3pcvji.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpmz3pcvji.cpp:27:9: error:\
    \ no match for \u2018operator[]\u2019 (operand types are \u2018std::map<std::__cxx11::basic_string<char>,\
    \ int>\u2019 and \u2018char\u2019)\n   27 |   counts[c]++;\n      |         ^\n\
    In file included from /usr/include/c++/9/map:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n\
    \                 from /tmp/tmpmz3pcvji.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:490:7:\
    \ note: candidate: \u2018std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::operator[](const key_type&) [with _Key = std::__cxx11::basic_string<char>;\
    \ _Tp = int; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc =\
    \ std::allocator<std::pair<const std::__cxx11::basic_string<char>, int> >; std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::mapped_type = int; std::map<_Key, _Tp, _Compare, _Alloc>::key_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n  490 |       operator[](const key_type&\
    \ __k)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:490:34: note:\
    \   no known conversion for argument 1 from \u2018char\u2019 to \u2018const key_type&\u2019\
    \ {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n  490 |       operator[](const\
    \ key_type& __k)\n      |                  ~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_map.h:510:7:\
    \ note: candidate: \u2018std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::operator[](std::map<_Key, _Tp, _Compare, _Alloc>::key_type&&)\
    \ [with _Key = std::__cxx11::basic_string<char>; _Tp = int; _Compare = std::less<std::__cxx11::basic_string<char>\
    \ >; _Alloc = std::allocator<std::pair<const std::__cxx11::basic_string<char>,\
    \ int> >; std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type = int; std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::key_type = std::__cxx11::basic_string<char>]\u2019\n\
    \  510 |       operator[](key_type&& __k)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:510:29:\
    \ note:   no known conversion for argum"
  stdout: ''
  timestamp: 1660141070
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  if (s.empty())\n\
    \    return std::vector<std::string>();\n  std::vector<std::string> res;\n  std::vector<std::string>::iterator\
    \ it;\n  \n  for (it = std::sregex_iterator(s.begin(), s.end(), std::regex(\"\
    [^aeiouAEIOU]\"), \n      std::regex_constants::match_flag_s::match_not_dot_newline);\n\
    \      it != std::sregex_iterator(); ++it) {\n    if (*it == \"a\" || \n     \
    \   *it == \"e\" || \n        *it == \"i\" || \n        *it == \"o\" || \n   \
    \     *it == \"u\" || \n        *it == \"A\" || \n        *it == \"E\" || \n \
    \       *it == \"I\" || \n        *it == \"O\" || \n        *it == \"U\")\n  \
    \  {\n      res.push_back(std::string((*it).str(), (*it).length()));\n      std::cout\
    \ << res.back() << std::endl; // uncomment to see all words found\n    }\n   \
    \ else if (res.back().size() + it->length() == n)\n    {\n      res.push_back(std::string((*it).str(),\
    \ (*it).length()));\n      std::cout << res.back() << std::endl; // uncomment\
    \ to see all words found\n    }\n  }\n\n  return res;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7hnaq0ed.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp7hnaq0ed.cpp:26:29: error:\
    \ \u2018match_flag_s\u2019 is not a member of \u2018std::regex_constants\u2019\
    ; did you mean \u2018match_flag_type\u2019?\n   26 |       std::regex_constants::match_flag_s::match_not_dot_newline);\n\
    \      |                             ^~~~~~~~~~~~\n      |                   \
    \          match_flag_type\n/tmp/tmp7hnaq0ed.cpp:27:10: error: no match for \u2018\
    operator!=\u2019 (operand types are \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >\u2019} and \u2018std::__cxx11::sregex_iterator\u2019\
    \ {aka \u2018std::__cxx11::regex_iterator<__gnu_cxx::__normal_iterator<const char*,\
    \ std::__cxx11::basic_string<char> > >\u2019})\n   27 |       it != std::sregex_iterator();\
    \ ++it) {\n      |       ~~ ^~      ~~~~~~~~~~~~~~~~~\n      |       |       \
    \   |\n      |       |          std::__cxx11::sregex_iterator {aka std::__cxx11::regex_iterator<__gnu_cxx::__normal_iterator<const\
    \ char*, std::__cxx11::basic_string<char> > >}\n      |       std::vector<std::__cxx11::basic_string<char>\
    \ >::iterator {aka __gnu_cxx::__normal_iterator<std::__cxx11::basic_string<char>*,\
    \ std::vector<std::__cxx11::basic_string<char> > >}\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp7hnaq0ed.cpp:2:\n/usr/include/c++/9/bits/regex.h:1037:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1037 |     operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1037:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp7hnaq0ed.cpp:27:34:\
    \ note:   \u2018std::vector<std::__cxx11::basic_string<char> >::iterator\u2019\
    \ {aka \u2018__gnu_cxx::"
  stdout: ''
  timestamp: 1660141071
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    stack<bool> st;\n    st.push(true);\n    st.push(true);\n    st.push(false);\n\
    \    \n    for (char c : s) {\n        if (c == ' ' || c == '\\t' || c == ','\
    \ || c == '.') {\n            st.push(true);\n        } else if (c != ' ') {\n\
    \            st.push(false);\n        }\n    }\n    \n    while (st.top()) {\n\
    \        if (st.top()) {\n            st.top() = false;\n            res.emplace_back(s.substr(0,\
    \ s.size() - 1));\n        }\n        \n        int nn = s.size() - 1;\n     \
    \   while (!st.empty() && nn == s.size() - 1) {\n            char c = s.back();\n\
    \            if (c == ' ' || c == '\\t' || c == ',' || c == '.') {\n         \
    \       st.top() = false;\n                s.pop_back();\n                \n \
    \               if (st.top()) {\n                    st.top() = false;\n     \
    \               res.emplace_back(s.substr(0, s.size() - 1));\n               \
    \ }\n            } else {\n                st.top() = false;\n               \
    \ s.pop_back();\n            }\n            \n            nn--;\n        }\n \
    \   }\n    \n    for (size_t i = 0; i < s.size(); i++) {\n        if (!st.empty()\
    \ && s.at(i) == ' ') {\n            st.top() = false;\n            s.pop_back();\n\
    \        }\n    }\n    \n    st.push(true);\n    \n    for (char c : s) {\n  \
    \      if (c == ' ' || c == '\\t' || c == ',' || c == '.') {\n            st.push(true);\n\
    \        } else if (c != ' ') {\n            st.push(false);\n        }\n    }\n\
    \    \n    while (st.top()) {\n        if (st.top()) {\n            st.top() =\
    \ false;\n            res.emplace_back(s.substr(0, s.size() - 1));\n        }\n\
    \        \n        int nn = s.size() - 1;\n        while (!st.empty() && nn ==\
    \ s.size() - 1) {\n            char c = s.back();\n            if (c == ' ' ||\
    \ c == '\\t' || c == ',' || c == '.') {\n                st.top() = false;\n \
    \               s.pop_back();\n                \n                if (st.top())\
    \ {\n                    st.top() = false;\n                    res.emplace_back(s.substr(0,\
    \ s.size() - 1));\n                }\n            } else {\n                st.top()\
    \ = false;\n                s.pop_back();\n            }\n            \n     \
    \       nn--;\n        }\n    }\n    \n    \n    \n    \n    while (s.size() !=\
    \ 0) {\n        if (s.back() == ' ' || s.back() == '\\t' || s.back() == ',' ||\
    \ s.back() == '.') {\n            s.pop_back();\n        }\n    }\n    \n    return\
    \ res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp681rsm8r.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp681rsm8r.cpp:21:5: error:\
    \ \u2018stack\u2019 was not declared in this scope; did you mean \u2018std::stack\u2019\
    ?\n   21 |     stack<bool> st;\n      |     ^~~~~\n      |     std::stack\nIn\
    \ file included from /usr/include/c++/9/stack:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmp681rsm8r.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmp681rsm8r.cpp:21:11: error: expected primary-expression\
    \ before \u2018bool\u2019\n   21 |     stack<bool> st;\n      |           ^~~~\n\
    /tmp/tmp681rsm8r.cpp:22:5: error: \u2018st\u2019 was not declared in this scope;\
    \ did you mean \u2018s\u2019?\n   22 |     st.push(true);\n      |     ^~\n  \
    \    |     s\n"
  stdout: ''
  timestamp: 1660141070
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ result;\n    // Write your code here\n    assert(n <= s.size());\n    for(int\
    \ i = 0; i < s.size(); i++){\n        if(s[i] != \" \"){\n            for(int\
    \ j = 0; j<s.size(); j++){\n                if(j == i){\n                    if(n\
    \ == (s[i] - 'a')){\n                        result.push_back(\"a\");\n      \
    \              }\n                    else{\n                        result.push_back(s[j]);\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   if(s.empty()){\n        return result;\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had\
    \ a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"\
    })));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_91d98rv.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp_91d98rv.cpp:24:20: error:\
    \ ISO C++ forbids comparison between pointer and integer [-fpermissive]\n   24\
    \ |         if(s[i] != \" \"){\n      |                    ^~~\n/tmp/tmp_91d98rv.cpp:31:46:\
    \ error: no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type&)\u2019\
    \n   31 |                         result.push_back(s[j]);\n      |           \
    \                                   ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_91d98rv.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019} to \u2018const value_type&\u2019\
    \ {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 1184 |       push_back(const\
    \ value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_vector.h:1200:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp,\
    \ _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>; _Alloc\
    \ = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp, _Alloc>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n 1200 |       push_back(va"
  stdout: ''
  timestamp: 1660141070
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::stack<std::string>\
    \ s; \n    for(int i=0;i<s.length();i++) {\n        if(s[i] == 'A'||s[i] == 'U'||s[i]\
    \ == 'L'||s[i] == 'S') {\n            s.push(s.top());\n        }\n        if(s[i]\
    \ == 'B'||s[i] == 'I'||s[i] == 'K'||s[i] == 'N'||s[i] == 'M'||s[i] == 'R') {\n\
    \            s.push(s.top());\n        }\n        if(s[i] == 'C'||s[i] == 'O'||s[i]\
    \ == 'P'||s[i] == 'T'||s[i] == 'V'||s[i] == 'W') {\n            s.push(s.top());\n\
    \        }\n        if(s[i] == 'D'||s[i] == 'E'||s[i] == 'F'||s[i] == 'H'||s[i]\
    \ == 'P'||s[i] == 'Y') {\n            s.push(s.top());\n        }\n        if(s[i]\
    \ == 'G'||s[i] == 'J'||s[i] == 'L'||s[i] == 'Q'||s[i] == 'S'||s[i] == 'X') {\n\
    \            s.push(s.top());\n        }\n        if(s[i] == 'H'||s[i] == 'J'||s[i]\
    \ == 'K'||s[i] == 'N'||s[i] == 'U'||s[i] == 'X') {\n            s.push(s.top());\n\
    \        }\n        if(s[i] == 'I'||s[i] == 'O'||s[i] == 'P'||s[i] == 'T'||s[i]\
    \ == 'Y'||s[i] == 'W') {\n            s.push(s.top());\n        }\n        if(s[i]\
    \ == 'K'||s[i] == 'Q'||s[i] == 'R'||s[i] == 'S'||s[i] == 'U'||s[i] == 'Y') {\n\
    \            s.push(s.top());\n        }\n        if(s[i] == 'L'||s[i] == 'Q'||s[i]\
    \ == 'S'||s[i] == 'T'||s[i] == 'Y'||s[i] == 'W') {\n            s.push(s.top());\n\
    \        }\n        if(s[i] == 'M'||s[i] == 'O'||s[i] == 'R'||s[i] == 'U'||s[i]\
    \ == 'Y'||s[i] == 'W') {\n            s.push(s.top());\n        }\n        if(s[i]\
    \ == 'N'||s[i] == 'O'||s[i] == 'U'||s[i] == 'Y'||s[i] == 'W') {\n            s.push(s.top());\n\
    \        }\n        if(s[i] == 'P'||s[i] == 'R'||s[i] == 'S'||s[i] == 'T'||s[i]\
    \ == 'Y'||s[i] == 'W') {\n            s.push(s.top());\n        }\n        if(s[i]\
    \ == 'Q'||s[i] == 'S'||s[i] == 'T'||s[i] == 'Y'||s[i] == 'W') {\n            s.push(s.top());\n\
    \        }\n        if(s[i] == 'R'||s[i] == 'S'||\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppl7yea15.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmppl7yea15.cpp:20:29: error:\
    \ declaration of \u2018std::stack<std::__cxx11::basic_string<char> > s\u2019 shadows\
    \ a parameter\n   20 |     std::stack<std::string> s;\n      |               \
    \              ^\n/tmp/tmppl7yea15.cpp:21:21: error: \u2018class std::stack<std::__cxx11::basic_string<char>\
    \ >\u2019 has no member named \u2018length\u2019\n   21 |     for(int i=0;i<s.length();i++)\
    \ {\n      |                     ^~~~~~\n/tmp/tmppl7yea15.cpp:22:13: error: no\
    \ match for \u2018operator[]\u2019 (operand types are \u2018std::stack<std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018int\u2019)\n   22 |         if(s[i] == 'A'||s[i] == 'U'||s[i]\
    \ == 'L'||s[i] == 'S') {\n      |             ^\n/tmp/tmppl7yea15.cpp:22:26: error:\
    \ no match for \u2018operator[]\u2019 (operand types are \u2018std::stack<std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018int\u2019)\n   22 |         if(s[i] == 'A'||s[i] == 'U'||s[i]\
    \ == 'L'||s[i] == 'S') {\n      |                          ^\n/tmp/tmppl7yea15.cpp:22:39:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::stack<std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018int\u2019)\n   22 |         if(s[i] == 'A'||s[i] == 'U'||s[i]\
    \ == 'L'||s[i] == 'S') {\n      |                                       ^\n/tmp/tmppl7yea15.cpp:22:52:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::stack<std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018int\u2019)\n   22 |         if(s[i] == 'A'||s[i] == 'U'||s[i]\
    \ == 'L'||s[i] == 'S') {\n      |                                            \
    \        ^\n/tmp/tmppl7yea15.cpp:25:13: error: no match for \u2018operator[]\u2019\
    \ (operand types are \u2018std::stack<std::__cxx11::basic_string<char> >\u2019\
    \ and \u2018int\u2019)\n   25 |         if(s[i] == 'B'||s[i] == 'I'||s[i] == 'K'||s[i]\
    \ == 'N'||s[i] == 'M'||s[i] == 'R') {\n      |             ^\n/tmp/tmppl7yea15.cpp:25:26:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::stack<std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018int\u2019)\n   25 |         if(s[i] == 'B'||s"
  stdout: ''
  timestamp: 1660141070
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // your implementation\
    \ here\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp4w9wt94u: /tmp/tmp4w9wt94u.cpp:24: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::unordered_set<char>\
    \ vowel{'a', 'e', 'i', 'o', 'u'};\n    std::vector<std::string> words;\n    std::string\
    \ word = \"\";\n    long i = 0;\n    for (i; i < s.length() && i < n; i++) {\n\
    \        word = words + s[i];\n        if (vowel.count(word[0])) {\n         \
    \   words.push_back(word);\n        }\n    }\n    return words;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcjdythmx.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpcjdythmx.cpp:25:22: error:\
    \ no match for \u2018operator+\u2019 (operand types are \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   25 |         word = words + s[i];\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpcjdythmx.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:423:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpcjdythmx.cpp:25:27:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   25 |         word = words + s[i];\n      |      \
    \                     ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpcjdythmx.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1216:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::move_iterator<_IteratorL>\
    \ std::operator+(typename std::move_iterator<_IteratorL>::difference_type, const\
    \ std::move_iterator<_IteratorL>&)\u2019\n 1216 |     operator+(typename move_iterator<_Iterator>::difference_type\
    \ __n,\n      |"
  stdout: ''
  timestamp: 1660141070
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    assert(n >=\
    \ 0 && n <= s.size());\n    std::vector<std::string> v;\n    for (size_t i = 0;\
    \ i < s.size(); i++) {\n        bool has = false;\n        std::string t = s.substr(i,\
    \ n);\n        for (char c : t) {\n            if (c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u') {\n                has = true;\n              \
    \  break;\n            }\n        }\n        if (has) v.push_back(t);\n    }\n\
    \    return v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmplu7lj_xd: /tmp/tmplu7lj_xd.cpp:37: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ words;\n    // Your code here\n    \n    return words;\n}\nint main() {\n  \
    \  auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp00vqimlo: /tmp/tmp00vqimlo.cpp:27: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  assert(!s.empty()); // Only work for empty strings\n  v.push_back(s);\n\
    \  for(long i = 1; i < s.size() && i < n; ++i){\n    v.push_back(v[i - 1] + s[i]);\n\
    \  }\n  return v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpq6jg68kn: /tmp/tmpq6jg68kn.cpp:30: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    if (s.length() == 0) {\n        res.emplace_back(std::string());\n\
    \        return res;\n    }\n    std::vector<char> v;\n    // Insert first character\n\
    \    v.push_back(s[0]);\n    for (auto c : s) {\n        // Insert next characters\n\
    \        v.push_back(c);\n        if (v.size() == n) {\n            res.emplace_back(std::string(v.begin(),\
    \ v.end()));\n            v.resize(0);\n        }\n    }\n    if (v.size() > 0)\
    \ {\n        res.emplace_back(std::string(v.begin(), v.end()));\n    }\n    return\
    \ res;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp30cswaz7: /tmp/tmp30cswaz7.cpp:43: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::unordered_map<char,\
    \ int> m;\n    std::set<std::string> word_set;\n    for (char c : s) {\n     \
    \   m[c]++;\n    }\n    auto insert_word_to_set = [&](const std::string& word)\
    \ {\n        word_set.insert(word);\n    };\n    for (char c : s) {\n        if\
    \ (c == ' ') continue;\n        if (m[c] == n) insert_word_to_set(word + c);\n\
    \    }\n    std::vector<std::string> res;\n    for (auto word : word_set) {\n\
    \        res.push_back(word);\n    }\n    return res;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphvtcfzp_.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmphvtcfzp_.cpp:30:43: error:\
    \ \u2018word\u2019 was not declared in this scope\n   30 |         if (m[c] ==\
    \ n) insert_word_to_set(word + c);\n      |                                  \
    \         ^~~~\n"
  stdout: ''
  timestamp: 1660141071
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Do not\
    \ write main() function.\n    // Do not read input, instead use the arguments\
    \ to the function.\n    // Do not print the output, instead return values that\
    \ you compute.\n    // You can only return the result of the function.\n\n   \
    \ std::vector<std::string> ans;\n    if (s.empty()) {\n        return ans;\n \
    \   }\n    \n    std::string word;\n    \n    for (int i = 0; i < s.size(); i++)\
    \ {\n        \n        word = s.substr(i, 1);\n        \n        bool found =\
    \ false;\n        \n        for (int j = 0; j < n; j++) {\n            if (word.at(0)\
    \ == vowels[j]) {\n                found = true;\n                break;\n   \
    \         }\n        }\n        \n        if (found) {\n            ans.push_back(word);\n\
    \        }\n        \n    }\n    \n    return ans;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppkut2e8x.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmppkut2e8x.cpp:39:31: error:\
    \ \u2018vowels\u2019 was not declared in this scope\n   39 |             if (word.at(0)\
    \ == vowels[j]) {\n      |                               ^~~~~~\n"
  stdout: ''
  timestamp: 1660141071
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ res;\n  \n  std::string word = \"\";\n  std::stack<std::string> stk;\n  std::stack<std::string>\
    \ temp;\n  stk.push(word);\n  temp.push(word);\n  \n  while (!stk.empty()) {\n\
    \    word = stk.top();\n    stk.pop();\n    \n    if (word.length() == 0) {\n\
    \      continue;\n    }\n    \n    \n    for (auto const &c: word) {\n      \n\
    \      if (c == ' ' || c == '\\t' || c == '\\n') {\n        temp.push(word);\n\
    \        temp.pop();\n      } else if (c != ' ') {\n        \n        if (n <=\
    \ 0) {\n          temp.push(word);\n          temp.pop();\n          break;\n\
    \        }\n        \n        stk.push(c);\n        n--;\n      }\n    }\n   \
    \ \n    if (temp.empty()) {\n      res.emplace_back(word);\n    }\n  }\n  \n \
    \ if (res.empty()) {\n    return {};\n  }\n  \n  return res;\n}\nint main() {\n\
    \    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5jonpjdb.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp5jonpjdb.cpp:50:19: error:\
    \ no matching function for call to \u2018std::stack<std::__cxx11::basic_string<char>\
    \ >::push(const char&)\u2019\n   50 |         stk.push(c);\n      |          \
    \         ^\nIn file included from /usr/include/c++/9/stack:61,\n            \
    \     from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n           \
    \      from /tmp/tmp5jonpjdb.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:233:7:\
    \ note: candidate: \u2018void std::stack<_Tp, _Sequence>::push(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Sequence = std::deque<std::__cxx11::basic_string<char>,\
    \ std::allocator<std::__cxx11::basic_string<char> > >; std::stack<_Tp, _Sequence>::value_type\
    \ = std::__cxx11::basic_string<char>]\u2019\n  233 |       push(const value_type&\
    \ __x)\n      |       ^~~~\n/usr/include/c++/9/bits/stl_stack.h:233:30: note:\
    \   no known conversion for argument 1 from \u2018const char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \  233 |       push(const value_type& __x)\n      |            ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_stack.h:238:7: note: candidate: \u2018void std::stack<_Tp,\
    \ _Sequence>::push(std::stack<_Tp, _Sequence>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Sequence = std::deque<std::__cxx11::basic_string<char>, std::allocator<std::__cxx11::basic_string<char>\
    \ > >; std::stack<_Tp, _Sequence>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n  238 |       push(value_type&& __x)\n      |       ^~~~\n/usr/include/c++/9/bits/stl_stack.h:238:25:\
    \ note:   no known conversion for argument 1 from \u2018const char\u2019 to \u2018\
    std::stack<std::__cxx11::basic_string<char> >::value_type&&\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>&&\u2019}\n  238 |       push(value_type&& __x)\n\
    \      |            ~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660141070
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ v;\n  if (s.empty()) return v;\n  std::vector<std::string> subs;\n  for (auto\
    \ &i : s) {\n    v.clear();\n    for (auto &j : subs) {\n      if (i + j == s)\
    \ {\n        v.push_back(j);\n      }\n    }\n    if (v.size() == n) subs.push_back(i);\n\
    \  }\n  return v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6ax4z513.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp6ax4z513.cpp:30:40: error:\
    \ no matching function for call to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::push_back(char&)\u2019\n   30 |     if (v.size() == n) subs.push_back(i);\n\
    \      |                                        ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6ax4z513.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |         "
  stdout: ''
  timestamp: 1660141071
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // your code\
    \ goes here\n    std::vector<std::string> v;\n    vector<string>::iterator it;\n\
    \    string str;\n    int n;\n    // str is string that contain n consonants\n\
    \    for(int i = 0; i<s.size(); i++)\n    {\n        if((s.at(i) == n) && (n!=0))\
    \ \n        {\n            n--;\n            continue;\n        }\n        if(n==0)\n\
    \        {\n            v.push_back(str);\n            n = s[i];\n           \
    \ str = s.substr(i,1);\n        }\n        else\n            str += s.at(i);\n\
    \    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n \
    \   assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmprsreffce.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmprsreffce.cpp:22:5: error:\
    \ \u2018vector\u2019 was not declared in this scope\n   22 |     vector<string>::iterator\
    \ it;\n      |     ^~~~~~\n/tmp/tmprsreffce.cpp:22:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprsreffce.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprsreffce.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmprsreffce.cpp:22:12:\
    \ error: \u2018string\u2019 was not declared in this scope\n   22 |     vector<string>::iterator\
    \ it;\n      |            ^~~~~~\n/tmp/tmprsreffce.cpp:22:12: note: suggested\
    \ alternatives:\nIn file included from /usr/include/c++/9/iosfwd:39,\n       \
    \          from /usr/include/c++/9/ios:38,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmprsreffce.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33: note:  \
    \ \u2018std::string\u2019\n   79 |   typedef basic_string<ch"
  stdout: ''
  timestamp: 1660141071
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.empty())\
    \ {\n        return {};\n    }\n    std::vector<std::string> v;\n    long ncons\
    \ = 0, slen = s.length();\n    long cnt = 0;\n    for (long i = 0; i < slen; ++i)\n\
    \    {\n        cnt += s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o'\
    \ || s[i] == 'u' ? 1 : 0;\n        if (cnt > n) {\n            v.push_back(s.substr(i,\
    \ i - ncons));\n            cnt = ncons;\n        }\n        ncons += (s[i] ==\
    \ 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' ? 1 : 0);\n\
    \    }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n \
    \   assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp9g1jp_v_: /tmp/tmp9g1jp_v_.cpp:39: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  if (s.empty())\n\
    \    return std::vector<std::string>();\n  std::vector<std::string> words;\n \
    \ std::string vowels = \"aeiouy\";\n  for (size_t i = 0, j = s.size(); i < j;\
    \ i++) {\n    if (std::count(s.begin(), s.end(), vowels[i]) >= n) {\n      words.push_back((std::string(s.begin()\
    \ + i, s.end())));\n    }\n  }\n  return words;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpwify04rp: /tmp/tmpwify04rp.cpp:33: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    assert(n >=\
    \ 0);\n    std::vector<std::string> ret;\n    for (auto &i : s)\n        if (i.size()\
    \ == n) {\n            ret.push_back(i);\n        }\n    return ret;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppazgp6rt.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmppazgp6rt.cpp:23:15: error:\
    \ request for member \u2018size\u2019 in \u2018i\u2019, which is of non-class\
    \ type \u2018char\u2019\n   23 |         if (i.size() == n) {\n      |       \
    \        ^~~~\n/tmp/tmppazgp6rt.cpp:24:28: error: no matching function for call\
    \ to \u2018std::vector<std::__cxx11::basic_string<char> >::push_back(char&)\u2019\
    \n   24 |             ret.push_back(i);\n      |                            ^\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppazgp6rt.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<st"
  stdout: ''
  timestamp: 1660141071
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // TODO: Implement\
    \ me\n    return {};\n}\nint main() {\n    auto candidate = select_words;\n  \
    \  assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp2occszhm: /tmp/tmp2occszhm.cpp:25: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Your code\
    \ here\n    std::vector<std::string> retv;\n    for(auto it = s.begin(); it!=s.end();\
    \ ++it){\n        if(*it == ' '){\n            while(n != 0 && !isspace(*it)){\n\
    \                ++it;\n                --n;\n            }\n        }\n     \
    \   if(*it == '\\0' || n == 0){\n            break;\n        }\n        if(isspace(*it)\
    \ && n > 0){\n            --n;\n            continue;\n        }\n        if(*it\
    \ == '\\0' || n == 0){\n            break;\n        }\n        for(auto p = it+1;\
    \ p != s.end(); ++p){\n            if((*it == *p) && n != 0){\n              \
    \  --n;\n                break;\n            }\n        }\n        if(n != 0){\n\
    \            break;\n        }\n        retv.push_back(std::string(it+1, s.end()));\n\
    \    }\n    return retv;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpwqrvdsua: /tmp/tmpwqrvdsua.cpp:54: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    int count\
    \ = 0;\n    std::vector<std::string> word_vec;\n    for (char c : s) {\n     \
    \   std::string str = \"\";\n        if (c == 'a' || c == 'e' || c == 'i' || c\
    \ == 'o' || c == 'u' || c == 'y') {\n            str = (str + c);\n          \
    \  count++;\n        } else if (c >= 'a' && c <= 'z') {\n            str = (str\
    \ + c);\n        } else if (c >= 'A' && c <= 'Z') {\n            str = (str +\
    \ c);\n        } else if (c == ' ') {\n            str = str;\n        } else\
    \ if (c >= '0' && c <= '9') {\n            str = (str + c);\n        } else {\n\
    \            assert(false && \"Not a letter\");\n        }\n        if (count==n)\
    \ {\n            word_vec.push_back(str);\n        }\n    }\n    return word_vec;\n\
    }\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp_1y91yur: /tmp/tmp_1y91yur.cpp:46: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    for(long i = 0; i < s.length(); i++) {\n        if(s.at(i) == ' ') {\n\
    \            v.push_back((std::string)s.substr(0, i));\n            s = s.substr(i\
    \ + 1);\n        }\n    }\n    if(s.length() >= n) {\n        for(long i = 0;\
    \ i < s.length(); i++) {\n            if(s.at(i) == ' ') {\n                v.push_back((std::string)s.substr(0,\
    \ i));\n                s = s.substr(i + 1);\n                break;\n       \
    \     }\n        }\n    }\n    for(long i = 0; i < s.length(); i++) {\n      \
    \  if(!isalpha(s.at(i)) && s.at(i) != ' ') {\n            v.push_back((std::string)s.substr(0,\
    \ i));\n            s = s.substr(i + 1);\n            break;\n        }\n    }\n\
    \    return v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp74we4tmg: /tmp/tmp74we4tmg.cpp:47: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ ans;\n  ans.reserve(s.size());\n  std::unordered_set<char> s;\n  for (char c\
    \ : s) {\n    s.insert(c);\n  }\n  long k = 0;\n  while (n > 0) {\n    long cur\
    \ = k;\n    for (char c : s) {\n      if (s.count(c) == n) {\n        ans.push_back((std::string)s.begin()\
    \ + cur);\n        s.erase(c);\n        break;\n      }\n      cur += n;\n   \
    \ }\n    k++;\n  }\n  return ans;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpk_zs0_2a.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpk_zs0_2a.cpp:22:28: error:\
    \ declaration of \u2018std::unordered_set<char> s\u2019 shadows a parameter\n\
    \   22 |   std::unordered_set<char> s;\n      |                            ^\n\
    /tmp/tmpk_zs0_2a.cpp:31:44: error: no matching function for call to \u2018std::__cxx11::basic_string<char>::basic_string(std::unordered_set<char>::iterator)\u2019\
    \n   31 |         ans.push_back((std::string)s.begin() + cur);\n      |      \
    \                                      ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpk_zs0_2a.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note: candidate: \u2018template<class _Tp, class> std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::basic_string(const _Tp&, const _Alloc&)\u2019\n  654 |  basic_string(const\
    \ _Tp& __t, const _Alloc& __a = _Alloc())\n      |  ^~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:654:2:\
    \ note:   template argument deduction/substitution failed:\nIn file included from\
    \ /usr/include/c++/9/bits/move.h:55,\n                 from /usr/include/c++/9/bits/stl_pair.h:59,\n\
    \                 from /usr/include/c++/9/bits/stl_algobase.h:64,\n          \
    \       from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpk_zs0_2a.cpp:2:\n/usr/include/c++/9/type_traits:\
    \ In substitution of \u2018template<bool _Cond, class _Tp> using enable_if_t =\
    \ typen"
  stdout: ''
  timestamp: 1660141071
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ res;\n    // ++n; \n    res.push_back((std::string)\"\");\n    std::stack<std::pair<std::string,long>>\
    \ s;\n    if(s.size() < 1) {\n        return res;\n    }\n    auto itr = s.top();\
    \ \n    itr.first = (std::string)\"\";\n    auto itr2 = s.top();\n    itr2.first\
    \ = (std::string)\"\";\n    for(unsigned int i=0;i<s.length();i++) {\n       \
    \ if(i == s.length()-1) {\n            s.top().first = s.top().first+\" \"+s.top().second;\n\
    \        }\n        else if(s.top().first != s.top().second) {\n            s.top().first\
    \ = s.top().first+\" \"+s.top().second;\n        }\n        else if(s.top().first==\"\
    \ \") {\n            s.top().first = (std::string)\"\";\n        }\n        else\
    \ {\n            auto itr3 = s.top();\n            itr3.first = (std::string)\"\
    \";\n            if(itr3.second < n) { \n                s.top().first = s.top().first+\"\
    \ \"+s.top().second;\n            }\n            itr2.first = s.top().first;\n\
    \            itr2.second = itr2.first + itr2.second;\n            s.top().first\
    \ = itr2.first;\n            itr2.first = itr2.first;\n            itr2.second\
    \ = itr2.second + itr2.second;\n            itr.first = itr2.first;\n        \
    \    itr.second = itr2.second;\n        }\n    }\n    if(s.empty()) {\n      \
    \  res.push_back(s.top().first);\n    }\n    return res;\n}\nint main() {\n  \
    \  auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpplsz23no.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpplsz23no.cpp:23:45: error:\
    \ declaration of \u2018std::stack<std::pair<std::__cxx11::basic_string<char>,\
    \ long int> > s\u2019 shadows a parameter\n   23 |     std::stack<std::pair<std::string,long>>\
    \ s;\n      |                                             ^\n/tmp/tmpplsz23no.cpp:31:30:\
    \ error: \u2018class std::stack<std::pair<std::__cxx11::basic_string<char>, long\
    \ int> >\u2019 has no member named \u2018length\u2019\n   31 |     for(unsigned\
    \ int i=0;i<s.length();i++) {\n      |                              ^~~~~~\n/tmp/tmpplsz23no.cpp:32:19:\
    \ error: \u2018class std::stack<std::pair<std::__cxx11::basic_string<char>, long\
    \ int> >\u2019 has no member named \u2018length\u2019\n   32 |         if(i ==\
    \ s.length()-1) {\n      |                   ^~~~~~\n/tmp/tmpplsz23no.cpp:33:46:\
    \ error: no match for \u2018operator+\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018long int\u2019)\n   33 |             s.top().first = s.top().first+\"\
    \ \"+s.top().second;\n      |                             ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n\
    \      |                                          |            |\n      |    \
    \                                      |            long int\n      |        \
    \                                  std::__cxx11::basic_string<char>\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpplsz23no.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr std::reverse_iterator<_Iterator>\
    \ std::operator+(typename std::reverse_iterator<_Iterator>::difference_type, const\
    \ std::reverse_iterator<_Iterator>&)\u2019\n  423 |     operator+(typename reverse_iterator<_Iterator>::difference_type\
    \ __n,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:423:5: note: "
  stdout: ''
  timestamp: 1660141071
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    v.push_back(s);\n    while(n>0){\n        v.push_back(v.back());\n \
    \   }\n    return v;\n}\nint main() {\n    auto candidate = select_words;\n  \
    \  assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660141076
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // Complete\
    \ this function\n    std::vector<std::string> v;\n    v.push_back(s);\n    return\
    \ v;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpda6kodc5: /tmp/tmpda6kodc5.cpp:27: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141071
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n\tstd::vector<std::string>\
    \ v;\n\t// code here\n\treturn v;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp1k12glxk: /tmp/tmp1k12glxk.cpp:26: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141072
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::sort(s.begin(),\
    \ s.end());\n  std::vector<std::string> ans;\n  std::string w = \"\";\n  long\
    \ cn = 0;\n  for (auto i : s) {\n    if (i == 'a') {\n      w = \"a\";\n    }\
    \ else if (i == 'u') {\n      w = \"u\";\n    } else if (i == 'l') {\n      w\
    \ = \"l\";\n    } else if (i == 'l') {\n      w = \"ll\";\n    } else if (i ==\
    \ 'h') {\n      w = \"h\";\n    } else if (i == 'e') {\n      w = \"e\";\n   \
    \ } else if (i == 'd') {\n      w = \"d\";\n    } else if (i == 's') {\n     \
    \ w = \"s\";\n    } else if (i == 'p') {\n      w = \"p\";\n    } else if (i ==\
    \ 's') {\n      w = \"ss\";\n    } else if (i == 'y') {\n      w = \"y\";\n  \
    \  } else if (i == 'r') {\n      w = \"r\";\n    } else if (i == 'e') {\n    \
    \  w = \"ee\";\n    } else if (i == 'm') {\n      w = \"m\";\n    } else if (i\
    \ == 'a') {\n      w = \"a\";\n    } else if (i == 'a') {\n      w = \"aa\";\n\
    \    }\n    cn += 1;\n    std::string rep = w;\n    while (cn > n) {\n      rep\
    \ += \"x\";\n      cn -= 1;\n    }\n    ans.push_back(rep);\n  }\n  if (w == \"\
    \") {\n    ans.push_back(\"\");\n  }\n  return ans;\n}\nint main() {\n    auto\
    \ candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpkad_9cdq: /tmp/tmpkad_9cdq.cpp:73: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141072
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    if (s.empty())\
    \ {\n        return {};\n    }\n    std::vector<std::string> v;\n    for (int\
    \ i = 0; i < s.length(); i++) {\n        if (s.at(i) == '_') {\n            v.emplace_back(\"\
    \");\n        } else if (s.at(i) == ' ') {\n            v.emplace_back(\"\");\n\
    \        } else if (s.at(i) == 'n') {\n            v.emplace_back(s.substr(0,\
    \ i) + s.substr(i+1));\n        } else {\n            for (long j = 1; j <= n;\
    \ j++) {\n                v.emplace_back(s.substr(0, i) + s.substr(i + j));\n\
    \            }\n        }\n    }\n    return v;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 23) > this->size() (which is 22)\n"
  stdout: ''
  timestamp: 1660141072
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // code here\n\
    \    std::vector<std::string> results;\n    std::sort(s.begin(), s.end());\n \
    \   std::vector<std::string> vec;\n    vec.reserve(s.size());\n    for (auto el\
    \ : s)\n    {\n        if (el.find('a') == 0 || el.find('e') == 0 || el.find('i')\
    \ == 0 || el.find('o') == 0 || el.find('u') == 0 || el.find('A') == 0 || el.find('E')\
    \ == 0 || el.find('I') == 0 || el.find('O') == 0 || el.find('U') == 0)\n     \
    \   {\n            vec.push_back(el);\n        }\n    }\n    int i = 0;\n    while\
    \ (i < vec.size())\n    {\n        std::string word = vec[i];\n        for (auto\
    \ el : word)\n        {\n            if (el == 'a' || el == 'e' || el == 'i' ||\
    \ el == 'o' || el == 'u' || el == 'A' || el == 'E' || el == 'I' || el == 'O' ||\
    \ el == 'U')\n            {\n                if (n-- == 0)\n                {\n\
    \                    results.push_back(word);\n                }\n           \
    \ }\n        }\n        i++;\n    }\n    return results;\n}\nint main() {\n  \
    \  auto candidate = select_words;\n    assert(candidate((\"Mary had a little lamb\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp769714xz.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmp769714xz.cpp:27:16: error:\
    \ request for member \u2018find\u2019 in \u2018el\u2019, which is of non-class\
    \ type \u2018char\u2019\n   27 |         if (el.find('a') == 0 || el.find('e')\
    \ == 0 || el.find('i') == 0 || el.find('o') == 0 || el.find('u') == 0 || el.find('A')\
    \ == 0 || el.find('E') == 0 || el.find('I') == 0 || el.find('O') == 0 || el.find('U')\
    \ == 0)\n      |                ^~~~\n/tmp/tmp769714xz.cpp:27:37: error: request\
    \ for member \u2018find\u2019 in \u2018el\u2019, which is of non-class type \u2018\
    char\u2019\n   27 |         if (el.find('a') == 0 || el.find('e') == 0 || el.find('i')\
    \ == 0 || el.find('o') == 0 || el.find('u') == 0 || el.find('A') == 0 || el.find('E')\
    \ == 0 || el.find('I') == 0 || el.find('O') == 0 || el.find('U') == 0)\n     \
    \ |                                     ^~~~\n/tmp/tmp769714xz.cpp:27:58: error:\
    \ request for member \u2018find\u2019 in \u2018el\u2019, which is of non-class\
    \ type \u2018char\u2019\n   27 |         if (el.find('a') == 0 || el.find('e')\
    \ == 0 || el.find('i') == 0 || el.find('o') == 0 || el.find('u') == 0 || el.find('A')\
    \ == 0 || el.find('E') == 0 || el.find('I') == 0 || el.find('O') == 0 || el.find('U')\
    \ == 0)\n      |                                                          ^~~~\n\
    /tmp/tmp769714xz.cpp:27:79: error: request for member \u2018find\u2019 in \u2018\
    el\u2019, which is of non-class type \u2018char\u2019\n   27 |         if (el.find('a')\
    \ == 0 || el.find('e') == 0 || el.find('i') == 0 || el.find('o') == 0 || el.find('u')\
    \ == 0 || el.find('A') == 0 || el.find('E') == 0 || el.find('I') == 0 || el.find('O')\
    \ == 0 || el.find('U') == 0)\n      |                                        \
    \                                       ^~~~\n/tmp/tmp769714xz.cpp:27:100: error:\
    \ request for member \u2018find\u2019 in \u2018el\u2019, which is of non-class\
    \ type \u2018char\u2019\n   27 |         if (el.find('a') == 0 || el.find('e')\
    \ == 0 || el.find('i') == 0 || el.find('o') == 0 || el.find('u') == 0 || el.find('A')\
    \ == 0 || el.find('E') == 0 || el.find('I') == 0 || el.fi"
  stdout: ''
  timestamp: 1660141071
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n  std::vector<std::string>\
    \ res;\n  if (s.empty()) return res;\n  std::vector<int> vowels = {\"a\", \"e\"\
    , \"i\", \"o\", \"u\"};\n  std::vector<int> consonants = {1, 2, 3, 4};\n  int\
    \ i = 0;\n  for (; i < s.size(); i++) {\n    if (vowels.find(s[i]) != -1) {\n\
    \      int j = 1;\n      for (; j < n && consonants.find(s[j]) == -1; j++) {\n\
    \        ;\n      }\n      res.push_back(s.substr(i, (j - i)));\n      i = j;\n\
    \    }\n  }\n  return res;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpujz0ll7b.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpujz0ll7b.cpp:22:53: error:\
    \ could not convert \u2018{\"a\", \"e\", \"i\", \"o\", \"u\"}\u2019 from \u2018\
    <brace-enclosed initializer list>\u2019 to \u2018std::vector<int>\u2019\n   22\
    \ |   std::vector<int> vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n      |\
    \                                                     ^\n      |             \
    \                                        |\n      |                          \
    \                           <brace-enclosed initializer list>\n/tmp/tmpujz0ll7b.cpp:26:16:\
    \ error: \u2018class std::vector<int>\u2019 has no member named \u2018find\u2019\
    \n   26 |     if (vowels.find(s[i]) != -1) {\n      |                ^~~~\n/tmp/tmpujz0ll7b.cpp:28:34:\
    \ error: \u2018class std::vector<int>\u2019 has no member named \u2018find\u2019\
    \n   28 |       for (; j < n && consonants.find(s[j]) == -1; j++) {\n      | \
    \                                 ^~~~\n"
  stdout: ''
  timestamp: 1660141071
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ ans;\n    // Write your code here\n    if(s.empty())\n    {\n        return\
    \ ans;\n    }\n    std::string word = \"\";\n    for(char c:s)\n    {\n      \
    \  if((c == 'a')||(c == 'e')||(c == 'i')||(c == 'o')||(c == 'u')||(c == 'y'))\n\
    \        {\n            ans.push_back(word);\n            word = \"\";\n     \
    \   }\n        word += c;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = select_words;\n    assert(candidate((\"Mary had a little lamb\"), (4)) ==\
    \ (std::vector<std::string>({(std::string)\"little\"})));\n    assert(candidate((\"\
    Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmpura68yk5: /tmp/tmpura68yk5.cpp:40: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141072
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ result;\n    if (s.empty()) {\n        return result;\n    }\n    string word\
    \ = \"\";\n    int cnt = 0;\n    for (char c : s) {\n        if (c == 'y' || c\
    \ == 'e' || c == 'a' || c == 'i' || c == 'o' || c == 'u') {\n            cnt +=\
    \ 1;\n        }\n        word += c;\n    }\n    if (cnt == n) {\n        result.emplace_back(word);\n\
    \    }\n    for (int i = 0; i < (int) s.size(); i++) {\n        word = s.substr(i,\
    \ 1);\n        cnt += 1;\n        if (word == 'y' || word == 'e' || word == 'a'\
    \ || word == 'i' || word == 'o' || word == 'u') {\n            cnt += 1;\n   \
    \     }\n        if (cnt != n) {\n            result.emplace_back(word);\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = select_words;\n\
    \    assert(candidate((\"Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa7jzgbjj.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpa7jzgbjj.cpp:24:5: error:\
    \ \u2018string\u2019 was not declared in this scope\n   24 |     string word =\
    \ \"\";\n      |     ^~~~~~\n/tmp/tmpa7jzgbjj.cpp:24:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpa7jzgbjj.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpa7jzgbjj.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmpa7jzgbjj.cpp:30:9: error: \u2018word\u2019 was not declared in this scope\n\
    \   30 |         word += c;\n      |         ^~~~\n/tmp/tmpa7jzgbjj.cpp:33:29:\
    \ error: \u2018word\u2019 was not declared in this scope\n   33 |         result.emplace_back(word);\n\
    \      |                             ^~~~\n/tmp/tmpa7jzgbjj.cpp:36:9: error: \u2018\
    word\u2019 was not declared in this scope\n   36 |         word = s.substr(i,\
    \ 1);\n      |         ^~~~\n"
  stdout: ''
  timestamp: 1660141072
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    std::vector<std::string>\
    \ v;\n    assert(n >= 1 && n <= s.length());\n    \n    // 1. split on space\n\
    \    std::string ss[2];\n    \n    ss[0] = s;\n    ss[1] = \"\";\n    \n    size_t\
    \ start = 0;\n    \n    while (start < s.length()) {\n        ss[1] += s[start];\n\
    \        \n        if (s[start] == \" \")\n            ++start;\n        else\n\
    \            break;\n    }\n    \n    ss[1] = ss[1].substr(0, ss[1].length() -\
    \ 1);\n    \n    // 2. Count number of consonants\n    long num_cons = 0, count\
    \ = 1;\n    \n    for (auto c : ss[1]) {\n        if (c != \" \" && c != '\\0'\
    \ && c != '-' && c != '!') {\n            ++num_cons;\n            count += 1;\n\
    \        }\n    }\n    \n    if (n == count) {\n        v.push_back(ss[0]);\n\
    \    }\n    \n    // 3. Find all words that have the right number of consonants\n\
    \    // This can be done in 3 ways:\n    //   1. Loop through the whole string\n\
    \    //   2. Loop through the string until you find a space\n    //   3. Loop\
    \ through the string once and keep track of consonants seen\n    \n    // 1. Loop\
    \ through the whole string\n    while (start < s.length()) {\n        if (s[start]\
    \ == \" \") {\n            break;\n        }\n        \n        // 2. Loop through\
    \ the string until you find a space\n        while (s[start] == \" \") {\n   \
    \         ++start;\n        }\n        \n        // 3. Loop through the string\
    \ once and keep track of consonants seen\n        long num_cons_seen = 0;\n  \
    \      \n        for (auto c : ss[1]) {\n            if (c != \" \" && c != '\\\
    0' && c != '-' && c != '!') {\n                ++num_cons_seen;\n            \
    \    if (num_cons_seen == n) {\n                    v.push_back(ss[0]);\n    \
    \            }\n            }\n        }\n    }\n    \n    return v;\n}\nint main()\
    \ {\n    auto candidate = select_words;\n    assert(candidate((\"Mary had a little\
    \ lamb\"), (4)) == (std::vector<std::string>({(std::string)\"little\"})));\n \
    \   assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb0te0l1b.cpp: In function \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > select_words(std::string, long int)\u2019:\n/tmp/tmpb0te0l1b.cpp:34:25: error:\
    \ ISO C++ forbids comparison between pointer and integer [-fpermissive]\n   34\
    \ |         if (s[start] == \" \")\n      |                         ^~~\n/tmp/tmpb0te0l1b.cpp:46:18:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   46 |         if (c != \" \" && c != '\\0' && c != '-' && c != '!') {\n   \
    \   |                  ^~~\n/tmp/tmpb0te0l1b.cpp:64:25: error: ISO C++ forbids\
    \ comparison between pointer and integer [-fpermissive]\n   64 |         if (s[start]\
    \ == \" \") {\n      |                         ^~~\n/tmp/tmpb0te0l1b.cpp:69:28:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   69 |         while (s[start] == \" \") {\n      |                        \
    \    ^~~\n/tmp/tmpb0te0l1b.cpp:77:22: error: ISO C++ forbids comparison between\
    \ pointer and integer [-fpermissive]\n   77 |             if (c != \" \" && c\
    \ != '\\0' && c != '-' && c != '!') {\n      |                      ^~~\n"
  stdout: ''
  timestamp: 1660141071
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a string s and a\
    \ natural number n, you have been tasked to implement \n// a function that returns\
    \ a vector of all words from string s that contain exactly \n// n consonants,\
    \ in order these words appear in the string s.\n// If the string s is empty then\
    \ the function should return an empty vector.\n// Note: you may assume the input\
    \ string contains only letters and spaces.\n// Examples:\n// >>> select_words((\"\
    Mary had a little lamb\"), (4))\n// (std::vector<std::string>({(std::string)\"\
    little\"}))\n// >>> select_words((\"Mary had a little lamb\"), (3))\n// (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"}))\n// >>> select_words((\"simple white space\"\
    ), (2))\n// (std::vector<std::string>())\n// >>> select_words((\"Hello world\"\
    ), (4))\n// (std::vector<std::string>({(std::string)\"world\"}))\n// >>> select_words((\"\
    Uncle sam\"), (3))\n// (std::vector<std::string>({(std::string)\"Uncle\"}))\n\
    std::vector<std::string> select_words(std::string s, long n) {\n    // your code\
    \ goes here\n    std::vector<std::string> words;\n    if (s.empty()) {\n     \
    \   return words;\n    }\n    for (size_t i = 0; i < s.size(); i++) {\n      \
    \  if (s[i] != 'a' && s[i] != 'e' && s[i] != 'i' && s[i] != 'o' && s[i] != 'u')\
    \ {\n            words.push_back(s.substr(i, n));\n        }\n    }\n    \n  \
    \  return words;\n}\nint main() {\n    auto candidate = select_words;\n    assert(candidate((\"\
    Mary had a little lamb\"), (4)) == (std::vector<std::string>({(std::string)\"\
    little\"})));\n    assert(candidate((\"Mary had a little lamb\"), (3)) == (std::vector<std::string>({(std::string)\"\
    Mary\", (std::string)\"lamb\"})));\n    assert(candidate((\"simple white space\"\
    ), (2)) == (std::vector<std::string>()));\n    assert(candidate((\"Hello world\"\
    ), (4)) == (std::vector<std::string>({(std::string)\"world\"})));\n    assert(candidate((\"\
    Uncle sam\"), (3)) == (std::vector<std::string>({(std::string)\"Uncle\"})));\n\
    \    assert(candidate((\"\"), (4)) == (std::vector<std::string>()));\n    assert(candidate((\"\
    a b c d e f\"), (1)) == (std::vector<std::string>({(std::string)\"b\", (std::string)\"\
    c\", (std::string)\"d\", (std::string)\"f\"})));\n}\n"
  status: Exception
  stderr: 'tmp_78arkl7: /tmp/tmp_78arkl7.cpp:35: int main(): Assertion `candidate(("Mary
    had a little lamb"), (4)) == (std::vector<std::string>({(std::string)"little"}))''
    failed.

    '
  stdout: ''
  timestamp: 1660141072
