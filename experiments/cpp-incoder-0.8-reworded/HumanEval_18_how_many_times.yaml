name: HumanEval_18_how_many_times
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Find how many times a given\
  \ substring can be found in the original string. Count overlaping cases.\n// >>>\
  \ how_many_times((\"\"), (\"a\"))\n// (0)\n// >>> how_many_times((\"aaa\"), (\"\
  a\"))\n// (3)\n// >>> how_many_times((\"aaaa\"), (\"aa\"))\n// (3)\nlong how_many_times(std::string\
  \ string, std::string substring) {\n"
tests: "}\nint main() {\n    auto candidate = how_many_times;\n    assert(candidate((\"\
  \"), (\"x\")) == (0));\n    assert(candidate((\"xyxyxyx\"), (\"x\")) == (4));\n\
  \    assert(candidate((\"cacacacac\"), (\"cac\")) == (4));\n    assert(candidate((\"\
  john doe\"), (\"john\")) == (1));\n}\n"
completions: ["    if (string.length() == 0) {\n        return 0;\n    }\n    if (substring.length()\
    \ == 0) {\n        return string.length();\n    }\n    auto i = string.length();\n\
    \    for (auto j = (string.length() - substring.length()); j >= 0; j--) {\n  \
    \      if (string[i] == substring[j]) {\n            i++;\n        } else if (string[i]\
    \ == substring[j]) {\n            if (j == 0) {\n                i++;\n      \
    \      } else {\n                i--;\n            }\n        }\n    }\n    return\
    \ i;", "    long count = 0;\n    int i = 0;\n    while (i < string.size() && i\
    \ < substring.size()) {\n        if (string[i] == substring[i]) {\n          \
    \  count++;\n            i++;\n        } else {\n            if (string[i] ==\
    \ substring[0]) {\n                count++;\n                i++;\n          \
    \  } else if (string[i] == substring[1]) {\n                count++;\n       \
    \         i++;\n                i++;\n            } else if (string[i] == substring[2])\
    \ {\n                count++;\n                i++;\n                i++;\n  \
    \              i++;\n            } else if (string[i] == substring[3]) {\n   \
    \             count++;\n                i++;\n                i++;\n         \
    \       i++;\n                i++;\n            } else if (string[i] == substring[4])\
    \ {\n                count++;\n                i++;\n                i++;\n  \
    \              i++;\n                i++;\n                i++;\n            }\
    \ else {\n                return -1;\n            }\n        }\n    }\n    return\
    \ count;", '    return count(string.begin(), string.end(), substring.begin(),
    substring.end());', "  int times = 0;\n  int n = string.length();\n  int m = substring.length();\n\
    \  if (m > n)\n    m = n;\n  for (int i = 0; i < m; i++) {\n    if (string[i]\
    \ == substring[i]) {\n      times += 1;\n      continue;\n    }\n    int len =\
    \ substring.length();\n    int found = 0;\n    for (int j = 0; j < len; j++) {\n\
    \      int s_index = i + j;\n      if (s_index > n || string[s_index] != substring[j])\n\
    \        break;\n      for (int k = i; k < string.length(); k++) {\n        if\
    \ (s_index < n) {\n          if (string[k] == substring[j])\n            found++;\n\
    \        }\n      }\n      if (found == len)\n        times++;\n    }\n  }\n \
    \ return times;", "    long count = 0;\n    size_t slen = string.size();\n   \
    \ size_t ssc = substring.size();\n    for (size_t i = 0; i < ssc; i++)\n     \
    \   for (size_t j = 0; j < slen; j++)\n            if (string[j] == substring[i])\n\
    \                count++;\n    return count;", "    // If string == substring,\
    \ it returns 1 since string.length() = substring.length()\n    if (string.length()\
    \ == substring.length()) {\n        return 1;\n    }\n\n    // If string.length()\
    \ < substring.length(), it returns 0\n    if (string.length() < substring.length())\
    \ {\n        return 0;\n    }\n\n    long count = 0;\n    for (long i = 0; i <\
    \ string.length(); i++) {\n        for (long j = 0; j < substring.length(); j++)\
    \ {\n            if (string.at(i) == substring.at(j)) {\n                count++;\n\
    \            }\n        }\n    }\n    return count;", "    int len = string.length();\n\
    \    int pos = 0;\n    int count = 0;\n    while (pos < len) {\n        int nextpos\
    \ = string.find(substring, pos);\n        if (nextpos == string::npos) {\n   \
    \         return count;\n        }\n        count += 1;\n        pos = nextpos\
    \ + 1;\n    }\n    return count;", "    int n = string.length();\n    int m =\
    \ substring.length();\n    long answer = 0;\n    if (n > m) {\n        string\
    \ += substring;\n        n = m;\n        m = n;\n    }\n    bool endOfString =\
    \ false;\n    for (int i = 0; i < n; i++) {\n        if (string[i] == substring[0])\
    \ {\n            bool foundAll = true;\n            for (int j = 0; j < m; j++)\
    \ {\n                if (string[i + j] != substring[j]) {\n                  \
    \  foundAll = false;\n                    break;\n                }\n        \
    \    }\n            if (foundAll) {\n                answer = answer + 1;\n  \
    \          }\n        }\n    }\n    if (endOfString) {\n        answer = answer\
    \ + 1;\n    }\n    return answer;", "    auto n = string.find(substring);\n  \
    \  if (n == std::string::npos) {\n        return 0;\n    }\n    long result =\
    \ 0;\n    while (n != string::npos) {\n        result += 1;\n        n = string.find(substring,\
    \ n + 1);\n    }\n    return result;", "    size_t pos = 0;\n    long count =\
    \ 0;\n    while (pos != std::string::npos && pos < string.length()) {\n      \
    \  pos = string.find(substring, pos);\n        if (pos == std::string::npos) {\n\
    \            break;\n        }\n        ++count;\n    }\n    return count;", "\t\
    long count = 0;\n\tstd::string string2 = string+substring;\n\twhile(!string2.empty())\
    \ {\n\t\tif(string.find(string2) != string2.npos) ++count;\n\t\tstring = string2;\n\
    \t\tstring2 += substring;\n\t}\n\treturn count;", "    size_t found = string.find(substring);\n\
    \    long cnt = 0;\n    while (found != std::string::npos) {\n        cnt++;\n\
    \        found = string.find(substring, found + 1);\n    }\n    return cnt;",
  "  // Make use of 'std::count'.\n  std::size_t count = std::count(string.begin(),\
    \ string.end(), substring);\n  // Make use of 'std::count_if'.\n  std::size_t\
    \ count_if = std::count_if(string.begin(), string.end(), [&](char character) {\n\
    \    return character == substring[0];\n  });\n  return count + count_if;", " \
    \   long count = 0;\n    for (auto iter = string.begin(); iter != string.end();\
    \ ++iter) {\n        bool found = false;\n        for (auto iter2 = substring.begin();\
    \ iter2 != substring.end(); ++iter2) {\n            if (*iter == *iter2) {\n \
    \               found = true;\n                break;\n            }\n       \
    \ }\n        if (!found) {\n            count++;\n        }\n    }\n    return\
    \ count;", "  int i, j = 0;\n  int n = string.length();\n  int m = substring.length();\n\
    \  long ans = 0;\n  for (i = 0; i < n; i++) {\n    if (string.substr(i, m) ==\
    \ substring)\n      j++;\n  }\n  if (j > 0) {\n    for (i = 0; i < n; i++)\n \
    \     if (string.substr(i, m) == substring)\n        ans += 1;\n  }\n  return\
    \ ans;", "    int count = 0;\n    std::string copy = string;\n    while (std::find(copy.begin(),\
    \ copy.end(), substring) != copy.end())\n    {\n        copy += substring;\n \
    \       count++;\n    }\n    return count;", "  long count = 0;\n  if (string.length()\
    \ == 0) return 0;\n  if (string.length() + substring.length() == 0) return 1;\n\
    \  size_t pos = 0;\n  while (true) {\n    pos = string.find(substring, pos);\n\
    \    if (pos == std::string::npos) return count;\n    count++;\n    pos += substring.length();\n\
    \  }", "    long count = 0;\n    int pos1, pos2;\n    for (pos1 = 0; pos1 < string.length();\
    \ pos1++) {\n        for (pos2 = 0; pos2 < string.length(); pos2++) {\n      \
    \      if (pos1 != pos2 && string[pos1] == substring[pos2]) {\n              \
    \  count++;\n            }\n        }\n    }\n    return count;", "    if (string.length()\
    \ <= substring.length()) return 0;\n    long count = 0;\n    for (auto i : substring)\
    \ {\n        if (string[i] == i) count++;\n    }\n    return count;", "    long\
    \ count = 0;\n    for (int i = 0; i < string.length(); ++i) {\n        if (string.at(i)\
    \ == substring.at(0)) {\n            count += 1;\n            if (string.at(i\
    \ + 1) == substring.at(0)) {\n                count += 1;\n                if\
    \ (string.at(i + 2) == substring.at(0)) {\n                    count += 1;\n \
    \                   if (string.at(i + 3) == substring.at(0)) {\n             \
    \           count += 1;\n                    }\n                }\n          \
    \  }\n        }\n    }\n    return count;", "\t\n\t// Declare a variables to store\
    \ the count of matches of the original string.\n\tlong count = 0;\n\n\t// Declare\
    \ a variables to store the original string.\n\tstd::string original = string;\n\
    \n\t// Declare a variables to store the count of overlaping matches of the original\
    \ string.\n\tint count_of_overlaping_cases = 0;\n\n\t// Declare a variables to\
    \ store the original string.\n\tstd::string original_copy = original;\n\n\t//\
    \ Iterate through the substring\n\tfor (auto &c : substring) {\n\n\t\t// Iterate\
    \ through the original string\n\t\tfor (auto &c2 : original) {\n\n\t\t\t// Stop\
    \ the search when we have found the matching character\n\t\t\tif (c2 == c) {\n\
    \t\t\t\tcount = count + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Stop the search\
    \ when the character is not equal to the matching character\n\t\t\tif (c2 != c)\
    \ {\n\t\t\t\tcount_of_overlaping_cases += 1;\n\t\t\t}\n\t\t}\n\n\t\t// Stop the\
    \ search when we encounter a non-matching character\n\t\tif (count >= string.length())\
    \ {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the total count of matches\n\treturn\
    \ count;", "\t// code here\n\tlong count = (string.find(substring) != std::string::npos)\
    \ ? 1 : 0;\n\t\n\tfor (auto i = string.rbegin(); i != string.rend(); i++) {\n\t\
    \tif (i->find(substring) != std::string::npos)\n\t\t\tcount += 1;\n\t}\n\treturn\
    \ count;", "\tlong count = 0;\n\tstd::string rev_string = string;\n\tfor (auto\
    \ it = rev_string.rbegin(); it != rev_string.rend(); ++it) {\n\t\tif (*it != substring[0])\
    \ {\n\t\t\tbreak;\n\t\t}\n\t}\n\trev_string.erase(0, (it - rev_string.begin())\
    \ + 1);\n\tauto it = rev_string.find(substring);\n\twhile (it != std::string::npos)\
    \ {\n\t\tit = rev_string.find(substring, it + 1);\n\t\t++count;\n\t}\n\treturn\
    \ count;", "    std::set<std::string> s;\n    s.insert(substring);\n    // Iterate\
    \ over each character in string\n    for (auto c: string) {\n        // If substring\
    \ is in this character\n        if (s.count(c)) {\n            s.erase(c);\n \
    \           // Add one to this count\n            return s.size() + 1;\n     \
    \   }\n    }\n    // If the string doesn't contain substring return 0\n    return\
    \ 0;", "    std::string substring_no_case = string; //removes caps and converts\
    \ to lower case\n    std::transform(substring_no_case.begin(), substring_no_case.end(),\
    \ substring_no_case.begin(), ::tolower);\n    std::vector<bool> vec(substring_no_case.length(),\
    \ false);\n    for (size_t i = 0; i < substring_no_case.length(); i++)\n     \
    \   vec[substring_no_case[i] - 'a'] = true;\n    long cnt = 0;\n    size_t start_pos\
    \ = 0;\n    for (size_t i = substring_no_case.length() - substring.length(); start_pos\
    \ < string.length(); start_pos += substring.length(), i = i + substring.length())\
    \ {\n        for (size_t j = i; j < string.length(); j++)\n            if (vec[string[j]\
    \ - 'a'] == true)\n                cnt++;\n    }\n    return cnt;", "    if (string.find(substring)\
    \ == string::npos) return 0;\n    int count = 0;\n    int l = string.find(substring);\n\
    \    while (l+1 < string.length()) {\n        if (string[l] == substring[l+1])\
    \ {\n            count++;\n            l += 2;\n        }\n        else {\n  \
    \          l += 1;\n        }\n    }\n    return count;", "    long ret = 0;\n\
    \    int len1 = string.length(), len2 = substring.length();\n    for (int i =\
    \ 0; i < len1; i++) {\n        for (int j = 0; j < len2; j++) {\n            if\
    \ (string[i] == substring[j]) {\n                ret++;\n            }\n     \
    \       if (i == len1 - 1 && j == len2 - 1) {\n                break;\n      \
    \      }\n        }\n    }\n    return ret;", "    long count = 0;\n    for (auto\
    \ &c : string) {\n        for (auto &cc : substring) {\n            if (c == cc)\n\
    \                count++;\n        }\n    }\n    return count;", "    std::map<std::string,\
    \ int> m;\n    // count all substrings\n    for (auto &c : substring) ++m[c];\n\
    \    // count overlapping substrings\n    for (auto &c : string) if (m[c]) return\
    \ m[c] + how_many_times(string.substr(0, c - 1), substring);\n    // no substring\
    \ found\n    return 0;", "    int string_length = string.length();\n    int substring_length\
    \ = substring.length();\n    \n    // If the string length is less than the substring\
    \ length\n    if (string_length < substring_length)\n        return 0;\n     \
    \   \n    // Initialize count\n    int count = 0;\n    \n    // If the length\
    \ of the string is 0, the return count is 0\n    if (string_length == 0)\n   \
    \     return count;\n        \n    // If the substring length is 0, the return\
    \ count is 0\n    if (substring_length == 0)\n        return count;\n        \n\
    \    // If the length of the string and substring are the same, the return count\
    \ is 0\n    if (string_length == substring_length)\n        return count;\n  \
    \      \n    // If the string length and substring lengths are different, check\
    \ the substring at the second character of string\n    // to see if it is the\
    \ same as the first character of substring. If it is same, then increment the\
    \ count.\n    if (string[string_length - 1] == substring[0]) {\n        if (substring_length\
    \ == 1)\n            count++;\n        else\n            count += how_many_times(string.substr(0,\
    \ string_length - 1), substring.substr(1));\n    }\n    \n    return count;",
  "    // Write your code here\n    long count = 0;\n    for (char &c : string)\n\
    \        if (c == substring[0])\n            for (int i = 0; i < substring.length();\
    \ i++)\n                if (c == substring[i])\n                    count++;\n\
    \    return count;", "    long count = 0;\n    for (auto it : string) {\n    \
    \    if (it == substring[0]) {\n            if (it+1 == substring[0]) {\n    \
    \            count += 1;\n            } else if (it+2 == substring[0]) {\n   \
    \             count += 2;\n            }\n        }\n    }\n    return count;",
  "    long count = 0;\n    for (size_t i = 0, j = string.size(); i < j; i++) {\n\
    \        if (string[i] == substring[0]) {\n            count += how_many_times(string.substr(0,\
    \ i), substring.substr(1)); // Count overlaping cases by calling same function\
    \ recursively\n        } else if (string[i] == substring[1]) {\n            count\
    \ += how_many_times(string.substr(0, i + 1), substring.substr(1)); // Count overlaping\
    \ cases by calling same function recursively\n        }\n    }\n    return count;",
  "\tassert(string.find(substring) == string::npos);\n\treturn (string.size() - string.find(substring))\
    \ - string.find(substring);", "    // Use std::map to count the occurrences of\
    \ substrings in string\n    std::map<char, int> mp;\n    mp[string[0]] = 0;\n\
    \    for (auto c : string) {\n        mp[c]++;\n    }\n\n    int counter = 0;\n\
    \    for (auto c : substring) {\n        counter += mp[c];\n    }\n\n    return\
    \ counter;", "    int len1 = string.length();\n    int len2 = substring.length();\n\
    \    int count = 0;\n    for (int i = 0; i < len1; i++) {\n        for (int j\
    \ = 0; j < len2; j++) {\n            if (string[i] == substring[j])\n        \
    \        count++;\n        }\n    }\n    return count;", "  if (string.length()\
    \ == 0 || substring.length() == 0) return 0;\n  long result = 0;\n  bool first\
    \ = true;\n  for (int i = 0; i < string.length(); i++) {\n    if (i == 0 || string[i]\
    \ != substring[0]) first = false;\n    else if (!first && string[i] == substring[substring.length()\
    \ - 1]) result += 1;\n    else result += how_many_times(string.substr(i + 1, string.length()\
    \ - i) + substring, substring);\n  }\n  return result;", "\tint i = 0;\n\tint\
    \ j = 0;\n\tint k = 0;\n\tint count = 0;\n\n\twhile (i < string.length() && j\
    \ < substring.length()) {\n\t\tif (string[i] == substring[j]) {\n\t\t\ti += 1;\n\
    \t\t\tj += 1;\n\t\t} else {\n\t\t\tk = 0;\n\t\t\tif (string[i] == substring[j])\
    \ {\n\t\t\t\ti += 1;\n\t\t\t\tj += 1;\n\t\t\t\tcount += 1;\n\t\t\t} else {\n\t\
    \t\t\twhile (k < substring.length() && j < substring.length()) {\n\t\t\t\t\tif\
    \ (string[i] == substring[k]) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tk += 1;\n\t\t\
    \t\t\t\tj += 1;\n\t\t\t\t\t\tcount += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else\
    \ {\n\t\t\t\t\t\tk = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn\
    \ count;", "    long count = 0;\n    long start = 0;\n    long end = 0;\n    for(long\
    \ i = 0; i < string.length(); i++) {\n        end = i;\n        for(long j = 0;\
    \ j < substring.length(); j++) {\n            if(i == string.length() - substring.length())\
    \ break;\n            if(string.at(i) == substring.at(j)) break;\n        }\n\
    \        if((end != i) && string.at(i) == substring.at(0)) start++;\n    }\n \
    \   if(start == 0) return 0;\n    if(start < end) {\n        long end1 = end;\n\
    \        end++;\n        while(string.at(0) == string.at(end1)) end++;\n     \
    \   if(end == string.length()) return 0;\n    }\n    while(start < end) {\n  \
    \      long tmp = end;\n        end++;\n        for(long i = 0; i < substring.length();\
    \ i++) {\n            if(string.at(tmp) == substring.at(i)) {\n              \
    \  count++;\n                break;\n            }\n        }\n    }\n    return\
    \ count;", "\tstd::map<char,long> map;\n\t\n\t// Iterate through the string\n\t\
    for (auto &c : string) {\n\t\tif (map.find(c) != map.end())\n\t\t\tmap[c] += 1;\n\
    \t\telse\n\t\t\tmap[c] = 1;\n\t}\n\t\n\t// Iterate through the substring\n\tfor\
    \ (auto &c : substring) {\n\t\tif (map.find(c) != map.end())\n\t\t\tmap[c] +=\
    \ 1;\n\t\telse\n\t\t\tmap[c] = 1;\n\t}\n\t\n\t// Return the value\n\treturn *std::max_element(map.begin(),\
    \ map.end());", "  // Your code here\n  long count = 1;\n  int len = string.size();\n\
    \  int len_sub = substring.size();\n  for (int i = 0; i < len - 1; i++) {\n  \
    \  if (string[i] != substring[i]) {\n      count++;\n      if (string[i] == substring[i])\
    \ {\n        if (string[i + 1] == substring[i + 1]) {\n          count++;\n  \
    \      }\n      }\n    }\n  }\n  for (int i = len - 1; i > 0; i--) {\n    if (string[i]\
    \ != substring[i]) {\n      count--;\n      if (string[i] == substring[i]) {\n\
    \        if (string[i - 1] == substring[i - 1]) {\n          count--;\n      \
    \  }\n      }\n    }\n  }\n  return count;", "   assert(string.length() >= substring.length());\n\
    \   long count = 0;\n   std::size_t pos = 0;\n   while (pos < string.length())\
    \ {\n      pos = string.find(substring, pos);\n      if (pos != std::string::npos)\
    \ {\n         count++;\n         pos += substring.length();\n      }\n   }\n \
    \  return count;", '    return std::count_if(string.begin(), string.end(), [&](auto
    const &c){return (substring.find(c) != std::string::npos);});', "    long ans\
    \ = 0;\n    int ls = string.length();\n    int ln = substring.length();\n    std::string\
    \ temp;\n    \n    for (int i = 0; i < ls; i++) {\n        // If substring is\
    \ not present in string then skip it.\n        if (string[i] == substring[0])\n\
    \            temp.push_back(string[i]);\n        \n        else if (string[i]\
    \ == substring[ln-1])\n        {\n            ans += 1;\n            temp += string[i];\n\
    \        }\n        else\n            temp.push_back(string[i]);\n    }\n    return\
    \ ans;", "    long count = 0;\n    int i = 0;\n    int j = string.length();\n\n\
    \    while (i < j) {\n        if (string.substr(i, substring.length()) == substring)\
    \ {\n            i += substring.length();\n            count++;\n        }\n \
    \       else if (string.substr(j, substring.length()) == substring) {\n      \
    \      j -= substring.length();\n            j += substring.length();\n      \
    \      count++;\n        }\n        else {\n            i++;\n            count++;\n\
    \        }\n    }\n    return count;", "    int count = 0;\n    int i = 0;\n \
    \   int j = substring.size() - 1;\n\n    while (i <= j) {\n        while (string[i]\
    \ != substring[j]) i++;\n        while (string[j] != substring[i]) j--;\n\n  \
    \      if (i >= 0 && j >= 0 && string[i] == substring[j] && string[i] == substring[i])\
    \ count++;\n        i++;\n        j--;\n    }\n    return count;", "  long count\
    \ = 0;\n  for (auto i : string) {\n    if (i == substring[0]) {\n      count +=\
    \ how_many_times(string.substr(1), substring);\n    } else if (i == substring[1])\
    \ {\n      count += how_many_times(string.substr(1), substring.substr(1));\n \
    \   }\n  }\n  return count;", "    long count = 0;\n    for (auto &i : string)\
    \ {\n        if (i == substring[0]) {\n            count += string.find(substring,\
    \ 0) == 0 ? 1 : 0;\n        }\n    }\n    return count;", "    // write your code\
    \ here\n    long count = 1;\n    for (int i = 0; i < string.size(); i++) {\n \
    \       if (string[i] == substring[0]) {\n            if (string[i + substring.length()]\
    \ == substring[substring.length() - 1]) {\n                count += 1;\n     \
    \       }\n        }\n    }\n    return count;", "\tassert (string.size() > substring.size());\n\
    \tauto count = 0;\n\tauto i = string.find(substring);\n\twhile (i != string::npos)\n\
    \t{\n\t\tcount++;\n\t\ti = string.find(substring, i + 1);\n\t}\n\treturn count;",
  "\tstd::string sub = substring;\n\tstd::size_t found = std::count(string.begin(),\
    \ string.end(), substring);\n\tstd::size_t olap = std::count_if(string.begin(),\
    \ string.end(), [&sub](char c) {\n\t\treturn c == sub[0] && sub.size() > 0 &&\
    \ sub.back() == c;\n\t});\n\treturn olap + (found - olap);", "    size_t count\
    \ = 0;\n    for (size_t i = 0; i < string.size(); i++) {\n        auto it = string.find(substring,\
    \ i);\n        if (it == string::npos) {\n            break;\n        }\n    \
    \    count += (it - i);\n        i = it;\n    }\n    return count;", "  long count\
    \ = 0;\n  for (auto i = 0; i < string.size(); i++)\n    if (string[i] == substring[0])\n\
    \      count += how_many_times(string.substr(i + 1), substring);\n  return count;",
  "    auto found = std::count(string.begin(), string.end(), substring);\n    return\
    \ found;", "    if(!string.empty() && string.find(substring) == std::string::npos)\n\
    \        return 0;\n    int index = 0;\n    while(string[index] == substring[0])\
    \ {\n        string += string.find(substring, index + 1);\n        index += substring.size();\n\
    \    }\n    return index - string.find(substring) + 1;", "    long count = 0;\n\
    \    string sub;\n    for (size_t i = 0; i < string.size(); i++) {\n        if\
    \ (string[i] == substring[0]) {\n            count += 1;\n            sub = string.substr(i);\n\
    \            while (sub.size() > 0) {\n                if (sub[0] == substring[sub.size()\
    \ - 1]) {\n                    count += 1;\n                    sub.erase(0, 1);\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n        }\n    }\n    return count;", "    assert(string.length()\
    \ >= substring.length());\n    long n = 0;\n    for (int i = 0; i < string.length();\
    \ i++) {\n        if (string[i] == substring[0]) {\n            if (i> 0) {\n\
    \                for (size_t j = i; j < substring.length(); j++) {\n         \
    \           if (string[i + j] != substring[j]) {\n                        break;\n\
    \                    }\n                }\n                if (j == substring.length())\
    \ {\n                    n++;\n                }\n            }\n        }\n \
    \   }\n    return n;", "    long count = 0;\n    for (int i = 0; i < string.size();\
    \ ++i) {\n        count += string[i] == substring[i] ? 0 : 1;\n    }\n    return\
    \ count;", "    int count = 0;\n    for (int i = 0; i < string.size(); i++) {\n\
    \        if (string[i] == substring[0]) {\n            for (int j = 0; j < substring.size();\
    \ j++) {\n                if (string[i + j] == substring[j])\n               \
    \     count++;\n            }\n        }\n    }\n    return count;", "    if(string.find(substring)\
    \ == string::npos)\n        return 0;\n    int count = 1;\n    for(int i = 0;\
    \ i < string.size(); i++) {\n        bool found = false;\n        for(int j =\
    \ 0; j < substring.size(); j++)\n            if((i == 0 && j == 0) || (string[i]\
    \ == substring[j] && i != 0 && j != 0))\n                found = true;\n     \
    \   if(found)\n            count++;\n    }\n    return count;", "    size_t i\
    \ = 0;\n    size_t j = 0;\n    size_t count = 0;\n    while (j < string.size()\
    \ && i < substring.size()) {\n        if (string[j] == substring[i]) {\n     \
    \       i++;\n            count++;\n        }\n        else if (string[j] > substring[i])\
    \ {\n            j = string.size() - 1;\n            count++;\n        }\n   \
    \     else {\n            j++;\n            count++;\n        }\n    }\n    return\
    \ count;", "\tassert(string.size() > 0 && substring.size() > 0);\n\tlong cnt =\
    \ 0;\n\tsize_t start = 0;\n\twhile ((start = string.find(substring, start)) !=\
    \ string::npos) {\n\t\t++cnt;\n\t\t++start;\n\t}\n\treturn cnt;", "  assert(string.size()\
    \ > substring.size());\n  long count = 0;\n  for (int i = 0; i < string.size();\
    \ i++) {\n    if (string.substr(i, substring.length()) == substring) {\n     \
    \ count++;\n    }\n  }\n  return count;", "    long n = 0, count = 0;\n    \n\
    \    \n    if (string.find(substring) == string.npos)\n        return 0;\n   \
    \ \n    \n    for (long i = 0; i <= string.size(); i++)\n        if (string[i]\
    \ == substring[0])\n            if (string.find(substring, i + 1) != std::string::npos)\n\
    \                count++;\n            \n            \n    n = (string.length()\
    \ - string.replace(substring.begin(), substring.end(), \"\").length());\n    if\
    \ (n > 0) {\n        n -= count + 1;\n        \n    }\n    \n    return n;", " \
    \   int n = string.length();\n    int m = substring.length();\n    long count\
    \ = 0;\n    for (int i = 0; i < n; i++) {\n        count = 0;\n        for (int\
    \ j = 0; j < m; j++) {\n            if (string[i] == substring[j]) {\n       \
    \         count++;\n                break;\n            }\n        }\n       \
    \ if (count == m) {\n            count++;\n        }\n    }\n    return count;",
  "    // Count the number of times the substring appears in the string\n    int count\
    \ = 0;\n    std::string result = \"\";\n    for (int i = 0; string[i] != '\\0';\
    \ i++) {\n        if (string[i] == substring[0]) {\n            result += string[i];\n\
    \            count++;\n        }\n        else if (string[i] > substring[0]) {\n\
    \            if (count > 0) {\n                result += string[i];\n        \
    \        count--;\n            }\n        }\n    }\n    // Return the number of\
    \ times substrings appears in the string\n    return count;", "  long count =\
    \ 0;\n  int start = 0;\n  while (start < string.length()) {\n    int end = string.find(substring,\
    \ start);\n    if (end == std::string::npos) {\n      break;\n    }\n    count++;\n\
    \    start = end + substring.length();\n  }\n  return count;", "    auto it =\
    \ string.find(substring);\n    if (it != string.npos) {\n        return 1;\n \
    \   } else {\n        return 0;\n    }", "    int count = 0;\n    size_t pos =\
    \ 0;\n    size_t len = string.length();\n    while (pos < len) {\n        // Find\
    \ where substring is found from the current position\n        pos = string.find(substring,\
    \ pos);\n        if (pos == std::string::npos) {\n            break;\n       \
    \ }\n        // Increment the count if substring is found\n        ++count;\n\
    \        // Skip the current position in the string\n        pos += substring.length();\n\
    \    }\n    return count;", "    long count = 0;\n    // Loop for each character\
    \ in the original string\n    size_t pos = 0;\n    while ((pos = string.find(substring,\
    \ pos)) != std::string::npos) {\n        // We are in the string so increment\
    \ the count\n        count++;\n        // Move to the end of the found substring\n\
    \        pos += substring.size();\n    }\n    return count;", "    // This uses\
    \ O(n) time but O(n + k) space.\n    long n = string.length(), k = substring.length();\n\
    \    vector<pair<long, long> > vec;\n    vec.reserve(n);\n    for (int i = 0;\
    \ i < n; i++) {\n        string sub = substring.substr(i, k);\n        if (string[i]\
    \ == sub[0]) {\n            long t = 0, l = k;\n            for (int j = i; j\
    \ < n && j < i + k; j++) {\n                if (string[j] != sub[j]) break;\n\
    \                l++;\n                t += 1;\n            }\n            vec.push_back({t,\
    \ l});\n        }\n    }\n    return vec.size();", "    long count = 0;\n    if\
    \ (string == \"\") {\n        return count;\n    }\n    if (substring == \"\"\
    ) {\n        return 0;\n    }\n    for (int i = 0; i < string.length(); i++) {\n\
    \        for (int j = 0; j < substring.length(); j++) {\n            if (string[i]\
    \ == substring[j]) {\n                count++;\n                if (i + 1 != string.length())\
    \ {\n                    count += how_many_times(string.substr(i + 1, string.length()\
    \ - i - 1), substring);\n                }\n            }\n        }\n    }\n\
    \    return count;", "\tint n = string.length();\n\tint m = substring.length();\n\
    \tlong count = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < m;\
    \ j++) {\n\t\t\tif (string[i] == substring[j]) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn count;", "    assert(string.length() >= substring.length());\n\
    \    long ans = 0;\n    int i = 0;\n    while (i < string.length() && string.substr(i,\
    \ substring.length()).compare(substring) == 0) {\n        ans += 1;\n        i\
    \ += substring.length();\n    }\n    return ans;", "    long count = 0;\n    for\
    \ (size_t i = 0; i < string.size(); ++i) {\n        if (string.at(i) == substring.at(0))\
    \ {\n            for (size_t j = 0; j < substring.size(); ++j) {\n           \
    \     if (string.at(i + j) == substring.at(j)) {\n                    count +=\
    \ 1;\n                }\n            }\n        }\n    }\n    return count;",
  "    // assert(string.size() > substring.size()); // check string sizes\n    //\
    \ assert(string.size() > string.size() + substring.size()); // check string sizes\n\
    \n    long count = 0;\n    for (int i = 0; i < string.size(); ++i) {\n       \
    \ // std::cout << \"string[\" << i << \"] is \" << string[i] << \" at \" << &string[i]\
    \ << \", substring length \"<< substring.size() << \", substring \" << substring\
    \ << std::endl;\n        if (string[i] == substring[0]) { // if first character\
    \ in substring\n            if (i == string.size() - substring.size()) {\n   \
    \             // std::cout << \"substring \" << substring << \" found at end of\
    \ string\" << std::endl;\n                return count;\n            }\n     \
    \       for (int j = 0; j < substring.size(); ++j) {\n                if (string[i\
    \ + j] != substring[j]) { // if substring not equal to next character\n      \
    \              break;\n                }\n                // std::cout << \"Substring\
    \ \" << substring << \" found at index: \" << i << \" with \" << j << std::endl;\n\
    \                if (j == substring.size() - 1) {\n                    count++;\n\
    \                }\n            }\n        } else {\n            // std::cout\
    \ << \"substring \" << substring << \" not found in string\" << std::endl;\n \
    \           return 0;\n        }\n    }\n\n    // std::cout << \"substring \"\
    \ << substring << \" not found at end of string\" << std::endl;\n    return 0;",
  "    long count = 0;\n    for(auto ch : string) {\n        if(ch == substring[0])\
    \ {\n            count += 1;\n            if(ch == substring[1]) {\n         \
    \       count += 1;\n                \n            }\n        }\n    }\n    return\
    \ count;", "    int count = 0;\n    for (int i = 0; i < string.size(); i++)\n\
    \    {\n        count += string[i] == substring[0] || string[i] == substring[1];\n\
    \        // cout << string[i] << endl;\n        if (string[i] != substring[0])\n\
    \        {\n            count += 1;\n            // cout << \"aaa\" << endl;\n\
    \        }\n        if (string[i] != substring[1])\n        {\n            count\
    \ += 1;\n            // cout << \"aaa\" << endl;\n        }\n    }\n    cout <<\
    \ \"\\n\" << (count) << endl;\n    return count;", "    long n = 0;\n    size_t\
    \ pos = 0;\n    while (pos < string.size()) {\n        pos = string.find(substring,\
    \ pos);\n        if (pos == std::string::npos) break;\n        n++;\n        pos\
    \ += substring.length();\n    }\n    return n;", "  int cnt = 0;\n  int i = 0;\n\
    \  int j = string.length() - substring.length();\n\n  // count overlaping cases\n\
    \  while (i < j) {\n    if (string[i] == substring[j]) {\n      ++cnt;\n     \
    \ i++;\n      j--;\n    }\n    else if (string[i] > substring[j]) {\n      i++;\n\
    \    }\n    else {\n      j--;\n    }\n  }\n  return cnt;", "   long cnt = 0;\n\
    \   for (size_t i = 0; i < string.size(); i++) {\n      cnt += string.find(substring,\
    \ i) != std::string::npos;\n      i += substring.size();\n   }\n   return cnt;",
  "    int m = 0, n = string.length();\n    for (int i = 0; i < n; i++) {\n      \
    \  if (string[i] == substring[0]) {\n            int k = i;\n            for (int\
    \ j = i; j < n; j++) {\n                if (string[j] != substring[j]) {\n   \
    \                 if (j - k > 1) {\n                        m = m + 1;\n     \
    \               }\n                    break;\n                }\n           \
    \ }\n        }\n    }\n    return m;", "    string pattern(substring);\n    long\
    \ counter = 0;\n    int count = 0;\n    for (int i = 0; i <= string.size() - pattern.size();\
    \ i++) {\n        std::string string_temp = string.substr(i, pattern.size());\n\
    \        if (string_temp == pattern) {\n            counter++;\n            count++;\n\
    \        }\n    }\n    return count;", "    int n = string.find(substring);\n\
    \    if (n == std::string::npos) return 0;\n    int count = 0;\n    while (n !=\
    \ -1) {\n        ++count;\n        n += substring.size();\n        n = string.find(substring,\
    \ n);\n    }\n    return count;", "\tstd::set<char> string_set;\n\tstd::set<char>\
    \ substring_set;\n\tfor (char c: string) {\n\t\tif (c != substring[0]) {\n\t\t\
    \tif (substring.find(c) == std::string::npos)\n\t\t\t\tstring_set.insert(c); //\
    \ if the substring is not found then add it with the count 1\n\t\t\telse\n\t\t\
    \t\tsubstring_set.insert(c); // if the substring is found then add it with the\
    \ count 1\n\t\t} else {\n\t\t\tsubstring_set.insert(c); // if the substring is\
    \ found then add it with the count 1\n\t\t}\n\t}\n\treturn string_set.count(string)\
    \ + substring_set.count(substring);", "    long ans = 0;\n    for (long i = 0;\
    \ i < string.length(); i++) {\n        if (string.substr(i, substring.length())\
    \ == substring) {\n            ans += 1;\n        }\n    }\n    return ans;",
  "    assert(!substring.empty());\n    size_t len1 = string.length();\n    size_t\
    \ len2 = substring.length();\n    long count = 0;\n    for (size_t i = 0; i <\
    \ len1; i++) {\n        size_t j = 0;\n        for (; j < len2; j++) {\n     \
    \       if (string[i] == substring[j] && string[i] != substring[j + 1]) {\n  \
    \              count++;\n                break;\n            }\n        }\n  \
    \  }\n    return count;", "    if(string.size() == 0) return 0;\n\n    long long\
    \ n = 0;\n    for(size_t i = 0; i < string.size(); i++) {\n        n += std::count(string.begin()+i,\
    \ string.end(), substring[i]);\n    }\n    return n;", "    // write your code\
    \ here\n    long cnt = 0;\n    for (auto it = string.cbegin(); it != string.cend();\
    \ ++it) {\n        auto i1 = substring.find(*it);\n        if (i1 != std::string::npos)\
    \ {\n            cnt += (i1 + 1);\n        }\n    }\n    return cnt;", "    long\
    \ count{0};\n    long start{0};\n    long end{0};\n    start = string.length()\
    \ - substring.length();\n    end = string.length();\n    count = std::count(string.begin(),\
    \ string.end(), substring);\n    return count;", "    long count = 0;\n    long\
    \ lpos = 0;\n    for (auto it = string.begin(); it != string.end(); it++) {\n\
    \        lpos = it;\n        if (lpos == string.length() || substring[0] == string[lpos]\
    \ || substring[0] == string[lpos - 1]) {\n            count++;\n        }\n  \
    \  }\n    return count;", "    long count = 0;\n    auto start = string.find(substring);\n\
    \    if (start != string::npos) {\n        count = 1;\n        start = start +\
    \ substring.length();\n    }\n    while (start != string::npos) {\n        ++count;\n\
    \        start = string.find(substring, start);\n    }\n    return count;", " \
    \ // Initialize a counter and count overlapping occurrences of substring\n  long\
    \ count = 0;\n  int index = string.find(substring);\n  while (index != string::npos)\
    \ {\n    count++;\n    index = string.find(substring, index + 1);\n  }\n  return\
    \ count;", "  int l1 = string.length(), l2 = substring.length();\n  vector<int>\
    \ result;\n  for (int i = 0; i < l1; i++) {\n    if (string[i] == substring[0]\
    \ && substring[l2 - 1] == string[l1 - 1]) {\n      result.push_back(i);\n    }\n\
    \  }\n  return result.size();", "    long count = 0;\n    long len = string.length();\n\
    \    long pos = 0;\n    // Find all the cases of substring\n    while ((pos =\
    \ string.find(substring, pos)) != string::npos) {\n        ++count;\n        //\
    \ Move to next position after last found case\n        pos += (substring.size());\n\
    \    }\n    return count;", "    long sum = 0;\n    for (size_t i = 0; i < string.size();\
    \ i++) {\n        if (string[i] == substring[0]) {\n            sum += how_many_times(string.substr(i\
    \ + 1), substring);\n        } else if (string[i] == substring[1]) {\n       \
    \     sum += how_many_times(string.substr(i), substring);\n        } else {\n\
    \            sum += 1;\n        }\n    }\n    return sum;", "    long count =\
    \ 0;\n    int i = 0;\n    int j = 0;\n    while (i < string.size() && j < substring.size())\
    \ {\n        if (string[i] == substring[j]) {\n            i++;\n            j++;\n\
    \        }\n        else if (string[i] == substring[j] && string[i] != substring[j])\
    \ {\n            j++;\n        }\n        else if (string[i] != substring[j])\
    \ {\n            break;\n        }\n        else {\n            i++;\n       \
    \     j++;\n        }\n        count++;\n    }\n    return count;", "    // write\
    \ your code here\n    return 0;", "    // Your code here\n    return __builtin_popcount(string.find(substring));",
  "    string sub_str = substring;\n    long num_of_times = 0;\n    for (auto &it\
    \ : string) {\n        if (it == sub_str.front() || it == sub_str.back()) {\n\
    \            num_of_times++;\n        }\n    }\n    return num_of_times;", "\t\
    std::map<char, long> char_map;\n\tstd::map<long, char> char_map2;\n\tfor (char\
    \ c : string)\n\t\tif (c != '\\0')\n\t\t\tchar_map[c] = char_map.size();\n\tfor\
    \ (char c : substring)\n\t\tif (c != '\\0')\n\t\t\tchar_map2[char_map[c]] = c;\n\
    \tlong count = 0;\n\tfor (auto [key, value] : char_map2)\n\t\tif (value != '.')\n\
    \t\t\tcount += char_map[value];\n\treturn count;", "\tassert (string.size() >\
    \ substring.size());\n\tlong count_times = 0;\n\tfor (auto c : string) {\n\t\t\
    if (c == substring[0]) {\n\t\t\tcount_times += how_many_times(string.substr(1),\
    \ substring);\n\t\t} else if (c != substring[0]) {\n\t\t\tcount_times += how_many_times(string.substr(1),\
    \ substring.substr(1));\n\t\t}\n\t}\n\treturn count_times;", "  // Find the start\
    \ and end positions.\n  int str_start = string.find(substring);\n  int str_end\
    \ = string.find(substring, str_start + 1);\n\n  // If not found, return 0.\n \
    \ if (str_end == std::string::npos)\n    return 0;\n\n  int sub_start = substring.find(substring);\n\
    \  int sub_end = substring.find(substring, sub_start + 1);\n\n  // If not found,\
    \ return 0.\n  if (sub_end == std::string::npos)\n    return 0;\n\n  // If substring\
    \ is present atleast once in string then count it.\n  if (sub_start <= str_start\
    \ && sub_end <= str_end)\n    return 1 + how_many_times(string, substring);\n\n\
    \  return 0;", "\tassert(string.length() >= substring.length());\n\tlong count\
    \ = 0;\n\tint start = 0;\n\tfor (int i = 0; i < string.length(); ++i) {\n\t\t\
    if (string[i] == substring[0]) {\n\t\t\tif (start <= i) {\n\t\t\t\t++count;\n\t\
    \t\t}\n\t\t\tstart = i + 1;\n\t\t}\n\t\tif (string[i] == substring[substring.length()\
    \ - 1]) {\n\t\t\tif (i == string.length() - substring.length() - 1) {\n\t\t\t\t\
    ++count;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;", "    long count = 0;\n    int\
    \ i = 0;\n    while (i + substring.length() <= string.length()) {\n        bool\
    \ found = false;\n        for (char c : substring) {\n            if (string[i\
    \ + c] == '\\0') {\n                found = true;\n                break;\n  \
    \          }\n        }\n        if (!found) {\n            i += substring.length();\n\
    \        } else {\n            count++;\n            i += substring.length() -\
    \ 1;\n        }\n    }\n    return count;", "    long count = 0;\n    size_t size\
    \ = string.size();\n    size_t substring_size = substring.size();\n    if (size\
    \ >= substring_size)\n        return 0;\n    for (size_t i = 0; i < size && i\
    \ < substring_size; i++) {\n        size_t j;\n        for (j = i; j < substring_size;\
    \ j++) {\n            assert(string[j] == substring[j]);\n            if (string[j]\
    \ == substring[j]) {\n                count++;\n                j++;\n       \
    \     }\n        }\n    }\n    return count;", "    int count = 0;\n    int i\
    \ = 0;\n    size_t pos = 0;\n    while (i < string.length()) {\n        pos =\
    \ string.find(substring, i);\n        i += pos - i;\n        if (pos != std::string::npos)\n\
    \            count += 1;\n    }\n    return count;", "\tlong cnt = 0;\n\tfor(auto\
    \ it=string.begin(); it != string.end(); ++it) {\n\t\tif(*it == substring[0])\
    \ {\n\t\t\tfor(auto jt = it; jt != string.end(); ++jt) {\n\t\t\t\tif(*jt == substring[1])\
    \ {\n\t\t\t\t\tcnt += 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\
    return cnt;", "    long count = 0;\n    long pos1 = 0;\n    long pos2 = string.length();\n\
    \n    while (pos2 < pos1) {\n        if (string[pos2 - 1] != substring[pos1 -\
    \ 1]) {\n            count++;\n        }\n\n        if (pos2 - pos1 > substring.length()\
    \ - 1) {\n            pos1++;\n            pos2 = pos1;\n        } else {\n  \
    \          pos2++;\n        }\n    }\n\n    return count;", "\tlong count = 0;\n\
    \tfor (size_t i = 0; i < string.size(); i++) {\n\t\tfor (size_t j = 0; j < substring.length();\
    \ j++) {\n\t\t\tif (string[i] == substring[j]) { count++; }\n\t\t}\n\t}\n\treturn\
    \ count;", "    long count = 0;\n    size_t start = 0;\n    size_t end = 0;\n\n\
    \    for (size_t i = 0; i < string.size() - substring.size(); i++) {\n       \
    \ if (string.substr(i, substring.length()) == substring) {\n            count++;\n\
    \            start = i + 1;\n            end = i + substring.length();\n     \
    \   }\n    }\n\n    return count;", "    int len_string = string.size();\n   \
    \ int len_substring = substring.size();\n    int count = 0; // Number of overlapping\
    \ substring occurrences\n    for (int i = 0; i <= len_string; i++) {\n       \
    \ if (string[i] == substring[0]) {\n            count++;\n            for (int\
    \ j = 1; j <= len_substring; j++) {\n                if (string[i + j] != substring[j])\n\
    \                    break;\n                count++;\n            }\n       \
    \ }\n    }\n    return count;", "    // Write your code here\n    long count =\
    \ 0;\n    int len_string = string.length();\n    int len_substring = substring.length();\n\
    \    if (len_string == 0 || len_substring == 0) return count;\n    int i;\n  \
    \  for (i = 0; i < (len_string - len_substring); i++) {\n        count += string.find(substring,\
    \ i);\n        if (count >= (len_substring-1)) count--;\n    }\n    return count;",
  "    long count = 0, index = 0, flag = 0;\n\n    for (index = 0; index < string.size();\
    \ index++) {\n        if (string[index] == substring[0]) {\n            for (;\
    \ index < string.size() && flag == 0; index++) {\n                if (string[index]\
    \ == substring[0]) {\n                    flag = 1;\n                    count++;\n\
    \                }\n            }\n        }\n    }\n    return count;", "   \
    \ long count = 0;\n    int len = string.length();\n    int si = substring.find('a');\n\
    \    // Find overlapping matches\n    while (si != -1) {\n        while (si +\
    \ len < string.length() && string.substr(si, len) == substring)\n            ++count;\n\
    \        si = string.find('a', si + 1);\n    }\n    return count;", "    if (string.find(substring)\
    \ == string::npos) return 0;\n    if (string.size() <= substring.size() || substring.size()\
    \ > string.size()) return 0;\n    if (substring.size() == 1) return (string.find(substring)\
    \ == string::npos) ? 1 : 0;\n    long ans = 0;\n    string tmp = string;\n   \
    \ for (auto &c : substring) {\n        if (tmp.find(c) != string::npos) {\n  \
    \          ans += (c - 'a') * how_many_times(tmp, substring);\n            tmp\
    \ = tmp.erase(0, tmp.find(c) + 1);\n        }\n        else break;\n    }\n  \
    \  return ans;", "    // Write your code here\n\tlong count = 0;\n\tint i = 0;\n\
    \tlong len = string.size();\n\twhile (i < len) {\n\t\tif (string[i] == substring[0])\
    \ {\n\t\t\tcount = count + 1;\n\t\t\tfor (int j = 1; j < substring.length(); ++j)\
    \ {\n\t\t\t\tif (string[i + j] != substring[j])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\
    \t\ti += substring.length() - 1;\n\t\t} else if (string[i] == substring[0]) {\n\
    \t\t\ti += 1;\n\t\t} else {\n\t\t\ti = i + 1;\n\t\t}\n\t}\n\treturn count;", " \
    \   long count = 0;\n    for (size_t i = 0; i < string.size(); i++) {\n      \
    \  if (string[i] == substring[0]) {\n            if (i + substring.length() ==\
    \ string.size()) break;\n            for (size_t j = 0; j < substring.length();\
    \ j++) {\n                if (string[i + j] != substring[j]) break;\n        \
    \    }\n            if (j == substring.length()) count++;\n        }\n    }\n\
    \    return count;", "  // Count overlapping cases, i.e, count how many times\
    \ the substring exists in the given string\n  long count = 0;\n  int idx = 0;\n\
    \  while ((idx = string.find(substring, idx)) != std::string::npos) {\n    ++count;\n\
    \    idx = idx + 1;\n  }\n  return count;", "    int count = 0;\n    for (int\
    \ i = 0; i < string.size(); i++) {\n        if (string[i] == substring[0]) {\n\
    \            std::string str1 = string.substr(0, i);\n            std::string\
    \ str2 = string.substr(i + substring.length());\n            count += how_many_times(str1,\
    \ substring);\n            count += how_many_times(str2, substring);\n       \
    \ } else if (string[i] == substring[1]) {\n            std::string str1 = string.substr(0,\
    \ i);\n            std::string str2 = string.substr(i + substring.length());\n\
    \            count += how_many_times(str1, substring);\n            count += how_many_times(str2,\
    \ substring);\n        } else if (string[i] == substring[2]) {\n            std::string\
    \ str1 = string.substr(0, i);\n            std::string str2 = string.substr(i\
    \ + substring.length());\n            count += how_many_times(str1, substring);\n\
    \            count += how_many_times(str2, substring);\n        } else if (string[i]\
    \ == substring[3]) {\n            std::string str1 = string.substr(0, i);\n  \
    \          std::string str2 = string.substr(i + substring.length());\n       \
    \     count += how_many_times(str1, substring);\n            count += how_many_times(str2,\
    \ substring);\n        } else if (string[i] == substring[4]) {\n            std::string\
    \ str1 = string.substr(0, i);\n            std::string str2 = string.substr(i\
    \ + substring.length());\n            count += how_many_times(str1, substring);\n\
    \            count += how_many_times(str2, substring);\n        } else if (string[i]\
    \ == substring[5]) {\n            std::string str1 = string.substr(0, i);\n  \
    \          std::string str2 = string.substr(i + substring.length());\n       \
    \     count += how_many_times(str1, substring);\n            count += how_many_times(str2,\
    \ substring);\n        } else if (string[i] == substring[6]) {\n            std::string\
    \ str1 = string.substr(0, i);\n            std::string str2 = string.substr(i\
    \ + substring.length());\n            count += how_many_times(str1, substring);\n\
    \            count += how_many_times(str2, substring);\n        } else if (string[i]\
    \ == substring[7]) {\n            std::string str1 = string.substr(0, i);\n  \
    \          std::string str2 = string.substr(i + substring.length());\n       \
    \     count += how_many_times(str1, substring);\n            count += how_many_times(str2,\
    \ substring);\n        } else if (string[i] == substring[8]) {\n            std::string\
    \ str1 = string.substr(0, i);\n            std::string str2 = string.substr(i\
    \ + substring.length());\n            count += how_many_times(str1, substring);\n\
    \            count += how_many_times(str2, substring);\n        } else if (string[i]\
    \ == substring[9]) {\n            ", "    int i = 0;\n    int j = 0;\n    int\
    \ k = 0;\n    int m = 0;\n    while (j < string.length()) {\n        if (string.at(i)\
    \ == substring.at(k)) {\n            i++;\n            k++;\n            j++;\n\
    \            continue;\n        }\n        if (string.at(i) == substring.at(m))\
    \ {\n            if (k >= substring.length())\n                m++;\n        \
    \    k++;\n            j++;\n        }\n        i++;\n        m++;\n    }\n  \
    \  return m;", "    long count = 0;\n    for (int i = 0; i < string.size(); i++)\n\
    \    {\n        // Check if the current character is equal to the one we are looking\
    \ for\n        if (string[i] == substring[0])\n        {\n            // Check\
    \ if the current character is equal to the one beyond the one we are looking for\n\
    \            if (string[i + 1] == substring[0])\n            {\n             \
    \   // If we matched the first character, then check the second character\n  \
    \              // And then check the third character\n                // And then\
    \ check the fourth character\n                // And then check the fifth character\n\
    \                // And so on\n                if (string[i + 2] == substring[1]\
    \ && string[i + 3] == substring[2] && string[i + 4] == substring[3] && string[i\
    \ + 5] == substring[4])\n                {\n                    count += 1;\n\
    \                }\n            }\n        }\n    }\n    return count;", "  int\
    \ i = 0;\n  int count = 0;\n  std::string temp = string;\n  while (true) {\n \
    \   temp.erase(std::remove(temp.begin(), temp.end(), substring[i]), temp.end());\n\
    \    if (temp == string) {\n      count++;\n      i++;\n      if (i >= substring.size())\n\
    \        break;\n    }\n  }\n  return count;", "  int n = string.length();\n \
    \ int m = substring.length();\n  assert(n >= m);\n\n  int result = 0;\n  int i\
    \ = 0, j = 0;\n  while (i < n && j < m) {\n    if (string[i] == substring[j])\
    \ {\n      ++i;\n      ++j;\n      ++result;\n    } else if (string[i] == substring[j])\
    \ {\n      ++i;\n      ++result;\n    } else {\n      ++j;\n    }\n  }\n  while\
    \ (i < n) {\n    ++result;\n    ++i;\n  }\n  while (j < m) {\n    ++result;\n\
    \    ++j;\n  }\n  return result;", "  long count = 0;\n  std::string::const_iterator\
    \ i; // to traverse string\n  for (i = string.cbegin(); i != string.cend(); ++i)\n\
    \    if (*i == substring[0]) {\n      count += 1;\n      if (i == string.cbegin())\n\
    \        count += i[1] == substring[1]? 1 : 0;\n      if (i == string.cend())\n\
    \        count += i[string.size() - 1] == substring[substring.size() - 1]? 1 :\
    \ 0;\n    }\n  return count;", "    int count = 0;\n    int i = 0;\n    while\
    \ (i < string.size()) {\n        if (string[i] == substring[0]) {\n          \
    \  i++;\n            while (i < string.size() && string[i] == substring[0])\n\
    \                i++;\n            count++;\n            if (i >= string.size())\
    \ {\n                break;\n            }\n            while (i < string.size()\
    \ && string[i] != substring[0])\n                i++;\n        } else {\n    \
    \        while (i < string.size() && string[i] != substring[0])\n            \
    \    i++;\n        }\n    }\n    return count;", "    long count = 0;\n    for\
    \ (auto i = 0; i < string.size(); i++) {\n        if (string[i] == substring[0]\
    \ && string[i + 1] == substring[1]) {\n            count++;\n        }\n    }\n\
    \    return count;", "    long count = 0;\n    int length = string.length();\n\
    \    long lenght = substring.length();\n    bool found = false;\n\n    for (int\
    \ i = 0; i < length; i++) {\n        if (string[i] == substring[0]) {\n      \
    \      for (int j = 1; j < lenght; j++) {\n                if (string[i + j] ==\
    \ substring[j]) {\n                    found = true;\n                    break;\n\
    \                }\n            }\n            if (found) {\n                count++;\n\
    \            }\n        }\n    }\n\n    return count;", "    long count = 0;\n\
    \    for (int i = 0; i < string.size(); ++i) {\n        if (string[i] == substring[0])\
    \ {\n            for (int j = 0; j < substring.length(); ++j) {\n            \
    \    if (string[i + j + 1] != substring[j]) break;\n            }\n          \
    \  count += j;\n        }\n    }\n    return count;", "    if (string.find(substring)\
    \ != string::npos)\n        return string.find(substring) - string.find(substring);\n\
    \    return -1;", "  long count = 0;\n  string sub_s = substring;\n  for (int\
    \ i = 0; i < string.length(); i++) {\n    if (string[i] == sub_s) {\n      count++;\n\
    \    }\n  }\n  return count;", "    long count = 0;\n    // Step 1: Make an array\
    \ of all the unique characters in the given string.\n    // Note: We don't need\
    \ to check for spaces in this function.\n    char letters[string.size()];\n  \
    \  memcpy(letters, string.c_str(), sizeof(letters));\n    // Step 2: Iterate through\
    \ the given string looking for occurrences of the given substring.\n    // Note:\
    \ We don't need to check for spaces in this function.\n    for (size_t i = 0;\
    \ i < (size_t) string.length(); i++) {\n        size_t pos = 0;\n        // Step\
    \ 3: Check if the letter at position i is found in the given substring. If so\
    \ increment the counter by 1.\n        // Note: We don't need to check for spaces\
    \ in this function.\n        while (pos < substring.length() && (pos != (size_t)\
    \ string.length() || string[i] != substring[pos])) {\n            pos++;\n   \
    \     }\n        letters[i] = 0;\n        if (pos == substring.length()) {\n \
    \           count++;\n        }\n    }\n    return count;", "  int start = 0;\n\
    \  int end = 0;\n  int count = 0;\n  while (end < string.size()) {\n    end =\
    \ string.find(substring, start);\n    if (end != std::string::npos) {\n      count++;\n\
    \      start = end + 1;\n    } else {\n      count = 1;\n      start = string.find(substring,\
    \ end) + 1;\n    }\n  }\n  return count;", "    int count = 0;\n    int i = 0;\n\
    \    int j = 0;\n    int k = 0;\n    while (i < string.length()) {\n        k\
    \ = string.find(substring, j);\n        if (k == string::npos) {\n           \
    \ j++;\n        } else {\n            count++;\n            j = k;\n        }\n\
    \        i++;\n    }\n    return count;", "    // Initialize number of times the\
    \ substring occurs in the original string.\n    long count = 0;\n    int index\
    \ = 0;\n    // Iterate through each character in the given substring.\n    for\
    \ (;; index++) {\n        // If the current character is not in the given string,\
    \ return 0.\n        if (string[index] == substring[index]) {\n            count++;\n\
    \        }\n        // If index equals the length of the given string, then the\
    \ substring has found all the characters of the given string, so return count.\n\
    \        if (index == substring.length()) {\n            return count;\n     \
    \   }\n    }", "    int length = string.length();\n    int sublength = substring.length();\n\
    \    if (sublength > length) {\n        return 0;\n    }\n    if (length == 0)\
    \ {\n        return 0;\n    }\n    int count = 0;\n    int i = 0;\n    while (i\
    \ < length && i < sublength) {\n        if (string[i] == substring[i]) {\n   \
    \         count++;\n            i += 1;\n        } else if (string[i] < substring[i])\
    \ {\n            i += 1;\n        } else {\n            i += 1;\n        }\n \
    \   }\n    return count;", "  // Create a vector with count for each character\
    \ of the substring\n  // and count the number of times a character appears in\
    \ the string\n  auto char_vec = [&](std::string &s) {\n    std::vector<int> vec(s.begin(),\
    \ s.end());\n    std::iota(vec.begin(), vec.end(), 0);\n    return vec;\n  };\n\
    \  // Calculate the count for each character in the original string\n  auto char_vec2\
    \ = [&](std::string &s) {\n    std::vector<int> vec(s.begin(), s.end());\n   \
    \ std::iota(vec.begin(), vec.end(), 0);\n    return vec;\n  };\n  auto char_vec_vec\
    \ = char_vec(substring);\n  auto char_vec_vec2 = char_vec2(string);\n  auto char_vec_vec_vec\
    \ = char_vec_vec(string);\n  auto char_vec_vec_vec2 = char_vec_vec2(string);\n\
    \n  // Sort the vector and then search for the count of 'substring' in the vector\n\
    \  auto char_vec_sort = char_vec_vec_vec.begin(), char_vec_vec_vec.end(), char_vec_vec_vec2.begin(),\
    \ char_vec_vec_vec2.end();\n  std::sort(char_vec_sort, char_vec_sort+char_vec_vec_vec.size(),\
    \ [&](auto &x, auto &y){return x < y;});\n  for (size_t i = 0; i < char_vec_vec_vec.size();\
    \ i++) {\n    if (char_vec_vec_vec[i] == char_vec_vec_vec2[i]) return char_vec_vec_vec[i];\n\
    \  }\n  return 0;", "    long n = 0;\n    for (auto &c : string) {\n        if\
    \ (c.compare(substring) == 0)\n            n++;\n    }\n    return n;", "    long\
    \ count = 0;\n    for (int i = 0; i < string.length(); i++) {\n        if (string.substr(0,\
    \ substring.length()).compare(substring) == 0)\n            count++;\n    }\n\
    \    return count;", "\tlong count = 0;\n\tfor (int i = 0; i < string.length();\
    \ i++) {\n\t\tif (string[i] == substring[0]) {\n\t\t\tif (string[i+1] == substring[1])\
    \ {\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\
    \t\t\tbreak;\n\t\t}\n\t}\n\treturn count;", "    long result = 0;\n    for (int\
    \ i = 0; i < string.size(); i++) {\n        int index = string.find(substring,\
    \ i);\n        if (index != std::string::npos) {\n            result += 1;\n \
    \           i = index;\n        }\n    }\n    return result;", "    long count\
    \ = 0;\n    for (std::string::size_type pos = string.find(substring); pos != std::string::npos;\
    \ pos = string.find(substring, pos + substring.length())) {\n        count++;\n\
    \    }\n    return count;", "    long count = 0;\n    for (size_t i = 0; i < string.size();\
    \ i++) {\n        bool found = false;\n        for (size_t j = 0; j < substring.size();\
    \ j++) {\n            if (string[i] == substring[j]) {\n                count++;\n\
    \                found = true;\n                break;\n            }\n      \
    \  }\n        if (!found)\n            break;\n    }\n    return count;", "  if\
    \ (string.size() == 0 || substring.size() == 0) {\n    return 0;\n  }\n  int n\
    \ = string.find(substring);\n  int count = 0;\n  while (n != std::string::npos)\
    \ {\n    n = string.find(substring, n + substring.length());\n    count += 1;\n\
    \  }\n  return count;", "  long ans = 0;\n  int i = 0;\n  int j = 0;\n  int size\
    \ = string.length();\n  int size2 = substring.length();\n  while (i < size &&\
    \ j < size2) {\n    if (string[i] == substring[j])\n      i++;\n    else if (string[i]\
    \ == substring[j])\n      i++;\n    else if (string[i] == substring[j])\n    \
    \  i++;\n    else if (string[i] > substring[j])\n      j++;\n    else if (string[i]\
    \ < substring[j])\n      j++;\n    else if (string[i] < substring[j])\n      j++;\n\
    \    else if (string[i] > substring[j])\n      j++;\n    else if (string[i] ==\
    \ substring[j])\n      i++;\n    else if (string[i] > substring[j])\n      i++;\n\
    \    else if (string[i] < substring[j])\n      i++;\n    else if (string[i] <\
    \ substring[j])\n      i++;\n    else\n      ans++;\n  }\n  return ans;", "  \
    \  int n = string.find(substring);\n    if (n == std::string::npos) {\n      \
    \  return 0;\n    }\n    // This code is based on the code by Siddharth Chandra\n\
    \    // https://gist.github.com/cdezanella/8977582\n    // https://stackoverflow.com/questions/35159818/how-many-times-a-substring-occurs-in-a-string\n\
    \    long count = 0;\n    long index = string.find(substring);\n    while (index\
    \ != string::npos) {\n        index = string.find(substring, index + 1);\n   \
    \     count++;\n    }\n    return count;", "    long count = 0;\n    std::string::size_type\
    \ start = 0;\n    std::string::size_type end = string.size();\n    while (start\
    \ < end) {\n        std::string::size_type middle = std::min(end, start + substring.length());\n\
    \        if (string.substr(start, middle) == substring) {\n            count +=\
    \ 1;\n            start = middle + 1;\n        }\n        else {\n           \
    \ end = middle;\n        }\n    }\n    return count;", '    return count(string.begin(),
    string.end(), substring.begin(), substring.end()) + std::count(string.begin(),
    string.end(), substring.begin(), substring.end()) - 1;', "\tlong count = 1;\n\t\
    for(size_t i=0; i<string.size(); i++) {\n\t\tif(!string.at(i).equals(substring[0]))\
    \ {\n\t\t\tcontinue;\n\t\t}\n\t\tfor(size_t j=1; j<substring.size(); j++) {\n\t\
    \t\tif(!string.at(i).equals(substring[j])) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\
    count++;\n\t\t}\n\t}\n\treturn count;", "    long sum = 0;\n    int i = 0;\n \
    \   int j = substring.size() - 1;\n    while (i < string.size() && !(string.at(i)\
    \ == substring.at(j))) {\n        i++;\n        j--;\n        if (string.at(i)\
    \ == substring.at(j)) {\n            sum++;\n            i++;\n            j--;\n\
    \        }\n    }\n    while (i < string.size() && string.at(i) == substring.at(j))\
    \ {\n        sum++;\n        i++;\n        j--;\n    }\n    return sum;", "  \
    \  assert(string.size() > substring.size());\n    long times = 0;\n    int i =\
    \ 0;\n    int n = (int)string.size() - (int)substring.size();\n    for (int j\
    \ = i; j < n; j++) {\n        if (string[i+j] == substring[j]) times++;\n    \
    \    else if ((times == 0) || (substring[j] < string[i])) break;\n    }\n    return\
    \ times;", "  if (string.size() == 0) return 0;\n  else if (string.find(substring)\
    \ == string::npos) return 0;\n  else {\n    int count = 0;\n    for (int i = 0;\
    \ i < string.size() && count < substring.length(); i++) {\n      if (string[i]\
    \ == substring[count]) count++;\n      else count = 0;\n    }\n    return count;\n\
    \  }", "    if (substring == \"\") return 0;\n\n    long count = 0;\n    for (auto\
    \ i = string.rbegin(); i != string.rend(); i++) {\n        if (*i == substring[0])\
    \ {\n            count += 1;\n            for (auto j = substring.length(); j\
    \ > 0; j--) {\n                if (*i == *(i - j)) {\n                    count\
    \ += 1;\n                    i -= j;\n                }\n            }\n     \
    \   }\n    }\n\n    return count;", "    // Store the size of the original string\n\
    \    size_t string_size = string.size();\n    // Store the size of the original\
    \ substring\n    size_t substring_size = substring.size();\n    // Initialize\
    \ a counter to count the number of times the substring can be found in the original\
    \ string\n    long counter = 0;\n    // Create a variable for storing each character\
    \ of the original string\n    char char_array[substring_size];\n    // Create\
    \ a variable for storing each character of the original string\n    for (size_t\
    \ i = 0; i < substring_size; i++) {\n        char_array[i] = string[i];\n    }\n\
    \    // Iterate through each character of the original string and check if it\
    \ matches the substring\n    for (size_t i = 0; i < string_size; i++) {\n    \
    \    // Check every character in the substring\n        for (size_t j = 0; j <\
    \ substring_size; j++) {\n            if (char_array[i] == char_array[j]) {\n\
    \                // If there is a match, increment the counter\n             \
    \   counter++;\n                // If no match is found, set the counter to zero\n\
    \            } else {\n                // If the character in the substring is\
    \ not found in the original string, set the counter to zero\n                counter\
    \ = 0;\n                break;\n            }\n        }\n        // If the counter\
    \ has been initialized, check if it is a substring\n        if (counter > 0) {\n\
    \            // If the counter is more than zero, check if it is the same size\
    \ as the original string\n            if (counter == string_size) {\n        \
    \        // If it is equal size, it can be considered a substring\n          \
    \      return 1;\n            }\n        }\n    }\n    // If the counter has not\
    \ been initialized, it cannot be considered a substring\n    return 0;", "   \
    \ assert(string.length()>=substring.length());\n    long count = 0;\n    long\
    \ start = 0;\n    long end = string.length();\n    while (start < end) {\n   \
    \     long mid = start + (end - start) / 2;\n        bool found = string.find(substring,\
    \ mid) != std::string::npos;\n        if (found == true) {\n            start\
    \ = mid;\n            count += 1;\n        }\n        else {\n            end\
    \ = mid;\n        }\n    }\n    return count;", "    long count = 0;\n    for\
    \ (char i = 0; i <= string.length(); i++) {\n        if (string[i] == substring[0])\n\
    \            count++;\n        if (string[i] == substring[1])\n            count++;\n\
    \        if (string[i] == substring[2])\n            count++;\n        if (string[i]\
    \ == substring[3])\n            count++;\n        if (string[i] == substring[4])\n\
    \            count++;\n        if (string[i] == substring[5])\n            count++;\n\
    \        if (string[i] == substring[6])\n            count++;\n    }\n    return\
    \ count;", "    // Complete the code here\n    long count = 0;\n    int start\
    \ = 0;\n    int end = string.length();\n    while (start < end) {\n        //\
    \ Find the start index\n        while (string[start] == substring[0]) {\n    \
    \        start++;\n        }\n        \n        // Find the end index\n      \
    \  while (string[end] == substring[substring.length() - 1]) {\n            end--;\n\
    \        }\n        \n        if (string[start] == substring[substring.length()\
    \ - 1]) {\n            count++;\n            while (string[end] == substring[0])\
    \ {\n                end--;\n            }\n        } else {\n            start++;\n\
    \            end--;\n        }\n    }\n    return count;", "  long count = 0;\n\
    \  std::string::size_type start = 0, end = 0;\n  while (end < string.length())\
    \ {\n    end = string.find(substring, start);\n    if (end != string::npos) {\n\
    \      count++;\n      start = end + 1;\n    }\n  }\n  return count;", "  int\
    \ found = 0;\n  // iterate through string and check if substring is present with\
    \ overlapping characters\n  for(int i = 0; i < string.size(); i++)\n    for(int\
    \ j = i + 1; j < string.size(); j++)\n      if(string[i] == substring[j] && string[j]\
    \ != substring[i])\n        found++;\n  return found;", "    long count = 0;\n\
    \    if (string.size() == 0) return count;\n    if (string[0] == substring[0])\
    \ {\n        for (size_t i = 1; i < substring.length(); i++) {\n            if\
    \ (string[i - 1] == substring[i] && string[i] != substring[i]) count++;\n    \
    \    }\n    }\n    return count;", "  // Create a map to store occurences of the\
    \ substring in string\n  std::map<char, int> map;\n  for (auto c : string) {\n\
    \    // If key is not found, add a new pair\n    if (map.find(c) == map.end())\n\
    \      map[c] = 1;\n    // Else, increment the counter\n    else\n      map[c]\
    \ += 1;\n  }\n  // Return the number of occurences\n  return map.count(substring);",
  "    int len = substring.length();\n    if (string.length() - substring.size() <=\
    \ len)\n        return 0;\n    long ans = 0;\n    for (int i = 0; i < string.length()\
    \ - len + 1; i++)\n        if (string.substr(i, len) == substring)\n         \
    \   ans++;\n    return ans;", "    auto i = string.find(substring);\n    if (i\
    \ == std::string::npos) return 0;\n    return i + 1;", "  int found = 0;\n  long\
    \ count = 0;\n  int pos = 0;\n  while (pos < string.size()) {\n    pos = string.find(substring,\
    \ pos);\n    if (pos == string::npos) {\n      count += found;\n      found =\
    \ 0;\n    } else {\n      found++;\n    }\n    pos++;\n  }\n  return count;",
  "    auto it = std::search( string.begin(), string.end(), substring.begin(), substring.end()\
    \ );\n    return std::distance(string.begin(), it);", "  long n = 0, count = 0;\n\
    \  int len1 = string.length();\n  int len2 = substring.length();\n  assert(len1\
    \ >= 0 && len2 >= 0);\n  for (int i = 0; i < len1; i++) {\n    if (string[i] ==\
    \ substring[0]) {\n      count += 1;\n      for (int j = 0; j < len2 - 1; j++)\
    \ {\n        if (string[i + j + 1] == substring[j + 1]) {\n          count +=\
    \ 1;\n          i += j + 2;\n        }\n      }\n      n += count;\n      count\
    \ = 0;\n    }\n  }\n  return n;", "    long count = 0;\n    long n = string.length();\n\
    \    long m = substring.length();\n    for (long i = 0; i < n; i++) {\n      \
    \  for (long j = 0; j < m; j++) {\n            if (string[i] == substring[j] &&\
    \ i != j) {\n                count++;\n            }\n        }\n    }\n    return\
    \ count;", "    long count = 0;\n    for (int i = 0; i < string.size() && i <\
    \ substring.size(); i++) {\n        if (string[i] == substring[i]) {\n       \
    \     count++;\n        }\n    }\n    return count;", "    long count = 0;\n \
    \   for (auto i = 0u; i < string.size(); i++) {\n        if (string[i] == substring[0])\
    \ {\n            count += how_many_times(string+(i+1), substring);\n        }\n\
    \        if (string[i] == substring[1]) {\n            count += how_many_times(string+(i+1),\
    \ substring);\n        }\n    }\n    return count;", "    long count = 0;\n  \
    \  int i = 0;\n    int j = 0;\n    while (i < string.length() && j < substring.length())\
    \ {\n        if (string[i] == substring[j]) {\n            count++;\n        \
    \    i++;\n            j++;\n        }\n        else if (string[i] == substring[j])\
    \ //case not overlapped but start from jth char.\n            j++;\n        else\
    \ if (string[i] > substring[j - 1]) //case not overlapped but continue in previous\
    \ substring.\n            i++;\n        else //case overlapped continue to next\
    \ character.\n            i++;\n    }\n    return count;", "    if (substring.size()\
    \ > string.length())\n        return 0;\n    int count = 0;\n    int index = -1;\n\
    \    long index_of = -1;\n    for (int i = 0; i < string.size(); i++) {\n    \
    \    index = string.find(substring, i);\n        if (index == -1)\n          \
    \  return 0;\n        else if (index != index_of) {\n            index_of = index;\n\
    \            count++;\n        }\n    }\n    return count;", "    long count =\
    \ 0;\n    string string_copy = string;\n    int len1 = string.length();\n    int\
    \ len2 = substring.length();\n    string pattern = substring;\n    int index =\
    \ 0;\n    while (true) {\n        index = string::npos;\n        string temp_string\
    \ = string;\n        pattern = substring;\n        while (string::npos != (index\
    \ = temp_string.find(pattern, index))) {\n            count++;\n            index\
    \ += pattern.length();\n        }\n        if (index == string::npos) {\n    \
    \        break;\n        }\n        index = 0;\n    }\n    string temp_sub = substring;\n\
    \    string temp_string = string;\n    int len3 = string.length();\n    while\
    \ (true) {\n        index = string::npos;\n        string temp_string = string;\n\
    \        while (true) {\n            if (string::npos != (index = temp_string.find(temp_sub,\
    \ index))) {\n                count++;\n                index += temp_sub.length();\n\
    \            } else {\n                break;\n            }\n        }\n    \
    \    if (index == string::npos) {\n            break;\n        }\n        index\
    \ = 0;\n    }\n    return count;", "    long count = 0; //0\n    int i = 0;\n\
    \    for (; i < string.length(); i++) {\n        if (string.at(i) == substring.at(i))\
    \ {\n            count++;\n        }\n        else {\n            if (count >\
    \ 0) {\n                count--;\n            }\n            if (count == 0) {\n\
    \                break;\n            }\n        }\n    }\n    return count;",
  "    long count=0,i=0;\n    for(;i<string.size();i++)\n    {\n        if(string[i]==substring[0]){\n\
    \            for(;i+1<string.length && string[i+1]==substring[i];i++)\n      \
    \      {\n            }\n            if(substring.length==i+1)\n            {\n\
    \                count++;\n            }\n        }\n    }\n    return count;",
  "    int count = 0;\n    for (int i = 0; i < string.size() && i < substring.size();\
    \ i++) {\n        if (string[i] == substring[i]) {\n            count++;\n   \
    \     }\n    }\n    return count;", "  long count = 0;\n  long length_string =\
    \ string.length();\n  long length_substring = substring.length();\n  long i =\
    \ 0;\n  long j = 0;\n  while (i < length_string) {\n    while (j < length_substring)\
    \ {\n      if (string[i] == substring[j]) {\n        j++;\n      } else {\n  \
    \      break;\n      }\n    }\n    if (j == length_substring) {\n      count++;\n\
    \      j = 0;\n    } else {\n      i++;\n      j = 0;\n    }\n  }\n  return count;",
  "\tif (string == \"\" && substring == \"\") {\n\t\treturn 0;\n\t}\n\tstring sub_temp\
    \ = substring + string; // concatenate substring and string\n\tlong count = 0;\n\
    \t// check if string contains substring\n\tfor (unsigned int i = 0; i < sub_temp.size();\
    \ ++i) {\n\t\tif (string[i - 1] == sub_temp[i]) {\n\t\t\t++i;\n\t\t\tcount++;\n\
    \t\t}\n\t}\n\t// return how many times substring is in string\n\treturn count;",
  "    // Return 0 if the string does not contain the substring.\n    if (string.find(substring)\
    \ == std::string::npos) return 0;\n\n    // Initialize result variable to 0.\n\
    \    long count = 0;\n\n    // Iterate through all the characters in string.\n\
    \    for (std::string::iterator itr = string.begin(); itr != string.end(); itr++)\
    \ {\n        // Check if current character is equal to the substring character.\n\
    \        // If it is, increase the count and jump to the next character.\n   \
    \     if (*itr == *substring) count++;\n        itr++;\n    }\n\n    // Return\
    \ count.\n    return count;", "    int count = 0;\n    std::string string_reversed\
    \ = string(string.rbegin(), string.rend());\n    std::cout << string_reversed\
    \ << std::endl;\n    for (unsigned int i = 0; i < string_reversed.size(); i++)\
    \ {\n        if (string_reversed.find(substring, i) != std::string::npos) {\n\
    \            count++;\n        }\n    }\n    return count;", "    std::sort(string.begin(),\
    \ string.end());\n    std::sort(substring.begin(), substring.end());\n\n    size_t\
    \ start_index = 0;\n    size_t end_index = string.length();\n\n    if (string.length()\
    \ == substring.length())\n        return 0;\n\n    while (start_index < end_index\
    \ && substring.find(string[start_index]) != std::string::npos) {\n        start_index++;\n\
    \    }\n\n    end_index = string.length();\n    start_index = 0;\n    while (end_index\
    \ > 0 && substring.find(string[end_index - 1]) != std::string::npos) {\n     \
    \   end_index--;\n    }\n\n    if (start_index == end_index)\n        return 0;\n\
    \n    return end_index - start_index;", "    long count = 0;\n    string temp(string.begin(),\
    \ string.end());\n    for (auto c : substring) {\n        auto found = temp.find(c);\n\
    \        while (found != string::npos) {\n            temp.replace(found, c.size(),\
    \ \"\");\n            found = temp.find(c);\n            ++count;\n        }\n\
    \    }\n    return count;", "    long count = 0;\n    // Find how many times substring\
    \ occurs in string. Start by searching for string from beginning. Stop if substring\
    \ is not found\n    for (auto i = string.begin(); i != string.end(); i = (i ==\
    \ string.end()) ? string.begin() : std::find(i, string.end(), substring)) {\n\
    \        // For each string, increment count if substring has found at some location\
    \ in string\n        if ((i + substring.size()) == string.end()) {\n         \
    \   count++;\n            // If substring is found in string, but at end of string\n\
    \        } else if (i + substring.size() >= string.end()) {\n            count\
    \ = -1;\n        }\n    }\n    return count;", "    int count = 0;\n    for (int\
    \ i = 0; i < string.size(); ++i) {\n        if (string[i] == substring[0]) {\n\
    \            for (int j = i; j < string.size(); ++j) {\n                if (string[j]\
    \ == substring[j]) {\n                    ++count;\n                    i += j\
    \ - i;\n                    break;\n                }\n            }\n       \
    \ }\n    }\n    return count;", "    long count = 0;\n    int i = 0;\n    while(i\
    \ < string.size()) {\n        if (string[i] == substring[0]) {\n            count\
    \ += substring.length();\n            i++;\n        }\n        else if (string[i]\
    \ == substring[1]) {\n            count += substring.length();\n            i++;\n\
    \        }\n        else if (string[i] == substring[2]) {\n            count +=\
    \ substring.length();\n            i++;\n        }\n        else if (string[i]\
    \ == substring[3]) {\n            count += substring.length();\n            i++;\n\
    \        }\n        else if (string[i] == substring[4]) {\n            count +=\
    \ substring.length();\n            i++;\n        }\n        else if (string[i]\
    \ == substring[5]) {\n            count += substring.length();\n            i++;\n\
    \        }\n        else if (string[i] == substring[6]) {\n            count +=\
    \ substring.length();\n            i++;\n        }\n        else if (string[i]\
    \ == substring[7]) {\n            count += substring.length();\n            i++;\n\
    \        }\n        else if (string[i] == substring[8]) {\n            count +=\
    \ substring.length();\n            i++;\n        }\n        else if (string[i]\
    \ == substring[9]) {\n            count += substring.length();\n            i++;\n\
    \        }\n        else if (string[i] == substring[10]) {\n            count\
    \ += substring.length();\n            i++;\n        }\n        else if (string[i]\
    \ == substring[11]) {\n            count += substring.length();\n            i++;\n\
    \        }\n        else if (string[i] == substring[12]) {\n            count\
    \ += substring.length();\n            i++;\n        }\n        else if (string[i]\
    \ == substring[13]) {\n            count += substring.length();\n            i++;\n\
    \        }\n        else if (string[i] == substring[14]) {\n            count\
    \ += substring.length();\n            i++;\n        }\n        else if (string[i]\
    \ == substring[15]) {\n            count += substring.length();\n            i++;\n\
    \        }\n        else if (string[i] == substring[16]) {\n            count\
    \ += substring.length();\n            i++;\n        }\n        else if (string[i]\
    \ == substring[17]) {\n            count += substring.length();\n            i++;\n\
    \        }\n        else if (string[i] == substring[18]) {\n            count\
    \ += substring.length();\n            i++;\n        }\n        else if (string[i]\
    \ == substring[19]) {\n            count += substring.length();\n            i++;\n\
    \        }\n        else if (string[i] == substring[20]) {\n            count\
    \ += substring.length();\n            i++;\n        }\n        else if (string[i]\
    \ == substring[21]) {\n            count += substring.length();\n            i++;\n\
    \        }\n        else if (string[i] == substring[22]) {\n            count\
    \ += substring.length();\n            i++;\n        }\n        else if (string[i]\
    \ == substring[23]) {\n            count += substring.length();\n            i++;\n\
    \        }\n        else if (string[i] == substring[24", "    std::string pattern\
    \ = substring;\n    long count = 0, pos;\n\n    // The pattern should be an anagram\
    \ of substring\n    assert(pattern.size() == substring.size());\n    // Find the\
    \ positions of substring\n    for (pos = 0 ; pos < string.size(); pos++) {\n \
    \       if (string.substr(pos, substring.size()) == pattern) {\n            count++;\n\
    \        }\n    }\n\n    return count;", "    long result = 0;\n    long count[26]\
    \ = {};\n    long offset = 0;\n    for (int i = 0; string[i] != '\\0'; i++) {\n\
    \        for (int j = 0; substring[j] != '\\0'; j++) {\n            if (string[i\
    \ + offset] == substring[j])\n                count[static_cast<long>(string[i\
    \ + offset])]++;\n        }\n        offset = offset + 1;\n    }\n    for (long\
    \ k = 0; k <= 26; k++)\n        result += count[k];\n    return result;", "  \
    \  long count = 0;\n    for (auto &c : string) {\n        if (c == substring[0])\
    \ {\n            for (auto &cc : substring) {\n                if (c == cc) {\n\
    \                    count += 1;\n                    break;\n               \
    \ }\n            }\n        }\n    }\n    return count;", "    long count = 0;\n\
    \    int index_1 = 0, index_2 = 0, size = string.length(), size1 = substring.length();\n\
    \    while (index_1 < size && index_2 < size1) {\n        if (string[index_1]\
    \ != substring[index_2]) {\n            index_1++;\n            index_2++;\n \
    \           if (index_1 == size || index_2 == size1) {\n                count++;\n\
    \            }\n        } else {\n            index_1++;\n            index_2++;\n\
    \        }\n    }\n    return count;", "    // return how many times a substring\
    \ can be found in the original string. Count overlaping cases.\n    long cnt =\
    \ 0;\n    long posA = string.find(substring);\n    if (posA != string::npos)\n\
    \        cnt++;\n    long posB = string.find(substring, posA);\n    if (posB !=\
    \ string::npos)\n        cnt += posB - posA;\n    return cnt;", "\tint n = 0;\n\
    \tstd::string temp;\n\tfor (int i = 0; i < string.size(); i++) {\n\t\tif (string[i]\
    \ == substring[0]) {\n\t\t\tfor (int j = 0; j < substring.length(); j++) {\n\t\
    \t\t\tif (string[i + j] != substring[j]) break;\n\t\t\t}\n\t\t\tif (j == substring.length())\
    \ {\n\t\t\t\tn++;\n\t\t\t} else {\n\t\t\t\ttemp = temp + string[i];\n\t\t\t\t\
    for (int j = i; j < string.size(); j++) {\n\t\t\t\t\tif (string[j] == substring[0])\
    \ {\n\t\t\t\t\t\tfor (int k = i; k < string.size(); k++) {\n\t\t\t\t\t\t\ttemp\
    \ += string[k];\n\t\t\t\t\t\t\tif (string[k] == substring[j]) n++;\n\t\t\t\t\t\
    \t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn n;", "  int n = string.find(substring);\n\
    \  if (n == std::string::npos)\n    return 0;\n  int count = 0;\n  for (size_t\
    \ i = 0; i < string.size(); ++i) {\n    if (n == i) {\n      count++;\n      continue;\n\
    \    }\n    if (string[i] == substring[0] && string[i + 1] == substring[1]) {\n\
    \      count += 2;\n      i += 2;\n    }\n  }\n  return count;", "    long count\
    \ = 0;\n    for(std::size_t i = 0; i < string.size(); i++) {\n        if (string[i]\
    \ == substring[0]) {\n            ++count;\n        }\n    }\n    for(std::size_t\
    \ i = 0; i < substring.size(); i++) {\n        if (string[string.size() - substring.size()\
    \ + i] == substring[i]) {\n            ++count;\n        }\n    }\n    return\
    \ count;", "    if (substring.empty()) return 0;\n    int count = 0;\n    int\
    \ len = string.size();\n    int len2 = substring.size();\n    for (int i = 0;\
    \ i < len; i++) {\n        size_t j;\n        for (j = 0; j < len2; j++) {\n \
    \           if (string[i] == substring[j]) {\n                count++;\n     \
    \           if (len2 - j >= 2) count++;\n                break;\n            }\n\
    \        }\n        if (j == len2) break;\n    }\n    return count;", "\tint i\
    \ = 0, j = 0, k = 0;\n\tint count = 0;\n\tfor (; i < string.size(); i++) {\n\t\
    \tif (string[i] == substring[i]) {\n\t\t\tj++;\n\t\t}\n\t\telse if (string[i]\
    \ > substring[i]) {\n\t\t\tk++;\n\t\t}\n\t\telse if (string[i] < substring[i])\
    \ {\n\t\t\tj++;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;",
  "  long answer = 0;\n  string temp_string;\n  for (int i = 0; i < string.size();\
    \ i++) {\n    if (string[i] == substring[0]) {\n      for (int j = 0; j < substring.size();\
    \ j++) {\n        if (string[i + j + 1] == substring[j]) {\n          temp_string\
    \ = temp_string + string[i];\n          answer = answer + 1;\n        }\n    \
    \  }\n    }\n  }\n  return answer;", "\tint n = string.length() - substring.length();\n\
    \tif (n == 0)\n\t\treturn 0;\n\tstd::map<std::string, int> m;\n\tfor (int i =\
    \ 0; i < n; i++)\n\t\tm[(substring + string.substr(i, n))] += 1;\n\treturn m.size();",
  "  long count = 0;\n  if (string == substring) {\n    return 1;\n  }\n  string.erase(string.find_first_not_of(substring),\
    \ substring.length());\n  while (string.find(substring) != string::npos) {\n \
    \   ++count;\n    string.erase(string.find(substring), substring.length());\n\
    \  }\n  return count;", "\tlong count = 0;\n\t// Iterate over original string.\n\
    \tfor (int i = 0; i < string.length(); i++) {\n\t\t// Check if the character at\
    \ current index is equal to the given substring.\n\t\t// If it is equal, then\
    \ increment the counter.\n\t\tif (string[i] == substring[0]) {\n\t\t\tif (string.substr(i)\
    \ == substring) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;", " \
    \   // count overlaping cases\n    size_t count = std::count(string.begin(), string.end(),\
    \ substring.begin());\n    // count non-overlaping cases\n    for (size_t i =\
    \ 0; i < substring.length(); i++) {\n        count = std::count_if(string.begin(),\
    \ string.end(),\n            [&substring](int c) \n            {\n           \
    \     return c == 'a' || c == 'A' || c == 'e' || c == 'E' || c == 'i' || c ==\
    \ 'I' || c == 'o' || c == 'O' || c == 'u' || c == 'U' || c == substring[i];\n\
    \            });\n    }\n    return count;", "    long count = 0;\n    for (auto\
    \ &i : string) {\n        if (i == substring[0]) {\n            for (auto &j :\
    \ substring) {\n                if (j == i) {\n                    count++;\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    return count;"]
stop_tokens:
- "\n}"
