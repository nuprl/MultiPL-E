name: HumanEval_21_rescale_to_unit
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given vector of numbers (of\
  \ at least two elements), apply a linear transform to that vector,\n// such that\
  \ the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit((std::vector<float>({(float)1.0,\
  \ (float)2.0, (float)3.0, (float)4.0, (float)5.0})))\n// (std::vector<float>({(float)0.0,\
  \ (float)0.25, (float)0.5, (float)0.75, (float)1.0}))\nstd::vector<float> rescale_to_unit(std::vector<float>\
  \ numbers) {\n"
tests: "}\nint main() {\n    auto candidate = rescale_to_unit;\n    assert(candidate((std::vector<float>({(float)2.0,\
  \ (float)49.9}))) == (std::vector<float>({(float)0.0, (float)1.0})));\n    assert(candidate((std::vector<float>({(float)100.0,\
  \ (float)49.9}))) == (std::vector<float>({(float)1.0, (float)0.0})));\n    assert(candidate((std::vector<float>({(float)1.0,\
  \ (float)2.0, (float)3.0, (float)4.0, (float)5.0}))) == (std::vector<float>({(float)0.0,\
  \ (float)0.25, (float)0.5, (float)0.75, (float)1.0})));\n    assert(candidate((std::vector<float>({(float)2.0,\
  \ (float)1.0, (float)5.0, (float)3.0, (float)4.0}))) == (std::vector<float>({(float)0.25,\
  \ (float)0.0, (float)1.0, (float)0.5, (float)0.75})));\n    assert(candidate((std::vector<float>({(float)12.0,\
  \ (float)11.0, (float)15.0, (float)13.0, (float)14.0}))) == (std::vector<float>({(float)0.25,\
  \ (float)0.0, (float)1.0, (float)0.5, (float)0.75})));\n}\n"
completions: ["    // Find the min and max of the numbers\n    float min_number =\
    \ *std::min_element(numbers.begin(), numbers.end());\n    float max_number = *std::max_element(numbers.begin(),\
    \ numbers.end());\n\n    // If the min and max are the same, just return the numbers\n\
    \    if (min_number == max_number) {\n        return numbers;\n    }\n\n    //\
    \ If the min and max are different, rescale the numbers to bring them to the range\n\
    \    // [min_number, max_number]\n    std::vector<float> rescaled_numbers;\n \
    \   rescaled_numbers.reserve(numbers.size());\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        rescaled_numbers.push_back((numbers[i] - min_number) / (max_number\
    \ - min_number));\n    }\n    return rescaled_numbers;", "    assert(numbers.size()\
    \ >= 2);\n    std::vector<float> transformed_numbers(numbers.size());\n    float\
    \ max_number = std::numeric_limits<float>::min();\n    float min_number = std::numeric_limits<float>::max();\n\
    \    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (numbers[i] < min_number)\n\
    \            min_number = numbers[i];\n        if (numbers[i] > max_number)\n\
    \            max_number = numbers[i];\n    }\n    for (size_t i = 0; i < numbers.size();\
    \ ++i) {\n        if (numbers[i] == 0.0 && numbers[i+1] == 1.0)\n            continue;\n\
    \        transformed_numbers[i] = ((numbers[i] - min_number) / (max_number - min_number))\
    \ * (1.0 + 1.0/(1.0 + i));\n    }\n    return transformed_numbers;", "    if (numbers.empty())\
    \ return {0.0f};\n    assert(numbers.size() >= 2);\n    auto unit_range = std::equal_range(numbers.begin(),\
    \ numbers.end(), numbers[0]);\n    const auto midpoint_iter = std::next(unit_range.first,\
    \ numbers.end() / 2);\n    std::iter_swap(unit_range.first, midpoint_iter);\n\
    \    const auto inv_range = std::equal_range(midpoint_iter + 1, unit_range.second,\
    \ numbers[0]);\n    std::vector<float> rescaled;\n    rescaled.reserve(numbers.size());\n\
    \    for (auto iter = midpoint_iter + 1; iter != unit_range.second; ++iter) {\n\
    \        rescaled.push_back((*iter - numbers[0]) / (*inv_range.first - numbers[0]));\n\
    \    }\n    return rescaled;", "  // Find smallest and largest number\n  float\
    \ min_value = numbers[0];\n  float max_value = numbers[0];\n  for (size_t i =\
    \ 1; i < numbers.size(); ++i) {\n    min_value = std::min(numbers[i], min_value);\n\
    \    max_value = std::max(numbers[i], max_value);\n  }\n\n  // Scale numbers so\
    \ that minimum becomes a 0 and maximum becomes a 1\n  float scale = max_value\
    \ - min_value;\n  std::vector<float> scaled;\n  for (float number : numbers) {\n\
    \    scaled.push_back(number - min_value);\n    scaled.push_back(number * scale);\n\
    \  }\n  return scaled;", "  // assert (numbers.size() >= 2);\n  assert(numbers.size()\
    \ >= 2);\n  std::sort(numbers.begin(), numbers.end()); //Sort the array\n  std::sort(numbers.begin()\
    \ + 1, numbers.end(), [](float a, float b) { return (a < b); });\n  numbers[1]\
    \ = numbers[1] - numbers[0];\n  numbers[0] = 0;\n  numbers[numbers.size()-1] =\
    \ 1;\n  return numbers;", "    // Sort the input numbers\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    // Compute the difference between the min and the max of\
    \ the input numbers\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    //\
    \ Get the absolute value of the difference between the min and the max\n    float\
    \ abs_dif = std::abs(max_val - min_val);\n    // Get the unit vector with components:\n\
    \    // - the first component (component = 1/abs_dif)\n    // - the second component\
    \ (component = (abs_dif-1)/abs_dif)\n    // - the third component (component =\
    \ (abs_dif-2)/abs_dif)\n    float unit_vector[3] = { 1.0f / abs_dif, ((abs_dif\
    \ - 1.0f) / abs_dif), ((abs_dif - 2.0f) / abs_dif) };\n    // Rescale the numbers\n\
    \    std::vector<float> rescaled(numbers.size());\n    for (size_t i = 0; i <\
    \ numbers.size(); ++i) {\n        rescaled[i] = numbers[i] * unit_vector[0];\n\
    \        if (i < numbers.size() - 1) {\n            rescaled[i] += numbers[i +\
    \ 1] * unit_vector[1];\n            if (i < numbers.size() - 2) {\n          \
    \      rescaled[i] += numbers[i + 2] * unit_vector[2];\n            }\n      \
    \  }\n    }\n    return rescaled;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ result(numbers.size());\n    for (int i = 0; i < numbers.size(); i++) {\n  \
    \      float min_val = numbers[i]; \n        int min_idx = 0;\n        for (int\
    \ j = 0; j < numbers.size(); j++) {\n            if (numbers[j] < min_val) {\n\
    \                min_idx = j;\n                min_val = numbers[j];\n       \
    \     }\n        }\n        result[i] = (numbers[min_idx] - min_val) / (numbers.size()\
    \ - 1);\n    }\n    return result;", "\tassert(numbers.size() > 1);\n\tassert(numbers.front()*numbers.back()\
    \ < 1.0); // Ensure numbers don't get out of bounds\n\tnumbers.front() = numbers.front()\
    \ / numbers.back();\n\tfor (auto it = numbers.rbegin() + 1; it != numbers.rend();\
    \ ++it)\n\t\t*it *= numbers.back();\n\tnumbers.front() = std::min(numbers.front(),\
    \ 1.0f);\n\tnumbers.back() = std::max(numbers.back(), 0.0f);\n\treturn numbers;",
  "    std::vector<float> new_vector;\n    float smallest_element = std::numeric_limits<float>::max();\n\
    \    float largest_element = std::numeric_limits<float>::min();\n    for (float\
    \ element : numbers) {\n        if (element > largest_element) {\n           \
    \ largest_element = element;\n        }\n        if (element < smallest_element)\
    \ {\n            smallest_element = element;\n        }\n    }\n    for (float\
    \ element : numbers) {\n        new_vector.push_back(element / (largest_element\
    \ - smallest_element));\n    }\n    return new_vector;", "    int n = (int) numbers.size();\n\
    \    std::vector<float> output(n);\n    for (int i = 0; i < n; ++i) {\n      \
    \  if (numbers[i] < 0.0) numbers[i] = 0.0;\n        if (numbers[i] > 1.0) numbers[i]\
    \ = 1.0;\n        if (numbers[i] < 1.0) numbers[i] = (float) (float) numbers[i];\n\
    \        if (numbers[i] >= 1.0) numbers[i] = (float) (float) numbers[i];\n   \
    \ }\n    std::transform(numbers.begin(), numbers.end(), numbers.begin(), [&](float\
    \ x) { return (x - min) / (max - min); });\n    return output;", "    std::vector<float>\
    \ new_number(numbers.size());\n    // We start by scaling numbers so that their\
    \ sum is 1.0 (that is, the sum of squared is 1.0)\n    float scale = ((float)numbers.back());\n\
    \    for (size_t i = 0; i < new_number.size(); i++) {\n        new_number[i] =\
    \ (numbers[i] / scale);\n        scale *= numbers[i];\n    }\n    // Now we divide\
    \ each number by its sum so that the sum of all numbers is 1.0.\n    for (size_t\
    \ i = 0; i < new_number.size(); i++) {\n        new_number[i] /= scale;\n    }\n\
    \    return new_number;", "    // Assert that we have at least two elements\n\
    \    assert(numbers.size() >= 2);\n    std::vector<float> temp(numbers);\n   \
    \ double min = std::numeric_limits<float>::max();\n    double max = std::numeric_limits<float>::min();\n\
    \    for (size_t i = 0; i < numbers.size(); ++i) {\n        min = std::min(min,\
    \ numbers[i]);\n        max = std::max(max, numbers[i]);\n    }\n    double range_length\
    \ = max - min;\n    double scaling_factor = range_length / numbers.size();\n \
    \   for (size_t i = 0; i < numbers.size(); ++i) {\n        temp[i] = numbers[i]\
    \ - min;\n        temp[i] = temp[i] * scaling_factor;\n    }\n    return temp;",
  "    assert(numbers.size() > 1);\n    std::vector<float> rescaled_numbers;\n   \
    \ rescaled_numbers.reserve(numbers.size());\n    float min_val = numbers[0];\n\
    \    float max_val = numbers[0];\n    for (auto it = numbers.begin() + 1; it !=\
    \ numbers.end(); ++it) {\n        float val = *it;\n        min_val = std::min(min_val,\
    \ val);\n        max_val = std::max(max_val, val);\n        rescaled_numbers.push_back(val\
    \ - (val - min_val) / (max_val - min_val) * (max_val - min_val));\n    }\n   \
    \ return rescaled_numbers;", "    std::vector<float> out(numbers.begin(), numbers.end());\n\
    \    // find the min\n    float min = (float)out.front();\n    // find the max\n\
    \    float max = (float)out.back();\n    // loop through each number\n    for\
    \ (size_t i = 0; i < out.size(); i++) {\n        // scale the number from 0 to\
    \ 1 using the min and max\n        out[i] = ((float)out[i] - (float)min) / (float)((float)max\
    \ - (float)min);\n    }\n    return out;", "    std::vector<float> rescaled_numbers;\n\
    \    // If numbers is empty, return rescaled_numbers and do nothing\n    if (numbers.empty())\
    \ {\n        return rescaled_numbers;\n    }\n\n    double sum_of_elements = std::accumulate(numbers.begin(),\
    \ numbers.end(), 0);\n\n    // Find max and min values of numbers\n    double\
    \ max_value = numbers.front();\n    double min_value = numbers.back();\n    for\
    \ (double elem : numbers) {\n        if (elem > max_value) {\n            max_value\
    \ = elem;\n        }\n\n        if (elem < min_value) {\n            min_value\
    \ = elem;\n        }\n    }\n\n    // The scaling factor will be (max_value -\
    \ min_value) / (sum_of_elements - 1)\n    double scaling_factor = max_value -\
    \ min_value;\n    scaling_factor = scaling_factor / (sum_of_elements - 1);\n\n\
    \    // Apply scaling factor\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (double elem : numbers) {\n        rescaled_numbers.push_back((scaling_factor\
    \ * elem) + min_value);\n    }\n\n    return rescaled_numbers;", "    double min\
    \ = numbers[0];\n    double max = numbers[0];\n    for (size_t i = 1; i < numbers.size();\
    \ i++) {\n        if (numbers[i] < min)\n            min = numbers[i];\n     \
    \   if (numbers[i] > max)\n            max = numbers[i];\n    }\n    double diff\
    \ = (max - min) / 2.0;\n    for (size_t i = 0; i < numbers.size(); i++) {\n  \
    \      if (numbers[i] == min)\n            numbers[i] = (double)0.0\n        else\
    \ if (numbers[i] == max)\n            numbers[i] = (double)1.0;\n        else\
    \ {\n            double new_val = numbers[i] - min;\n            numbers[i] =\
    \ new_val / diff;\n        }\n    }\n    return numbers;", "    std::vector<float>\
    \ unit(numbers.begin(), numbers.end());\n    std::vector<float> result = {0.0};\n\
    \    int count = 0;\n    for(auto i = numbers.begin(); i != numbers.end(); i++)\
    \ {\n        float number = *i;\n        if(number < 1) {\n            result.push_back((1.0f\
    \ - number) / 2.0f);\n        } else {\n            result.push_back(number /\
    \ 2.0f);\n        }\n    }\n    std::nth_element(unit.begin(), unit.begin() +\
    \ count, unit.end());\n    unit.erase(unit.begin(), unit.begin() + count);\n \
    \   return std::move(result);", "    if (numbers.empty()) return numbers;\n  \
    \  numbers.sort();\n    float min_number = numbers[0];\n    float max_number =\
    \ numbers[0];\n    for (int i = 0; i < numbers.size(); i++) {\n        if (numbers[i]\
    \ > max_number) max_number = numbers[i];\n        if (numbers[i] < min_number)\
    \ min_number = numbers[i];\n    }\n    std::vector<float> rescaled;\n    rescaled.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        rescaled.push_back(float(number-min_number)/(max_number-min_number));\n\
    \    }\n    return rescaled;", "  int num_numbers = numbers.size();\n  if (num_numbers\
    \ == 0) {\n    return numbers;\n  }\n  std::vector<float> normalized_number(num_numbers,\
    \ 0.0);\n  for (int i = 0; i < num_numbers; i++) {\n    normalized_number[i] =\
    \ std::min(std::max(numbers[i], 0.0), 1.0);\n  }\n  return normalized_number;",
  "    assert(numbers.size() > 1);\n    // Sort the numbers and find the smallest\
    \ and largest values\n    std::vector<float> sorted_numbers = std::sort(numbers.begin(),\
    \ numbers.end());\n    float min_value = sorted_numbers[0];\n    float max_value\
    \ = sorted_numbers[0];\n    for (float number : numbers) {\n        min_value\
    \ = std::min(min_value, number);\n        max_value = std::max(max_value, number);\n\
    \    }\n    // Now scale all the numbers to be between 0 and 1\n    for (float\
    \ number : numbers) {\n        number -= min_value;\n        number /= (max_value\
    \ - min_value);\n    }\n    return numbers;", "  assert(numbers.size() > 1);\n\
    \  // Find the min, max, and sum of the incoming numbers\n  float max_element\
    \ = std::numeric_limits<float>::max();\n  float min_element = std::numeric_limits<float>::min();\n\
    \  float sum = std::numeric_limits<float>::max();\n  for (float element : numbers)\n\
    \    sum += element;\n  for (float element : numbers)\n    min_element = std::min(min_element,\
    \ element);\n  for (float element : numbers)\n    max_element = std::max(max_element,\
    \ element);\n\n  // Find the new min/max based on the new sum and old min/max\n\
    \  float new_min = sum * (min_element / sum);\n  float new_max = sum * (max_element\
    \ / sum);\n  // Construct the new vector with those values\n  std::vector<float>\
    \ new;\n  new.reserve(numbers.size());\n  for (float element : numbers)\n    new.push_back((element\
    \ - new_min) / (new_max - new_min));\n  return new;", "    assert(numbers.size()\
    \ > 1);\n    // find min and max elements\n    float min = std::numeric_limits<float>::min();\n\
    \    float max = std::numeric_limits<float>::max();\n    for (float n : numbers)\
    \ {\n        min = std::min(min, n);\n        max = std::max(max, n);\n    }\n\
    \    float range = (max - min) / (numbers.size() - 1);\n    for (float n : numbers)\
    \ {\n        n -= min;\n        n *= range;\n    }\n    // scale the numbers to\
    \ range [0, 1]\n    float range2 = 1.0;\n    float range1 = 0.0;\n    for (float\
    \ n : numbers) {\n        range1 = std::min(range1, n);\n        range2 = std::max(range2,\
    \ n);\n    }\n    range1 = range1 / range2;\n    range2 = range2 / range1;\n \
    \   // recalculate the min\n    float range_diff = (range2 - range1);\n    min\
    \ = range1 - (range_diff * numbers.front());\n    // recalculate the max\n   \
    \ float range_diff2 = range_diff;\n    max = range2 - (range_diff2 * numbers.back());\n\
    \    // return the numbers\n    std::vector<float> out;\n    out.push_back(range1);\n\
    \    out.push_back(min);\n    out.push_back(max);\n    out.push_back(range2);\n\
    \    out.push_back(max);\n    return out;", "    assert(numbers.size() > 1);\n\
    \    float min = numbers[0];\n    float max = numbers[0];\n    for (auto n : numbers)\
    \ {\n        if (n < min) min = n;\n        if (n > max) max = n;\n    }\n   \
    \ std::vector<float> rescaled;\n    rescaled.reserve(numbers.size());\n    for\
    \ (auto n : numbers) {\n        rescaled.push_back(n - (float)(max - min) / (float)((float)n\
    \ - min));\n    }\n    return rescaled;", "  assert(numbers.size() > 1);\n  float\
    \ smallest_number = numbers[0];\n  float largest_number = numbers[0];\n  for (auto\
    \ number : numbers) {\n    smallest_number = std::min(smallest_number, number);\n\
    \    largest_number = std::max(largest_number, number);\n  }\n\n  std::vector<float>\
    \ transformed_numbers;\n  for (auto number : numbers) {\n    transformed_numbers.push_back(std::max(smallest_number,\
    \ number) / std::min(largest_number, number));\n  }\n\n  return transformed_numbers;",
  "  assert(numbers.size() > 1);\n  float min = std::min(numbers.begin(), numbers.end());\
    \ // smallest number\n  float max = std::max(numbers.begin(), numbers.end());\
    \ // largest number\n  float scale = max - min; // rescale by max min\n  for (auto&\
    \ num : numbers) num = (num - min) / scale;\n  return numbers;", "  // assert\
    \ two or more elements are in numbers (to avoid doing unnecessary copying\n  //\
    \ and memory reallocations)\n  assert(numbers.size() > 1);\n  // assert that each\
    \ element is a float, not a double (to avoid doing unnecessary copying\n  // and\
    \ memory reallocations)\n  assert(std::all_of(numbers.begin(), numbers.end(),\
    \ [](float n) {\n    return std::is_floating_point<float>::value && std::is_same<float,\
    \ float>::value;\n  }));\n\n  // Find the minimum and maximum values in the vector\
    \ (this is done in O(n) time)\n  // and store them in a tuple\n  auto min_max_elements\
    \ = std::minmax_element(numbers.begin(), numbers.end());\n\n  // Find the difference\
    \ between the minimum and maximum values and divide it by\n  // its magnitude\
    \ (this is done in O(1) time)\n  auto min_max_differences = std::make_pair(\n\
    \      min_max_elements.first - numbers.begin(),\n      min_max_elements.second\
    \ - numbers.end());\n  auto min_max_differences_magnitude = std::sqrt(min_max_differences.first\
    \ * min_max_differences.first);\n\n  // Multiply the vector by the reciprocal\
    \ of the magnitude of the difference\n  numbers = numbers * min_max_differences_magnitude\
    \ / min_max_differences.second;\n\n  // Multiply each element by the reciprocal\
    \ of the magnitude of the difference\n  for (size_t i = 0; i < numbers.size();\
    \ i++) {\n    numbers[i] *= min_max_differences_magnitude / min_max_differences.second;\n\
    \  }\n\n  // Return the resulting vector\n  return numbers;", "    std::vector<float>\
    \ unit_numbers;\n    for (auto i = 0; i < numbers.size(); i++) {\n        unit_numbers.push_back((numbers[i]\
    \ - numbers.at(i - 1)) / numbers.at(i - 1));\n    }\n    return unit_numbers;",
  "    assert(numbers.size() > 1);\n    float max_num = *std::max_element(numbers.begin(),\
    \ numbers.end()); // find the largest number\n    float min_num = *std::min_element(numbers.begin(),\
    \ numbers.end()); // find the smallest number\n    float range = max_num - min_num;\
    \ // the range of the numbers\n    float inv_range = 1.0f / range; // inverse\
    \ of the range\n    // Now we can iterate over the numbers, find the smallest\
    \ and largest, \n    // rescale them and concatenate the result into the vector\n\
    \    std::vector<float> result;\n    for (float num : numbers) {\n        float\
    \ new_num = (num - min_num) * inv_range;\n        result.push_back(new_num);\n\
    \    }\n    return result;", "    if (numbers.size() < 2) {\n        std::cerr\
    \ << \"rescale_to_unit(): Invalid argument, vector must have at least 2 elements.\"\
    \ << std::endl;\n        std::exit(EXIT_FAILURE);\n    }\n    // Compute the mean\
    \ of the vector\n    double mean = numbers[0];\n    for (size_t i = 1; i < numbers.size();\
    \ ++i) {\n        mean += numbers[i];\n    }\n    // Compute the standard deviation\
    \ of the vector\n    double sd = 0.0;\n    for (size_t i = 0; i < numbers.size();\
    \ ++i) {\n        sd += std::pow(numbers[i] - mean, 2);\n    }\n    sd = sqrt(sd\
    \ / numbers.size());\n    // Compute rescaled vector\n    std::vector<float> rescaled;\n\
    \    for (size_t i = 0; i < numbers.size(); ++i) {\n        rescaled.push_back(numbers[i]\
    \ / sd);\n    }\n    // If the vector has only one number, we make it a vector\
    \ of one number\n    if (numbers.size() == 1) {\n        std::vector<float> one_vector;\n\
    \        one_vector.push_back(numbers[0]);\n        return one_vector;\n    }\n\
    \    return rescaled;", "    // Find minimum and maximum values\n    float min_value\
    \ = std::numeric_limits<float>::max();\n    float max_value = std::numeric_limits<float>::min();\n\
    \    for (auto number : numbers) {\n        if (number < min_value) {\n      \
    \      min_value = number;\n        }\n        if (number > max_value) {\n   \
    \         max_value = number;\n        }\n    }\n\n    // Find the range that\
    \ would give us [0, 1] range\n    float range_1 = max_value - min_value;\n   \
    \ float range_2 = 1.0f / range_1;\n\n    // Convert the numbers to unit interval\n\
    \    std::vector<float> unit;\n    for (auto number : numbers) {\n        unit.push_back((number\
    \ - min_value) * range_2);\n    }\n\n    return unit;", "    size_t len = numbers.size();\n\
    \    std::vector<float> res(len);\n    if (len == 0)\n        return res;\n  \
    \  if (len == 1) {\n        res[0] = numbers[0];\n        return res;\n    }\n\
    \n    float min = numbers[0];\n    float max = numbers[0];\n\n    for (size_t\
    \ i = 1; i < len; i++) {\n        min = std::min(min, numbers[i]);\n        max\
    \ = std::max(max, numbers[i]);\n    }\n\n    for (size_t i = 0; i < len; i++)\
    \ {\n        res[i] = numbers[i] - min / (max - min);\n    }\n\n    return res;",
  "    assert(numbers.size()>1);\n    auto min_value = numbers[0];\n    auto max_value\
    \ = numbers[0];\n    for (auto &n:numbers) {\n        if (n<min_value) min_value\
    \ = n;\n        if (n>max_value) max_value = n;\n    }\n    \n    auto min_unit\
    \ = min_value;\n    auto max_unit = max_value;\n    int interval = std::ceil((max_unit\
    \ - min_unit)/10.0);\n    int unit = min_unit;\n    for (int i=0;i<numbers.size();\
    \ i++) {\n        auto number = numbers[i];\n        if (number<min_unit) number\
    \ = min_unit;\n        if (number>max_unit) number = max_unit;\n        if (number\
    \ > max_unit) number = max_unit;\n        if (number < min_unit) number = min_unit;\n\
    \        if (number%10==0) number/=10;\n        while (number%interval != 0) {\n\
    \            interval++;\n            unit = min_unit + interval;\n        }\n\
    \        numbers[i] = number;\n    }\n    return numbers;", "    // sort vector\
    \ as smallest to largest\n    std::sort(numbers.begin(), numbers.end());\n\n \
    \   // compute new length\n    float length = numbers[numbers.size() - 1];\n\n\
    \    // compute new scale\n    float scale = 1 / length;\n\n    // apply scale\
    \ to numbers\n    for (auto& num : numbers) {\n        num *= scale;\n    }\n\n\
    \    return numbers;", "  assert(numbers.size() >= 2);\n  float max_value = numbers[0];\n\
    \  float min_value = numbers[0];\n  for (const auto& el : numbers) {\n    max_value\
    \ = std::max(max_value, el);\n    min_value = std::min(min_value, el);\n  }\n\
    \  std::vector<float> result;\n  float range = max_value - min_value;\n  float\
    \ range_divided_by_2 = range / 2.0f;\n  for (size_t i = 0; i < numbers.size();\
    \ i++) {\n    float el = numbers[i];\n    float scaled = (el - min_value) / range_divided_by_2;\n\
    \    result.push_back(scaled / range * 2.0f);\n  }\n  return result;", "    std::vector<float>\
    \ result(numbers.size(), 0);\n    float min = std::numeric_limits<float>::min();\n\
    \    float max = std::numeric_limits<float>::max();\n\n    for (auto number :\
    \ numbers) {\n        auto number_scaled = number / max - min;\n        result[0]\
    \ += number_scaled;\n        result[1] -= number_scaled;\n        result[2] -=\
    \ number_scaled;\n        result[3] += number_scaled;\n        result[4] -= number_scaled;\n\
    \    }\n    return result;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ res(numbers.begin(), numbers.end());\n    int index = 0;\n    float largest_value\
    \ = res[0];\n    float smallest_value = res[0];\n    while (index < res.size())\
    \ {\n        float current_value = res[index];\n        if (current_value > largest_value)\
    \ {\n            largest_value = current_value;\n        } else if (current_value\
    \ < smallest_value) {\n            smallest_value = current_value;\n        }\n\
    \        index++;\n    }\n    // apply linear transformation\n    float range_percentage\
    \ = largest_value - smallest_value;\n    res[0] = (largest_value - smallest_value)\
    \ / range_percentage;\n    res[res.size() - 1] = range_percentage;\n    return\
    \ res;", "    // Write your code here\n    // Do not use assert since we will\
    \ be testing the correctness of the solution.\n    assert(numbers.size() >= 2);\n\
    \    std::vector<float> transformed;\n    for (size_t i = 0; i < numbers.size();\
    \ ++i) {\n        float max_value = numbers[i];\n        float min_value = numbers[0];\n\
    \        for (size_t j = 0; j < numbers.size(); ++j) {\n            if (max_value\
    \ < numbers[j]) {\n                max_value = numbers[j];\n            }\n  \
    \          if (min_value > numbers[j]) {\n                min_value = numbers[j];\n\
    \            }\n        }\n        float range = (max_value - min_value) / (numbers.size()\
    \ - 1);\n        transformed.push_back((numbers[i] - min_value) / range);\n  \
    \  }\n    return transformed;", "    int n = numbers.size();\n    assert(n >=\
    \ 2);\n    std::vector<float> rescaled(n - 1);\n    rescaled[0] = numbers[0];\n\
    \    float max_val = numbers[0];\n    for (int i = 1; i < n; i++) {\n        rescaled[i]\
    \ = numbers[i] / max_val;\n        max_val = std::max(max_val, numbers[i]);\n\
    \    }\n    return rescaled;", "\t// If numbers is empty, return vector of zeros\n\
    \tif (numbers.empty())\n\t\treturn std::vector<float>();\n\n\t// If no elements\
    \ were greater than 1, then return vector of zeros\n\tif (numbers.front() > 1.0)\n\
    \t\treturn std::vector<float>();\n\n\t// Otherwise apply the linear transform\
    \ to each number in the input vector\n\tstd::vector<float> returnVector(numbers.begin(),\
    \ numbers.end());\n\n\tstd::transform(numbers.begin(), numbers.end(), returnVector.begin(),\n\
    \t\t[](float x) { return (x > 1.0) ? 1.0 : ((x < 0.0) ? 0.0 : x); });\n\n\treturn\
    \ returnVector;", "    assert(numbers.size() >= 2);\n    auto smallest_number\
    \ = numbers.front();\n    auto largest_number = numbers.back();\n    auto normalized_numbers\
    \ = numbers.begin() + 1; //shift the vector by one position\n    for (size_t i\
    \ = 0; i < numbers.size(); ++i) {\n        // Multiply element by the difference\
    \ between the max and min\n        normalized_numbers[i] = ((numbers[i] - smallest_number)\
    \ / (largest_number - smallest_number));\n    }\n    return normalized_numbers;",
  "    // Sort the numbers in ascending order\n    std::sort(numbers.begin(), numbers.end());\n\
    \n    // If the smallest number is greater than 0, apply a linear transformation\n\
    \    // >>> rescale_to_unit((std::vector<float>({(float)1.0, (float)2.0, (float)3.0,\
    \ (float)4.0, (float)5.0})))\n    // std::vector<float>({(float)0.0, (float)0.25,\
    \ (float)0.5, (float)0.75, (float)1.0}))\n    if (numbers[0] > 0) {\n        numbers.erase(numbers.begin());\
    \ // Remove the first element, which will be 0\n        numbers.push_back(0.0);\
    \ // Add an element at the end, which will be 1\n    }\n\n    // Return the vector\
    \ with the transformed numbers\n    return numbers;", "    std::vector<float>\
    \ output{0.0f};\n    // find the largest\n    float largest = std::max<float>(numbers.begin(),\
    \ numbers.end());\n    // find the smallest\n    float smallest = std::min<float>(numbers.begin(),\
    \ numbers.end());\n    float scale = (largest - smallest) / (numbers.size() -\
    \ 1);\n    for (auto number : numbers) {\n        output.push_back(number * scale);\n\
    \    }\n    return output;", "    // Create a unit vector\n    std::vector<float>\
    \ unit(numbers.begin(), numbers.end());\n    // Find the minimum\n    float min\
    \ = *std::min_element(unit.begin(), unit.end());\n    // Subtract it from all\
    \ elements of the vector\n    for (float v : unit) {\n        v -= min;\n    }\n\
    \    // Normalize the vector\n    for (float v : unit) {\n        v *= 2.0f;\n\
    \    }\n    return unit;", "    // Find the smallest and largest numbers in the\
    \ given vector.\n    auto smallest_num = std::numeric_limits<float>::max();\n\
    \    auto largest_num = std::numeric_limits<float>::min();\n    for (auto num\
    \ : numbers) {\n        if (num < smallest_num) {\n            smallest_num =\
    \ num;\n        }\n        if (num > largest_num) {\n            largest_num =\
    \ num;\n        }\n    }\n    // Find scaling factor between smallest and largest\n\
    \    float scale = 1.0f / (largest_num - smallest_num);\n    // Rescale the vector\
    \ such that smallest number becomes 0 and largest becomes 1\n    // >>> rescale_to_unit((std::vector<float>({(float)1.0,\
    \ (float)2.0, (float)3.0, (float)4.0, (float)5.0})))\n    // (std::vector<float>({(float)0.0,\
    \ (float)0.25, (float)0.5, (float)0.75, (float)1.0}))\n    std::vector<float>\
    \ res;\n    res.reserve(numbers.size());\n    for (auto num : numbers) {\n   \
    \     res.push_back((num - smallest_num) * scale);\n    }\n    return res;", " \
    \   assert(numbers.size() > 1);\n    int i = 1;\n    for (auto number : numbers)\
    \ {\n        number *= (float)i;\n        ++i;\n    }\n    return numbers;", "\t\
    if (numbers.empty()) {\n\t\treturn {};\n\t}\n\tif (numbers.size() == 1) {\n\t\t\
    return numbers;\n\t}\n\tstd::vector<float> scaled(numbers.begin(), numbers.end());\n\
    \tstd::transform(numbers.begin(), numbers.end(), scaled.begin(), [](float x) {\
    \ return x; });\n\tfor (float i = 0; i < numbers.size(); i++) {\n\t\tif (scaled[i]\
    \ < 0.0f) {\n\t\t\tscaled[i] = 0.0f;\n\t\t}\n\t\tif (scaled[i] > 1.0f) {\n\t\t\
    \tscaled[i] = 1.0f;\n\t\t}\n\t}\n\treturn scaled;", "    std::vector<float> result;\n\
    \    double min = std::numeric_limits<float>::max();\n    double max = std::numeric_limits<float>::min();\n\
    \    for (auto number : numbers) {\n        min = std::min(min, number);\n   \
    \     max = std::max(max, number);\n    }\n\n    for (auto number : numbers) {\n\
    \        number -= min;\n        number /= (max - min);\n        result.push_back(number);\n\
    \    }\n\n    return result;", "  assert(numbers.size() >= 2);\n  numbers.resize(numbers.size()\
    \ * 1.0f / numbers.size());\n  // std::cout << numbers << std::endl;\n  for (int\
    \ i = 0; i < numbers.size(); ++i) {\n    // std::cout << numbers[i] << std::endl;\n\
    \    numbers[i] = numbers[i] * 1.0f / numbers.size();\n  }\n  // std::cout <<\
    \ numbers << std::endl;\n  return numbers;", "  int min_number = std::numeric_limits<float>::max();\n\
    \  int max_number = std::numeric_limits<float>::min();\n  for (auto &n : numbers)\
    \ {\n    min_number = std::min(min_number, n);\n    max_number = std::max(max_number,\
    \ n);\n  }\n  int size = numbers.size();\n  float range_ = (max_number - min_number);\n\
    \  float inv_range = 1.0;\n  float rescale = (range_ / size) / inv_range;\n  std::vector<float>\
    \ rescaled_numbers(size);\n  for (int i = 0; i < numbers.size(); i++) {\n    rescaled_numbers[i]\
    \ = (numbers[i] - min_number) * rescale;\n  }\n  return rescaled_numbers;", " \
    \   float total_elements = std::accumulate(numbers.begin(), numbers.end(), 0.0f);\n\
    \    if (total_elements > 1.0f) {\n        float scale = 1.0f / total_elements;\n\
    \        numbers.clear();\n        for (float &num : numbers) {\n            num\
    \ *= scale;\n        }\n        numbers.push_back(1.0);\n    }\n    return numbers;",
  "  // If the list is empty\n  if (numbers.empty())\n    return {};\n  // Store the\
    \ size of the vector\n  assert(numbers.size() > 0);\n  auto num_elements = numbers.size();\n\
    \  // Initialize the minimum number to 0\n  auto min_number = numbers[0];\n  //\
    \ Initialize the maximum number to 1\n  auto max_number = numbers[0];\n  for (auto\
    \ number : numbers)\n    min_number = std::min(min_number, number);\n  for (auto\
    \ number : numbers)\n    max_number = std::max(max_number, number);\n  // Apply\
    \ a linear transform\n  std::vector<float> transformed_numbers(num_elements);\n\
    \  for (auto index = 0; index < num_elements; ++index) {\n    transformed_numbers[index]\
    \ = (numbers[index] - min_number) / (max_number - min_number);\n  }\n  return\
    \ transformed_numbers;", "    numbers.sort();\n    std::vector<float> rescaled_numbers(numbers.begin(),\
    \ numbers.end());\n    for (int i = 0; i < rescaled_numbers.size(); i++) {\n \
    \       if (rescaled_numbers[i] != 0.0) {\n            rescaled_numbers[i] = ((rescaled_numbers[i]\
    \ - numbers[0]) / (numbers[0] - numbers[numbers.size() - 1]));\n            rescaled_numbers[rescaled_numbers.size()\
    \ - 1 - i] = ((rescaled_numbers[rescaled_numbers.size() - 1 - i] - numbers[0])\
    \ / (numbers[0] - numbers[numbers.size() - 1]));\n        }\n    }\n    return\
    \ rescaled_numbers;", "    if (numbers.empty())\n        return numbers;\n   \
    \ if (numbers.front()<numbers.back())\n        std::swap(numbers[0], numbers[numbers.size()\
    \ - 1]);\n    float smallest_number = std::min(numbers.front(), numbers.back());\n\
    \    float max_number = std::max(numbers.front(), numbers.back());\n    float\
    \ scale = max_number / smallest_number;\n    numbers.front() = smallest_number\
    \ * scale;\n    numbers.back() = max_number * scale;\n    return numbers;", " \
    \   std::vector<float> result;\n    // Make sure we have at least two elements\n\
    \    assert(numbers.size() >= 2);\n    // Compute the min and max values\n   \
    \ auto min = *std::min_element(numbers.begin(), numbers.end());\n    auto max\
    \ = *std::max_element(numbers.begin(), numbers.end());\n    // Compute the scale\n\
    \    auto scale = float(max - min);\n    // Compute the result\n    for (auto\
    \ i : numbers) {\n        result.push_back((i - min) * scale);\n    }\n    return\
    \ result;", "    numbers.resize(numbers.size());\n    float max = std::max(numbers[0],\
    \ numbers[1]);\n    float min = std::min(numbers[0], numbers[1]);\n    float diff_norm\
    \ = max - min;\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n      \
    \  numbers[i] /= diff_norm;\n    }\n    numbers[0] -= min;\n    numbers[1] +=\
    \ min;\n    return numbers;", "  // assert (numbers.size() >= 2);\n  if (numbers.empty())\n\
    \    return numbers;\n  std::sort(numbers.begin(), numbers.end());\n  std::vector<float>\
    \ result(numbers.size());\n  result[0] = (numbers[0] + numbers[1]) / 2.0;\n  result[1]\
    \ = numbers[1] - numbers[0];\n  for (unsigned int i = 2; i < numbers.size(); i++)\
    \ {\n    result[i] = (result[i - 1] + numbers[i]) / 2.0;\n  }\n  return result;",
  "  // Check if there are at least two elements\n  if (numbers.empty() || numbers.size()\
    \ < 2)\n    return numbers;\n  // Sort elements such that largest number will\
    \ be at end\n  std::sort(numbers.begin(), numbers.end());\n  // Find the smallest\
    \ and largest\n  float smallest_number = numbers[0];\n  float largest_number =\
    \ numbers[0];\n  for (unsigned int i = 1; i < numbers.size(); i++) {\n    if (numbers[i]\
    \ < smallest_number) {\n      smallest_number = numbers[i];\n    }\n    if (numbers[i]\
    \ > largest_number) {\n      largest_number = numbers[i];\n    }\n  }\n  // Calculate\
    \ scaling factor\n  float scale_factor = float(smallest_number - largest_number);\n\
    \  // Now rescale all the numbers\n  std::vector<float> rescaled_numbers;\n  rescaled_numbers.reserve(numbers.size());\n\
    \  for (unsigned int i = 0; i < numbers.size(); i++) {\n    rescaled_numbers.push_back((scale_factor\
    \ * numbers[i]) + largest_number);\n  }\n  // Done\n  return rescaled_numbers;",
  "    if (numbers.size() <= 1) {\n        return numbers;\n    }\n    auto last_number\
    \ = numbers.back();\n    std::vector<float> new_numbers;\n    new_numbers.push_back(0.0);\n\
    \    new_numbers.push_back(last_number);\n    for (const auto & number : numbers)\
    \ {\n        new_numbers.push_back(number);\n    }\n    new_numbers = std::unique(new_numbers.begin(),\
    \ new_numbers.end()); // only unique numbers\n    std::sort(new_numbers.begin(),\
    \ new_numbers.end()); // sort them\n    auto last_new_number = new_numbers[1];\n\
    \    auto first_new_number = new_numbers[0];\n    if (first_new_number >= last_new_number)\
    \ {\n        return new_numbers;\n    }\n    auto num_units = (new_numbers.size()\
    \ / 2) * last_new_number + first_new_number;\n    num_units = num_units % 1.0;\
    \ // guarantee no floating point problem\n    new_numbers[0] = num_units;\n  \
    \  for (auto i = 1; i < new_numbers.size(); ++i) {\n        new_numbers[i] = new_numbers[i\
    \ - 1] + new_numbers[i];\n    }\n    return new_numbers;", "    std::vector<float>\
    \ normalized;\n    normalized.reserve(numbers.size());\n\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end()); // smallest number in input\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end()); // largest number in input\n\n    float range = max - min;\n\
    \    float minNew = (range) / numbers.size(); // smallest number that we want\
    \ to return\n    float maxNew = (range) / numbers.size(); // largest number that\
    \ we want to return\n\n    for (auto num : numbers) {\n        normalized.push_back((num\
    \ - minNew) / range);\n    }\n\n    return normalized;", "    // assert(numbers.size()\
    \ >= 2);\n    float min = numbers.front();\n    float max = numbers.back();\n\
    \    float range = (max - min);\n    for (auto num: numbers) {\n        float\
    \ scaled = (num - min) / range;\n        numbers.push_back(scaled);\n    }\n \
    \   return numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ unit;\n    unit.push_back(numbers[0]);\n    for (int i = 1; i < numbers.size();\
    \ i++) {\n        unit.push_back(unit[i - 1] + numbers[i]);\n    }\n    return\
    \ unit;", "  // assert numbers.size() >= 2\n  auto max_value = numbers[0];\n \
    \ auto min_value = numbers[0];\n  for (auto &i : numbers) {\n    if (max_value\
    \ < i) max_value = i;\n    if (min_value > i) min_value = i;\n  }\n\n  std::vector<float>\
    \ res;\n  res.reserve(numbers.size());\n  for (auto &i : numbers) {\n    res.push_back((i\
    \ - min_value) / (max_value - min_value));\n  }\n  return res;", "    std::vector<float>\
    \ output(numbers.size());\n\n    for (size_t i = 0; i < numbers.size(); i++) {\n\
    \        output[i] = numbers[i] / numbers[0];\n    }\n\n    return output;", " \
    \   if (numbers.empty()) return {0.0f};\n    std::vector<float> result = {0.0f};\n\
    \    float min_val = numbers[0]; int min_idx = -1;\n    for (size_t i = 0; i <\
    \ numbers.size(); i++) {\n        float curr_val = numbers[i];\n        if (curr_val\
    \ < min_val) {\n            min_val = curr_val; min_idx = i;\n        }\n    }\n\
    \    if (min_idx == 0) return {0.0f};\n    min_val -= min_val;\n    result[0]\
    \ = min_val;\n    for (size_t i = 1; i < numbers.size(); i++) {\n        float\
    \ curr_val = numbers[i];\n        result[i] = result[i-1] + ((curr_val - min_val)\
    \ / (float)(i - 1));\n    }\n    return result;", "    std::for_each(numbers.begin(),\
    \ numbers.end(), [&](float number) {\n        if (number < 0) {\n            number\
    \ = -(1.0f / number);\n        }\n    });\n    numbers.erase(numbers.end() - 1);\n\
    \    return numbers;", "    std::vector<float> rescaled;\n    rescaled.reserve(numbers.size());\n\
    \    assert(numbers.size()>=2);\n    // Calculate the new scaling factor to apply\
    \ to the vector\n    // For large vectors, this can cause overflow; scale using\
    \ doubles and rescale to floats afterwards\n    const double min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    const double max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    double scale = (max - min)/(numbers.size()-1);\n    for (auto n : numbers)\
    \ {\n        rescaled.push_back(scale*n);\n    }\n    return rescaled;", "   \
    \ std::vector<float> result;\n    // Find min/max values in input vector\n   \
    \ float minVal = std::numeric_limits<float>::min();\n    float maxVal = std::numeric_limits<float>::max();\n\
    \    for(float val : numbers) {\n        if(val < minVal) {\n            minVal\
    \ = val;\n        }\n        if(val > maxVal) {\n            maxVal = val;\n \
    \       }\n    }\n    float scale = maxVal - minVal; // Scale is 0 <-> 1\n   \
    \ for(float val : numbers) {\n        result.push_back(val - minVal);\n      \
    \  result.push_back(val * scale);\n    }\n    return result;", "    std::vector<float>\
    \ rescaled;\n    assert(numbers.size() > 2);\n    float max_value = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float min_value = *std::min_element(numbers.begin(), numbers.end());\n\
    \    max_value = (max_value - min_value) + 1.0; // Rescale from [min_value, max_value]\
    \ to [0, 1]\n    rescaled.reserve(numbers.size());\n    for (float number : numbers)\
    \ {\n        rescaled.push_back((number - min_value) / max_value);\n    }\n  \
    \  return rescaled;", "\tif (numbers.empty()) {\n\t\treturn numbers;\n\t}\n\t\
    std::sort(numbers.begin(), numbers.end());\n\tif (numbers.size() > 2) {\n\t\t\
    float min = numbers[0];\n\t\tfloat max = numbers[1];\n\t\tfor (float number :\
    \ numbers) {\n\t\t\tif (number < min) {\n\t\t\t\tmin = number;\n\t\t\t}\n\t\t\t\
    if (number > max) {\n\t\t\t\tmax = number;\n\t\t\t}\n\t\t}\n\t\tif (min == max)\
    \ {\n\t\t\treturn numbers;\n\t\t}\n\t\tfor (float number : numbers) {\n\t\t\t\
    if (number <= (max - min) / 2.0) {\n\t\t\t\tnumber = 0;\n\t\t\t} else {\n\t\t\t\
    \tnumber = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn numbers;", "    numbers.reserve(numbers.size()\
    \ + 2);\n    std::transform(numbers.begin(), numbers.end(), numbers.begin(), [](float\
    \ num){\n        return static_cast<float>(num);\n    });\n    auto max = std::max_element(numbers.begin(),\
    \ numbers.end());\n    auto min = std::min_element(numbers.begin(), numbers.end());\n\
    \    std::transform(numbers.begin(), numbers.end(), numbers.begin(), [](float\
    \ num){\n        return std::min(std::max(num, min), max);\n    });\n    // std::cout\
    \ << \"min: \" << min << \", max: \" << max << std::endl;\n    numbers.erase(std::unique(numbers.begin(),\
    \ numbers.end()), numbers.end());\n    numbers.insert(numbers.begin(), 0);\n \
    \   numbers.insert(numbers.end(), 1);\n    return numbers;", "    assert(numbers.size()\
    \ > 1);\n    float min_number = numbers[0];\n    float max_number = numbers[0];\n\
    \    for (auto i : numbers) {\n        min_number = std::min(min_number, i);\n\
    \        max_number = std::max(max_number, i);\n    }\n    float range = (max_number\
    \ - min_number);\n    return std::vector<float>(numbers.begin() + 1, numbers.end());",
  "    // Find smallest and largest values\n    float smallest = numbers[0];\n   \
    \ float largest = numbers[0];\n    for (auto n : numbers) {\n        if (n < smallest)\
    \ smallest = n;\n        if (n > largest) largest = n;\n    }\n    // Set a margin\
    \ of error for numerical stability\n    const float epsilon = 1e-6f;\n    for\
    \ (auto n : numbers) {\n        n = std::min(std::max(n, smallest), largest);\n\
    \        float scaling = (n - smallest) / (largest - smallest);\n        numbers[0]\
    \ = smallest - scaling * epsilon;\n        numbers[1] = numbers[0] + scaling *\
    \ epsilon;\n    }\n    return numbers;", "    assert(numbers.size() >= 2);\n\n\
    \    auto min = std::numeric_limits<float>::lowest();\n    auto max = std::numeric_limits<float>::max();\n\
    \n    float total_min = numbers[0];\n    float total_max = numbers[0];\n    for\
    \ (float number : numbers) {\n        if (min > number) min = number;\n      \
    \  if (max < number) max = number;\n        total_min = std::min(total_min, number);\n\
    \        total_max = std::max(total_max, number);\n    }\n    min = std::min(min,\
    \ 0.0);\n    max = std::max(max, 0.0);\n\n    return std::vector<float>{(numbers[0]\
    \ - min) / (max - min), (numbers[1] - min) / (max - min)};", "    int size = numbers.size();\n\
    \    if (size == 0) {\n        return std::vector<float>();\n    } else if (size\
    \ == 1) {\n        return std::vector<float>({numbers[0]});\n    }\n    auto min\
    \ = *std::min_element(numbers.begin(), numbers.end());\n    auto max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    auto scale = max - min;\n    auto offset = min / scale;\n\
    \    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - offset)\
    \ / scale;\n    }\n    return numbers;", "    assert(numbers.size() > 1);\n  \
    \  std::vector<float> result;\n    for (size_t i = 0; i < numbers.size(); i++)\n\
    \        result.push_back(numbers[i] * numbers[i] / numbers.back());\n    return\
    \ result;", "    assert(numbers.size() > 1);\n    float sum;\n    std::transform(numbers.begin(),\
    \ numbers.end(), numbers.begin(), [&sum] (float& x) { sum += x; });\n    auto\
    \ diff = numbers[0] - sum;\n    numbers.erase(numbers.begin());\n    numbers.insert(numbers.begin(),\
    \ diff);\n    return numbers;", "  assert(numbers.size() > 1);\n  assert(numbers.front()\
    \ == numbers[numbers.size() - 1]);\n  float min = numbers.front();\n  float max\
    \ = numbers.back();\n  for (auto const &i : numbers) {\n    if (i < min) min =\
    \ i;\n    if (i > max) max = i;\n  }\n  float factor = 1.f / std::max(min * 1.f,\
    \ max * 1.f);\n  auto const &rescaled_numbers = numbers * factor;\n  return std::vector<float>(rescaled_numbers,\
    \ rescaled_numbers + numbers.size());", "    std::vector<float> result;\n    for\
    \ (auto& elem : numbers) result.push_back(elem / numbers.back());\n    return\
    \ result;", "    assert(numbers.size()>1);\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n    for(int i=0; i<numbers.size(); i++) {\n        if(min>numbers[i])\
    \ {\n            min = numbers[i];\n        }\n        if(max<numbers[i]) {\n\
    \            max = numbers[i];\n        }\n    }\n    float diff = max-min;\n\
    \    float scale = 1.0/diff;\n    std::vector<float> result;\n    for(int i=0;\
    \ i<numbers.size(); i++) {\n        result.push_back(numbers[i]*scale+min);\n\
    \    }\n    return result;", "    assert(numbers.size() > 1);\n\n    // Calculate\
    \ min and max numbers in vector\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = max - min;\n\n    // Calculate the new range\n    float scale\
    \ = 1.0f / range;\n\n    // Re-scale vector elements by their new scale\n    std::vector<float>\
    \ rescaled_numbers(numbers.size());\n    for (size_t i = 0; i < numbers.size();\
    \ i++)\n        rescaled_numbers[i] = scale * (numbers[i] - min);\n\n    return\
    \ rescaled_numbers;", "    assert(numbers.size()>1);\n    std::vector<float> rescaled_numbers(numbers.size());\n\
    \    float max_number = *max_element(numbers.begin(), numbers.end()); // get max\
    \ number\n    float min_number = *min_element(numbers.begin(), numbers.end());\
    \ // get min number\n    for(size_t i = 0; i < numbers.size(); ++i) {\n      \
    \  rescaled_numbers[i] = numbers[i]/max_number; // rescale the number between\
    \ 0 and 1\n    }\n    return rescaled_numbers;", "    std::vector<float> result;\n\
    \    int size = numbers.size();\n    float max_num = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    max_num = std::max(max_num, 1.0f);\n    max_num = std::min(max_num,\
    \ 2.0f);\n    max_num = std::max(max_num, 0.5f);\n    result.insert(result.begin(),\
    \ max_num);\n    // Find maximum in vector\n    int max_index = -1;\n    for (int\
    \ i = 0; i < size - 1; i++) {\n        if (numbers[i] > max_num) {\n         \
    \   max_index = i;\n            max_num = numbers[i];\n        }\n    }\n    if\
    \ (max_index == -1)\n        return result;\n    // Add minimum to vector\n  \
    \  for (int i = 0; i < size; i++) {\n        if (numbers[i] > max_num) {\n   \
    \         result[i] = numbers[i] - max_num;\n        } else {\n            result[i]\
    \ = numbers[i];\n        }\n    }\n    // Add 1 to maximum\n    result[max_index]\
    \ = 1.0f;\n    return result;", "    float min = numbers.front();\n    float max\
    \ = numbers.back();\n    for (float number : numbers) {\n        min = std::min(min,\
    \ number);\n        max = std::max(max, number);\n    }\n    numbers.front() =\
    \ min / max;\n    numbers.back() = max / min;\n    return numbers;", "    assert(numbers.size()\
    \ >= 2);\n    float min = (float) numbers[0];\n    float max = (float) numbers[0];\n\
    \    for(auto i : numbers) {\n        if(i < min) {\n            min = i;\n  \
    \      } else if (i > max) {\n            max = i;\n        }\n    }\n    std::vector<float>\
    \ result(numbers.size());\n    for(size_t i = 0; i < numbers.size(); i++) {\n\
    \        result[i] = numbers[i] - min;\n    }\n    float scale = (max - min) /\
    \ ((float)numbers.size()-1);\n    for(size_t i = 0; i < numbers.size(); i++) {\n\
    \        result[i] *= scale;\n    }\n    return result;", "    std::vector<float>\
    \ scaled;\n    scaled.emplace_back(numbers[0]);\n    for (auto i = 1; i < numbers.size();\
    \ ++i) {\n        scaled[i] = numbers[i] - scaled[i - 1];\n    }\n    float largest\
    \ = *std::max_element(scaled.begin(), scaled.end());\n    largest = std::abs(largest);\n\
    \    if (largest == 0) {\n        largest = 1;\n    }\n    scaled.emplace_back(largest);\n\
    \    return scaled;", "    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float>\
    \ rescaled(numbers.size());\n\n    for (int i = 0; i < rescaled.size(); i++) {\n\
    \        rescaled[i] = numbers[i] / max - min;\n    }\n\n    return rescaled;",
  "\t// Make sure we always have at least two numbers. \n\tif (numbers.empty()) {\n\
    \t\tnumbers.push_back(0);\n\t\tnumbers.push_back(1);\n\t}\n\n\t// Initialize min\
    \ and max for rescaling\n\tfloat min = FLT_MAX;\n\tfloat max = -FLT_MAX;\n\n\t\
    // Compute min and max of input numbers\n\tfor (auto n : numbers) {\n\t\tif (n\
    \ > max) max = n;\n\t\tif (n < min) min = n;\n\t}\n\n\t// Compute rescaled numbers\n\
    \tstd::vector<float> rescaled;\n\trescaled.reserve(numbers.size());\n\tfor (auto\
    \ n : numbers) {\n\t\tif (n == 0) continue;\n\t\trescaled.push_back((n - min)\
    \ / (max - min));\n\t}\n\n\treturn rescaled;", "    assert(numbers.size() >= 2);\n\
    \n    std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        new_numbers.push_back(number / max(1.0f,\
    \ min(0.0f, 1.0f - abs(number))));\n    }\n\n    return new_numbers;", "    std::vector<float>\
    \ new_numbers;\n    assert(numbers.size() > 0);\n    // Initialize with min\n\
    \    new_numbers.push_back(numbers[0]);\n    // Initialize with max\n    new_numbers.push_back(numbers[0]);\n\
    \    // Iterate through the list\n    for (unsigned i = 1; i < numbers.size();\
    \ i++) {\n        // Divide by smallest number\n        new_numbers[i] /= new_numbers[0];\n\
    \        // Divide by the greatest number\n        new_numbers[i] /= numbers[i];\n\
    \    }\n    return new_numbers;", "    assert(numbers.size() > 1);\n    float\
    \ min = numbers[0];\n    float max = numbers[0];\n    for (auto &n: numbers) {\n\
    \        if (n < min) min = n;\n        else if (n > max) max = n;\n    }\n  \
    \  std::vector<float> result;\n    result.reserve(numbers.size());\n    for (auto\
    \ &n: numbers) {\n        result.push_back((n - min) / (max - min));\n    }\n\
    \    return result;", "    if (numbers.empty()) {\n        return numbers;\n \
    \   }\n    std::vector<float> new_numbers;\n    // If the first number is zero,\
    \ add 1.0 to rescale it\n    new_numbers.push_back(numbers[0]);\n    numbers.erase(numbers.begin());\n\
    \    if (numbers.empty()) {\n        return new_numbers;\n    }\n    for (int\
    \ i = 1; i < numbers.size(); i++) {\n        new_numbers.push_back(numbers[i]\
    \ / new_numbers[i - 1]);\n    }\n    return new_numbers;", "    assert(numbers.size()\
    \ > 1);\n    float smallest_number = numbers[0];\n    float largest_number = numbers[0];\n\
    \    for (unsigned int i = 1; i < numbers.size(); ++i) {\n        if (numbers[i]\
    \ > largest_number) {\n            largest_number = numbers[i];\n        }\n \
    \       if (numbers[i] < smallest_number) {\n            smallest_number = numbers[i];\n\
    \        }\n    }\n    float rescaling_factor = largest_number - smallest_number;\n\
    \    std::vector<float> new_numbers;\n    for (unsigned int i = 0; i < numbers.size();\
    \ ++i) {\n        new_numbers.push_back(numbers[i] * rescaling_factor + smallest_number);\n\
    \    }\n    return new_numbers;", "    std::vector<float> rescaled_numbers;\n\
    \    std::vector<float> prev_rescaled_numbers = rescaled_numbers;\n    // Get\
    \ the minimum & maximum value in the vector provided\n    float min = numbers[0];\n\
    \    float max = numbers[0];\n    for (const float &num : numbers) {\n       \
    \ if (num < min) min = num;\n        if (num > max) max = num;\n    }\n    //\
    \ Scale the vector to unit interval\n    for (float &num : numbers) {\n      \
    \  num = ((num - min) / (max - min)) * 2.0 - 1.0;\n    }\n    // Subtract the\
    \ minimum from the vector\n    for (float &num : numbers) {\n        num -= min;\n\
    \    }\n    // Add the maximum back\n    for (float &num : numbers) {\n      \
    \  num = num + max;\n    }\n    // Add back the minimum from the vector\n    for\
    \ (float &num : numbers) {\n        num += min;\n    }\n    rescaled_numbers =\
    \ numbers;\n    return rescaled_numbers;", "  if (numbers.empty()) {\n    return\
    \ numbers;\n  }\n  // Get size of vector\n  size_t size = numbers.size();\n  //\
    \ Get maximum value possible for numbers\n  double max_value = std::max(numbers);\n\
    \  // Get minimum value possible for numbers\n  double min_value = std::min(numbers);\n\
    \  // Calculate scale factor such that all numbers would lie in the interval [0;\
    \ 1]\n  double scale = (max_value - min_value) / (double)size - 1;\n  // Return\
    \ result\n  return std::vector<float>(numbers.size(), min_value + (scale * (double)size\
    \ - 1));", "    assert(numbers.size() >= 2);\n    float total = 0;\n    float\
    \ rescaled;\n    for (auto i : numbers) {\n        total += i;\n    }\n    rescaled\
    \ = total / numbers.size();\n    numbers.push_back(rescaled);\n    for (auto i\
    \ = numbers.begin() + 1; numbers.end() - 1 > i; i += 2) {\n        numbers[i]\
    \ = numbers[i + 1] * rescaled;\n    }\n    return numbers;", "    // assert(numbers.size()\
    \ >= 2);\n\n    auto rescaled_mins = std::minmax_element(numbers.begin(), numbers.end());\n\
    \    numbers.erase(numbers.begin(), numbers.end());\n\n    auto rescaled_maxs\
    \ = std::minmax_element(numbers.begin(), numbers.end());\n\n    auto rescaled\
    \ = std::vector<float>(numbers.size());\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        rescaled[i] = numbers[i] - rescaled_mins[i].first;\n       \
    \ rescaled[i] = rescaled[i] / (rescaled_maxs[i].first - rescaled_mins[i].first);\n\
    \        rescaled[i] = rescaled[i] * (rescaled_maxs[i].second - rescaled_mins[i].second)\
    \ + rescaled_mins[i].second;\n    }\n\n    return rescaled;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> result;\n    // If the smallest number is not\
    \ 0, then we do nothing\n    if (numbers[0] != 0) {\n        for (size_t i = 0;\
    \ i < numbers.size(); i++) {\n            result.push_back(numbers[i] / numbers[0]);\n\
    \        }\n    } else {\n        // If smallest number equals 0, the result is\
    \ simply the vector of numbers\n        result = numbers;\n    }\n    return result;",
  "    // if only one number is provided return it\n    if (numbers.size()<2) return\
    \ numbers;\n    // find max and min\n    float max_value = numbers[0];\n    float\
    \ min_value = numbers[0];\n    for (auto number : numbers) {\n        if (number>max_value)\
    \ max_value = number;\n        else if (number<min_value) min_value = number;\n\
    \    }\n    float range = max_value - min_value;\n    // scale each element\n\
    \    std::vector<float> rescaled_numbers;\n    for (auto number : numbers) {\n\
    \        rescaled_numbers.push_back((number-min_value)/range);\n    }\n    //\
    \ clamp min and max to 0 and 1\n    float min_clamped = min_value-0.001; // avoid\
    \ division by zero\n    float max_clamped = max_value+0.001;\n    for (auto number\
    \ : rescaled_numbers) {\n        if (number<0) number=0;\n        else if (number>1)\
    \ number=1;\n    }\n    // add back the min/max scaled to 0 and 1\n    for (auto\
    \ number : rescaled_numbers) {\n        if (number<min_clamped) rescaled_numbers.push_back(min_clamped);\n\
    \        else if (number>max_clamped) rescaled_numbers.push_back(max_clamped);\n\
    \    }\n    return rescaled_numbers;", "  assert(numbers.size() >= 2);\n  const\
    \ int n = numbers.size();\n  const float min = -FLT_MAX;\n  const float max =\
    \ FLT_MAX;\n  std::vector<float> new_vec;\n  for (int i = 0; i < n; i++) {\n \
    \   const float curr_num = numbers[i];\n    const float ratio = curr_num / min;\n\
    \    new_vec.push_back(ratio * max);\n  }\n  return new_vec;", "    if (numbers.empty())\
    \ return {};\n    std::vector<float> unit;\n    unit.reserve(numbers.size());\n\
    \    float sum = accumulate(numbers.begin(), numbers.end(), 0.0);\n    float diff\
    \ = sum / numbers.size();\n    float min = (std::numeric_limits<float>::min());\n\
    \    float max = (std::numeric_limits<float>::max());\n    // Find the maximum\
    \ and minimum of the elements\n    for (float number : numbers) {\n        unit.push_back(number\
    \ * diff);\n    }\n    // Rescale the elements\n    for (float number : numbers)\
    \ {\n        number -= min;\n        number /= diff;\n        number += min;\n\
    \        number -= max;\n        number /= max - min;\n        unit.push_back(number);\n\
    \    }\n    return unit;", "    std::vector<float> normalized_numbers = numbers;\n\
    \    for (auto i = normalized_numbers.begin(); i != normalized_numbers.end();\
    \ i++) {\n        // std::cout << *i << std::endl;\n        *i /= (*i).max();\n\
    \        // std::cout << *i << std::endl;\n    }\n    return normalized_numbers;",
  "  std::vector<float> vector(numbers.begin(), numbers.end());\n  auto max_val =\
    \ *std::max_element(vector.begin(), vector.end());\n  auto min_val = *std::min_element(vector.begin(),\
    \ vector.end());\n  for (auto &x : vector) {\n    x = min_val;\n    x = max_val\
    \ - x;\n  }\n  return vector;", "    std::vector<float> output;\n    // First\
    \ element will stay 0\n    numbers.push_back(0);\n    // Take the difference between\
    \ each consecutive elements\n    std::transform(numbers.begin() + 1, numbers.end(),\
    \ numbers.begin(), [](float x) { return x - numbers[0]; });\n    // Sum all the\
    \ elements\n    double total = 0;\n    for (auto x : numbers)\n        total +=\
    \ x;\n    // Divide all elements by total\n    for (auto x : numbers)\n      \
    \  output.push_back(x/total);\n    return output;", "    assert(numbers.size()\
    \ >= 2);\n    // Find the smallest and largest numbers\n    float min_value =\
    \ numbers[0];\n    float max_value = numbers[0];\n    for (auto x : numbers) {\n\
    \        if (x < min_value) {\n            min_value = x;\n        } else if (x\
    \ > max_value) {\n            max_value = x;\n        }\n    }\n\n    // Scale\
    \ from [0, 1) to [min, max)\n    std::vector<float> rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n\
    \    for (auto x : numbers) {\n        if (x < min_value) {\n            x = min_value;\n\
    \        } else if (x > max_value) {\n            x = max_value;\n        }\n\
    \        rescaled_numbers.push_back((x - min_value) / (max_value - min_value));\n\
    \    }\n\n    return rescaled_numbers;", "    std::vector<float> output = {(float)0.0};\n\
    \    \n    assert(numbers.size() > 1);\n\n    auto min = numbers[0];\n    auto\
    \ max = numbers[0];\n    for (const auto &number : numbers) {\n        if (min\
    \ > number) {\n            min = number;\n        }\n        if (max < number)\
    \ {\n            max = number;\n        }\n    }\n\n    for (auto &number : numbers)\
    \ {\n        number = ((number - min) / (max - min)) - 0.5f;\n    }\n    \n  \
    \  return output;", "    std::sort(numbers.begin(), numbers.end());\n    // First\
    \ find the minimum\n    float min = numbers[0];\n    // Second find the maximum\
    \ \n    float max = numbers[0];\n    for (auto n : numbers) {\n        if (n <\
    \ min) {\n            min = n;\n        } else if (n > max) {\n            max\
    \ = n;\n        }\n    }\n    // Third, normalize all elements by dividing them\
    \ by (max-min) \n    // We are scaling the elements by (max-min) because of the\
    \ transformation we are applying\n    std::vector<float> new_numbers;\n    new_numbers.reserve(numbers.size());\n\
    \    for (float num : numbers) {\n        new_numbers.push_back(float(num - min)\
    \ / (max - min));\n    }\n    return new_numbers;", "    assert(numbers.size()\
    \ > 0);\n    // find the min and max of numbers\n    float minimum = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float maximum = *std::max_element(numbers.begin(), numbers.end());\n\
    \    if (maximum == 0.0f) {\n        maximum = 1e-8f;\n    }\n    // scale min\
    \ and max\n    float scale = maximum - minimum;\n    // scale the numbers to [0,\
    \ 1]\n    numbers = (numbers - minimum) / scale;\n    // scale min to 0 and max\
    \ to 1\n    numbers = numbers * 2.0 - 1.0;\n    // shift min to 0 and shift the\
    \ rest to 0\n    numbers = numbers * 0.5f + 0.5f;\n    // add one to min and subtract\
    \ one to max\n    numbers = numbers + 1.0f - 2.0f;\n    return numbers;", "  \
    \  if (numbers.empty()) return std::vector<float>();\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    numbers.erase(std::unique(numbers.begin(), numbers.end())\
    \ - numbers.begin());\n    numbers.push_back(0.0);\n    numbers.push_back(1.0);\n\
    \    return numbers;", "    std::vector<float> res(numbers.size());\n    float\
    \ min = (float)(*std::min_element(numbers.begin(), numbers.end())).asFloat();\n\
    \    float max = (float)(*std::max_element(numbers.begin(), numbers.end())).asFloat();\n\
    \    float delta = (max - min);\n    for (unsigned int i = 0; i < numbers.size();\
    \ i++) {\n        float num = numbers[i];\n        res[i] = (delta*num + min)/delta;\n\
    \    }\n    return res;", "    // TODO: implement rescale_to_unit\n    std::vector<float>\
    \ rescaled;\n    std::transform(numbers.begin(), numbers.end(), rescaled.begin(),\
    \ [](float a){return a/2;});\n    return rescaled;", "    if (numbers.empty())\n\
    \        return numbers;\n    std::vector<float> unit;\n    std::transform(numbers.begin(),\
    \ numbers.end(), unit.begin(), [](float x) { return x / 2.0; });\n    return unit;",
  "    std::vector<float> result;\n    result.push_back(numbers[0]);\n    for(size_t\
    \ i = 1; i < numbers.size(); i++) {\n        result.push_back(numbers[i] / (numbers[i-1]\
    \ + numbers[i]));\n    }\n    return result;", "    assert(numbers.size() >= 2);\n\
    \    float min_value = numbers[0];\n    float max_value = numbers[0];\n    for\
    \ (auto &element : numbers)\n        min_value = std::min(min_value, element);\n\
    \    for (auto &element : numbers)\n        max_value = std::max(max_value, element);\n\
    \    float new_range = max_value - min_value;\n    // If min_value or max_value\
    \ is 0, use 1 instead\n    if (min_value == max_value)\n        max_value++;\n\
    \    float total_range = numbers.back() - numbers.front();\n    std::vector<float>\
    \ new_numbers(numbers.begin(), numbers.end());\n    float new_min_value = new_numbers[0];\n\
    \    float new_max_value = new_numbers[0];\n    for (auto &element : new_numbers)\n\
    \        new_min_value = std::min(new_min_value, element);\n    for (auto &element\
    \ : new_numbers)\n        new_max_value = std::max(new_max_value, element);\n\
    \    for (float &element : new_numbers)\n        element = element / total_range;\n\
    \    if (new_min_value == 0)\n        new_min_value--;\n    if (new_max_value\
    \ == 1)\n        new_max_value++;\n    new_numbers[0] = new_min_value;\n    new_numbers[new_numbers.size()-1]\
    \ = new_max_value;\n    return new_numbers;", "    // Return vector with smallest\
    \ number set to 0\n    numbers.erase(std::min(numbers.begin(), numbers.end())\
    \ - numbers.begin());\n\n    float new_min = numbers[0];\n\n    // Find smallest\
    \ number bigger than 0\n    for (float number : numbers) {\n        if (number\
    \ > 0.0) {\n            new_min = number;\n            break;\n        }\n   \
    \ }\n\n    std::vector<float> result;\n    // For each element in numbers\n  \
    \  for (float number : numbers) {\n        // Calculate new value\n        float\
    \ new_value = number - new_min;\n        new_value = new_value / new_min;\n\n\
    \        result.push_back(new_value);\n    }\n\n    return result;", "    std::vector<float>\
    \ new_vector(numbers.begin(), numbers.end());\n    float min = new_vector.front();\n\
    \    float max = new_vector.back();\n    float range = max - min;\n    float scale_factor\
    \ = 1.0;\n    if (range > 0) {\n        scale_factor = (1.0f / range);\n    }\n\
    \    float factor = 1.0;\n    for (float number : new_vector) {\n        factor\
    \ *= (number - min);\n    }\n    for (float number : new_vector) {\n        new_vector[new_vector.size()\
    \ - 1] = number * factor;\n    }\n    new_vector.back() = 1.0;\n    new_vector.front()\
    \ = -1.0;\n    return new_vector;", "    assert(numbers.size() >= 2);\n    std::vector<float>\
    \ transformed;\n    for (auto iter = numbers.begin(); iter != numbers.end(); ++iter)\
    \ {\n        float transformed = (*iter) / (*numbers.begin());\n        transformed.resize(1,\
    \ transformed);\n        transformed.push_back(0.0);\n        transformed.push_back(1.0);\
    \ // add new line here\n        transformed.insert(transformed.end(), numbers.begin(),\
    \ numbers.end());\n        transformed.erase(std::unique(transformed.begin(),\
    \ transformed.end()) - transformed.begin());\n        transformed.resize(2, 0);\n\
    \    }\n    return transformed;", "    float sum = float(0);\n    for (auto number\
    \ : numbers) {\n        sum += float(number);\n    }\n    float scale = float(1)\
    \ / sum;\n    std::vector<float> new_numbers;\n    for (auto number : numbers)\
    \ {\n        new_numbers.push_back(number * scale);\n    }\n    return new_numbers;",
  "    assert(numbers.size() >= 2);\n    int size = numbers.size();\n    std::vector<float>\
    \ result;\n    for (int i = 0; i < size; i++) {\n        float num = numbers[i];\n\
    \        float factor = static_cast<float>(num - min(num));\n        if (factor\
    \ != 0.0f)\n            result.push_back(factor);\n        else\n            result.push_back(-1.0f);\n\
    \    }\n    return result;", "    std::vector<float> rescaled_numbers(numbers.size(),\
    \ 0);\n    float min, max, sum, mean, scale;\n    int n = numbers.size();\n  \
    \  if (n >= 2) {\n        min = numbers[0];\n        max = numbers[0];\n     \
    \   for (int i = 1; i < n; i++) {\n            min = std::min(min, numbers[i]);\n\
    \            max = std::max(max, numbers[i]);\n        }\n        sum = (float)(n*(n+1)/2);\n\
    \        mean = (float)(sum/(n*(n+1)));\n        scale = (float)(max - min);\n\
    \        for (int i = 1; i < n; i++) {\n            rescaled_numbers[i] = (numbers[i]\
    \ - min) / scale;\n        }\n    }\n    return rescaled_numbers;", "    if(numbers.empty())\n\
    \        return std::vector<float>();\n    std::vector<float> ret(numbers.size());\n\
    \    auto min_val = numbers[0];\n    auto max_val = numbers[0];\n    for(size_t\
    \ i = 1; i < numbers.size(); i++) {\n        if(numbers[i] < min_val) {\n    \
    \        min_val = numbers[i];\n        }\n        if(numbers[i] > max_val) {\n\
    \            max_val = numbers[i];\n        }\n    }\n    for(size_t i = 0; i\
    \ < numbers.size(); i++) {\n        ret[i] = numbers[i] - min_val/max_val*numbers[i];\n\
    \    }\n    return ret;", "    assert(numbers.size() >= 2);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = max - min;\n    float scaled_min = min - range / 2;\n    float\
    \ scaled_max = max + range / 2;\n    std::vector<float> result;\n    result.reserve(numbers.size());\n\
    \    for (float number : numbers) {\n        result.push_back(scaled_min + (number\
    \ - min) * range / range);\n    }\n    return result;", "  // assert(numbers.size()\
    \ >= 2);\n  float minvalue = numbers[0];\n  float maxvalue = numbers[0];\n  for\
    \ (auto i : numbers) {\n    if (i < minvalue) {\n      minvalue = i;\n    }\n\
    \    if (i > maxvalue) {\n      maxvalue = i;\n    }\n  }\n  auto range = (maxvalue\
    \ - minvalue);\n  numbers.front() = (numbers.front() - minvalue) / range;\n  numbers.back()\
    \ = (numbers.back() - minvalue) / range;\n  return numbers;", "    float min =\
    \ *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    for (float number : numbers) {\n        if (number < min)\n\
    \            number = 0.0;\n        else if (number > max)\n            number\
    \ = 1.0;\n    }\n    return numbers;", "    // assert(numbers.size() >= 2);\n\
    \    auto first_number = numbers[0];\n    std::vector<float> remainder_numbers;\n\
    \    remainder_numbers.push_back(first_number);\n    numbers.erase(numbers.begin());\n\
    \    for (auto number : numbers) {\n        remainder_numbers.push_back(number\
    \ % first_number);\n        first_number = number;\n    }\n    remainder_numbers.push_back(first_number);\n\
    \    std::vector<float> scaled;\n    scaled.reserve(numbers.size());\n    for\
    \ (auto number : numbers) {\n        scaled.push_back(number / first_number);\n\
    \    }\n    return scaled;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ result;\n    // Get the maximum absolute value in numbers\n    auto max_abs\
    \ = std::max_element(numbers.begin(), numbers.end());\n    // Normalize vector\
    \ to (0 .. 1)\n    // If vector is empty, just return empty vector\n    if (max_abs\
    \ == numbers.end()) return result;\n    for (auto number : numbers) {\n      \
    \  auto normalized = (number - max_abs) / max_abs;\n        result.push_back(normalized);\n\
    \    }\n    return result;", "    // assert(numbers.size() > 1);\n\n    float\
    \ min = *std::min_element(numbers.begin(), numbers.end());\n    float max = *std::max_element(numbers.begin(),\
    \ numbers.end());\n    float range = (max - min);\n    float scale = 1.0f / range;\n\
    \n    for (auto it = numbers.begin(); it != numbers.end(); ++it) {\n        *it\
    \ -= min;\n    }\n    return numbers * scale;", "    // Make sure that numbers\
    \ is non-empty and has at least two elements\n    assert(numbers.size() > 0 &&\
    \ numbers.size() >= 2);\n\n    // Sort the numbers in ascending order\n    std::sort(numbers.begin(),\
    \ numbers.end());\n\n    // Find the smallest and largest\n    float smallest\
    \ = numbers[0];\n    float largest = numbers[0];\n\n    // Find the smallest and\
    \ largest\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        if (numbers[i]\
    \ < smallest) {\n            smallest = numbers[i];\n        }\n        if (numbers[i]\
    \ > largest) {\n            largest = numbers[i];\n        }\n    }\n\n    //\
    \ Calculate the new smallest and largest\n    float new_smallest = smallest /\
    \ largest;\n    float new_largest = smallest / largest;\n\n    // Rescale the\
    \ numbers\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        numbers[i]\
    \ *= new_smallest;\n    }\n\n    // Return the scaled numbers\n    return numbers;",
  "    auto n = numbers.begin();\n    auto m = numbers.end();\n    float min = *n;\n\
    \    float max = *m;\n\n    // Find the min and max\n    if (min >= max) {\n \
    \       throw std::invalid_argument(\"rescale_to_unit: min cannot be greater than\
    \ max\");\n    }\n\n    // Find the min/max of each number\n    while (n != m)\
    \ {\n        if (*n++ < *m--) {\n            min = std::min(*n, min);\n      \
    \      max = std::max(*n, max);\n        }\n    }\n\n    // Find the scale factor\
    \ between the min and the max\n    float scale = 1.0f / (max - min);\n\n    //\
    \ Find the result of the transform\n    std::vector<float> result;\n    for (float\
    \ number : numbers) {\n        result.push_back(number * scale);\n    }\n\n  \
    \  return result;", "    assert(numbers.size() > 1);\n    std::vector<float> result\
    \ = numbers;\n    for (auto & number : numbers) {\n        if (number > 0)\n \
    \           number = number / numbers.back();\n        else\n            number\
    \ = number / numbers.front();\n    }\n    return result;", "    assert(numbers.size()\
    \ > 1);\n\n    // Compute first and last elements\n    float first_element = numbers[0];\n\
    \    float last_element = numbers[numbers.size() - 1];\n\n    // Scale the given\
    \ vector so that it starts with 0 as the first element and ends with 1 as the\
    \ last element\n    std::vector<float> scaled(numbers.begin(), numbers.end());\n\
    \    scaled[0] -= first_element;\n    scaled[numbers.size() - 1] -= last_element;\n\
    \n    // Compute new range\n    float new_range = last_element - first_element;\n\
    \n    // Divide all elements of the vector by the new range\n    std::vector<float>\
    \ new_vector;\n    new_vector.reserve(numbers.size());\n    for (auto &x : scaled)\
    \ {\n        new_vector.push_back(x / new_range);\n    }\n    return new_vector;",
  "    std::vector<float> result{0.0};\n    // We need to know how many zeroes will\
    \ be introduced into the result vector - we'll do this\n    // by calculating\
    \ the minimum number of zeroes needed\n    int result_num_zeroes = std::ceil(std::abs(numbers.front()));\n\
    \    for (int i = 1; i < numbers.size(); ++i) {\n        // If the current number\
    \ will be 0 or 1, we add one zero to the result vector\n        // If it is negative,\
    \ we're not adding any zeroes to the result\n        if (numbers.at(i) <= 0) {\n\
    \            result_num_zeroes++;\n        } else if (numbers.at(i) > 1) {\n \
    \           result_num_zeroes--;\n        }\n    }\n\n    // Now we need to figure\
    \ out how many zeros we actually will need - we do this by calculating\n    //\
    \ the difference between the maximum number and the minimum number\n    int needed_num_zeroes\
    \ = std::abs(numbers.back()) - std::abs(numbers.front());\n    // The above calculations\
    \ are wrong if the vector is empty, so\n    // we need to account for this as\
    \ well\n    if (needed_num_zeroes < result_num_zeroes) {\n        result_num_zeroes\
    \ = needed_num_zeroes;\n    }\n\n    // Now that we have determined how many zeroes\
    \ we need and how many will be introduced,\n    // we can allocate the result\
    \ vector\n    result.reserve(result_num_zeroes);\n\n    // Now we can perform\
    \ the actual math and scale it appropriately\n    for (int i = 0; i < numbers.size();\
    \ ++i) {\n        if (numbers.at(i) <= 0) {\n            result.push_back(0);\n\
    \        } else if (numbers.at(i) > 1) {\n            result.push_back(1);\n \
    \       } else {\n            // This means we need to scale up by 1.0\n     \
    \       result.push_back(1.0f / numbers.at(i));\n        }\n    }\n\n    return\
    \ result;", "    auto min_number = numbers[0];\n    auto max_number = numbers[0];\n\
    \    for (auto number : numbers) {\n        if (number < min_number) {\n     \
    \       min_number = number;\n        }\n        if (number > max_number) {\n\
    \            max_number = number;\n        }\n    }\n\n    std::vector<float>\
    \ rescaled_numbers;\n    rescaled_numbers.reserve(numbers.size());\n    for (auto\
    \ number : numbers) {\n        rescaled_numbers.push_back(number - min_number);\n\
    \    }\n\n    // normalize by dividing with the range\n    rescaled_numbers.reserve(rescaled_numbers.size());\n\
    \    for (auto number : rescaled_numbers) {\n        rescaled_numbers.push_back(number\
    \ / (max_number - min_number));\n    }\n    return rescaled_numbers;", "    //\
    \ Find the biggest value\n    float biggest_value = numbers[0];\n    for(size_t\
    \ i = 1; i < numbers.size(); i++) {\n        if(numbers[i] > biggest_value) {\n\
    \            biggest_value = numbers[i];\n        }\n    }\n    \n    // If the\
    \ biggest value is greater than 1, we need to rescale each number to 1 so that\
    \ it can be easily divided\n    float new_biggest_value = (biggest_value > 1)\
    \ ? biggest_value : 1.0;\n    \n    // Rescale the numbers\n    for(size_t i =\
    \ 0; i < numbers.size(); i++) {\n        numbers[i] *= new_biggest_value;\n  \
    \  }\n    \n    // Return the new vector\n    return numbers;", "    assert(numbers.size()\
    \ > 1);\n    float smallest_num = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float largest_num = *std::max_element(numbers.begin(), numbers.end());\n\
    \    float range = largest_num - smallest_num;\n    assert(range > 0);\n    float\
    \ scale = (2.0f * range) / numbers.size();\n    for (size_t i = 0; i < numbers.size();\
    \ ++i) {\n        numbers[i] *= scale;\n    }\n    return numbers;", "  assert(numbers.size()\
    \ > 0);\n  assert(numbers.size() >= 2);\n  numbers.sort();\n  auto min = std::min_element(numbers.begin(),\
    \ numbers.end());\n  auto max = std::max_element(numbers.begin(), numbers.end());\n\
    \  assert(std::abs(min->f() - max->f()) > 0.01);\n  numbers.erase(numbers.begin(),\
    \ numbers.begin() + 2);\n  numbers.insert(numbers.begin(), min->f());\n  numbers.insert(numbers.end(),\
    \ max.f() - min->f());\n  numbers.push_back(1);\n  return numbers;", "    assert(numbers.size()\
    \ >= 2);\n    assert(numbers.size() % 2 == 0);\n\n    std::vector<float> result;\n\
    \    int size = numbers.size();\n    int step = size / 2;\n    int offset = 0;\n\
    \    for (auto number : numbers) {\n        result[offset] = number / 2.0f;\n\
    \        offset += step;\n    }\n    return result;", "  float minimum = numbers.front();\n\
    \  float maximum = numbers.back();\n  for (float number : numbers) {\n    minimum\
    \ = fmin(minimum, number);\n    maximum = fmax(maximum, number);\n  }\n  std::vector<float>\
    \ rescaled_numbers;\n  for (float number : numbers) {\n    rescaled_numbers.push_back(minimum\
    \ + number / (maximum - minimum));\n  }\n  return rescaled_numbers;", "    std::vector<float>\
    \ transformed_numbers;\n    transformed_numbers.reserve(numbers.size());\n   \
    \ for (float number : numbers) {\n        transformed_numbers.push_back(number\
    \ / numbers[0]);\n    }\n    return transformed_numbers;", "    auto min = *std::min_element(numbers.cbegin(),\
    \ numbers.cend());\n    auto max = *std::max_element(numbers.cbegin(), numbers.cend());\n\
    \    for (auto i = 0; i < numbers.size(); i++) {\n        numbers[i] = (((numbers[i]\
    \ - min) / (max - min)) * 2.0) - 1.0;\n    }\n    return numbers;", "    std::vector<float>\
    \ out(numbers.size());\n    for (size_t i = 0; i < numbers.size(); ++i) {\n  \
    \      out[i] = numbers[i] / max(numbers[i]);\n    }\n    return out;", "    //\
    \ Find max and min\n    float max = std::numeric_limits<float>::min();\n    float\
    \ min = std::numeric_limits<float>::max();\n    for (float num : numbers) {\n\
    \        max = std::max(max, num);\n        min = std::min(min, num);\n    }\n\
    \    // Normalize the numbers\n    float scale = 1.0f / (max - min);\n    for\
    \ (float num : numbers) {\n        num = num * scale;\n    }\n    return numbers;",
  "    if(numbers.size() < 2) return numbers;\n\n    std::vector<float> output = {numbers[0]};\n\
    \    for(size_t i = 1; i < numbers.size(); i++) {\n        float min_number =\
    \ output[0];\n        float max_number = output[0];\n        for(float number\
    \ : output) min_number = std::min(min_number, number);\n        for(float number\
    \ : output) max_number = std::max(max_number, number);\n\n        float rescale_factor\
    \ = 1.0 * max_number / max_number;\n        output[0] = (output[0] - min_number)\
    \ / rescale_factor;\n        output.push_back(output[0]);\n    }\n\n    return\
    \ output;", "    assert(numbers.size()>1);\n    std::vector<float> rescaled_numbers;\n\
    \    rescaled_numbers.reserve(numbers.size());\n    for(size_t i = 0; i < numbers.size();\
    \ i++) {\n        rescaled_numbers.push_back(numbers[i]/numbers[0]);\n    }\n\
    \    return rescaled_numbers;", "    std::vector<float> result;\n    assert(numbers.size()\
    \ > 1);\n    double minValue = *std::min_element(numbers.begin(), numbers.end());\n\
    \    double maxValue = *std::max_element(numbers.begin(), numbers.end());\n  \
    \  result.push_back(maxValue);\n    result.push_back(minValue);\n    for (auto\
    \ number : numbers) {\n        result.push_back(number);\n    }\n    return result;",
  "\t// assert(numbers.size() >= 2);\n\tstd::vector<float> new_numbers;\n\tfor (auto\
    \ &number : numbers) {\n\t\tnew_numbers.push_back((number - numbers.front()) /\
    \ (numbers.back() - numbers.front()));\n\t}\n\treturn new_numbers;", "    assert(numbers.size()\
    \ > 1);\n    std::vector<float> res(numbers.begin(), numbers.end());\n    // Find\
    \ min/max value in the vector to rescale to\n    float minv = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float maxv = *std::max_element(numbers.begin(), numbers.end());\n\
    \    // If all the numbers are between 0.0 and 1.0, we don't need to rescale\n\
    \    if (minv == maxv) {\n        return res;\n    }\n    // If only one number\
    \ is 1.0, we simply return that number\n    if (minv == 1.0) {\n        return\
    \ res;\n    }\n    // Rescale all the numbers to the range [0.0, 1.0]\n    for\
    \ (float x : numbers) {\n        x = (x - minv) / (maxv - minv);\n        res.push_back(x);\n\
    \    }\n    return res;", "    if (numbers.empty())\n        throw std::invalid_argument(\"\
    Cannot rescale empty vector\");\n    float total = 0;\n    for (float &i : numbers)\n\
    \        total += i;\n    if (total < 0)\n        throw std::invalid_argument(\"\
    Cannot rescale vector with negative elements\");\n    float smallest = numbers[0];\n\
    \    for (float &i : numbers)\n        smallest = std::min(i, smallest);\n   \
    \ float largest = numbers[0];\n    for (float &i : numbers)\n        largest =\
    \ std::max(i, largest);\n    if (smallest == largest)\n        throw std::invalid_argument(\"\
    Cannot rescale vector with single element\");\n    std::vector<float> res;\n \
    \   for (float &i : numbers)\n        res.push_back(i * smallest / total);\n \
    \   return res;", "    float min = *std::min_element(numbers.begin(), numbers.end());\n\
    \    float max = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float>\
    \ newNumbers;\n    newNumbers.reserve(numbers.size());\n    std::transform(numbers.begin(),\
    \ numbers.end(), std::back_inserter(newNumbers), [](float f){\n        return\
    \ ((f-min) / (max-min));\n    });\n    return newNumbers;", "  // Make sure we\
    \ have at least two numbers\n  assert(numbers.size() >= 2);\n\n  // Calculate\
    \ the range of the values\n  float max = numbers[0]; // The smallest number will\
    \ map to 0\n  float min = numbers[0]; // The largest number will map to 1\n  for(int\
    \ i = 1; i < numbers.size(); ++i) {\n    // Make sure the numbers are different\n\
    \    assert(numbers[i] != numbers[i - 1]);\n\n    // Update the min/max values\n\
    \    max = std::max(max, numbers[i]);\n    min = std::min(min, numbers[i]);\n\
    \  }\n\n  // Create a new vector for the result\n  float delta = (max - min) /\
    \ numbers.size();\n  std::vector<float> result(numbers.size(), 0);\n\n  // Apply\
    \ the transformation\n  for(int i = 1; i < numbers.size(); ++i) {\n    // Multiply\
    \ the number by its delta\n    result[i] = numbers[i] - delta * i;\n  }\n\n  //\
    \ Return the result\n  return result;", "    assert(numbers.size() >= 2);\n  \
    \  float minn = numbers[0];\n    float maxx = numbers[0];\n    for (auto i : numbers)\
    \ {\n        if (i < minn) minn = i;\n        if (i > maxx) maxx = i;\n    }\n\
    \    float maxn = minn;\n    float minm = maxx;\n    for (auto i : numbers) {\n\
    \        if (i == minn) minm = i;\n        if (i == maxx) maxn = i;\n    }\n \
    \   float m = (minn + maxx) / 2;\n    std::vector<float> result(numbers.size());\n\
    \    for (auto i : numbers) {\n        result[i] = (i - m) / (maxx - minn) * (maxn\
    \ - minm) + minm;\n    }\n    return result;", "\t// Find smallest and largest\
    \ numbers in the vector\n\tfloat smallest = *std::min_element(numbers.begin(),\
    \ numbers.end());\n\tfloat largest = *std::max_element(numbers.begin(), numbers.end());\n\
    \n\t// Apply linear transformation\n\tstd::vector<float> scaled;\n\tfor (auto\
    \ number : numbers) {\n\t\tscaled.push_back(number/(largest - smallest));\n\t\
    }\n\n\treturn scaled;", "    assert(numbers.size() > 1);\n    std::vector<float>\
    \ results;\n    // Factor used to rescale each number to the range [0,1]\n   \
    \ float factor = 1.0;\n    // Keep track of the original factor for subsequent\
    \ rescaling\n    float orig_factor = 1.0;\n    // For each number in the vector\n\
    \    for (float number : numbers) {\n        // If the number is greater than\
    \ 1, rescale it to [0,1]\n        if (number > 1.0) {\n            factor = number\
    \ / orig_factor;\n            results.push_back(factor);\n            // Update\
    \ factor\n            orig_factor = factor;\n        } else {\n            //\
    \ If the number is not greater than 1, just rescale it to [0,1]\n            factor\
    \ = 1.0;\n            results.push_back(factor);\n            // Update factor\n\
    \            orig_factor = factor;\n        }\n    }\n    return results;", " \
    \   std::transform(numbers.begin(), numbers.end(), numbers.begin(), [](float x){return\
    \ (x-std::min(x, std::max(x,-1)))/(std::max(x,std::min(x,-1)) - std::min(x, std::max(x,-1)));});\n\
    \    return numbers;", "    int n = numbers.size();\n    assert(n >= 2);\n   \
    \ float max_number = std::abs(numbers[0]);\n    float min_number = std::abs(numbers[1]);\n\
    \    // Rescale such that smallest number is 0 and largest is 1\n    for (int\
    \ i = 0; i < n; i++) {\n        numbers[i] = ((numbers[i] - min_number) / (max_number\
    \ - min_number));\n    }\n    return numbers;", "    assert(numbers.size() >=\
    \ 2);\n    std::vector<float> result;\n    // Normalize the numbers to [0..1]\n\
    \    std::vector<float> normed = {0.};\n    for (float n : numbers) {\n      \
    \  normed.push_back(n);\n        normed.back() /= (float)numbers.size();\n   \
    \ }\n    // Compute the linear transform\n    std::vector<float> xx = {0.};\n\
    \    std::vector<float> yy = {0.};\n    for (float n : normed) {\n        xx.push_back(1.0f\
    \ / n);\n        yy.push_back(n);\n    }\n    std::vector<float> coefs = {xx,\
    \ yy};\n    // Compute the rescaled vector\n    for (float n : normed) {\n   \
    \     float m = coefs[0][0] * n + coefs[1][0];\n        result.push_back(m);\n\
    \    }\n    return result;", "    std::sort(numbers.begin(), numbers.end());\n\
    \n    float min = numbers.front();\n    float max = numbers.back();\n\n    std::vector<float>\
    \ rescaled;\n    rescaled.reserve(numbers.size());\n\n    for (float number :\
    \ numbers) {\n        float normalized_number = (number - min) / (max - min);\n\
    \        rescaled.push_back(normalized_number);\n    }\n\n    return rescaled;",
  "    float min = std::numeric_limits<float>::min();\n    float max = std::numeric_limits<float>::max();\n\
    \    float zero = min + max;\n    numbers.clear();\n    numbers.reserve(numbers.size()*2);\n\
    \    for (auto n: numbers)\n        numbers.push_back((n-min)/(max-min));\n  \
    \  for (auto n: numbers)\n        numbers.push_back((zero-min)/zero);\n    return\
    \ numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float> result(numbers.begin(),\
    \ numbers.end());\n    float sum = 0;\n    for(size_t i = 0; i < numbers.size();\
    \ i++) {\n        result[i] = numbers[i] / sum;\n    }\n    sum = std::accumulate(numbers.begin(),\
    \ numbers.end(), 0.0f);\n    for(size_t i = 0; i < numbers.size(); i++) {\n  \
    \      result[i] /= sum;\n    }\n    return result;", "    assert(numbers.size()\
    \ > 1);\n    // First and last number are the same\n    numbers[0] = 0.0;\n  \
    \  numbers[numbers.size() - 1] = 1;\n    // First two numbers are always 0.0\n\
    \    numbers[1] = 0.0;\n    numbers[2] = 0.0;\n    // Calculate the average\n\
    \    float sum = numbers[0] + numbers[1] + numbers[2];\n    float avg = sum /\
    \ numbers.size();\n    // Subtract the average from every number\n    for (size_t\
    \ i = 3; i < numbers.size(); i++) {\n        numbers[i] = (numbers[i] - avg) /\
    \ sum;\n    }\n    return numbers;", "    std::vector<float> new_numbers;\n  \
    \  std::transform(numbers.begin(), numbers.end(), std::back_inserter(new_numbers),\
    \ [](float value){return (float)((value - numbers.front()) / (numbers.back() -\
    \ numbers.front()));});\n    return new_numbers;", "    int n = numbers.size();\n\
    \    if (n <= 1) {\n        numbers.push_back(numbers[0]);\n        return numbers;\n\
    \    }\n    numbers.push_back(0.0);\n    numbers.push_back(1.0) / numbers[0];\n\
    \    for (int i = 1; i < n; ++i) {\n        numbers[i] /= numbers[i - 1];\n  \
    \  }\n    return numbers;", "    std::vector<float> new_numbers = numbers;\n\n\
    \    // Compute the min and max of the vector\n    auto min_number = new_numbers[0];\n\
    \    auto max_number = new_numbers[0];\n    for (size_t i = 1; i < new_numbers.size();\
    \ ++i) {\n        min_number = std::min(min_number, new_numbers[i]);\n       \
    \ max_number = std::max(max_number, new_numbers[i]);\n    }\n\n    // Compute\
    \ the ratio of max to min\n    auto max_to_min = max_number / min_number;\n\n\
    \    // Scale the vector\n    for (size_t i = 0; i < new_numbers.size(); ++i)\
    \ {\n        new_numbers[i] *= max_to_min;\n    }\n\n    return new_numbers;",
  "    assert(numbers.size() > 0);\n    int n = numbers.size();\n    std::vector<float>\
    \ result;\n    for (int i = 0; i < n; i++) {\n        float min = numbers[0];\n\
    \        float max = numbers[0];\n        for (int j = 0; j < n; j++) {\n    \
    \        min = std::min(min, numbers[j]);\n            max = std::max(max, numbers[j]);\n\
    \        }\n        result[i] = (max - min) / 2.0 + min;\n    }\n    return result;",
  "\tif (numbers.empty()) return std::vector<float>();\n\tstd::vector<float> numbers_scaled;\n\
    \tnumbers_scaled.reserve(numbers.size());\n\tauto min_element = numbers.front();\n\
    \tauto max_element = numbers.back();\n\tassert(min_element >= 0);\n\tassert(max_element\
    \ <= 1);\n\tnumbers_scaled.push_back((min_element + (max_element - min_element)\
    \ * (numbers.front() - min_element)) / 2);\n\tfor (auto i : numbers)\n\t\tnumbers_scaled.push_back((i\
    \ - (min_element + (max_element - min_element) * (numbers.front() - min_element))\
    \ / 2));\n\tassert(numbers_scaled.size() == numbers.size());\n\treturn numbers_scaled;",
  "    std::vector<float> unit;\n    unit.push_back(numbers[0]);\n    float largest\
    \ = numbers[0];\n    float smallest = numbers[0];\n    size_t index = 0;\n   \
    \ for (size_t i = 1; i < numbers.size(); i++) {\n        if (numbers[i] < smallest)\
    \ {\n            smallest = numbers[i];\n        }\n        if (numbers[i] > largest)\
    \ {\n            largest = numbers[i];\n        }\n    }\n    float ratio = smallest\
    \ / largest;\n    for (size_t i = 1; i < numbers.size(); i++) {\n        unit[i]\
    \ = numbers[i] * ratio;\n    }\n    return unit;", "    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    assert(min < max);\n    float range = max - min;\n    assert(range > 0);\n\
    \    float result = 0.0;\n    for (auto v : numbers) {\n        float curr_range\
    \ = (v - min);\n        curr_range = (curr_range / range) * 2.0 + 1.0;\n     \
    \   curr_range = (curr_range > 1.0) ? 1.0 : curr_range;\n        curr_range =\
    \ (curr_range < 0.0) ? 0.0 : curr_range;\n        result = result + curr_range;\n\
    \    }\n    return result;", "    assert(numbers.size() >= 2);\n    auto [min,\
    \ max] = std::minmax_element(numbers.begin(), numbers.end());\n    // min: 0.0,\
    \ max: 1.0\n    min = std::max(min, 0.0);\n    max = std::min(max, 1.0);\n   \
    \ // min: 0.0, max: 1.0\n    std::vector<float> out(numbers);\n    for (float\
    \ &num : out) {\n        // num: 0.0, 0.25, 0.5, 0.75, 1.0\n        // num: min,\
    \ min, min, min, max\n        num = std::min(max, std::max(num - min, 0.0f));\n\
    \    }\n    return out;", "    if (numbers.empty()) return {0};\n    assert(numbers.size()\
    \ >= 2);\n    auto low = numbers[0];\n    auto high = numbers[0];\n    \n    for\
    \ (auto number : numbers) {\n        if (number < low) low = number;\n       \
    \ if (number > high) high = number;\n    }\n    \n    auto factor = 1.0 / (high\
    \ - low);\n    \n    auto rescaled = {0.0};\n    \n    for (auto number : numbers)\
    \ {\n        rescaled.push_back((number - low) * factor);\n    }\n    \n    return\
    \ rescaled;", "  assert(numbers.size() > 1);\n  float minimum = *std::min_element(numbers.begin(),\
    \ numbers.end());\n  float maximum = *std::max_element(numbers.begin(), numbers.end());\n\
    \  float scale = (maximum - minimum) / numbers.back();\n  numbers.front() = (maximum\
    \ - scale) / numbers.back();\n  numbers.back() = maximum + scale;\n  return numbers;",
  "    // Your code here\n    assert(numbers.size()>2);\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==0.0;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==1.0;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==-1.0;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==2.0;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==-2.0;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==0.5f;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==0.75f;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==1.0f;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==-1.f;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==2.f;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==-2.f;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==0.5f;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==0.75f;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==1.0f;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==-1.f;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==2.f;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==-2.f;}),numbers.end());\n    numbers.erase(std::remove_if(numbers.begin(),\
    \ numbers.end(), [](float n){return n==0.5f;}),numbers.", "    std::vector<float>\
    \ rescaled_numbers = numbers;\n    for (float number : rescaled_numbers) {\n \
    \       rescaled_numbers[0] = (float) number;\n        rescaled_numbers[1] = (float)\
    \ (number / numbers[0]);\n    }\n    return rescaled_numbers;", "    if (numbers.empty())\
    \ {\n        return numbers;\n    }\n    std::vector<float> new_numbers;\n   \
    \ for (auto &number : numbers) {\n        if (number <= 0.0) {\n            new_numbers.push_back(0.0\
    \ / number);\n        } else {\n            new_numbers.push_back(1.0 / number);\n\
    \        }\n    }\n    return new_numbers;", "    assert(numbers.size() >= 2);\n\
    \    float smallest = std::numeric_limits<float>::lowest();\n    float largest\
    \ = std::numeric_limits<float>::max();\n    for (size_t i = 0; i < numbers.size();\
    \ i++) {\n        smallest += numbers[i];\n        largest -= numbers[i];\n  \
    \      numbers[i] = ((numbers[i] - smallest) / (largest - smallest)) * 2.0f -\
    \ 1.0f;\n    }\n    return numbers;", "    if (numbers.empty()) {\n        return\
    \ std::vector<float>(numbers.begin(), numbers.begin() + 1);\n    }\n    // The\
    \ minimum number should be 0\n    assert(numbers[0] == 0.f);\n    // The maximum\
    \ number should be 1\n    assert(numbers[numbers.size() - 1] == 1.f);\n    std::vector<float>\
    \ returnNumbers;\n    double minNumber = 0;\n    double maxNumber = 1.0;\n   \
    \ for (auto number : numbers) {\n        minNumber = std::min(minNumber, number);\n\
    \        maxNumber = std::max(maxNumber, number);\n    }\n    returnNumbers.resize((int)maxNumber\
    \ - minNumber);\n    for (auto i = 0; i < returnNumbers.size(); i++) {\n     \
    \   returnNumbers[i] = 0.5f + ((float)minNumber + maxNumber - returnNumbers[i]\
    \ - 1) / maxNumber;\n    }\n    return returnNumbers;", "    assert(numbers.size()\
    \ > 2);\n    std::vector<float> result(numbers.begin(), numbers.end());\n    result[0]\
    \ = numbers[0];\n    result[1] = numbers[1] / numbers[0];\n    for (size_t i =\
    \ 2; i < numbers.size(); i++) {\n        result[i] = numbers[i] / result[1];\n\
    \    }\n    return result; // TODO: return vector", "    int max_val = std::numeric_limits<float>::max();\n\
    \    int min_val = std::numeric_limits<float>::min();\n    float rescaled_max\
    \ = max_val;\n    float rescaled_min = min_val;\n    for (int i = 0; i < numbers.size();\
    \ i++) {\n        rescaled_max = std::max(rescaled_max, numbers[i]);\n       \
    \ rescaled_min = std::min(rescaled_min, numbers[i]);\n    }\n    rescaled_max\
    \ = std::max(rescaled_max, min_val);\n    rescaled_min = std::min(rescaled_min,\
    \ max_val);\n    std::vector<float> rescaled;\n    rescaled.reserve(numbers.size());\n\
    \    for (auto &num : numbers) {\n        rescaled.push_back(num - rescaled_min)\
    \ / (rescaled_max - rescaled_min);\n    }\n    return rescaled;", "    assert(numbers.size()\
    \ > 1);\n    assert(numbers[0] > 0);\n    assert(numbers[0] <= 1);\n    assert(numbers[1]\
    \ >= 0);\n    std::vector<float> normalized_numbers;\n    normalized_numbers.reserve(numbers.size());\n\
    \    for (auto number : numbers) {\n        normalized_numbers.push_back(number\
    \ * numbers[0]);\n    }\n    return normalized_numbers;", "    float total = 0;\n\
    \    for (float n : numbers) total += n;\n    if (total < 1) return numbers;\n\
    \    numbers.push_back(1);\n    for (float n : numbers) numbers[0] -= n;\n   \
    \ if (numbers[0] < 0) numbers.erase(numbers.begin());\n    return numbers;", " \
    \   // Sort the elements of the vector, smallest first\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    // Determine number of elements for given number of elements\n\
    \    int n = numbers.size();\n    // Get the smallest and largest elements\n \
    \   float low = numbers[0];\n    float high = numbers[0];\n    // Determine linear\
    \ factor of new minimum and maximum\n    float scale_factor;\n    if (n >= 2)\
    \ {\n        scale_factor = (high - low) / (n - 1);\n    } else {\n        scale_factor\
    \ = 1.0;\n    }\n    // Iterate over all numbers and scale them\n    for (int\
    \ i = 0; i < n; i++) {\n        numbers[i] = (numbers[i] - low) / scale_factor;\n\
    \    }\n    return numbers;", "    double range[] = {numbers.front(), numbers.back()};\n\
    \    double lengths[] = {0.0, 1.0};\n    double scale = 1.0/(range[1] - range[0]);\n\
    \    for (size_t i = 1; i < numbers.size(); ++i) {\n        range[i] = range[i-1]\
    \ + (numbers[i] - range[i-1]) * scale;\n        lengths[i] = range[i] - range[i-1];\n\
    \    }\n    // scale back to [0, 1], since that is what we want.\n    std::vector<float>\
    \ rescaled(lengths);\n    for (size_t i = 0; i < rescaled.size(); ++i) {\n   \
    \     rescaled[i] = range[i] + (rescaled[i] - range[i])*scale;\n    }\n    return\
    \ rescaled;", "    assert(numbers.size() >= 2);\n    auto minimum = numbers[0];\n\
    \    auto maximum = numbers[0];\n    for (auto number : numbers) {\n        if\
    \ (number < minimum) {\n            minimum = number;\n        }\n        if (number\
    \ > maximum) {\n            maximum = number;\n        }\n    }\n\n    if (maximum\
    \ - minimum > 1e-5) {\n        auto range = (maximum - minimum) / 2.0f;\n    \
    \    auto range = std::abs(range);\n        auto offset = minimum - range / 2.0f;\n\
    \        std::vector<float> result;\n        result.reserve(numbers.size());\n\
    \        for (auto number : numbers) {\n            result.push_back((number -\
    \ offset) / range);\n        }\n        return result;\n    } else {\n       \
    \ return numbers;\n    }", "\tassert(numbers.size() > 1);\n\tassert(numbers.front()<=numbers.back());\n\
    \n\t// Find the minimum number and the maximum number\n\tfloat min_number = numbers[0];\n\
    \tfloat max_number = numbers[0];\n\tfor (auto number : numbers) {\n\t\tif (number\
    \ < min_number) {\n\t\t\tmin_number = number;\n\t\t}\n\t\tif (number > max_number)\
    \ {\n\t\t\tmax_number = number;\n\t\t}\n\t}\n\n\t// Rescale all the numbers to\
    \ [0, max_number - min_number]\n\tfor (auto number : numbers) {\n\t\tnumber =\
    \ (number - min_number) / (max_number - min_number);\n\t}\n\n\t// Zero all the\
    \ numbers\n\tfor (auto number : numbers) {\n\t\tnumber = 0;\n\t}\n\n\treturn numbers;",
  "    assert(numbers.size() >= 2);\n    auto rescale = [numbers](float number) {\n\
    \        return number / numbers[0];\n    };\n    numbers.resize(numbers.size()\
    \ - 1);\n    for (size_t i = 1; i < numbers.size() - 1; i++) {\n        numbers[i]\
    \ = rescale(numbers[i + 1]);\n    }\n    return numbers;", "    // Assert we have\
    \ at least two numbers in the list\n    assert(numbers.size() > 1);\n    // Start\
    \ with the smallest number being zero and the largest being one\n    std::vector<float>\
    \ result;\n    float min = numbers[0];\n    float max = numbers[0];\n    for (auto\
    \ x : numbers) {\n        if (x < min) min = x;\n        else if (x > max) max\
    \ = x;\n    }\n    // Iterate through all numbers and update the smallest and\
    \ largest number\n    for (auto x : numbers) {\n        float old_min = min;\n\
    \        float old_max = max;\n        // This number will be used to \"shift\"\
    \ the number after it is scaled to between 0 and 1\n        float new_min = old_min\
    \ + (x - old_min) / std::max(std::abs(old_max - old_min), 1e-6f);\n        float\
    \ new_max = old_max + (x - old_max) / std::min(std::abs(old_max - old_min), 1e-6f);\n\
    \        result.push_back((new_min - min) / (max - min));\n    }\n    return result;",
  "    std::size_t size = numbers.size();\n    float min = numbers[0];\n    float\
    \ max = numbers[0];\n\n    for (std::size_t i = 0; i < size; i++) {\n        min\
    \ = std::min(min, numbers[i]);\n        max = std::max(max, numbers[i]);\n   \
    \ }\n    \n    std::vector<float> result;\n    result.reserve(size);\n    \n \
    \   for (std::size_t i = 0; i < size; i++) {\n        float number = numbers[i]\
    \ - min;\n        result.push_back(number/((float)max - min));\n    }\n\n    return\
    \ result;", "\tassert(numbers.size() > 1);\n\tassert(numbers.front() > 0);\n\t\
    std::vector<float> new_vector;\n\tdouble min_value = std::numeric_limits<float>::min();\n\
    \tdouble max_value = std::numeric_limits<float>::max();\n\tfor (auto number :\
    \ numbers)\n\t\tnew_vector.push_back(min_value + (number - min_value) * (max_value\
    \ - min_value) / (numbers.back() - min_value));\n\treturn new_vector;", "    std::vector<float>\
    \ temp(numbers.begin() + 1, numbers.end());\n    // Find min and max of all numbers\n\
    \    float min = (float)numbers.front();\n    float max = (float)numbers.back();\n\
    \    // Compute scale factor between min and max\n    float scale_factor = (max\
    \ - min);\n    // Normalize all the numbers\n    for (float number : temp) {\n\
    \        number *= (scale_factor);\n    }\n    return temp;", "    std::vector<float>\
    \ rescaled_numbers(numbers.size());\n    // First sort the vector\n    std::sort(numbers.begin(),\
    \ numbers.end());\n    // Then find the range where the largest number will become\
    \ 0, and the smallest number will become 1\n    auto max_in_range = std::max_element(numbers.begin(),\
    \ numbers.end()) - numbers.begin();\n    auto min_in_range = std::min_element(numbers.begin(),\
    \ numbers.end()) - numbers.begin();\n    // Divide all numbers by the range so\
    \ that the smallest number will become 0\n    // and the largest will become 1\n\
    \    for (std::size_t i = 0; i < numbers.size(); ++i) {\n        rescaled_numbers[i]\
    \ = numbers[i] / max_in_range * 2 - min_in_range;\n    }\n    return rescaled_numbers;",
  "    // Create a histogram of the input vector\n    std::vector<float> histogram(numbers.begin(),\
    \ numbers.end());\n    // Apply a linear transformation to each value in histogram\n\
    \    for (auto value : histogram) {\n        value = value * 0.9 / std::min(std::max(value,\
    \ 0.0), 1.0);\n    }\n    return histogram;", "  if (numbers.empty()) return {};\n\
    \n  // sort numbers\n  std::sort(numbers.begin(), numbers.end());\n\n  // compute\
    \ maximum and minimum of vector\n  float max_val = numbers[0];\n  float min_val\
    \ = numbers[0];\n\n  for (const auto number : numbers) {\n    max_val = std::max(max_val,\
    \ number);\n    min_val = std::min(min_val, number);\n  }\n\n  // rescale each\
    \ element\n  float factor = max_val - min_val;\n\n  for (int i = 0; i < numbers.size();\
    \ i++) {\n    numbers[i] = (numbers[i] - min_val) / factor;\n  }\n\n  return numbers;",
  "    assert(numbers.size()>1);\n    float min_number = numbers[0];\n    float max_number\
    \ = numbers[0];\n    for (float number : numbers) {\n        if (number < min_number)\
    \ {\n            min_number = number;\n        }\n        if (number > max_number)\
    \ {\n            max_number = number;\n        }\n    }\n    // Rescale\n    for\
    \ (float number : numbers) {\n        number *=  (max_number-min_number) / (number-min_number);\n\
    \    }\n    return numbers;", "    // If no numbers, return empty vector\n   \
    \ if (numbers.empty()) return std::vector<float>();\n    // The smallest number\
    \ will be 0, and the largest will be 1\n    numbers.push_back(0);\n    numbers.push_back(1);\
    \ // Add 1 because we are not rescaling the first element\n    // The min and\
    \ max are now 0 and 1\n    // The mean is now 0.5 (the sum of all the numbers)\n\
    \    numbers.push_back(numbers[0] + numbers[1]); // Add the middle value\n   \
    \ // The range is now 0.5 to 1\n    // The new numbers are the old numbers, minus\
    \ the mean and range (which is now 0)\n    return numbers;", "  int min_value\
    \ = numbers[0];\n  int max_value = numbers[0];\n  for (int i = 1; i < numbers.size();\
    \ ++i) {\n    if (numbers[i] < min_value) min_value = numbers[i];\n    if (numbers[i]\
    \ > max_value) max_value = numbers[i];\n  }\n  std::vector<float> result;\n  result.push_back(min_value);\n\
    \  result.push_back((max_value - min_value) / 2);\n  result.push_back(max_value);\n\
    \  return result;", "\tassert(numbers.size() > 1);\n\tstd::vector<float> new_numbers;\n\
    \tfloat smallest_number = numbers[0];\n\tfloat largest_number = numbers[0];\n\n\
    \tfor (int i = 0; i < numbers.size(); i++) {\n\t\tif (numbers[i] > largest_number)\
    \ {\n\t\t\tlargest_number = numbers[i];\n\t\t} else if (numbers[i] < smallest_number)\
    \ {\n\t\t\tsmallest_number = numbers[i];\n\t\t}\n\t}\n\n\tfor (int i = 0; i <\
    \ numbers.size(); i++) {\n\t\tnew_numbers.push_back(smallest_number + (numbers[i]\
    \ - smallest_number) * (largest_number - smallest_number) / (largest_number -\
    \ smallest_number));\n\t}\n\n\treturn new_numbers;", "\tassert(numbers.size()\
    \ > 1);\n\tauto x_min = std::min(numbers.front(), numbers.back());\n\tauto x_max\
    \ = std::max(numbers.front(), numbers.back());\n\tassert(x_min < x_max);\n\tnumbers.front()\
    \ = x_min;\n\tnumbers.back() = x_max;\n\tnumbers.front() = x_min - (x_min - numbers.back())\
    \ / numbers.front();\n\tnumbers.back() = x_max - (x_max - numbers.front()) / numbers.back();\n\
    \tstd::transform(numbers.begin(), numbers.end(), numbers.begin(), [](float n)\
    \ {return (n - numbers.front()) / (numbers.back() - numbers.front());});\n\treturn\
    \ numbers;", "  // assert(numbers.size() > 1);\n  // assert(numbers.size() <=\
    \ 50);\n  // assert(numbers.front()>0);\n  // assert(numbers.back()<1);\n\n  //\
    \ Sort smallest to largest\n  std::sort(numbers.begin(), numbers.end());\n\n \
    \ // Find the smallest and largest element in the unsorted vector\n  float smallest\
    \ = numbers[0];\n  float largest = numbers[0];\n  for (float x : numbers) {\n\
    \    if (x < smallest) {\n      smallest = x;\n    } else if (x > largest) {\n\
    \      largest = x;\n    }\n  }\n\n  // Find the difference of smallest and largest\
    \ element\n  float difference = largest - smallest;\n\n  // Multiply all the numbers\
    \ by a scale factor of (difference / largest)\n  // Multiply by 1.0 to make sure\
    \ we round towards zero\n  float scale = 1.0f / difference;\n  std::vector<float>\
    \ rescaled;\n  rescaled.reserve(numbers.size());\n  for (float number : numbers)\
    \ {\n    rescaled.push_back(number * scale);\n  }\n  return rescaled;", "    assert(numbers.size()\
    \ > 1);\n    const float scale = std::min(numbers[0] * numbers[1], (numbers[0]\
    \ + numbers[1]) * numbers[2]);\n    numbers.erase(numbers.begin());\n    numbers.insert(numbers.begin(),\
    \ 1.0);\n    numbers.insert(numbers.end(), scale / numbers.size());\n    return\
    \ numbers;", "    assert(numbers.size() > 1);\n    float min = *std::min_element(numbers.begin(),\
    \ numbers.end());\n    float max = *std::max_element(numbers.begin(), numbers.end());\n\
    \    assert(min < max);\n    // Make sure to keep original range by making sure\
    \ min is smaller than max\n    numbers[0] = max;\n    numbers[numbers.size() -\
    \ 1] = min;\n    // Rescale\n    for (size_t i = 0; i < numbers.size(); i++) {\n\
    \        if (numbers[i] > 0.0f)\n            numbers[i] = numbers[i] / max;\n\
    \        else\n            numbers[i] = 0.0f - numbers[i];\n    }\n    return\
    \ numbers;", "    assert(numbers.size() >= 2);\n    std::vector<float> result;\n\
    \    result.push_back(numbers[0]);\n    result.push_back(numbers[1]);\n    for\
    \ (float number : numbers) {\n        result.push_back((number - numbers[0]) /\
    \ (numbers[1] - numbers[0]));\n    }\n    return result;", "    std::vector<float>\
    \ result;\n    int n = numbers.size();\n    float min_val = numbers[0];\n    float\
    \ max_val = numbers[0];\n    for (int i = 1; i < n; ++i) {\n        if (numbers[i]\
    \ < min_val) min_val = numbers[i];\n        else if (numbers[i] > max_val) max_val\
    \ = numbers[i];\n    }\n    for (int i = 0; i < n; ++i) {\n        result[i] =\
    \ (numbers[i] - min_val) / (max_val - min_val);\n    }\n    return result;"]
stop_tokens:
- "\n}"
