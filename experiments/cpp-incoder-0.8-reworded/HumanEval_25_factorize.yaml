name: HumanEval_25_factorize
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return vector of prime factors\
  \ of given integer in the order from smallest to largest.\n// Each of the factors\
  \ should be vectored number of times corresponding to how many times it appeares\
  \ in factorization.\n// Input number should be equal to the product of all factors\n\
  // >>> factorize((8))\n// (std::vector<long>({(long)2, (long)2, (long)2}))\n// >>>\
  \ factorize((25))\n// (std::vector<long>({(long)5, (long)5}))\n// >>> factorize((70))\n\
  // (std::vector<long>({(long)2, (long)5, (long)7}))\nstd::vector<long> factorize(long\
  \ n) {\n"
tests: "}\nint main() {\n    auto candidate = factorize;\n    assert(candidate((2))\
  \ == (std::vector<long>({(long)2})));\n    assert(candidate((4)) == (std::vector<long>({(long)2,\
  \ (long)2})));\n    assert(candidate((8)) == (std::vector<long>({(long)2, (long)2,\
  \ (long)2})));\n    assert(candidate((57)) == (std::vector<long>({(long)3, (long)19})));\n\
  \    assert(candidate((3249)) == (std::vector<long>({(long)3, (long)3, (long)19,\
  \ (long)19})));\n    assert(candidate((185193)) == (std::vector<long>({(long)3,\
  \ (long)3, (long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((20577))\
  \ == (std::vector<long>({(long)3, (long)19, (long)19, (long)19})));\n    assert(candidate((18))\
  \ == (std::vector<long>({(long)2, (long)3, (long)3})));\n}\n"
completions: ["    std::vector<long> v; // Store all prime factors of n in this vector.\n\
    \    long i = 2; // Initialize i to 2.\n    long f = 1; // Initialize f to 1.\n\
    \n    while (i < n) { // While i is less than n.\n        while ((n % i) == 0)\
    \ { // While n is a multiple of i.\n            v.push_back(i); // Add i to v.\n\
    \            n = n / i; // Divide n by i.\n            f++; // Increment f to\
    \ 1.\n        }\n        i++; // Increment i to 1.\n    }\n    if (f != 1) //\
    \ If f was not equal to 1\n        v.push_back(static_cast<long>(f)); // Then\
    \ add f to v.\n    return v;", "  std::vector<long> factors(n);\n  std::vector<long>::iterator\
    \ p;\n  long n = n;\n  long res = 1;\n  int i = 1;\n  while (n != 0) {\n    p\
    \ = find(factors.begin(), factors.end(), n);\n    if (p != factors.end()) factors[p]++;\n\
    \    else {\n      factors.push_back(n);\n      break;\n    }\n    res = res *\
    \ i;\n    i = i + 1;\n    n = n / i;\n  }\n  return factors;", "    // Initilize\
    \ all factors to zero\n    std::vector<long> factorize(n,0);\n    long d = 2;\n\
    \    // Find next prime factor of n\n    while (!(n/d).is_integer()) {\n     \
    \   ++d;\n    }\n    // If there are two factors of n, then return (n,2)\n   \
    \ if (n/d==2) {\n        return std::vector<long>({n,2});\n    }\n    // If there\
    \ are no factors of n, then return the prime factors of n\n    std::vector<long>\
    \ prime_factors(n, 1);\n    for (long p; p*d<=n; p+=d) {\n        // If any of\
    \ the factors of p are prime.\n        if (prime_factors[p]==1) {\n          \
    \  // Add the prime factors of p to factorize.\n            factorize[p] = prime_factors;\n\
    \            // Remove the prime factors of p from its prime factorization.\n\
    \            prime_factors = prime_factors.erase(p);\n        }\n    }\n    return\
    \ factorize;", "\t// Base case\n\tif (n == 1 || n == 2) {\n\t\treturn { n };\n\
    \t}\n\t// If n is odd or even, there are many solutions, so we won't check it.\n\
    \tstd::vector<long> factors;\n\t// Try dividing by 2 first\n\tstd::vector<long>\
    \ factors2;\n\tif (n % 2 == 0) {\n\t\tfactors2 = factorize(n/2);\n\t}\n\tfactors.reserve(factors2.size());\n\
    \tstd::transform(factors2.begin(), factors2.end(), std::back_inserter(factors),\
    \ [](long x) { return x * 2; });\n\tif (n % 2 == 1) {\n\t\tfactors.push_back(2);\n\
    \t}\n\t// Try dividing by 3 next\n\tif (n % 3 == 0) {\n\t\tstd::vector<long> factors3\
    \ = factorize(n / 3);\n\t\tstd::transform(factors3.begin(), factors3.end(), std::back_inserter(factors),\
    \ [](long x) { return x * 3; });\n\t\tif (n % 3 == 1) {\n\t\t\tfactors.push_back(3);\n\
    \t\t}\n\t\t// Try dividing by 5 next\n\t\tif (n % 5 == 0) {\n\t\t\tstd::vector<long>\
    \ factors5 = factorize(n / 5);\n\t\t\tstd::transform(factors5.begin(), factors5.end(),\
    \ std::back_inserter(factors), [](long x) { return x * 5; });\n\t\t\tif (n % 5\
    \ == 1) {\n\t\t\t\tfactors.push_back(5);\n\t\t\t}\n\t\t\t// Try dividing by 7\
    \ next\n\t\t\tif (n % 7 == 0) {\n\t\t\t\tstd::vector<long> factors7 = factorize(n\
    \ / 7);\n\t\t\t\tstd::transform(factors7.begin(), factors7.end(), std::back_inserter(factors),\
    \ [](long x) { return x * 7; });\n\t\t\t\tif (n % 7 == 1) {\n\t\t\t\t\tfactors.push_back(7);\n\
    \t\t\t\t}\n\t\t\t\t// Try dividing by 9 next\n\t\t\t\tif (n % 9 == 0) {\n\t\t\t\
    \t\tstd::vector<long> factors9 = factorize(n / 9);\n\t\t\t\t\tstd::transform(factors9.begin(),\
    \ factors9.end(), std::back_inserter(factors), [](long x) { return x * 9; });\n\
    \t\t\t\t\tif (n % 9 == 1) {\n\t\t\t\t\t\tfactors.push_back(9);\n\t\t\t\t\t}\n\t\
    \t\t\t\t// Try dividing by 11 next\n\t\t\t\t\tif (n % 11 == 0) {\n\t\t\t\t\t\t\
    std::vector<long> factors11 = factorize(n / 11);\n\t\t\t\t\t\tstd::transform(factors11.begin(),\
    \ factors11.end(), std::back_inserter(factors), [](long x) { return x * 11; });\n\
    \t\t\t\t\t\tif (n % 11 == 1) {\n\t\t\t\t\t\t\tfactors.push_back(11);\n\t\t\t\t\
    \t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn factors;", "    std::vector<long>\
    \ factorized(n, 1);\n    std::vector<long> primes = prime_factors(n);\n    for\
    \ (int i = 2; i < primes.size(); i++) {\n        factorized[i] += factorized(primes[i]);\n\
    \    }\n    return factorized;", "    std::vector<long> factors;\n    factors.push_back(n);\n\
    \    for (int i = 2; i < n; i++) {\n        while (n % i == 0) {\n           \
    \ factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n != 1)\
    \ {\n        factors.push_back(n);\n    }\n    return factors;", "    std::vector<long>\
    \ res;\n    if (n != 1) {\n        long curr = n;\n        while (curr != 1) {\n\
    \            if (n % curr == 0) {\n                curr = n / curr;\n        \
    \        res.push_back(n);\n            }\n            else {\n              \
    \  curr = 1;\n            }\n        }\n    }\n    return res;", "    // Initialize\
    \ vector for prime factorization\n    std::vector<long> factors(2);\n    // Initialize\
    \ vector for counting occurrences of prime factors\n    std::vector<long> count(2);\n\
    \    // Initialize flag for checking if current number is a prime number or not\n\
    \    bool isPrime = true;\n    // Initialize flag indicating whether to store\
    \ factors in descending order\n    bool descending = false;\n\n    // Generate\
    \ prime factorization of input number\n    for (long i = 3; i * i <= n; i += 2)\n\
    \        if (n % i == 0) {\n            // Found factor\n            factors[factors.size()\
    \ - 1] += i;\n            count[factors.size() - 1]++;\n            // Update\
    \ flag\n            isPrime = false;\n        }\n    // If input number is prime\
    \ then no factors found\n    if (isPrime)\n        return factors;\n\n    // Sort\
    \ vector of factors in descending order\n    std::sort(factors.begin(), factors.end(),\
    \ [&count](long a, long b) {\n        return count[b] < count[a];\n    });\n\n\
    \    // Reverse vector if flag is set\n    if (descending)\n        std::reverse(factors.begin(),\
    \ factors.end());\n    return factors;", "    std::vector<long> factor;\n    long\
    \ s = 2;\n    long d = n - 1;\n    while (d % s == 0) {\n        s = s + 1;\n\
    \        d = d / s;\n    }\n    factor.push_back(s);\n    while (d != 1) {\n \
    \       d = d / s;\n        factor.push_back(d);\n    }\n    return factor;",
  "  std::vector<long> factors(0);\n  int i = 1;\n  factors.push_back(n);\n  while\
    \ (i < n) {\n    while ((n % i == 0)) {\n      n = n / i;\n      factors.push_back(i);\n\
    \    }\n    i++;\n  }\n  return factors;", "    if (n == 1) return std::vector();\n\
    \    std::vector<long> factors;\n    long i = 2;\n    std::vector<long> factorization(n);\n\
    \    for (long i = 0; i <= n; i++) {\n        long f = i;\n        while ((f %\
    \ i) == 0) {\n            f = i / i;\n            factorization.push_back(f);\n\
    \        }\n    }\n    for (int i = 0; i < factorization.size(); i++) {\n    \
    \    if (factorization[i] > i) {\n            factors.push_back(factorization[i]);\n\
    \        }\n    }\n    return factors;", "    std::vector<long> factors;\n   \
    \ factorize(n, factors);\n    return factors;", "    std::vector<long> factorization;\n\
    \    long current = n;\n    bool isPrime = true;\n    while (current != 1) {\n\
    \        isPrime = true;\n        for (int i = 2; i <= current / i; i++) {\n \
    \           if (current % i == 0) {\n                isPrime = false;\n      \
    \          break;\n            }\n        }\n        if (isPrime) {\n        \
    \    factorization.push_back(current);\n            current = (current / 2);\n\
    \        }\n    }\n    return factorization;", "    std::vector<long> result;\n\
    \    for (long factor = 2; factor * factor <= n; factor += 1) {\n        while\
    \ (n % factor == 0) {\n            result.push_back(factor);\n            n /=\
    \ factor;\n        }\n    }\n    if (n != 1) {\n        result.push_back(n);\n\
    \    }\n    std::sort(result.begin(), result.end());\n    return result;", " \
    \   std::vector<long> factors;\n    long c = n;\n    long q = 2;\n    while (c\
    \ != 1 && q * q < c) q *= c;\n    if (c == 1) {\n        factors.push_back(q);\n\
    \        return factors;\n    }\n    q++;\n    for (long i = 2; i * i <= c; i++)\
    \ {\n        while ((c % i) == 0) {\n            c /= i;\n            q++;\n \
    \       }\n        factors.push_back(q);\n    }\n    return factors;", "    std::vector<long>\
    \ factors;\n    long p = n;\n    long i = 2;\n    while (i <= sqrt(p)) {\n   \
    \     if (p % i == 0) {\n            factors.push_back(i);\n            p = p\
    \ / i;\n            while (p % i == 0) {\n                factors.push_back(i);\n\
    \                p = p / i;\n                ++i;\n            }\n        } else\
    \ {\n            ++i;\n        }\n    }\n    return factors;", "    int primes[N];\n\
    \    long factor = 1;\n    for (int i = 2; i <= n / factor; i++) {\n        if\
    \ (n % i == 0) {\n            primes[i / factor]++;\n        }\n    }\n    std::vector<long>\
    \ factorized;\n    for (int i = 1; i <= n; i++) {\n        if (primes[i] == 0)\
    \ {\n            factorized.push_back(factor);\n            factor *= i;\n   \
    \     }\n    }\n    return factorized;", "    std::vector<long> factors;\n   \
    \ if (n == 1) {\n        factors.push_back(n);\n        return factors;\n    }\n\
    \    long m = n;\n    while (m % 2 == 0) {\n        m = m / 2;\n    }\n    long\
    \ a = 2;\n    long b = 1;\n    while (1) {\n        while (b & 1 == 0) {\n   \
    \         b = b << 1;\n        }\n        a = a + b;\n        while (a < m) {\n\
    \            if (m % a == 0) {\n                factors.push_back(a);\n      \
    \          m = m/a;\n                break;\n            }\n            a = a\
    \ + 1;\n        }\n        if (a == m) {\n            break;\n        }\n    \
    \    b = a * 2;\n    }\n    if (n > 1) {\n        for (int i = 0; i < factors.size()\
    \ - 1; ++i) {\n            if (n % factors[i] == 0 && factors[i] > 1) {\n    \
    \            factors[factors.size()-i-1] = factors[factors.size()-i-1] * factors[i];\n\
    \                break;\n            }\n        }\n    }\n    return factors;",
  "  std::vector<long> pf;\n  std::vector<long> f; // vector of factors found\n  for\
    \ (int i = 2; i <= n; i++) {\n    while (n % i == 0) {\n      f.push_back(i);\n\
    \      n /= i;\n    }\n  }\n  // find out how many times each factor appears\n\
    \  for (int i = 0; i < f.size(); i++) {\n    pf.push_back(f[i]);\n    pf[i] *=\
    \ pf.size();\n  }\n  // sort vector according to how many times each factor appears\n\
    \  sort(pf.begin(), pf.end());\n  return pf;", "  // Use vector to store prime\
    \ factors\n  std::vector<long> factors;\n  for (long i = 2; i < n; i++) {\n  \
    \  while (n % i == 0) {\n      factors.push_back(i);\n      n = n / i;\n    }\n\
    \  }\n  return factors;", "    std::vector<long> factorization(n + 1, 1);\n  \
    \  for (long i = 2; i <= n; i++)\n        for (long j = 0; j < factorization[i];\
    \ j++)\n            if (n % i == 0 && i != j) {\n                factorization[i]\
    \ = j;\n                break;\n            }\n    return factorization;", " \
    \   std::vector<long> factors;\n    long sqr = sqr(n);\n    // Find the primes\
    \ of divisors of sqr\n    for (int i = 0; i < sqr; i++) {\n        int j = i;\n\
    \        for (; j < sqr; j += i) {\n            if (n % j == 0) {\n          \
    \      break;\n            }\n        }\n        if (j > i) {\n            factors.push_back(j);\n\
    \            n = n / j;\n        }\n    }\n    if (n != 0) {\n        factors.push_back(n);\n\
    \    }\n    return factors;", "    std::vector<long> vec;\n    for (long i = 1;\
    \ i <= n; i++) {\n        vec.push_back(i);\n        std::vector<long>::iterator\
    \ it = std::find(vec.begin(), vec.end(), i);\n        while (it != vec.end())\
    \ {\n            it--;\n            vec.erase(it);\n        }\n    }\n    return\
    \ vec;", "  assert(n > 0);\n  std::vector<long> factors; // to store factors whose\
    \ size is equal to number of occurrences\n  factors.reserve(n);\n  // Step 1:\
    \ Find the prime factors\n  for (long i = 1; i <= sqrt(n); i++) {\n    if (n %\
    \ i == 0) {\n      factors.push_back(i);\n      factors.push_back(n / i);\n  \
    \  }\n  }\n  // Step 2: Check if factors are in the correct order\n  std::sort(factors.begin(),\
    \ factors.end()); // sort the factors in ascending order\n  if (factors[0] !=\
    \ 2) {\n    factors.push_back(2);\n  }\n  if (factors[factors.size() - 1] != n)\
    \ {\n    factors.push_back(factors[factors.size() - 1]);\n  }\n  return factors;",
  "    std::unordered_map<long, int> factor;\n    long product = n;\n    for (int\
    \ i = 1; i <= static_cast<int>(std::ceil(std::sqrt(n))); ++i) {\n        while\
    \ (product % i == 0) {\n            product /= i;\n            ++factor[i];\n\
    \        }\n    }\n    std::vector<long> v(factor.begin(), factor.end());\n  \
    \  std::sort(v.begin(), v.end(), [product](long x, long y) {\n        return std::abs(product\
    \ - x) < std::abs(product - y);\n    });\n    return v;", "  std::vector<long>\
    \ factors;\n  long curr = 1, count = 0;\n  while (true) {\n    while (n % curr)\
    \ {\n      curr = curr << 1;\n      count++;\n    }\n    if (curr == 1) {\n  \
    \    factors.push_back(curr);\n      count--;\n      continue;\n    }\n    curr\
    \ = curr << 1;\n    factors.push_back(curr);\n    count--;\n  }\n  if (count !=\
    \ 1) {\n    factors.push_back(1);\n  }\n  return factors;", "    std::vector<long>\
    \ vec;\n    auto p = 1LL;\n    while (p * p <= n) {\n        if (n % p == 0) {\n\
    \            vec.push_back(p);\n            while (n / p == 0) {\n           \
    \     vec.push_back(p);\n                n /= p;\n            }\n            if\
    \ (n != 1)\n                vec.push_back(n);\n            n /= p;\n        }\n\
    \        p++;\n    }\n    return vec;", "    std::vector<long> factorization;\n\
    \    int i, k;\n    for (i = 2; i <= n / i; ++i) {\n        k = n;\n        while\
    \ (k % i == 0) {\n            k = k / i;\n        }\n        factorization.push_back(i);\n\
    \        factorization.push_back(k);\n    }\n    return factorization;", "   \
    \ std::vector<long> factors;\n    long num = 1;\n    for (long i = 2; i <= n /\
    \ i; ++i) {\n        if (n % i == 0) {\n            factors.push_back(i);\n  \
    \          num *= i;\n        }\n    }\n    factors.push_back(num);\n    return\
    \ factors;", "    std::vector<long> res;\n    long cur = n;\n    while (cur >\
    \ 2) {\n        while (cur % 2 == 0) {\n            long d = 2;\n            while\
    \ (cur % d == 0) {\n                d += 2;\n            }\n            res.push_back(d\
    \ / 2);\n            cur /= d;\n        }\n        while (cur % 3 == 0) {\n  \
    \          long d = 3;\n            while (cur % d == 0) {\n                d\
    \ += 3;\n            }\n            res.push_back(d / 3);\n            cur /=\
    \ d;\n        }\n        while (cur % 5 == 0) {\n            long d = 5;\n   \
    \         while (cur % d == 0) {\n                d += 5;\n            }\n   \
    \         res.push_back(d / 5);\n            cur /= d;\n        }\n        cur\
    \ /= 2;\n    }\n    res.push_back(n);\n    return res;", "  std::vector<long>\
    \ result;\n  // Check for factors\n  long i = 2;\n  while (n != 1) {\n    while\
    \ (n % i == 0) {\n      result.push_back(i);\n      n = n / i;\n    }\n    i++;\n\
    \  }\n  if (n != 1) {\n    result.push_back(n);\n  }\n  return result;", "\t//\
    \ n is divided by 2 until it becomes integer and remainder is 1, otherwise n is\
    \ prime\n\t// if n is prime number then all its prime factors are 1\n\tstd::vector<long>\
    \ factors;\n\tfactors.push_back(n);\n\tint i = 2;\n\twhile (n % i == 0) {\n\t\t\
    factors.push_back(i);\n\t\tn = n / i;\n\t}\n\tif (n != 1) {\n\t\tfactors.push_back(n);\n\
    \t}\n\treturn factors;", "  std::vector<long> result;\n  if (n == 1) {\n    result.push_back(1);\n\
    \    return result;\n  }\n  if (n == 2) {\n    result.push_back(1);\n    return\
    \ result;\n  }\n  std::vector<long> factors = factorize(n);\n  std::sort(factors.begin(),\
    \ factors.end());\n  // Scan the factors starting from smallest and count how\
    \ many times each one appeared.\n  // For this we need to keep track of how many\
    \ factors were already seen.\n  std::vector<long> already_seen(factors.size(),\
    \ 0);\n  result.push_back(n);\n  // Scan the factors, skipping those that are\
    \ already seen.\n  // If we see a factor, then subtract it from the seen count\
    \ for the previous number and add it to the result.\n  for (int i = 0; i < factors.size();\
    \ i++) {\n    while (already_seen[factors[i]] > 0) {\n      already_seen[factors[i]\
    \ - 1]--;\n    }\n    result.push_back(factors[i]);\n    already_seen[factors[i]]++;\n\
    \  }\n  return result;", "\tstd::vector<long> factors(0, 1);\n\tlong s = sqrt(n);\n\
    \tlong q = n;\n\tfor (long i = 2; i <= s; ++i) {\n\t\tif (q % i == 0) {\n\t\t\t\
    while (q % i == 0) {\n\t\t\t\t++factors[i - 2];\n\t\t\t\tq /= i;\n\t\t\t}\n\t\t\
    }\n\t}\n\treturn factors;", "    std::vector<long> factors;\n    long curr = 0;\n\
    \    long curr2 = 0;\n    long total = 1;\n\n    while (n != 1) {\n        while\
    \ (n % curr == 0) {\n            curr++;\n            total *= curr;\n       \
    \ }\n        while (n % curr2 == 0) {\n            curr2++;\n            total\
    \ *= curr2;\n        }\n        if (curr == curr2) {\n            factors.push_back(total);\n\
    \            n /= curr2;\n            total /= curr;\n            curr2 = 0;\n\
    \            curr++;\n        }\n    }\n    return factors;", "    long max_factor\
    \ = 0;\n    std::vector<long> factors(max_factor + 1, 0);\n    long i, cur, fac,\
    \ factor = 1, pos = 0;\n    while ((n != 1) && (n != 0) && (factors[factor] ==\
    \ 0)) {\n        cur = n;\n        while ((cur != 1) && (cur != 0) && (factors[factor]\
    \ == 0)) {\n            fac = 0;\n            for (i = 0; i < factor.size(); i++)\
    \ {\n                if ((factor[i] * factor[pos]) < cur) {\n                \
    \    fac = i;\n                    factor = factor[i];\n                    pos\
    \ = i;\n                }\n            }\n            if (fac != 0) {\n      \
    \          factors[fac] += 1;\n            }\n            cur /= factor;\n   \
    \     }\n        max_factor++;\n        factors[max_factor] = 1;\n        n =\
    \ cur;\n    }\n    return factors;", "    if (n < 2) return {n};\n    std::vector<long>\
    \ result = {n};\n    for (long i = 2; i <= n/2; i++) {\n        while (n % i ==\
    \ 0) {\n            n /= i;\n            result.push_back(i);\n        }\n   \
    \ }\n    result.push_back(n);\n    return result;", "  std::vector<long> fac;\n\
    \  // If factor is 1 then just add it for loop\n  for (long i = 2; i <= sqrt(n);\
    \ i++) {\n    if (n % i == 0) {\n      fac.push_back(i);\n      fac.push_back(n/i);\n\
    \    }\n  }\n  // If n is divisible by any integer between 2 and sqrt(n) then\
    \ add it to fac\n  for (long i = 2; i*i <= n; i++) {\n    if (n % i == 0) {\n\
    \      fac.push_back(i);\n      fac.push_back(n/i);\n    }\n  }\n  // If n is\
    \ not divisible by any integer between 2 and sqrt(n) then remove its prime factor\
    \ and remove all its multiples from the factorization\n  long m = n;\n  fac.pop_back();\n\
    \  for (long i = 0; i < fac.size(); i++) {\n    while (m % fac[i] == 0) {\n  \
    \    fac.erase(fac.begin() + i);\n      m /= fac[i];\n    }\n  }\n  return fac;",
  "  // Factorization of n can be made in linear time\n  std::vector<long> factors;\n\
    \n  // If n is prime, return its prime factorization by itself\n  if (n == 1 ||\
    \ n == 0)\n    factors.push_back(1);\n  else if (n % 2 == 0) {\n    factors.push_back(2);\n\
    \    factors.push_back(n / 2);\n  } else {\n    long i = 2;\n    for (long c =\
    \ 3; c < n; c++) {\n      while (n % i == 0) {\n        factors.push_back(i);\n\
    \        n /= i;\n      }\n      i += 2;\n    }\n  }\n\n  return factors;", " \
    \   std::vector<long> ffactors(1, n);\n    for (auto i = 2; i < n; i++)\n    \
    \    if (n % i == 0)\n            ffactors[ffactors.size() - 1] *= i;\n    if\
    \ (ffactors.back() == 1)\n        ffactors.push_back(ffactors.back());\n    return\
    \ ffactors;", "    if (n == 0)\n        return {};\n    std::vector<long> factorization;\n\
    \    for (long i = 1; i <= n; ++i) {\n        while (n % i == 0) {\n         \
    \   factorization.push_back(i);\n            n /= i;\n        }\n    }\n    if\
    \ (n > 1)\n        factorization.push_back(n);\n    return factorization;", " \
    \   std::vector<long> factors(n);\n    long x = n;\n    long y = 1;\n    long\
    \ p = 1;\n    long k = 1;\n    while (x != 1) {\n        if ((x % y) == 0) {\n\
    \            factors[k] = y;\n            factors[++k] = x;\n            while\
    \ (x % y == 0) {\n                factors[--k] = y;\n                factors[++k]\
    \ = x % y;\n                x /= y;\n            }\n            p /= y;\n    \
    \    } else {\n            factors[k] = y;\n            factors[++k] = x;\n  \
    \          x /= y;\n        }\n        y *= 2;\n    }\n    return factors;", " \
    \   std::vector<long> factors;\n    long product = 1;\n    long factor = 1;\n\n\
    \    // find highest multiple of factor less than or equal to n\n    while (n\
    \ >= factor) {\n        factor *= factor;\n        ++factor;\n    }\n    if (n\
    \ <= 1) {\n        // no divisors exist less than or equal to n\n        factors.push_back(n);\n\
    \        return factors;\n    }\n\n    // find highest factor less than or equal\
    \ to n\n    while (n >= factor) {\n        factor *= factor;\n    }\n    product\
    \ = n;\n    factor = factor;\n    long divisor = 1;\n    while (product % factor\
    \ == 0) {\n        product /= factor;\n        divisor += 1;\n    }\n    while\
    \ (factor < product) {\n        ++factor;\n        divisor *= factor;\n    }\n\
    \    factors.push_back(divisor);\n    return factors;", "  if (n == 1) return\
    \ std::vector<long>({n});\n  std::vector<long> factors(factorization(n));\n  std::sort(factors.begin(),\
    \ factors.end());\n  std::vector<long> res;\n  long factor = 1;\n  for (long i\
    \ : factors) {\n    if (factor == 1) res.push_back(i);\n    else res.push_back(i\
    \ * factor);\n    factor++;\n  }\n  return res;", "    std::vector<long> factorize;\n\
    \    long k = 1, p = 1, f = 0;\n    while (f != n && (n % p) == 0) {\n       \
    \ factorize.push_back(p);\n        f = 0;\n        while (k <= n / p) {\n    \
    \        p = p * k;\n            k = k + 1;\n        }\n    }\n    if (f == n)\
    \ {\n        factorize.push_back(n);\n    }\n    return factorize;", "    // Write\
    \ your code here.\n    std::vector<long> a;\n    for (int i = 2; i < n / 2; i++)\
    \ {\n        while (n % i == 0)\n            a.push_back(i);\n        n = n /\
    \ i;\n    }\n    return a;", "    std::vector<long> vec;\n    long i = 1;\n  \
    \  while (n != 1) {\n        while (n % i == 0) {\n            vec.push_back(i);\n\
    \            n /= i;\n        }\n        i++;\n    }\n    return vec;", "    //\
    \ Store results of factorization here\n    std::vector<long> factor(n);\n\n  \
    \  // Prime factors of n\n    std::unordered_set<long> primes;\n    for (long\
    \ i = 1; i <= n; ++i) {\n        while (n % i == 0) {\n            factor[i] =\
    \ i;\n            n = n / i;\n            primes.insert(i);\n        }\n    }\n\
    \n    // Number of times each factor appeared in factorization\n    std::vector<long>\
    \ counts(primes.size());\n\n    // Iterate through factors to find how many times\
    \ they appeared in factorization\n    for (long i = 0; i < primes.size(); ++i)\
    \ {\n        long p = primes.find(i);\n        if (p != primes.end()) {\n    \
    \        long count = 0;\n            for (long j = p + 1; j < n; ++j) {\n   \
    \             if (n % j == 0) {\n                    ++count;\n              \
    \      while (n % j == 0) {\n                        n /= j;\n               \
    \         --count;\n                    }\n                }\n            }\n\
    \            counts[i] = count;\n        }\n    }\n\n    // Store results of factorization\
    \ here\n    for (long i = 0; i < primes.size(); ++i) {\n        long factor =\
    \ factor[i];\n        for (long j = 0; j < counts[i]; ++j) {\n            factor[factors.size()\
    \ - counts[i] - j] = factors[factors.size() - counts[i] - j - 1];\n        }\n\
    \    }\n\n    return factor;", "    std::vector<long> factors;\n    long m = n;\n\
    \    long p = 1;\n    while (m * p < n) {\n        p += 1;\n        m = m * p;\n\
    \    }\n    factors.push_back(n);\n    while (m) {\n        p = 2;\n        while\
    \ (m * p < n) {\n            p += 1;\n            m = m * p;\n        }\n    \
    \    factors.push_back(m);\n        n = n;\n        m = m;\n    }\n    factors.push_back(n);\n\
    \    return factors;", "    std::vector<long> factors(0, 1);\n    // Loop till\
    \ no more factors are found.\n    // A number has only two prime factors if and\
    \ only if they are 1.\n    while (n) {\n        int divisor = 2;\n        while\
    \ (n % divisor == 0) {\n            factors.push_back(divisor);\n            n\
    \ /= divisor;\n        }\n    }\n    return factors;", "    // TODO: Implement\n\
    \    long factors[1000000];\n    long p = 1ULL << n;\n    for (long i = 2; i <\
    \ p; i++) {\n        if (p%i == 0) {\n            factors[n - 1] = i;\n      \
    \      factors[n - 2] = i / factors[n - 1];\n            p = (p / i) * i;\n  \
    \      }\n    }\n    // std::cout << p << std::endl;\n    std::vector<long> res(n);\n\
    \    for (long i = 1; i < n; i++)\n        res[n - i - 1] *= factors[n - i];\n\
    \    return res;", "    std::vector<long> vec;\n    vec.push_back(n);\n    for\
    \ (int i = 2; i <= std::sqrt(n); i++) {\n        while (n % i == 0) {\n      \
    \      vec.push_back(i);\n            n /= i;\n        }\n    }\n    vec.push_back(n);\n\
    \    return vec;", "    std::vector<long> result;\n    // To store prime factors\
    \ of n.\n    std::vector<long> factors;\n    // To store count of how many times\
    \ each prime number appeared in the given factorization.\n    std::vector<long>\
    \ count_of_appearences;\n    // To store count of how many times each prime number\
    \ appeared in the given factorization.\n    std::vector<long> count_of_appearences_2;\n\
    \    // To store count of how many times each prime number appeared in the given\
    \ factorization.\n    std::vector<long> count_of_appearences_3;\n    // To store\
    \ count of how many times each prime number appeared in the given factorization.\n\
    \    std::vector<long> count_of_appearences_4;\n\n    long next_prime = 2, next_prime_2\
    \ = 2, next_prime_3 = 2, next_prime_4 = 0;\n\n    // Fill factors vector with\
    \ all prime factors of n.\n    while (next_prime < n) {\n        if (next_prime\
    \ % 2 == 0) {\n            factors.push_back((next_prime));\n        } else {\n\
    \            next_prime += next_prime;\n        }\n    }\n\n    // Fill count_of_appearences\
    \ vector with all prime factors of n.\n    while (next_prime < n) {\n        long\
    \ temp = next_prime;\n        next_prime += next_prime;\n\n        if (temp %\
    \ 2 == 0) {\n            count_of_appearences.push_back(temp);\n        } else\
    \ {\n            count_of_appearences.push_back(count_of_appearences[count_of_appearences.size()\
    \ - 1] + 1);\n        }\n    }\n\n    // Fill count_of_appearences_2 vector with\
    \ all prime factors of n.\n    while (next_prime_2 < n) {\n        long temp =\
    \ next_prime_2;\n        next_prime_2 += next_prime_2;\n\n        if (temp % 3\
    \ == 0) {\n            count_of_appearences_2.push_back(temp);\n        } else\
    \ {\n            count_of_appearences_2.push_back(count_of_appearences_2[count_of_appearences_2.size()\
    \ - 1] + 1);\n        }\n    }\n\n    // Fill count_of_appearences_3 vector with\
    \ all prime factors of n.\n    while (next_prime_3 < n) {\n        long temp =\
    \ next_prime_3;\n        next_prime_3 += next_prime_3;\n\n        if (temp % 4\
    \ == 0) {\n            count_of_appearences_3.push_back(temp);\n        } else\
    \ {\n            count_of_appearences_3.push_back(count_of_appearences_3[count_of_appearences_3.size()\
    \ - 1] + 1);\n        }\n    }\n\n    // Fill count_of_appearences_4 vector with\
    \ all prime factors of n.\n    while (next_prime_4 < n) {\n        long temp =\
    \ next_prime_4;\n        next_prime_", "    // write your code here\n    std::vector<long>\
    \ ans;\n    long cur;\n    long mod = n;\n    while (mod) {\n        cur = mod;\n\
    \        while (cur) {\n            mod = cur % cur;\n            cur /= cur;\n\
    \        }\n        ans.push_back(mod);\n    }\n    std::sort(ans.begin(), ans.end());\n\
    \    return ans;", "  std::vector<long> res;\n  long p = 1;\n  while (p < n) {\n\
    \    long q = 1;\n    while (p < n && q * p <= n) {\n      q *= p;\n    }\n  \
    \  if (p < q) {\n      res.push_back(q);\n    }\n    p = q + 1;\n  }\n  return\
    \ res;", "    std::vector<long> result;\n    long m = n;\n    long factor = 1;\n\
    \    // check whether given number is a prime number\n    while (m != 1) {\n \
    \       if (m%2 == 0) {\n            if (m != 1) {\n                m = m/2;\n\
    \                factor = factor*2;\n            }\n            else {\n     \
    \           result.push_back(1);\n                factor = 1;\n              \
    \  m = 1;\n            }\n        }\n        else {\n            m = m/2;\n  \
    \          factor = factor*2+1;\n        }\n    }\n    return result;", "  if\
    \ (n < 2)\n    return std::vector<long>();\n  std::multiset<long> factors;\n \
    \ for (long i = 2; i <= n / i; i++)\n    factors.insert(i);\n  std::vector<long>\
    \ res;\n  while (!factors.empty()) {\n    long f = factors.begin()->first;\n \
    \   factors.erase(factors.begin());\n    res.push_back(f);\n    for (long i =\
    \ 1; i <= n / f; i++)\n      if (n % i == 0)\n        factors.insert(i);\n  }\n\
    \  return res;", "    std::vector<long> factors;\n    long n = sqrt(n);\n    long\
    \ start = 2, end;\n    while (start * start + 1 <= n) {\n        if (n % start\
    \ == 0)\n            end = start + (n / start);\n        else {\n            end\
    \ = n;\n            break;\n        }\n        factors.push_back(start);\n   \
    \     start = end + 1;\n    }\n    factors.push_back(n);\n    return factors;",
  "    std::vector<long> factors;\n    if (n <= 1) return factors;\n    long k = 2;\n\
    \    while ((n % k) == 0) k++;\n    factors.push_back(k);\n    while (2 * k <=\
    \ n) k++;\n    while (n % k == 0) {\n        n = (n / k);\n        factors.push_back(k);\n\
    \    }\n    return factors;", "    std::vector<long> factors; // vectors containing\
    \ factorizations of given number\n    long i = 2;\n    long factor = 1;\n    while\
    \ (i <= n) {\n        while (n % i == 0) {\n            factors.push_back(factor);\n\
    \            n /= i;\n        }\n        i++;\n        factor++;\n    }\n    if\
    \ (n != 1) {\n        factors.push_back(factor);\n    }\n    return factors;",
  "    long i = 1, factorization[n];\n    while (i * i <= n) {\n        while (n %\
    \ i == 0) {\n            n /= i;\n            factorization[i]++;\n        }\n\
    \        i++;\n    }\n    if (n == 1)\n        return std::vector<long>{n};\n\
    \    return std::vector<long>{n};", "    // Vector to store factorization\n  \
    \  std::vector<long> factor;\n    long factorCount = 0;\n    // For storing prime\
    \ numbers less than n\n    long currentNum = n;\n    while (currentNum != 1) {\n\
    \        // Check whether current number is divisible by any other number\n  \
    \      long flag = 1;\n        for (long i = 1; i < currentNum; i++) {\n     \
    \       if (n % i == 0) {\n                flag = 0;\n                break;\n\
    \            }\n        }\n        // If no such number exists\n        if (flag\
    \ == 1) {\n            // If current number is not equal to 1\n            if\
    \ (currentNum != 1) {\n                // Increment factor count\n           \
    \     factorCount++;\n                // If factorcount is equal to 2, add it\
    \ to factor\n                if (factorCount == 2) {\n                    factor.push_back(i);\n\
    \                }\n            }\n        }\n        // Set new current number\n\
    \        currentNum /= 2;\n    }\n    return factor;", "    std::vector<long>\
    \ factors(n);\n    long n = 1;\n    for (long i = 1; i <= n; i++) {\n        long\
    \ temp = n;\n        while (temp % i == 0) {\n            factors[temp / i] =\
    \ factors[temp / i] + 1;\n            temp /= i;\n        }\n    }\n    return\
    \ factors;", "    // Initialization of vector to store factorization\n    std::vector<long>\
    \ res;\n    long cur = 1;\n    while (cur < n) {\n        while (n % cur == 0)\
    \ {\n            n /= cur;\n            res.push_back(cur);\n        }\n     \
    \   cur++;\n    }\n    res.push_back(n);\n    return res;", "    std::vector<long>\
    \ factorized(1, 1);\n    for (long i = 2; i < n; ++i) {\n        while (n % i\
    \ == 0) {\n            factorized[factorized.size() - 1] *= i;\n            n\
    \ /= i;\n        }\n    }\n    factorized[factorized.size() - 1] = n;\n    return\
    \ factorized;", "    std::vector<long> factors;\n    // Initialization to count\
    \ number of factors\n    long factor_count = 1;\n    // Iterating over all odd\
    \ integers from 1 to sqrt(n)\n    // for odd integers i. e. 1..sqrt(n), i.e sqrt(n)..\
    \ sqrt(n+1)-1\n    for (int i = 1; i <= sqrt(n); i += 2) {\n        // If n%i\
    \ == 0, then i is a factor of n\n        if (n % i == 0) {\n            // Incrementing\
    \ number of factors by 1\n            factor_count++;\n            // Adding i\
    \ to the vector\n            factors.push_back(i);\n            // Removing i\
    \ from the list of factors\n            factors.erase(std::remove(factors.begin(),\
    \ factors.end(), i), factors.end());\n        }\n    }\n    // Returning list\
    \ of factors\n    return factors;", "    std::vector<long> factors(0);\n    long\
    \ factor = 1;\n    long divisor = 1;\n    long m = 1;\n\n    while(n) {\n    \
    \    if(n % divisor == 0) {\n            factors.push_back(factor);\n        \
    \    divisor = divisor * factor;\n        }\n        factor *= m;\n        m++;\n\
    \        n /= factor;\n    }\n    return factors;", "    std::vector<long> vec;\n\
    \    for (int i = 2; i <= sqrt(n); i++) {\n        if (n % i == 0) {\n       \
    \     vec.push_back(i);\n            n /= i;\n        }\n    }\n    vec.push_back(n);\n\
    \    return vec;", "    std::unordered_map<long, std::vector<long>> factorization;\n\
    \n    auto factorize_innermost = [&](long n) {\n        std::vector<long> f;\n\
    \        for (long i = 1; i < n; ++i) {\n            long p = n;\n           \
    \ while (p * i < (i + 1)) {\n                p += i;\n            }\n        \
    \    f.push_back(p);\n        }\n\n        return f;\n    };\n\n    for (long\
    \ i = 2; i <= n; i++) {\n        std::vector<long> f;\n        while (n % i ==\
    \ 0) {\n            f.push_back(i);\n            n /= i;\n        }\n        if\
    \ (f.empty())\n            continue;\n\n        factorization[i].push_back(f);\n\
    \    }\n\n    if (n != 1)\n        factorization[1].push_back(n);\n\n    std::vector<long>\
    \ f;\n    for (long i = 0; i < 2; i++) {\n        for (auto f : factorization[i])\
    \ {\n            f.insert(f.end(), 1);\n            f.insert(f.end(), factorization[1][i]);\n\
    \        }\n    }\n\n    if (f.empty())\n        return std::vector<long>();\n\
    \n    return f;", "\t// Initialize vector with 0s.\n\tstd::vector<long> factor;\n\
    \tlong m = n;\n\n\t// Try dividing each number and store the number of times each\
    \ factor occurs in factorization vector\n\twhile (m > 0) {\n\t\tfor (int i = 2;\
    \ i < m; i++) {\n\t\t\tif (m % i == 0) {\n\t\t\t\tfactor.push_back(i); // Store\
    \ factor with number of occurrences\n\t\t\t\tm /= i; // Divide input number by\
    \ factor\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn factor;", "    std::vector<long>\
    \ f(n);\n    std::vector<long> fp(2*n, 1);\n    std::vector<long> fp2(2*n, 1);\n\
    \    std::vector<long> fp3(2*n, 1);\n    std::vector<long> fp4(2*n, 1);\n    long\
    \ a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n\
    \    long f = n;\n    while (b != 1) {\n        fp[0] = 1;\n        bool b1 =\
    \ false;\n        while (!b1 && !fp[0]) {\n            f[1] = 2;\n           \
    \ fp[1] = f[1] - 1;\n            while (!f[fp[1]]) {\n                fp[1]++;\n\
    \                fp[2] = fp[1];\n                fp3[fp[2]] = fp[3];\n       \
    \         fp4[fp[2]] = fp[4];\n                fp[fp[1]] = fp[fp[1] - 1];\n  \
    \              while (!f[fp[1]]) {\n                    fp[1]++;\n           \
    \         fp[2] = fp[1];\n                    fp3[fp[2]] = fp[3];\n          \
    \          fp4[fp[2]] = fp[4];\n                    fp[fp[1]] = fp[fp[1] - 1];\n\
    \                }\n            }\n            fp[2] = fp[1];\n            fp3[fp[2]]\
    \ = fp[3];\n            fp4[fp[2]] = fp[4];\n            fp[fp[1]] = fp[fp[1]\
    \ - 1];\n            fp[0] = fp[fp[0] - 1];\n            b1 = true;\n        }\n\
    \        e = fp[fp[0]];\n        f[1] = fp[fp[1]];\n        while (!f[1]) {\n\
    \            f[2] = f[1] + 1;\n            fp[2] = f[2];\n            while (!f[fp[2]])\
    \ {\n                fp[2]++;\n                fp[3] = fp[2];\n              \
    \  fp4[fp[3]] = fp[4];\n                fp[fp[2]] = fp[fp[2] - 1];\n         \
    \       while (!f[fp[2]]) {\n                    fp[2]++;\n                  \
    \  fp[3] = fp[2];\n                    fp4[fp[3]] = fp[4];\n                 \
    \   fp[fp[2]] = fp[fp[2] - 1];\n                }\n            }\n           \
    \ fp[3] = fp[2];\n            fp4[fp[3]] = fp[4];\n            fp[fp[2]] = fp[fp[2]\
    \ - 1];\n            f[1] = fp[fp[2]];\n            e = fp[fp[0]];\n         \
    \   f[2] = fp[fp[1]];\n        }\n        d += f[1];\n        if (e == 2) {\n\
    \            a *= e;\n            b *= e;\n            e /= 2;\n        }\n  \
    \      if (e != 1) {\n            f[1] = 2*e;\n            fp[1] = f[1] - 1;\n\
    \            while ((!f[fp", "  std::vector<long> primes;\n  std::vector<long>\
    \ factors; // Vector to store factors\n  // All prime numbers are initially prime\n\
    \  bool is_prime = true;\n  // Initialize factors and primes\n  for (int i = 1;\
    \ i < n; i++)\n    primes.push_back(i);\n  long factor = 1;\n  // Iterate until\
    \ we have all primes\n  while (is_prime) {\n    is_prime = false;\n    // Iterate\
    \ through all primes one by one\n    for (int i = 0; i < primes.size(); i++) {\n\
    \      // If current prime's number is not factor of the current prime, that prime\
    \ is not prime\n      if (factor % primes[i] != 0) {\n        is_prime = true;\n\
    \        // Skip the current prime\n        continue;\n      }\n      // If current\
    \ prime's number is factor, find it and multiply factors\n      for (int j = 0;\
    \ j < factors.size(); j++) {\n        // Multiply factor with current prime and\
    \ increment factors\n        factor *= primes[i];\n        factors.push_back(factor);\n\
    \      }\n    }\n  }\n  return factors;", "    std::vector<long> factors;\n  \
    \  long max_divisor = 1;\n    for (int i = 2; i <= n / 2; i++) {\n        if (n\
    \ % i == 0) {\n            max_divisor = i;\n            for (int j = i * 2; j\
    \ < n; j++) {\n                if (j % i == 0) {\n                    factors.push_back(i\
    \ * j / max_divisor);\n                    break;\n                }\n       \
    \     }\n        }\n    }\n    return factors;", "    std::vector<long> factors;\n\
    \    long count = 1;\n    factors.push_back(1);\n    for (int i = 2; i <= sqrt(n);\
    \ i++) {\n        if (n % i == 0) {\n            count *= i;\n            factors.push_back(i);\n\
    \            n /= i;\n        }\n    }\n    factors.push_back(n);\n    return\
    \ factors;", "    assert(n >= 2);\n    std::vector<long> fac;\n    fac[0] = std::sqrt(n);\n\
    \    long p = 1;\n    for (long i = 2; i <= fac[0]; i++) {\n        if (n % i\
    \ == 0) {\n            fac[p++] = i;\n            n /= i;\n        }\n    }\n\
    \    if (n > 1) {\n        fac[p++] = n;\n    }\n    return fac;", "    long max_factor\
    \ = 1;\n    long max_count = 0;\n    std::vector<long> factorized(n, 0);\n   \
    \ // Iterate through all primes till sqrt(n)\n    for (long i = 2; i < n; ++i)\
    \ {\n        while (n % i == 0) {\n            n = n / i;\n            ++factorized[i];\n\
    \        }\n        if (n > max_factor) max_factor = n;\n        if (factorized[i]\
    \ == max_count) break;\n        ++max_count;\n    }\n    return factorized;",
  "    std::vector<long> primes(n + 1, 1);\n    std::vector<long> factors(n + 1, 1);\n\
    \    factors[0] = 2;\n\n    for (int i = 3; i <= n; i += 2) {\n        while (n\
    \ % i == 0) {\n            factors[i] += 1;\n            while (n % i == 0) {\n\
    \                primes[i] += 1;\n                n /= i;\n            }\n   \
    \     }\n    }\n\n    // remove duplicates from factors vector\n    std::vector<long>\
    \ res(factors.begin(), factors.end());\n    std::vector<long>::iterator it = std::unique(factors.begin(),\
    \ factors.end());\n    factors.resize(it - factors.begin() + 1);\n\n    // remove\
    \ duplicates from primes vector\n    std::vector<long>::iterator pit = std::unique(primes.begin(),\
    \ primes.end());\n    primes.resize(pit - primes.begin() + 1);\n\n    // remove\
    \ duplicates from res vector\n    std::vector<long>::iterator rit = std::unique(factors.begin(),\
    \ factors.end());\n    res.resize(rit - factors.begin() + 1);\n\n    return res;",
  "  std::vector<long> ans;\n  if (n == 2) ans.push_back(2);\n  if (n == 1) ans.push_back(1);\n\
    \  if (n == 0) ans.push_back(1);\n  if (n == 1) ans.push_back(1);\n  if (n ==\
    \ 2) ans.push_back(2);\n  if (n % 2 == 0) ans.push_back(2);\n  if (n % 3 == 0)\
    \ ans.push_back(2);\n  if (n % 5 == 0) ans.push_back(5);\n  if (n % 7 == 0) ans.push_back(7);\n\
    \  // Check if n is divisible by any of its prime factors\n  for (size_t i = 0;\
    \ i < ans.size(); i++) {\n    if (n % (ans[i] * ans[i ^ 1]) == 0) ans.push_back(i);\n\
    \  }\n  return ans;", "    int prime = 1;\n    std::vector<long> factors;\n  \
    \  for (long i = 2; i <= n; i++) {\n        while (n % i == 0) {\n           \
    \ factors.push_back(i);\n            n = n / i;\n            prime++;\n      \
    \  }\n    }\n    factors.push_back(n);\n    if (prime > 1) factors.push_back(prime);\n\
    \    return factors;", "  assert(n % 2 == 0);\n  std::vector<long> f;\n  for (long\
    \ i = 2; i <= n / 2; ++i)\n    if (n % i == 0) {\n      f.push_back(i);\n    \
    \  n = (n * i) / 2;\n    }\n  f.push_back(n);\n  return f;", "  std::vector<long>\
    \ factors;\n  // Initialise vector with 1..n\n  for (long i = 1; i <= n; i++)\
    \ {\n    factors.push_back(i);\n  }\n\n  // Iterate through numbers in vector\
    \ and find factors till sqrt(n)\n  while (n != 1) {\n    while (n % factors.size()\
    \ != 0) {\n      factors.push_back(n % factors.size());\n      n = n / factors.size();\n\
    \    }\n  }\n\n  // Return factors\n  return factors;", "    if (n<=1) return\
    \ {};\n    long p1 = 1; long p2 = 0; long p3 = 0; long p4 = 0;\n    while (n >\
    \ p2) {\n        while (n%p2 == 0) p2++;\n        p3 = p2;\n        while (p3%n==0)\
    \ p3++;\n        p4 = n;\n        while (p4%p2==0) p4++;\n        p2 = p3;\n \
    \       while (p2%p1==0) p2++;\n        p1 = n;\n        while (p1%p1==0) p1++;\n\
    \    }\n    std::vector<long> v;\n    while (p1!=0) {\n        v.push_back(p1);\n\
    \        p1 = p1*p2;\n        p2 = p3*p2;\n        p3 = p4*p2;\n        p4 = n;\n\
    \    }\n    v.push_back(n);\n    return v;", "    std::vector<long> factors;\n\
    \    if (n <= 1) return factors;\n    long i = 3, count = 1;\n    while (i !=\
    \ n) {\n        while (i * i <= n) {\n            if (n % i == 0) {\n        \
    \        factors.push_back(i);\n                n /= i;\n                count++;\n\
    \            }\n            i++;\n        }\n        if (n == 1)\n           \
    \ factors.push_back(n);\n        n = count;\n        count = 1;\n    }\n    return\
    \ factors;", "    std::vector<long> factors;\n    if (n <= 2) {\n        factors.push_back(n);\n\
    \        return factors;\n    }\n    long d = 2;\n    for (long i = 3; i <= n/2;\
    \ i++) {\n        while ((n % i) == 0) {\n            n /= i;\n            factors.push_back(i);\n\
    \        }\n        if (n <= 1) return factors;\n        if (i == d) d = 2*d;\n\
    \    }\n    return factors;", "    std::vector<long> factors;\n    long factor\
    \ = n;\n    // To keep factorization unordered use map container\n    std::map<long,\
    \ long> factorization;\n    while (true) {\n        factorization[factor]++;\n\
    \        long new_factor = factor;\n        while (true) {\n            if (factorization.find(new_factor)\
    \ == factorization.end()) {\n                factors.push_back(new_factor);\n\
    \                factorization.insert(std::pair<long, long>(new_factor, 1L));\n\
    \                break;\n            } else {\n                if (factorization[new_factor]\
    \ != 1L) new_factor *= new_factor;\n                else break;\n            }\n\
    \        }\n        factor *= factor;\n    }\n    return factors;", "    std::vector<long>\
    \ factors;\n    long i = 2;\n    while(i < n) {\n        if(n % i == 0) {\n  \
    \          factors.push_back(i);\n            n = n / i;\n        } else {\n \
    \           i++;\n        }\n    }\n    factors.push_back(n);\n    return factors;",
  "    std::vector<long> factors;\n    if (n < 2) {\n        return factors;\n   \
    \ }\n    int counter = 1;\n    for (int i = 2; i < n; i++) {\n        while (n\
    \ % i == 0) {\n            counter++;\n            factors.push_back(i);\n   \
    \         n /= i;\n        }\n        if (n == 1) {\n            factors.push_back(i);\n\
    \            return factors;\n        }\n    }\n    // All factors were multiplied\
    \ with each other\n    factors.push_back(1);\n    return factors;", "    std::vector<long>\
    \ factors;\n    long product = 1;\n    long currentSum = 1;\n    long sum = 1;\n\
    \    while (n != 0) {\n        sum = currentSum * n;\n        if (sum > n) {\n\
    \            factors.push_back(sum - n);\n            factors.push_back(n);\n\
    \            break;\n        } else {\n            if (n % 2 != 0) {\n       \
    \         currentSum += 2;\n            } else {\n                currentSum +=\
    \ 1;\n            }\n            n /= 2;\n        }\n    }\n    factors.push_back(product);\n\
    \    factors.push_back(currentSum);\n    return factors;", "    std::vector<long>\
    \ factors;\n    long limit = sqrt(n);\n    long divisor;\n    for (divisor = 1;\
    \ divisor <= limit; divisor++) {\n        if (n % divisor) {\n            break;\n\
    \        }\n    }\n    for (long i = 1; i <= limit; i *= 2) {\n        if (n %\
    \ i) {\n            factors.push_back(i);\n            while (n / i > i) {\n \
    \               n /= i;\n                factors.push_back(i);\n            }\n\
    \        }\n    }\n    return factors;", "    std::vector<long> p;\n    long i;\n\
    \    if (n < 2) {\n        p.push_back(n);\n        return p;\n    }\n    std::vector<long>\
    \ q = factorize(n/2);\n    for (i = 0; i < q.size(); ++i) {\n        long f =\
    \ q[i];\n        long r = n;\n        while (true) {\n            while (r % f\
    \ == 0) {\n                p.push_back(f);\n                r = r / f;\n     \
    \       }\n            if (r == 1) break;\n            f = q[i];\n           \
    \ ++i;\n        }\n    }\n    return p;", "    std::vector<long> res;\n    if\
    \ (n < 3) {\n        res.push_back(n);\n        return res;\n    }\n    long d\
    \ = 2;\n    while (d * d <= n) {\n        if (n % d == 0) {\n            while\
    \ (n % d == 0) {\n                n /= d;\n                res.push_back(d);\n\
    \            }\n        }\n        d++;\n    }\n    return res;", "    std::vector<long>\
    \ v(n + 1);\n    std::vector<bool> isPrime(n + 1);\n    std::iota(v.begin(), v.end(),\
    \ 1);\n    std::iota(isPrime.begin(), isPrime.end(), true);\n    for (int i =\
    \ 2; i * i <= n; ++i) {\n        if (isPrime[i]) {\n            for (int j = i\
    \ * i; j <= n; j += i) {\n                isPrime[j] = false;\n            }\n\
    \        }\n    }\n    // Find the smallest number that is a multiple of all the\
    \ primes in v\n    long ans = 1;\n    for (auto i : v) {\n        ans *= i;\n\
    \    }\n    ans *= n;\n    std::vector<long> ansprime(1);\n    ansprime[0] = ans;\n\
    \    for (auto i : v) {\n        while (ansprime[0] % i == 0) {\n            ansprime[0]\
    \ = (ansprime[0] / i) + 1;\n            ansprime[0] = ansprime[0] % i;\n     \
    \   }\n    }\n    return ansprime;", "    std::vector<long> f(n+1, 1); \n    long\
    \ l = 1; \n    for (long i=2; i<=n; i++) { \n        while (f [(i-1)/l]>0) l++;\
    \ \n        f[i]++;\n        if (l==2) {\n            while (f [(i+1)/l]>0) l++;\
    \ \n            f[i]++;\n        }\n    }\n    return f;", "    long max_value\
    \ = n;\n    for (long i = 2; i < max_value; i++) {\n        while (n % i == 0)\
    \ {\n            max_value = i;\n        }\n    }\n    if (max_value != n) {\n\
    \        std::vector<long> factors;\n        factors.push_back(n);\n        long\
    \ counter = 1;\n        for (long i = 1; i < max_value; i++) {\n            while\
    \ (n % i == 0) {\n                factors.push_back(i);\n                n /=\
    \ i;\n                counter++;\n            }\n        }\n        if (counter\
    \ == 1) {\n            factors.push_back(max_value);\n        }\n        return\
    \ factors;\n    }\n    return {n};", "    long count = 0;\n    long factor = 2;\n\
    \    std::vector<long> factorization;\n    factorization.push_back((long)1);\n\
    \    do {\n        while (n % factor == 0) {\n            factorization.push_back(factor);\n\
    \            n /= factor;\n            count++;\n        }\n        factor++;\n\
    \    } while (n > 1);\n    for (auto i : factorization) {\n        factorization.push_back(i);\n\
    \    }\n    factorization.push_back(factor);\n    factorization.push_back((long)1);\n\
    \    return factorization;", "  std::vector<long> factorization;\n  // We use\
    \ binary search as we assume that factors are already sorted.\n  auto binary_search\
    \ = [](const std::vector<long> &vec, long &value) {\n    auto left = 0;\n    auto\
    \ right = vec.size() - 1;\n    while (left <= right) {\n      long mid = (left\
    \ + right) / 2;\n      if (vec[mid] >= value) {\n        right = mid - 1;\n  \
    \    } else {\n        left = mid + 1;\n      }\n    }\n    return left;\n  };\n\
    \  while (n != 1) {\n    factorization.push_back(n);\n    // Check if factorization\
    \ is prime\n    long mid = n / 2;\n    long count = 0;\n    for (long &i : factorization)\
    \ {\n      if (i == mid) {\n        ++count;\n      }\n    }\n    if (count ==\
    \ 0) {\n      // If factor is not prime then check if it can be divided by other\
    \ factors\n      for (long &i : factorization) {\n        if (n % i == 0) {\n\
    \          n = (n / i) + 1;\n          factorization.push_back(i);\n         \
    \ break;\n        }\n      }\n    } else {\n      // If factor is prime then find\
    \ its position\n      long index = binary_search(factorization, mid);\n      //\
    \ Update factorization\n      n = n / factorization[index];\n      factorization.push_back(factorization[index]);\n\
    \    }\n  }\n  return factorization;", "\tif (n%2 == 0)\n\t\treturn std::vector<long>{2};\n\
    \t\n\tstd::vector<long> f(n+1, 1);\n\tfor (long i = 3; i <= n; i+=2) {\n\t\tif\
    \ (n % i == 0) {\n\t\t\tlong temp = i;\n\t\t\tfor (long j = 1; j < temp; j++)\
    \ f[j+1] *= i;\n\t\t\tf[temp]++;\n\t\t}\n\t}\n\t\n\tlong ans = 1;\n\tfor (long\
    \ i = 2; i <= n; i++) {\n\t\tans *= i;\n\t\tlong c = 0;\n\t\twhile (ans % i ==\
    \ 0) c++;\n\t\tif (c > 0) f.push_back(i);\n\t\tc = 0;\n\t}\n\tif (n < 2) return\
    \ f;\n\t\n\tfor (long i = 2; i <= n; i++) {\n\t\twhile (n % i == 0) f[i]--;\n\t\
    }\n\t\n\treturn f;", "    std::vector<long> f;\n    std::vector<long> p;\n   \
    \ // Get prime factors of n\n    for (int i = 2; i <= sqrt(n); ++i)\n        if\
    \ (n % i == 0)\n            p.push_back(i);\n    // Number of times each prime\
    \ factor appeared in factorization\n    for (long i : p)\n        f.push_back(0);\n\
    \    // Factor prime numbers\n    for (long i : p)\n        while (n%i == 0)\n\
    \            ++f[i];\n    // Return vector of prime factors\n    return f;", " \
    \ std::vector<long> ret;\n  long i = 2;\n  while (i <= n / i) {\n    while (n\
    \ % i == 0) {\n      ret.push_back(i);\n      n /= i;\n    }\n    i++;\n  }\n\
    \  if (n != 1)\n    ret.push_back(n);\n  return ret;", "  if (n <= 1) return {};\n\
    \  std::vector<long> p;\n  long factor = 2, divisor = 2;\n  while (true) {\n \
    \   while (n%divisor == 0) {\n      p.push_back(factor);\n      n = n/divisor;\n\
    \      factor++;\n    }\n    if (n == 1) break;\n    divisor++;\n  }\n  return\
    \ p;", "    if (n <= 1)\n        return std::vector<long>({n});\n    std::vector<long>\
    \ factors;\n    long d = 1;\n    for (long i = 3; i <= n / i; ++i) {\n       \
    \ while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n\
    \            if (n <= 1) {\n                factors.push_back(i);\n          \
    \      break;\n            }\n        }\n        d *= i;\n    }\n    factors.push_back(d);\n\
    \    return factors;", "    long p = n;\n    std::vector<long> factors;\n    while\
    \ (p != 1) {\n        // Find smallest factor and multiply by it to find the next\
    \ smallest factor\n        long next = p / 2;\n        while (next % p == 0) {\n\
    \            next /= p;\n        }\n        p -= next;\n        // If the current\
    \ number is less than the next smallest factor then divide next smallest factor\
    \ by it\n        // and add current number to the vector\n        if (next < n)\
    \ {\n            factors.push_back(next);\n        }\n    }\n    return factors;",
  "    std::vector<long> factors;\n    for (long i = 1; i <= n; i++) {\n        long\
    \ f = i;\n        while (f*f <= n) {\n            if (n%f == 0) {\n          \
    \      factors.push_back(f);\n                n /= f;\n                break;\n\
    \            }\n            ++f;\n        }\n    }\n    if (n != 1)\n        factors.push_back(n);\n\
    \    return factors;", "    if (n<2) return std::vector<long>(0);\n    long p=1,\
    \ q, factorization[100];\n    for (long i=1;i<=n;i++) {\n        while ((n%i)==0)\
    \ {\n            p*=i;\n            n /= i;\n            if (n==1) return std::vector<long>({p});\n\
    \            else if (p==1) return std::vector<long>({p});\n        }\n      \
    \  q=i;\n        while (n % q==0) {\n            q/=q;\n            factorization[p++]=q;\n\
    \        }\n    }\n    return std::vector<long>(factorization);", "\t// Initialize\
    \ vector with all factors of given number to be factorized later\n\tstd::vector<long>\
    \ factors(n);\n\tlong curr = n;\n\t// Iterate through factors\n\twhile (curr <=\
    \ 1) {\n\t\t// If the number is divisible by any factor, add that factor to the\
    \ vector\n\t\tfor (long i = 1; i <= curr; i++) {\n\t\t\tif (curr % i == 0) {\n\
    \t\t\t\tfactors.push_back(i);\n\t\t\t\tcurr /= i;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ factors;", "    long ans = n;\n    std::vector<long> factors;\n    if (n ==\
    \ 1) factors.push_back(1); else for (long i = 2; i <= n / i; i++)\n        if\
    \ (n % i == 0) ans = ans / i;\n        while (n % i == 0) {\n            ans /=\
    \ i;\n            factors.push_back(i);\n            n /= i;\n        }\n    return\
    \ factors;", "    std::vector<long> result;\n    if (n == 1)\n        result.push_back(n);\n\
    \    else {\n        // Sieve of Eratosthenes\n        for (long i = 2; i * i\
    \ <= n; i++)\n            if (n % i == 0)\n                for (long j = i; j\
    \ * j <= n; j++)\n                    if (n % j == 0)\n                      \
    \  for (long k = j; k * k <= n; k++)\n                            if (n % k ==\
    \ 0)\n                                result.push_back(i * j * k);\n    }\n  \
    \  return result;", "    // Initialize vector\n    std::vector<long> vec;\n  \
    \  // Get first prime factor\n    long first = n;\n    // While there are still\
    \ prime factors\n    while (first != 1) {\n        // Get second prime factor\n\
    \        long second = first;\n        // While there are still more prime factors\n\
    \        while ((second != 1) && (n % second == 0)) {\n            // Get next\
    \ prime factor\n            second = first;\n        }\n        // If we found\
    \ second prime factor\n        if (second != 1) {\n            // Append that\
    \ prime factor to vector\n            vec.push_back(second);\n            // Reduce\
    \ n by second factor\n            n /= second;\n            // Remove first prime\
    \ factor from the vector\n            vec.erase(vec.begin());\n        } else\
    \ {\n            // Reduce n by first factor\n            n /= first;\n      \
    \      // Remove first prime factor from the vector\n            vec.erase(vec.begin());\n\
    \        }\n        // Get first prime factor from n\n        first = n;\n   \
    \ }\n    return vec;", "    std::vector<long> vec;\n    vec.push_back(n);\n  \
    \  vec.push_back(2);\n    vec.push_back(2);\n    long i = 2;\n    while (true)\
    \ {\n        while (n % i == 0)\n            i += 2;\n        if (i == n) {\n\
    \            return vec;\n        }\n        vec.push_back(i);\n        n /= i;\n\
    \        i++;\n    }", "\t// If input number is even\n\tif (n % 2 == 0) {\n\t\t\
    // If input number is even, there is only one factor and that is its square root\n\
    \t\tlong root = (long) (sqrt(n));\n\t\t// If input number is even, there is only\
    \ one factor and that is its square root\n\t\tif (root % 2 == 0)\n\t\t\t// If\
    \ square root is even and input number is even, there is only 1 factor.\n\t\t\t\
    return std::vector<long>{root};\n\t\telse {\n\t\t\t// If square root is even and\
    \ input number is odd, there is 2 factors.\n\t\t\t// One is square root and other\
    \ is square root divided by 2.\n\t\t\tlong div = root / 2;\n\t\t\tlong mod = root\
    \ % 2;\n\t\t\treturn std::vector<long>{root, div, mod};\n\t\t}\n\t} else {\n\t\
    \t// If input number is odd, there is two factors other than square root of input\
    \ number\n\t\tlong div = n / 2;\n\t\tlong mod = n % 2;\n\t\treturn std::vector<long>{div,\
    \ mod};\n\t}", "    if (n < 2) return std::vector<long>();\n    std::vector<long>\
    \ factors(n);\n    long product = 1;\n    for (int i = 2; i <= n; ++i) {\n   \
    \     while (n % i == 0) {\n            factors[i / 2]++;\n            product\
    \ *= i;\n            n /= i;\n        }\n    }\n    std::vector<long>::iterator\
    \ itr = std::find(std::begin(factors), std::end(factors), 1);\n    if (itr !=\
    \ std::end(factors)) {\n        for (long i : factors)\n            factors[i\
    \ / 2] *= i;\n    }\n    return factors;", "    std::vector<long> pf;\n    pf.push_back(1);\n\
    \    long i = 2;\n    long factor = 2;\n    while (i * factor <= n) {\n      \
    \  if (n % i == 0) {\n            pf.push_back(i);\n            while (n % i ==\
    \ 0) {\n                n /= i;\n            }\n            pf.push_back(factor);\n\
    \            factor *= i;\n            if (n > 1) {\n                i = 2;\n\
    \                factor = 2;\n            } else {\n                break;\n \
    \           }\n        } else {\n            i += 1;\n            factor *= i;\n\
    \        }\n    }\n    pf.push_back(factor);\n    if (n > 1) {\n        i = 2;\n\
    \        factor = 2;\n    } else {\n        return pf;\n    }\n    while (i *\
    \ factor <= n) {\n        if (n % i == 0) {\n            pf.push_back(i);\n  \
    \          while (n % i == 0) {\n                n /= i;\n            }\n    \
    \        pf.push_back(factor);\n            factor *= i;\n            if (n >\
    \ 1) {\n                i = 2;\n                factor = 2;\n            } else\
    \ {\n                break;\n            }\n        } else {\n            i +=\
    \ 1;\n            factor *= i;\n        }\n    }\n    pf.push_back(factor);\n\
    \    return pf;", "  std::vector<long> result;\n  // If the number is not divisible\
    \ by 2, then there cannot be factors\n  if (n % 2 == 0) return result;\n  long\
    \ a = 1;\n  long b = 0;\n  // Find largest prime number smaller than or equal\
    \ to n and divide n by that number\n  // It means that all numbers in factorization\
    \ will have n / i as factor since they were already divided.\n  for (long i =\
    \ 3; i <= sqrt(n); i = i + 2) {\n    if (n % i == 0) {\n      b = i;\n      n\
    \ = (n / i) - 1;\n      result.push_back(i);\n      continue;\n    }\n    long\
    \ m = 1;\n    while (n % i == 0) {\n      n = n / i;\n      m++;\n    }\n    if\
    \ (m == 2) {\n      if (n == 1) result.push_back(i);\n      result.push_back(i);\n\
    \    }\n  }\n  return result;", "    assert(n % 2 == 0);\n    long a = n / 2;\n\
    \    std::vector<long> factorization;\n    long b;\n    // Find prime factors\n\
    \    while (n) {\n        for (b = 2; b * b <= a; b++) {\n            if (a %\
    \ b == 0) {\n                break;\n            }\n        }\n        if ((b\
    \ * b) == a) {\n            factorization.push_back(b);\n            n /= b;\n\
    \        }\n    }\n    assert(n % 2 == 0);\n    if (n != 2) {\n        factorization.push_back(1);\n\
    \    }\n    return factorization;", "    std::vector<long> result;\n    long m\
    \ = n;\n    long a = 1;\n    // The current number is the product of the factors,\
    \ except for 1 which is equal to n\n    while (m % 2 == 0) {\n        a = a *\
    \ 2;\n        m = m / 2;\n    }\n    // If m is odd then m divides 2\n    if (m\
    \ % 2 == 1) {\n        a = a * 2;\n    }\n    long b = 1;\n    while (m % 3 ==\
    \ 0) {\n        b = b * 3;\n        m = m / 3;\n    }\n    // If m is odd then\
    \ m divides 3\n    if (m % 3 == 1) {\n        b = b * 3;\n    }\n    long c =\
    \ 1;\n    while (m % 5 == 0) {\n        c = c * 5;\n        m = m / 5;\n    }\n\
    \    // If m is odd then m divides 5\n    if (m % 5 == 1) {\n        c = c * 5;\n\
    \    }\n    long d = 1;\n    while (m % 7 == 0) {\n        d = d * 7;\n      \
    \  m = m / 7;\n    }\n    // If m is odd then m divides 7\n    if (m % 7 == 1)\
    \ {\n        d = d * 7;\n    }\n    if (a == 1) {\n        result.push_back(b);\n\
    \        result.push_back(c);\n        result.push_back(d);\n    } else {\n  \
    \      result.push_back(b);\n        result.push_back(d);\n        result.push_back(c);\n\
    \    }\n    return result;", "    std::vector<long> factors;\n    long product\
    \ = 1;\n    long k = 0;\n    long i = 2;\n    long j = 1;\n    long t = n;\n \
    \   while (true) {\n        product = product * i;\n        i++;\n        if (i\
    \ == t) {\n            if (product > n) {\n                factors.push_back(n);\n\
    \                break;\n            }\n            factors.push_back(product);\n\
    \            break;\n        }\n        while (product % i == 0) {\n         \
    \   product /= i;\n            factors.push_back(i);\n        }\n        j = i;\n\
    \        while (j % t == 0) {\n            j /= t;\n            factors.push_back(j);\n\
    \        }\n        if (j == 1)\n            k = i;\n    }\n    return factors;",
  "    assert(n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n % 7 == 0);\n    std::vector<long>\
    \ factor;\n    long max_divisor = n;\n    factor.push_back(n);\n    long mod =\
    \ n;\n    while (mod != 1) {\n        max_divisor--;\n        mod = mod / 2;\n\
    \    }\n    if (max_divisor == 2) {\n        factor.push_back(n);\n    } else\
    \ if (max_divisor > 2) {\n        factor.push_back(n);\n        while (n % 2 ==\
    \ 0) {\n            factor.push_back(2);\n            n = n / 2;\n        }\n\
    \        while (n % 3 == 0) {\n            factor.push_back(3);\n            n\
    \ = n / 3;\n        }\n        while (n % 5 == 0) {\n            factor.push_back(5);\n\
    \            n = n / 5;\n        }\n        while (n % 7 == 0) {\n           \
    \ factor.push_back(7);\n            n = n / 7;\n        }\n    }\n    return factor;",
  "\t// if n is prime return 1 and n\n\tif(n % 2 == 0 || n == 1) return std::vector<long>({n});\n\
    \t\n\t// create vector of long elements to store factors.\n\tstd::vector<long>\
    \ factors;\n\t\n\t// first find factors\n\tlong f1 = 1;\n\tlong f2 = 2;\n\tlong\
    \ f3 = 1;\n\tlong f4 = 3;\n\tlong f5 = 3;\n\tlong f6 = 2;\n\tlong f7 = 2;\n\t\
    long f8 = 2;\n\tlong f9 = 3;\n\tlong f10 = 1;\n\tlong f11 = 2;\n\tlong f12 = 1;\n\
    \tlong f13 = 2;\n\tlong f14 = 1;\n\tlong f15 = 2;\n\tlong f16 = 2;\n\tlong f17\
    \ = 1;\n\tlong f18 = 2;\n\tlong f19 = 2;\n\tlong f20 = 1;\n\tlong f21 = 1;\n\t\
    long f22 = 1;\n\tlong f23 = 1;\n\tlong f24 = 1;\n\tlong f25 = 2;\n\tlong f26 =\
    \ 2;\n\tlong f27 = 2;\n\tlong f28 = 2;\n\tlong f29 = 1;\n\tlong f30 = 1;\n\tlong\
    \ f31 = 1;\n\tlong f32 = 2;\n\tlong f33 = 1;\n\tlong f34 = 1;\n\tlong f35 = 2;\n\
    \tlong f36 = 2;\n\tlong f37 = 2;\n\tlong f38 = 1;\n\tlong f39 = 2;\n\tlong f40\
    \ = 2;\n\tlong f41 = 1;\n\tlong f42 = 3;\n\tlong f43 = 3;\n\tlong f44 = 3;\n\t\
    long f45 = 3;\n\tlong f46 = 3;\n\tlong f47 = 2;\n\tlong f48 = 2;\n\tlong f49 =\
    \ 2;\n\tlong f50 = 3;\n\tlong f51 = 1;\n\tlong f52 = 2;\n\tlong f53 = 2;\n\tlong\
    \ f54 = 2;\n\tlong f55 = 2;\n\tlong f56 = 2;\n\tlong f57 = 1;\n\tlong f58 = 2;\n\
    \tlong f59 = 2;\n\tlong f60 = 2;\n\tlong f61 = 1;\n\tlong f62 = 3;\n\tlong f63\
    \ = 3;\n\tlong f64 = 3;\n\tlong f65 = 3;\n\tlong f66 = 2;\n\tlong f67 = 2;\n\t\
    long f68 = 1;\n\tlong f69 = 2;\n\tlong f70 = 2;\n\tlong f71 = 1;\n\tlong f72 =\
    \ 3;\n\tlong f73 = 3;\n\tlong f74 = 3;\n\tlong f75 = 3;\n\tlong f76 = 2;\n\tlong\
    \ f77 = 2;\n\tlong f78 = 2;\n\tlong f79 = 2;\n\t", "    if (n == 1) return {0};\n\
    \    std::vector<long> factorization(n);\n    // If n is prime, it is already\
    \ factored\n    if (n % 2 == 0 && factorization[n/2] == 0) return factorization;\n\
    \    long p = 2, counter = 1;\n    // If n is even\n    if (n % 2 != 0 && factorization[n/2]\
    \ != 0) return factorization;\n    while (counter != n) {\n        counter++;\n\
    \        for (int i = 3; i <= std::sqrt(n); i += 2) {\n            // If n is\
    \ divisible by i, then increase its factor count by 1\n            if (n % i ==\
    \ 0 && factorization[n/i] != 0) factorization[n/i+1]++;\n            // If n is\
    \ divided by i, then decrease its factor count by 1\n            if (n % i ==\
    \ 0 && factorization[n/i-1] != 0) factorization[n/i]--;\n        }\n        p++;\n\
    \    }\n    // If n is prime, then factorization contains one more factor by 1\
    \ and n itself\n    if (factorization[n/2] == 1) factorization[n/2-1]++;\n   \
    \ // Return factorization\n    return factorization;", "    std::vector<long>\
    \ factors;\n    for (long i = 2; i <= n / i; i++) {\n        while (n % i == 0)\
    \ {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n\
    \    if (n != 1) {\n        factors.push_back(n);\n    }\n    return factors;",
  "    std::vector<long> factor(1);\n    // If n is divisible by any number, it is\
    \ not a factor.\n    if (n % 2 == 0) {\n        factor[0] = 1;\n        return\
    \ factor;\n    }\n    // Divide n by every even number starting from 2\n    for\
    \ (long i = 2; i <= n / 2; ++i)\n        while (n % i == 0)\n            factor[factor.size()\
    \ - 2] = i;\n    // Divide n by every odd number starting from 2\n    for (long\
    \ i = 3; i <= n / 2; ++i)\n        while (n % i == 0)\n            factor.push_back(factor.size()\
    \ - 1 + i);\n    return factor;", "    assert(n != 0);\n    std::vector<long>\
    \ factorization(n);\n    long counter = 1;\n    for (long i = 2; i < n; ++i) {\n\
    \        if (n % i == 0) {\n            factorization[i] += counter;\n       \
    \     counter += 1;\n            while ((n % i) == 0) {\n                n /=\
    \ i;\n                ++counter;\n            }\n            if (n > 1) {\n  \
    \              --counter;\n            }\n        }\n    }\n    factorization.push_back(n);\n\
    \    return factorization;", "  std::vector<long> result;\n  long factor = 1;\n\
    \  for (long i = 1; i <= n; i++) {\n    while (n % i == 0) {\n      factor +=\
    \ i;\n      n /= i;\n    }\n    if (n != 1) result.push_back(factor);\n    factor\
    \ = 1;\n  }\n  return result;", "    int flag = 0;\n    std::vector<long> fct;\n\
    \    long i = 2;\n    long fp = 1;\n    long p = n;\n\n    while ((p & 1) == 0)\
    \ {\n        p = p * i;\n        i++;\n    }\n\n    // If p is odd, it is sure\
    \ that it will not divide by any factors. So, no need to test it for divisability\n\
    \    if ((p & 1) == 1) {\n        fct.push_back(p);\n    } else {\n        while\
    \ (p != 0) {\n            while (p % i == 0) {\n                p = p / i;\n \
    \               fct.push_back(i);\n                flag++;\n            }\n  \
    \          i++;\n        }\n        // If flag is still zero, it means that all\
    \ numbers are divisible by any factors.\n        if (flag == 0) {\n          \
    \  fct.push_back(p);\n        }\n    }\n    return fct;", "  long factor[] = {1,\
    \ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157,\
    \ 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241,\
    \ 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,\
    \ 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439,\
    \ 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547,\
    \ 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,\
    \ 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751,\
    \ 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859,\
    \ 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\
    \ 983, 991, 997}))\n  int res = 1;\n  int i = 0;\n  std::vector<long> ans;\n \
    \ long a = n;\n  while(a != 1){\n    if (a % factor[i++] == 0){\n      a= a/factor[i];\n\
    \      ans.push_back(factor[i]);\n    }\n  }\n  return ans;", "    assert(n >\
    \ 0);\n    std::vector<long> prime_fac_vec;\n    prime_fac_vec.push_back(n);\n\
    \    // prime factor will be the smallest prime factor found and will be updated\
    \ if any factor has more than one\n    long long max_prime_fac = 0;\n    // initialize\
    \ first prime factor as n\n    long long p_fac=n;\n    // initialize other prime\
    \ factor as 1\n    long long p_fac_1 = 1;\n    // initialize factor count as 0\n\
    \    long long fac = 0;\n    // iterate till the largest prime factor is greater\
    \ than the given number\n    while (p_fac != 1) {\n        // iterate till the\
    \ prime factors less than n are found.\n        while (p_fac * p_fac_1 != n) {\n\
    \            p_fac *= p_fac_1;\n            ++fac;\n        }\n        // update\
    \ max prime factor if current prime factor is greater than the given number\n\
    \        max_prime_fac = std::max(p_fac, max_prime_fac);\n        p_fac_1 *= p_fac;\n\
    \        p_fac = 1;\n    }\n    // iterate till the largest prime factor is greater\
    \ than the given number\n    while (p_fac != 1) {\n        // iterate till the\
    \ prime factors less than n are found.\n        while (p_fac * p_fac_1 != n) {\n\
    \            p_fac *= p_fac_1;\n            ++fac;\n        }\n        // update\
    \ max prime factor if current prime factor is greater than the given number\n\
    \        max_prime_fac = std::max(p_fac, max_prime_fac);\n        p_fac_1 *= p_fac;\n\
    \        p_fac = 1;\n    }\n    // iterate till the largest prime factor is greater\
    \ than the given number\n    while (p_fac != 1) {\n        // iterate till the\
    \ prime factors less than n are found.\n        while (p_fac * p_fac_1 != n) {\n\
    \            p_fac *= p_fac_1;\n            ++fac;\n        }\n        // update\
    \ max prime factor if current prime factor is greater than the given number\n\
    \        max_prime_fac = std::max(p_fac, max_prime_fac);\n        p_fac_1 *= p_fac;\n\
    \        p_fac = 1;\n    }\n    // add final factor to prime factor vector\n \
    \   prime_fac_vec.push_back(max_prime_fac);\n    return prime_fac_vec;", "  long\
    \ p = 1;\n  std::vector<long> ans;\n  ans.push_back(n);\n  while (p != 1) {\n\
    \    while (n % p == 0) {\n      ans.push_back(p);\n      n /= p;\n    }\n   \
    \ p++;\n  }\n  return ans;", "    std::stack<long> s;\n    s.push_back(n);\n \
    \   std::vector<long> factors;\n    long m = n;\n    while (s.size() > 0) {\n\
    \        while (m % 2 == 0) {\n            s.push((m / 2));\n        }\n     \
    \   while (m % 3 == 0) {\n            s.push((m / 3));\n        }\n        while\
    \ (m % 5 == 0) {\n            s.push((m / 5));\n        }\n        while (m %\
    \ 7 == 0) {\n            s.push((m / 7));\n        }\n        while (m % 11 ==\
    \ 0) {\n            s.push((m / 11));\n        }\n        while (m % 13 == 0)\
    \ {\n            s.push((m / 13));\n        }\n        while (m % 17 == 0) {\n\
    \            s.push((m / 17));\n        }\n        while (m % 19 == 0) {\n   \
    \         s.push((m / 19));\n        }\n        while (m % 23 == 0) {\n      \
    \      s.push((m / 23));\n        }\n        while (m % 29 == 0) {\n         \
    \   s.push((m / 29));\n        }\n        while (m % 31 == 0) {\n            s.push((m\
    \ / 31));\n        }\n        while (m % 37 == 0) {\n            s.push((m / 37));\n\
    \        }\n        while (m % 41 == 0) {\n            s.push((m / 41));\n   \
    \     }\n        while (m % 43 == 0) {\n            s.push((m / 43));\n      \
    \  }\n        while (m % 47 == 0) {\n            s.push((m / 47));\n        }\n\
    \        while (m % 49 == 0) {\n            s.push((m / 49));\n        }\n   \
    \     while (m % 53 == 0) {\n            s.push((m / 53));\n        }\n      \
    \  while (m % 59 == 0) {\n            s.push((m / 59));\n        }\n        while\
    \ (m % 61 == 0) {\n            s.push((m / 61));\n        }\n        while (m\
    \ % 67 == 0) {\n            s.push((m / 67));\n        }\n        while (m % 71\
    \ == 0) {\n            s.push((m / 71));\n        }\n        while (m % 73 ==\
    \ 0) {\n            s.push((m / 73));\n        }\n        while (m % 79 == 0)\
    \ {\n            s.push((m / 79));\n        }\n        while (m % 89 == 0) {\n\
    \            s.push((m / 89));\n        }\n        while (m % 97 == 0) {\n   \
    \         s.push((m / 97));\n        }\n        while (m % 101 == 0) {\n     \
    \       s.push((m / 101));\n        }\n        while (m % 103 == 0) {\n      \
    \      s.push((m / 103));\n        }\n        while (m % 107 == 0) {\n       \
    \     s.push((m / 107));\n        }\n        while (m % ", "    std::vector<long>\
    \ vec;\n    long num = 1;\n    bool isDivisor = true;\n    vec.push_back(n);\n\
    \    while (vec.back() !=0){\n        num = num * vec.back();\n        // Check\
    \ if number is a multiple of previous primes\n        if(num % vec.back() != 0){\n\
    \            isDivisor = false;\n            break;\n        }\n        vec.pop_back();\n\
    \    }\n    if (isDivisor == true){\n        return vec;\n    }\n    // If number\
    \ is a perfect prime then there can be no other factors\n    std::vector<long>\
    \ factors = factorize(num);\n    for(auto const& i : factors){\n        vec.push_back(i);\n\
    \    }\n    return vec;", "\tstd::vector<long> primes;\n\tlong f[n+1] = {0};\n\
    \tf[0] = 1;\n\t// Loop through all numbers from 2 to n and increase counter in\
    \ each element of f by 1\n\tfor(long i = 2; i <= n; i++) {\n\t\tf[i]+=1;\n\t\t\
    for(long j = 2*i; j <= n; j+=i) {\n\t\t\tf[j] += 1;\n\t\t}\n\t}\n\tlong res =\
    \ 1;\n\t// Loop through f and find out number of factors for n\n\tfor(long i =\
    \ 1; i < n; i++) {\n\t\tif(f[i] > 1) {\n\t\t\t// Loop through f and multiply corresponding\
    \ element of f with each number in f to get corresponding factor\n\t\t\tfor(long\
    \ j = i; j < n; j+=i) {\n\t\t\t\tres = (res*f[j])%n;\n\t\t\t}\n\t\t\t// If any\
    \ number in f is not 1 than it is a factor of n\n\t\t\tif(res != 1)\n\t\t\t\t\
    primes.push_back(i);\n\t\t}\n\t}\n\treturn primes;", "    std::vector<long> result;\n\
    \    if (n == 1) return result;\n    for (long i = 2; i <= std::sqrt(n); i++)\
    \ {\n        while (n % i == 0) {\n            result.push_back(i);\n        \
    \    n /= i;\n        }\n    }\n    if (n != 1) result.push_back(n);\n    return\
    \ result;", "    long i = 2;\n    std::vector<long> factors(1);\n    for(; i <=\
    \ n; i++) {\n        // if i is prime\n        if(i%2 == 0) {\n            factors.push_back(i);\n\
    \            factors.push_back(n/i);\n        }\n        // if i is odd\n    \
    \    else {\n            for(long j = i*i; j < n; j += i) {\n                factors.push_back(j);\n\
    \            }\n        }\n    }\n    return factors;", "\tif (n == 1) return\
    \ { n };\n\n\tstd::vector<long> prime_vec;\n\tstd::vector<long> factorization_vec;\n\
    \n\tlong curr = 0;\n\n\twhile (n != 1) {\n\t\tlong next_pow = 1;\n\n\t\tfor (long\
    \ i = 0; i < factorization_vec.size(); i++)\n\t\t\tnext_pow *= factorization_vec[i];\n\
    \n\t\tfactorization_vec.push_back(next_pow);\n\n\t\twhile (next_pow != 1 && n\
    \ % next_pow != 0) {\n\t\t\tfactorization_vec.push_back(n);\n\t\t\tn /= next_pow;\n\
    \t\t}\n\n\t\tif (next_pow == 1) {\n\t\t\tprime_vec.push_back(n);\n\t\t\tfactorization_vec.clear();\n\
    \t\t}\n\t}\n\n\tif (prime_vec.size() == 1) return prime_vec;\n\telse return factorization_vec;",
  "    int m = 2;\n    while (m <= n / m) {\n        while (n % m == 0) {\n      \
    \      n /= m;\n        }\n        m++;\n    }\n    std::vector<long> factor;\n\
    \    while (n != 1) {\n        factor.push_back(n);\n        n = n / factor.back();\n\
    \    }\n    return factor;", "    std::vector<long> factors;\n    if (n <= 1)\
    \ return factors;\n    // Base case\n    long base = 2;\n    while (n >= base)\
    \ {\n        if (n % base == 0) {\n            factors.push_back(base);\n    \
    \        while (n / base >= base) {\n                n /= base;\n            \
    \    factors.push_back(base);\n            }\n        }\n        base++;\n   \
    \ }\n    // If n is prime then factors would be 1\n    if (n > 1)\n        factors.push_back(1);\n\
    \    return factors;", "    std::vector<long> factors;\n    long factor = 1;\n\
    \    long divisor = 1;\n    std::vector<bool> visited(n);\n    for (int i = 0;\
    \ i < n; i++) {\n        if (!visited[i]) {\n            while (factor <= n /\
    \ divisor) {\n                factors.push_back(factor);\n                divisor\
    \ *= factor;\n            }\n            visited[i] = true;\n        }\n     \
    \   factor *= i;\n    }\n    return factors;", "  std::vector<long> factors(0);\n\
    \  for (long i = 2; i <= sqrt(n); i++) {\n    // For every number whose square\
    \ is greater than or equal to i, we found factors.\n    if (n % i == 0) {\n  \
    \    factors.push_back(i );\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    factors.push_back(n);\n\
    \  }\n  return factors;", "    std::vector<long> factors;\n    long max_count\
    \ = 1;\n    for (int i = 0; i < n; ++i) {\n        long cnt = 1;\n        while\
    \ (n % i == 0) {\n            cnt += 1;\n            n /= i;\n        }\n    \
    \    if (cnt > max_count) {\n            max_count = cnt;\n            factors.clear();\n\
    \        }\n        factors.push_back(i);\n    }\n    if (max_count == 1)\n  \
    \      return factors;\n    for (long i = 2; i <= max_count; i++) {\n        while\
    \ (n % i == 0)\n            n /= i;\n        if (n == 1)\n            break;\n\
    \    }\n    if (n == 1)\n        factors.push_back(n);\n    return factors;",
  "    if (n == 1)\n        return std::vector<long>({n});\n    std::vector<long>\
    \ f;\n    for (long i = 2; i <= sqrt(n); i++) {\n        while (n % i == 0) {\n\
    \            f.push_back(i);\n            n /= i;\n        }\n    }\n    return\
    \ f;", "    // Find prime factors using sieve of eratosthenes\n    long n = abs(n);\n\
    \    std::vector<long> factorization(n);\n    std::vector<bool> prime(n);\n  \
    \  prime[0]=true;\n    long max_factor = 1;\n    for(long i=2; i<n; ++i) {\n \
    \       prime[i] = prime[i-1] && n%i;\n        if( !prime[i] ) continue;\n   \
    \     for(long j=i*i;j<=n;j+=i) {\n            if( prime[j] ) {\n            \
    \    max_factor *= j;\n                factorization[i] = max_factor;\n      \
    \      }\n        }\n    }\n    std::reverse(factorization.begin(),factorization.end());\n\
    \    return factorization;", "    long count = 1;\n    // Checking if input is\
    \ an odd number \n    if (n % 2 == 0){\n        return std::vector<long>({n, 1});\n\
    \    }\n    std::vector<long> res;\n    for (long i = 3; i <= n / 2; i += 2){\n\
    \        while (n % i == 0){\n            count++;\n            n /= i;\n    \
    \    }\n        res.push_back(i);\n    }\n    if (n > 1){\n        long n = sqrt(n);\n\
    \        while (n % 2 == 0){\n            n /= 2;\n            count++;\n    \
    \    }\n        res.push_back(n);\n    }\n    res.push_back(count);\n    return\
    \ res;", "    std::vector<long> vec;\n    vec.push_back(n);\n    for(long i =\
    \ 3; i*i <= n; i += 2) {\n        if(n % i == 0) {\n            while(n % i ==\
    \ 0) {\n                vec.push_back(i);\n                n /= i;\n         \
    \   }\n        }\n    }\n    if(n != 1) {\n        vec.push_back(n);\n    }\n\
    \    return vec;", "    if (n <= 1) return {};\n    std::vector<long> factorization;\n\
    \    long temp = n;\n    // While loop should stop when factorization vector is\
    \ empty\n    while (!factorization.empty() && temp != 1) {\n        // Get next\
    \ factor from factorization vector and check if it is larger than current number\
    \ n\n        auto it = std::find(factorization.begin(), factorization.end(), temp);\n\
    \        // If it's not larger than current number n, then we can add it to factorization\n\
    \        if (it != factorization.end()) {\n            long temp2 = it->second;\n\
    \            // Add it only if it doesn't exist already\n            if (std::find(factorization.begin(),\
    \ factorization.end(), temp2) == factorization.end()) {\n                factorization.push_back(temp2);\n\
    \            }\n            temp = temp / temp2;\n        }\n    }\n    return\
    \ factorization;", "    std::vector<long> factors;\n    long k = n;\n    for (long\
    \ d = 2; d * d <= n; d++) {\n        if (n % d == 0)\n            factors.push_back(d);\n\
    \        while (n / d != k) {\n            long c = n % d;\n            n /= d;\n\
    \            factors.push_back(c);\n        }\n    }\n    long result = 1;\n \
    \   for (auto i : factors)\n        result *= i;\n    factors.push_back(result);\n\
    \    return factors;", "  std::vector<long> factors;\n  factorize(n, 0, factors);\n\
    \  return factors;", "  std::vector<long> v;\n  int i = 2;\n  while (i < n) {\n\
    \    if (n % i == 0) {\n      v.push_back(i);\n      n /= i;\n    } else {\n \
    \     i++;\n    }\n  }\n  if (n > 1) {\n    v.push_back(n);\n  }\n  return v;",
  "    std::vector<long> pfactors(n, 1);\n    for (int i = 2; i < pfactors.size();\
    \ i++) {\n        while (pfactors[i] * i >= n) {\n            pfactors[i] /= i;\n\
    \            while (i > 1) {\n                if (n % i == 0) {\n            \
    \        pfactors[i] *= i;\n                    n /= i;\n                    break;\n\
    \                }\n                i /= 2;\n            }\n            if (n\
    \ == 1)\n                break;\n        }\n    }\n    return pfactors;", "  std::vector<long>\
    \ result;\n  long i = 2;\n  while (i * i <= n) {\n    while ((n % i) == 0) {\n\
    \      result.push_back(i);\n      n /= i;\n    }\n    i++;\n  }\n  if (n != 1)\n\
    \    result.push_back(n);\n  return result;", "    std::vector<long> factors;\n\
    \    long fact = 1;\n    long n = n;\n    long factCount = 1;\n    while(n) {\n\
    \        factCount++;\n        while(n%2 == 0) {\n            fact = fact*2;\n\
    \            n = n/2;\n        }\n        if(n%2 == 1) {\n            fact = fact*3;\n\
    \            n = n/2;\n        }\n        factors.push_back(fact);\n        fact\
    \ = 1;\n    }\n    return factors;", "    std::vector<long> ret;\n    if (n <=\
    \ 1) return ret;\n    long ans;\n    long i = 2;\n    long p = 1;\n    for (long\
    \ x = 1; x <= n; ++x) {\n        long c = 1;\n        while (i * i <= x && x *\
    \ x <= n) {\n            c += 1;\n            i <<= 1;\n            x <<= 1;\n\
    \        }\n        if (p != x) {\n            ans = c * p;\n            ret.push_back((long)\
    \ ans);\n            p = x;\n        }\n    }\n    if (i == 1) return ret;\n \
    \   ans = c * p;\n    ret.push_back((long) ans);\n    return ret;", "  std::vector<long>\
    \ factors;\n  long divisor = 1;\n  while (n % divisor) {\n    factors.push_back(divisor);\n\
    \    n /= divisor;\n  }\n  if (n > 1) {\n    factors.push_back(1);\n  }\n  return\
    \ factors;", "    std::vector<long> factors(factorization(n));\n    for (long\
    \ i : factors) {\n        assert(n % i == 0);\n    }\n    return factors;", " \
    \   // if n is even, return all even numbers\n    if (n%2 == 0){\n        std::vector<long>\
    \ even;\n        for(int i=3; i<=n; i+=2){\n            if (n % i == 0){\n   \
    \             even.push_back(i);\n            }\n        }\n        return even;\n\
    \    }\n    // n is odd, then n-1 must be prime, so return all factors of n-1\n\
    \    if (n == 1 || n == 2){\n        std::vector<long> factors;\n        for(int\
    \ i=3; i<=n; i+=2){\n            if (n % i == 0){\n                factors.push_back(i);\n\
    \            }\n        }\n        return factors;\n    }\n    // n is not prime,\
    \ then return all factors of n\n    std::vector<long> factors;\n    for(int i=3;\
    \ i<=n; i+=2){\n        if (n % i == 0){\n            factors.push_back(i);\n\
    \        }\n    }\n    return factors;", "  std::vector<long> res;\n  std::vector<long>\
    \ factors;\n  bool found = false;\n  for (long i = 2; i <= n / i; i++) {\n   \
    \ long temp = i;\n    while (temp % 2 == 0) {\n      temp /= 2;\n    }\n    factors.push_back(temp);\n\
    \    if (temp == n) {\n      found = true;\n    }\n  }\n  if (!found) {\n    factors.push_back(n);\n\
    \  }\n  for (long i = 0; i < factors.size(); i++) {\n    res.push_back(factors[i]);\n\
    \    for (long j = i + 1; j < factors.size(); j++) {\n      if (n % factors[j]\
    \ == 0) {\n        n /= factors[j];\n        res.push_back(factors[j]);\n    \
    \  }\n    }\n  }\n  return res;", "    // initialize vector of factorization as\
    \ {0,1}\n    std::vector<long> factorization{0,1};\n    // initialize count for\
    \ first factor\n    long factor_count = 0;\n    // find first factor of n\n  \
    \  for (long i = 2; i < n; i++) {\n        // if n is prime then we already have\
    \ factorization\n        if (n % i == 0) {\n            // add factor i to the\
    \ factorization\n            factorization.push_back(i);\n            // update\
    \ count of factor\n            factor_count++;\n        }\n        // if n is\
    \ not prime then check if it is divisable by all the factors\n        else {\n\
    \            for (long k : factorization) {\n                if (n % k == 0) {\n\
    \                    // if n is divisible by all the factors then break out of\
    \ loop and update count of factor\n                    factorization.clear();\n\
    \                    factor_count = 1;\n                    break;\n         \
    \       }\n            }\n        }\n    }\n    // return factorization\n    return\
    \ factorization;", "    if (n < 2)\n        return std::vector<long>();\n    //\
    \ Create a vector with only 1\n    std::vector<long> factors{1};\n    long res\
    \ = n;\n    std::vector<long> counter(factors.size());\n    // Find the factors\n\
    \    while (1) {\n        // Update factor count\n        for (int i = 0; i <\
    \ counter.size(); i++) {\n            if (res / counter[i] == 1) {\n         \
    \       counter[i]++;\n            }\n        }\n        // Find next factor\n\
    \        for (int i = counter.size() - 1; i >= 0; i--) {\n            if (counter[i]\
    \ > 1) {\n                res = res / counter[i];\n                factors.push_back(counter[i]);\n\
    \                break;\n            }\n        }\n        // Check if we've found\
    \ a factor\n        if (res == 1) {\n            break;\n        }\n    }\n  \
    \  return factors;", "    std::vector<long> factors;\n    long m = n;\n    //\
    \ While m != 1 and m > 1 because m is multiple of number which is going to be\
    \ factorized.\n    // Because m is prime we can use m % n to get next multiple\
    \ of n which is m (m % n == 0).\n    while (m != 1 && m > 1) {\n        // Get\
    \ next multiple of n which is m.\n        long mNext = m % n;\n        // Get\
    \ its factors.\n        std::vector<long> temp;\n        for (long i = 2; i <=\
    \ mNext; i++) {\n            if (m % i == 0) {\n                temp.push_back(i);\n\
    \            }\n        }\n        // If there are factors we add them to the\
    \ vector.\n        if (temp.size() != 0) {\n            factors.push_back(temp.size());\n\
    \        }\n        // If no factors we skip to next multiple of n which is m\
    \ because m is prime.\n        else {\n            m /= n;\n        }\n    }\n\
    \    return factors;", "    // initialize vector of prime factors\n    std::vector<long>\
    \ vec;\n    // initialize vector of prime factors\n    long d = 2;\n    long x\
    \ = 1;\n    // loop till n has factors\n    while (x * d < n) {\n        if (n\
    \ % x == 0) {\n            // factorization of a number\n            // store\
    \ factor\n            vec.push_back(x);\n            // update d\n           \
    \ d = d * (x + 1);\n        }\n        else {\n            x = x * x + 1;\n  \
    \      }\n    }\n    // update d till it reaches n\n    while (d < n) {\n    \
    \    d = d * (n + 1);\n    }\n    return vec;", "    if (n == 1)\n        return\
    \ std::vector<long>({1});\n    else if (n <= 1)\n        return std::vector<long>({n});\n\
    \    std::vector<long> f1, f2, f3;\n    f1 = factorize(n/2);\n    f2 = factorize(n/2);\n\
    \    for(long i = 0; i < f1.size(); ++i){\n        for (long j = 0; j < f2.size();\
    \ ++j){\n            if (f1[i] * f2[j] == n){\n                f3.push_back(f1[i]*f2[j]);\n\
    \                break;\n            }\n        }\n    }\n    return f3;", " \
    \   assert(n >= 1);\n    std::vector<long> result;\n    // Find prime factors\
    \ of number\n    for (long i = 2; i * i <= n; i++) {\n        // If number is\
    \ divisible by i, then i can be factored.\n        if (n % i == 0)\n         \
    \   result.push_back(i / n);\n    }\n    // If there are same factors, sort them\
    \ by multiplicity and put them in order from smallest to largest\n    if (result.size()\
    \ != 1) {\n        std::sort(result.begin(), result.end(), std::greater<long>());\n\
    \        long l = result[0];\n        for (long i = 0; i < result.size() - 1;\
    \ i++) {\n            if (result[i + 1] != l / result[i]) {\n                result.insert(result.begin()\
    \ + i + 1, l / result[i]);\n                break;\n            }\n        }\n\
    \    }\n    return result;", "\tlong ans = 1;\n\tstd::vector<long> res;\n\tlong\
    \ i = 2;\n\tfor (; n > 0; n /= i) {\n\t\tif (n % i == 0)\n\t\t\tans *= i;\n\t\t\
    else {\n\t\t\tans /= i;\n\t\t\tif (ans > 0)\n\t\t\t\tres.push_back(i);\n\t\t\t\
    ans = 1;\n\t\t}\n\t\ti++;\n\t}\n\tres.push_back(ans);\n\treturn res;", "    if\
    \ (n <= 1) return {};\n\n    std::vector<long> result;\n    long cur = 1;\n  \
    \  long count = 1;\n    long i = 2;\n    long n1 = 1;\n    while (i <= n && n\
    \ % i == 0) {\n        result.push_back(count); // add count of i to vec\n   \
    \     n1 = i;\n        count = 1; // reset counter\n        while (n % i == 0)\
    \ {\n            n = n / i;\n            count++;\n        }\n        i++;\n \
    \   }\n    if (n != 1) result.push_back(count); // add count of n to vec\n   \
    \ return result;", "    std::vector<long> result;\n    long i = 2;\n    long j;\n\
    \    while (i <= sqrt(n)) {\n        // check if i divides n\n        if (n %\
    \ i == 0)\n            j = i;\n        else\n            j = (i * i) / n;\n  \
    \      if (j > i) {\n            result.push_back(i);\n            while (j >\
    \ i) {\n                result.push_back(j);\n                j = (j * i) / n;\n\
    \            }\n        } else {\n            if (j > i) {\n                result.push_back(j);\n\
    \            } else {\n                result.push_back(i);\n            }\n \
    \       }\n        i += 2;\n    }\n    if (n != result.back()) {\n        result.push_back(n);\n\
    \    }\n    std::reverse(result.begin(), result.end());\n    return result;",
  "    // Initialize vector with zero factors\n    std::vector<long> factors(0);\n\
    \    // Loop for checking for factor using sieve of erathostenes\n    for (long\
    \ i = 2; i <= n; ++i) {\n        // If current number is not prime\n        if\
    \ (n % i == 0) {\n            // Add factors except one\n            while (n\
    \ % i == 0) {\n                factors.push_back(i);\n                n /= i;\n\
    \            }\n        }\n    }\n    return factors;", "    std::vector<long>\
    \ factors;\n    long a = 1;\n    for (long i = 2; i <= n / 2; i++) {\n       \
    \ if ((n % i) == 0) {\n            factors.push_back(i);\n            a = a *\
    \ i;\n        }\n    }\n    factors.push_back(a);\n    return factors;", "   \
    \ std::vector<long> factors;\n    long i = 2;\n    while (i <= n) {\n        if\
    \ (n % i == 0) {\n            factors.push_back(i);\n            while (i < n\
    \ / i) {\n                ++i;\n            }\n        }\n        ++i;\n    }\n\
    \    return factors;", "  std::vector<long> factorization;\n  if (n != 1) {\n\
    \    if (n % 2 == 0) factorization.push_back(2);\n    if (n % 3 == 0) factorization.push_back(3);\n\
    \    if (n % 5 == 0) factorization.push_back(5);\n    if (n % 7 == 0) factorization.push_back(7);\n\
    \    long i = 3;\n    while (i <= sqrt(n)) {\n      if (n % i == 0) {\n      \
    \  while (i <= sqrt(n)) {\n          if (n % i == 0) {\n            factorization.push_back(i);\n\
    \            n /= i;\n            break;\n          }\n          i++;\n      \
    \  }\n        if (n != 1) factorization.push_back(n);\n      }\n      i++;\n \
    \   }\n  }\n  return factorization;", "\tstd::vector<long> factors;\n\tfor (long\
    \ i = 2; i * i <= n; i++) {\n\t\tbool found = false;\n\t\tlong j = 2;\n\t\twhile\
    \ (!found && (j * j <= n)) {\n\t\t\tif (n % j == 0) {\n\t\t\t\tfound = true;\n\
    \t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (found) {\n\t\t\tfactors.push_back(i);\n\t\t\
    }\n\t}\n\treturn factors;", "    std::vector<long> result;\n    long i = n;\n\
    \    while (i > 0) {\n        // i /= 2;\n        i = i / 2;\n        if (n %\
    \ i == 0) {\n            int count = 0;\n            for (int j = i; j > 0; j\
    \ /= 2) {\n                if (n % j == 0)\n                    count++;\n   \
    \         }\n            result.push_back(i);\n            result.push_back(count);\n\
    \            break;\n        }\n    }\n    return result;", "    std::vector<long>\
    \ factorization;\n    long sq = sqrt(n);\n    long rem;\n    long count = 0;\n\
    \    for (; sq != 1; sq = sq / 2)\n        for (rem = n / sq; rem > 0; rem = rem\
    \ / sq) {\n            count = count + 1;\n            factorization.push_back(rem);\n\
    \            n = n / rem;\n        }\n    if (n != 1) {\n        factorization.push_back(n);\n\
    \    }\n    return factorization;", "    std::vector<long> factors;\n    long\
    \ f = 2;\n    long pow = 1;\n    long sum = 1;\n    while (true) {\n        while\
    \ (n % f == 0) {\n            sum += pow;\n            pow *= f;\n        }\n\
    \        if (sum == n) {\n            factors.push_back(f);\n            sum =\
    \ 1;\n            pow = 1;\n        } else {\n            f += 2;\n        }\n\
    \        if (f > n / 2)\n            break;\n    }\n    return factors;", "  long\
    \ count = 1;\n  long start = 1;\n  std::vector<long> factors;\n  long factor =\
    \ 1;\n  long n = std::abs(n);\n  long i = 1;\n  while (i <= n) {\n    while ((n\
    \ % i) == 0) {\n      n /= i;\n      ++count;\n    }\n    factors.push_back(std::abs(i));\n\
    \    i = 2 * i;\n    if (n != 1) {\n      ++count;\n    }\n  }\n  if (n == 1)\
    \ {\n    return factors;\n  }\n  long s = 1;\n  for (int i = 0; i < factors.size();\
    \ ++i) {\n    while (factors[i] * s > n) {\n      s += factors[i];\n    }\n  }\n\
    \  if (s < n) {\n    factors.push_back(n);\n  }\n  return factors;", "  std::vector<long>\
    \ factors;\n  long i = 2;\n  while (n%i && i<=n / i) {\n    if (n % i == 0) {\n\
    \      factors.push_back(i);\n      n /= i;\n    }\n    ++i;\n  }\n  if (n !=\
    \ 1)\n    factors.push_back(n);\n  return factors;", "    std::vector<long> fact;\n\
    \    if (n <= 1)\n        fact.push_back(1);\n    else if (n % 2 == 0)\n     \
    \   fact.push_back(2);\n    else {\n        std::vector<long> f1 = factorize(n\
    \ / 2);\n        for (long i : f1)\n            for (long j : f1)\n          \
    \      if (i * j == n)\n                    fact.push_back(i * j);\n    }\n  \
    \  return fact;", "    std::vector<long> factorization(n);\n    long factor =\
    \ 2, divisor;\n    for (long i = 1; i <= n; i++) {\n        while (n % i == 0)\
    \ {\n            factorization[i - 1]++;\n            n /= i;\n        }\n   \
    \     while (factorization[i - 1] > 0) {\n            factorization[i - 1]--;\n\
    \            divisor = 1;\n            for (long j = 1; j <= factorization[i -\
    \ 1]; j++) {\n                divisor *= factor;\n            }\n            factor\
    \ *= divisor;\n        }\n    }\n    if (n == 1) {\n        factorization[0] =\
    \ 1;\n    }\n    return factorization;", "\tassert(n % 2 == 0);\n\tstd::vector<long>\
    \ factors{2};\n\twhile (n > 2) {\n\t\tif (n % 2 == 0) factors.push_back(2);\n\t\
    \tn = n / 2;\n\t}\n\tlong k = 1;\n\tfor (int i = 3; i <= n / i; i++) {\n\t\twhile\
    \ (n % i == 0) {\n\t\t\tk++;\n\t\t\tfactors.push_back(i);\n\t\t\tn = n / i;\n\t\
    \t}\n\t}\n\treturn factors;", "    std::vector<long> prime_factorization;\n  \
    \  for (long i = 2; i <= n / i; i++) {\n        while (n % i == 0) {\n       \
    \     prime_factorization.push_back(i);\n            n /= i;\n        }\n    }\n\
    \    if (n != 1) prime_factorization.push_back(n);\n    return prime_factorization;",
  "    std::vector<long> result;\n    long i = 1L;\n    for (long p = 2L; p < n; ++p)\
    \ {\n        while (i * p <= n) {\n            if (n % i == 0) {\n           \
    \     long temp = i;\n                while (i * p <= n) {\n                 \
    \   n = (n * temp) % n;\n                    ++p;\n                }\n       \
    \         result.push_back(p);\n                i = temp;\n            } else\
    \ {\n                ++p;\n            }\n        }\n        if (n != 1) {\n \
    \           long temp = i;\n            while (n * p <= n) {\n               \
    \ n = (n * temp) % n;\n                ++p;\n            }\n            result.push_back(p);\n\
    \            i = temp;\n        }\n    }\n    return result;", "    long product\
    \ = 1, p = 2;\n    while ((p << 1) <= n) {\n        product *= p;\n        p++;\n\
    \    }\n    std::vector<long> factors;\n    long c = product;\n    while (p >\
    \ 2) {\n        long k = 0, factor = 1;\n        while (k < (p - 1)) {\n     \
    \       if (c == product / p) {\n                factor += p;\n              \
    \  c = 1;\n            } else {\n                c /= p;\n            }\n    \
    \        k++;\n        }\n        factors.push_back(factor);\n        p--;\n \
    \   }\n    return factors;", "    std::vector<long> factorization;\n    std::vector<long>::iterator\
    \ itr = std::find(factorization.begin(), factorization.end(), 0);\n    long curr\
    \ = 1;\n    long factor = 2;\n    while (true) {\n        if (n >= curr) {\n \
    \           factorization.push_back(curr);\n            factor *= curr;\n    \
    \        itr = std::find(factorization.begin(), factorization.end(), curr);\n\
    \            curr = 1;\n            if (itr == factorization.end()) {\n      \
    \          break;\n            }\n        } else {\n            curr++;\n    \
    \    }\n    }\n    return factorization;", "  std::vector<long> res;\n  std::vector<long>\
    \ a(n);\n  for (long i = 2; i <= n; i++) {\n    a[i] = 1;\n  }\n  for (long i\
    \ = 2; i <= n; i++) {\n    while (n % i == 0) {\n      a[i] = a[i] * a[i] / i;\n\
    \      n = n / i;\n    }\n  }\n  res.assign(a.begin(), a.end());\n  return res;",
  "    assert(n != 1);\n    long c = n;\n    std::vector<long> factors;\n    while\
    \ (1) {\n        long r = 1;\n        long d;\n        for (int i = 2; i <= c;\
    \ i++) {\n            d = i;\n            while (d % 2 == 0 && d <= c) {\n   \
    \             d *= 2;\n            }\n            if (r * d > c) {\n         \
    \       break;\n            }\n            r *= d;\n        }\n        if (r >\
    \ c) {\n            factors.push_back(r);\n            c = r;\n        } else\
    \ {\n            factors.push_back(c);\n            break;\n        }\n    }\n\
    \    return factors;", "    std::vector<long> primes;\n    primes.push_back(n);\n\
    \    long m = n;\n    while (true) {\n        long c = m;\n        long e = 1;\n\
    \        while (c % 2 == 0) {\n            e *= 2;\n            c /= 2;\n    \
    \    }\n        while (c % 3 == 0) {\n            e *= 3;\n            c /= 3;\n\
    \        }\n        while (c % 5 == 0) {\n            e *= 5;\n            c /=\
    \ 5;\n        }\n        primes.push_back(e + 1);\n        m += 1;\n        //\
    \ check if m is greater than given number to check if it can be divided by any\
    \ further factor.\n        // if it is not then it is either prime or composite\
    \ and we add it to the vector primes.\n        // If it is composite and can be\
    \ divided by any further factor we skip this number\n        if (m > n) {\n  \
    \          break;\n        }\n    }\n    return primes;", "    std::vector<long>\
    \ f(n);\n    long p = 2;\n    long k = 1;\n    f[0] = 1;\n    long d = 1;\n  \
    \  while (d <= n) {\n        while (p < n && n % p == 0) {\n            n /= p;\n\
    \            f[k++] = p;\n        }\n        if (n > 1) {\n            d++;\n\
    \            while (p < n && n % p == 0) {\n                n /= p;\n        \
    \        f[k++] = p;\n            }\n        }\n        p++;\n    }\n    for (int\
    \ i = k - 1; i >= 0; i--)\n        if (n / f[i] > 1)\n            break;\n   \
    \ return f;", "    if (n == 1)\n        return std::vector<long>{n};\n    // Initialize\
    \ and fill vector with first prime factor of given number\n    std::vector<long>\
    \ factors;\n    long curr_pfp = 2;\n    while (curr_pfp <= n && n % curr_pfp ==\
    \ 0)\n        factors.push_back(curr_pfp);\n    // Increment first prime factor\
    \ and continue finding more until factor of n exceeds n\n    while (curr_pfp <=\
    \ n) {\n        while (n % curr_pfp == 0)\n            n /= curr_pfp;\n      \
    \  if (n == 1)\n            break;\n        factors.push_back(curr_pfp);\n   \
    \     curr_pfp++;\n    }\n    std::vector<long> fp(factors.size());\n    for (int\
    \ i = 0; i < fp.size(); i++)\n        fp[i] = factors[i];\n    return fp;", " \
    \   std::vector<long> factors;\n    for (long i = 2; i <= n; i++) {\n        while\
    \ (n % i == 0) {\n            n /= i;\n            factors.push_back(i);\n   \
    \     }\n    }\n    if (n > 1)\n        factors.push_back(1);\n    return factors;",
  "    std::vector<long> v;\n    v.reserve(n);\n    for (long i = 2; i <= sqrt(n);\
    \ ++i)\n    {\n        if (n % i == 0)\n            v.push_back(i);\n    }\n\n\
    \    for (int i = (int)v.size() - 1; i >= 0; --i)\n    {\n        for (long j\
    \ = i + 1; j * i <= n; j += i)\n            v.push_back(j * i);\n    }\n    return\
    \ v;", "\tif (n == 1)\n\t\treturn std::vector<long>({});\n\tstd::vector<long>\
    \ ret(factor(n));\n\tret.erase(ret.begin() + ret.begin() % ret.size());\n\treturn\
    \ ret;", "    if (n == 1) {\n        return {1};\n    }\n    std::vector<long>\
    \ ans;\n    for (long i = 2; i <= n / 2; ++i) {\n        while ((n % i) == 0)\
    \ {\n            ans.push_back(i);\n            n /= i;\n        }\n    }\n  \
    \  ans.push_back(n);\n    return ans;", "    std::vector<long> factors;\n    long\
    \ temp = n;\n    long counter = 0;\n    while(temp > 1) {\n        if(n % temp\
    \ == 0) {\n            factors.push_back(temp);\n            counter++;\n    \
    \        while(temp % temp == 0) {\n                temp = temp / temp;\n    \
    \            counter++;\n            }\n        }\n        temp = temp / temp;\n\
    \    }\n    factors.push_back(counter);\n    return factors;", "\tif (n == 1)\
    \ {\n\t\treturn {n};\n\t} else {\n\t\tstd::vector<long> factors;\n\t\tfor (long\
    \ i = 2; i <= std::sqrt(n); i++) {\n\t\t\tbool isPrime = true;\n\t\t\tfor (long\
    \ j = i * i; j < n; j += i) {\n\t\t\t\tif (n % j == 0) {\n\t\t\t\t\tisPrime =\
    \ false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isPrime) {\n\t\t\t\t\
    factors.push_back(i);\n\t\t\t}\n\t\t}\n\t\treturn factors;\n\t}", "    std::vector<long>\
    \ factor;\n    if (n == 1) return std::vector<long>({n});\n    long max = (long)sqrt(n);\n\
    \    long ans = 0;\n    for (long i = 2; i <= max; i++) {\n        while ((n %\
    \ i) == 0) {\n            ans = i;\n            factor.push_back(i);\n       \
    \     n /= i;\n        }\n    }\n    if (n != 1) factor.push_back(1);\n    return\
    \ factor;", "  long factors = 0;\n  std::vector<long> fac;\n  long i = 2;\n  while\
    \ (i * i <= n) {\n    while (n % i == 0) {\n      n = n / i;\n      fac[factors]\
    \ = i;\n      factors++;\n    }\n    i++;\n  }\n  return fac;", "    std::vector<long>\
    \ ans;\n    int k = 0, c = 1;\n    while (1) {\n        while (k > 0) {\n    \
    \        c *= k;\n            k--;\n        }\n        long x = n;\n        while\
    \ (c % x == 0) {\n            c *= x;\n            x /= x;\n            k++;\n\
    \        }\n        if (x == 1)\n            break;\n        ans.push_back(x);\n\
    \    }\n    return ans;", "    std::sort(std::begin(primes), std::end(primes),\
    \ [](long i, long j) {\n        return primes[i] < primes[j];\n    });\n    std::vector<long>\
    \ ans;\n    long i = 1;\n    long j = 1;\n    long k = 2;\n    long l = 2;\n \
    \   while (j <= n / i) {\n        while (k <= (n / j)) {\n            if (n %\
    \ i == 0) {\n                ans.push_back(i);\n                n /= i;\n    \
    \            k = k;\n            }\n            else {\n                ans.push_back(i);\n\
    \                n /= i;\n                k++;\n            }\n        }\n   \
    \     if (n != 1) {\n            ans.push_back(n);\n            n = 1;\n     \
    \   }\n        if (ans.size() == 1) break;\n        if (ans.back() >= primes[ans.size()\
    \ - 2]) break;\n        if (ans.size() == 2) break;\n        i++;\n        j++;\n\
    \    }\n    return ans;", "  std::vector<long> primes;\n  long m = n;\n  long\
    \ p = 2; //first prime factor of n\n  while (m % p != 0) {\n    primes.push_back(p);\n\
    \    m /= p;\n    p++;\n  }\n  for (long i = p; i <= m; i++) {\n    while (n %\
    \ i == 0) {\n      primes.push_back(i);\n      n /= i;\n    }\n  }\n  if (n >\
    \ 1) {\n    primes.push_back(n);\n  }\n  return primes;", "\tstd::vector<long>\
    \ result;\n\tlong sq = sqrt(n), q = n/sq;\n\tfor (int i = 2; i <= sq; i++) {\n\
    \t\tif (q%i == 0) {\n\t\t\tresult.push_back(i);\n\t\t\tq/= i;\n\t\t}\n\t}\n\t\
    return result;", "\t// Create all prime factorizations until n less than 10^9\n\
    \tstd::vector<long> factorization(n + 1, 0);\n\tlong p = 2; long count = 1;\n\t\
    while (p < n && count <= 10) {\n\t\tif (n % p == 0) {\n\t\t\tfactorization[p]\
    \ += 1;\n\t\t\tn /= p;\n\t\t\tcount++;\n\t\t}\n\t\tp++;\n\t}\n\tif (n != 1) {\n\
    \t\tfactorization[n] += 1;\n\t}\n\tstd::reverse(factorization.begin(), factorization.end());\n\
    \treturn factorization;", "    std::vector<long> primeFactors;\n    long count\
    \ = 0;\n    for (long i = 2; i <= n; i++) {\n        while ((n % i) == 0) {\n\
    \            n = n / i;\n            primeFactors.push_back(count++);\n      \
    \  }\n    }\n    if (n > 1) {\n        primeFactors.push_back(count++);\n    }\n\
    \    return primeFactors;", "    long d = n;\n    // Store factorization in vector\
    \ \n    std::vector<long> factorization;\n\n    // Start storing factors of n\
    \ from smallest to largest\n    while (d % 2 == 0) {\n        factorization.push_back(d);\n\
    \        d /= 2;\n    }\n\n    // If n has only 1 factor of prime then n is prime\
    \ itself.\n    // In this case just return the vector of prime factors.\n    if\
    \ (d == 1)\n        return factorization;\n\n    // Start storing factors of n\
    \ from smallest to largest\n    while (d % 3 == 0) {\n        factorization.push_back(d);\n\
    \        d /= 3;\n    }\n\n    // If n has only 1 factor of prime then n is prime\
    \ itself.\n    // In this case just return the vector of prime factors.\n    if\
    \ (d == 1)\n        return factorization;\n\n    // Start storing factors of n\
    \ from smallest to largest\n    while (d % 5 == 0) {\n        factorization.push_back(d);\n\
    \        d /= 5;\n    }\n\n    // If n has only 1 factor of prime then n is prime\
    \ itself.\n    // In this case just return the vector of prime factors.\n    if\
    \ (d == 1)\n        return factorization;\n\n    // Start storing factors of n\
    \ from smallest to largest\n    while (d % 7 == 0) {\n        factorization.push_back(d);\n\
    \        d /= 7;\n    }\n\n    // If n has only 1 factor of prime then n is prime\
    \ itself.\n    // In this case just return the vector of prime factors.\n    if\
    \ (d == 1)\n        return factorization;\n\n    // If n is not prime then store\
    \ it in factorization\n    return factorization;"]
stop_tokens:
- "\n}"
