name: HumanEval_11_string_xor
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input are two strings a and\
  \ b consisting only of 1s and 0s.\n// Perform binary XOR on these inputs and return\
  \ result also as a string.\n// >>> string_xor((\"010\"), (\"110\"))\n// (\"100\"\
  )\nstd::string string_xor(std::string a, std::string b) {\n"
tests: "}\nint main() {\n    auto candidate = string_xor;\n    assert(candidate((\"\
  111000\"), (\"101010\")) == (\"010010\"));\n    assert(candidate((\"1\"), (\"1\"\
  )) == (\"0\"));\n    assert(candidate((\"0101\"), (\"0000\")) == (\"0101\"));\n\
  }\n"
completions: ["    assert(a.size() >= b.size());\n    std::string res = \"\";\n  \
    \  for(int i = 0; i < a.size(); i++) {\n        for(int j = 0; j < b.size(); j++)\
    \ {\n            if(std::tolower(a[i]) == std::tolower(b[j])) {\n            \
    \    res += '1';\n            } else {\n                res += '0';\n        \
    \    }\n        }\n    }\n    return res;", "    std::string ret;\n    for (auto\
    \ i = 0; i < a.size() && i < b.size(); i++) {\n        ret.push_back(std::to_string(a[i]\
    \ ^ b[i]));\n    }\n    return ret;", "    assert(a.size() == b.size());\n   \
    \ std::string result;\n    int carry = 0, pos = 0;\n    while (pos < a.size())\
    \ {\n        char temp = a[pos] ^ b[pos];\n        result += temp;\n        carry\
    \ += temp;\n        pos++;\n    }\n    int lastPos = 0;\n    while (pos < a.size())\
    \ {\n        char temp = carry;\n        result += temp;\n        carry += a[pos];\n\
    \        pos++;\n    }\n    if (carry != 0) {\n        result += carry + a[pos];\n\
    \    }\n    if (result.size() >= 2) {\n        result.resize(result.size() - 1);\n\
    \    }\n    return result;", "    string result;\n    int m = std::min(a.size(),\
    \ b.size());\n    for (int i = 0; i < m; i++) {\n        int x = a.at(i) ^ b.at(i);\n\
    \        result.append(std::to_string((x & 1) ? 2 : 0));\n    }\n    return result;",
  "  int len = (int)a.size() + (int)b.size();\n  char temp[len];\n  int i = 0;\n \
    \ int j = 0;\n  while (i < a.size() && j < b.size()) {\n    temp[i++] = a[j++];\n\
    \  }\n  while (i < a.size()) {\n    temp[i++] = a[i++];\n  }\n  while (j < b.size())\
    \ {\n    temp[i++] = b[j++];\n  }\n  std::string ans = \"\";\n  for (int k = 0;\
    \ k < len; k++) {\n    ans += temp[k];\n  }\n  return ans;", "    size_t len1\
    \ = a.length();\n    size_t len2 = b.length();\n    std::string result = \"\"\
    ;\n    assert(len1 < len2);\n    while (len1 != len2)\n        len1 -= len2;\n\
    \    if (len1 == 0)\n        return result;\n    while (len1 != 0)\n        result\
    \ += a[--len1];\n    while (len2 != 0)\n        result += b[--len2];\n    return\
    \ result;", "  assert(a.size() == b.size());\n  std::string c(a.size(), 0);\n\
    \  for (int i = 0; i < a.size(); ++i)\n    c[i] = (to_lower(a[i]) ^ to_lower(b[i]))\
    \ % 2;\n  return c;", "    int length = a.size() + b.size();\n    std::string\
    \ res;\n    // Initialize result\n    res.resize(length);\n    // Perform XOR\
    \ on input strings\n    for (int i = 0; i < length; i++)\n        res.at(i) =\
    \ a.at(i) ^ b.at(i);\n    // Return result string\n    return res;", "    std::string\
    \ res;\n    int len = std::min(a.size(), b.size());\n    for(int i = 0; i < len;\
    \ ++i) {\n        res += std::to_string(a[i] ^ b[i]);\n    }\n    return res;",
  "    std::bitset<8> a_temp;\n    std::bitset<8> b_temp;\n    std::bitset<8> result;\n\
    \    int carry = 0;\n    for (int i = 0; i < 8; i++) {\n        if (a[i] != '1')\
    \ a_temp[i] = 0;\n        if (b[i] != '1') b_temp[i] = 0;\n    }\n    for (int\
    \ i = 0; i < 8; i++) {\n        a_temp[i] ^= b_temp[i];\n        a_temp[i] ^=\
    \ carry;\n        carry = a_temp[i];\n        carry <<= 1;\n        carry |= 1;\n\
    \        if (a_temp[i]) result += std::bitset<8>('1');\n    }\n    std::string\
    \ result;\n    for (int i = 0; i < 8; i++) result += std::bitset<8>(result[i]).to_string();\n\
    \    return result;", "    assert(a.size() > 0 && b.size() > 0);\n    assert(a.size()\
    \ == b.size());\n    std::string s;\n    for (int i = 0; i < a.size(); i++) {\n\
    \        if (int(a[i]) ^ int(b[i])) s += '1';\n        else s += '0';\n    }\n\
    \    return s;", "    size_t len1 = a.length();\n    size_t len2 = b.length();\n\
    \    std::string res = \"\";\n    if (len1 != len2) {\n        std::cerr << \"\
    Size mismatch \" << len1 << \" \" << len2 << std::endl;\n    }\n    for (size_t\
    \ i = 0; i < len1; i++) {\n        res += (static_cast<char>(a[i] ^ b[i]) - static_cast<char>('0'))\
    \ * pow(10, len - 1 - i);\n    }\n    return res;", "    std::string res = \"\"\
    ;\n    // Iterate over the two strings one char at a time.\n    for (int i = 0;\
    \ i < a.size(); ++i) {\n        res += a[i] ^ b[i];\n    }\n    return res;",
  "    std::string res = \"\";\n    int sum = 0;\n    for (int i = 0; i < a.size();\
    \ i++) {\n        int x = a[i] - '0';\n        int y = b[i] - '0';\n        sum\
    \ += x * y;\n    }\n    for (int i = 0; i < a.size(); i++) {\n        sum += a[i]\
    \ - '0';\n    }\n    for (int i = 0; i < b.size(); i++) {\n        sum += b[i]\
    \ - '0';\n    }\n    sum = (~sum + 1) % 2;\n    res += std::to_string(sum);\n\
    \    return res;", "    std::string c = \"0\";\n    if (a.length() > b.length())\
    \ {\n        c = b;\n        b = a;\n        a = c;\n    }\n    int length = a.length();\n\
    \    int max_length = b.length();\n    int max_length_temp = max_length;\n   \
    \ for (int i = length; i >= 0; --i) {\n        if (std::bitset<max_length_temp>(a[i])\
    \ == std::bitset<max_length_temp>(b[i])) {\n            max_length_temp--;\n \
    \       }\n        else {\n            max_length = i;\n            break;\n \
    \       }\n    }\n    string result = \"0\";\n    for (int i = 0; i < max_length_temp;\
    \ i++) {\n        result += std::bitset<max_length>(a[i]);\n    }\n    for (int\
    \ i = 0; i < max_length_temp; i++) {\n        result += std::bitset<max_length>(b[i]);\n\
    \    }\n    return result;", "  int i = 0;\n  int j = 0;\n  int k = 0;\n  int\
    \ n = a.size();\n  int m = b.size();\n  std::string result(n + 1, ' ');\n  for\
    \ (int j = 0; j < n; j++) {\n    k = ((b[j] - '0') * i + (a[j] - '0')) % 2;\n\
    \    result[j] = (b[j] == a[j]) ? '0' : '1';\n    if (k != 0) j++;\n    i = ((i\
    \ + 1) % 2);\n  }\n  result[n - 1] = '0';\n  return result;", "    assert(a.size()\
    \ == b.size());\n    std::string ans(a.size(), '0');\n    for (auto &x : a) {\n\
    \        x = (x ^ b[a.size() - x - 1]);\n    }\n    return ans;", "    std::string\
    \ result = \"\";\n    int size = a.size();\n    for (int i = 0; i < size; i++)\
    \ {\n        result += a[i] ^ b[i];\n    }\n    return result;", "    std::unordered_map<char,\
    \ int> hash;\n    std::string result = \"\";\n\n    // Iterate through characters\
    \ of string 'a' and initialize int to 1 if 'a' character is present in string\
    \ 'b'\n    for(char aChar: a) {\n        if(b.find(aChar) != std::string::npos)\n\
    \            hash[aChar] = 1;\n        else\n            hash[aChar] = 0;\n  \
    \  }\n\n    // Iterate through characters of string 'b' and initialize int to\
    \ 1 if 'b' character is present in string 'a'\n    for(char bChar: b) {\n    \
    \    if(hash.find(bChar) != hash.end())\n            hash[bChar] = 1;\n      \
    \  else\n            hash[bChar] = 0;\n    }\n\n    for(char aChar: a) {\n   \
    \     result += aChar;\n    }\n\n    for(char bChar: b) {\n        if(hash.find(bChar)\
    \ != hash.end()) {\n            result += '0';\n        }\n    }\n\n    return\
    \ result;", "    std::string s = a + b;\n    for (size_t i = 0; i < s.size() /\
    \ 2; i++) {\n        s[2 * i] = s[2 * i] ^ s[2 * i + 1];\n        s[2 * i + 1]\
    \ = s[2 * i] ^ s[2 * i + 1];\n    }\n    return s;", "\tstd::string s = \"\";\n\
    \tauto i = a.begin(), j = b.begin();\n\twhile(i < a.end() && j < b.end()) {\n\t\
    \ts += ((*i ^ *j) ^ '0');\n\t\ti++;\n\t\tj++;\n\t}\n\twhile(i < a.end()) {\n\t\
    \ts += (*i ^ '0');\n\t\ti++;\n\t}\n\twhile(j < b.end()) {\n\t\ts += (*j ^ '0');\n\
    \t\tj++;\n\t}\n\treturn s;", "    std::bitset<64> ba;\n    ba.assign(a.begin(),\
    \ a.end());\n    std::bitset<64> bb;\n    bb.assign(b.begin(), b.end());\n   \
    \ std::string result = \"\";\n    while (ba.size() > 0) {\n        result += (char)(ba.reduce()\
    \ ^ bb.reduce());\n        ba.flip_all();\n        bb.flip_all();\n    }\n   \
    \ return result;", "  int n = a.length(), m = b.length(), m2 = m;\n  assert(m\
    \ > 0);\n  // m2 will hold final result\n  std::string result;\n  for (int i =\
    \ 0; i < n2; i++) {\n    result += (char)(std::tolower(a[i]) ^ std::tolower(b[n1\
    \ - 1 - i]));\n  }\n  return result;", "    // TODO: Complete this function\n\
    \    // This string XOR operation is called XOR on strings as it is similar to\
    \ concatenating two strings.\n    // For eg: XOR(\"ab\", \"cd\") returns \"acdb\"\
    .\n    // For this problem, we will consider strings as arrays of ASCII characters.\n\
    \    // Read more about the logic here: http://www.cprogramming.com/reference/string/byte/strxor.html\n\
    \    // The function should return a new string consisting of the result of the\
    \ XOR operation.\n    // Note that this function returns an empty string if the\
    \ input strings are of different sizes.\n    if (a.length() != b.length())\n \
    \       return \"\";\n    // Declare two temporary variables to hold results of\
    \ XOR\n    // One character at a time will be added to the result string.\n  \
    \  // For example: XOR(\"ab\", \"cd\") --> 'a', 'b', 'c', 'd'\n    // One XOR\
    \ operation is performed for each input character to get the result\n    // For\
    \ example: \"a\" XOR \"b\" --> 'a'\n    // \"a\" XOR \"\" --> \"\"\n    // \"\"\
    \ XOR \"a\" --> \"\"\n    // Note that an empty string is returned when a string\
    \ of length 0 is passed\n    // For this problem, we will consider strings as\
    \ arrays of ASCII characters.\n    char result[kMaxLength];\n    // Use an auxiliary\
    \ array for counting number of characters in input strings\n    int countA = 0;\n\
    \    int countB = 0;\n    // Iterate through each character in input strings\n\
    \    for (int i = 0; i < a.length(); i++) {\n        // If the current character\
    \ is a character from string A\n        if (a[i] == '1') {\n            // Increment\
    \ count\n            countA++;\n            // Get the character from the input\
    \ string and store it in the result string\n            // Remember that indexing\
    \ starts from 0 so the last element of a string has index length-1\n         \
    \   result[countA] = a[i];\n        }\n    }\n    // Iterate through each character\
    \ in input strings\n    for (int i = 0; i < b.length(); i++) {\n        // If\
    \ the current character is a character from string B\n        if (b[i] == '1')\
    \ {\n            // Increment count\n            countB++;\n            // Get\
    \ the character from the input string and store it in the result string\n    \
    \        // Remember that indexing starts from 0 so the last element of a string\
    \ has index length-1\n            result[countA] = b[i];\n        }\n    }\n \
    \   // Return the result string\n    return std::string(result);", "    std::cout\
    \ << \"string_xor(a,b) = \" << string_xor(a, b) << std::endl;\n    assert(a.size()\
    \ == b.size());\n    std::string result = \"\";\n    for (size_t i = 0; i < (a.size());\
    \ i++) {\n        result += (a[i] ^ b[i]);\n    }\n    return result;", "    int\
    \ size = a.size();\n    assert(size == b.size());\n    std::string ans(size);\n\
    \    for (int i = 0; i < size; i++)\n    {\n        ans[i] = a[i] ^ b[i];\n  \
    \  }\n    return ans;", "  int len = a.length();\n  std::string s(len, '0');\n\
    \  for (int i = 0; i < len; i++) {\n    s[i] = a[i]^b[i];\n  }\n  return s;",
  "  std::bitset<16> abits(a.size(), 0);\n  std::bitset<16> bbits(b.size(), 0);\n\
    \  for (int i = 0; i < 16; i++) {\n    abits[i] = a[i] != '0';\n    bbits[i] =\
    \ b[i] != '0';\n  }\n  return abits ^ (bbits);", "    std::vector<char> a_vector(a.size()\
    \ + 1, 0);\n    std::vector<char> b_vector(b.size() + 1, 0);\n    for (size_t\
    \ i = 0; i < a.size(); i++) {\n        a_vector[i] = a[i];\n    }\n    for (size_t\
    \ i = 0; i < b.size(); i++) {\n        b_vector[i] = b[i];\n    }\n    // return\
    \ \"a\" + b;\n    std::string xor_string = std::to_string(a_vector[0]) +'0' +\
    \ std::to_string(b_vector[0]);\n    for (size_t i = 1; i < a_vector.size() - 1;\
    \ i++) {\n        xor_string += '0' + std::to_string(a_vector[i]) +'0' + std::to_string(b_vector[i]);\n\
    \    }\n    return std::to_string(a_vector.size() - 1) +'0' + std::to_string(xor_string);",
  "    std::string result;\n    auto bit_count = std::max(std::max(a.size(), b.size()),\
    \ static_cast<size_t>(9));\n    for (auto i = 0; i < bit_count; i++) {\n     \
    \   auto a_char = (a.size() <= bit_count - i ? 0 : (std::stoul(a.substr(i, 1))\
    \ != 0));\n        auto b_char = (b.size() <= bit_count - i ? 0 : (std::stoul(b.substr(i,\
    \ 1)) != 0));\n        auto carry = static_cast<size_t>(a_char) != static_cast<size_t>(b_char);\n\
    \        result.push_back((carry ? '1' : '0') + static_cast<char>((a_char ^ b_char)));\n\
    \    }\n    return result;", "    std::string res = \"\";\n    for(int i = 0;\
    \ i < a.size(); i++)\n        res += ((a[i] == '1') != (b[i] == '1')) ? '0' :\
    \ '1';\n    return res;", "    std::string ans = a;\n    std::string bn = b;\n\
    \    // We will continue doing XOR until we get to the end of the\n    // second\
    \ string. At that point we will start our search for\n    // the second string.\n\
    \    while (!bn.empty()) {\n        size_t offset = bn.find('0');\n        if\
    \ (offset != std::string::npos) {\n            size_t start = offset - 1;\n  \
    \          // We will keep XORing until we get to the end of the first\n     \
    \       // string or the end of the second string.\n            while (!ans.empty())\
    \ {\n                char an = ans[0];\n                char bn = bn[0];\n   \
    \             // First character in both strings must be different\n         \
    \       // Otherwise, we would have done XOR on the whole string.\n          \
    \      if ((an != '1') && (bn != '1')) {\n                    ans[start] = '1';\n\
    \                    break;\n                }\n                // If either string\
    \ ends with 0, then XOR it with the other\n                // string. Otherwise,\
    \ just add the character from the other\n                // string.\n        \
    \        if ((an == '0') || (bn == '0')) {\n                    ans[start] = bn;\n\
    \                    break;\n                }\n                // If both strings\
    \ are empty, then just append the first character\n                // from the\
    \ first string to the result.\n                if (bn == '1') {\n            \
    \        ans[start] = an;\n                    break;\n                }\n   \
    \             ans[start] = an;\n                start--;\n            }\n    \
    \        break;\n        }\n        bn.pop_back();\n    }\n    return ans;", " \
    \   std::stringstream result;\n    // If string length is odd, add trailing 0\n\
    \    if (a.size() % 2 != 0 || b.size() % 2 != 0)\n        result += std::string(a.size()\
    \ + 1, 0);\n    std::string carry = std::string(1, 0);\n    for (std::string::iterator\
    \ it1 = a.begin(), it2 = b.begin(); it1 != a.end(); ++it1, ++it2) {\n        std::string\
    \ s = it1 ^ it2;\n        result += std::to_string(s.size(), 2) + (carry != s);\n\
    \        carry = s;\n    }\n    return result.str();", "    std::string ans =\
    \ \"\";\n    int m = a.size();\n    int n = b.size();\n    int carry = 0;\n  \
    \  for (int i = 0; i < m; i++) {\n        carry = 0;\n        for (int j = 0;\
    \ j < n; j++) {\n            int d = a[i][0] - b[j][0] + carry;\n            ans\
    \ += (d > 9) ? d + 9 : d;\n            carry = d / 10;\n            d = d % 10;\n\
    \        }\n    }\n    if (carry > 0)\n        ans += carry;\n    return ans;",
  "    std::string result = \"\";\n    for (int i = 0; i < a.size(); i++) {\n    \
    \    if (int(a[i]) ^ int(b[i])) result += ((int(a[i]) ^ int(b[i])) > 0)\n    \
    \        ? ((char) 1) : (char) 0;\n    }\n    return result;", "    std::string\
    \ res = \"\";\n    int n = a.size();\n    int m = b.size();\n    for (int i =\
    \ 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            res +=\
    \ ((int)a[i]) ^ ((int)b[j]);\n        }\n    }\n    return res;", "    std::string\
    \ result(a.size() + b.size());\n    size_t i = 0;\n    for (size_t j = 0;j < a.size();\
    \ ++j) {\n        char c1 = a[j];\n        char c2 = b[j];\n        result[i++]\
    \ = c1 ^ c2;\n    }\n    return result + i;", "    std::string ret;\n    for (int\
    \ i = 0; i < a.size(); i++) {\n        char c = a[i] - '0';\n        c ^= b[i]\
    \ - '0';\n        ret += c < 10 ? std::string(1, c + 1) : std::string(1, c);\n\
    \    }\n    return ret;", "  std::string res = \"0\";\n  res.reserve(a.size()\
    \ + b.size());\n  for (int i = 0; i < a.size(); ++i) {\n    res += (std::tolower(a[i])\
    \ ^ std::tolower(b[i]));\n  }\n  return res;", "    std::stringstream ss;\n  \
    \  ss << std::hex << std::setfill('0');\n    ss << std::setw(2) << std::setbase(16)\
    \ << std::hex;\n    ss << std::hex << std::setfill('0');\n    ss << std::setw(2)\
    \ << std::setbase(16) << std::hex;\n    ss << std::hex << std::setfill('0');\n\
    \    ss << std::setw(2) << std::setbase(16) << std::hex;\n    ss << std::hex <<\
    \ std::setfill('0');\n    ss << std::setw(2) << std::setbase(16) << std::hex;\n\
    \    ss << std::hex << std::setfill('0');\n    ss << std::setw(2) << std::setbase(16)\
    \ << std::hex;\n    ss << std::hex << std::setfill('0');\n    ss << std::setw(2)\
    \ << std::setbase(16) << std::hex;\n    ss << std::hex << std::setfill('0');\n\
    \    ss << std::setw(2) << std::setbase(16) << std::hex;\n    ss << std::hex <<\
    \ std::setfill('0');\n    ss << std::setw(2) << std::setbase(16) << std::hex;\n\
    \    ss << std::hex << std::setfill('0');\n    ss << std::setw(2) << std::setbase(16)\
    \ << std::hex;\n    ss << std::hex << std::setfill('0');\n    ss << std::setw(2)\
    \ << std::setbase(16) << std::hex;\n    ss << std::hex << std::setfill('0');\n\
    \    ss << std::setw(2) << std::setbase(16) << std::hex;\n    ss << std::hex <<\
    \ std::setfill('0');\n    ss << std::setw(2) << std::setbase(16) << std::hex;\n\
    \    ss << std::hex << std::setfill('0');\n    ss << std::setw(2) << std::setbase(16)\
    \ << std::hex;\n    ss << std::hex << std::setfill('0');\n    ss << std::setw(2)\
    \ << std::setbase(16) << std::hex;\n    ss << std::hex << std::setfill('0');\n\
    \    ss << std::setw(2) << std::setbase(16) << std::hex;\n    ss << std::hex <<\
    \ std::setfill('0');\n    ss << std::setw(2) << std::setbase(16) << std::hex;\n\
    \    ss << std::hex << std::setfill('", "    assert(a.size() == b.size());\n \
    \   int carry = 0;\n    std::string res = \"\";\n    for (size_t i = 0; i < a.size();\
    \ ++i) {\n        int temp = carry;\n        int res = (a[i] ^ b[i]) + temp;\n\
    \        carry = res / 2;\n        res = (res % 2) + temp;\n        res += carry;\n\
    \        res += '0';\n        res += '0';\n    }\n    if (carry != 0) res += '1';\n\
    \    return res;", "    std::string ans = \"\";\n    for(int i = 0; i < a.length();\
    \ i++) {\n        ans += to_string(((int)(a.at(i))^(int)b.at(i))); \n    }\n \
    \   return ans;", "    int n = a.length();\n    assert(n >= b.length());\n   \
    \ std::string s(n);\n    for (int i = 0; i < n; ++i) {\n        char ca = a[i];\n\
    \        char cb = b[i];\n        s[i] = (ca^cb);\n    }\n    return s;", "  \
    \  // Find the length of shortest string\n    int shortest = a.length() < b.length()\
    \ ? a.length() : b.length();\n    std::stringstream result;\n    std::string temp\
    \ = \"\";\n    // Loop through all characters in shortest string\n    for (int\
    \ i = 0; i < shortest; i++) {\n        temp += std::to_string(std::bit_xor(\n\
    \            std::stoul(a[i]) - std::stoul(b[i]), \n            std::stoul(a[i])\
    \ - std::stoul(b[i])));\n    }\n    // Return result\n    return (temp == \"\"\
    ) ? \"0\" :\n        temp;", "    std::string result;\n    int l1 = a.length();\n\
    \    int l2 = b.length();\n    int size = (l1 > l2) ? l1 : l2;\n    int i = 0;\n\
    \    while (i < size) {\n        result += a[i]^b[i++];\n    }\n    return result;",
  "  if (a.size() != b.size()) return \"Not equal\";\n  string s = a;\n  reverse(s.begin(),\
    \ s.end());\n  reverse(b.begin(), b.end());\n  for (size_t i = 0; i < s.size();\
    \ i++) {\n    s[i] ^= b[i];\n  }\n  return s;", "    std::string res;\n    //\
    \ Iterate through each character of string a and b and\n    // compare with their\
    \ XOR. Append the XOR to the\n    // result string.\n    for (char& c : a) {\n\
    \        c = c ^ b[res.size()];\n        res += c;\n    }\n    // Do the same\
    \ with b. Append the XOR to the\n    // result string.\n    for (char& c : b)\
    \ {\n        c = c ^ a[res.size()];\n        res += c;\n    }\n    return res;",
  "    std::string result = \"\";\n    int size = a.size();\n    int sizeb = b.size();\n\
    \n    for(int i = 0; i < size; i++) {\n        result += (std::to_string(static_cast<int>(a[i]\
    \ ^ b[i])));\n    }\n    return result;", "    assert(a.size() == b.size());\n\
    \    std::string result = \"\";\n    for(int i = 0; i < a.size(); i++) {\n   \
    \     if(int(a[i]) ^ int(b[i]))\n            result += (a[i] ? '1' : '0');\n \
    \       else\n            result += (a[i] ? '0' : '1');\n    }\n    return result;",
  "    if (a.size() == b.size()) assert(a.size() > 0);\n    if (a.size() == 0) return\
    \ b;\n    if (b.size() == 0) return a;\n    std::string res = \"\";\n    int len\
    \ = (b.size() + 1) >> 1;\n    for (int i = 0; i < len; i++) {\n        char a1\
    \ = b[i]; char a2 = b[i + 1];\n        char a3 = b[i + len];\n        char b1\
    \ = a[i];\n        res += a1 ^ a2;\n        res += a3 ^ b1;\n    }\n    return\
    \ res;", "\tstd::string c = a;\n\tfor (int i = 0; i < b.size(); i++) {\n\t\tc\
    \ = c + b[i];\n\t}\n\treturn c;", "    // Get the sizes of the strings\n    int\
    \ len = a.size();\n    int len2 = b.size();\n    // Allocate memory for output\n\
    \    std::string result;\n    // Perform XOR on strings and store result in result\n\
    \    for (int i = 0; i < len; i++) {\n        result[i] = a[i] ^ b[i];\n    }\n\
    \    return result;", "  if (a.length() < b.length()) {\n    return string_xor(b,\
    \ a);\n  }\n  if (b.length() < a.length()) {\n    return string_xor(a, b);\n \
    \ }\n  int maxLength = (a.length() > b.length()) ? a.length() : b.length();\n\
    \  int minLength = (a.length() < b.length()) ? a.length() : b.length();\n  std::string\
    \ rep(minLength, '0');\n  int index = 0;\n  for (int i = 0; i < maxLength; i++)\
    \ {\n    rep[i] = a[index] ^ b[index];\n    index++;\n  }\n  return rep;", " \
    \   std::stack<char> s;\n    // We will XOR until we have no more symbols to XOR\n\
    \    while (a.length() > 0 && b.length() > 0) {\n        // If current symbols\
    \ from both inputs are the same, XOR it and\n        // put the result onto stack\n\
    \        if (a[0] == b[0]) {\n            s.push(a[0]);\n            a.erase(0,\
    \ 1);\n            b.erase(0, 1);\n        }\n        // If current symbol from\
    \ b input is different from current symbol\n        // from b input, XOR current\
    \ symbol from a and put the result onto\n        // stack.\n        else if (b[0]\
    \ != a[0]) {\n            s.push(a[0]);\n            a.erase(0, 1);\n        }\n\
    \        // If current symbol from a input is different from current symbol from\n\
    \        // a input, XOR current symbol from b and put the result onto stack.\n\
    \        else if (a[0] != b[0]) {\n            s.push(a[0]);\n            b.erase(0,\
    \ 1);\n        }\n        else {\n            // If the stack is empty means both\
    \ inputs are empty and we will\n            // return the empty string.\n    \
    \        if (s.empty()) {\n                return \"\";\n            }\n     \
    \       // Else pop top element from stack and use it as the result for\n    \
    \        // XOR operation.\n            else {\n                s.push(s.pop());\n\
    \            }\n        }\n    }\n    // If we have reached here then there were\
    \ no more symbols to XOR.\n    // Return whatever remains onto stack.\n    if\
    \ (s.empty()) {\n        return \"\";\n    }\n    // Else if stack isn't empty\
    \ then we have more symbols to XOR.\n    // Return the last symbol onto the stack.\n\
    \    else {\n        s.push(s.pop());\n        return s.top();\n    }", "    //\
    \ Find the common lengths\n    int len1 = a.length();\n    int len2 = b.length();\n\
    \    int lenmin = len1 < len2 ? len1 : len2;\n    // Compare and find the minimum\
    \ string length after comparison\n    int index = 0;\n    for(int i=0; i<lenmin;\
    \ i++) {\n        if(a[i] != b[i]) {\n            index = i;\n            break;\n\
    \        }\n    }\n\n    // Compare and return the results\n    if((a.length()\
    \ >= lenmin) && (b.length() >= lenmin)) {\n        std::string answer = a.substr(0,\
    \ index) + b.substr(index, lenmin);\n        return answer;\n    }\n    return\
    \ std::string();", "    assert(a.size() >= b.size());\n    std::string result\
    \ = \"\";\n    for (int i = 0; i < a.size(); i++) {\n        result.push_back(a[i]\
    \ ^ b[i]);\n    }\n    return result;", "    if (a.size() != b.size()) return\
    \ \"error\";\n    std::string res = \"0\";\n    for (size_t i = 0; i < a.size();\
    \ i++) {\n        res += std::to_string(a[i] ^ b[i]);\n    }\n    return res;",
  "    // Convert the strings to character arrays and add null terminators.\n    //\
    \ This is done in the loop just before this function is called.\n    char ca[a.size()+1];\n\
    \    strncpy(ca, a.c_str(), a.size()+1);\n\n    char cb[b.size()+1];\n    strncpy(cb,\
    \ b.c_str(), b.size()+1);\n\n    // Perform binary XOR on ca and cb\n    char\
    \ xor[a.size()+1];\n    for (int i = 0; i < a.size()+1; i++)\n        xor[i] =\
    \ ca[i] ^ cb[i];\n\n    // Append null-terminators to xor string.\n    xor[a.size()+1]\
    \ = '\\0';\n\n    // Convert the character array back to string.\n    std::string\
    \ res = xor;\n\n    // Return result.\n    return res;", "  assert(a.size() +\
    \ b.size() == 2);\n  std::string result = \"\";\n  for (int i = 0; i < a.size();\
    \ i++) {\n    result += std::bitset<8>(a[i]) ^ std::bitset<8>(b[i]);\n  }\n  return\
    \ result;", "    // Code goes here\n    string answer=\"\";\n    for(int i=0;\
    \ i<a.length(); i++)\n    {\n        answer+=((a[i]!=b[i])?'1':'0');\n    }\n\
    \    return answer;", "  std::string res = \"0\";\n  for (int i = 0; i < a.size();\
    \ i++) {\n    res += (a[i] ^ b[i]);\n  }\n  return res;", "  assert(a.size() ==\
    \ b.size());\n  std::string s(b.size(), '0');\n  for (int i = 0; i < a.size();\
    \ i++)\n    s[i] = (a[i] ^ b[i]);\n  return s;", "    std::string ans = \"\";\n\
    \    for (unsigned i = 0; i < a.length(); i++) {\n        ans += (std::to_string(static_cast<int>(a[i])\
    \ ^ static_cast<int>(b[i])));\n    }\n    return ans;", "  int size = a.size()\
    \ + b.size();\n  assert(size == 8);\n  std::string res(8, '\\0');\n  for (int\
    \ i = 0; i < 8; ++i) {\n    res[i] = (a[i] ^ b[i]);\n  }\n  return res;", "  \
    \  int len1 = a.size();\n    int len2 = b.size();\n    int res = len1 < len2 ?\
    \ len1 : len2;\n    std::string res = (len1 < len2) ? a : b;\n    for (int i =\
    \ 0; i < res; ++i) {\n        res ^= ((unsigned char)a[i] ^ b[i]);\n    }\n  \
    \  return res;", "    int carry = 0;\n    for (int i = 0; i < a.length(); i++)\
    \ {\n        int x = a[i] - '0';\n        int y = b[i] - '0';\n        int z =\
    \ x + y + carry;\n        carry = z / 10;\n        z %= 10;\n        z.push_back(z\
    \ % 10);\n    }\n    std::string result = \"\";\n    while(carry) {\n        result.push_back('0'\
    \ + carry);\n        carry = 1;\n    }\n    for(int i=result.length()-1;i>=0;i--)\n\
    \        result += result[i];\n    return std::string(result);", "    std::string\
    \ result = \"\";\n    for (auto i = a.begin(); i != a.end(); i++) {\n        result\
    \ += std::to_string(int(*i ^ int(b.at(i - a.begin()))) % 2);\n    }\n    return\
    \ result;", "    std::string ans = \"\";\n    int l = a.length();\n    int m =\
    \ b.length();\n    int count = 0;\n    for (int i = 0; i < m; i++) {\n       \
    \ for (int j = 0; j < l; j++) {\n            count += (a[j] == b[i]) ? (1): (0);\n\
    \        }\n        ans += (char)('0' + count);\n        count = 0;\n    }\n \
    \   return ans;", "    if (a.size() != b.size())\n        throw std::runtime_error(\"\
    Strings must have equal lengths.\");\n\n    int i = 0, j = 0;\n    std::string\
    \ result;\n\n    while (i < a.size() && j < b.size()) {\n        if (static_cast<int>(a[i])\
    \ == static_cast<int>(b[j]))\n            result += a[i];\n        ++i;\n    \
    \    ++j;\n    }\n\n    while (i < a.size()) {\n        result += a[i];\n    \
    \    ++i;\n    }\n\n    while (j < b.size()) {\n        result += b[j];\n    \
    \    ++j;\n    }\n\n    return result;", "    std::string s = a[0] + b[0];\n \
    \   for (int i = 1; i < a.size() && i < b.size(); ++i) {\n        if (s[i] ==\
    \ '1') {\n            s += a[i];\n        } else {\n            s += b[i];\n \
    \       }\n    }\n    return s;", "    // Check size of input\n    assert(a.length()\
    \ == b.length());\n\n    // Check length of input string\n    if (a.length() ==\
    \ 0)\n        return std::string();\n    if (b.length() == 0)\n        return\
    \ std::string();\n\n    // Convert both string to binary string\n    std::string\
    \ x = a;\n    std::string y = b;\n\n    // Perform XOR and convert back to string\n\
    \    return std::bitset<sizeof(unsigned) * 8>((x ^ y)).to_string();", "\tstd::string\
    \ ans = \"\";\n\tassert (a != \"\" && b != \"\");\n\tassert (a[0] == b[0]);\n\t\
    \n\tfor (int i = 0; i < a.size(); i++) {\n\t\tans += a[i] ^ b[i];\n\t}\n\t\n\t\
    return ans;", "    int i = 0, j = 0, k = 0;\n    while (i < a.length() && j <\
    \ b.length()) {\n        if (tolower(a[i]) != tolower(b[j])) {\n            return\
    \ a.substr(0, k);\n        }\n        i += 1;\n        j += 1;\n        k += 1;\n\
    \    }\n    if (a.length() == 0) {\n        return b.substr(0, k);\n    }\n  \
    \  if (b.length() == 0) {\n        return a.substr(0, k);\n    }\n    assert(0);\n\
    \    return \"\";", "    std::array<char, 4> s{{'0','0','0','0'}};\n    assert(a.size()\
    \ == b.size());\n    for (char& c : s) {\n        c = (a[b[0]] ^ b[1]) ^ '0';\n\
    \    }\n    std::string rep(s.size());\n    std::copy(rep.begin(), rep.end(),\
    \ s.begin());\n    return rep;", "    int n = a.size();\n    char arr[n + 2];\n\
    \    strcpy(arr, a.c_str());\n    arr[n / 2] = '\\0';\n    strcpy(arr + n, b.c_str());\n\
    \    arr[n / 2] = '\\0';\n    std::string ans;\n    for (int i = 0; i < n / 2;\
    \ i++) {\n        ans += std::string(std::string(arr[i], arr[i + 1]));\n    }\n\
    \    return ans;", "  std::string ret;\n  for (int i = 0; i < a.length(); i++)\
    \ {\n    std::string str1, str2;\n    if (a[i] == '1') {\n      str1 = \"1\";\n\
    \      str2 = \"0\";\n    } else {\n      str1 = \"0\";\n      str2 = \"1\";\n\
    \    }\n    for (int j = 0; j < b.length(); j++) {\n      std::string str3, str4;\n\
    \      if (b[j] == '1') {\n        str3 = \"1\";\n        str4 = \"0\";\n    \
    \  } else {\n        str3 = \"0\";\n        str4 = \"1\";\n      }\n      ret\
    \ += std::string(str1) + std::string(str2) + std::string(str3) + std::string(str4);\n\
    \    }\n  }\n  return ret;", "  std::string res = \"\";\n  for (size_t i = 0;\
    \ i < a.size(); ++i) {\n    res += std::bitset<8>(a[i]) ^ std::bitset<8>(b[i]);\n\
    \  }\n  return res;", "    std::vector<char> v(a, b);\n    std::string result;\n\
    \    for (auto it = v.begin(); it != v.end(); ++it)\n        result.append((*it)\
    \ ^ std::tolower(*it));\n    return result;", "  int x = 0;\n  for (int i = 0;\
    \ i < a.size(); i++) {\n    x += (int)a[i] - '0';\n  }\n  for (int i = 0; i <\
    \ b.size(); i++) {\n    x += (int)b[i] - '0';\n  }\n  std::string res = std::to_string(x);\n\
    \  std::reverse(std::begin(res), std::end(res));\n  return res;", "    // Convert\
    \ strings to an array of bits and perform XOR.\n    // A -> a^b\n    // B -> b^a\n\
    \    std::vector<bool> a_bits(a.length(), 0);\n    std::vector<bool> b_bits(b.length(),\
    \ 0);\n    for (int i = 0; i < a.length(); i++) {\n        a_bits[i] = a[i] ^\
    \ b[i];\n    }\n    for (int i = 0; i < b.length(); i++) {\n        b_bits[i]\
    \ = b[i] ^ a[i];\n    }\n    std::string c_str(2 * a.length(), '0');\n    for\
    \ (int i = 0; i < a.length(); i++) {\n        c_str[2 * i] = a_bits[i];\n    \
    \    c_str[2 * i + 1] = b_bits[i];\n    }\n    return c_str;", "    int carry\
    \ = 0;\n    for (int i = 0; i < b.size(); i++) {\n        int x = std::stoi(a,\
    \ 2);\n        int y = std::stoi(b, 2);\n        int z = x ^ y ^ carry;\n    \
    \    carry = z >> 1;\n        a[i] += carry * 2 + '0';\n        b[i] += carry\
    \ * 2 + '0';\n    }\n    return a;", "    if (a.size() != b.size()) throw std::runtime_error(\"\
    Strings do not have same length\");\n    std::string res = \"\";\n    for (int\
    \ i = 0; i < a.size(); i++) {\n        res += a[i] ^ b[i];\n    }\n    return\
    \ res;", "\t// We start by getting size of inputs. We know that both strings are\
    \ equal size.\n\tint len1 = a.size(), len2 = b.size();\n\t// We are gonna XOR\
    \ bits of these two strings so lets get their bit representation\n\tuint64_t xor_sum\
    \ = 0;\n\tfor (int i = 0; i < len1; i++) {\n\t\tuint64_t bit = uint64_t(a[i] -\
    \ '0') ^ uint64_t(b[i] - '0');\n\t\txor_sum += bit;\n\t}\n\tstd::string res =\
    \ \"\";\n\t// Now we can convert it to string and print it\n\tfor (int i = 0;\
    \ i < len1; i++) {\n\t\tuint64_t bit = xor_sum >> i;\n\t\tif (bit == 0) res +=\
    \ \"0\";\n\t\telse res += \"1\";\n\t}\n\treturn res;", "    std::string ret;\n\
    \    int len = a.length();\n    int b_len = b.length();\n    for(auto i=0;i<len;i++){\n\
    \        if(a[i]=='0'){\n            ret+=b[b_len-i-1];\n        }\n    }\n  \
    \  return ret;", "    std::string result;\n    // If string lengths are different\
    \ at some point then\n    // the XOR operation will not give correct answer.\n\
    \    assert(a.size() == b.size());\n    // Initialize result\n    for (size_t\
    \ i = 0; i < a.size(); i++) {\n        // Perform XOR operation and append result\
    \ to result\n        result += std::bitset<8>(a[i]) ^ std::bitset<8>(b[i]);\n\
    \    }\n    // Append leading zeros to result\n    while (result.size() < 8) result.insert(0,\
    \ '0');\n    return result;", "  std::string res;\n  for (int i = 0; i < a.size();\
    \ i++) {\n    res += a[i] == \"1\" ? b[i] : \"0\";\n  }\n  return res;", "  string\
    \ s = a + b;\n  assert(s.size() == 4);\n  s.erase(std::remove(s.begin(), s.end(),\
    \ '0'), s.end());\n  s.erase(std::remove(s.begin(), s.end(), '1'), s.end());\n\
    \  return s;", "    std::string ans = \"\";\n    for (int i = 0; i < a.size();\
    \ i++) {\n        ans += (char) (((a[i] == '1') ^ (b[i] == '1')) ? '0' : '1');\n\
    \    }\n    return ans;", "    assert(a.size() == b.size());\n    std::string\
    \ res = \"0\";\n    for (int i = 0; i < a.size(); i++) {\n        res += a[i]^b[i];\n\
    \    }\n    return res;", "    // We need to do some additional handling of strings\
    \ whose lengths exceed the maximum allowed length.\n    // They should be padded\
    \ with spaces.\n    if (a.size() > MAX_LENGTH) {\n        a = std::string(a, 0,\
    \ MAX_LENGTH);\n    }\n    if (b.size() > MAX_LENGTH) {\n        b = std::string(b,\
    \ 0, MAX_LENGTH);\n    }\n    std::string result = \"\";\n    int carry = 0;\n\
    \    for (int i = 0; i < a.size(); i++) {\n        int x = (int)(b[i] ^ a[i]);\n\
    \        int newCarry = carry + x & 1;\n        carry = (int)(carry + x >> 1);\n\
    \        result += newCarry;\n    }\n    if (carry != 0)\n        result += (char)(carry\
    \ + 32);\n    return result;", "  std::string answer;\n  for (int i = 0; i < a.size();\
    \ i++) {\n    if (a[i] != '0' || b[i] != '0') {\n      answer.push_back(a[i] ^\
    \ b[i]);\n    }\n  }\n  return answer;", "    std::string result = \"\";\n   \
    \ // Check two strings sizes\n    if (a.size() != b.size()) return \"\";\n\n \
    \   // Iterate through each of them\n    for (size_t i = 0; i < a.size(); i++)\
    \ {\n        // Compute XOR of two corresponding characters\n        result +=\
    \ static_cast<char>(static_cast<int>(a[i]) ^ static_cast<int>(b[i]));\n    }\n\
    \n    // Return result\n    return result;", "    assert(a.size() >= b.size());\n\
    \    std::string ans = \"\";\n    int i = 0, j = 0;\n    while(i < a.size() &&\
    \ j < b.size()) {\n        int m = std::min(a.size(), b.size());\n        int\
    \ n = std::min(i, j);\n        int x = std::min(a[i], b[j]);\n        ans += x\
    \ ^ m;\n        i += n;\n        j += n;\n    }\n    return ans;", "\tauto xor_string\
    \ = std::string{};\n\tfor(auto &i : a){\n\t\txor_string += std::to_string((int)i^(int)b[a.size()-1])+'0';\n\
    \t}\n\treturn xor_string;", "  int size = a.size();\n  // XOR result string with\
    \ empty string and add all bits at same positions.\n  std::string result = \"\"\
    ;\n  for (int i = 0; i <= size - 1; i++) {\n    result += to_string(int(static_cast<unsigned\
    \ int>(a[i] ^ b[i])));\n  }\n  return result;", "    size_t max_size = std::max(a.size(),\
    \ b.size());\n    std::string output = (max_size >= 3 ? std::string((max_size\
    \ - 3) * (max_size - 3)) / 2 : \"0\") + max_size;\n    size_t result_size = output.size();\n\
    \    output.resize(result_size);\n    \n    // Convert each character of string\
    \ to corresponding bit in binary number\n    for (size_t i = 0; i < max_size;\
    \ ++i) {\n        output[i] = a[i] ^ b[i];\n    }\n    return output;", "    int\
    \ len = (int)a.size();\n    int b_size = (int)b.size();\n    std::string result;\n\
    \    for (int i = 0; i < len; i++) {\n        int ai = (int)a[i]-'0';\n      \
    \  int bi = (int)b[i]-'0';\n        result.append(static_cast<char>(((ai ^ bi)\
    \ ^ (ai ^ bi))%10 + '0'));\n    }\n    return result;", "    std::string ans =\
    \ \"\";\n    for(int i = 0; i < a.size(); i++) {\n        if(a[i] == '1') ans\
    \ += '0';\n        else ans += '1';\n        if(b[i] == '1') ans += '0';\n   \
    \     else ans += '1';\n    }\n    return ans;", "    std::string s = std::string(\"\
    \");\n    int carry = 0;\n    for (unsigned int i = 0; i < a.size(); i++) {\n\
    \        int value = atoi(a.c_str() + i) - atoi(b.c_str() + i);\n        if (value\
    \ < 0) {\n            carry = 1;\n            value = ~value;\n        }\n   \
    \     s += (value & 1) + carry;\n        carry = 0;\n    }\n    while (carry)\
    \ {\n        s += carry;\n        carry = 0;\n    }\n    return s;", "    std::string\
    \ ans = \"\";\n    for (int i = 0; i < a.size(); ++i) {\n        int res = a[i]\
    \ + b[i];\n        ans = res + ans;\n    }\n    return ans;", "    if (a.size()\
    \ == 1 && b.size() == 1) {\n        return (char)((int)a[0] ^ int(b[0]));\n  \
    \  }\n    else if ((a.size() == 2 && b.size() == 2) && a[0] == 0 && b[0] == 1\
    \ && a[1] == 1 && b[1] == 1) {\n        return std::string(\"111\");\n    }\n\
    \    else {\n        return \"Invalid input\";\n    }", "  std::string ret(\"\"\
    );\n  for (int i = 0; i < a.size(); i++) {\n    ret += tolower(a[i]) ^ tolower(b[i]);\n\
    \  }\n  return ret;", "  std::string result = \"\";\n  int l = (int) a.size();\n\
    \  int r = (int) b.size();\n  assert(l == r);\n  for (int i = 0; i < l; i++) {\n\
    \    result += (a[i] ^ b[i]);\n  }\n  return result;", "    std::string ans;\n\
    \    // Traverse through both strings one character at a time.\n    for (int i\
    \ = 0; i < a.size(); i++) {\n        ans += a[i] ^ b[i];\n    }\n    return ans;",
  '    return std::string(b.size(), 0);', "  assert(a.length() == b.length());\n \
    \ std::string xor = \"\";\n  for (int i = 0; i < a.length(); i++) {\n    xor +=\
    \ to_string(a[i] ^ b[i]);\n  }\n  return xor;", "    std::vector<int> va = to_vector(a);\n\
    \    std::vector<int> vb = to_vector(b);\n    std::string res = \"\";\n    for\
    \ (auto v : va) {\n        res += ((v == 1) ? 0 : 1);\n    }\n    for (auto v\
    \ : vb) {\n        res += ((v == 1) ? 0 : 1);\n    }\n    return res;", "    std::string\
    \ res;\n    for(int i = 0; i < a.length(); i++) {\n        res += (((int)a[i]\
    \ ^ b[i]) >= 0) ? \"1\" : \"0\";\n    }\n    return res;", "    int len1 = a.size(),\
    \ len2 = b.size();\n    if (len1 > len2)\n        std::swap(len1, len2);\n   \
    \ if (len1 == 0)\n        return a;\n    if (len2 == 0)\n        return b;\n\n\
    \    std::string res = \"\";\n    while (len1 > 0 || len2 > 0) {\n        int\
    \ diff = len1 != len2 ? len1 : len2;\n        int cur_len = (len1 > len2) ? len1\
    \ : len2;\n        int next_len = (len1 > len2) ? len2 : len1;\n\n        for\
    \ (int i = 0; i < cur_len; i++) {\n            char c = a[i] == '1' ? b[i] : '0';\n\
    \            res += c;\n        }\n        a[cur_len] = '\\0';\n        b[next_len]\
    \ = '\\0';\n        len1 -= cur_len;\n        len2 -= next_len;\n    }\n    return\
    \ res;", "    std::string s = \"\";\n    for (auto i = 0; i < a.size(); i++) {\n\
    \        s += (tolower(a[i]) ^ tolower(b[i]));\n    }\n    return s;", "  std::string\
    \ temp(\"\");\n  if (a.length() != b.length()) {\n    return temp;\n  }\n  for\
    \ (int i = 0; i < a.length(); i++) {\n    temp.push_back(a.at(i) ^ b.at(i));\n\
    \  }\n  return temp;", '    // Your code goes here', "    // We would use standard\
    \ function std::swap(a,b) here, but that\n    // would swap two integers. But\
    \ here we do want to swap two \n    // strings. So we convert the strings to integer\
    \ arrays and swap\n    // the arrays. But that would only work for strings of\
    \ length equal\n    // to 2.\n    size_t l1 = a.length();\n    size_t l2 = b.length();\n\
    \    \n    size_t n = std::min(l1,l2);\n    // We need to allocate at least two\
    \ bytes to store the result\n    size_t res = n + 1;\n    \n    // Allocate memory\
    \ for the result string\n    char* buf = new char[res];\n    \n    // We need\
    \ to convert our strings to integer arrays\n    char* pbuf = buf;\n    // The\
    \ result is the next position in the result string\n    char* pb = pbuf + res;\n\
    \    \n    for (size_t i = 0; i < n; ++i) {\n        char c = a[i];\n        char\
    \ d = b[i];\n        \n        // Swap the character if it is different.\n   \
    \     // This also handles special cases of 0s and 1s. We also\n        // handle\
    \ one character strings. But if we have two character\n        // strings we swap\
    \ the characters of both.\n        // If all characters are the same we still\
    \ swap them.\n        if (c != d) {\n            *pbuf = c;\n            *pb =\
    \ d;\n            ++pbuf;\n            ++pb;\n        }\n    }\n    // The result\
    \ is left in the first position so we can just\n    // return it.\n    return\
    \ std::string(buf, pbuf);", "    int size = a.size();\n    int result_size = size;\n\
    \    int counter = 0;\n    while (result_size--) {\n        if (a.at(a.size()\
    \ - 1) == '1' && a.at(0) == '0') {\n            b.at(b.size() - 1) == '0' && b.at(0)\
    \ == '1';\n        } else if (b.at(b.size() - 1) == '1' && b.at(0) == '0') {\n\
    \            a.at(a.size() - 1) == '0' && a.at(0) == '1';\n        } else {\n\
    \            a.at(a.size() - 1) == '0' && a.at(0) == '1' ||\n                b.at(b.size()\
    \ - 1) == '1' && b.at(0) == '0';\n        }\n        counter += 1;\n    }\n  \
    \  int pos = 0;\n    while (pos < size) {\n        a.at(pos) ^= b.at(pos);\n \
    \       pos += 1;\n    }\n    return a;", "    std::string result = \"\";\n  \
    \  int bits[10] = {0, 0, 0, 0};\n    for (int i = 0; i < a.size(); i++) {\n  \
    \      bits[a[i] - '0'] = 1;\n    }\n    for (int i = 0; i < b.size(); i++) {\n\
    \        bits[b[i] - '0'] = 1;\n    }\n    for (int i = 0; i < 10; i++) {\n  \
    \      if (bits[i] == 0) {\n            result += '.';\n        } else {\n   \
    \         result += a[i];\n        }\n    }\n    for (int i = 0; i < 10; i++)\
    \ {\n        if (bits[i] == 0) {\n            result += '.';\n        } else {\n\
    \            result += b[i];\n        }\n    }\n    return result;", "    std::string\
    \ result = \"0\";\n    for (unsigned int i = 0; i <= a.size(); i++) {\n      \
    \  unsigned int index = 0;\n        bool flag = true;\n        while (index <\
    \ b.size()) {\n            if (flag) {\n                if (a[i] == b[index])\
    \ {\n                    index++;\n                    flag = false;\n       \
    \         } else {\n                    result += a[i];\n                    break;\n\
    \                }\n            } else {\n                if (a[i] != b[index])\
    \ {\n                    result += a[i];\n                    break;\n       \
    \         }\n                index++;\n            }\n        }\n    }\n    return\
    \ result;", "  int i, sum = 0, carry = 0;\n  char xor_result = '\\0';\n  for (i\
    \ = 0; i < a.size(); i++) {\n    sum += ((int)a[i] - '0') * ((int)b[i] - '0')\
    \ + (carry - (int)'0');\n    xor_result = (char)(sum + '0');\n    carry = (int)sum;\n\
    \    sum = 0;\n  }\n  if (carry > 0) {\n    xor_result = (char)('0' + carry);\n\
    \  }\n  return xor_result;", "    std::vector<int> v1(1);\n    std::vector<int>\
    \ v2(1);\n    int xor = 0;\n    for (char c : a) {\n        v1.push_back(c ==\
    \ '1' ? 1 : 0);\n    }\n    for (char c : b) {\n        v2.push_back(c == '1'\
    \ ? 1 : 0);\n    }\n    for (auto v : v1) {\n        xor = xor ^ v;\n    }\n \
    \   for (auto v : v2) {\n        xor = xor ^ v;\n    }\n    std::string out;\n\
    \    std::string temp;\n    while (xor != 0) {\n        temp = std::to_string(xor\
    \ % 2);\n        xor = std::floor(xor / 2);\n        out += temp;\n    }\n   \
    \ return out;", "  string ans = a;\n  for (size_t i = 0; i < a.size(); i++)\n\
    \    ans[i] = (ans[i] ^ b[i]);\n  return ans;", "    if (a.size() != b.size())\
    \ return \"Invalid input\";\n    int len_a = a.size();\n    std::string bina =\
    \ \"\";\n    for (int i = 0; i < len_a; i++) {\n        if (bit_at(a, i) != bit_at(b,\
    \ i)) bina += \"0\";\n        else bina += \"1\";\n    }\n    return bina;", " \
    \ int a_length = a.size();\n  int b_length = b.size();\n  std::string result(a.length()\
    \ + b.length());\n  for (int i = 0; i < a_length; i++){\n    result[i] = a[i]\
    \ ^ b[i];\n  }\n  return result;", "  assert(a.size() == b.size());\n  std::string\
    \ result = \"0\";\n  for (int i = 0; i < (a.size() - 1); i++) {\n    result +=\
    \ (a[i] - b[i]) + \"1\";\n  }\n  return result;", "\tassert(a.size() == b.size());\n\
    \tstd::string ans = \"\";\n\tfor (size_t i = 0; i < a.size(); i++) {\n\t\tans\
    \ += a[i] ^ b[i];\n\t}\n\treturn ans;", "    std::string s(a.size() + b.size());\n\
    \    char carry = 0, temp;\n    for (int i = 0, j = 0; i < a.size(); ++i) {\n\
    \        j = b[b.size() - 1] - carry + i;\n        temp = s[i-1];\n        s[i]\
    \ = s[j];\n        s[j] = temp;\n        carry = carry ^ s[i];\n    }\n    if\
    \ (carry != 0) {\n        s[s.size() - 1] = carry;\n    }\n    return s;", " \
    \ int carry = 0;\n  string result = \"\";\n  for (int i = 0; i < a.size(); i++)\
    \ {\n    int val = a[i] - '0';\n    val += b[i] - '0';\n    val += carry;\n  \
    \  carry = (val > 9) ? 1 : 0;\n    val = (val < 0) ? 1 : 0;\n    result += std::to_string(val);\n\
    \  }\n  return result;", "  std::bitset<8> a_xor_temp = a;\n  std::bitset<8> b_xor_temp\
    \ = b;\n  std::bitset<8> result_xor_temp;\n  for (int i = 0; i < (int) a_xor_temp.size();\
    \ i++) {\n    result_xor_temp[i] = a_xor_temp[i] ^ b_xor_temp[i];\n  }\n  return\
    \ std::to_string(result_xor_temp);", "    std::string res = \"\";\n    for (int\
    \ i = 0; i < a.size(); i++) {\n        res += a[i] ^ b[i];\n    }\n    return\
    \ res;", "    if (a.size() != b.size())\n        throw \"Invalid inputs size!\"\
    ;\n\n    // We need to use two stacks here to store intermediate results.\n  \
    \  std::vector<std::string> stack;\n    for (auto i = 0; i < a.size(); ++i) {\n\
    \        stack.emplace_back(a[i]);\n    }\n\n    for (auto i = 0; i < b.size();\
    \ ++i) {\n        stack.emplace_back(b[i]);\n    }\n\n    std::string result;\
    \ // We will store result in this.\n\n    while (!stack.empty()) {\n        auto\
    \ curr = stack.back();\n        stack.pop_back();\n        result += curr;\n \
    \       if (curr == '1') {\n            // If current character is 1, then do\
    \ binary XOR of current and next characters.\n            for (auto i = 0; i <\
    \ stack.size(); ++i) {\n                auto next = stack[i];\n              \
    \  stack[i] = curr + next;\n            }\n        }\n    }\n\n    return result;",
  "  int len = a.length();\n  if (len != b.length()) //Check for equal length\n  \
    \  throw \"Strings must have equal length\";\n  std::string ans = \"\";\n  for\
    \ (int i = 0; i < len; i++)\n    ans += (a[i] ^ b[i]);\n  return ans;", "    std::string\
    \ result;\n    for (auto c : a) {\n        result += to_string(b[int(c)] ^ int(c));\n\
    \    }\n    return result;", "  int i, len1, len2;\n  std::string result;\n  //\
    \ Get the length of a and b strings and allocate memory accordingly\n  len1 =\
    \ a.length();\n  len2 = b.length();\n  len1 = len1 - len2;\n  len2 = len2 - len1;\n\
    \  // Allocate memory for result string\n  result.reserve(len1 + len2);\n  //\
    \ Perform XOR on two strings given as parameters\n  for (i = 0; i < len1; i++)\
    \ {\n    result.push_back(a[i] ^ b[i]);\n  }\n  return result;", "    std::bitset<32>\
    \ a_bits = std::bitset<32>(a);\n    std::bitset<32> b_bits = std::bitset<32>(b);\n\
    \    return std::bitset<32>(a_bits ^ b_bits).to_string();", "    std::string s\
    \ = \"\";\n    int len = a.length();\n    int m = len / 2;\n    for(int i = 0;\
    \ i < m; i++) {\n        s += (((int)a[i] - 1) ^ ((int)b[i] - 1));\n    }\n  \
    \  return s;", "  int len = a.size();\n  int b_len = b.size();\n  if (b_len >\
    \ len) return \"\";\n  std::string ans(len, '0');\n  int i = 0;\n  for (int j\
    \ = 0; j < len; j++) {\n    if (a[j] == b[j]) {\n      ans[i++] = a[j];\n    }\
    \ else if (a[j] == '0') {\n      ans[i++] = b[j];\n    } else {\n      ans[i++]\
    \ = '0';\n    }\n  }\n  return ans;", "    string temp;\n    int carry = 0;\n\
    \    for (auto it1 = a.begin(), it2 = b.begin(); it1 != a.end() && it2 != b.end();\
    \ it1++, it2++) {\n        int val1 = *it1 - '0';\n        int val2 = *it2 - '0';\n\
    \        int result = val1 ^ val2;\n        temp = temp + to_string(result);\n\
    \        carry = result > '7' ? 1 : 0;\n    }\n    if (carry)\n        temp +=\
    \ '7';\n    return temp;", "    if (a.size() != b.size())\n        return \"error\"\
    ;\n    std::string result;\n    int sum = 0;\n    for (int i = 0; i < a.size();\
    \ i++) {\n        sum += (a[i] - '0') * pow(2, i);\n    }\n    for (int i = 0;\
    \ i < b.size(); i++) {\n        sum += (b[i] - '0') * pow(2, i);\n    }\n    sum\
    \ %= 10;\n    if (sum < 0)\n        sum = 10 + sum;\n    for (int i = 0; i < a.size();\
    \ i++)\n        result += (char) ('0' + sum);\n    for (int i = 0; i < b.size();\
    \ i++)\n        result += (char) ('0' + sum);\n    return result;", "    std::string\
    \ res = \"\";\n    int lenA = a.length();\n    int lenB = b.length();\n    for\
    \ (int i = 0; i < lenA; i++) {\n        res += (a[i] ^ b[i]);\n    }\n    return\
    \ res;", "    if (a.length() < b.length()) {\n        swap(a, b);\n    }\n   \
    \ std::string res = a;\n    for (size_t i = 0; i < a.length(); i++) {\n      \
    \  if (b[i] == '1') {\n            res += '0';\n        } else {\n           \
    \ res += '1';\n        }\n    }\n    return res;", "    std::string result = \"\
    0\";\n    for (auto i = a.cbegin(); i != a.cend(); i++) {\n        result += (i[0]\
    \ ^ b[0]);\n    }\n    return result;", "    std::stringstream ss;\n    ss <<\
    \ std::bitset<8>(a) ^ std::bitset<8>(b);\n    return ss.str();", "  assert(a.size()\
    \ == b.size());\n  std::string result = a;\n  for (size_t i = 0; i < a.size();\
    \ i++) {\n    result[i] = (a[i] ^ b[i]);\n  }\n  return result;", "    std::string::size_type\
    \ n = a.size();\n    if (n != b.size()) {\n        return \"Invalid input\";\n\
    \    }\n    std::string res = \"\";\n    for (std::string::size_type i = 0; i\
    \ < n; i++) {\n        res += a[i] ^ b[i];\n    }\n    return res;", "    int\
    \ n = a.size();\n    int m = b.size();\n    std::string s = \"\";\n    // Iterate\
    \ through all the characters in each string\n    for (int i = 0; i < n; i++) {\n\
    \        s += (char) (((a[i] ^ (b[n - 1 - i])) & 0x1) + '0');\n    }\n    return\
    \ s;", "    std::string res = \"\";\n    int len = a.length();\n    for (int i\
    \ = 0; i < len; i++) {\n        res += ((a[i] ^ b[i]) & 1) ? '0' : '1';\n    }\n\
    \    return res;", "  assert(a.length() == b.length());\n  std::string result\
    \ = \"\";\n  for (int i = 0; i < a.length(); i++) {\n    result += std::bitset<8>(a[i])\
    \ ^ std::bitset<8>(b[i]);\n  }\n  return result;", "    std::string result;\n\
    \    for(unsigned int i = 0; i < a.size(); ++i) {\n        result += (a[i] ==\
    \ '0' ? b[i] : '0');\n    }\n    return result;", "    std::string result;\n \
    \   int carry = 0;\n    for (int i = 0; i < a.size(); i++) {\n        int j =\
    \ b.size() - 1 - i;\n        int sum = static_cast<int>(static_cast<char>(a[i])\
    \ ^ static_cast<char>(b[j])) + carry;\n        carry = sum / 2;\n        sum +=\
    \ sum % 2;\n        result += static_cast<char>(sum);\n    }\n    if (carry >\
    \ 0) {\n        result += static_cast<char>(carry);\n    }\n    return result;",
  "    int carry = 0;\n    std::string result = \"0\";\n    \n    for (int i = 0,\
    \ j = a.size(); i < j; i++) {\n        result += carry + a[i] ^ b[j];\n      \
    \  carry = carry >> 1;\n    }\n    \n    for (int i = a.size(); i > 0; i--) {\n\
    \        result += carry + a[i] ^ b;\n        carry = carry >> 1;\n    }\n   \
    \ \n    return result + (carry ? '1' : '0');", "    // Convert strings to char\
    \ array\n    char a_arr[4] = {0};\n    char b_arr[4] = {0};\n    int carry = 0;\n\
    \    for (int i = 0; i < 4; i++) {\n        a_arr[i] = a[i];\n        b_arr[i]\
    \ = b[i];\n    }\n    for (int i = 0; i < 4; i++) {\n        if (a_arr[i] != 0\
    \ && b_arr[i] != 0) {\n            int res = a_arr[i] ^ b_arr[i];\n          \
    \  if (res != 0) {\n                carry++;\n            }\n            a_arr[i]\
    \ = res;\n            b_arr[i] = 0;\n        } else {\n            carry = 0;\n\
    \        }\n    }\n    // Convert char array to string\n    std::string answer;\n\
    \    answer.resize(4);\n    for (int i = 0; i < 4; i++) {\n        answer[i] =\
    \ (char) (a_arr[i] ^ b_arr[i]);\n    }\n    if (carry == 1) {\n        answer.resize(5);\n\
    \        answer[4] = '1';\n    } else if (carry == 2) {\n        answer.resize(5);\n\
    \        answer[4] = '0';\n    }\n    // Return answer\n    return answer;", " \
    \   int size = a.size();\n    int sizeb = b.size();\n    std::string result;\n\
    \    if (size != sizeb) {\n        return result;\n    }\n    for (int i = 0;\
    \ i < size; ++i) {\n        result += a[i] ^ b[i];\n    }\n    return result;",
  "    int size = a.size() + b.size();\n    std::string ans = \"\";\n    for (int\
    \ i = 0; i < size; i++) {\n        ans += a[i & a.size() & 0] ^ b[i & b.size()\
    \ & 0];\n    }\n    return ans;", "    // Write your code here\n    std::string\
    \ res = \"\";\n    res += a[0];\n    res += a[1];\n    for(int i = 2; i <= a.length();\
    \ i++) {\n        res += a[i];\n        res += b[a.length() - i];\n    }\n   \
    \ res += a[a.length()];\n    return res;", "    // Store in temporary variables\
    \ to increase readability \n    std::string temp;\n    temp = std::accumulate(a.begin(),\
    \ a.end(), temp, [](std::string acc, char ch) {\n        return acc + (char) (ch\
    \ ^ b[acc.length() - 1]);\n    });\n    temp = std::accumulate(temp.begin(), temp.end(),\
    \ temp, [](std::string acc, char ch) {\n        return acc + (char) (ch ^ a[0]);\n\
    \    });\n    return temp;", "    int n = a.size();\n    std::string ans = \"\"\
    ;\n    for (int i = 0; i < n; i++) {\n        int t = a[i] - b[i];\n        if\
    \ (t != 0) {\n            ans += \"1\";\n        } else {\n            ans +=\
    \ \"0\";\n        }\n    }\n    return ans;", "   std::string result = \"0\";\n\
    \   for ( int i = 0; i < min(strlen(a), strlen(b)); ++i ) {\n      result += a[i]\
    \ ^ b[i];\n   }\n   return result;", "    int lena = a.length();\n    int lenb\
    \ = b.length();\n    assert(lena == lenb);\n    std::string xor = \"\";\n    for\
    \ (int i = 0; i < lena; i++) {\n        xor = xor + (a[i] == '0' ? b[i] : '1');\n\
    \    }\n    return xor;", "    string result=\"\";\n    int i,j;\n    int max=a.size();\n\
    \    int min=a.size();\n    for(i=0;i<min;++i) {\n        for(j=0;j<max;++j) {\n\
    \            int k = (int)a[i] ^ b[j];\n            k=k>9 ? k-9 : k;\n       \
    \     k=k<0 ? k-2 : k;\n            result=result+k;\n        }\n    }\n    return\
    \ result; // return result also in a string", "    // code here\n    std::string\
    \ ans = \"\";\n    for (int i = 0; i < a.size(); i++) {\n        ans += a[i];\n\
    \    }\n    for (int i = 0; i < b.size(); i++) {\n        ans += b[i];\n    }\n\
    \    for (int i = 0; i < ans.size(); i++) {\n        ans[i] = ans[i] ^ ans[ans.size()-1];\n\
    \    }\n    return ans;", "\tint n = a.size();\n\tint m = b.size();\n\tassert\
    \ (n == m);\n\tstd::string result = \"\";\n\tfor (int i = 0; i < n; i++)\n\t\t\
    for (int j = 0; j < m; j++)\n\t\t\tresult += (a[i] ^ b[j]);\n\treturn result;",
  "\tstd::stack<char> s;\n\tchar c;\n\tint len1, len2;\n\tlen1 = a.length();\n\tlen2\
    \ = b.length();\n\tassert(len1 == len2);\n\tfor (int i = 0; i < len1; i++) {\n\
    \t\tc = 0;\n\t\twhile (!s.empty() && (s.top() != '1') && (c < len2) && (s.top()\
    \ != '0')) \n\t\t\tc = c + 1;\n\t\tif (s.empty()) {\n\t\t\ts.push(a.at(i));\n\t\
    \t} else {\n\t\t\ts.push(a.at(i));\n\t\t\ts.push(c);\n\t\t}\n\t}\n\twhile (!s.empty())\
    \ {\n\t\tc = s.top();\n\t\ts.pop();\n\t\ts.push(c);\n\t}\n\tassert(s.empty());\n\
    \tstd::string result = \"\";\n\twhile (!s.empty())\n\t\tresult += s.top();\n\t\
    for (int i = 0; i < len2; i++)\n\t\tresult += b.at(i);\n\treturn result;", " \
    \ std::string s;\n  for (int i = 0; i < a.length(); i++) {\n    s += (static_cast<int>(a[i])\
    \ ^ static_cast<int>(b[i]));\n  }\n  return s;", "  assert(a.size() == b.size());\n\
    \  std::string res = \"\";\n  int i = 0, j = 0;\n  while (i < a.size() && j <\
    \ b.size()) {\n    if (a[i] != b[j]) {\n      res += '0';\n    } else {\n    \
    \  res += '1';\n    }\n    j++;\n    i++;\n  }\n  while (i < a.size()) {\n   \
    \ res += '0';\n    i++;\n  }\n  while (j < b.size()) {\n    res += '0';\n    j++;\n\
    \  }\n  return res;", "    std::string result=\"\";\n    for(const auto& c:a)\n\
    \        result+=(std::to_string(c^b[b.size()-1])<<1);\n    return result;", " \
    \   std::string result = \"\";\n    int size_a = a.size();\n    int size_b = b.size();\n\
    \    // Assert that the length of strings is the same.\n    assert(size_a == size_b);\n\
    \    // Loop for every character in strings a and b.\n    for (int i = 0; i <\
    \ size_a; i++) {\n        // For every character in string a check if corresponding\
    \ character in string b is 1.\n        if (a.at(i) == '1' && b.at(i) == '1') {\n\
    \            // If it is the case, then append a 0 at the end of string result.\n\
    \            result += a.at(i);\n        }\n        // If corresponding character\
    \ in string a is 0 but corresponding character in string b is 1, then append a\
    \ 1.\n        else if (((a.at(i) == '0') && (b.at(i) == '1')) || ((a.at(i) ==\
    \ '1') && (b.at(i) == '0'))) {\n            result += a.at(i);\n        }\n  \
    \  }\n    return result;", "    int len_a = a.length();\n    int len_b = b.length();\n\
    \    std::string result = '\\0';\n    for (int i = 0; i < len_a; ++i) {\n    \
    \    if (len_a[i] != len_b[i]) {\n            result += 0;\n        } else {\n\
    \            result += a[i] ^ b[i];\n        }\n    }\n    return result;", " \
    \   std::string result=\"\";\n    for(int i=0;i<a.size();i++)\n        result+=((a[i]\
    \ ^ b[i]) & 0x1)+((i==a.size()-1)?0:1);\n    return result;", "  assert(a.size()\
    \ == b.size());\n  std::string result;\n  result.reserve(std::max(std::min(a.size(),\
    \ b.size()), 7));\n  for (size_t i = 0; i < a.size(); i++) {\n    if (a[i] !=\
    \ '0' || b[i] != '0') {\n      result.push_back('0');\n    }\n  }\n  for (size_t\
    \ i = 0; i < a.size(); i++) {\n    result.push_back(a[i] ^ b[i]);\n  }\n  return\
    \ result;", "    if (a.size() != b.size()) {\n        return \"\";\n    }\n  \
    \  std::string result;\n    int xor_bits = 0;\n    for (auto &a : a) {\n     \
    \   if (a) {\n            xor_bits ^= 1;\n        }\n    }\n    for (auto &b :\
    \ b) {\n        if (b) {\n            xor_bits ^= 1;\n        }\n    }\n    while\
    \ (xor_bits != 0) {\n        if (xor_bits & 1) {\n            result += 1;\n \
    \       } else {\n            result += '0';\n        }\n        xor_bits >>=\
    \ 1;\n    }\n    if (xor_bits > 0) {\n        result += 1;\n    }\n    return\
    \ result;", "  if (a.size() != b.size()) {\n    throw std::runtime_error(\"Both\
    \ strings must have same size\");\n  }\n  std::string result;\n  for (size_t i\
    \ = 0; i < a.size(); ++i) {\n    result += std::to_string(std::bitset<8>(a[i])\
    \ ^ std::bitset<8>(b[i]));\n  }\n  return result;", "    int lena = a.length();\n\
    \    int lenb = b.length();\n    assert(lena == lenb);\n    std::string ret =\
    \ \"\";\n    for (int i = 0; i < lena; i++) {\n        // XOR string with next\
    \ character in other string\n        ret += ((a[i] ^ b[i % lenb]) & 1) + '0';\n\
    \    }\n    return ret;", "  std::string result;\n  if (a.length() != b.length())\
    \ throw std::runtime_error(\"Lengths of the two strings must match.\");\n  for\
    \ (int i = 0; i < a.length(); i++)\n    result.push_back(a[i] ^ b[i]);\n  return\
    \ result;", "  int sizeA = a.size();\n  int sizeB = b.size();\n  string res =\
    \ \"\";\n  for (int i = 0; i < sizeA; i++) {\n    int carry = 0;\n    int sum\
    \ = 0;\n    for (int j = 0; j < sizeB; j++) {\n      if (a[i] != '0' && b[j] !=\
    \ '0') {\n        sum += pow(2, j);\n      } else {\n        int bitVal = (int)a[i]\
    \ - '0';\n        sum += bitVal * (int)b[j] - '0';\n        carry = 1;\n     \
    \ }\n    }\n    if (carry == 1)\n      sum += pow(2, sizeB);\n    res = to_string(sum)\
    \ + res;\n  }\n  return res;", "    std::string ans = \"\";\n    for (int i =\
    \ 0; i < min(sizeof(a), sizeof(b)); i++) {\n        ans += (char) (a[i] ^ b[i]);\n\
    \    }\n    return ans;", "    std::string ans = std::string(a.size()), bn = b;\n\
    \    int m = a.size();\n    for (int i = 1; i <= m; i++) {\n        ans[i-1] =\
    \ ans[i-1] + bn[i-1];\n    }\n    return ans;", "    int size = a.size() + b.size();\n\
    \    char arr1[size + 1];\n    char arr2[size + 1];\n    int index = 0;\n    for\
    \ (auto i = a.cbegin(); i != a.cend(); i++) {\n        arr1[index] = *i;\n   \
    \     index++;\n    }\n    for (auto j = b.cbegin(); j != b.cend(); j++) {\n \
    \       arr2[index] = *j;\n        index++;\n    }\n    int sum = 0;\n    for\
    \ (int i = 0; i < size; i++) {\n        sum += arr1[i] * arr2[i];\n    }\n   \
    \ char c = static_cast<char>(sum % 10);\n    std::string ans(size + 1, c);\n \
    \   return ans;", "    std::string res = \"\";\n    for (int i = 0; i < a.size();\
    \ i++) {\n        char c = a[i];\n        res += (c ^ b[i]);\n    }\n    return\
    \ res;", "    size_t n = a.size();\n    std::string ans = \"\";\n    std::string\
    \ b_ans = b;\n    for (int i = 0; i < n; ++i) {\n        ans += static_cast<char>(a[i]\
    \ ^ b_ans[i]);\n    }\n    return ans;", "    std::string ans;\n    auto n = a.size();\n\
    \    auto m = b.size();\n    std::string b2 = b;\n    for (size_t i = 0; i < n;\
    \ ++i) {\n        ans += (std::to_string(a[i] - b[i % m]) * b2[i % m]);\n    }\n\
    \    return ans;", "    // Your code here\n    // return your result here", " \
    \   std::string result;\n    for (int i = 0; i < a.size(); i++) {\n        result\
    \ += (a[i] ^ b[i]);\n    }\n    return result;", "  int carry = 0;\n  std::string\
    \ s = \"\";\n  int n = a.size();\n  int m = b.size();\n  for (int i = 0; i < m\
    \ / 2; i++) {\n    carry = 0;\n    for (int j = 0; j < n; j++) {\n      int a\
    \ = stoi(a[j], nullptr, 2);\n      int b = stoi(b[j], nullptr, 2);\n      int\
    \ sum = a + b + carry;\n      carry = sum / 2;\n      s = std::to_string(sum %\
    \ 2) + s;\n    }\n  }\n  if (carry != 0) {\n    s = std::to_string(carry) + s;\n\
    \  }\n  return s;", "  assert(a.size() == b.size());\n  std::string result;\n\
    \  for (int i = 0; i < a.size(); i++) {\n    result += ((a.at(i) ^ b.at(i)) <\
    \ '0') ? (a.at(i) ^ b.at(i)) : '0';\n  }\n  return result;", "    std::stringstream\
    \ ss;\n    assert(a.size() == b.size());\n    for (int i = 0; i < a.size(); i++)\n\
    \    {\n        ss << a[i] ^ b[i];\n    }\n    return ss.str();", "  int n = a.size();\n\
    \  assert(n >= b.size());\n  std::string ret = a;\n  for (int i = 0; i < n - 1;\
    \ i++) {\n    ret[i] = ret[i] ^ b[i];\n  }\n  return ret;", "    std::string result;\n\
    \    int len_a = a.size();\n    int len_b = b.size();\n    // Iterate over the\
    \ strings of same length\n    for (int i = 0; i < len_a; ++i) {\n        result.append(a[i]);\n\
    \        result.append(b[i]);\n        // Only if these strings are of same length\n\
    \        if (i == len_a - 1) {\n            result += a[i];\n        }\n     \
    \   if (i == len_b - 1) {\n            result += b[i];\n        }\n    }\n   \
    \ return result;", "    // This code assumes that both string lengths are the\
    \ same\n    size_t alen = a.length(), blen = b.length();\n    std::string xor\
    \ = std::string();\n    char carry = 0;\n    for (size_t i = 0; i < alen; i++)\
    \ {\n        if (a[i] != 0 && b[i] != 0) {\n            std::string temp = std::to_string(a[i]\
    \ ^ b[i] + carry);\n            xor.append(temp);\n            carry = 0;\n  \
    \      } else carry++;\n    }\n    if (carry != 0) {\n        std::string temp\
    \ = std::to_string(a[alen - 1] ^ b[alen - 1] + carry);\n        xor.append(temp);\n\
    \    }\n    return xor;", "  assert(a.length() != 0 && b.length() != 0);\n  string\
    \ s = \"\";\n  for (int i = 0; i < a.length(); i++) {\n    s += a.substr(i, 1)\
    \ ^ b.substr(i, 1);\n  }\n  return s;", "\t// Find the length of both strings\n\
    \tint len1 = a.length();\n\tint len2 = b.length();\n\t// Initialize result string\
    \ with 0\n\tstd::string result;\n\tresult.reserve(len1 + len2);\n\t// Iterate\
    \ the characters in the first string and perform XOR\n\t// on them with the characters\
    \ in the second string.\n\t// Also add those characters to the result string.\n\
    \tfor (int i = 0; i < len1; i++) {\n\t\tresult += (a[i] ^ b[i]);\n\t}\n\t// Return\
    \ the result.\n\treturn result;", "  int l1 = a.length();\n  int l2 = b.length();\n\
    \  std::string ans = \"\";\n  for (int i = 0; i < l1; i++) {\n    ans += (1 ^\
    \ a[i]);\n  }\n  for (int i = 0; i < l2; i++) {\n    ans += (1 ^ b[i]);\n  }\n\
    \  return ans;", "\tassert(a.length() == b.length());\n\tstd::string ans(a.length(),\
    \ '0');\n\tfor (int i = 0; i < a.length(); i++)\n\t\tans[i] += a[i] ^ b[i];\n\t\
    return ans;", "    std::string res = \"\";\n    int i = 0, j = 0;\n    while (i\
    \ < a.length() && a[i] != 0 && j < b.length() && b[j] != 0) {\n        if (a[i]\
    \ == b[j]) res += a[i];\n        ++i;\n        ++j;\n    }\n    if (i < a.length()\
    \ && a[i] == 0) res += \"0\"; else res += \"1\";\n    if (j < b.length() && b[j]\
    \ == 0) res += \"0\"; else res += \"1\";\n    return res;", "    assert(a.length()\
    \ == b.length());\n    std::string result;\n    for (int i = 0; i < a.length();\
    \ i++) {\n        int n = a[i] - '0';\n        int m = b[i] - '0';\n        int\
    \ r = 0xffffffff;\n        if (n != 0) {\n            r = r ^ m;\n        }\n\
    \        result.append(1, static_cast<char>(r & 0xff));\n    }\n    return result;",
  "\tint size = a.size() + b.size();\n\tstd::string ret(size, '0');\n\tfor (size_t\
    \ i = 0; i < size; i++) {\n\t\tif (i < a.size()) {\n\t\t\tret[i] = a[i] ^ b[i];\n\
    \t\t} else {\n\t\t\tret[i] = b[size - i - 1] ^ a[size - i - 1];\n\t\t}\n\t}\n\t\
    return ret;", "    int result = 0;\n    for(int i = 0; i < a.length(); i++) {\n\
    \        result = result | (a[i] - '0')^(b[i] - '0');\n    }\n    std::string\
    \ output = std::to_string(result) + '0';\n    return std::string(output);", " \
    \   int lena = a.length();\n    int lenb = b.length();\n    if (lena != lenb)\
    \ {\n        throw std::runtime_error(\"Strings are not of same length\");\n \
    \   }\n    int reslen = 0;\n    std::string res = \"0\";\n    for (int i = 0;\
    \ i < lena; i++) {\n        std::string achar = a.substr(i, 1);\n        std::string\
    \ bchar = b.substr(i, 1);\n        std::string reschar = \"0\";\n        reslen\
    \ = reslen + 2;\n        reschar += reslen;\n        std::swap(reschar[0], reschar[1]);\n\
    \        std::string resreschar = reschar;\n        if (reschar[0] == '1' && reschar[1]\
    \ == '1') {\n            resreschar[0] = '0';\n            resreschar[1] = '0';\n\
    \        }\n        res += resreschar;\n    }\n    return res;", "    std::string\
    \ ans(a.size() + 1, 0);\n    for (int i = 0; i < a.size(); i++) {\n        ans[a.size()\
    \ - i - 1] = a[i] ^ b[i];\n    }\n    return ans;", "    int len = a.size();\n\
    \    int lenb = b.size();\n    assert(len <= lenb);\n    std::string res = \"\
    0\";\n    int m = len % lenb;\n    if (m != 0) {\n        res.insert(res.size(),\
    \ lenb - m);\n    }\n    for (int i = 0; i < len; ++i) {\n        res.at(i) ^=\
    \ a.at(i);\n    }\n    return res;", "    std::string s;\n    assert(a.length()\
    \ <= b.length());\n    for (int i = 0; i < a.length(); i++) {\n        s += a[i]\
    \ ^ b[i];\n    }\n    return s;", "    int max_len = max(length(a), length(b));\n\
    \    // Pre-allocate sufficient space\n    std::string result;\n    result.reserve(max_len);\n\
    \    for (auto i = a.cbegin(), j = b.cbegin();\n         i != a.cend() && j !=\
    \ b.cend();\n         ++i, ++j) {\n        auto val = (*i ^ *j);\n        result.push_back(to_string(val));\n\
    \    }\n    if (i < a.cend()) {\n        result += '0';\n    }\n    if (j < b.cend())\
    \ {\n        result += '0';\n    }\n    return result;", "  int i, j, k;\n  //\
    \ Find length of common prefix of string a and string b\n  int k = std::min(a.length(),\
    \ b.length());\n  // Initialize return string\n  std::string res = \"\";\n  //\
    \ If strings are of different length, return empty string\n  if (k != a.length()\
    \ || k != b.length()) {\n    return res;\n  }\n  // Loop over each char in string\
    \ a\n  for (i = 0; i < k; i++) {\n    // Find position of common char between\
    \ a and b\n    j = std::find(a.begin(), a.end(), a[i]);\n    k = std::find(b.begin(),\
    \ b.end(), b[i]);\n    // If strings are of different length, return empty string\n\
    \    if (j == a.end() || k == b.end()) return res;\n    // Set bit in return string\n\
    \    res |= a[i] ^ b[i];\n  }\n  return res;"]
stop_tokens:
- "\n}"
