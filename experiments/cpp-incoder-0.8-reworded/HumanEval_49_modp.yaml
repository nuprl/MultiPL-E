name: HumanEval_49_modp
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return 2^n modulo p (be aware\
  \ of numerics).\n// >>> modp((3), (5))\n// (3)\n// >>> modp((1101), (101))\n// (2)\n\
  // >>> modp((0), (101))\n// (1)\n// >>> modp((3), (11))\n// (8)\n// >>> modp((100),\
  \ (101))\n// (1)\nlong modp(long n, long p) {\n"
tests: "}\nint main() {\n    auto candidate = modp;\n    assert(candidate((3), (5))\
  \ == (3));\n    assert(candidate((1101), (101)) == (2));\n    assert(candidate((0),\
  \ (101)) == (1));\n    assert(candidate((3), (11)) == (8));\n    assert(candidate((100),\
  \ (101)) == (1));\n    assert(candidate((30), (5)) == (4));\n    assert(candidate((31),\
  \ (5)) == (3));\n}\n"
completions: ["    if (n == 0) return 0;\n    if (p == 0) return 1;\n    long r =\
    \ 1;\n    while (n != 0) {\n        if ((n & 1) == 1) r = (r * p) % p;\n     \
    \   n >>= 1;\n        p = (p * p) % p;\n    }\n    return r;", "    long result\
    \ = 0;\n    long factor = 1;\n    long remainder = n;\n    long mod = p;\n   \
    \ while (remainder >= mod) {\n        remainder -= mod;\n        factor *= mod;\n\
    \    }\n    while (remainder > 0) {\n        remainder *= factor;\n        factor\
    \ *= factor;\n    }\n    result = factor;\n    return result;", "  if (p % 2 ==\
    \ 0) return ((n % p) + (p / 2)) % p;\n  return ((n % p) + (p / 2)) % p;", "\t\
    // Simplified version of Hacker's Delight\n\tassert(p != 0);\n\tlong x = 1;\n\t\
    while (n > p) {\n\t\tn /= p;\n\t\tx *= p;\n\t}\n\twhile (n != 0) {\n\t\tn /= p;\n\
    \t}\n\treturn x;", "  assert(p%2 == 1);\n  assert(n%2 == 1);\n  return n*p - n*(p\
    \ - 1) / 2;", "    if (n < p) {\n        n %= p;\n    } else if (n > p) {\n  \
    \      n -= p;\n    }\n    return n;", "  long q = p / n;\n  if (q > 0) return\
    \ q;\n  return n - (q * n);", "  // Precondition: n > 0 and p > 0.\n  assert(n\
    \ >= 0 && p > 0);\n  // Use bitwise and and logical operations to compute a bitwise\
    \ value.\n  long value = ((p + 1) >> 1) | (n & ((p + 1) << 1));\n  assert(value\
    \ >= n);\n  assert(value > 0);\n  return value;", "  long result = 1LL;\n  while\
    \ (p > result) {\n    result *= p;\n    result %= n;\n  }\n  return result;",
  "    long res = 1;\n    for(long i = p; i > 1; i--) {\n        if((res % p) == 0)\
    \ {\n            res *= i;\n        }\n    }\n    return res;", "  long res =\
    \ 1L;\n  while (p > 0)\n    res = (res * p) % n;\n  return res;", "    long p1\
    \ = p-1;\n    long q = (p*p-1)/p1;\n    return q == 0 ? p+1 : ((q*q-1)*p)/q;",
  "\tlong res = 1;\n\tfor (int i = 1; i <= n / p; i++) {\n\t\tres = (res*p + n % p)\
    \ % p;\n\t}\n\treturn res;", "  assert(p >= 0 && p < INT_MAX);\n  long ret = (n\
    \ % p) + p;\n  ret %= INT_MAX;\n  return ret;", "    long ret = 1;\n    while\
    \ (ret < p) {\n        ret *= 2;\n    }\n    while (n >= p) {\n        ret %=\
    \ p;\n        n  /= p;\n    }\n    return ret;", "  assert(p != 0);\n  assert(n\
    \ != 0);\n  if (n >= p) {\n    long q = n / p;\n    long r = n % p;\n    if (r\
    \ == 0) {\n      return q;\n    }\n    return q + modp(r, p - r);\n  }\n  return\
    \ 0;", "\tn = ((n&1)==1) ? n*p : n%p;\n\tlong q = (n&2) ? (n%(p>>1)) : (n >> 1);\n\
    \treturn (n&4) ? q : modp(q, p);", "  if (n & -p == 0) return 0;\n  return (n>>p)|p;",
  "    long res = 1;\n    while((p & 1) == 0)\n        p >>= 1, res = res * n + (p\
    \ & 1);\n    while((p >>= 1) == 0)\n        p >>= 1, res = res * n + (p & 1);\n\
    \    return res * n % p;", "  long ans = 0;\n  for (int i = 1; i <= n; i++) {\n\
    \    ans += p % i;\n    p /= i;\n  }\n  return ans;", "    long ans = 1;\n   \
    \ long tmp = 1;\n    long mod = p * p - 1;\n    while(p > 0) {\n        if (n\
    \ % p != 0) {\n            tmp += mod / p;\n            mod = mod%p;\n       \
    \ }\n        ans = tmp * ans + mod;\n        n = n / p;\n        p *= p;\n   \
    \ }\n    return ans * mod;", "\tlong mod = 1;\n\twhile (n != 0) {\n\t\tif (n %\
    \ p > 0)\n\t\t\tmod *= p;\n\t\tn /= p;\n\t\tp *= p;\n\t}\n\treturn mod;", '  return
    n * (p - 1) + (n % p);', '    return ((n*p)+((n%p)?1:0)) % p;', "    long ans\
    \ = 0;\n    while (n > 0) {\n        long rem = n % p;\n        ans = (rem > 0\
    \ ? ans : modp(rem, p));\n        n /= p;\n    }\n    return ans;", "    long\
    \ result = (n + p - 1) % p;\n    return (result < 0) ? result + p : result;",
  "    while (p) {\n        long a = p % n;\n        p /= n;\n        n = a;\n   \
    \ }\n    return n;", "    long a = n - (p - 1) % p;\n    long b = n % p;\n   \
    \ if (b == 0) return a;\n    return a + p;", "\tassert(n >= 0);\n\tassert(p >=\
    \ 0);\n\tif (n == 0) return 1;\n\tlong q = 1;\n\tfor (long i = 1; i <= n; ++i)\
    \ {\n\t\tq = q * p;\n\t\tif (q % p == 0) q = (q / p) + 1;\n\t}\n\tlong r = q %\
    \ p;\n\treturn (r == 0) ? p : r;", "  long r = n % p;\n  if (r == 0)\n    return\
    \ p;\n  else\n    return (r + p) % p;", "\tif (n == 0 || p == 0) return 1;\n\t\
    long r = p * pow(10, n);\n\treturn (r / p) % p;", "    long res = 1L;\n    while\
    \ (p > 0) {\n        if (p & 1L)\n            res = (res * n) % p;\n        n\
    \ >>= 1L;\n        p >>= 1L;\n    }\n    return res;", "  if (n >= p)\n    return\
    \ n - p;\n  return n + p;", "    long ans = 1L;\n    while (n) {\n        ans\
    \ = ans * p;\n        ans = ans % p;\n        n /= 2;\n    }\n    return ans;",
  "  assert(p > 0);\n  return ((n + p) % p) / p;", "  long res = 1;\n  while (n) {\n\
    \    if ((n & p) == 0)\n      res += 1;\n    n /= p;\n  }\n  return res;", " \
    \   if (n == 0)\n        return 1;\n    if (p % 2 == 0)\n        return n - pow(2,\
    \ (n + 1) >> 1) - 1;\n    return modp(n >> 1, p) % p;", "  assert(p);\n  assert(n);\n\
    \  if (n == 0) {\n    return 1;\n  } else if (n < p) {\n    return modp(p - n\
    \ + 1, p) % p;\n  }\n  long r = p + 1;\n  for (long i = 1; i < p; i++) {\n   \
    \ r = ((r % p) + p) % p;\n  }\n  return n % r;", "    long res = 1;\n    while\
    \ (n) {\n        res = (n % p + res + p) % p;\n        n /= p;\n    }\n    return\
    \ res;", "    assert(n > 0);\n    assert(p > 0);\n    long t = p % n;\n    if\
    \ (t == 0) {\n        return n;\n    } else {\n        long r = modp(t, p);\n\
    \        return r + n;\n    }", "    long q = 1; // pow(n, q) will give the best\
    \ answer. Enough for now.\n    long t = 1;\n    long r = 1;\n    long m = 0;\n\
    \    while (t <= n) {\n        if (t % 2 == 0) {\n            q += p;\n      \
    \      t = q * t;\n        }\n        r = r * t;\n        t += 1;\n    }\n   \
    \ return (r * r + m) % p;", "  if (p == 0)\n    return 0;\n  if (p == 1)\n   \
    \ return 1;\n  if (p == 2)\n    return n;\n  long res = n % p;\n  if (res == 0)\n\
    \    return n;\n  else\n    return p + modp(n - res, p);", "  assert (n > 0);\n\
    \  assert (p > 0);\n  // if n is power of p, return n; else return (n % p)\n \
    \ if (n & (n - 1)) {\n    n -= p;\n  } else {\n    n %= p;\n  }\n  return n;",
  "\t// Avoid division by 0.\n\tif(p == 0) return n;\n\treturn n % p;", "  assert(p\
    \ > 0);\n  assert(n > 0);\n  long x = 0;\n  long r = 1;\n  while (n > 0) {\n \
    \   long t = x % p;\n    x = r;\n    r = r * n / t;\n    n = t % p;\n  }\n  return\
    \ r;", '    return ((n % p) + p) % p;', "\treturn (n > p) ? (n % p + p % n) :\
    \ (n % (p - 1) + n % p);", "  assert(n >= 0 && p >= 0 && p <= 101);\n  long r\
    \ = 0, d = 1;\n  for (long i = 1; i < p; ++i)\n    d = d * 2;\n  for (long i =\
    \ 1; i <= n; i += 1) {\n    long tmp = i % d;\n    r = r * tmp + tmp;\n    d =\
    \ d / 2;\n  }\n  return r;", "  if (p == 0) {\n    return n;\n  }\n  long rem\
    \ = n % p;\n  if (rem < p) {\n    rem += p;\n  }\n  return rem == p ? 0 : (rem\
    \ % p) + p;", '    return ((n%p) + p) % p;', "    long r = 1;\n    for (long i\
    \ = 1; i <= p; i++) r *= (n + i);\n    return r;", "  long res = 1;\n  while (1)\
    \ {\n    if ((p & n) != p) res = (res << 1);\n    if ((p & n) != 0) return res;\n\
    \    n = n << 1;\n    p >>= 1;\n  }", "    long d = 1;\n    long m = 1;\n    while\
    \ (n%p) {\n        n = (n*d) % p;\n        m = (m*d) % p;\n        d++;\n    }\n\
    \    return m*d%p;", "\tassert(p >= 1);\n\tlong res = n;\n\tlong mod = (p - 1)\
    \ / p;\n\tif (n % p) {\n\t\tres += mod;\n\t\tmod = 1;\n\t}\n\twhile (p & 1) {\n\
    \t\tmod *= p;\n\t\tp >>= 1;\n\t}\n\tres %= mod;\n\treturn res;", "  assert(p >=\
    \ 1 && p <= 101);\n  long r = p * (long) n;\n  r += (p - 1L) * (long) (r + n);\n\
    \  return r;", '    return ((n % p) + p) % p;', "    if(n == 0) return 1;\n  \
    \  if(n == p) return n;\n    if(n%2 == 0) return modp( (n-1), (p / 2) );\n   \
    \ if(n%2 == 1) return modp( n/2, p );\n    long d = modp( (n-1)/2, p );\n    long\
    \ r = n%p;\n    if(r == 0) return d;\n    else return d + modp( r / (p / 2), p\
    \ );", '  return (n%p)+p;', "  long r = 1;\n  while (n != 0) {\n    if (n % p\
    \ == 0)\n      r *= p;\n    n /= p;\n  }\n  return r;", "\t// Return 2^n modulo\
    \ p.\n\tlong ret = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (n % i == 0) {\n\
    \t\t\tret *= p;\n\t\t\tret %= p;\n\t\t}\n\t\tret *= 2;\n\t\tret %= p;\n\t}\n\t\
    return ret;", "    long ans = 1;\n    while (n) {\n        if (n % p)\n      \
    \      ans = (ans * p + n % p) % p;\n        n = (n - ans) % p;\n    }\n    return\
    \ ans;", "    assert(n >= 0);\n    long q = n;\n    while (p != 0) {\n       \
    \ if (p & 1) {\n            q = (q * q) % p;\n        }\n        p >>= 1;\n  \
    \  }\n    return q;", "  assert(n > 0);\n  long ans = 1;\n  while (n > p) {\n\
    \    ans = (ans * n) % p;\n    n = (n * ans + 1) % p;\n  }\n  return ans;", " \
    \   assert(p >= 1 && p <= 4294967295);\n    return ((long) pow(2, n)) % p;", " \
    \ long x = n >> 1;\n  long r = p & 1;\n  n = x - 1;\n  while (n > 0) {\n    long\
    \ y = x % p;\n    if (y > 0)\n      y = p + y;\n    x = y;\n    n--;\n  }\n  if\
    \ (r)\n    x = x + p;\n  return x;", "\tassert (n>0); // assert (p>0); // assert\
    \ (p%2==0); // assert (n%p==0); // (n%p)==0; // assert (n==p or n==-p); // assert\
    \ (p>0); // assert (p<p*n); // (n<n)\n\tassert (p==0 || p==-1); // assert (p==0);\
    \ // assert (p==0); // assert (n==-1 or n==1); // assert (n==0 || n==1); // assert\
    \ (n==p*n); // (n==p or n==-p); // assert (p==p or p==-p); // assert (p==-1 or\
    \ p==1); // assert (p==1 or p==-1); // assert (p==0 or p==1); // assert (p==0\
    \ or p==1); // assert (n==0 or n==1); // assert (n==-1 or n==1); // assert (n==0\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 or n==1); // assert (n==-1\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 or n==1); // assert (n==-1\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 or n==1); // assert (n==-1\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 or n==1); // assert (n==-1\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 or n==1); // assert (n==-1\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 or n==1); // assert (n==-1\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 or n==1); // assert (n==-1\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 or n==1); // assert (n==-1\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 or n==1); // assert (n==-1\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 or n==1); // assert (n==-1\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 or n==1); // assert (n==-1\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 or n==1); // assert (n==-1\
    \ or n==1); // assert (n==-1 or n==1); // assert (n==-1 ", "    long res = 1;\n\
    \    while (n) {\n        res = (n % p) + res;\n        n = n / p;\n    }\n  \
    \  return res;", "  if(n<0)\n    n+=p;\n  long ans = 1;\n  while(ans<p) ans+=p;\n\
    \  while(ans<=n) ans+=p;\n  return ans%p;", "  long ans = 1;\n  while (n > p)\
    \ {\n    ans = (ans * p) + n;\n    n /= p;\n  }\n  return ans;", "    long mod\
    \ = 0;\n    while ((n & 1) == 0) {\n        mod <<= 1;\n        mod |= 1;\n  \
    \      n >>= 1;\n    }\n    while ((p & 1) == 0) {\n        mod <<= 1;\n     \
    \   mod |= 1;\n        p >>= 1;\n    }\n    while (n != 0) {\n        if (n &\
    \ p)\n            mod <<= 1;\n        n >>= 1;\n        p >>= 1;\n    }\n    return\
    \ mod;", "  assert(n >= p);\n  if (n == 0) return 1;\n  if (n & -p == 0) return\
    \ n;\n  long q = (n / p + 1) * p;\n  long r = n % p;\n  return (q - r + p) % p;",
  "  assert(n > 0);\n  assert(p > 0);\n  if (p == 0) return 1;\n  long r = 1;\n  while\
    \ (n) {\n    if (n & 1) r *= p;\n    n >>= 1;\n    p *= p;\n  }\n  return r;",
  "\tif(n<0) {\n\t\tn+=p;\n\t\tif(n < 0) n = 0;\n\t} else {\n\t\tn%=p;\n\t\tif(n >=\
    \ p) n-= p;\n\t}\n\treturn n;", "    if (p == 0)\n        return 0;\n    if (n\
    \ == 1)\n        return p;\n    if (n >= p)\n        return modp(n - 1, p) % p;\n\
    \    return modp(n - 1, p) % p + p;", "    long result = (n % p);\n    return\
    \ result < 0 ? result + p : result;", "    long q = (n >> 32) + ((n & -(int)n)\
    \ * p);\n    return (q >> 32) + (q & -(int)q);", '    return ((n % p) + (p % p))
    % p;', "    long ans = 0;\n    while (p) {\n        if (n & 1)\n            ans\
    \ = ans * 2 + 1;\n        n /= 2;\n        p /= 2;\n    }\n    return ans;", " \
    \   if (n >= p)\n        return 1;\n    long res = 1;\n    while (n /= p)\n  \
    \      res = (res * p + n) % p;\n    return res;", "\tassert(p);\n\tlong ans =\
    \ 1;\n\twhile (n > 0) {\n\t\tif (n & 1)\n\t\t\tans = (ans * p) % p;\n\t\tn >>=\
    \ 1;\n\t\tp = (p * p) % p;\n\t}\n\treturn (ans + 1L) % p;", '    return p == 0
    ? n : n % p;', "    long res = n;\n    \n    while (p & 1) {\n        if (res\
    \ <= 1) return 0;\n        res = (res % p) + p;\n    }\n    \n    if (n >= p)\
    \ return res;\n    else return (n-res) % p;", "    if (n == 0)\n        return\
    \ 0;\n    long q = (p - 1) % p;\n    return (n << q) % p;", "    long d = p -\
    \ 1;\n    return ((n % p) + d) % p;", "    long r = n % p;\n    if (r != 0) {\n\
    \        long rem = n % p;\n        r += (rem / p) * p;\n    }\n    return r;",
  "  assert(p == p % n); // no repeated division\n  if (n < 0) {\n    return modp(-n,\
    \ p) % n;\n  } else {\n    if (n == 0) {\n      return 1;\n    }\n    int d =\
    \ (int)n;\n    if (d == 0 || d == 1) {\n      return n;\n    }\n    if (d % 2\
    \ == 0) {\n      d /= 2;\n    } else {\n      d *= 2;\n    }\n    n /= d;\n  \
    \  p /= d;\n    while (p > 1) {\n      p /= 2;\n    }\n    return n % p;\n  }",
  "    long res = 0;\n    while (n >= p) {\n        res ^= n;\n        res = (res*n)\
    \ % p;\n        n /= p;\n    }\n    return res;", "    if (p == 0)\n        return\
    \ 0;\n    long m = 1L << n;\n    for (; (m & p) != 0; m >>= 1)\n        if (m\
    \ & 1)\n            n -= 1;\n    return n;", "  assert(n >= p);\n  long ret =\
    \ 0;\n  while (n) {\n    ret += (n & 1);\n    n >>= 1;\n  }\n  if (ret)\n    ret\
    \ += p;\n  return ret;", "  long ans = (n - 1) * (p - 1) % p;\n  if (ans == 0)\n\
    \    ans = 1;\n  return ans;", "  if(n%p==0) return p;\n  if(n%p==p) return n%p;\n\
    \  long r = p-1;\n  while(r%n==0) r/=n;\n  if(r%n==0) return r;\n  else return\
    \ modp(n, p-1);", "  long res = 1;\n  while (n) {\n    if (n & 1) res *= p;\n\
    \    n >>= 1;\n    p *= p;\n  }\n  return res;", '  return ((n % p) + (p < 0))
    %p;', "    long p1 = 1; // p mod p1 is 1\n    long p2 = 0; // p mod p2 is 0\n\
    \    long q = 1; // q divides n\n\n    long r = (n / p) % p; // q divides n\n\
    \    if (q == 1) return 1; // n is prime\n    if (q > 1) return 0; // n has a\
    \ composite factor > 1\n    long p = p % q; // q is prime\n    long q = q / p;\
    \ // p is prime\n\n    long d = (p - 1); // p-1 is not equal to 1\n    while (q\
    \ % d == 0 && d != p)\n    {\n        if (d % 2 == 0)\n        {\n           \
    \ d += 1;\n            while (n % d == 0)\n                n /= d;\n        }\n\
    \        else\n        {\n            d += 2;\n            while (n % d == 0)\n\
    \                n /= d;\n        }\n        p = d;\n        q = p / p1;\n   \
    \ }\n    if (d == 1)\n    {\n        // p-1 is equal to 1\n        while (n %\
    \ p == 0)\n            n /= p;\n    }\n    else\n    {\n        while (n % d ==\
    \ 0)\n            n /= d;\n        while (n % p == 0)\n            n /= p;\n \
    \   }\n    return n;", "  if (n & (n - 1))\n    return n % p + p;\n  return n\
    \ % p;", "    long t = 0;\n    while ((p&1)==0) p >>= 1;\n    for (long i = 1;\
    \ i < p; ++i) {\n        if ((n&1)==0) n >>= 1;\n        t = ((t*p)+n) % p;\n\
    \    }\n    return t;", "  long m = n % (p + 2);\n  if (m < p) m += p;\n  return\
    \ m;", "\tif (n >= p)\n\t\treturn (n + p - 1) % (p - 1);\n\telse\n\t\treturn n;",
  "    long res = 1; // init\n    while (p > 0) {\n        if (n % p == 0)\n     \
    \       res = res * (p - 1); // res^(p-1)\n        n /= p;\n    }\n    return\
    \ res;", "    long q = p / 2;\n    long r = p % 2;\n    if (r == 0) return (n\
    \ & 1L);\n    else return (n & 1L) | modp((n - q * p), q);", "  assert(n >= 0);\n\
    \  long ans = 1;\n  while (n != 0) {\n    if (n % 2 == 1) {\n      ans = (ans\
    \ * p) % p;\n    }\n    n = n / 2;\n  }\n  return ans;", "    long res = 1;\n\
    \    while (p) {\n        if (n & 1LL) res *= p;\n        n /= p;\n        p *=\
    \ p;\n    }\n    return res;", "  long ans = n;\n  long r = 1;\n  while (ans >\
    \ p) {\n    r <<= 1;\n    ans >>= 1;\n  }\n  return r * p;", "    if (n >= p)\
    \ return n - p;\n    if (n < 0) return (p - 1) - modp(n - p, p);\n    return n;",
  '    return n % p;', "    long r = n;\n    while (p > 0) {\n        if (p % 2 ==\
    \ 1) {\n            r = (r * 10) % p;\n        }\n        p = (p * 10 + 5) / 2;\n\
    \    }\n    return r;", "  assert(p >= 1);\n  long q = 1;\n  while (q * p < n)\
    \ q *= p;\n  while (q > p) {\n    if (n % q == 0) {\n      long a = q * q;\n \
    \     long b = n - q * p * p;\n      long c = p * q * p;\n      long d = a * b\
    \ - c;\n      if (d >= 0) {\n        q ^= a * (b - c);\n        n ^= c;\n    \
    \  }\n    }\n    q--;\n  }\n  assert(q == 1);\n  return n;", "    long r = 1;\n\
    \    long m = 1;\n    long q;\n\n    while (p > 1) {\n        q = p / n;\n   \
    \     p = (p - q * n) >> 1;\n        m = m << 1;\n        r = r | m;\n    }\n\
    \    return r | m;", "  long res = 1;\n  for (long i = 1; i <= n; ++i) res *=\
    \ p;\n  return res;", "  assert(p >= 0);\n  long r = 1;\n  for (int i = p; i >\
    \ 0; i /= 2) r *= n;\n  return (r % p);", "    // assert(p % 2 == 0);\n    //\
    \ assert(p * p % 2 == n);\n    long q = 1;\n    long r = n;\n    while (r != 0)\
    \ {\n        long t = r / p;\n        q = q * (p % 2) + t;\n        r = r % p;\n\
    \    }\n    return q;", "  long x = n % p;\n  x = ((x % p) < p) ? x : p - (x %\
    \ p);\n  return x;", "    if (n >= p) return n;\n    long r = p%n;\n    return\
    \ r+(r != 0)?modp(r,p):n;", "  assert(p);\n  // Initialize to one. Be careful\
    \ with unsigned-integer promotion,\n  // it's important for modpow() to be called\
    \ correctly.\n  long res = 1;\n  // Iterate n. Stop when n % p == 0 (mod p) and\
    \ start a new iteration, which is guaranteed\n  // to terminate if n is odd. Subsequent\
    \ iterations will never terminate, since n & p > 0\n  // only as n gets closer\
    \ to p.\n  for (long i = 2; i <= n; ++i)\n    res = (res*i) % p;\n  return res;",
  "  assert(p<=INT_MAX);\n  long r = n;\n  long mask = 1;\n  while (r != 0) {\n  \
    \  r = r / p;\n    mask <<= 1;\n  }\n  mask >>= 1;\n  return mask % p;", "   \
    \ long r = 1;\n    for (; n >= p; n /= p) r *= p;\n    return r;", "    long ret\
    \ = n;\n    while (ret >= p) {\n        ret -= p;\n        ret += p + 1;\n   \
    \ }\n    return (ret % p + p) % p;", "  assert(p != 0);\n  // We don't care about\
    \ the parity of n or p.\n  // Just compute 2^n modulo p.\n  // Since p is a prime,\
    \ this is a fast, easy-to-verify calculation.\n  long res = 1;\n  while (n !=\
    \ 0) {\n    res = (res*2) % p;\n    n--;\n  }\n  return res;", "    long ans =\
    \ 1;\n    int i = 0;\n    while (p != 0) {\n        p /= 10;\n        ans = ans\
    \ * ans % p;\n        i++;\n    }\n    if (n == ans)\n        return 1;\n    return\
    \ 0;", "    // We could return (p-1)/n * p % p but that's not optimal.\n    //\n\
    \    // We could also use (p - 1) & ((p-1) > 0), but that's also not optimal.\n\
    \    //\n    // Instead we use a little trick: we keep shifting n while p < 0,\n\
    \    // and divide the result by p when p >= 0.\n    while ((p < 0) || (p > n))\
    \ {\n        long tmp = n;\n        n = p;\n        p = tmp;\n    }\n    return\
    \ p % n;", "\tif (n >= p)\n\t\treturn 1;\n\telse if (n < 0)\n\t\treturn modp(-ln,\
    \ p);\n\telse\n\t\treturn pow(10, p % n);", "    long res = 1LL;\n    while (p)\
    \ {\n        if ((n & 1LL) == p)\n            n /= 2LL;\n        else\n      \
    \      res *= 2LL;\n        n &= p-1;\n    }\n    return res;", "    long res\
    \ = 1;\n    for (int i = 0; i < 32; ++i) {\n        if ((n & 1) != 0) {\n    \
    \        res = (res * p) % p;\n        }\n        n >>= 1;\n        p >>= 1;\n\
    \    }\n    return res;", "    // We don't want to use recursion and keep it simple,\
    \ just do it on paper.\n    long res = 1;\n    long mod = p;\n    while (n >=\
    \ p) { res *= p; mod *= p; n -= p; }\n    while (mod > 1) { res %= mod; mod /=\
    \ 10; }\n    return res;", "  long result = 1L;\n  while (n) {\n    if (n & 1)\
    \ result = result * p;\n    n = n >> 1;\n    p = p * p;\n  }\n  return result;",
  '    return (n % p + p) % p;', "\tif (n == 0 || p == 0) {\n\t\treturn n;\n\t} else\
    \ if (n <= p) {\n\t\treturn n;\n\t} else {\n\t\tlong m = n % p;\n\t\treturn ((m\
    \ * m) % p) + p;\n\t}", "  assert(p > 0);\n  long r = p % n;\n  long t = p + p\
    \ - r;\n  r = n % t;\n  return t + (n - r);", "  // Write your code here.\n  long\
    \ res = 0;\n  for(int i = 0; i < (p / 2); i++) {\n    if(n % 2 == 1) {\n     \
    \ res += 1;\n      n /= 2;\n    } else {\n      res += 2;\n      n /= 2;\n   \
    \ }\n  }\n  assert(n == 0);\n  while(p % 2 == 0) {\n    res -= 1;\n    p /= 2;\n\
    \  }\n  while(p % 2 == 1) {\n    res += 2;\n    p /= 2;\n  }\n  return res;",
  "    long res = 1;\n    while (n > 0) {\n        if (res >= p) break;\n        res\
    \ *= 2;\n        n--;\n    }\n    return res;", "    long r = 1;\n    long t =\
    \ 1;\n    long q = 1;\n    long p1 = p * p;\n    while ((n /= 2) != 0) {\n   \
    \     t = p1 - ((r * n) % p);\n        r = n;\n        n = t;\n        q = p1\
    \ - ((r * t) % p);\n    }\n    return q;", "  assert(n > p);\n  long r = 1;\n\
    \  while (n > 0) {\n    if (n & 1) {\n      r = (r * p) % p;\n    }\n    n >>=\
    \ 1;\n    p = (p * p) % p;\n  }\n  return r;", "    long m = 1;\n    for (long\
    \ i = 1; i < p; i++) {\n        m = (m * n) % p;\n        n = (n * n) % p;\n \
    \   }\n    return m;", "\tassert(p);\n\tlong ret = 1;\n\twhile (n != 0) {\n\t\t\
    ret *= 2;\n\t\tret %= p;\n\t\tn /= 2;\n\t}\n\treturn ret;", "    long x = 0;\n\
    \    while(n) {\n        // get least (64-bit) part of n\n        long l = (n\
    \ & ((1LL << 63) - 1));\n        n -= l;\n        // left shift n by 63 bits,\
    \ while accumulating lsb of n\n        x += (l << 63);\n        // add l (from\
    \ least (64-bit) part of n) to x\n        x += l;\n    }\n    x %= p;\n    //\
    \ add 1 to x to make it positive\n    x += 1;\n    // shift x by 63 bits to get\
    \ lsb (64-bit) part of n\n    x >>= 63;\n    // and add it to n\n    return n\
    \ + x;", "\treturn ((n % p) + p) % p;", '  return pow(2,n) % p;', "  if(p == 0)\
    \ return 1;\n  if(p == 1) return n;\n  if(n == 0) return 0;\n  if(n == 1) return\
    \ p;\n  long r = n % p;\n  long q = modp(n / p, p);\n  if(r != 0) return (r *\
    \ q) + p;\n  return q;", "    int r = n % p;\n    return (r < 0) ? r + p : r;",
  '    return ((n % p) + p) % p;', "\tlong ans = 0;\n\twhile (n > 0) {\n\t\tans +=\
    \ n % p;\n\t\tn = n / p;\n\t}\n\treturn ans;", "  long r = n % p;\n  if (r ==\
    \ 0) {\n    r = p;\n  }\n  return r;", "  long r = 1;\n  while (p > 0 && n > 0)\
    \ {\n    if (n % p == 0 && n != p)\n      r *= p;\n    n /= p;\n    p /= 10;\n\
    \  }\n  return r;", "  assert(n % p == 0);\n  long q = (n / p + 1) * p;\n  if\
    \ (n / p < q) {\n    q += p;\n  }\n  long r = q - n;\n  assert(r >= 0 && r % p\
    \ == 0);\n  return r;", "    long ans = (n & -p) + p;\n    return (ans & -ans)\
    \ | ans;", "    long n2 = n * n;\n    long p2 = p * p;\n    n2 *= p2;\n    n2\
    \ %= p2;\n    return n2;", "    long modp = 1;\n    while (n%p) {\n        modp\
    \ = (modp*p) + 1;\n        n /= p;\n    }\n    return modp;", "    long mod =\
    \ 1;\n    int i = 1;\n    while (n) {\n        if (n&1) mod += p;\n        n =\
    \ n/2;\n        p /= 2;\n    }\n    return mod;", "  long r = 1;\n  while (n >\
    \ p) r = (r * n) % p;\n  return r;", "    long ans = (1ull << p) - 1;\n    long\
    \ s = ans;\n    while (n) {\n        if (n&1)\n            s = ans ^ (s >> 1);\n\
    \        n >>= 1;\n        ans ^= s;\n    }\n    return ans;", "    long ans =\
    \ 1;\n    while ((n%p) == 0) {\n        ans *= p;\n        n/=p;\n    }\n    return\
    \ (n%p) ? ans : ans % p;", "  assert(n > 0 && p == 0 || p > n);\n  return pow(2,\
    \ n);", "\treturn (1LL<<n)%(1LL<<p);", "  assert(p >= 1);\n  long ret = 0;\n \
    \ while (n > 0) {\n    ret += n % p;\n    n /= p;\n  }\n  return ret;", "  if\
    \ (p % 2 == 1) return (p - 1) * (n - 1) / (2 * n);\n  else return (p - 1) * (2\
    \ * n - 1) / (2 * n);", "    long q = (p / p) % p;\n    if (n == 0) return q;\n\
    \    if (n < p) return modp(n, p);\n    return q;", "    long res = 1;\n    while\
    \ (p) {\n        if (p & 1) res = (n % p) + res;\n        n = n / p;\n       \
    \ p = (p >> 1);\n    }\n    return res;", '    return ((n % p) + p) % p;', " \
    \ assert(p != 0);\n  assert(n != 0);\n  long r = n % p;\n  if (r == 0) {\n   \
    \ return n;\n  } else {\n    return r + p;\n  }", "    long a=0, b=1;\n    while(n)\
    \ {\n        int d = (n&-b) % p;\n        if(a) {\n            d += p;\n     \
    \   }\n        a = b;\n        b = d;\n        n >>= 1;\n    }\n    return a;",
  "\tif (n & -p == 0) return n;\n\tlong ret = p >> 1;\n\tlong n1 = n;\n\tfor (int\
    \ k = 1; k < p; k++, n1 <<= 1)\n\t\tif (n1 & p) ret ^= (n << k);\n\treturn ret;",
  "  assert(p != 0)\n  long ans = 1LL;\n  for (long x = n; x > 0; x = x / 2)\n   \
    \ ans *= p;\n  ans %= p;\n  assert(n % p == 0);\n  return ans;", "  int k = n\
    \ & -p;\n  n ^= k & -p;\n  k &= p;\n  n ^= k;\n  return n & -p;", "    long q\
    \ = n % p;\n    if (p > q) {\n        p = q;\n    }\n    return p * p + n;", " \
    \ assert(p > 0);\n  if (p == 1) return 1;\n  if (p > n) return p - n;\n  if (n\
    \ <= 0) return 0;\n  long mod = 0;\n  while (n) {\n    mod = (mod * n) % p;\n\
    \    n /= p;\n  }\n  return mod;", "    long long q = n / p;\n    long long r\
    \ = n % p;\n    long long result = (long long)(q * p + r) % p;\n    if (result\
    \ < 0) {\n        result += p;\n    }\n    return result;", "\tif (n <= p)\n\t\
    \treturn 1L;\n\tif (n == p)\n\t\treturn n;\n\tif (n % p == 0)\n\t\treturn n;\n\
    \treturn (n % p + p) % p;", "  // assert(p != 0);\n  // assert(p > 0);\n  if (n\
    \ == p)\n    return n;\n  long res = 1;\n  for (; n != 0; n = (n / p) * p)\n \
    \   if (n % p == 0)\n      res = (long) res * p;\n  return res;", "    if (n <=\
    \ 0) return 0;\n    long res = n % p;\n    if (res < 0)\n        res += p;\n \
    \   return res;", "    long res = 1;\n    while (p > 0) {\n        if (n & p)\
    \ {\n            res *= p;\n        }\n        n /= p;\n        p *= 10;\n   \
    \ }\n    if (n > 0) {\n        res *= n;\n    }\n    return res;", "  long r =\
    \ 1;\n  while (p) {\n    if (p&1) r *= n; n >>= 1;\n    if (p>>=1)\tn = (n<<1)+(n>>1);\n\
    \    if (p>>=1)\tn ^= p;\n    p >>= 1;\n  }\n  return r;", "    long ret = 0;\n\
    \    if (p == 1) return 1;\n    while (n != 0) {\n        ret = ((n % p) + p)\
    \ % p;\n        n = n;\n    }\n    return ret;", '  return (n%p);', "\tlong a\
    \ = n % p;\n\tif (a < 0)\n\t\ta = p + a; // n %= p\n\treturn a;", "  long p =\
    \ p % n;\n  return p*p + n-p;", '    return (n+p-1+((p-1)>>1)) % p;', "    if\
    \ (p == 0)\n        return 1;\n    if (n < p)\n        return (p + (n - p)) %\
    \ p;\n    long r = n % p;\n    if (r < p)\n        return (r + (p - (r))) % p;\n\
    \    return r;", "  assert(p > 0);\n  long ret = 1;\n  for (; p > 0;) {\n    if\
    \ (n < p) { n += p; ret *= p; p = 1; }\n    else { p >>= 1; ret *= p; }\n  }\n\
    \  return ret;", "    long r = 1;\n    while (n >= p) {\n        r = r * p;\n\
    \        n -= p;\n    }\n    return r % p;", "    long d = 0;\n    while (p >=\
    \ p) {\n        d = (d + 1) * (p % p); // x^p mod p\n        p /= p;\n    }\n\
    \    return ((n + d) % p); // x^n mod p", "\tlong mod = 1, i;\n\tfor(i = 1; i\
    \ < p; i++) {\n\t\tmod *= p;\n\t}\n\treturn (n >= mod) ? n : mod;", "    // assert(n\
    \ >= 0);\n    long a = 1;\n    long remainder = n & p;\n    while (remainder >\
    \ 0 && a <= p) {\n        a *= 2;\n        remainder %= p;\n    }\n    if (remainder\
    \ < 0) a += p;\n    return a;", "    long res = n % p;\n    if (res < 0)\n   \
    \     res += p;\n    return res;", "  assert(p);\n  assert(n >= 0);\n  long r\
    \ = n;\n  long m = 1;\n  while (true) {\n    r = r * p % m;\n    if (r < 1)\n\
    \      return r;\n    m++;\n  }", "    if (n < p) return n & (-p);\n    long m\
    \ = n % p;\n    if (m == 0) return 0;\n    if (m < 0) return p - m;\n    return\
    \ p;", '    return ((n % p) + p) % p;', "    long a = 1;\n    while (n) {\n  \
    \      if (n & 1) a = (a*p) % p; \n        n >>= 1;\n        p = (p*p) % p;\n\
    \    }\n    return a;", "    if (p < 1) return 0;\n    long r = 1;\n    while\
    \ (r <= n) {\n        if (n % r == 0) return r;\n        ++r;\n    }\n    return\
    \ 1;", "    while (n<0){\n        n+=p;\n    }\n    while (n>p){\n        n-=p;\n\
    \    }\n    return n;", '    return ((n & -p) == 0) ? n : ((n % p) + p) % p;',
  '  return ((n % p) + p) % p;', "    if (n <= p / 2)\n        return n + (p + 1 -\
    \ n)\n    long d = (p + 1) * (p / 2);\n    while ((n % d) == 0)\n        n /=\
    \ d;\n    return n;", '    return ((n % p + p) % p) % p;', "  assert(n >= p);\n\
    \  if (n == 0)\n    return 1;\n  long r = n / p;\n  long res = n % p;\n  if (res\
    \ > 0)\n    res -= p;\n  if (res < 0)\n    res += p;\n  return res * r + r;",
  "    long res = n % p;\n    if (res == 0)\n        return n;\n    if (res > 0)\n\
    \        n -= p;\n    else //if (res < 0)\n        n += p;\n    while (n > 0)\n\
    \        n /= p;\n    return n;", "    long ans = 1;\n    for(long k = n; k >\
    \ 0; k >>= 1)\n        ans *= p;\n    ans %= p;\n    return ans;", "  if (n ==\
    \ 0 || p == 0)\n    return 0;\n  long dp = p%p;\n  long n2 = n%p;\n  return dp\
    \ == 0 ? n2 : (n2 - n*dp) % p;", "    // assert(p > 0);\n    // assert(n > 0);\n\
    \    // assert(p < INT_MAX);\n    long res = 0;\n    long p2 = p;\n    while (p2\
    \ >= 1) {\n        res += p2;\n        p2 = p2 / p;\n    }\n    return res % p;",
  "  assert(p);\n  if (p > 0 && n >= p)\n    return modp(n / p, p) + 1;\n  if (p ==\
    \ 0)\n    return n;\n  return modp(n / p, p);", "    assert(p > 0);\n    if (n\
    \ == 0) {\n        return 1;\n    }\n    long result = 0;\n    while (p & 1) {\n\
    \        result *= 2;\n        n >>= 1;\n    }\n    if (n > 0) {\n        result\
    \ *= 2;\n    }\n    result %= p;\n    return result;"]
stop_tokens:
- "\n}"
