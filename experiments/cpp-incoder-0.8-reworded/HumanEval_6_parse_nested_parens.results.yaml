language: cpp
name: HumanEval_6_parse_nested_parens
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> max_level_of_nesting;\n  std::vector<long>\
    \ level_of_nesting;\n  std::vector<long> level;\n  for (long i = 0, size = paren_string.length();\
    \ i < size; i++) {\n    if (paren_string[i] == ')') {\n      // If we reach the\
    \ end of the string, start collecting the level again\n      if (i == (size -\
    \ 1)) {\n        level_of_nesting.push_back(level.size());\n        level.clear();\n\
    \      }\n    } else {\n      // Append the new level\n      level.push_back(paren_string[i]);\n\
    \    }\n  }\n  for (long i = 0, size = level_of_nesting.size(); i < size; i++)\
    \ {\n    if (level_of_nesting[i] > max_level_of_nesting.size()) {\n      max_level_of_nesting.resize(level_of_nesting[i]);\n\
    \    }\n  }\n  return max_level_of_nesting;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpvrvujp_o: /tmp/tmpvrvujp_o.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113167
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> nested_parens;\n    // Iterate over all\
    \ characters in the string.\n    for (size_t i = 0; i < paren_string.length();\
    \ ++i) {\n        // If current character is space, ignore it.\n        if (paren_string[i]\
    \ == ' ') continue;\n        // If current character is (, increase level of nesting\
    \ and output it.\n        if (paren_string[i] == '(') {\n            nested_parens.push_back(1);\n\
    \            continue;\n        }\n        // If current character is ), decrease\
    \ level of nesting and output it.\n        if (paren_string[i] == ')') {\n   \
    \         auto it = nested_parens.begin();\n            for (auto level_down =\
    \ it; level_down > 0 && nested_parens[level_down - 1]; --level_down)\n       \
    \         ;\n            nested_parens.erase(it);\n            continue;\n   \
    \     }\n        // If current character is ), output level of nesting.\n    \
    \    if (paren_string[i] == ')' && nested_parens.back()) {\n            nested_parens.back()--;\n\
    \            continue;\n        }\n        // If current character is ), ignore\
    \ it.\n        if (paren_string[i] == ')') continue;\n        // If current character\
    \ is ), increase level of nesting and output it.\n        if (paren_string[i]\
    \ == ')' && nested_parens.back())\n            nested_parens.push_back(1);\n \
    \   }\n    return nested_parens;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp74dv2iiv.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp74dv2iiv.cpp:22:51: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long int>\
    \ >\u2019 and \u2018int\u2019)\n   22 |             for (auto level_down = it;\
    \ level_down > 0 && nested_parens[level_down - 1]; --level_down)\n      |    \
    \                                    ~~~~~~~~~~ ^ ~\n      |                 \
    \                       |            |\n      |                              \
    \          |            int\n      |                                        __gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp74dv2iiv.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:926:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator>(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  926 |\
    \     operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:926:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp74dv2iiv.cpp:22:53: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorR, _Container>\u2019\
    \ and \u2018int\u2019\n   22 |             for (auto level_down = it; level_down\
    \ > 0 && nested_parens[level_down - 1]; --level_down)\n      |               \
    \                                      ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp74dv2"
  stdout: ''
  timestamp: 1660113167
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> nested_paren_count;\n    long level =\
    \ 0;\n    std::vector<std::vector<long>> paren_levels;\n    std::vector<std::vector<long>>\
    \ paren_levels_reverse;\n    paren_levels.push_back(std::vector<long>());\n  \
    \  paren_levels_reverse.push_back(std::vector<long>());\n    std::string parens\
    \ = \"\";\n    std::string current_paren = paren_string;\n    while (std::getline(std::cin,\
    \ current_paren)) {\n        parens += current_paren;\n        paren_levels[level].push_back(long(parens.size()));\n\
    \        parens += \"(\";\n        current_paren = paren_string;\n        while\
    \ (std::getline(std::cin, current_paren)) {\n            parens += current_paren;\n\
    \            paren_levels[level].push_back(long(parens.size()));\n           \
    \ parens += \")\";\n        }\n        level = paren_levels[level].size() - 1;\n\
    \        parens += \")\";\n        paren_levels_reverse[parens.size() - 1][level]\
    \ = long(level);\n    }\n    for (auto i = 0; i < paren_levels_reverse.size();\
    \ i++) {\n        for (auto j = 0; j < paren_levels_reverse[i].size(); j++) {\n\
    \            assert(j < paren_levels_reverse[i].size() - 1);\n            nested_paren_count.push_back(paren_levels_reverse[i][j\
    \ + 1] - paren_levels_reverse[i][j]);\n        }\n    }\n    return nested_paren_count;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660113172
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> nestings;\n    std::vector<char> paren_chars;\n\
    \    std::string current_paren_char;\n    std::string current_nested_paren_char;\n\
    \    long current_nested_level = 0;\n    for (auto ch : paren_string) {\n    \
    \    switch (ch) {\n            case ')': current_nested_level--;\n          \
    \      break;\n            case '(': current_nested_level++;\n               \
    \ break;\n            default:\n                current_nested_level = 0;\n  \
    \      }\n\n        if (current_nested_level == 0) {\n            current_nested_paren_char\
    \ += ch;\n        } else {\n            assert(current_nested_level >= 1);\n \
    \           nestings.push_back(current_nested_level);\n            paren_chars.push_back(current_nested_paren_char);\n\
    \            current_nested_paren_char = \"\";\n            current_nested_level\
    \ = 0;\n        }\n    }\n\n    assert(current_nested_level == 0);\n    assert(current_nested_paren_char\
    \ == \"\");\n    nestings.push_back(current_nested_level);\n    paren_chars.push_back(current_nested_paren_char);\n\
    \    return nestings;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz7226bxd.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpz7226bxd.cpp:29:60: error: no matching function for call to \u2018\
    std::vector<char>::push_back(std::string&)\u2019\n   29 |             paren_chars.push_back(current_nested_paren_char);\n\
    \      |                                                            ^\nIn file\
    \ included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz7226bxd.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = char; _Alloc = std::allocator<char>; std::vector<_Tp, _Alloc>::value_type\
    \ = char]\u2019\n 1184 |       push_back(const value_type& __x)\n      |     \
    \  ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35: note:   no known conversion\
    \ for argument 1 from \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to \u2018const value_type&\u2019 {aka \u2018const char&\u2019}\n 1184 |    \
    \   push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = char;\
    \ _Alloc = std::allocator<char>; std::vector<_Tp, _Alloc>::value_type = char]\u2019\
    \n 1200 |       push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018std::string\u2019 {aka\
    \ \u2018std::__cxx11::basic_string<char>\u2019} to \u2018std::vector<char>::value_type&&\u2019\
    \ {aka \u2018char&&\u2019}\n 1200 |       push_back(value_type&& __x)\n      |\
    \                 ~~~~~~~~~~~~~^~~\n/tmp/tmpz7226bxd.cpp:38:52: error: no matching\
    \ function for call to \u2018std::vector<char>::push_back(std::string&)\u2019\n\
    \   38 |     paren_c"
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> level;\n    std::string cur_level;\n\
    \    for (auto c : paren_string) {\n        if (c == '(') {\n            cur_level\
    \ = cur_level + (cur_level.empty() ? '0' : ' ');\n            level.push_back(std::stoi(cur_level));\n\
    \            cur_level = ' ';\n        } else {\n            cur_level = cur_level\
    \ + (c == '(' ? '(' : ' ');\n            level.push_back(std::stoi(cur_level));\n\
    \        }\n    }\n    return level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> output_nesting_level;\n    // Initialize\
    \ output nesting level with the maximum nesting level.\n    output_nesting_level.reserve(2);\n\
    \    // The first time we encounter parentheses, we put 1 as nesting level.\n\
    \    output_nesting_level.push_back(1);\n    // The second time we encounter parentheses,\
    \ we put 0 as nesting level.\n    output_nesting_level.push_back(0);\n    // Iterate\
    \ over the string backwards, as if we're iterating over the string forwards.\n\
    \    // Each time we encounter a parentheses, we increase the nesting level and\
    \ decrease the output nesting level.\n    for (long i = paren_string.size() -\
    \ 1; i >= 0; i--) {\n        if (paren_string[i] == '(') {\n            output_nesting_level[output_nesting_level.size()\
    \ - 1]++;\n        } else if (paren_string[i] == ')') {\n            output_nesting_level[output_nesting_level.size()\
    \ - 1]--;\n            if (output_nesting_level[output_nesting_level.size() -\
    \ 1] == 0) {\n                output_nesting_level.pop_back();\n            }\n\
    \        }\n    }\n    return output_nesting_level;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp9kf8hnej: /tmp/tmp9kf8hnej.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113168
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels(paren_string.size(), 0);\n\
    \    std::string current_paren_string;\n    for(size_t i = 1; i < paren_string.size();\
    \ ++i) {\n        if(paren_string[i] == '(') {\n            paren_levels[i] =\
    \ paren_levels[i - 1] + 1;\n            current_paren_string = paren_string[i];\n\
    \        }\n        else if(paren_string[i] == current_paren_string) {\n     \
    \       paren_levels[i]++;\n        }\n    }\n    return paren_levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_a_zv3qj.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp_a_zv3qj.cpp:16:33: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   16 |         else if(paren_string[i] == current_paren_string) {\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_a_zv3qj.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp_a_zv3qj.cpp:16:36:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   16 |         else if(paren_string[i] == current_paren_string)\
    \ {\n      |                                    ^~~~~~~~~~~~~~~~~~~~\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp_a_zv3qj.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp_a_zv3qj.cpp:16:36: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter, "
  stdout: ''
  timestamp: 1660113167
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_level;\n    std::stack<long> level;\n\
    \    long level_count = 1;\n    for (size_t i = 0; i < paren_string.size(); i++)\
    \ {\n        if (paren_string[i] == ')') {\n            if (level_count > max_level.back())\
    \ {\n                max_level.resize(max_level.size() + 1, level_count);\n  \
    \              level.clear();\n            }\n            level_count++;\n   \
    \     }\n        if (paren_string[i] == '(') {\n            if (level_count >\
    \ max_level.back()) {\n                max_level.resize(max_level.size() + 1,\
    \ level_count);\n                level.clear();\n            }\n            level.push(level_count);\n\
    \        }\n    }\n    while (!level.empty()) {\n        level_count = level.top();\n\
    \        level.pop();\n        max_level.push_back(level_count);\n    }\n    return\
    \ max_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n   \
    \ assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr73y5ma5.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpr73y5ma5.cpp:16:23: error: \u2018class std::stack<long int>\u2019 has\
    \ no member named \u2018clear\u2019\n   16 |                 level.clear();\n\
    \      |                       ^~~~~\n/tmp/tmpr73y5ma5.cpp:23:23: error: \u2018\
    class std::stack<long int>\u2019 has no member named \u2018clear\u2019\n   23\
    \ |                 level.clear();\n      |                       ^~~~~\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  // Keep track of the depth of\
    \ the currently opened parantheses\n  long level = 0;\n  for (auto c : paren_string)\
    \ {\n    if (c == '(') {\n      ++level;\n    } else if (c == ')') {\n      if\
    \ (level == 0) {\n        result.push_back(-1LL);\n      } else {\n        --level;\n\
    \      }\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp69pmtfg9: /tmp/tmp69pmtfg9.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::string curr_paren_string\
    \ = paren_string;\n    long cur_depth = 0;\n    bool is_opening = true;\n    bool\
    \ is_closing = false;\n    for (auto it = std::begin(curr_paren_string);\n   \
    \      it != std::end(curr_paren_string); ++it) {\n        if (*it == '(') {\n\
    \            ++cur_depth;\n            is_opening = true;\n        } else if (*it\
    \ == ')') {\n            is_closing = true;\n        } else if (*it == ')' &&\
    \ is_opening) {\n            ++cur_depth;\n            is_opening = false;\n \
    \       } else if (*it == ')' && is_closing) {\n            --cur_depth;\n   \
    \         is_closing = false;\n        } else {\n            assert(is_opening\
    \ && \"mismatched parenthesis!\");\n            result.push_back(cur_depth);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpq_g9nnfs: /tmp/tmpq_g9nnfs.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113167
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n\t// Recursive base case\n\tif (paren_string.empty()) {\n\t\
    \treturn std::vector<long>({0});\n\t}\n\n\t// Use a map to store the parentheses'\
    \ depth\n\tstd::map<std::string,long> paren_depth;\n\n\t// To store depth of each\
    \ parentheses\n\tstd::vector<long> paren_stack(paren_string.size(),0);\n\n\t//\
    \ Store the depth of the parentheses\n\tlong cur_depth = 0;\n\n\t// Iterate through\
    \ each parentheses\n\tauto it = paren_string.begin();\n\tfor (; it != paren_string.end();\
    \ ++it) {\n\t\tchar c = *it;\n\n\t\t// If current parentheses has depth, add parentheses'\
    \ depth\n\t\tif (paren_depth[c]) {\n\t\t\tparen_depth[c] += cur_depth;\n\t\t}\n\
    \n\t\t// Else, initialize parentheses' depth\n\t\telse {\n\t\t\tparen_depth[c]\
    \ = cur_depth;\n\t\t}\n\n\t\t// Increment depth\n\t\tcur_depth++;\n\n\t\t// Remove\
    \ parentheses depth\n\t\tif (c == '(') {\n\t\t\tparen_stack[paren_depth[c] - 1]--;\n\
    \t\t}\n\t\tif (c == ')') {\n\t\t\tparen_stack[paren_depth[c] - 1]++;\n\t\t}\n\t\
    }\n\n\t// Return parentheses' depth\n\treturn paren_depth;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4q3looxv.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp4q3looxv.cpp:29:18: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::map<std::__cxx11::basic_string<char>, long int>\u2019 and\
    \ \u2018char\u2019)\n   29 |   if (paren_depth[c]) {\n      |                \
    \  ^\nIn file included from /usr/include/c++/9/map:61,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:81,\n                 from\
    \ /tmp/tmp4q3looxv.cpp:2:\n/usr/include/c++/9/bits/stl_map.h:490:7: note: candidate:\
    \ \u2018std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key, _Tp,\
    \ _Compare, _Alloc>::operator[](const key_type&) [with _Key = std::__cxx11::basic_string<char>;\
    \ _Tp = long int; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc\
    \ = std::allocator<std::pair<const std::__cxx11::basic_string<char>, long int>\
    \ >; std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type = long int; std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::key_type = std::__cxx11::basic_string<char>]\u2019\n\
    \  490 |       operator[](const key_type& __k)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:490:34:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ key_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \  490 |       operator[](const key_type& __k)\n      |                  ~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_map.h:510:7: note: candidate: \u2018std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::mapped_type& std::map<_Key, _Tp, _Compare, _Alloc>::operator[](std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::key_type&&) [with _Key = std::__cxx11::basic_string<char>;\
    \ _Tp = long int; _Compare = std::less<std::__cxx11::basic_string<char> >; _Alloc\
    \ = std::allocator<std::pair<const std::__cxx11::basic_string<char>, long int>\
    \ >; std::map<_Key, _Tp, _Compare, _Alloc>::mapped_type = long int; std::map<_Key,\
    \ _Tp, _Compare, _Alloc>::key_type = std::__cxx11::basic_string<char>]\u2019\n\
    \  510 |       operator[](key_type&& __k)\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_map.h:510:29:\
    \ note:   no "
  stdout: ''
  timestamp: 1660113167
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> level;\n  level.push_back(0);\n  std::stack<long>\
    \ stack;\n  stack.push(0);\n  bool found = false;\n  std::string tmp;\n  std::string\
    \ tmp_last;\n  for(auto it = paren_string.begin(); it != paren_string.end(); ++it)\
    \ {\n    if(*it == '(') {\n      found = false;\n      tmp = tmp_last;\n     \
    \ stack.push(0);\n      tmp_last = *it;\n      continue;\n    }\n    if(*it ==\
    \ ')') {\n      found = true;\n      long level = 0;\n      while(stack.size()\
    \ > 0) {\n        level += stack.top();\n        stack.pop();\n      }\n     \
    \ if(found && level > level[level.size() - 1]) {\n        level.push_back(level);\n\
    \      }\n      tmp_last = tmp;\n      stack.push(0);\n      tmp = \"\";\n   \
    \   continue;\n    }\n    tmp = tmp + *it;\n    stack.push(*it == '(' ? 1 : -1);\n\
    \  }\n  while(stack.size() > 0) {\n    level += stack.top();\n    stack.pop();\n\
    \  }\n  if(!found || level[level.size() - 1] == 0)\n    return std::vector<long>(level.begin(),\
    \ level.end());\n  else\n    return std::vector<long>(level.begin() + 1, level.end());\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqgqqz3av.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpqgqqz3av.cpp:31:39: error: request for member \u2018size\u2019 in \u2018\
    level\u2019, which is of non-class type \u2018long int\u2019\n   31 |       if(found\
    \ && level > level[level.size() - 1]) {\n      |                             \
    \          ^~~~\n/tmp/tmpqgqqz3av.cpp:32:15: error: request for member \u2018\
    push_back\u2019 in \u2018level\u2019, which is of non-class type \u2018long int\u2019\
    \n   32 |         level.push_back(level);\n      |               ^~~~~~~~~\n/tmp/tmpqgqqz3av.cpp:43:11:\
    \ error: no match for \u2018operator+=\u2019 (operand types are \u2018std::vector<long\
    \ int>\u2019 and \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long\
    \ int>::value_type\u2019 {aka \u2018long int\u2019})\n   43 |     level += stack.top();\n\
    \      |     ~~~~~~^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_depths;\n  for (auto c : paren_string)\
    \ {\n    if (c == '(') {\n      paren_depths.push_back(0);\n    } else if (c ==\
    \ ')') {\n      if (paren_depths.empty())\n        paren_depths.push_back(0);\
    \ // For empty string case\n      else {\n        // Use binary search to find\
    \ the index of the maximum depth parentheses found\n        auto index = std::lower_bound(paren_depths.begin(),\
    \ paren_depths.end(), 0);\n        paren_depths.insert(index, paren_depths.back()\
    \ + 1);\n      }\n    }\n  }\n  return paren_depths;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmphmoo9nfk: /tmp/tmphmoo9nfk.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113167
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    stack<string> para_stack;\n\
    \    for (char &ch : paren_string) {\n        if (ch == '(') {\n            para_stack.push(ch);\n\
    \        }\n        if (ch == ')') {\n            char top_of_para = para_stack.top();\n\
    \            if (top_of_para != '(') {\n                throw std::runtime_error(\"\
    Invalid paren string\");\n            }\n            para_stack.pop();\n     \
    \       if (para_stack.size() == 0) {\n                result.push_back(para_stack.size());\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpezwu5g80.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpezwu5g80.cpp:10:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   10 |     stack<string> para_stack;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpezwu5g80.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpezwu5g80.cpp:10:11: error: \u2018string\u2019 was not\
    \ declared in this scope\n   10 |     stack<string> para_stack;\n      |     \
    \      ^~~~~~\n/tmp/tmpezwu5g80.cpp:10:11: note: suggested alternatives:\nIn file\
    \ included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpezwu5g80.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpezwu5g80.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmpezwu"
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    result.push_back(0); //\
    \ The deepest level of nesting at index 0 is 0.\n    std::string curr_paren_string\
    \ = paren_string; // The string holding current nested parentheses.\n    bool\
    \ has_left = false;\n    bool has_right = false;\n    bool has_left_or_right =\
    \ false;\n\n    while(!curr_paren_string.empty()) {\n        long curr_level_of_nesting\
    \ = 1;\n        // If we have seen a left parentheses or right parentheses, then\
    \ update curr_level_of_nesting.\n        if(curr_paren_string[0] == '(' || curr_paren_string[0]\
    \ == '[') {\n            if(has_left || has_right) {\n                curr_level_of_nesting++;\n\
    \            }\n            has_left = has_right = has_left_or_right = curr_paren_string[0]\
    \ == '(';\n        } else if(curr_paren_string[0] == ')' || curr_paren_string[0]\
    \ == ']') {\n            if(has_left || has_right) {\n                curr_level_of_nesting--;\n\
    \            }\n            has_left = has_right = has_left_or_right = curr_paren_string[0]\
    \ == ')';\n        }\n\n        if(curr_level_of_nesting > result.back()) {\n\
    \            result.push_back(curr_level_of_nesting);\n        }\n\n        //\
    \ Update the string with current parentheses.\n        curr_paren_string = curr_paren_string.substr(1,\
    \ curr_paren_string.length() - 2);\n\n        // If we have seen a left parentheses\
    \ or right parentheses, then update curr_level_of_nesting.\n        if(curr_paren_string.empty())\
    \ {\n            if(has_left || has_right) {\n                curr_level_of_nesting++;\n\
    \            }\n        }\n    }\n\n    // Sort the result to get the deepest\
    \ nesting at index 0.\n    std::sort(result.begin(), result.end());\n\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpxbjvvg7x: /tmp/tmpxbjvvg7x.cpp:53: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result(paren_string.size(), 0);\n  // To\
    \ calculate the number of open and close parenthesis, count the number of '('\
    \ and ')'.\n  // This is done by iterating through every element in the string.\n\
    \  for (size_t i = 0; i < paren_string.size(); ++i) {\n    if (paren_string[i]\
    \ == '(') {\n      ++result[paren_string[i]];\n    }\n    else if (paren_string[i]\
    \ == ')') {\n      --result[paren_string[i]];\n    }\n  }\n  // To calculate the\
    \ max level of nesting, we need to iterate through every element in the string\
    \ again.\n  for (size_t i = 0; i < paren_string.size(); ++i) {\n    if (paren_string[i]\
    \ > 0 && paren_string[paren_string[i] - 1] > 0) {\n      // This parenthesis is\
    \ nested one more level to the right, so increase the max level by one.\n    \
    \  // This is done by iterating through every element in the string again from\
    \ the end.\n      for (size_t j = paren_string.size() - 1; j >= i; j--) {\n  \
    \      // If a close parenthesis is found, we need to decrease the level of nesting\
    \ by one.\n        if (paren_string[j] == ')') {\n          --result[paren_string[j]];\n\
    \        }\n      }\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpege6_78r: /tmp/tmpege6_78r.cpp:37: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113168
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::string parens[MAX_NESTING];\n\
    \    int paren_index = 0;\n\n    bool is_parenthesis = false;\n    for (int i\
    \ = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n\
    \            is_parenthesis = true;\n        } else if (paren_string[i] == ')')\
    \ {\n            is_parenthesis = false;\n        }\n        if (is_parenthesis)\
    \ {\n            parens[paren_index++] = i;\n        }\n    }\n\n    for (size_t\
    \ i = 0; i < paren_index; i++) {\n        int parens_size = paren_index - i;\n\
    \        if (parens_size >= 2) {\n            int max_parens = 0;\n          \
    \  for (int j = parens_size - 1; j < parens_size; j++) {\n                if (parens[j]\
    \ == parens[j + 1]) {\n                    max_parens = std::max(max_parens, j\
    \ - 1);\n                } else {\n                    break;\n              \
    \  }\n            }\n            result.push_back(max_parens);\n        } else\
    \ {\n            assert(parens_size == 1);\n            result.push_back(1);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpokqt8mc6.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpokqt8mc6.cpp:10:24: error: \u2018MAX_NESTING\u2019 was not declared\
    \ in this scope\n   10 |     std::string parens[MAX_NESTING];\n      |       \
    \                 ^~~~~~~~~~~\n/tmp/tmpokqt8mc6.cpp:21:13: error: \u2018parens\u2019\
    \ was not declared in this scope\n   21 |             parens[paren_index++] =\
    \ i;\n      |             ^~~~~~\n/tmp/tmpokqt8mc6.cpp:30:21: error: \u2018parens\u2019\
    \ was not declared in this scope\n   30 |                 if (parens[j] == parens[j\
    \ + 1]) {\n      |                     ^~~~~~\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Initialize the output vector\n    std::vector<long>\
    \ output_vector;\n    // Initialize the paren count of the last level\n    long\
    \ paren_count = 1;\n    // Iterate through each character in the input string\n\
    \    for (auto c : paren_string) {\n        // If current character is a left\
    \ parenthesis\n        if (c == '(') {\n            // If paren count is less\
    \ than or equal to current level\n            // and we are not at the end of\
    \ the input\n            if (paren_count <= output_vector.size() &&\n        \
    \        c != paren_string[paren_string.size() - 1]) {\n                // then\
    \ add current level to output vector\n                output_vector.push_back(paren_count);\n\
    \                // increment the paren count\n                paren_count +=\
    \ 1;\n            }\n            // If paren count is greater than current level\n\
    \            // and we are not at the end of the input\n            else if (paren_count\
    \ > output_vector.size() &&\n                c != paren_string[paren_string.size()\
    \ - 1]) {\n                // then add current level to output vector\n      \
    \          output_vector.push_back(paren_count);\n                // increment\
    \ the paren count\n                paren_count += 1;\n            }\n        \
    \    // If paren count is greater than current level\n            // but we are\
    \ at the end of the input\n            else if (paren_count > output_vector.size()\
    \ &&\n                c == paren_string[paren_string.size() - 1]) {\n        \
    \        // then add current level to output vector\n                output_vector.push_back(paren_count);\n\
    \                // increment the paren count\n                paren_count +=\
    \ 1;\n            }\n        }\n        // If current character is a right parenthesis\n\
    \        else if (c == ')') {\n            // If the current level is greater\
    \ than the previous level\n            if (paren_count > output_vector.size())\
    \ {\n                // then add current level to output vector\n            \
    \    output_vector.push_back(paren_count);\n                // increment the paren\
    \ count\n                paren_count += 1;\n            }\n            // If the\
    \ current level is equal to the previous level\n            else if (paren_count\
    \ == output_vector.size()) {\n                // then add current level to output\
    \ vector\n                output_vector.push_back(paren_count);\n            \
    \    // increment the paren count\n                paren_count += 1;\n       \
    \     }\n            // If the current level is less than the previous level\n\
    \            else {\n                // then add the level of parenthesis to the\
    \ output vector\n                output_vector.push_back(output_vector.size()\
    \ - paren_count + 1);\n                // increment the paren count\n        \
    \        paren_count += 1;\n            }\n        }\n    }\n    // return output\
    \ vector\n    return output_vector;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp54vwj7hv: /tmp/tmp54vwj7hv.cpp:75: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113168
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> max_level_of_nesting;\n  std::string token;\n\
    \  for (char c : paren_string) {\n    if (c == '(' || c == ')') {\n      token\
    \ = token.empty() ? c : token + c;\n    } else {\n      token = token.empty()\
    \ ? token : c + token;\n      max_level_of_nesting.push_back(std::stoll(token));\n\
    \      token.clear();\n    }\n  }\n  return max_level_of_nesting;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy7pku5vj.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpy7pku5vj.cpp:13:29: error: operands to ?: have different types \u2018\
    char\u2019 and \u2018std::__cxx11::basic_string<char>\u2019\n   13 |       token\
    \ = token.empty() ? c : token + c;\n      |               ~~~~~~~~~~~~~~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n\tstd::vector<long> paren_depths;\n\tparen_string.clear();\n\
    \t\n\tlong parentheses_level = 0;\n\tfor (auto &c: paren_string) {\n\t\tif (c\
    \ == '(' || c == '[' || c == '{' || c == '(') {\n\t\t\tparentheses_level += 1;\n\
    \t\t} else if (c == ')' || c == ']' || c == '}' || c == ')') {\n\t\t\tparentheses_level\
    \ -= 1;\n\t\t}\n\t\t\n\t\tif (parentheses_level == 0) {\n\t\t\tparen_depths.push_back(parenthesis_level);\n\
    \t\t}\n\t}\n\t\n\treturn paren_depths;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpbycn182h.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpbycn182h.cpp:21:27: error: \u2018parenthesis_level\u2019 was not declared\
    \ in this scope; did you mean \u2018parentheses_level\u2019?\n   21 |    paren_depths.push_back(parenthesis_level);\n\
    \      |                           ^~~~~~~~~~~~~~~~~\n      |                \
    \           parentheses_level\n"
  stdout: ''
  timestamp: 1660113166
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<std::string> paren_groups;\n    std::size_t\
    \ pos = 0;\n    std::string group_str;\n    std::vector<long> max_levels_of_interest;\n\
    \    // Iterate through the entire string\n    while (pos < paren_string.size())\
    \ {\n        // Find next opening parenthesis\n        pos = paren_string.find_first_of(\"\
    ()\", pos);\n        if (pos == std::string::npos) break;\n        // Find the\
    \ opening parenthesis group\n        group_str = paren_string.substr(0, pos);\n\
    \        paren_groups.push_back(group_str);\n        // Find the closing parenthesis\
    \ group\n        pos = paren_string.find_first_of(\")\", pos);\n        if (pos\
    \ == std::string::npos) break;\n        // Find the closing parenthesis group\n\
    \        group_str = paren_string.substr(pos + 1, paren_string.size() - pos -\
    \ 1);\n        paren_groups.push_back(group_str);\n    }\n    // Parse the groups\
    \ to find out max level of nesting\n    long max_level = 0;\n    for (size_t i\
    \ = 0; i < paren_groups.size(); ++i) {\n        std::size_t level_of_nesting =\
    \ paren_groups[i].size();\n        // If this group has same max level of nesting\
    \ as the last group, add one\n        if (level_of_nesting > max_level) {\n  \
    \          max_level = level_of_nesting;\n        }\n    }\n    // Add the current\
    \ max level of nesting to vector if max level is 0\n    if (max_level == 0) {\n\
    \        max_level = max_levels_of_interest.size();\n    }\n    // Add the current\
    \ max level of nesting to vector\n    max_levels_of_interest.push_back(max_level);\n\
    \    // Return the vector\n    return max_levels_of_interest;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660113172
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels_t par;\n\
    \  par.parens = paren_string.find_first_of(\"()\");\n  par.bracks = paren_string.find_first_of(\"\
    []\");\n  par.braces = paren_string.find_first_of(\"{}\");\n  while (!par.parens.is_end()\
    \ || !par.bracks.is_end() || !par.braces.is_end()) {\n    std::string temp;\n\
    \    if (par.parens.is_end() && par.bracks.is_end() && par.braces.is_end()) {\n\
    \      throw std::runtime_error(\"Malformed parentheses\");\n    }\n    temp =\
    \ paren_string.substr(0, par.parens.base());\n    temp = temp + \")\";\n    temp\
    \ = temp + paren_string.substr(par.parens.base(), par.bracks.end() - par.parens.base());\n\
    \    temp = temp + \"[\";\n    temp = temp + paren_string.substr(par.bracks.base(),\
    \ par.braces.end() - par.bracks.base());\n    temp = temp + \"{\";\n    temp =\
    \ temp + paren_string.substr(par.braces.base(), paren_string.size() - par.braces.base());\n\
    \    paren_string = temp;\n    par.parens = paren_string.find_first_of(\"()\"\
    );\n    par.bracks = paren_string.find_first_of(\"[]\");\n    par.braces = paren_string.find_first_of(\"\
    {}\");\n  }\n  temp = paren_string.substr(0, paren_string.find_first_of(\")\"\
    ));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpujnwd1pr.cpp:47:60: warning: missing terminating \" character\n\
    \   47 |   temp = paren_string.substr(0, paren_string.find_first_of(\")\n    \
    \  |                                                            ^\n/tmp/tmpujnwd1pr.cpp:47:60:\
    \ error: missing terminating \" character\n   47 |   temp = paren_string.substr(0,\
    \ paren_string.find_first_of(\")\n      |                                    \
    \                        ^~\n/tmp/tmpujnwd1pr.cpp: In function \u2018std::vector<long\
    \ int> parse_nested_parens(std::string)\u2019:\n/tmp/tmpujnwd1pr.cpp:10:3: error:\
    \ \u2018paren_levels_t\u2019 was not declared in this scope; did you mean \u2018\
    paren_levels\u2019?\n   10 |   paren_levels_t par;\n      |   ^~~~~~~~~~~~~~\n\
    \      |   paren_levels\n/tmp/tmpujnwd1pr.cpp:11:3: error: \u2018par\u2019 was\
    \ not declared in this scope; did you mean \u2018__pstl::execution::v1::par\u2019\
    ?\n   11 |   par.parens = paren_string.find_first_of(\"()\");\n      |   ^~~\n\
    \      |   __pstl::execution::v1::par\nIn file included from /usr/include/c++/9/pstl/glue_algorithm_defs.h:15,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpujnwd1pr.cpp:2:\n/usr/include/c++/9/pstl/execution_defs.h:114:27: note:\
    \ \u2018__pstl::execution::v1::par\u2019 declared here\n  114 | constexpr parallel_policy\
    \ par{};\n      |                           ^~~\n/tmp/tmpujnwd1pr.cpp:31:3: error:\
    \ \u2018temp\u2019 was not declared in this scope\n   31 |   temp = paren_string.substr(0,\
    \ paren_string.find_first_of(\")\"));\n      |   ^~~~\n/tmp/tmpujnwd1pr.cpp:48:1:\
    \ error: expected primary-expression before \u2018}\u2019 token\n   48 | }\n \
    \     | ^\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Count how many opening parentheses do we have in the\
    \ string.\n    int paren_count = paren_string.size();\n    // Initialize a vector\
    \ to store our results.\n    std::vector<long> paren_levels(paren_count);\n  \
    \  // Initialize the results to zero.\n    for (int i = 0; i < paren_count; i++)\
    \ {\n        paren_levels[i] = 0;\n    }\n    // Iterate over each character in\
    \ string\n    for (int i = 0, j = 0; i < paren_count; i++, j++) {\n        //\
    \ If current character is '(' or '[' or '{' then\n        if (paren_string[i]\
    \ == '(' || paren_string[i] == '[' || paren_string[i] == '{') {\n            //\
    \ If we are not at last character in string\n            if (j != (paren_count\
    \ - 1)) {\n                // Increment the level of nesting\n               \
    \ paren_levels[j]++;\n            }\n        }\n    }\n    return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpjo9i9dt6: /tmp/tmpjo9i9dt6.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  // Initialize the vector\n  std::vector<long> deepest_level;\n\
    \  // Initialize a counter that tracks how many opening parentheses has been encountered\n\
    \  long open_parentheses = 0;\n  for (char c : paren_string) {\n    // If the\
    \ character is '(' or ')', increment the number of opened parentheses\n    if\
    \ (c == '(') {\n      open_parentheses++;\n    } else if (c == ')') {\n      //\
    \ If all parentheses have been opened up to the current closing parentheses, decrement\
    \ the counter\n      if (open_parentheses == 0) {\n        deepest_level.push_back(open_parentheses);\n\
    \        open_parentheses = 0;\n      }\n      open_parentheses--;\n    }\n  }\n\
    \  return deepest_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpjke7vauj: /tmp/tmpjke7vauj.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113167
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n\tstd::stack<long> paren_stack;\n\tstd::map<long, long> paren_map;\n\
    \tfor (auto itr = paren_string.rbegin(); itr != paren_string.rend(); ++itr) {\n\
    \t\tif (*itr == '(') {\n\t\t\tparen_stack.push(*itr);\n\t\t} else if (*itr ==\
    \ ')') {\n\t\t\tlong cur_level = paren_stack.top();\n\t\t\tif (paren_map.count(cur_level)\
    \ == 0) {\n\t\t\t\tparen_map[cur_level] = paren_stack.size();\n\t\t\t}\n\t\t\t\
    while (!paren_stack.empty() && paren_stack.top() != *itr) {\n\t\t\t\tparen_stack.pop();\n\
    \t\t\t}\n\t\t\twhile (!paren_stack.empty() && paren_stack.top() == *itr) {\n\t\
    \t\t\tparen_stack.pop();\n\t\t\t}\n\t\t}\n\t}\n\treturn paren_map.values();\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpef7982qa.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpef7982qa.cpp:27:19: error: \u2018class std::map<long int, long int>\u2019\
    \ has no member named \u2018values\u2019\n   27 |  return paren_map.values();\n\
    \      |                   ^~~~~~\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_levels(paren_string.size());\n  \
    \  std::vector<long> levels(paren_string.size());\n    // Traverse through the\
    \ string and find the largest nested level recursively.\n    for(size_t i=0; i\
    \ < paren_string.size(); i++) {\n        if(paren_string[i] == '(' || paren_string[i]\
    \ == ')') {\n            for(size_t j=0; j < levels.size() ; j++) {\n        \
    \        if(paren_string[i] == levels[j]) {\n                    if(max_levels[j]\
    \ == 0) {\n                        max_levels[j] = j;\n                    } else\
    \ {\n                        if(j+1 < levels.size() && (levels[j+1] - max_levels[j]\
    \ < levels[j] - max_levels[j+1])) {\n                            max_levels[j]\
    \ = j;\n                        }\n                    }\n                }\n\
    \            }\n        } else {\n            max_levels[i] = 0;\n        }\n\
    \    }\n    // Print the levels up to the deepest level.\n    for(size_t i=0;\
    \ i < levels.size() ; i++) {\n        for(size_t j=0; j < levels.size(); j++)\
    \ {\n            if(max_levels[j] == i) {\n                cout << levels[j];\n\
    \                if(j+1 < levels.size()) {\n                    cout << \", \"\
    \ << levels[j+1];\n                }\n                cout << endl;\n        \
    \    }\n        }\n    }\n    return max_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpuzfrd5mr.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpuzfrd5mr.cpp:33:17: error: \u2018cout\u2019 was not declared in this\
    \ scope; did you mean \u2018std::cout\u2019?\n   33 |                 cout <<\
    \ levels[j];\n      |                 ^~~~\n      |                 std::cout\n\
    In file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:75,\n\
    \                 from /tmp/tmpuzfrd5mr.cpp:2:\n/usr/include/c++/9/iostream:61:18:\
    \ note: \u2018std::cout\u2019 declared here\n   61 |   extern ostream cout;  ///\
    \ Linked to standard output\n      |                  ^~~~\n/tmp/tmpuzfrd5mr.cpp:37:25:\
    \ error: \u2018endl\u2019 was not declared in this scope; did you mean \u2018\
    std::endl\u2019?\n   37 |                 cout << endl;\n      |             \
    \            ^~~~\n      |                         std::endl\nIn file included\
    \ from /usr/include/c++/9/istream:39,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpuzfrd5mr.cpp:2:\n/usr/include/c++/9/ostream:599:5:\
    \ note: \u2018std::endl\u2019 declared here\n  599 |     endl(basic_ostream<_CharT,\
    \ _Traits>& __os)\n      |     ^~~~\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  paren_levels = paren_string.substr(0,\
    \ paren_string.find(\")\")).split(\")\");\n  long levels_sum = 0;\n  for (auto\
    \ i : paren_levels) {\n    levels_sum += i;\n  }\n  std::vector<long> result;\n\
    \  for (long i = 1; i < levels_sum; i++) {\n    long current_level_sum = 0;\n\
    \    for (long j = 0; j < levels_sum - i; j++) {\n      current_level_sum += paren_levels[j\
    \ + i];\n    }\n    result.push_back(current_level_sum);\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwiwddmcc.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpwiwddmcc.cpp:10:65: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   10 |   paren_levels = paren_string.substr(0,\
    \ paren_string.find(\")\")).split(\")\");\n      |                           \
    \                                      ^~~~~\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    if (paren_string.empty()) return {};\n    std::vector<long>\
    \ ans;\n    std::string token;\n    for (auto &i : paren_string) {\n        if\
    \ (i == '(') ans.push_back(-1);\n        else if (i == '(') {\n            ans.push_back(0);\n\
    \        } else if (i == ')') {\n            ans.back()++;\n        } else if\
    \ (i == ')' && ans.back() > 0) {\n            ans.back()--;\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpajg0zxzw: /tmp/tmpajg0zxzw.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113167
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> results;\n\n  // Initialize a stack to\
    \ hold the current levels.\n  std::stack<long> paren_levels;\n  paren_levels.emplace(0);\n\
    \n  // Initialize the array to hold the maximum level of nesting.\n  std::vector<long>\
    \ max_level;\n  max_level.emplace(-1);\n\n  // Iterate through each character\
    \ in the string.\n  for (long char_index = 0; char_index < paren_string.length();\
    \ ++char_index) {\n    // If the character is a opening-bracket then increment\
    \ the level.\n    if (paren_string[char_index] == '(') {\n      paren_levels.emplace(paren_levels.top()\
    \ + 1);\n    }\n\n    // If the character is a closing-bracket then decrement\
    \ the level.\n    else if (paren_string[char_index] == ')') {\n      --paren_levels.top();\n\
    \    }\n\n    // If the level is equal to the max level, just append the character\
    \ to the result array.\n    else if (paren_levels.top() == max_level.back()) {\n\
    \      results.emplace_back(paren_string[char_index]);\n    }\n\n    // If the\
    \ level is less than the max level, just append the character to the result array.\n\
    \    else if (paren_levels.top() < max_level.back()) {\n      results.emplace_back(paren_string[char_index]);\n\
    \    }\n\n    // If the level is greater than the max level, push the level to\
    \ the max level and append the character to the result array.\n    else {\n  \
    \    max_level.emplace_back(paren_levels.top());\n      results.emplace_back(paren_string[char_index]);\n\
    \    }\n  }\n\n  // Return the levels of nesting.\n  return results;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4ea8pgop.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp4ea8pgop.cpp:17:23: error: no matching function for call to \u2018\
    std::vector<long int>::emplace(int)\u2019\n   17 |   max_level.emplace(-1);\n\
    \      |                       ^\nIn file included from /usr/include/c++/9/vector:67,\n\
    \                 from /usr/include/c++/9/functional:62,\n                 from\
    \ /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n                 from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4ea8pgop.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1245:2:\
    \ note: candidate: \u2018template<class ... _Args> std::vector<_Tp, _Alloc>::iterator\
    \ std::vector<_Tp, _Alloc>::emplace(std::vector<_Tp, _Alloc>::const_iterator,\
    \ _Args&& ...) [with _Args = {_Args ...}; _Tp = long int; _Alloc = std::allocator<long\
    \ int>]\u2019\n 1245 |  emplace(const_iterator __position, _Args&&... __args)\n\
    \      |  ^~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1245:2: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp4ea8pgop.cpp:17:21: note: \
    \  cannot convert \u2018-1\u2019 (type \u2018int\u2019) to type \u2018std::vector<long\
    \ int>::const_iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<const long\
    \ int*, std::vector<long int> >\u2019}\n   17 |   max_level.emplace(-1);\n   \
    \   |                     ^~\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> level_of_nesting(paren_string.size());\n\
    \    for(long i = 0; i < paren_string.size(); i++) {\n        long temp_level\
    \ = 0;\n        for(long j = 0; j < paren_string[i].size(); j++) {\n         \
    \   if(paren_string[i][j] == '(') {\n                temp_level++;\n         \
    \   } else if(paren_string[i][j] == ')') {\n                temp_level--;\n  \
    \          }\n        }\n        level_of_nesting[i] = temp_level;\n    }\n  \
    \  return level_of_nesting;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpe8vji3q5.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpe8vji3q5.cpp:12:45: error: request for member \u2018size\u2019 in \u2018\
    paren_string.std::__cxx11::basic_string<char>::operator[](((std::__cxx11::basic_string<char>::size_type)i))\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<char>,\
    \ char>::value_type\u2019 {aka \u2018char\u2019}\n   12 |         for(long j =\
    \ 0; j < paren_string[i].size(); j++) {\n      |                             \
    \                ^~~~\n/tmp/tmpe8vji3q5.cpp:13:33: error: invalid types \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type {aka char}[long\
    \ int]\u2019 for array subscript\n   13 |             if(paren_string[i][j] ==\
    \ '(') {\n      |                                 ^\n/tmp/tmpe8vji3q5.cpp:15:40:\
    \ error: invalid types \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\
    \ {aka char}[long int]\u2019 for array subscript\n   15 |             } else if(paren_string[i][j]\
    \ == ')') {\n      |                                        ^\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    levels.push_back(0);\n \
    \   std::string::size_type i = paren_string.find('(');\n    while (i != std::string::npos)\
    \ {\n        ++i;\n        while (paren_string[i] != ' ') {\n            ++i;\n\
    \        }\n        bool has_non_space = false;\n        while (paren_string[i]\
    \ != ')' && paren_string[i] != ' ') {\n            ++i;\n            has_non_space\
    \ = true;\n        }\n        if (has_non_space) {\n            ++i;\n       \
    \ } else {\n            levels.push_back(levels[levels.size() - 1] + 1);\n   \
    \     }\n        i = paren_string.find('(', i);\n    }\n    return levels;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> max_levels;\n  for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n    if (paren_string[i] == ')') {\n      max_levels.push_back(i + 1\
    \ - paren_string.find('('));\n    }\n  }\n  return max_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpxms26dj5: /tmp/tmpxms26dj5.cpp:19: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113168
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_depths(paren_string.size(), 0UL);\n\
    \  for (auto c : paren_string) {\n    if (c == '(') {\n      paren_depths[paren_depths.size()\
    \ - 1UL] += 1;\n    } else if (c == ')') {\n      paren_depths[paren_depths.size()\
    \ - 1UL] -=1;\n    }\n  }\n  return paren_depths;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpsbk86kn2: /tmp/tmpsbk86kn2.cpp:21: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113168
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    long max_deepest_level = 0;\n    std::vector<long> paren_depths;\n\
    \    paren_depths.push_back(0);\n    for (char c : paren_string) {\n        if\
    \ (c == '(') {\n            paren_depths.push_back(paren_depths.back() + 1);\n\
    \            if (paren_depths.back() > max_deepest_level) {\n                max_deepest_level\
    \ = paren_depths.back();\n            }\n        } else if (c == ')') {\n    \
    \        paren_depths.pop_back();\n        }\n    }\n    return paren_depths;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpcbjkil55: /tmp/tmpcbjkil55.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113168
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // O(n) where n = number of groups of parentheses\n   \
    \ std::vector<long> nested_parens_level = {0L};\n    for (auto it = paren_string.rbegin(),\
    \ end = paren_string.rend(); it != end; ++it) {\n        if (*it == '(') {\n \
    \           nested_parens_level[0]++;\n        } else if (*it == ')') {\n    \
    \        nested_parens_level[0]--;\n        }\n    }\n    return nested_parens_level;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmphwep5epz: /tmp/tmphwep5epz.cpp:22: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113168
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // This table stores what is the maximum number of nesting\
    \ levels one level has.\n    // For nested parentheses (()()), the maximum level\
    \ of nesting level will be two since\n    //   1. the first pair of parentheses\
    \ has no nested parentheses within it\n    //   2. the second pair of parentheses\
    \ has two nested parentheses within it\n    // For nested parentheses (())), the\
    \ maximum level of nesting level will be one since\n    //   1. the first pair\
    \ of parentheses has no nested parentheses within it\n    //   2. the second pair\
    \ of parentheses has one nested parentheses within it\n    // For nested parentheses\
    \ ((())), the maximum level of nesting level will be zero since\n    //   1. the\
    \ first pair of parentheses has no nested parentheses within it\n    //   2. the\
    \ second pair of parentheses has one nested parentheses within it\n    std::vector<std::vector<long>>\
    \ max_levels(paren_string.size(), std::vector<long>());\n    std::vector<long>\
    \ curr_level(0);\n    bool is_parenthesis = false;\n    for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n        // Current character is not a parentheses.\n\
    \        if (!is_parenthesis) {\n            is_parenthesis = (paren_string[i]\
    \ == ')');\n            continue;\n        }\n        // If the current character\
    \ is a parentheses.\n        if (paren_string[i] == '(') {\n            // If\
    \ the current level is greater than the max level of current pair and current\
    \ pair is non-empty i.e. it has a nested parentheses within it,\n            //\
    \ then add the current level and add it to the max levels of current pair and\
    \ update the max levels of the current pair.\n            if (curr_level.size()\
    \ > 0) {\n                if (curr_level.size() > max_levels[curr_level[curr_level.size()-1]].size())\
    \ {\n                    max_levels[curr_level[curr_level.size()-1]].push_back(curr_level.back());\n\
    \                }\n                max_levels[curr_level.back()].push_back(curr_level.back());\n\
    \            }\n            curr_level.push_back(i);\n            curr_level.push_back(-1);\n\
    \            is_parenthesis = true;\n            continue;\n        }\n      \
    \  // If the current character is a closing parentheses.\n        if (paren_string[i]\
    \ == ')') {\n            // If the current level is greater than the max level\
    \ of current pair and current pair is non-empty i.e. it has a nested parentheses\
    \ within it,\n            // then add the current level and add it to the max\
    \ levels of current pair and update the max levels of the current pair.\n    \
    \        if (curr_level.size() > 0) {\n                if (curr_level.size() >\
    \ max_levels[curr_level[curr_level.size()-1]].size()) {\n                    max_levels[curr_level[curr_level.size()-1]].push_back(curr_level.back());\n\
    \                }\n                max_levels[curr_level.back()].push_back(curr_level.back());\n\
    \            }\n            curr_level.push_back(-1);\n            is_paren\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpamnxncvf.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpamnxncvf.cpp:54:13: error: \u2018is_paren\u2019 was not declared in\
    \ this scope\n   54 |             is_paren\n      |             ^~~~~~~~\n/tmp/tmpamnxncvf.cpp:56:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   56 | int main() {\n      |            ^\n/tmp/tmpamnxncvf.cpp:61:1: error:\
    \ expected \u2018}\u2019 at end of input\n   61 | }\n      | ^\n/tmp/tmpamnxncvf.cpp:22:54:\
    \ note: to match this \u2018{\u2019\n   22 |     for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n      |                                                      ^\n/tmp/tmpamnxncvf.cpp:61:1:\
    \ error: expected \u2018}\u2019 at end of input\n   61 | }\n      | ^\n/tmp/tmpamnxncvf.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpamnxncvf.cpp:61:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   61 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    for (auto &c : paren_string) {\n        // Get rid of characters that are\
    \ not parentheses.\n        if ((c != '(') && (c != ')')) {\n            continue;\n\
    \        }\n        // Get the deepest paren_level for current character.\n  \
    \      long paren_level = paren_levels.size();\n        // Move to next index\
    \ for next iteration.\n        paren_levels.push_back(paren_level);\n        //\
    \ If we are seeing parentheses then skip to next character.\n        if (paren_level\
    \ == 0) continue;\n        // Pop current character from paren_levels vector and\
    \ decrement paren_level.\n        paren_levels.pop_back();\n        paren_level--;\n\
    \        // If paren_level is 0 then we are done processing paren_levels.\n  \
    \      if (paren_level == 0) break;\n    }\n    return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpwhrikm_b: /tmp/tmpwhrikm_b.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> return_val;\n    long level = 1;\n  \
    \  long curr = 0;\n    std::string token;\n    long curr_p = 0;\n    for (auto\
    \ c : paren_string) {\n        if (c == '(') {\n            if (curr_p != 0) {\n\
    \                return_val.emplace_back(level);\n                level++;\n \
    \           }\n            curr_p = 1;\n            token.clear();\n        }\
    \ else if (c == ')') {\n            curr_p = 0;\n            token.push_back(curr);\n\
    \            curr++;\n            level--;\n            if (level == 0)\n    \
    \            return_val.emplace_back(level);\n        } else {\n            token.push_back(c);\n\
    \        }\n    }\n    if (level != 0) {\n        return_val.emplace_back(level);\n\
    \    }\n    return return_val;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpxcz4zpzi: /tmp/tmpxcz4zpzi.cpp:40: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113168
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_depths(paren_string.size() + 1,\
    \ 0); // The +1 is for the last '('\n    for (auto i : paren_string) {\n     \
    \   if (i == '(') ++paren_depths[0];\n        if (i == ')') --paren_depths[paren_depths.size()\
    \ - 1];\n        if (paren_depths[paren_depths.size() - 1] == 0) return paren_depths;\n\
    \    }\n    throw std::invalid_argument(\"No parentheses\");\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpgk2931lf: /tmp/tmpgk2931lf.cpp:19: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> nest;\n    std::string temp_str = paren_string;\n\
    \    std::string temp_temp = \"(\";\n    int count = 0;\n    while (temp_str !=\
    \ \"\") {\n        temp_temp = temp_temp + temp_str;\n        if (temp_temp.find(\"\
    \ (\") != std::string::npos) {\n            temp_temp = temp_temp.replace(temp_temp.find(\"\
    \ (\"), 2, \"\");\n        }\n        if (temp_temp != \"\") {\n            nest.push_back(static_cast<long>(temp_temp.size())\
    \ / 2);\n            temp_temp = \"\";\n            count++;\n        }\n    \
    \    temp_str = temp_str.substr(1, temp_str.length() - 1);\n    }\n    return\
    \ nest;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpyz8ourpt: /tmp/tmpyz8ourpt.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113168
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Using stack to solve this problem (DFS without recursion)\
    \ \n    std::vector<long> result;\n    long cur_depth = 0;\n    long start_depth\
    \ = paren_string.size();\n    result.push_back(start_depth);\n    long index =\
    \ 0;\n    for(size_t i = 0; i < paren_string.size(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            cur_depth++;\n            if((cur_depth > result.back()))\
    \ {\n                result.push_back(cur_depth);\n            }\n        }\n\
    \        else if(paren_string[i] == ')') {\n            cur_depth--;\n       \
    \     if((cur_depth < result.back())) {\n                result.push_back(cur_depth);\n\
    \            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpq6ibv2cg: /tmp/tmpq6ibv2cg.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113167
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::string input_string = paren_string;\n  std::vector<long>\
    \ result;\n  std::string current_paren = \" \";\n  while (input_string != \"()\"\
    ) {\n    if (input_string.length() == 1) {\n      if (input_string[0] == '(')\
    \ {\n        current_paren = \" \";\n      } else if (input_string[0] == ')')\
    \ {\n        if (result.size() == 0) {\n          result.push_back(-1l);\n   \
    \     } else {\n          result.back() ++;\n        }\n        current_paren\
    \ = \" \";\n      }\n    } else {\n      if (input_string[0] == '(') {\n     \
    \   result.push_back(-1l);\n      } else if (input_string[0] == ')') {\n     \
    \   result.back() ++;\n      }\n      current_paren = input_string;\n      input_string\
    \ = input_string.substr(1);\n    }\n  }\n  return result;\n}\nint main() {\n \
    \   auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660113172
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    levels.push(0);\n    std::vector<std::string>\
    \ parens = extract_parens(paren_string);\n    for (auto& paren: parens) {\n  \
    \      for (long current_level: levels) {\n            if (paren == \")\") {\n\
    \                levels.push_back(current_level);\n                break;\n  \
    \          }\n            if (paren == \"(\") {\n                levels.push_back(current_level\
    \ + 1);\n                break;\n            }\n        }\n    }\n    return levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3njjb_px.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp3njjb_px.cpp:10:12: error: \u2018class std::vector<long int>\u2019\
    \ has no member named \u2018push\u2019\n   10 |     levels.push(0);\n      | \
    \           ^~~~\n/tmp/tmp3njjb_px.cpp:11:39: error: \u2018extract_parens\u2019\
    \ was not declared in this scope\n   11 |     std::vector<std::string> parens\
    \ = extract_parens(paren_string);\n      |                                   \
    \    ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660113167
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_count;\n    paren_count.push_back(0);\
    \ //Add 0 for the starting parenthesis.\n    long paren_level = 1;\n    for (auto\
    \ &c : paren_string) {\n        if (c == ')') {\n            paren_level--;\n\
    \        }\n        else if (c == '(') {\n            paren_level++;\n       \
    \ }\n        else {\n            long index = std::max(0, std::min(paren_level.back(),\
    \ paren_level.size() - 1));\n            paren_level[index] += 1;\n          \
    \  paren_count.push_back(paren_level[index]);\n        }\n    }\n    return paren_count;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl16k72uw.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpl16k72uw.cpp:20:59: error: request for member \u2018back\u2019 in \u2018\
    paren_level\u2019, which is of non-class type \u2018long int\u2019\n   20 |  \
    \           long index = std::max(0, std::min(paren_level.back(), paren_level.size()\
    \ - 1));\n      |                                                           ^~~~\n\
    /tmp/tmpl16k72uw.cpp:20:79: error: request for member \u2018size\u2019 in \u2018\
    paren_level\u2019, which is of non-class type \u2018long int\u2019\n   20 |  \
    \           long index = std::max(0, std::min(paren_level.back(), paren_level.size()\
    \ - 1));\n      |                                                            \
    \                   ^~~~\n/tmp/tmpl16k72uw.cpp:21:30: error: invalid types \u2018\
    long int[long int]\u2019 for array subscript\n   21 |             paren_level[index]\
    \ += 1;\n      |                              ^\n/tmp/tmpl16k72uw.cpp:22:52: error:\
    \ invalid types \u2018long int[long int]\u2019 for array subscript\n   22 |  \
    \           paren_count.push_back(paren_level[index]);\n      |              \
    \                                      ^\n"
  stdout: ''
  timestamp: 1660113166
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  // We use stack to keep track\
    \ of the deepest level of nesting\n  std::vector<std::vector<long> > stack_of_paren;\n\
    \  // For each parenthesis, push its level of nesting in the stack\n  for (auto\
    \ c : paren_string) {\n    if (c == '(') {\n      stack_of_paren.emplace_back();\n\
    \    } else if (c == ')') {\n      assert(stack_of_paren.size() > 0);\n      long\
    \ max_paren_level = 0;\n      long max_paren = 0;\n      for (auto v : stack_of_paren)\
    \ {\n        assert(v.size() > 0);\n        if (v.size() > max_paren_level) {\n\
    \          max_paren_level = v.size();\n          max_paren = v.back();\n    \
    \    }\n      }\n      stack_of_paren.pop_back();\n      if (max_paren_level >\
    \ result.size()) {\n        result.resize(max_paren_level);\n      }\n      result[max_paren_level\
    \ - 1] = max_paren;\n    }\n    stack_of_paren.back().push_back((int)(c == ' '));\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113167
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> nest_levels;\n    std::vector<long> paren_counts;\n\
    \    long paren_start_pos = 0;\n    long paren_end_pos = 0;\n    bool open_paren\
    \ = false;\n    bool close_paren = false;\n    for (long i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == ')') {\n            close_paren = true;\n\
    \            nest_levels.push_back((paren_end_pos - paren_start_pos) - 1);\n \
    \       }\n        else if (paren_string[i] == '(') {\n            open_paren\
    \ = true;\n            nest_levels.push_back(0);\n        }\n        else if (close_paren\
    \ && open_paren) {\n            paren_counts.push_back(1);\n            nest_levels.push_back(paren_counts.size()\
    \ - 1);\n            paren_end_pos = i;\n        }\n        else if (open_paren\
    \ && close_paren) {\n            paren_counts.push_back(1);\n            nest_levels.push_back(paren_counts.size()\
    \ - 1);\n            paren_start_pos = i;\n        }\n    }\n    return nest_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmps3c25ono: /tmp/tmps3c25ono.cpp:39: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113168
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Write your code here.\n    // Write your code in main\
    \ function and not in function calls.\n    // Please add your code in main function\
    \ and not in function calls.\n\n    // write your code here\n    std::vector<long>\
    \ v;\n    long max_level = 0;\n    for (auto c : paren_string) {\n        if (c\
    \ == '(') {\n            v.push_back(max_level);\n            max_level++;\n \
    \       } else if (c == ')') {\n            v.push_back(max_level);\n        \
    \    max_level--;\n        }\n    }\n    for (auto level : v)\n        max_level\
    \ = max(max_level, level);\n    v.push_back(max_level);\n    return v;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp639k0bgw.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp639k0bgw.cpp:26:21: error: \u2018max\u2019 was not declared in this\
    \ scope; did you mean \u2018std::max\u2019?\n   26 |         max_level = max(max_level,\
    \ level);\n      |                     ^~~\n      |                     std::max\n\
    In file included from /usr/include/c++/9/algorithm:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmp639k0bgw.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5: note: \u2018\
    std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp> __l, _Compare\
    \ __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660113169
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  // We create a map for the parenthesis.\n  // For every '('\
    \ and a ')', we increment the count by 1.\n  // For every ')' and a ')', we decrement\
    \ the count by 1.\n  // For the count of a ')', we output the deepest level of\
    \ nesting.\n  // For the count of a '(', we output the deepest level of nesting.\n\
    \  std::map<char, std::pair<std::pair<char, long>, long>> parenthesis;\n\n  //\
    \ We keep track of the deepest level of nesting of parentheses.\n  // We initialize\
    \ its value to zero.\n  // If every '(' has a matching ')', we set it to one.\n\
    \  // Otherwise, its value will be zero.\n  long deepest_level_of_nesting = -1;\n\
    \  for (char c : paren_string) {\n    if (c == '(') {\n      ++parenthesis[c].first;\n\
    \    } else if (c == ')') {\n      --parenthesis[c].first;\n      if (parenthesis[c].first\
    \ == 0) {\n        deepest_level_of_nesting = std::max(deepest_level_of_nesting,\
    \ parenthesis[c].second);\n      }\n    }\n  }\n  // We need to return vector\
    \ of deepest level of nestings.\n  std::vector<long> deepest_level_of_nestings;\n\
    \  deepest_level_of_nestings.push_back(deepest_level_of_nesting);\n  // For every\
    \ ')' we decrement the level of nesting.\n  for (char c : parenthesis) {\n   \
    \ if (c == ')') {\n      --deepest_level_of_nesting;\n    }\n  }\n  return deepest_level_of_nestings;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphabvet25.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmphabvet25.cpp:23:7: error: no match for \u2018operator++\u2019 (operand\
    \ type is \u2018std::pair<char, long int>\u2019)\n   23 |       ++parenthesis[c].first;\n\
    \      |       ^~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmphabvet25.cpp:25:7: error: no match\
    \ for \u2018operator--\u2019 (operand type is \u2018std::pair<char, long int>\u2019\
    )\n   25 |       --parenthesis[c].first;\n      |       ^~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmphabvet25.cpp:26:32: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::pair<char, long int>\u2019 and \u2018int\u2019)\n   26\
    \ |       if (parenthesis[c].first == 0) {\n      |                          \
    \      ^~ ~\n      |                                   |\n      |            \
    \                       int\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmphabvet25.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmphabvet25.cpp:26:35:\
    \ note:   \u2018std::pair<char, long int>\u2019 is not derived from \u2018const\
    \ std::__cxx11::sub_match<_BiIter>\u2019\n   26 |       if (parenthesis[c].first\
    \ == 0) {\n      |                                   ^\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmphabvet25.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator=="
  stdout: ''
  timestamp: 1660113168
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    if (paren_string.empty()) return std::vector<long>{};\n\
    \    std::vector<long> results;\n    auto open_pos = paren_string.find(\"(\");\n\
    \    auto close_pos = paren_string.find(\")\");\n    bool is_open = false;\n \
    \   long max_count = 0;\n    auto open = paren_string.begin(), open_size = paren_string.end()\
    \ - open;\n    auto close = paren_string.end() - 1, close_size = paren_string.end()\
    \ - close;\n    while(open != close) {\n        if (is_open && paren_string.find(\"\
    (\", open) == close_pos) {\n            results.push_back(0);\n            is_open\
    \ = false;\n            max_count = 0;\n        }\n        if (is_open && (paren_string[open_pos]\
    \ == '(')) {\n            is_open = true;\n            max_count++;\n        }\n\
    \        if (is_open && (paren_string[open_pos] == ')')) {\n            max_count--;\n\
    \        }\n        open++;\n        if (max_count == 0) {\n            results.push_back(std::distance(open,\
    \ close));\n        }\n    }\n    return results;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpc2dgj1l4.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpc2dgj1l4.cpp:15:5: error: inconsistent deduction for \u2018auto\u2019\
    : \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >\u2019\
    \ and then \u2018long int\u2019\n   15 |     auto open = paren_string.begin(),\
    \ open_size = paren_string.end() - open;\n      |     ^~~~\n/tmp/tmpc2dgj1l4.cpp:16:5:\
    \ error: inconsistent deduction for \u2018auto\u2019: \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 and then \u2018long int\u2019\n   16\
    \ |     auto close = paren_string.end() - 1, close_size = paren_string.end() -\
    \ close;\n      |     ^~~~\n/tmp/tmpc2dgj1l4.cpp:18:51: error: no matching function\
    \ for call to \u2018std::__cxx11::basic_string<char>::find(const char [2], __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >&)\u2019\n   18 |         if (is_open && paren_string.find(\"\
    (\", open) == close_pos) {\n      |                                          \
    \         ^\nIn file included from /usr/include/c++/9/string:55,\n           \
    \      from /usr/include/c++/9/bits/locale_classes.h:40,\n                 from\
    \ /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpc2dgj1l4.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2351:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find(const _CharT*, std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long "
  stdout: ''
  timestamp: 1660113169
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    if (paren_string.empty())\n        throw std::invalid_argument(\"\
    Input string is empty.\");\n    // Initialize result vector\n    std::vector<long>\
    \ result;\n    // Initialize left and right index\n    size_t left_index = 0;\n\
    \    size_t right_index = 0;\n    // Loop through string until we see a closing\
    \ parenthesis\n    while (left_index < paren_string.size()) {\n        // If we've\
    \ reached the left of the string, add one level of nesting by adding 1 to left_index\n\
    \        if (left_index == 0) {\n            result.push_back(1);\n          \
    \  left_index++;\n            // Keep track of the current level of nesting\n\
    \            size_t current_level = 1;\n            // Keep track of the next\
    \ level of nesting\n            size_t next_level = 1;\n            // Keep track\
    \ of whether we're currently inside a parenthesis group\n            bool in_group\
    \ = false;\n            // Iterate over string until we see an opening parenthesis\n\
    \            while (right_index < paren_string.size() && !in_group) {\n      \
    \          // If we've reached the right of the string, we're done adding nesting\n\
    \                if (right_index == paren_string.size()) {\n                 \
    \   result.push_back(current_level);\n                    break;\n           \
    \     }\n                // Otherwise, if the next character is a closing parenthesis,\
    \ we're done adding nesting\n                else if (paren_string[right_index]\
    \ == '(') {\n                    current_level++;\n                    next_level++;\n\
    \                    right_index++;\n                    in_group = true;\n  \
    \              }\n                // Otherwise, if we have a closing parenthesis,\
    \ we're in another parenthesis group\n                else if (paren_string[right_index]\
    \ == ')') {\n                    in_group = false;\n                    // If\
    \ we're at the end of our nested parenthesis, we'll add one more level of nesting\n\
    \                    if (current_level == next_level)\n                      \
    \  current_level++;\n                    result.push_back(current_level);\n  \
    \                  right_index++;\n                }\n                right_index++;\n\
    \            }\n            // If we're not done adding nesting when we reach\
    \ the end of the string, we're done adding nesting\n            if (right_index\
    \ == paren_string.size())\n                break;\n        }\n        // Otherwise,\
    \ if we've reached the right of the string, add one level of nesting by adding\
    \ 1 to left_index\n        else if (right_index == paren_string.size()) {\n  \
    \          result.push_back(1);\n            left_index++;\n            right_index++;\n\
    \            // Keep track of the current level of nesting\n            size_t\
    \ current_level = 1;\n            // Keep track of the next level of nesting\n\
    \            size_t next_level = 1;\n            // Keep track of whether we're\
    \ currently inside a parenthesis group\n            bool in_group = false;\n \
    \           // Iterate over string until we see an opening parenthesis\n     \
    \       while (right_index < paren_string.size() && !in_group) {\n           \
    \     // If we've reached the right of the string, we're done adding nesting\n\
    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoy8gedr_.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpoy8gedr_.cpp:73:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   73 | int main() {\n      |            ^\n/tmp/tmpoy8gedr_.cpp:78:1:\
    \ error: expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmpoy8gedr_.cpp:58:54:\
    \ note: to match this \u2018{\u2019\n   58 |         else if (right_index == paren_string.size())\
    \ {\n      |                                                      ^\n/tmp/tmpoy8gedr_.cpp:78:1:\
    \ error: expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmpoy8gedr_.cpp:17:46:\
    \ note: to match this \u2018{\u2019\n   17 |     while (left_index < paren_string.size())\
    \ {\n      |                                              ^\n/tmp/tmpoy8gedr_.cpp:78:1:\
    \ error: expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmpoy8gedr_.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpoy8gedr_.cpp:78:1: warning: control reaches end of non-void\
    \ function [-Wreturn-type]\n   78 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113169
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> ans;\n    std::string temp_ans;\n   \
    \ for(auto &it: paren_string) {\n        auto pos = it;\n        while(pos !=\
    \ paren_string.end() && !((pos == paren_string.begin() ? it == paren_string.begin()\
    \ : pos == paren_string.end() ? it == paren_string.end() : it == paren_string.begin())))\
    \ {\n            pos = pos + 1;\n        }\n        if(pos == paren_string.begin())\n\
    \            ans.push_back(1);\n        else if(pos == paren_string.end())\n \
    \           ans.push_back(ans.size());\n        else if(it == paren_string.end()\
    \ || it == paren_string.begin())\n            ans.push_back(ans.size());\n   \
    \     else\n            ans.push_back(ans.size() + 1);\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpoul5m7ow.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpoul5m7ow.cpp:13:19: error: no match for \u2018operator!=\u2019 (operand\
    \ types are \u2018char\u2019 and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   13 |         while(pos != paren_string.end() && !((pos == paren_string.begin()\
    \ ? it == paren_string.begin() : pos == paren_string.end() ? it == paren_string.end()\
    \ : it == paren_string.begin()))) {\n      |               ~~~ ^~ ~~~~~~~~~~~~~~~~~~\n\
    \      |               |                      |\n      |               char  \
    \                 std::__cxx11::basic_string<char>::iterator {aka __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >}\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpoul5m7ow.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:897:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator!=(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  897 |\
    \     operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:897:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpoul5m7ow.cpp:13:39: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018char\u2019\n   13 |         while(pos != paren_string.end() && !((pos\
    \ == paren_string.begin() ? it == paren_string.begin() : pos == paren_string.end()\
    \ ? it == paren_string.end() : it == paren_string.begin()))) {\n      |      \
    \                                 ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/inc"
  stdout: ''
  timestamp: 1660113169
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_level;\n    std::vector<long> paren_level_size;\n\
    \    // If string is empty or only contains spaces, return empty paren_level.\n\
    \    if (paren_string.empty() || paren_string.find_first_not_of(\" \") != std::string::npos)\
    \ {\n        return paren_level;\n    }\n\n    // Initialize paren_level with\
    \ deepest level of nesting.\n    paren_level.push_back(0);\n    paren_level_size.push_back(0);\n\
    \    for (auto &ch : paren_string) {\n        if (ch == '(') {\n            paren_level.push_back(paren_level.back()\
    \ + 1);\n            paren_level_size.push_back(paren_level_size.back() + 1);\n\
    \        } else if (ch == ')') {\n            paren_level.push_back(paren_level.back()\
    \ - 1);\n            paren_level_size.push_back(paren_level_size.back() - 1);\n\
    \        } else if (ch == ' ') {\n            // If we reach a space, store paren_level\
    \ as last element of paren_level_size array.\n            paren_level.back() =\
    \ std::max(paren_level.back(), paren_level_size.back());\n            paren_level_size.back()\
    \ = 1;\n        } else {\n            assert(0);\n        }\n    }\n    return\
    \ paren_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n \
    \   assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpiw38zfga: /tmp/tmpiw38zfga.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113169
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Your code goes here\n    std::vector<long> result;\n\
    \    std::vector<long> paren_stack;\n    long level = 0;\n    bool flag = false;\n\
    \    for (size_t i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i]\
    \ != '(') continue;\n        if (flag) {\n            paren_stack.push_back(level);\n\
    \            level = 0;\n        }\n        else {\n            flag = true;\n\
    \        }\n    }\n    if (flag) {\n        paren_stack.push_back(level);\n  \
    \  }\n    for (size_t i = 0; i < paren_stack.size(); ++i) {\n        for (size_t\
    \ j = 0; j < paren_stack.size() - i; ++j) {\n            if (paren_stack[j] >=\
    \ paren_stack[j + 1]) {\n                result.push_back(paren_stack[j + 1] +\
    \ 1);\n            }\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmphc53f93o: /tmp/tmphc53f93o.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Convert the input string into a vector of tokens.\n\
    \    std::vector<std::vector<std::string>> paren_tokens;\n    std::vector<std::string>\
    \ tokens;\n    for (auto &x : paren_string) {\n        if (x != ' ' && x != '('\
    \ && x != ')') {\n            tokens.push_back(x);\n        } else {\n       \
    \     paren_tokens.push_back(tokens);\n            tokens.clear();\n        }\n\
    \    }\n    paren_tokens.push_back(tokens);\n\n    // For each set of parentheses\
    \ separated by space, return the deepest level of nesting.\n    // E.g. for (((()))\
    \ we return 1 as the deepest nesting level.\n    std::vector<long> max_levels;\n\
    \    for (auto &x : paren_tokens) {\n        std::string token;\n        for (auto\
    \ &y : x) {\n            token += y + \" \";\n        }\n        long max_level\
    \ = 0;\n        for (auto &y : x) {\n            if (y == \"(\" || y == \"(\"\
    ) {\n                max_level++;\n            } else if (y == \")\" || y == \"\
    )\") {\n                max_level--;\n            }\n        }\n        max_levels.push_back((max_level\
    \ == 0) ? 0 : max_level);\n    }\n    return max_levels;\n}\nint main() {\n  \
    \  auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjy6jbmrk.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpjy6jbmrk.cpp:14:31: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(char&)\u2019\n   14\
    \ |             tokens.push_back(x);\n      |                               ^\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjy6jbmrk.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660113169
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  // Get number of spaces separating the groups of parenthesis\
    \ present in the string.\n  int num_of_spaces = paren_string.find_first_of(' ');\n\
    \  // Create a vector of long type to store the output\n  std::vector<long> levels(num_of_spaces);\n\
    \  int j = 0;\n  int i = 0;\n  while (i < paren_string.size()) {\n    // If '('\
    \ appears in the string then we get the index of the opening brace of the group.\n\
    \    // And store the number of levels of nesting in the vector\n    if (paren_string.at(i)\
    \ == '(') {\n      levels[j] = i;\n      ++j;\n    }\n    // If ')' appears in\
    \ the string then we get the index of the closing brace of the group.\n    //\
    \ And store the number of levels of nesting in the vector\n    if (paren_string.at(i)\
    \ == ')') {\n      if (j == num_of_spaces) {\n        std::cerr << \"Error, string\
    \ does not contain balanced parenthesis.\\n\";\n        assert(false);\n     \
    \ }\n      levels[j] = i;\n      --j;\n    }\n    ++i;\n  }\n  return levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpi4b0p8c7: /tmp/tmpi4b0p8c7.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels(paren_string.size());\n    std::vector<long>::iterator\
    \ it = levels.begin();\n    std::vector<std::string> parens = Split(paren_string,\
    \ \" \");\n    long index = 0;\n    while(!parens.empty()) {\n        if(parens[index].size()\
    \ > 0) {\n            ++index;\n        }\n        else {\n            assert(parens.size()\
    \ >= 1);\n            std::vector<long> levels_rest = Split(parens.back(), \"\
    )\");\n            for(long i = 0; i < levels_rest.size(); ++i) {\n          \
    \      assert(i < parens.size());\n                std::vector<long> levels_i\
    \ = Split(parens[i], \")\");\n                assert(!levels_i.empty());\n   \
    \             if(levels_i.back() != \"(\") {\n                    if(levels_i.back()\
    \ == \"(\") {\n                        --i;\n                    }\n         \
    \       }\n                assert(levels_i.back() == \"(\");\n               \
    \ long levels_i_index = levels_i.size() - 1;\n                long levels_rest_index\
    \ = levels_rest.size() - 1;\n                long max_level_i = (levels_i[levels_i_index]\
    \ == \"\") ? 0 : levels_i[levels_i_index];\n                long max_level_j =\
    \ (levels_rest[levels_rest_index] == \"\") ? 0 : levels_rest[levels_rest_index];\n\
    \                long level_i = max_level_i;\n                long level_j = max_level_j;\n\
    \                if(level_i < level_j) { level_i = level_j; }\n              \
    \  if(level_i > levels[it]) { levels[it] = level_i; }\n                ++it;\n\
    \            }\n            parens.pop_back();\n        }\n    }\n    std::vector<long>\
    \ result;\n    for(std::vector<long>::iterator it = levels.begin(); it != levels.end();\
    \ ++it) { result.push_back(*it); }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpjom4lv4j.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpjom4lv4j.cpp:11:39: error: \u2018Split\u2019 was not declared in this\
    \ scope\n   11 |     std::vector<std::string> parens = Split(paren_string, \"\
    \ \");\n      |                                       ^~~~~\n/tmp/tmpjom4lv4j.cpp:24:39:\
    \ error: ISO C++ forbids comparison between pointer and integer [-fpermissive]\n\
    \   24 |                 if(levels_i.back() != \"(\") {\n      |             \
    \                          ^~~\n/tmp/tmpjom4lv4j.cpp:25:43: error: ISO C++ forbids\
    \ comparison between pointer and integer [-fpermissive]\n   25 |             \
    \        if(levels_i.back() == \"(\") {\n      |                             \
    \              ^~~\nIn file included from /usr/include/c++/9/cassert:44,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:33,\n  \
    \               from /tmp/tmpjom4lv4j.cpp:2:\n/tmp/tmpjom4lv4j.cpp:29:43: error:\
    \ ISO C++ forbids comparison between pointer and integer [-fpermissive]\n   29\
    \ |                 assert(levels_i.back() == \"(\");\n      |               \
    \                            ^~~\n/tmp/tmpjom4lv4j.cpp:32:65: error: ISO C++ forbids\
    \ comparison between pointer and integer [-fpermissive]\n   32 |             \
    \    long max_level_i = (levels_i[levels_i_index] == \"\") ? 0 : levels_i[levels_i_index];\n\
    \      |                                                                 ^~\n\
    /tmp/tmpjom4lv4j.cpp:33:71: error: ISO C++ forbids comparison between pointer\
    \ and integer [-fpermissive]\n   33 |                 long max_level_j = (levels_rest[levels_rest_index]\
    \ == \"\") ? 0 : levels_rest[levels_rest_index];\n      |                    \
    \                                                   ^~\n/tmp/tmpjom4lv4j.cpp:37:36:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::vector<long\
    \ int>\u2019 and \u2018std::vector<long int>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019})\n   37 |                 if(level_i >\
    \ levels[it]) { levels[it] = level_i; }\n      |                             "
  stdout: ''
  timestamp: 1660113169
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> ret;\n    std::string temp = \"\";\n\
    \    for (size_t i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(' && paren_string[i + 1] != '(') {\n            if (temp.size() != 0) {\n\
    \                ret.push_back(stoi(temp));\n            }\n            temp =\
    \ \"\";\n        } else if (paren_string[i] == ')' && paren_string[i + 1] != '(')\
    \ {\n            long size = stoi(temp);\n            if (size > ret.size()) ret.push_back(size);\n\
    \            temp = \"\";\n        } else {\n            temp += paren_string[i];\n\
    \        }\n    }\n    if (temp.size() != 0) {\n        ret.push_back(stoi(temp));\n\
    \    }\n    return ret;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113170
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> nested_parens;\n    if (paren_string\
    \ == \"\") {\n        return nested_parens;\n    }\n    std::string::size_type\
    \ pos = 0;\n    std::string::size_type last_pos = paren_string.find_first_of(\"\
    )\", pos);\n    std::string::size_type paren_level = 0;\n    std::string curr_name\
    \ = \"\";\n    while (std::string::npos != last_pos) {\n        pos = last_pos;\n\
    \        last_pos = paren_string.find_first_of(\")\", pos);\n        std::string::size_type\
    \ cur_len = last_pos - pos;\n        if (paren_level > 0 && paren_level == cur_len)\
    \ {\n            nested_parens.push_back(paren_level);\n        }\n        paren_level++;\n\
    \        std::string curr = paren_string.substr(pos, cur_len);\n        // If\
    \ the first char of curr is '(', then it is a group.\n        if (curr[0] == '(')\
    \ {\n            std::string curr_level = curr;\n            while (std::find(curr_level.begin(),\
    \ curr_level.end(), ' ') != curr_level.end()) {\n                curr_level =\
    \ curr_level.substr(0, curr_level.find(' '));\n            }\n            if (curr_level.empty())\
    \ {\n                nested_parens.push_back(1);\n            } else {\n     \
    \           nested_parens.push_back(static_cast<long>(curr_level.size()) - 1);\n\
    \            }\n        } else {\n            curr_name = curr_name.length() >\
    \ 0 ? curr_name + \"(\" + curr : curr;\n        }\n    }\n    nested_parens.push_back(nested_parens.size());\n\
    \    return nested_parens;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660113174
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_level;\n    std::string curr_level;\n\
    \    for (size_t i = 0; i < paren_string.length(); ++i) {\n        if (paren_string[i]\
    \ == ')') {\n            if (curr_level.empty())\n                curr_level =\
    \ paren_string[i];\n            else\n                curr_level += paren_string[i];\n\
    \        }\n        else if (curr_level.empty()) {\n            curr_level = paren_string[i];\n\
    \        }\n        else if (curr_level == paren_string[i]) {\n            curr_level\
    \ += paren_string[i];\n        }\n        else {\n            max_level.push_back(stoi(curr_level));\n\
    \            curr_level.clear();\n        }\n    }\n    max_level.push_back(stoi(curr_level));\n\
    \    return max_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjyklytho.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpjyklytho.cpp:21:29: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019})\n   21 |         else if (curr_level == paren_string[i])\
    \ {\nIn file included from /usr/include/c++/9/regex:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n                 from\
    \ /tmp/tmpjyklytho.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5: note: candidate:\
    \ \u2018template<class _BiIter> bool std::__cxx11::operator==(const std::__cxx11::sub_match<_BiIter>&,\
    \ const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1026 |     operator==(const\
    \ sub_match<_BiIter>& __lhs, const sub_match<_BiIter>& __rhs)\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1026:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpjyklytho.cpp:21:46: note:   \u2018std::string\u2019 {aka \u2018\
    std::__cxx11::basic_string<char>\u2019} is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \n   21 |         else if (curr_level == paren_string[i]) {\n      |         \
    \                                     ^\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpjyklytho.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpjyklytho.cpp:21:46: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, "
  stdout: ''
  timestamp: 1660113169
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    if (paren_string.length() == 0) {\n        return {0};\n\
    \    }\n\n    std::vector<long> result = {0};\n    auto it = paren_string.begin();\n\
    \n    // Iterate through all of the parentheses until we hit the end of the string.\n\
    \    while (it != paren_string.end() && *it != '(') {\n        ++it;\n    }\n\n\
    \    // We have hit the end of the string. Return the result.\n    if (it == paren_string.end())\
    \ {\n        return result;\n    }\n\n    // Iterate through the string and accumulate\
    \ the result.\n    ++it;\n    for (; it != paren_string.end(); ++it) {\n     \
    \   // If the current char is '(' or ')', then accumulate the level of nesting\
    \ for the current parenthesis.\n        if (*it == '(') {\n            // If the\
    \ last element of the vector has been set, then we need to add the length of the\
    \ last element to the current level of nesting.\n            if (result.back().size()\
    \ == 0) {\n                result.back().push_back(1);\n            }\n      \
    \      else {\n                result.back().push_back(result[result.size() -\
    \ 1].size() + 1);\n            }\n        }\n        else if (*it == ')') {\n\
    \            // If the last element of the vector has been set, then we need to\
    \ subtract the length of the last element from the current level of nesting.\n\
    \            if (result.back().size() == 0) {\n                result.back().push_back(-1);\n\
    \            }\n            else {\n                result[result.size() - 1].erase(result.back().size()\
    \ - 1);\n            }\n        }\n        // If the current char is not a ')'\
    \ or '(', then we need to push a new level of nesting for the current parenthesis.\n\
    \        else {\n            result.back().push_back(1);\n        }\n    }\n\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo5jjc19q.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpo5jjc19q.cpp:32:31: error: request for member \u2018size\u2019 in \u2018\
    result.std::vector<long int>::back()\u2019, which is of non-class type \u2018\
    __gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019}\n   32 |             if (result.back().size() ==\
    \ 0) {\n      |                               ^~~~\n/tmp/tmpo5jjc19q.cpp:33:31:\
    \ error: request for member \u2018push_back\u2019 in \u2018result.std::vector<long\
    \ int>::back()\u2019, which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019}\n   33 |      \
    \           result.back().push_back(1);\n      |                             \
    \  ^~~~~~~~~\n/tmp/tmpo5jjc19q.cpp:36:31: error: request for member \u2018push_back\u2019\
    \ in \u2018result.std::vector<long int>::back()\u2019, which is of non-class type\
    \ \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type\u2019\
    \ {aka \u2018long int\u2019}\n   36 |                 result.back().push_back(result[result.size()\
    \ - 1].size() + 1);\n      |                               ^~~~~~~~~\n/tmp/tmpo5jjc19q.cpp:36:67:\
    \ error: request for member \u2018size\u2019 in \u2018result.std::vector<long\
    \ int>::operator[]((result.std::vector<long int>::size() - 1))\u2019, which is\
    \ of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>,\
    \ long int>::value_type\u2019 {aka \u2018long int\u2019}\n   36 |            \
    \     result.back().push_back(result[result.size() - 1].size() + 1);\n      |\
    \                                                                   ^~~~\n/tmp/tmpo5jjc19q.cpp:41:31:\
    \ error: request for member \u2018size\u2019 in \u2018result.std::vector<long\
    \ int>::back()\u2019, which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019}\n   41 |      \
    \       if (result.back().size() == 0) {\n      |                            \
    \   ^~~~\n/tmp/tmpo5jjc19q.cpp:42:31: error: request for member \u2018push_back\u2019\
    \ in \u2018result.std::vector<long i"
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n\tstd::stack<long> paren_depth_stack;\n\tparen_depth_stack.push(0);\n\
    \tstd::vector<long> depth;\n\tdepth.push_back(0);\n\tfor (char ch : paren_string)\
    \ {\n\t\tif (ch == '(' || ch == '[' || ch == '{') {\n\t\t\tdepth.push_back(paren_depth_stack.top());\n\
    \t\t\tparen_depth_stack.push(0);\n\t\t}\n\t\telse if (ch == '}' || ch == ']' ||\
    \ ch == ')') {\n\t\t\tif (paren_depth_stack.top() > 0) {\n\t\t\t\tdepth.push_back(paren_depth_stack.top());\n\
    \t\t\t\tparen_depth_stack.pop();\n\t\t\t} else {\n\t\t\t\tdepth.push_back(0);\n\
    \t\t\t}\n\t\t}\n\t\telse if (ch == ' ') {\n\t\t\tif (paren_depth_stack.top() >\
    \ 0) {\n\t\t\t\tdepth.push_back(paren_depth_stack.top());\n\t\t\t\tparen_depth_stack.pop();\n\
    \t\t\t}\n\t\t}\n\t\telse if (ch == ',') {\n\t\t\tif (depth.back() > 0) {\n\t\t\
    \t\tdepth.pop_back();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdepth.back()++;\n\t\t\
    }\n\t}\n\treturn depth;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpfro2k_w5: /tmp/tmpfro2k_w5.cpp:45: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    std::string current_level;\n\
    \    std::string parens_count = \"\";\n    int i = 1;\n    while (true) {\n  \
    \      current_level = parens_count;\n        if (current_level == \"\") {\n \
    \           current_level = \"1\";\n        }\n        parens_count = paren_string.substr(0,\
    \ i).substr(1, i - 1);\n        if (parens_count == \"\") {\n            levels.push_back(std::stoi(current_level));\n\
    \            return levels;\n        }\n        if (parens_count == \"0\") {\n\
    \            levels.push_back(std::stoi(current_level));\n            return levels;\n\
    \        }\n        if (parens_count == \"1\") {\n            levels.push_back(std::stoi(current_level)\
    \ + 1);\n            return levels;\n        }\n        ++i;\n    }\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpt3y9bijh: /tmp/tmpt3y9bijh.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> ret;\n    size_t open = 0;\n    size_t\
    \ close = 0;\n    size_t level = 0;\n    for (auto i = paren_string.rbegin();\
    \ i != paren_string.rend(); ++i) {\n        // Skip the opening parens.\n    \
    \    if (*i == '(') {\n            ++open;\n            ++level;\n        }\n\
    \        else if (*i == ')') {\n            ++close;\n            if (close ==\
    \ level) {\n                ret.emplace_back(level);\n                ++level;\n\
    \            }\n        }\n    }\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpbaqljf9z: /tmp/tmpbaqljf9z.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  std::vector<long> temp;\n\
    \  // Create a vector of paren_levels based on number of opened parentheses.\n\
    \  paren_levels.reserve(paren_string.size());\n  for (int i = 0; i < paren_string.size();\
    \ ++i) {\n    if (paren_string[i] == '(') {\n      paren_levels.push_back(temp.size());\n\
    \    }\n    temp.push_back(paren_string[i]);\n  }\n  // Perform depth-first search\
    \ to find the deepest nested level.\n  while (!temp.empty()) {\n    int j = temp.size()-1;\n\
    \    while (j >= 0) {\n      // For each of the levels of parentheses just before\
    \ current level,\n      // add (temp[j]) to paren_levels.\n      assert(paren_levels[j]\
    \ >= temp[j]);\n      paren_levels[j] += (temp[j]);\n      // Swap the elements\
    \ at the right position.\n      std::swap(temp[j], temp[j-1]);\n      // Pop all\
    \ the elements just before the current level.\n      j -= (temp[j]);\n    }\n\
    \    temp.clear();\n  }\n  return paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp4o1u5aai: /tmp/tmp4o1u5aai.cpp:25: std::vector<long int> parse_nested_parens(std::string):
    Assertion `paren_levels[j] >= temp[j]'' failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> parens;\n    parens.reserve(paren_string.size());\n\
    \    std::string parens_str = paren_string;\n    std::size_t paren_level = 1;\n\
    \    bool has_open_paren = false;\n    bool in_parens = false;\n    while (!parens_str.empty())\
    \ {\n        bool is_open = parens_str.front() == '(';\n        bool is_close_paren\
    \ = parens_str.back() == ')';\n        if (is_open) {\n            if (in_parens)\
    \ {\n                paren_level++;\n            } else {\n                paren_level\
    \ = 1;\n            }\n            has_open_paren = true;\n        }\n       \
    \ if (is_close_paren) {\n            if (in_parens) {\n                paren_level--;\n\
    \            } else {\n                throw std::runtime_error(\"Mismatched parenthesis.\"\
    );\n            }\n            has_open_paren = false;\n        }\n        if\
    \ (has_open_paren) {\n            parens.push_back(paren_level);\n        }\n\
    \        if (parens_str.empty()) {\n            throw std::runtime_error(\"Mismatched\
    \ parenthesis.\");\n        }\n        if (is_open) {\n            parens_str\
    \ = parens_str.substr(1);\n        } else {\n            parens_str = parens_str.substr(0,\
    \ parens_str.size()-1);\n        }\n    }\n    return parens;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::runtime_error'\n \
    \ what():  Mismatched parenthesis.\n"
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    size_t pos = 0;\n    size_t\
    \ pos_left = 0;\n    while (true) {\n        pos = paren_string.find_first_not_of(\"\
    (()\", pos);\n        if (pos == std::string::npos) {\n            break;\n  \
    \      }\n        pos_left = pos;\n        pos = paren_string.find_first_of(\"\
    ()\", pos);\n        if (pos == std::string::npos) {\n            break;\n   \
    \     }\n        levels.push_back(long(pos_left - pos));\n        pos = paren_string.find_first_of(\"\
    ()\", pos);\n    }\n    return levels;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpywf5lsj2: /tmp/tmpywf5lsj2.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_level;\n    std::string::size_type\
    \ start = 0;\n    for (std::string::size_type i = 0; (i < paren_string.length())\
    \ && (paren_string[i] != ' ');i++) {\n        long current_level = -1;\n     \
    \   for (std::string::size_type j = 0; (j < paren_string.length()) && (paren_string[j]\
    \ == paren_string[i]); j++) {\n            current_level++;\n        }\n     \
    \   // If we are at end of string\n        if (j == paren_string.length()) {\n\
    \            paren_level.push_back(current_level);\n            break;\n     \
    \   }\n        // If the previous character was not a space\n        if (j !=\
    \ start && (paren_string[start] == paren_string[j])) {\n            // if the\
    \ level of the previous charcter was greater than the current level\n        \
    \    if (current_level < paren_level[j - 1]) {\n                // update previous\
    \ character level\n                paren_level[j] = current_level;\n         \
    \       // Update the position of previous character in string\n             \
    \   start = j;\n            } else {\n                // If level is same, then\
    \ it means that we are entering a new level\n                paren_level.push_back(current_level);\n\
    \                break;\n            }\n        }\n        // If the previous\
    \ character was a space\n        if (j != start && (paren_string[start] != paren_string[j]))\
    \ {\n            // If the level of the previous character is greater than current\
    \ level\n            if (current_level < paren_level[j - 1]) {\n             \
    \   paren_level.push_back(current_level);\n                // Update previous\
    \ character level\n                start = j;\n            }\n            // If\
    \ level is same, then it means that we are entering a new level\n            paren_level.push_back(current_level);\n\
    \            break;\n        }\n    }\n    return paren_level;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphnl5_80y.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmphnl5_80y.cpp:17:13: error: \u2018j\u2019 was not declared in this scope\n\
    \   17 |         if (j == paren_string.length()) {\n      |             ^\n/tmp/tmphnl5_80y.cpp:22:13:\
    \ error: \u2018j\u2019 was not declared in this scope\n   22 |         if (j !=\
    \ start && (paren_string[start] == paren_string[j])) {\n      |             ^\n\
    /tmp/tmphnl5_80y.cpp:36:13: error: \u2018j\u2019 was not declared in this scope\n\
    \   36 |         if (j != start && (paren_string[start] != paren_string[j])) {\n\
    \      |             ^\n"
  stdout: ''
  timestamp: 1660113170
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  std::string current_paren_level\
    \ = \"\";\n  std::string current_paren_level_count = 0;\n  for (auto it = paren_string.begin();\
    \ it != paren_string.end(); it++) {\n    // Current paren level\n    if (*it ==\
    \ ' ') {\n      current_paren_level += *it;\n    } else {\n      // Current paren\
    \ level's count\n      current_paren_level_count += *it;\n      // If current\
    \ level's count is greather than current paren level's count\n      if (current_paren_level_count\
    \ > current_paren_level.size()) {\n        // Increase current level's count by\
    \ 1\n        current_paren_level_count++;\n        // If current level count's\
    \ length is greater than 1\n        if (current_paren_level_count > 1) {\n   \
    \       // Increase current level's count by 1\n          current_paren_level_count++;\n\
    \          // Add 1 to result vector if current level is less than current level's\
    \ count - 1\n          if (current_paren_level_count < current_paren_level.size())\
    \ {\n            result.push_back(current_paren_level_count);\n          }\n \
    \       }\n      }\n      // Reset current level's count for next level\n    \
    \  current_paren_level_count = 0;\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6_2bq08u.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp6_2bq08u.cpp:20:37: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019})\n   20 |       if (current_paren_level_count > current_paren_level.size())\
    \ {\n      |           ~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \      |           |                                                   |\n   \
    \   |           std::string {aka std::__cxx11::basic_string<char>}  std::__cxx11::basic_string<char>::size_type\
    \ {aka long unsigned int}\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6_2bq08u.cpp:2:\n/usr/include/c++/9/bits/regex.h:1081:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1081 |     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1081:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp6_2bq08u.cpp:20:64:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   20\
    \ |       if (current_paren_level_count > current_paren_level.size()) {\n    \
    \  |                                                                ^\nIn file\
    \ included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp6_2bq08u.cpp:2:\n/usr/include/c++/9/bits/regex.h:1136:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1136 |     operator>(const\
    \ __sub_ma"
  stdout: ''
  timestamp: 1660113170
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> nest_levels;\n  std::string parentheses;\n\
    \  \n  // For each group of parentheses, append one more level of nesting if it\
    \ is opened.\n  for (char paren = paren_string[0]; ; paren = paren_string[++i])\
    \ {\n    if (paren == '(') {\n      parentheses += paren;\n      nest_levels.push_back(nest_levels.size());\n\
    \    } else if (paren == ')') {\n      auto n = nest_levels.size() - 1;\n    \
    \  if (n >= 0) {\n        nest_levels[n]++;\n      }\n    } else {\n      parentheses\
    \ += paren;\n    }\n  }\n  \n  return nest_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpvix8lloy.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpvix8lloy.cpp:13:63: error: \u2018i\u2019 was not declared in this scope\n\
    \   13 |   for (char paren = paren_string[0]; ; paren = paren_string[++i]) {\n\
    \      |                                                               ^\n"
  stdout: ''
  timestamp: 1660113170
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    auto n = paren_string.find(\"((\");\n    auto e = paren_string.find(\"\
    )\");\n    std::vector<long> retval;\n    long max_level = std::numeric_limits<long>::max();\n\
    \    retval.push_back(0);\n    long level = 0;\n    while (n != std::string::npos\
    \ && e != std::string::npos) {\n        auto cur_level = std::min(max_level, level);\n\
    \        retval.push_back(cur_level);\n        max_level = std::max(max_level,\
    \ cur_level + 1);\n        n = paren_string.find(\"((\", e-1);\n        e = paren_string.find(\"\
    )\", e);\n        level++;\n    }\n    if (n == std::string::npos && e != std::string::npos)\
    \ {\n        retval.push_back(max_level);\n    }\n    return retval;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660113175
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  std::vector<std::string> paren_list(paren_string.begin(),\
    \ paren_string.end());\n  paren_list.pop_back(); // Remove the final \")\"\n\n\
    \  for (const std::string& cur : paren_list)\n  {\n    bool found_match = false;\n\
    \    long current_level = 0;\n    std::string current_group = \"\";\n\n    for\
    \ (auto it : cur)\n    {\n      if (it == '(')\n      {\n        current_level++;\n\
    \      }\n      if (it == ')')\n      {\n        current_level--;\n      }\n \
    \     if (current_level == 0)\n      {\n        current_group += it;\n       \
    \ found_match = true;\n      }\n    }\n    if (found_match)\n    {\n      result.emplace_back(std::stoul(current_group));\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/vector:66,\n                 from\
    \ /usr/include/c++/9/functional:62,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpzb2krwyq.cpp:2:\n/usr/include/c++/9/bits/stl_uninitialized.h: In instantiation\
    \ of \u2018_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator,\
    \ _ForwardIterator) [with _InputIterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; _ForwardIterator = std::__cxx11::basic_string<char>*]\u2019\
    :\n/usr/include/c++/9/bits/stl_uninitialized.h:307:37:   required from \u2018\
    _ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator,\
    \ std::allocator<_Tp>&) [with _InputIterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; _ForwardIterator = std::__cxx11::basic_string<char>*;\
    \ _Tp = std::__cxx11::basic_string<char>]\u2019\n/usr/include/c++/9/bits/stl_vector.h:1582:33:\
    \   required from \u2018void std::vector<_Tp, _Alloc>::_M_range_initialize(_ForwardIterator,\
    \ _ForwardIterator, std::forward_iterator_tag) [with _ForwardIterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >]\u2019\n/usr/include/c++/9/bits/stl_vector.h:654:4:\
    \   required from \u2018std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator,\
    \ const allocator_type&) [with _InputIterator = __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >; <template-parameter-2-2> = void; _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::allocator_type = std::allocator<std::__cxx11::basic_string<char> >]\u2019\
    \n/tmp/tmpzb2krwyq.cpp:10:79:   required from here\n/usr/include/c++/9/bits/stl_uninitialized.h:127:72:\
    \ error: static assertion failed: result type"
  stdout: ''
  timestamp: 1660113169
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  long max_depth = 0;\n  std::stack<long>\
    \ stack_of_parens;\n  std::string cur_paren = \"\";\n  for (auto cur_char : paren_string)\
    \ {\n    if (cur_char == '(') {\n      stack_of_parens.push(cur_paren.size());\n\
    \      cur_paren = \"\";\n    }\n    if (cur_char == ')') {\n      long paren_len\
    \ = stack_of_parens.top();\n      if (max_depth < paren_len) {\n        max_depth\
    \ = paren_len;\n      }\n      result.push_back(max_depth);\n      stack_of_parens.pop();\n\
    \    }\n    cur_paren += cur_char;\n  }\n  if (stack_of_parens.empty()) {\n  \
    \  max_depth = 0;\n  }\n  result.push_back(max_depth);\n  return result;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp39b7afhb: /tmp/tmp39b7afhb.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> ans;\n  stack<int> open_braces;\n  std::stack<long>\
    \ current_nesting;\n  long current_level = 0;\n  for (char c : paren_string) {\n\
    \    if (c == '(') {\n      // If we are not at the lowest level, then we decrease\
    \ the level of nesting by 1.\n      // So if we have (()) which is at level 1\
    \ and we are still at level 0, then we decrease the level of nesting by 2.\n \
    \     // That is because we do not want to get into (())) because we already have\
    \ (()) as a result.\n      current_nesting.push(current_level);\n    } else if\
    \ (c == ')' && current_nesting.top() > 0) {\n      // If we are currently not\
    \ at the lowest level of nesting, then we decrease the level of nesting by 1 which\
    \ brings us to our lowest level.\n      current_nesting.pop();\n    } else {\n\
    \      // If we are not at the lowest level of nesting, then we increase the level\
    \ of nesting by 1 which brings us to our highest level.\n      current_nesting.push(current_level\
    \ + 1);\n    }\n    current_level++;\n    // We append the level of nesting to\
    \ our vector result.\n    ans.push_back(current_nesting.top());\n  }\n  return\
    \ ans;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr4jtvopw.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpr4jtvopw.cpp:10:3: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   10 |   stack<int> open_braces;\n\
    \      |   ^~~~~\n      |   std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpr4jtvopw.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpr4jtvopw.cpp:10:9: error: expected primary-expression\
    \ before \u2018int\u2019\n   10 |   stack<int> open_braces;\n      |         ^~~\n"
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    int paren_count = 0;\n    std::vector<long> nested_paren_counts;\n\
    \    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == ')') {\n            nested_paren_counts.push_back(paren_count);\n       \
    \     paren_count = 0;\n        } else if (paren_string[i] == ')' && paren_count\
    \ > 0) {\n            paren_count--;\n        } else if (paren_string[i] == '(')\
    \ {\n            paren_count++;\n        }\n    }\n    nested_paren_counts.push_back(paren_count);\n\
    \    return nested_paren_counts;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp_o9jsn3m: /tmp/tmp_o9jsn3m.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_level_of_nesting;\n    std::string\
    \ parentheses;\n    long max_level = 0;\n    std::string current_string = \"\"\
    ;\n    std::vector<std::string> current_parentheses;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            current_string.push_back(c);\n     \
    \       current_parentheses.push_back(current_string);\n            current_string.clear();\n\
    \        } else if (c == ')') {\n            parentheses += current_string;\n\
    \            long level = 1;\n            for (auto str : current_parentheses)\
    \ {\n                if (str == parentheses) {\n                    level = current_parentheses.size();\n\
    \                    break;\n                }\n            }\n            if\
    \ (max_level < level) {\n                max_level = level;\n                max_level_of_nesting.push_back(level);\n\
    \            }\n            current_parentheses.clear();\n            current_string.clear();\n\
    \        } else {\n            current_string.push_back(c);\n        }\n    }\n\
    \    return max_level_of_nesting;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpzhpi8p1r: /tmp/tmpzhpi8p1r.cpp:42: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long cur_depth = 0;\n  \
    \  for (size_t i = 0; i < (paren_string.size() - 1); i++) {\n        if (paren_string[i]\
    \ == paren_string[i+1]) continue;\n        if (paren_string[i] == '(') {\n   \
    \         if (cur_depth > 0) {\n                result.push_back(cur_depth);\n\
    \            }\n            cur_depth++;\n        } else if (paren_string[i] ==\
    \ ')') {\n            if (cur_depth > 0) {\n                cur_depth--;\n   \
    \         } else {\n                throw std::runtime_error(\"No matching opening\
    \ parenthesis!\");\n            }\n        } else if (paren_string[i] == ' ')\
    \ {\n            cur_depth--;\n        }\n    }\n    result.push_back(cur_depth);\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::runtime_error'\n \
    \ what():  No matching opening parenthesis!\n"
  stdout: ''
  timestamp: 1660113170
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_list;\n    std::string paren_char\
    \ = \"()\";\n    for (size_t i = 0; i < paren_string.size(); i++) {\n        if\
    \ (paren_string[i] == paren_char) {\n            paren_list.push_back(paren_string.size());\n\
    \        } else if (paren_string[i] == \" \") {\n            paren_list.push_back(paren_list.back());\n\
    \        }\n    }\n    return paren_list;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp4jpi41ja.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp4jpi41ja.cpp:12:29: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   12 |         if (paren_string[i] == paren_char) {\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp4jpi41ja.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmp4jpi41ja.cpp:12:32:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   12 |         if (paren_string[i] == paren_char) {\n\
    \      |                                ^~~~~~~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmp4jpi41ja.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp4jpi41ja.cpp:12:32: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>\u2019 and \u2018__gnu_cxx"
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    long max_level = -1;\n \
    \   long depth = 1;\n    for (auto c : paren_string) {\n        if (c != '(' &&\
    \ c != ')') {\n            result.push_back(depth);\n        }\n        ++depth;\n\
    \        if (depth > max_level) {\n            max_level = depth;\n        }\n\
    \    }\n    if (max_level == -1) {\n        return result;\n    }\n    for (auto\
    \ c : paren_string) {\n        if (c != ')') {\n            result.push_back(max_level);\n\
    \        }\n        --depth;\n        if (depth > max_level) {\n            max_level\
    \ = depth;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmph87qn3xu: /tmp/tmph87qn3xu.cpp:37: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  if (paren_string.length() ==\
    \ 0) return result;\n  // Count the number of opening and closing parentheses\
    \ occurring in the paren_string\n  int n_parens = 0;\n  for (int i = 0, ii = paren_string.size();\
    \ i < ii; ++i) {\n    if (paren_string[i] == '(') ++n_parens;\n    if (paren_string[i]\
    \ == ')') --n_parens;\n  }\n  if (n_parens == 0) {\n    // If all the parentheses\
    \ are closed, then there are no nesting levels\n    result.push_back(0);\n   \
    \ return result;\n  }\n  // Calculate the max level of nesting by comparing the\
    \ number of opening and closing parentheses\n  long max_level = 0;\n  for (int\
    \ i = 0, ii = paren_string.size(); i < ii; ++i) {\n    if (paren_string[i] ==\
    \ '(') {\n      if (max_level < n_parens - 1) max_level = n_parens - 1;\n    }\
    \ else if (paren_string[i] == ')') {\n      if (max_level > 0) max_level--;\n\
    \    }\n  }\n  // For each level of nesting, count the number of nested parentheses\n\
    \  // If there is only one level of nesting, then there would be only one nested\
    \ parentheses.\n  for (long level = 1; level <= max_level; ++level) {\n    int\
    \ n_nested_parens = 0;\n    for (int i = 0, ii = paren_string.size(); i < ii;\
    \ ++i) {\n      if (paren_string[i] == '(') ++n_nested_parens;\n      if (paren_string[i]\
    \ == ')') --n_nested_parens;\n      if (n_nested_parens > level) break;\n    }\n\
    \    if (n_nested_parens == level) result.push_back(level);\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp99pkizc2: /tmp/tmp99pkizc2.cpp:46: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  long level_of_nesting = 1;\n\
    \  int paren_level = 0;\n  for (char c : paren_string) {\n    // If this is the\
    \ closing parenthesis\n    if (c == '(') {\n      paren_level--;\n    }\n    //\
    \ If this is the opening parenthesis\n    else if (c == ')') {\n      paren_level++;\n\
    \    }\n    // If this is not the opening or closing parenthesis\n    else {\n\
    \      if (paren_level == level_of_nesting) {\n        result.push_back(level_of_nesting);\n\
    \      }\n      level_of_nesting++;\n    }\n  }\n  return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpzf9sv0pm: /tmp/tmpzf9sv0pm.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::stack<std::vector<long>> nest;\n  std::vector<long>\
    \ parens = {-1};\n  for (auto iter = paren_string.begin(); iter != paren_string.end();\
    \ ++iter) {\n    long paren_count = 1;\n    bool is_empty = false;\n    while\
    \ (*iter == '(' || is_empty) {\n      is_empty = false;\n      if (*iter == '(')\
    \ {\n        ++paren_count;\n      }\n      ++iter;\n    }\n    if (is_empty)\
    \ {\n      paren_count = -1;\n    }\n    for (; paren_count > 0 && parens.size()\
    \ < parens.size() + 1; ++parens) {\n      if (paren_count == 0) {\n        parens.push_back(-1);\n\
    \      } else {\n        ++parens[parens.size() - 1];\n      }\n    }\n    nest.push(parens);\n\
    \  }\n\n  std::vector<long> result;\n  while (nest.size() != 0) {\n    std::vector<long>\
    \ tmp = nest.top();\n    nest.pop();\n    if (tmp.size() == 0) {\n      result.push_back(0);\n\
    \    } else {\n      long last_index = tmp.size() - 1;\n      if (tmp[last_index]\
    \ == -1) {\n        last_index--;\n      }\n      for (; last_index >= 0; --last_index)\
    \ {\n        result.push_back(tmp[last_index]);\n      }\n    }\n  }\n\n  return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkltq51yo.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpkltq51yo.cpp:24:66: error: no match for \u2018operator++\u2019 (operand\
    \ type is \u2018std::vector<long int>\u2019)\n   24 |     for (; paren_count >\
    \ 0 && parens.size() < parens.size() + 1; ++parens) {\n      |               \
    \                                                   ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_level;\n    // The key is that paren_string\
    \ is an unordered set of parenthesis.\n    // We need to build a tree that represent\
    \ the parenthesis nesting level for each parenthesis.\n    // The root is denoted\
    \ by a parenthesis string with only that parenthesis.\n    // We iterate over\
    \ the parenthesis to build the nested parenthesis tree. Each iteration, we update\
    \ the max_level\n    // for each previous parenthesis string and assign the new\
    \ value to the max_level with the next parenthesis.\n    for (auto it : paren_string)\
    \ {\n        // We need some extra space for parenthesis strings that end with\
    \ \")\".\n        if (it == '(') {\n            max_level.push_back(1);\n    \
    \    } else if (it == ')') {\n            // We need to update the max_level for\
    \ the previous parenthesis string\n            // and add the current level to\
    \ the max_level for the new parenthesis string.\n            max_level.insert(max_level.end(),\
    \ max_level[max_level.size() - 1], max_level.back() + 1);\n        } else {\n\
    \            // We only care about parenthesis strings that start \"(\" and end\
    \ \")\".\n            // We can skip the space and just update the max_level for\
    \ the parenthesis string.\n            max_level.push_back(1);\n        }\n  \
    \  }\n    return max_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp8kd5p92n: /tmp/tmp8kd5p92n.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113171
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // The output vector will keep a record of which nested\
    \ parenthesis has how many levels.\n    // Thus, the size of the vector will indicate\
    \ how many levels of nesting there are.\n    std::vector<long> output_vector;\n\
    \    bool flag = false;\n    std::string stack_string = \"\";\n    long stack_level\
    \ = 0;\n    long open_parentheses_count = 1;\n    for(size_t index=0; index <\
    \ paren_string.size(); ++index) {\n        if(paren_string[index] == '(') {\n\
    \            flag = true;\n            open_parentheses_count = 1;\n         \
    \   stack_string += paren_string[index];\n        } else if(paren_string[index]\
    \ == ')') {\n            flag = false;\n            stack_string += paren_string[index];\n\
    \            output_vector.push_back(stack_level);\n            stack_level--;\n\
    \        } else {\n            if(flag) {\n                stack_string += paren_string[index];\n\
    \                open_parentheses_count++;\n            } else {\n           \
    \     if(open_parentheses_count > stack_level) {\n                    stack_level\
    \ = open_parentheses_count;\n                    stack_string += paren_string[index];\n\
    \                } else {\n                    stack_level = open_parentheses_count;\n\
    \                }\n            }\n        }\n    }\n    if(stack_level > 0) {\n\
    \        output_vector.push_back(stack_level);\n    }\n    return output_vector;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpi018myh0: /tmp/tmpi018myh0.cpp:47: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113170
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_level;\n    for (size_t i = 0; i\
    \ < paren_string.size(); i++) {\n        size_t next_open_index = i;\n       \
    \ size_t max_open_index = 0;\n        while (next_open_index < paren_string.size())\
    \ {\n            char opening_bracket = paren_string[next_open_index];\n     \
    \       size_t closing_bracket = paren_string[next_open_index + 1];\n        \
    \    if (opening_bracket == '(') {\n                next_open_index++;\n     \
    \       } else if (opening_bracket == '(') {\n                opening_bracket\
    \ = ')';\n            } else {\n                break;\n            }\n      \
    \      if (max_open_index < next_open_index) {\n                max_open_index\
    \ = next_open_index;\n            }\n            if (closing_bracket != ')') {\n\
    \                break;\n            }\n            next_open_index++;\n     \
    \   }\n        assert(next_open_index < paren_string.size());\n        long max_level\
    \ = max_open_index - i;\n        max_level.push_back(max_level);\n    }\n    return\
    \ max_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n   \
    \ assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjdo5stz0.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpjdo5stz0.cpp:33:19: error: request for member \u2018push_back\u2019\
    \ in \u2018max_level\u2019, which is of non-class type \u2018long int\u2019\n\
    \   33 |         max_level.push_back(max_level);\n      |                   ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  auto size = paren_string.size();\n\
    \  for (int i = 0; i < size; i++) {\n    auto index = paren_string[i] - '(';\n\
    \    while (index > 0) {\n      result.push_back(index);\n      --index;\n   \
    \ }\n  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp7dp3twc7: /tmp/tmp7dp3twc7.cpp:22: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113171
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> nest_levels;\n    std::vector<std::string>\
    \ paren_strs = split(paren_string, ' ');\n    std::vector<int> paren_start_pos(paren_strs.size());\n\
    \    std::vector<long> cur_nest_level(paren_strs.size(), 0);\n    for (auto &s\
    \ : paren_strs) {\n        auto pos = paren_start_pos.size() - 1;\n        while\
    \ (pos >= 0) {\n            if (s == '(') {\n                paren_start_pos[pos]\
    \ += 1;\n            } else if (s == ')') {\n                paren_start_pos[pos]\
    \ -= 1;\n                if (paren_start_pos[pos] < 0) break;\n            }\n\
    \            pos = (pos - 1) / 2;\n        }\n        nest_levels.push_back(cur_nest_level[paren_start_pos.size()]);\n\
    \    }\n    return nest_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsb6f91lx.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpsb6f91lx.cpp:10:43: error: \u2018split\u2019 was not declared in this\
    \ scope\n   10 |     std::vector<std::string> paren_strs = split(paren_string,\
    \ ' ');\n      |                                           ^~~~~\n/tmp/tmpsb6f91lx.cpp:16:19:\
    \ error: no match for \u2018operator==\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019\
    \ and \u2018char\u2019)\n   16 |             if (s == '(') {\n      |        \
    \         ~ ^~ ~~~\n      |                 |    |\n      |                 |\
    \    char\n      |                 std::__cxx11::basic_string<char>\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsb6f91lx.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpsb6f91lx.cpp:16:22:\
    \ note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018\
    const std::__cxx11::sub_match<_BiIter>\u2019\n   16 |             if (s == '(')\
    \ {\n      |                      ^~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpsb6f91lx.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/s"
  stdout: ''
  timestamp: 1660113170
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // For each group of parentheses, maintain a stack which\
    \ stores the current nesting level.\n    std::vector<long> levels;\n    levels.push_back(0);\n\
    \    // Use a map to store nesting level.\n    std::map<long, long> nesting_level;\n\
    \    nesting_level[0] = 0;\n    long currLevel = levels[0];\n    for (size_t i\
    \ = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n\
    \            if (nesting_level.count(currLevel)) {\n                currLevel++;\n\
    \            }\n            else {\n                levels.push_back(currLevel);\n\
    \                nesting_level[currLevel] = currLevel;\n                currLevel++;\n\
    \            }\n        }\n        else if (paren_string[i] == ')') {\n      \
    \      currLevel--;\n        }\n    }\n    return levels;\n}\nint main() {\n \
    \   auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpf44z6j5e: /tmp/tmpf44z6j5e.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113171
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Your code here\n    // ...\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpgv9goiwx: /tmp/tmpgv9goiwx.cpp:14: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113171
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_depths;\n  paren_depths.reserve(paren_string.size()\
    \ / 2 + 1);\n  long paren_level = 0;\n  int paren_level_pos = 0;\n  long pos =\
    \ 0;\n  char ch;\n  while (pos < paren_string.size()) {\n    ch = paren_string[pos];\n\
    \    if (ch == '(') {\n      paren_level++;\n      paren_level_pos = pos;\n  \
    \  }\n    else if (ch == ')') {\n      paren_level--;\n    }\n    else if (ch\
    \ == ' ' || ch == '(' || ch == ')') {\n      if (paren_level > 0) {\n        //\
    \ This level is deeper than previous ones\n        paren_depths.push_back(paren_level);\n\
    \      }\n      paren_level = 0;\n      paren_level_pos = pos;\n    }\n    pos++;\n\
    \  }\n  // Push last level\n  if (paren_level > 0) {\n    paren_depths.push_back(paren_level);\n\
    \  }\n  return paren_depths;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp5oh5q40u: /tmp/tmp5oh5q40u.cpp:42: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113171
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_depth(paren_string.size() + 1);\n\
    \    std::vector<long> paren_level(paren_string.size() + 1, 0);\n    std::vector<long>\
    \ paren_level_cur(paren_string.size() + 1, 0);\n    for (auto i = 0; i < paren_string.size();\
    \ ++i) {\n        if (paren_string[i] == ')') {\n            if (paren_depth[i\
    \ - 1] > paren_depth[i - 2]) paren_level[i - 2] = paren_level[i - 1];\n      \
    \      else paren_level[i - 2] = paren_level[i - 1] + 1;\n            paren_depth[i]\
    \ = paren_depth[i - 1] + 1;\n            paren_level_cur[i] = paren_level_cur[i\
    \ - 1];\n        }\n        else if (paren_string[i] == '(') {\n            paren_level_cur[i]\
    \ = paren_level_cur[i - 1];\n            paren_level[i] = paren_level_cur[i] +\
    \ 1;\n        }\n    }\n\n    if (paren_depth[0] != paren_depth[1]) return std::vector<long>();\n\
    \    if (paren_level[0] == 0) return std::vector<long>();\n    if (paren_level_cur[0]\
    \ != paren_level_cur[1]) return std::vector<long>();\n\n    // The last element\
    \ of paren_level_cur and paren_level is the deepest level of nesting so far.\n\
    \    return std::vector<long>(paren_level.rbegin(), paren_level.rend());\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpruee_3s6: /tmp/tmpruee_3s6.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113171
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> results;\n    auto parens_index = paren_string.find_first_not_of(\"\
    ((\");\n    if (parens_index == std::string::npos) {\n        return results;\
    \ // If no valid group found, return empty vector\n    }\n    // To check how\
    \ many opening parens, decrement the parens_index\n    // and count the closing\
    \ parens encountered.\n    auto parens_count = paren_string.substr(parens_index).size();\n\
    \    // If no closing parens found, just decrement the parens_index\n    // and\
    \ continue to find the next opening parens\n    if (parens_count == 0) {\n   \
    \     parens_index--;\n        parens_count = 1;\n    }\n    // If the string\
    \ is empty, just add 0 to nested parens\n    if (parens_count == 0) {\n      \
    \  results.push_back(0);\n    }\n    // While a closing paren is encountered,\
    \ decrement parens_count and check the first opening paren\n    while (parens_count\
    \ > 0) {\n        auto paren_index = paren_string.find_first_not_of(\"()\", parens_index);\n\
    \        // If there are no more valid opening parens, break the loop\n      \
    \  if (paren_index == std::string::npos) {\n            break;\n        }\n  \
    \      // If the first opening paren is not at the end, add 1 to nested parens\n\
    \        if (paren_index != paren_string.size() - 1) {\n            results.push_back(paren_index\
    \ + 1);\n        } else {\n            results.push_back(-1);\n        }\n   \
    \     // Increment the parens_index to find the next closing paren\n        parens_index\
    \ = paren_string.find_first_of(\"()\", paren_index + 2);\n        parens_count--;\n\
    \    }\n    return results;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpecb8e5k4: /tmp/tmpecb8e5k4.cpp:48: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113172
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // A simple stack to store depth of parentheses.\n    std::stack<long>\
    \ paren_depth;\n    // A vector to store result.\n    std::vector<long> paren_level_vec(0);\n\
    \    // Iterate through the string.\n    for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n        // If current character is opening parentheses, push it.\n \
    \       if (paren_string[i] == '(') {\n            paren_depth.push(paren_level_vec.size());\n\
    \        }\n        // If current character is closing parentheses, push it.\n\
    \        if (paren_string[i] == ')') {\n            assert(paren_depth.top() >\
    \ 0);\n            paren_level_vec.push_back(paren_depth.top());\n           \
    \ paren_depth.pop();\n        }\n    }\n    return paren_level_vec;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpbck8s0wr: /tmp/tmpbck8s0wr.cpp:21: std::vector<long int> parse_nested_parens(std::string):
    Assertion `paren_depth.top() > 0'' failed.

    '
  stdout: ''
  timestamp: 1660113171
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Convert string into an array of strings of characters\
    \ where each character represents one group.\n    std::vector<std::array<char,\
    \ 1>> paren_array;\n    for (int i = 0; i <= paren_string.length(); i++) {\n \
    \       if (paren_string.at(i) == ' ') {\n            paren_array.push_back(std::array<char,\
    \ 1>());\n        } else if (paren_string.at(i) == '(') {\n            paren_array.back().at(0)\
    \ = '(';\n        } else if (paren_string.at(i) == ')') {\n            paren_array.back().at(0)\
    \ = ')';\n        } else {\n            assert(paren_string.at(i) == '(');\n \
    \           paren_array.back().at(0) = '(';\n        }\n    }\n\n    // Count\
    \ the number of groups (parentheses) per line.\n    int counts[paren_array[0].size()];\n\
    \    for (int i = 0; i < paren_array[0].size(); i++) {\n        counts[i] = 0;\n\
    \        for (int j = 0; j < paren_array.size(); j++) {\n            if (paren_array[j].at(i)\
    \ == paren_array[0].at(i)) {\n                counts[i]++;\n            }\n  \
    \      }\n    }\n\n    // Sort the groups by nesting level of parantheses.\n \
    \   for (int i = 0; i < paren_array[0].size(); i++) {\n        std::vector<std::pair<int,\
    \ int>> groups;\n        for (int j = 0; j < paren_array.size(); j++) {\n    \
    \        if (paren_array[j].at(i) == paren_array[0].at(i)) {\n               \
    \ for (int k = 0; k < paren_array[j].size(); k++) {\n                    if (paren_array[j].at(k)\
    \ != ' ') {\n                        groups.push_back(std::make_pair(counts[k],\
    \ j));\n                    }\n                }\n            }\n        }\n\n\
    \        // Sort the groups by nesting level of parantheses.\n        for (int\
    \ j = 0; j < groups.size(); j++) {\n            std::pair<int, int> group = groups[j];\n\
    \            for (int k = group.second; k < paren_array.size(); k++) {\n     \
    \           if (paren_array[k].at(i) == paren_array[0].at(i)) {\n            \
    \        for (int l = 0; l < counts[i]; l++) {\n                        counts[i]--;\n\
    \                    }\n                    break;\n                }\n      \
    \      }\n        }\n\n        // Add current parenthetical groups to the result\
    \ vector.\n        std::vector<long> result;\n        for (int j = 0; j < groups.size();\
    \ j++) {\n            std::vector<std::array<char, 1>> group;\n            for\
    \ (int k = 0; k < counts[groups[j].second]; k++) {\n                group.push_back(std::array<char,\
    \ 1>());\n            }\n\n            for (int l = 0; l < counts[groups[j].second];\
    \ l++) {\n                group[groups[j].second].at(0) = paren_array[(groups[j].second)\
    \ * group.size() + l].at(i);\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_gqou1sl.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp_gqou1sl.cpp:72:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n   72 | int main() {\n      |            ^\n/tmp/tmp_gqou1sl.cpp:77:1:\
    \ error: expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmp_gqou1sl.cpp:63:49:\
    \ note: to match this \u2018{\u2019\n   63 |         for (int j = 0; j < groups.size();\
    \ j++) {\n      |                                                 ^\n/tmp/tmp_gqou1sl.cpp:77:1:\
    \ error: expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmp_gqou1sl.cpp:36:53:\
    \ note: to match this \u2018{\u2019\n   36 |     for (int i = 0; i < paren_array[0].size();\
    \ i++) {\n      |                                                     ^\n/tmp/tmp_gqou1sl.cpp:77:1:\
    \ error: expected \u2018}\u2019 at end of input\n   77 | }\n      | ^\n/tmp/tmp_gqou1sl.cpp:8:65:\
    \ note: to match this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmp_gqou1sl.cpp:77:1: warning: control reaches end of non-void\
    \ function [-Wreturn-type]\n   77 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113171
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    stack<string> parens;\n\
    \    parens.push(\"((\");\n    \n    // Count depth level of parenthesis.\n  \
    \  auto paren_counter = 0ll;\n    for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n        if (parens[paren_string[i]] == '(') ++paren_counter;\n     \
    \   else if (parens[paren_string[i]] == ')') --paren_counter;\n        else if\
    \ (paren_counter == 0) {\n            result.push_back(paren_string[i]);\n   \
    \     }\n    }\n    \n    return result;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpfvzp0xcf.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpfvzp0xcf.cpp:10:5: error: \u2018stack\u2019 was not declared in this\
    \ scope; did you mean \u2018std::stack\u2019?\n   10 |     stack<string> parens;\n\
    \      |     ^~~~~\n      |     std::stack\nIn file included from /usr/include/c++/9/stack:61,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpfvzp0xcf.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:99:11:\
    \ note: \u2018std::stack\u2019 declared here\n   99 |     class stack\n      |\
    \           ^~~~~\n/tmp/tmpfvzp0xcf.cpp:10:11: error: \u2018string\u2019 was not\
    \ declared in this scope\n   10 |     stack<string> parens;\n      |         \
    \  ^~~~~~\n/tmp/tmpfvzp0xcf.cpp:10:11: note: suggested alternatives:\nIn file\
    \ included from /usr/include/c++/9/iosfwd:39,\n                 from /usr/include/c++/9/ios:38,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpfvzp0xcf.cpp:2:\n/usr/include/c++/9/bits/stringfwd.h:79:33:\
    \ note:   \u2018std::string\u2019\n   79 |   typedef basic_string<char>    string;\n\
    \      |                                 ^~~~~~\nIn file included from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpfvzp0xcf.cpp:2:\n/usr/include/c++/9/string:67:11: note:   \u2018std::pmr::string\u2019\
    \n   67 |     using string    = basic_string<char>;\n      |           ^~~~~~\n\
    /tmp/tmpfvzp0xcf.cpp"
  stdout: ''
  timestamp: 1660113171
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n\tstd::vector<long> parens_levels;\n\tparen_string = paren_string.substr(0,\
    \ paren_string.find_first_of('(')).substr(1);\n\tfor (auto &i: paren_string) {\n\
    \t\tif (i == '(') {\n\t\t\tparens_levels.push_back(parens_levels.size());\n\t\t\
    } else if (i == ')') {\n\t\t\tif (parens_levels.size() >= parens_levels[parens_levels.size()\
    \ - 1]) {\n\t\t\t\t--parens_levels[parens_levels.size() - 1];\n\t\t\t} else {\n\
    \t\t\t\tparens_levels.push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\treturn parens_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 1) > this->size() (which is 0)\n"
  stdout: ''
  timestamp: 1660113172
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  assert(!paren_string.empty());\n  std::vector<long> parens_nest;\n\
    \  parens_nest.push_back(1); // push 1 for the first parenthesis\n  parens_nest.push_back(1);\
    \ // push 1 for the second parenthesis\n\n  int pos = 0;\n  while (pos < paren_string.size())\
    \ {\n    int left_paren_pos = paren_string.find(\"(\", pos);\n    int right_paren_pos\
    \ = paren_string.find(\")\", pos);\n    if (left_paren_pos == std::string::npos\
    \ || right_paren_pos == std::string::npos)\n      break; // we reached the end\
    \ of string\n\n    int right_paren_length = right_paren_pos - left_paren_pos;\n\
    \    if (right_paren_length == 0)\n      break; // we reached the end of a group\n\
    \n    parens_nest.push_back(right_paren_length); // push right parenthesis length\n\
    \n    pos = right_paren_pos + 1; // next position to parse\n  }\n\n  return parens_nest;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpybyh1k4y: /tmp/tmpybyh1k4y.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113172
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n\tstd::vector<long> result(paren_string.size()); // result\
    \ will hold the nesting level for each group of parentheses\n\tstd::stack<long>\
    \ paren_stack;\n\tfor (std::size_t i = 0; i < paren_string.size(); ++i) {\n\t\t\
    if (paren_string[i] == ')' && paren_stack.empty()) {\n\t\t\tresult[i] = 0; //\
    \ if the current character is ')', it is an opener of the group of parentheses\n\
    \t\t} else if (paren_string[i] == '(') {\n\t\t\tparen_stack.push(paren_string[i]);\
    \ // push current character to the stack\n\t\t}\n\t\telse if (paren_string[i]\
    \ == ')') {\n\t\t\tstd::size_t j = paren_stack.top(); // get the deepest nesting\
    \ level of parentheses\n\t\t\tif (j > 0) {\n\t\t\t\t--j; // since we popped '('\
    \ from stack, we can decrease the nesting level of '('\n\t\t\t\tif (j == 0) {\n\
    \t\t\t\t\tresult[i] = j; // if the current character is ')', it is the deepest\
    \ level of nesting of this group of parentheses\n\t\t\t\t\tparen_stack.pop();\
    \ // pop current character out of the stack\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\
    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n \
    \   assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp0692eu2g: /tmp/tmp0692eu2g.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113172
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n\t// Create an empty stack\n\tstd::stack<std::string> paren_stack;\n\
    \t// Add the stack strings to the paren stack\n\tfor (auto &s: paren_string.rstrip().split('\
    \ ')) {\n\t\t// Skip empty string\n\t\tif (!s.empty()) {\n\t\t\t// Add paren stack\n\
    \t\t\tparen_stack.emplace(s);\n\t\t}\n\t}\n\t// Create empty array\n\tstd::vector<long>\
    \ result(paren_stack.size());\n\t// Start iterating through the stack backwards\n\
    \tfor (auto i = paren_stack.size(); i-- > 0;) {\n\t\t// Push the top paren on\
    \ the result\n\t\tresult.push_back(long(paren_stack.top()));\n\t\t// Pop the top\
    \ paren from the stack\n\t\tparen_stack.pop();\n\t}\n\treturn result;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkmen6l2a.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpkmen6l2a.cpp:12:29: error: \u2018std::string\u2019 {aka \u2018class\
    \ std::__cxx11::basic_string<char>\u2019} has no member named \u2018rstrip\u2019\
    \n   12 |  for (auto &s: paren_string.rstrip().split(' ')) {\n      |        \
    \                     ^~~~~~\n/tmp/tmpkmen6l2a.cpp:24:42: error: invalid cast\
    \ from type \u2018__gnu_cxx::__alloc_traits<std::allocator<std::__cxx11::basic_string<char>\
    \ >, std::__cxx11::basic_string<char> >::value_type\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } to type \u2018long int\u2019\n   24 |   result.push_back(long(paren_stack.top()));\n\
    \      |                                          ^\n"
  stdout: ''
  timestamp: 1660113171
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> nesting_level(paren_string.size());\n\
    \    for (long i = 0; i < paren_string.size(); i++) {\n        auto it = paren_string.begin()\
    \ + i;\n        for (; it != paren_string.end(); ++it) {\n            if (*it\
    \ == '(')\n                nesting_level[i]++;\n            else if (*it == ')')\n\
    \                nesting_level[i]--;\n        }\n    }\n    return nesting_level;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpih78hyll: /tmp/tmpih78hyll.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113172
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  long max_level = 0;\n  long\
    \ curr_level = 0;\n  for (auto it = paren_string.rbegin(); it != paren_string.rend();\
    \ ++it) {\n    if (*it == '(') {\n      if (curr_level == 0) {\n        ++max_level;\n\
    \        curr_level = max_level;\n      } else {\n        curr_level--;\n    \
    \  }\n    } else if (*it == ')') {\n      curr_level++;\n    }\n    result.push_back(curr_level);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpet56q9_6: /tmp/tmpet56q9_6.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113172
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_level;\n    // This stores the amount\
    \ of nesting levels encountered for each group of parentheses.\n    // The first\
    \ element (index 0) is always 0 because the first group of parentheses encountered\
    \ is always one level deep.\n    std::vector<int> paren_levels(paren_string.size(),\
    \ 0);\n    long cur_level = 0;\n    size_t pos = 0;\n    while (pos < paren_string.size())\
    \ {\n        char ch = paren_string[pos];\n        if (ch == '(') {\n        \
    \    paren_levels[pos] += 1;\n            cur_level += 1;\n        } else if (ch\
    \ == ')') {\n            paren_levels[pos] -=1;\n            if (paren_levels[pos]\
    \ <= 0) {\n                max_level.push_back(cur_level);\n                cur_level\
    \ = 0;\n            }\n        }\n        pos += 1;\n    }\n    return max_level;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpcmp2xu48: /tmp/tmpcmp2xu48.cpp:33: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113172
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Your code goes here\n    std::vector<long> max_level;\n\
    \    long max_level_ind = std::numeric_limits<long>::max();\n    for (auto i :\
    \ paren_string.rbegin()) {\n        if (i == ')')\n            max_level_ind--;\n\
    \        else if (i == '(')\n            max_level_ind++;\n        else if (max_level_ind\
    \ > max_level.size()) {\n            max_level.clear();\n            max_level_ind\
    \ = std::numeric_limits<long>::max();\n        }\n        long current_level =\
    \ max_level.size();\n        if (current_level > max_level_ind) {\n          \
    \  max_level.push_back(current_level);\n            max_level_ind = current_level;\n\
    \        }\n    }\n    return max_level;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmp0vznsruw.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp0vznsruw.cpp:12:39: error: no matching function for call to \u2018\
    begin(std::reverse_iterator<__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ > >&)\u2019\n   12 |     for (auto i : paren_string.rbegin()) {\n      |   \
    \                                    ^\nIn file included from /usr/include/c++/9/bits/range_access.h:36,\n\
    \                 from /usr/include/c++/9/string:54,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmp0vznsruw.cpp:2:\n/usr/include/c++/9/initializer_list:89:5: note: candidate:\
    \ \u2018template<class _Tp> constexpr const _Tp* std::begin(std::initializer_list<_Tp>)\u2019\
    \n   89 |     begin(initializer_list<_Tp> __ils) noexcept\n      |     ^~~~~\n\
    /usr/include/c++/9/initializer_list:89:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmp0vznsruw.cpp:12:39: note:   \u2018std::reverse_iterator<__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> > >\u2019 is not derived from \u2018std::initializer_list<_Tp>\u2019\
    \n   12 |     for (auto i : paren_string.rbegin()) {\n      |                \
    \                       ^\nIn file included from /usr/include/c++/9/string:54,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39"
  stdout: ''
  timestamp: 1660113172
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> max_nesting_parens;\n  for (size_t i =\
    \ 0; i < paren_string.size() - 1; ++i) {\n    std::string curr_parens = paren_string.substr(i,\
    \ paren_string.size() - i);\n    if (curr_parens.back() == '(' && curr_parens.front()\
    \ == ')') {\n      max_nesting_parens.push_back(i);\n    }\n  }\n  return max_nesting_parens;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp2r5d3a3x: /tmp/tmp2r5d3a3x.cpp:20: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113173
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Get all the groups in the string and store it in a vector\
    \ with type long because that would simplify many things.\n    // In the end,\
    \ return the vector of long type.\n    std::vector<long> groups;\n    std::stack<long>\
    \ paren_stack;\n    for (auto ch : paren_string) {\n        if (ch == ')') {\n\
    \            // Pop until we reach an opening paranthesis.\n            // Keep\
    \ doing this till we reach the parenthesis we started from.\n            while\
    \ (!paren_stack.empty() && paren_stack.top() != ch) {\n                paren_stack.pop();\n\
    \            }\n            while (!paren_stack.empty() && paren_stack.top() ==\
    \ ch) {\n                groups.push(paren_stack.top());\n                paren_stack.pop();\n\
    \            }\n        }\n        else {\n            // Push the character to\
    \ the stack. Also push it to the groups if it's not a parenthesis.\n         \
    \   paren_stack.push(ch);\n            if (ch == '(') {\n                groups.push(0);\n\
    \            }\n        }\n    }\n    return groups;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmprpewk8o1.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmprpewk8o1.cpp:21:24: error: \u2018class std::vector<long int>\u2019\
    \ has no member named \u2018push\u2019\n   21 |                 groups.push(paren_stack.top());\n\
    \      |                        ^~~~\n/tmp/tmprpewk8o1.cpp:29:24: error: \u2018\
    class std::vector<long int>\u2019 has no member named \u2018push\u2019\n   29\
    \ |                 groups.push(0);\n      |                        ^~~~\n"
  stdout: ''
  timestamp: 1660113172
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result(paren_string.size());\n    std::stack<int>\
    \ paren_stack;\n    size_t i = 0;\n    while (i < paren_string.size()) {\n   \
    \     if (paren_stack.empty()) {\n            if (paren_string[i] == '(') {\n\
    \                result.push_back(i);\n                paren_stack.push(i);\n\
    \                ++i;\n            } else if (paren_string[i] == ')') {\n    \
    \            long paren_level = result.back() - paren_stack.top();\n         \
    \       while (paren_stack.size() > paren_level)\n                    result.pop_back();\n\
    \                --paren_stack.size();\n                result.push_back(i);\n\
    \                paren_stack.push(i);\n                ++i;\n            } else\
    \ {\n                ++i;\n            }\n        } else {\n            size_t\
    \ paren_top = paren_stack.top();\n            if (paren_string[i] == ')') {\n\
    \                long paren_level = result.back() - paren_stack.top();\n     \
    \           while (paren_stack.size() > paren_level)\n                    result.pop_back();\n\
    \                --paren_stack.size();\n                result.push_back(paren_top);\n\
    \                paren_stack.push(paren_top);\n                ++i;\n        \
    \    } else {\n                ++i;\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6pewp5el.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp6pewp5el.cpp:22:36: error: lvalue required as decrement operand\n \
    \  22 |                 --paren_stack.size();\n      |                       \
    \             ^\n/tmp/tmp6pewp5el.cpp:35:36: error: lvalue required as decrement\
    \ operand\n   35 |                 --paren_stack.size();\n      |            \
    \                        ^\n"
  stdout: ''
  timestamp: 1660113172
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Your code goes here\n    int level_of_nesting = 0;\n\
    \    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    for (size_t i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            level_of_nesting++;\n        } else if (paren_string[i]\
    \ == ')') {\n            level_of_nesting--;\n        }\n        paren_levels.push_back(level_of_nesting);\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpcoe8hv8j: /tmp/tmpcoe8hv8j.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113172
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Initialize the vector of deepest levels of nesting for\
    \ each group.\n    std::vector<long> deepest_levels_of_nesting;\n\n    // Initialize\
    \ the current deepest level of nesting for each group.\n    std::vector<long>\
    \ current_deepest_levels_of_nesting;\n\n    // Initialize a stack of groups to\
    \ push all the groups which haven't encountered parentheses.\n    std::vector<std::tuple<std::string,\
    \ std::string, std::vector<long>, std::vector<long>> stack_of_groups;\n\n    //\
    \ Initialize an auxiliary stack which contains groups which haven't been encountered\
    \ parentheses.\n    std::vector<std::tuple<std::string, std::string, std::vector<long>,\
    \ std::vector<long>> stack_of_groups_without_parens;\n\n    // Iterate over the\
    \ input string\n    for (std::string::iterator i = paren_string.begin(); i !=\
    \ paren_string.end(); i++) {\n        // If current char is left parentheses,\
    \ push it to the stack.\n        if (*i == '(') {\n            stack_of_groups_without_parens.emplace_back(std::get<0>(stack_of_groups),\
    \ std::get<1>(stack_of_groups),\n                std::get<2>(stack_of_groups),\
    \ std::get<3>(stack_of_groups));\n            stack_of_groups.emplace_back(std::get<0>(stack_of_groups_without_parens),\
    \ std::get<1>(stack_of_groups_without_parens),\n                std::vector<long>(),\
    \ std::vector<long>());\n            stack_of_groups_without_parens.emplace_back(std::get<0>(stack_of_groups),\
    \ std::get<1>(stack_of_groups),\n                std::vector<long>(), std::get<3>(stack_of_groups));\n\
    \            stack_of_groups.emplace_back(std::get<0>(stack_of_groups_without_parens),\
    \ std::get<1>(stack_of_groups_without_parens),\n                std::get<2>(stack_of_groups),\
    \ std::get<3>(stack_of_groups));\n            // Push the current group to the\
    \ stack again.\n            stack_of_groups.emplace_back(std::get<0>(stack_of_groups_without_parens),\
    \ std::get<1>(stack_of_groups_without_parens),\n                std::get<2>(stack_of_groups),\
    \ std::get<3>(stack_of_groups));\n            current_deepest_levels_of_nesting.emplace_back(0);\n\
    \        }\n\n        // If current char is right parentheses, pop the top most\
    \ group and increment its deepest level of nesting.\n        else if (*i == ')')\
    \ {\n            deepest_levels_of_nesting.emplace_back(current_deepest_levels_of_nesting.back()\
    \ + 1);\n            stack_of_groups.pop_back();\n            stack_of_groups_without_parens.pop_back();\n\
    \n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd6zcpxgh.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpd6zcpxgh.cpp:16:92: error: template argument 1 is invalid\n   16 |\
    \     std::vector<std::tuple<std::string, std::string, std::vector<long>, std::vector<long>>\
    \ stack_of_groups;\n      |                                                  \
    \                                          ^~~~~~~~~~~~~~~\n/tmp/tmpd6zcpxgh.cpp:16:92:\
    \ error: template argument 2 is invalid\n/tmp/tmpd6zcpxgh.cpp:19:92: error: template\
    \ argument 1 is invalid\n   19 |     std::vector<std::tuple<std::string, std::string,\
    \ std::vector<long>, std::vector<long>> stack_of_groups_without_parens;\n    \
    \  |                                                                         \
    \                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpd6zcpxgh.cpp:19:92:\
    \ error: template argument 2 is invalid\n/tmp/tmpd6zcpxgh.cpp:25:13: error: \u2018\
    stack_of_groups_without_parens\u2019 was not declared in this scope\n   25 | \
    \            stack_of_groups_without_parens.emplace_back(std::get<0>(stack_of_groups),\
    \ std::get<1>(stack_of_groups),\n      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpd6zcpxgh.cpp:25:69: error: \u2018stack_of_groups\u2019 was not declared\
    \ in this scope\n   25 |             stack_of_groups_without_parens.emplace_back(std::get<0>(stack_of_groups),\
    \ std::get<1>(stack_of_groups),\n      |                                     \
    \                                ^~~~~~~~~~~~~~~\n/tmp/tmpd6zcpxgh.cpp:42:13:\
    \ error: \u2018stack_of_groups\u2019 was not declared in this scope\n   42 | \
    \            stack_of_groups.pop_back();\n      |             ^~~~~~~~~~~~~~~\n\
    /tmp/tmpd6zcpxgh.cpp:43:13: error: \u2018stack_of_groups_without_parens\u2019\
    \ was not declared in this scope\n   43 |             stack_of_groups_without_parens.pop_back();\n\
    \      |             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpd6zcpxgh.cpp:46:12:\
    \ error: a function-definition is not allowed here before \u2018{\u2019 token\n\
    \   46 | int main() {\n      |            ^\n/tmp/tmpd6zcpxgh.cpp:51:1: error:\
    \ expected \u2018}\u2019 at end of input\n   51 | }\n      | "
  stdout: ''
  timestamp: 1660113172
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Keep count of nested parentheses\n    size_t count =\
    \ 1;\n    // Store the positions of every parentheses\n    std::vector<size_t>\
    \ parens_positions;\n    std::string current_parenthesis;\n    // The current\
    \ maximum depth of nested parentheses.\n    // The value of this variable is maintained\
    \ in every recursive call.\n    // This variable is used in base case.\n    long\
    \ max_depth = 0;\n    for (auto it = paren_string.begin(); it != paren_string.end();\
    \ it++) {\n        if (*it == '(') {\n            count++;\n            parens_positions.push_back(parens_positions.size());\n\
    \        }\n        else if (*it == ')') {\n            count--;\n           \
    \ if (count < 0) {\n                break;\n            }\n        }\n       \
    \ if (count > max_depth) {\n            max_depth = count;\n            current_parenthesis\
    \ = paren_string.substr(parens_positions[parens_positions.size() - 1] + 1, parens_positions[parens_positions.size()\
    \ - 1] - 1);\n        }\n    }\n    return std::vector<long>({max_depth, current_parenthesis});\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy6xt7eqy.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpy6xt7eqy.cpp:34:62: error: no matching function for call to \u2018\
    std::vector<long int>::vector(<brace-enclosed initializer list>)\u2019\n   34\
    \ |     return std::vector<long>({max_depth, current_parenthesis});\n      | \
    \                                                             ^\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpy6xt7eqy.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:650:2:\
    \ note: candidate: \u2018template<class _InputIterator, class> std::vector<_Tp,\
    \ _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)\u2019\
    \n  650 |  vector(_InputIterator __first, _InputIterator __last,\n      |  ^~~~~~\n\
    /usr/include/c++/9/bits/stl_vector.h:650:2: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpy6xt7eqy.cpp:34:62: note:   candidate expects 3 arguments,\
    \ 1 provided\n   34 |     return std::vector<long>({max_depth, current_parenthesis});\n\
    \      |                                                              ^\nIn file\
    \ included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpy6xt7eqy.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:622:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>,\
    \ const allocator_type&) [with _Tp = long int; _Alloc = std::allocator<long int>;\
    \ std::vector<_Tp, _Alloc>::allocator_type = std::allocator<long int>]\u2019\n\
    \  622 |       vector(initializer_list<value_type> __l,\n      |       ^~~~~~\n\
    /usr/incl"
  stdout: ''
  timestamp: 1660113172
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_list;\n  long nest_level = 0;\n \
    \ auto it_begin = paren_string.begin();\n  auto it_end = paren_string.end();\n\
    \  auto paren_it = paren_string.begin();\n  auto paren_end = paren_string.end();\n\
    \  char next_char = '\\0';\n  while (true) {\n    paren_list.push_back(it_end\
    \ - paren_it);\n    nest_level = paren_list.back();\n    // If the string ends\
    \ after seeing any nested parentheses\n    if (it_end != paren_end) {\n      next_char\
    \ = *it_end++;\n    }\n    // Find the next closing parentheses\n    if (paren_it\
    \ != paren_end) {\n      paren_it = paren_end;\n      paren_end = paren_string.find_first_of(\"\
    (())\", paren_it);\n      continue;\n    }\n    // If there are no nested parenthesis\
    \ in the string, return vector of lengths of nested parentheses\n    if (it_end\
    \ == paren_string.end()) return paren_list;\n    break;\n  }\n  assert(false);\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8pzge48i.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp8pzge48i.cpp:26:62: error: no matching function for call to \u2018\
    std::__cxx11::basic_string<char>::find_first_of(const char [5], __gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >&)\u2019\n   26 |       paren_end = paren_string.find_first_of(\"\
    (())\", paren_it);\n      |                                                  \
    \            ^\nIn file included from /usr/include/c++/9/string:55,\n        \
    \         from /usr/include/c++/9/bits/locale_classes.h:40,\n                \
    \ from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp8pzge48i.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:2506:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::find_first_of(const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type)\
    \ const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>;\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned\
    \ int]\u2019\n 2506 |       find_first_of(const basic_string& __str, size_type\
    \ __pos = 0) const\n      |       ^~~~~~~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:2506:58:\
    \ note:   no known conversion for argument 2 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n 2506 |       find_first_of(const basic_string&\
    \ __str, size_type __pos = 0) const\n      |                                 \
    \               ~~~~~~~~~~^~~~~~~~~\n/usr/includ"
  stdout: ''
  timestamp: 1660113172
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    auto parens = paren_string.substr(0, paren_string.find('\
    \ ')).split(' ');\n    std::vector<long> levels;\n    for (auto &level: parens)\
    \ {\n        bool found_opening = false;\n        bool found_closing = false;\n\
    \        long level_size = 0;\n        for (size_t i = 0; i < level.size() &&\
    \ level.size() <= 3; i++) {\n            if (level[i] == '(') found_opening =\
    \ true;\n            if (level[i] == ')') found_closing = true;\n            level_size\
    \ += 1;\n        }\n        long max_depth = (level_size>3)?level_size:3;\n  \
    \      if (found_opening)\n            levels.push_back(level_size);\n       \
    \ if (found_closing && max_depth != level_size)\n            levels.push_back((max_depth-level_size));\n\
    \    }\n    return levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5k_yc9z1.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp5k_yc9z1.cpp:9:66: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n    9 |     auto parens = paren_string.substr(0,\
    \ paren_string.find(' ')).split(' ');\n      |                               \
    \                                   ^~~~~\n"
  stdout: ''
  timestamp: 1660113172
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> results;\n    std::string levels = \"\
    \";\n    for (char c : paren_string) {\n        if (c == '(' || c == ')')\n  \
    \          levels += c;\n        else if (c == ' ') {\n            while (levels.size()\
    \ > 0)\n                results.push_back(std::stoi(levels));\n            levels\
    \ = \"\";\n        }\n    }\n    while (levels.size() > 0)\n        results.push_back(std::stoi(levels));\n\
    \    return results;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113173
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> nested_paren_level;\n    // If there\
    \ are single characters, they must be escaped like in Python syntax\n    if (paren_string.length()\
    \ == 1) {\n        nested_paren_level.push_back(0);\n    }\n    else {\n     \
    \   // Iterate through each of the characters to find the deepest level of nesting\n\
    \        for (auto i = paren_string.begin(); i != paren_string.end(); i++) {\n\
    \            long previous_nesting_level = 0;\n            long current_nesting_level\
    \ = 0;\n            while (i != paren_string.end() && paren_string[i++] == ' ')\
    \ {\n                previous_nesting_level = current_nesting_level;\n       \
    \         current_nesting_level++;\n            }\n            // If the number\
    \ of spaces between the current character and the next character is less than\
    \ or equal to previous_nesting_level,\n            // then it is an opening parenthesis\
    \ group. Add the level of nesting for the group to the list of nested parenthesis\
    \ level.\n            if (i - 1 == paren_string.end() || *(i - 1) != ' ' || (*(i\
    \ - 1) == ' ' && *(i + 1) != ' ')) {\n                nested_paren_level.push_back(previous_nesting_level);\n\
    \            }\n        }\n    }\n    return nested_paren_level;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc6lcsvf2.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpc6lcsvf2.cpp:19:59: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019)\n   19 |             while (i != paren_string.end() && paren_string[i++]\
    \ == ' ') {\n      |                                                         \
    \  ^\nIn file included from /usr/include/c++/9/string:55,\n                 from\
    \ /usr/include/c++/9/bits/locale_classes.h:40,\n                 from /usr/include/c++/9/bits/ios_base.h:41,\n\
    \                 from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpc6lcsvf2.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1050:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator[](std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) const [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference\
    \ = const char&; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1050 |       operator[] (size_type __pos) const\
    \ _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1050:29:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018std::__cxx11::basic_string<char>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019}\n 1050 |       operator[] (size_type __pos)\
    \ const _GLIBCXX_NOEXCEPT\n      |                   ~~~~~~~~~~^~~~~\n/usr/include/c++/9/bits/bas"
  stdout: ''
  timestamp: 1660113172
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    int left_bracket = 0, right_bracket = 0;\n    std::vector<long>\
    \ nestings(0);\n    std::stringstream ss(paren_string);\n    long left_nest_level\
    \ = 0, right_nest_level = 0;\n    while (ss >> parenthesis_symbol) {\n       \
    \ if (parenthesis_symbol == '(') ++left_bracket;\n        else if (parenthesis_symbol\
    \ == ')') ++right_bracket;\n        else if (parenthesis_symbol == ')' && left_bracket\
    \ > 0 && right_bracket == 0) {\n            nestings.push_back(left_nest_level);\n\
    \            left_nest_level = 0;\n        }\n        else if (parenthesis_symbol\
    \ == '(' && left_bracket == 0 && right_bracket == 0) {\n            left_nest_level\
    \ = nestings.size();\n        }\n        else if (parenthesis_symbol == '(' &&\
    \ left_bracket > 0 && right_bracket > 0) {\n            if (left_bracket < right_bracket)\
    \ {\n                left_nest_level = std::max(left_nest_level, nestings[left_bracket]);\n\
    \            }\n            else {\n                right_nest_level = std::max(right_nest_level,\
    \ nestings[right_bracket]);\n            }\n        }\n    }\n    if (left_bracket\
    \ == 0 && right_bracket == 0) {\n        nestings.push_back(left_nest_level);\n\
    \    }\n    return nestings;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp86y4e8wi.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp86y4e8wi.cpp:13:18: error: \u2018parenthesis_symbol\u2019 was not declared\
    \ in this scope\n   13 |     while (ss >> parenthesis_symbol) {\n      |     \
    \             ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660113172
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // If string is empty or is equal to \"()\" then return\
    \ empty vector\n    if (paren_string == \"\" || paren_string == \"()\") {\n  \
    \      return std::vector<long>();\n    }\n    std::vector<long> stack;\n    int\
    \ counter = 0;\n    std::vector<long> parens;\n    for (auto &c : paren_string)\
    \ {\n        if (counter == 0 && c == '(') {\n            stack.push_back(-1);\n\
    \            parens.push_back(0);\n            counter++;\n        } else if (c\
    \ == ')') {\n            long temp = parens[parens.size() - 1];\n            if\
    \ (temp == -1) {\n                temp = counter;\n            }\n           \
    \ parens[parens.size() - 1] = temp;\n            while (!stack.empty() && stack.back()\
    \ == (long)-1) {\n                long val = stack[stack.size() - 1];\n      \
    \          stack.pop_back();\n                stack[stack.size() - 1] = val +\
    \ 1;\n                counter--;\n            }\n        } else if (c == ' ')\
    \ {\n            if (stack.size() > 0 && stack.back() == -1) {\n             \
    \   stack.back() = counter;\n                parens.back() = 0;\n            }\n\
    \            counter = 0;\n        } else if (c != ' ') {\n            stack.back()\
    \ = -1;\n            parens.back() = 0;\n        }\n        counter++;\n    }\n\
    \    return parens;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'munmap_chunk(): invalid pointer

    '
  stdout: ''
  timestamp: 1660113173
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Your code goes here\n    std::vector<long> result;\n\
    \    result.push_back(1);\n    if (paren_string.length() == 0)\n        return\
    \ result;\n    long level = 0;\n    std::vector<long> stack = {0};\n    for (auto\
    \ c : paren_string) {\n        switch (c) {\n        case '(':\n            stack.push_back(level);\n\
    \            break;\n        case ')':\n            level = stack[stack.size()\
    \ - 1];\n            stack.pop_back();\n            break;\n        default:\n\
    \            result.push_back(level);\n            break;\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp9i_pjzb3: /tmp/tmp9i_pjzb3.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113173
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Your code goes here\n    std::vector<long> deepest_level;\n\
    \    deepest_level.push_back(1);\n    std::vector<long> paren_depths;\n    paren_depths.push_back(0);\n\
    \    std::string temp_paren_string = paren_string;\n    // A simple while loop\
    \ here will do the trick\n    while(temp_paren_string.size() > 0) {\n        //\
    \ Find the next parenthesis in the input string\n        auto i = temp_paren_string.find(\"\
    )\");\n        if(i != std::string::npos) {\n            // If there are multiple\
    \ groups within the parenthesis\n            if(temp_paren_string.find(\"(\")\
    \ != std::string::npos) {\n                // Keep getting the longest group and\
    \ incrementing the depth\n                long new_deepest_level = std::max(deepest_level.back(),\
    \ paren_depths.back());\n                deepest_level.push_back(new_deepest_level);\n\
    \                paren_depths.push_back(new_deepest_level);\n            }\n \
    \           // If there are multiple groups outside the parenthesis\n        \
    \    else {\n                // Keep getting the longest group and incrementing\
    \ the depth\n                long new_deepest_level = std::max(deepest_level.back(),\
    \ paren_depths.back());\n                deepest_level.push_back(new_deepest_level);\n\
    \                paren_depths.push_back(new_deepest_level);\n            }\n \
    \           // Remove the longest group from the input string\n            temp_paren_string\
    \ = temp_paren_string.substr(i+1);\n        }\n        else {\n            //\
    \ If there are no more parenthesis in the input string\n            // Add the\
    \ current depth to the deepest level\n            deepest_level.back() += paren_depths.back();\n\
    \            paren_depths.back()++;\n            // Remove the currently used\
    \ parenthesis from the input string\n            temp_paren_string = temp_paren_string.substr(0,i);\n\
    \        }\n    }\n    return deepest_level;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpb9lahrx3: /tmp/tmpb9lahrx3.cpp:50: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113173
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> max_levels;\n  std::string curr = \"0\"\
    ;\n  long curr_index = 0;\n  for(char c : paren_string) {\n    if(curr == \"0\"\
    ) {\n      // First character encountered\n      curr = c;\n      curr_index =\
    \ 1;\n    } else if(curr != c) {\n      // Different characters encountered, reset\
    \ current level\n      curr_index = 0;\n      curr = \"0\";\n    }\n    if(curr_index\
    \ == 0) {\n      // If current character is open, save current level\n      max_levels.push_back(curr_index);\n\
    \    } else {\n      // If current character is close, save maximum of two previous\
    \ levels\n      if(max_levels.size() > 0 && max_levels[max_levels.size() - 1]\
    \ < curr_index) {\n        max_levels.push_back(max_levels[max_levels.size() -\
    \ 1]);\n      }\n      if(max_levels.size() > 1 && max_levels[max_levels.size()\
    \ - 2] < curr_index) {\n        max_levels.push_back(max_levels[max_levels.size()\
    \ - 2]);\n      }\n    }\n  }\n  return max_levels;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpgvsj4uvc.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpgvsj4uvc.cpp:17:20: error: no match for \u2018operator!=\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018char\u2019)\n   17 |     } else if(curr != c) {\n      |         \
    \      ~~~~ ^~ ~\n      |               |       |\n      |               |   \
    \    char\n      |               std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpgvsj4uvc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1037:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator!=(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1037 |     operator!=(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1037:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpgvsj4uvc.cpp:17:23:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::__cxx11::sub_match<_BiIter>\u2019\n   17\
    \ |     } else if(curr != c) {\n      |                       ^\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpgvsj4uvc.cpp:2:\n/usr/include/c++/9/bits/regex.h:1112:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator!=(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1112 |     operator!=(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1112:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpgvsj4uvc.cpp:17:23: note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018char\u2019\n   17 |     } e"
  stdout: ''
  timestamp: 1660113172
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> ans;\n    long temp_level = 0;\n    for\
    \ (size_t i = 0; i < (paren_string.size() - 1); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            temp_level++;\n        } else if (paren_string[i] ==\
    \ ')') {\n            temp_level--;\n            if (temp_level == 0)\n      \
    \          break;\n        }\n        ans.push_back(temp_level);\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp5fy23v6y: /tmp/tmp5fy23v6y.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113173
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n\tstd::vector<long> parens_stack;\n\tfor (char chr: paren_string)\
    \ {\n\t\tswitch (chr) {\n\t\t\tcase '(':\n\t\t\t\tparens_stack.push_back(0);\n\
    \t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlong deepest_level = 0;\n\t\t\t\tfor\
    \ (long level: parens_stack) {\n\t\t\t\t\tif (level > deepest_level) {\n\t\t\t\
    \t\t\tdeepest_level = level;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparens_stack.pop_back();\n\
    \t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tparens_stack.back() += 1;\n\t\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn parens_stack;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp6cykk0i.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpp6cykk0i.cpp:24:4: error: jump to case label\n   24 |    default:\n\
    \      |    ^~~~~~~\n/tmp/tmpp6cykk0i.cpp:16:10: note:   crosses initialization\
    \ of \u2018long int deepest_level\u2019\n   16 |     long deepest_level = 0;\n\
    \      |          ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660113173
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  \n  // A stack to keep track\
    \ of which brackets we are currently in\n  std::stack<int> brackets;\n  \n  //\
    \ Push brackets onto stack\n  for (int i = 0; i < paren_string.size(); i++) {\n\
    \    // Increment brackets\n    brackets.push(brackets.size());\n    \n    //\
    \ If parenthesis\n    if (paren_string[i] == '(') {\n      // Push brackets\n\
    \      brackets.push(brackets.size());\n    } else {\n      // Pop brackets\n\
    \      int bracket = brackets.size() - 1;\n      \n      // If brackets are matching\n\
    \      if (brackets[bracket] == i + 1) {\n        // Add level to result\n   \
    \     result.push_back(bracket);\n      }\n    }\n  }\n  \n  // If we didn't find\
    \ any brackets\n  if (result.size() == 0) {\n    // Add 1 to all brackets\n  \
    \  for (size_t i = 0; i < brackets.size(); ++i) {\n      brackets[i] += 1;\n \
    \   }\n    \n    // Add 1 to result\n    result.push_back(brackets.size());\n\
    \  }\n  \n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqhp2h4er.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpqhp2h4er.cpp:28:19: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::stack<int>\u2019 and \u2018int\u2019)\n   28 |       if\
    \ (brackets[bracket] == i + 1) {\n      |                   ^\n/tmp/tmpqhp2h4er.cpp:39:15:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::stack<int>\u2019\
    \ and \u2018size_t\u2019 {aka \u2018long unsigned int\u2019})\n   39 |       brackets[i]\
    \ += 1;\n      |               ^\n"
  stdout: ''
  timestamp: 1660113173
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> return_vec(paren_string.size());\n  for\
    \ (size_t i = 0; i < paren_string.size(); i++) {\n    long cur_depth = 0;\n  \
    \  char cur_ch = paren_string[i];\n    while (1) {\n      if (cur_ch == ')') {\n\
    \        return_vec[i] = cur_depth;\n        break;\n      } else if (cur_ch ==\
    \ '(') {\n        if (return_vec.back() == 0 || return_vec[return_vec.back() -\
    \ 1] > cur_depth) {\n          cur_depth++;\n        } else {\n          cur_depth\
    \ = 0;\n        }\n      } else if (cur_ch == '[') {\n        if (return_vec.back()\
    \ == 0 || return_vec[return_vec.back() - 1] == cur_depth) {\n          cur_depth++;\n\
    \        } else {\n          cur_depth = 0;\n        }\n      } else if (cur_ch\
    \ == '{') {\n        if (return_vec.back() == 0 || return_vec[return_vec.back()\
    \ - 1] < cur_depth) {\n          cur_depth++;\n        } else {\n          cur_depth\
    \ = 0;\n        }\n      }\n      cur_ch = paren_string[++i];\n    }\n  }\n  return\
    \ return_vec;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n  \
    \  assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpr3clgzat: /tmp/tmpr3clgzat.cpp:43: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113173
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> results;\n  if (paren_string.empty()) {\n\
    \    return results;\n  }\n\n  // To keep track of open and close parentheses.\n\
    \  std::stack<long> paren_level;\n  paren_level.push(0);\n\n  // We will save\
    \ the index of the last parenthesis we saw, and keep track of\n  // parentheses\
    \ we didn't see.\n  int last_paren_index = -1;\n  bool seen_open_paren = false;\n\
    \  for (auto c : paren_string) {\n    if (c == '(') {\n      // Opening an opening\
    \ (parenthesis) means we need to increase the level\n      // and mark the last\
    \ parenthesis index we saw.\n      paren_level.push(paren_level.top() + 1);\n\
    \      last_paren_index = paren_level.size() - 1;\n      seen_open_paren = true;\n\
    \    }\n    else if (c == ')') {\n      // Closing an opening (parenthesis) means\
    \ we need to decrease the level\n      // and see if we are at the deepest level\
    \ of nesting.\n      paren_level.pop();\n      if (!paren_level.empty() && paren_level.top()\
    \ == 0) {\n        last_paren_index = paren_level.size() - 1;\n        seen_open_paren\
    \ = false;\n      }\n    }\n    else {\n      // If this character is neither\
    \ a opening or a closing parenthesis,\n      // then it is not part of the parentheses\
    \ and we can ignore it.\n      if (seen_open_paren) {\n        last_paren_index\
    \ = -1;\n        seen_open_paren = false;\n      }\n    }\n  }\n\n  // Push the\
    \ last index of the parenthesis we saw to the results.\n  if (last_paren_index\
    \ >= 0) {\n    results.push_back(last_paren_index);\n  }\n  return results;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpnr5hbow2: /tmp/tmpnr5hbow2.cpp:57: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113173
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> level_counter;\n    auto get_level =\
    \ [&level_counter, &paren_string] (size_t i) {\n        auto start_index = i;\n\
    \        auto paren_count = 0;\n        while ((start_index = paren_string.find('(',\
    \ start_index)) >= 0) {\n            ++paren_count;\n        }\n        level_counter.push_back((long)\
    \ (paren_count - 1));\n    };\n    for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n        if (paren_string[i] == '(') {\n            get_level(i);\n \
    \       }\n        else if (paren_string[i] == ')') {\n            auto level\
    \ = level_counter.back();\n            level_counter.pop_back();\n           \
    \ get_level(i + 1);\n            get_level(i);\n        }\n    }\n    return level_counter;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660113178
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> stack;\n  for (auto &it : paren_string)\
    \ {\n    switch (it) {\n    case '(':\n      stack.push_back(1);\n      break;\n\
    \    case ')':\n      if (stack.empty())\n        throw std::invalid_argument(\"\
    missing closing parentheses\");\n      stack.pop_back();\n      break;\n    case\
    \ '[':\n      if (stack.empty())\n        throw std::invalid_argument(\"missing\
    \ opening bracket to define index\");\n      stack.push_back(-1);\n      break;\n\
    \    case ']':\n      if (stack.empty())\n        throw std::invalid_argument(\"\
    missing closing bracket to define index\");\n      long &index = stack.back();\n\
    \      stack.pop_back();\n      if (index >= 0)\n        stack.push_back(index);\n\
    \      break;\n    case ' ':\n      break;\n    default:\n      stack.pop_back();\n\
    \      break;\n    }\n  }\n  if (stack.empty())\n    throw std::invalid_argument(\"\
    missing closing parentheses\");\n  stack.pop_back();\n  return stack;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptmcfte7n.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmptmcfte7n.cpp:33:10: error: jump to case label\n   33 |     case ' ':\n\
    \      |          ^~~\n/tmp/tmptmcfte7n.cpp:28:13: note:   crosses initialization\
    \ of \u2018long int& index\u2019\n   28 |       long &index = stack.back();\n\
    \      |             ^~~~~\n/tmp/tmptmcfte7n.cpp:35:5: error: jump to case label\n\
    \   35 |     default:\n      |     ^~~~~~~\n/tmp/tmptmcfte7n.cpp:28:13: note:\
    \   crosses initialization of \u2018long int& index\u2019\n   28 |       long\
    \ &index = stack.back();\n      |             ^~~~~\n"
  stdout: ''
  timestamp: 1660113173
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> max_level;\n  long current_level = 0;\n\
    \  long current_level_start = 0;\n  for(auto it = paren_string.begin(); it !=\
    \ paren_string.end(); ++it) {\n    bool is_open = *it == '(';\n    if(is_open)\
    \ {\n      if(current_level == max_level.size()) {\n        max_level.push_back(0);\n\
    \      }\n      if(max_level[current_level] == 0) {\n        max_level[current_level]\
    \ = current_level_start;\n      }\n      ++current_level;\n    } else {\n    \
    \  if(current_level == 0) break;\n      current_level--;\n    }\n  }\n  return\
    \ max_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n   \
    \ assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp3k_r6wbe: /tmp/tmp3k_r6wbe.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113173
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> v1;\n  long level = 1;\n  long paren_level\
    \ = 0;\n  bool is_paren_open = false;\n  bool is_in_parens = false;\n  for (int\
    \ i = 0; i < paren_string.length(); ++i) {\n    if (paren_string[i] == '(' &&\
    \ !is_in_parens) {\n      paren_level = level;\n      is_paren_open = true;\n\
    \      is_in_parens = true;\n      v1.push_back(paren_level);\n      level +=\
    \ 1;\n    } else if (paren_string[i] == ')' && !is_in_parens) {\n      is_in_parens\
    \ = false;\n      level -= 1;\n    } else if (paren_string[i] == '(' && is_in_parens)\
    \ {\n      level += 1;\n    } else if (paren_string[i] == ')' && is_in_parens)\
    \ {\n      level -= 1;\n    } else {\n      if (paren_string[i] == ' ' && !is_in_parens)\
    \ {\n        v1.push_back(level);\n        level = 1;\n      }\n    }\n  }\n \
    \ v1.push_back(level);\n  return v1;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp046_1v19: /tmp/tmp046_1v19.cpp:40: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113173
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // initialize vectors\n    std::vector<long> max_levels_parens;\n\
    \    std::vector<long> max_level_parens;\n    std::vector<long> level_parens;\n\
    \n    // iterate through each group\n    for (auto group : paren_string) {\n \
    \       // If group is empty skip and continue\n        if (group.empty()) {\n\
    \            continue;\n        }\n\n        // initialize vector for current\
    \ group\n        max_levels_parens.push_back(0);\n\n        // Iterate through\
    \ all characters in the current group\n        for (auto c : group) {\n      \
    \      // If current character is opening parenthesis, increment max level\n \
    \           if (c == '(') {\n                max_levels_parens.back()++;\n   \
    \         }\n\n            // If current character is closing parenthesis, decrement\
    \ max level\n            else if (c == ')') {\n                max_levels_parens.back()--;\n\
    \            }\n        }\n\n        // Store the maximum level of nesting for\
    \ the current group\n        max_level_parens.push_back(max_levels_parens.back());\n\
    \n        // initialize vector for current group\n        level_parens.push_back(max_levels_parens.back());\n\
    \    }\n\n    // Return the vector\n    return level_parens;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphpky6lja.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmphpky6lja.cpp:17:19: error: request for member \u2018empty\u2019 in\
    \ \u2018group\u2019, which is of non-class type \u2018char\u2019\n   17 |    \
    \     if (group.empty()) {\n      |                   ^~~~~\n/tmp/tmphpky6lja.cpp:25:23:\
    \ error: \u2018begin\u2019 was not declared in this scope\n   25 |         for\
    \ (auto c : group) {\n      |                       ^~~~~\n/tmp/tmphpky6lja.cpp:25:23:\
    \ note: suggested alternatives:\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmphpky6lja.cpp:2:\n/usr/include/c++/9/valarray:1224:5:\
    \ note:   \u2018std::begin\u2019\n 1224 |     begin(const valarray<_Tp>& __va)\n\
    \      |     ^~~~~\nIn file included from /usr/include/c++/9/filesystem:38,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n\
    \                 from /tmp/tmphpky6lja.cpp:2:\n/usr/include/c++/9/bits/fs_dir.h:516:3:\
    \ note:   \u2018std::filesystem::__cxx11::begin\u2019\n  516 |   begin(recursive_directory_iterator\
    \ __iter) noexcept\n      |   ^~~~~\n/tmp/tmphpky6lja.cpp:25:23: error: \u2018\
    end\u2019 was not declared in this scope\n   25 |         for (auto c : group)\
    \ {\n      |                       ^~~~~\n/tmp/tmphpky6lja.cpp:25:23: note: suggested\
    \ alternatives:\nIn file included from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:95,\n\
    \                 from /tmp/tmphpky6lja.cpp:2:\n/usr/include/c++/9/valarray:1244:5:\
    \ note:   \u2018std::end\u2019\n 1244 |     end(const valarray<_Tp>& __va)\n \
    \     |     ^~~\nIn file included from /usr/include/c++/9/filesystem:38,\n   \
    \              from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:129,\n \
    \                from /tmp/tmphpky6lja.cpp:2:\n/usr/include/c++/9/bits/fs_dir.h:520:3:\
    \ note:   \u2018std::filesystem::__cxx11::end\u2019\n  520 |   end(recursive_directory_iterator)\
    \ noexcept\n      |   ^~~\n"
  stdout: ''
  timestamp: 1660113173
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // First step: find out how many open parenthesis there\
    \ are\n    size_t opening_count = 0;\n    for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n        if (paren_string[i] == '(') ++opening_count;\n        if (paren_string[i]\
    \ == ')') --opening_count;\n    }\n    // Next step: find out which parenthesis\
    \ is closest.\n    // Start from the end of the string, since we only have one\
    \ open parenthesis.\n    size_t paren_closest = paren_string.size() - 1;\n   \
    \ std::vector<long> max_level_of_nesting(opening_count, 0);\n    for (size_t i\
    \ = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i] == ')') {\n\
    \            assert(opening_count != 0);\n            assert(paren_closest >=\
    \ i);\n            if (max_level_of_nesting[opening_count - 1] > max_level_of_nesting[paren_closest])\
    \ {\n                paren_closest = i;\n            }\n        }\n        if\
    \ (paren_string[i] == '(') {\n            assert(opening_count != 0);\n      \
    \      opening_count += 1;\n            max_level_of_nesting[opening_count - 1]++;\n\
    \        }\n    }\n    return max_level_of_nesting;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp4id5ea9m: /tmp/tmp4id5ea9m.cpp:28: std::vector<long int> parse_nested_parens(std::string):
    Assertion `opening_count != 0'' failed.

    '
  stdout: ''
  timestamp: 1660113174
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Use map to store the result \n    std::map<long, long>\
    \ nesting_level;\n    for(char c : paren_string) {\n        nesting_level[c]++;\n\
    \    }\n    std::vector<long> result;\n    for(auto &pair : nesting_level) {\n\
    \        if(pair.second == 1) {\n            result.push_back(pair.first);\n \
    \       }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp1jjzywfi: /tmp/tmp1jjzywfi.cpp:24: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113173
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_levels;\n    // initialize paren_levels\
    \ with 0 for all i\n    for (long i = 0;i < paren_string.size();++i)\n       \
    \ paren_levels.push_back(0);\n    for (long i = 0;i < paren_string.size();++i)\
    \ {\n        if (paren_string[i] == '(')\n            paren_levels[paren_string[i]]++;\n\
    \        else if (paren_string[i] == ')')\n            paren_levels[paren_string[i]]--;\n\
    \    }\n    return paren_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmphhneste8: /tmp/tmphhneste8.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113173
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // This function assumes one and only one opening parenthesis.\n\
    \    // If there are multiple opening parenthesis, it will output the maximum\
    \ level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n    if (paren_string.length() < 2 || paren_string[0]\
    \ != '(' || paren_string[paren_string.length()-1] != ')')\n        throw std::runtime_error(\"\
    This function assumes one and only one opening parenthesis.\");\n    std::vector<std::string>\
    \ paren_strings;\n    std::vector<long> levels_of_nesting;\n    std::vector<std::string>\
    \ tokens;\n    std::string current_token = \"\";\n    for (auto c : paren_string)\
    \ {\n        if (c == '(')\n            paren_strings.push_back(current_token);\n\
    \        else if (c == ')')\n            levels_of_nesting.push_back(tokens.size());\n\
    \        else\n            current_token += c;\n    }\n    for (auto c : current_token)\n\
    \        tokens.push_back(c);\n    int max_level = 0;\n    for (auto level : levels_of_nesting)\
    \ {\n        if (level > max_level)\n            max_level = level;\n    }\n \
    \   std::vector<long> max_levels_of_nesting(max_level + 1, 0);\n    for (auto\
    \ level : levels_of_nesting) {\n        max_levels_of_nesting[level] = 1;\n  \
    \  }\n    int total_level = 0;\n    for (auto level : levels_of_nesting) {\n \
    \       total_level += level;\n    }\n    for (auto level : max_levels_of_nesting)\
    \ {\n        if (level > total_level) {\n            throw std::runtime_error(\"\
    This function assumes one and only one opening parenthesis.\");\n        }\n \
    \   }\n    return max_levels_of_nesting;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpcknf38h9.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpcknf38h9.cpp:27:27: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(char&)\u2019\n   27\
    \ |         tokens.push_back(c);\n      |                           ^\nIn file\
    \ included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcknf38h9.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7:\
    \ note: candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660113173
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> pars;\n    bool pars_opened = false;\n\
    \    long pars_level = 1;\n    // Traverse through the string, one character at\
    \ a time, maintaining depth level.\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        char c = paren_string[i];\n        if (c == '(') {\n       \
    \     if (pars_opened) {\n                pars_level = pars_level + 1;\n     \
    \       } else {\n                pars_opened = true;\n                pars_level\
    \ = pars_level;\n            }\n        } else if (c == ')') {\n            if\
    \ (pars_opened) {\n                pars_level = pars_level - 1;\n            \
    \    if (pars_level == 0)\n                    pars_opened = false;\n        \
    \    } else {\n                pars.push_back(pars_level);\n                pars_opened\
    \ = false;\n            }\n        } else {\n            pars.push_back(pars_level);\n\
    \            pars_opened = false;\n        }\n    }\n    return pars;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmptfq621jr: /tmp/tmptfq621jr.cpp:40: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113174
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_stack;\n  for (auto c : paren_string)\
    \ {\n    if (c == '(') {\n      paren_stack.push_back(-1);\n    } else {\n   \
    \   auto i = paren_stack.size() - 1;\n      while (i != -1 && paren_stack[i] <\
    \ 0) {\n        i--;\n      }\n      if (paren_stack[i] == -1) {\n        paren_stack.push_back(-1);\n\
    \        paren_stack.push_back(long(0));\n      } else {\n        paren_stack.push_back(i);\n\
    \      }\n    }\n  }\n  return paren_stack;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmphbyn98ju: /tmp/tmphbyn98ju.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113174
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> depths(paren_string.size(), 0);\n   \
    \ bool is_left_open = true;\n    long cur_depth = 0;\n    for (size_t i = 0; i\
    \ < (paren_string.size()); i++) {\n        char ch = paren_string[i];\n      \
    \  if (ch == '(' || ch == '{' || ch == '[') {\n            if (is_left_open) {\n\
    \                depths[cur_depth] = cur_depth + 1;\n            } else {\n  \
    \              depths[cur_depth] = cur_depth;\n                is_left_open =\
    \ false;\n                cur_depth = 0;\n            }\n        }\n        if\
    \ (ch == ')' || ch == '}' || ch == ']') {\n            cur_depth--;\n        \
    \    is_left_open = true;\n        }\n    }\n    return depths;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpvs3w56dr: /tmp/tmpvs3w56dr.cpp:32: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113174
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_level;\n    long max_level_count\
    \ = 0;\n    // Loop through the string and keep track of parens level\n    for\
    \ (auto c : paren_string) {\n        if (c == '(') {\n            ++max_level_count;\n\
    \        } else if (c == ')') {\n            --max_level_count;\n        }\n \
    \       if (max_level_count < 0) {\n            max_level_count = 0;\n       \
    \ }\n        max_level.push_back(max_level_count);\n    }\n    // Get the max\
    \ level of nesting\n    for (auto i : max_level) {\n        if (i == 0) {\n  \
    \          break;\n        }\n        if (i > max_level_count) {\n           \
    \ max_level_count = i;\n        }\n    }\n    return max_level;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpt4t10h3g: /tmp/tmpt4t10h3g.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113174
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  // Initialize the result to empty vector\n  std::vector<long>\
    \ result;\n  // Initialize the current level of nesting level to 1\n  long level\
    \ = 1;\n  // Iterate through input string\n  for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n    // Handle current character\n    if (paren_string[i] == '(') {\n\
    \      // If level is less than or equal to current level of nesting level, append\
    \ the current level of nesting level to result vector\n      if (level <= level)\
    \ {\n        result.push_back(level);\n      }\n      // Increment current level\
    \ of nesting level\n      level++;\n    } else if (paren_string[i] == ')') {\n\
    \      // If level is greater than current level of nesting level, append the\
    \ current level of nesting level to result vector\n      if (level > level) {\n\
    \        result.push_back(level);\n      }\n      // Decrement current level of\
    \ nesting level\n      level--;\n    }\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpspu_cfmk: /tmp/tmpspu_cfmk.cpp:36: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113174
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> level;\n    auto level_iter = level.end(),\
    \ paren_iter = paren_string.end();\n    for (auto level_iter_ptr = level.end();\
    \ level_iter_ptr != level.end();) {\n        if (level_iter_ptr == paren_string.end())\
    \ {\n            level_iter_ptr = level.end();\n            paren_iter--;\n  \
    \          continue;\n        }\n        if (level_iter_ptr == level.end()) {\n\
    \            level.push_back(1);\n            paren_iter--;\n            continue;\n\
    \        }\n        if (paren_iter == paren_string.end() || *level_iter_ptr !=\
    \ *paren_iter) {\n            level.push_back(++level_iter_ptr - level_iter);\n\
    \            paren_iter--;\n            continue;\n        }\n        auto start_iter\
    \ = level_iter_ptr++;\n        auto end_iter = paren_iter;\n        ++level_iter_ptr;\n\
    \        ++paren_iter;\n        while (level_iter_ptr != level.end() && paren_iter\
    \ != paren_string.end() && *level_iter_ptr == *paren_iter) {\n            ++level_iter_ptr;\n\
    \            ++paren_iter;\n        }\n        if (level_iter_ptr != level.end()\
    \ || *level_iter_ptr != *paren_iter) {\n            level.push_back(level_iter_ptr\
    \ - start_iter);\n            paren_iter--;\n        }\n    }\n    return level;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfewayc36.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpfewayc36.cpp:10:5: error: inconsistent deduction for \u2018auto\u2019\
    : \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long int> >\u2019\
    \ and then \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019\n   10 |     auto level_iter = level.end(), paren_iter = paren_string.end();\n\
    \      |     ^~~~\n/tmp/tmpfewayc36.cpp:12:28: error: no match for \u2018operator==\u2019\
    \ (operand types are \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >\u2019 and \u2018std::__cxx11::basic_string<char>::iterator\u2019 {aka\
    \ \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char> >\u2019\
    })\n   12 |         if (level_iter_ptr == paren_string.end()) {\n      |     \
    \        ~~~~~~~~~~~~~~ ^~ ~~~~~~~~~~~~~~~~~~\n      |             |         \
    \                        |\n      |             |                            \
    \     __normal_iterator<char*,std::__cxx11::basic_string<char>>\n      |     \
    \        __normal_iterator<long int*,std::vector<long int>>\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpfewayc36.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpfewayc36.cpp:12:48: note: \
    \  deduced conflicting types for parameter \u2018_Container\u2019 (\u2018std::vector<long\
    \ int>\u2019 and \u2018std::__cxx11::basic_string<char>\u2019)\n   12 |      \
    \   if (level_iter_pt"
  stdout: ''
  timestamp: 1660113174
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> level_of_nesting;\n    auto token_itr\
    \ = paren_string.begin();\n    auto paren_itr = paren_string.end();\n    while\
    \ (token_itr != paren_itr) {\n        if (token_itr != paren_string.begin()) {\n\
    \            level_of_nesting.push_back(token_itr - paren_string.begin());\n \
    \       }\n        token_itr = std::find(token_itr, paren_string.end(), ' ');\n\
    \        paren_itr = token_itr;\n    }\n    return level_of_nesting;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpod_at19x: /tmp/tmpod_at19x.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113175
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_paren_depth;\n    long max_paren\
    \ = 0;\n    std::string curr_string = paren_string;\n    while (true) {\n    \
    \    long curr_len = curr_string.size();\n        if (curr_len == 0) {\n     \
    \       break;\n        }\n        if (curr_string[0] == '(' && curr_string[curr_len\
    \ - 1] == ')') {\n            long paren_depth = 1;\n            auto it = curr_string.begin()\
    \ + 1;\n            while (it < curr_string.end() && curr_string[*it] == ')')\
    \ {\n                ++it;\n                ++paren_depth;\n            }\n  \
    \          if (paren_depth <= max_paren) {\n                max_paren_depth.push_back(paren_depth);\n\
    \            }\n        } else if (curr_string[0] == '(' && curr_string[curr_len\
    \ - 1] != ')') {\n            max_paren = std::max(max_paren, 0);\n        }\n\
    \        curr_string.erase(0, curr_len);\n    }\n    return max_paren_depth;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpowpn5_my.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpowpn5_my.cpp:28:46: error: no matching function for call to \u2018\
    max(long int&, int)\u2019\n   28 |             max_paren = std::max(max_paren,\
    \ 0);\n      |                                              ^\nIn file included\
    \ from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpowpn5_my.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpowpn5_my.cpp:28:46: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019\
    \ and \u2018int\u2019)\n   28 |             max_paren = std::max(max_paren, 0);\n\
    \      |                                              ^\nIn file included from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpowpn5_my.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpowpn5_my.cpp:28:46:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018int\u2019)\n   28 |             max_paren = std::max(max_paren,\
    \ 0);\n      |                                              ^\nIn file included\
    \ from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \               "
  stdout: ''
  timestamp: 1660113174
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    // To traverse the string\
    \ in order, insert a closing parenthesis to the stack\n    // if a closing parenthesis\
    \ is encountered while traversing the string.\n    // If the closing parenthesis\
    \ stack is empty then insert a opening parenthesis.\n    std::vector<int> paren_stack(paren_string.size()\
    \ + 1);\n    for(size_t i = 0; i < paren_string.size(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            paren_stack[i] = 0;\n        } else if(paren_string[i]\
    \ == ')') {\n            // Look for an opening parenthesis in the stack starting\
    \ from i\n            // and pop the closing parenthesis if exists.\n        \
    \    // The opening parenthesis is at stack[i-1] and the closing one is at paren_stack[paren_stack.length-1].\n\
    \            if(paren_stack.size() >= 1 && paren_stack[paren_stack.size()-1] ==\
    \ paren_stack[paren_stack.size()-2]) {\n                paren_stack[paren_stack.size()-1]\
    \ = 0;\n            }\n        } else {\n            paren_stack[i] = paren_stack.size()\
    \ - 1;\n        }\n    }\n    result.push_back(paren_string.size());\n    for(size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        if(paren_string[i] == '(') {\n\
    \            // If there is a closing parenthesis at the current level,\n    \
    \        // add it to the stack. Otherwise, if there is an opening parenthesis,\n\
    \            // add it to the stack and add the level of nesting to the current\
    \ result.\n            if(paren_stack[i] != paren_stack.size()-1) {\n        \
    \        result.push_back(i);\n            }\n        } else if(paren_string[i]\
    \ == ')') {\n            // If the current level has a closing parenthesis,\n\
    \            // remove the closing parenthesis from the stack.\n            if(paren_stack[paren_stack.size()-1]\
    \ != 0) {\n                result.push_back(paren_stack[paren_stack.size()-1]);\n\
    \                paren_stack[paren_stack.size()-1] = 0;\n            }\n     \
    \   } else {\n            // If the current level has an opening parenthesis,\n\
    \            // add the level of nesting to the current result.\n            result.push_back(paren_stack[paren_stack.size()-1]);\n\
    \            paren_stack[paren_stack.size()-1]++;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp4krp05go: /tmp/tmp4krp05go.cpp:55: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113175
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  // We need to track how many parentheses we've seen, as well\
    \ as how many levels of parentheses there are\n  long num_paren = 0;\n  long num_level\
    \ = 0;\n  std::vector<long> result;\n  while(std::find_if(paren_string.begin(),\
    \ paren_string.end(), [](char c){return c == '(';}) != paren_string.end()) {\n\
    \    char c = *paren_string.find_first_of(\")\");\n    if(paren_string[paren_string.end()\
    \ - 1] == '(') {\n      ++num_level;\n    }\n    else {\n      num_level--;\n\
    \    }\n    if(num_level == 0) {\n      result.push_back(num_paren);\n      num_paren\
    \ = 0;\n    }\n    ++num_paren;\n    ++paren_string;\n  }\n  assert(num_paren\
    \ == 0);\n  assert(num_level == 0);\n  return result;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpoe01pm2t.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpoe01pm2t.cpp:14:45: error: invalid type argument of unary \u2018*\u2019\
    \ (have \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019})\n   14 |     char c = *paren_string.find_first_of(\")\"\
    );\n      |                                             ^\n/tmp/tmpoe01pm2t.cpp:15:20:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::string\u2019\
    \ {aka \u2018std::__cxx11::basic_string<char>\u2019} and \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019)\n   15 |     if(paren_string[paren_string.end()\
    \ - 1] == '(') {\n      |                    ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpoe01pm2t.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:1050:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator[](std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::size_type) const [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference\
    \ = const char&; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type\
    \ = long unsigned int]\u2019\n 1050 |       operator[] (size_type __pos) const\
    \ _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:1050:29:\
    \ note:   no known conversion for argument 1 from \u2018__gnu_cxx::__normal_iterator<char*,\
    \ std::__cxx11::basic_string<char> >\u2019 to \u2018st"
  stdout: ''
  timestamp: 1660113174
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  // Scan for the first set of parentheses and store the number\
    \ of nesting levels.\n  size_t num_opening_parens = paren_string.find('(');\n\
    \  std::vector<long> nesting_levels;\n  nesting_levels.push_back(num_opening_parens);\
    \ // Assume that every set of parentheses has at least one level of nesting.\n\
    \  for (size_t i = 1; i < paren_string.size(); i++) {\n    if (paren_string[i\
    \ - 1] == '(') {\n      nesting_levels.push_back(nesting_levels.back() + 1); //\
    \ Each level of nesting after the first is incremented by one.\n    } else {\n\
    \      nesting_levels.back() = nesting_levels.back() - 1;\n    }\n  }\n\n  //\
    \ Now that all the parentheses have been scanned, traverse the string and count\
    \ the levels of parentheses.\n  long max_level = 0;\n  for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n    if (paren_string[i] == '(') {\n      max_level\
    \ = std::max(max_level, nesting_levels[i]); // Keep track of the maximum level\
    \ of nesting.\n    }\n  }\n\n  // Now the maximum level of nesting can be determined,\
    \ so calculate the result.\n  std::vector<long> result(max_level);\n  for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n    if (paren_string[i] == '(') {\n\
    \      result[nesting_levels[i] - 1]++;\n    } else {\n      result[nesting_levels[i]]--;\n\
    \    }\n  }\n\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113175
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    long highest_level = 0;\n    std::vector<long> paren_level;\n\
    \    for (auto ch : paren_string) {\n        if (ch == '(') highest_level++;\n\
    \        else if (ch == ')') highest_level--;\n        paren_level.push_back(highest_level);\n\
    \    }\n    return paren_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpxarp88up: /tmp/tmpxarp88up.cpp:20: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113175
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> depths;\n    long temp_depth = 0;\n \
    \   for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n \
    \       if ((*it == '(') && (*( it + 1 ) == '(')) {\n            temp_depth++;\n\
    \        } else {\n            temp_depth--;\n            if (temp_depth == 0)\
    \ {\n                depths.push_back(temp_depth);\n            }\n        }\n\
    \    }\n    return depths;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpsyhrt4j5: /tmp/tmpsyhrt4j5.cpp:25: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113175
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_level;\n    paren_level.push_back(0);\n\
    \    size_t paren_start = 0;\n    size_t paren_count = 0;\n    for (size_t i =\
    \ 0; i < paren_string.size(); ++i) {\n        if (paren_string[i] == ')') {\n\
    \            paren_count--;\n        }\n        if (paren_string[i] == '(') {\n\
    \            paren_count++;\n        }\n        if (paren_count == 0) {\n    \
    \        paren_level.push_back(paren_start - paren_count);\n        }\n      \
    \  if (paren_count == 1 && paren_string[i] == '(') {\n            paren_start\
    \ = i + 1;\n        }\n    }\n    return paren_level;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp12dyh4va: /tmp/tmp12dyh4va.cpp:31: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113175
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> results;\n    auto it = paren_string.begin();\n\
    \    for ( ; !is_end(paren_string, it); ++it) {\n        if (*it == '(') {\n \
    \           ++it;\n            for ( ; !is_end(paren_string, it); ++it) {\n  \
    \              if (*it == ')') {\n                    results.emplace_back(std::distance(paren_string.begin(),\
    \ it));\n                    break;\n                }\n            }\n      \
    \  }\n        else if (*it == ')') {\n            results.emplace_back(std::distance(paren_string.begin(),\
    \ it));\n            break;\n        }\n    }\n    return results;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo_0zu9am.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpo_0zu9am.cpp:11:14: error: \u2018is_end\u2019 was not declared in this\
    \ scope; did you mean \u2018va_end\u2019?\n   11 |     for ( ; !is_end(paren_string,\
    \ it); ++it) {\n      |              ^~~~~~\n      |              va_end\n"
  stdout: ''
  timestamp: 1660113175
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    int open = 1;\n    int depth = 0;\n    std::vector<long>\
    \ result;\n    while (open != -1) {\n        std::vector<long> temp;\n       \
    \ for (auto &c : paren_string) {\n            if (c == '(') {\n              \
    \  depth++;\n                result.push_back(depth);\n                temp.push_back(depth);\n\
    \            }\n            if (c == '(') {\n                depth++;\n      \
    \          temp.push_back(depth);\n            }\n            if (c == ')') {\n\
    \                depth--;\n                temp.push_back(depth);\n          \
    \      if (depth <= 0) {\n                    open--;\n                }\n   \
    \         }\n            if (c == ')') {\n                depth--;\n         \
    \       temp.push_back(depth);\n            }\n        }\n        paren_string\
    \ = std::move(temp);\n    }\n    return result;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpvi0lwfsf.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpvi0lwfsf.cpp:36:38: error: no match for \u2018operator=\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018std::remove_reference<std::vector<long int>&>::type\u2019 {aka \u2018\
    std::vector<long int>\u2019})\n   36 |         paren_string = std::move(temp);\n\
    \      |                                      ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpvi0lwfsf.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:669:7:\
    \ note: candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&\
    \ std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(const std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc\
    \ = std::allocator<char>]\u2019\n  669 |       operator=(const basic_string& __str)\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/basic_string.h:669:37: note:\
    \   no known conversion for argument 1 from \u2018std::remove_reference<std::vector<long\
    \ int>&>::type\u2019 {aka \u2018std::vector<long int>\u2019} to \u2018const std::__cxx11::basic_string<char>&\u2019\
    \n  669 |       operator=(const basic_string& __str)\n      |                \
    \ ~~~~~~~~~~~~~~~~~~~~^~~~~\n/usr/include/c++/9/bits/basic_string.h:708:7: note:\
    \ candidate: \u2018std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT,\
    \ _Traits, _Alloc>::operator=(const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>;\
    \ _Alloc = std::allocator<char>]\u2019\n  708 |       operator"
  stdout: ''
  timestamp: 1660113175
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels(paren_string.size(), 0);\n\
    \  std::vector<long>::iterator iter;\n  iter = paren_string.begin();\n  while\
    \ (iter != paren_string.end()) {\n    bool found = false;\n    iter = paren_string.begin();\n\
    \    while (iter != paren_string.end() && !found && (*iter == *iter)) {\n    \
    \  iter++;\n      found = true;\n    }\n    if (found) {\n      std::vector<long>\
    \ new_paren_levels(iter + 1, 0);\n      std::size_t i = paren_levels.size() -\
    \ 1;\n      while (i != paren_levels.size() - 1) {\n        new_paren_levels[i]\
    \ = paren_levels[i + 1];\n        std::swap(paren_levels[i], paren_levels[i +\
    \ 1]);\n        std::swap(paren_levels[i + 1], new_paren_levels[i + 1]);\n   \
    \     std::swap(paren_levels[paren_levels.size() - 1], new_paren_levels[paren_levels.size()\
    \ - 1]);\n        std::swap(paren_levels[paren_levels.size() - 2], paren_levels[paren_levels.size()\
    \ - 1]);\n        i--;\n      }\n      paren_levels = new_paren_levels;\n    }\
    \ else {\n      iter++;\n    }\n  }\n  return paren_levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2mdqe6js.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp2mdqe6js.cpp:11:29: error: no match for \u2018operator=\u2019 (operand\
    \ types are \u2018std::vector<long int>::iterator\u2019 {aka \u2018__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >\u2019} and \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019})\n   11 |   iter = paren_string.begin();\n      |                 \
    \            ^\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp2mdqe6js.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:784:11:\
    \ note: candidate: \u2018constexpr __gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >& __gnu_cxx::__normal_iterator<long int*, std::vector<long int> >::operator=(const\
    \ __gnu_cxx::__normal_iterator<long int*, std::vector<long int> >&)\u2019\n  784\
    \ |     class __normal_iterator\n      |           ^~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:784:11:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019} to \u2018const __gnu_cxx::__normal_iterator<long int*, std::vector<long\
    \ int> >&\u2019\n/usr/include/c++/9/bits/stl_iterator.h:784:11: note: candidate:\
    \ \u2018constexpr __gnu_cxx::__normal_iterator<long int*, std::vector<long int>\
    \ >& __gnu_cxx::__normal_iterator<long int*, std::vector<long int> >::operator=(__gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >&&)\u2019\n/usr/include/c++/9/bits/stl_iterator.h:784:11:\
    \ note:   no known conversion for argument 1 from \u2018std::__cxx11::basic_string<char>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<char*, std::__cxx11::basic_string<char>\
    \ >\u2019} to \u2018__gnu_cxx::__normal_iterator<long int*, std::vecto"
  stdout: ''
  timestamp: 1660113175
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    result.push_back(1);\n \
    \   long cur_depth = 1;\n    std::string::size_type pos_start = 0;\n    std::string::size_type\
    \ pos_end = 0;\n\n    // Iterate over each symbol in the parenthesis string.\n\
    \    // If the symbol is a left parenthesis, increment the depth of nesting.\n\
    \    // If the symbol is a right parenthesis, decrement the depth of nesting.\n\
    \    // If the symbol is a space, ignore it.\n    // If the symbol is \"()\",\
    \ push an empty string to our vector and update the current depth.\n    // If\
    \ the symbol is \")\", pop off the empty string from the vector and update the\
    \ current depth.\n    while (pos_end != paren_string.size()) {\n        pos_start\
    \ = pos_end;\n        pos_end = paren_string.find(' ', pos_start + 1);\n     \
    \   // If we have a left parenthesis and a right parenthesis, increment the depth.\n\
    \        if (paren_string[pos_start] == '(' && paren_string[pos_end - 1] == ')')\
    \ {\n            cur_depth++;\n        // If we have a left parenthesis and a\
    \ space, decrement the depth.\n        } else if (paren_string[pos_start] == '('\
    \ && paren_string[pos_end] != ' ') {\n            cur_depth--;\n        // If\
    \ we have a right parenthesis and a space, increment the depth.\n        } else\
    \ if (paren_string[pos_end] == ')' && paren_string[pos_end - 1] != ' ') {\n  \
    \          cur_depth++;\n        // If we have a space, we ignore it.\n      \
    \  } else if (paren_string[pos_end] == ' ') {\n            pos_end++;\n      \
    \  // If we are at the end of the string, break.\n        } else if (paren_string[pos_end]\
    \ == '\\0') {\n            break;\n        }\n        // Push the depth to our\
    \ vector.\n        result.push_back(cur_depth);\n    }\n\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp9kl93h3w: /tmp/tmp9kl93h3w.cpp:48: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113175
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_levels_of_nesting;\n    std::stack<int>\
    \ paren_nesting_level;\n    long paren_nesting_level_size = 0;\n    for (char\
    \ c : paren_string) {\n        if (c == ')') {\n            if (paren_nesting_level.empty())\
    \ {\n                assert(false);\n            }\n            paren_nesting_level_size--;\n\
    \            if (paren_nesting_level_size == 0) {\n                max_levels_of_nesting.push_back(paren_nesting_level.top());\n\
    \                paren_nesting_level.pop();\n            }\n        } else if\
    \ (c == ')') {\n            paren_nesting_level.push(c);\n            paren_nesting_level_size++;\n\
    \        } else {\n            assert(false);\n        }\n    }\n    return max_levels_of_nesting;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpe7hz4wt2: /tmp/tmpe7hz4wt2.cpp:26: std::vector<long int> parse_nested_parens(std::string):
    Assertion `false'' failed.

    '
  stdout: ''
  timestamp: 1660113175
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // This hash maps strings to arrays of ints representing\n\
    \    // how deep in nesting each string is at.\n    std::unordered_map<std::string,\
    \ std::vector<int>> paren_depth;\n    paren_depth[\"((\")\"].push_back(0);\n \
    \   paren_depth[\")(\"].push_back(0);\n    paren_depth[\")\"][0].push_back(0);\n\
    \    size_t nesting_level = 0;\n    std::vector<long> nesting_level_values;\n\
    \    for (auto &c : paren_string) {\n        if (paren_depth.find(c) == paren_depth.end())\
    \ {\n            // New string and it's first character isn't a paren so keep\
    \ counting parens at level 0\n            paren_depth.insert({c, std::vector<int>()});\n\
    \        }\n        size_t paren_depth_of_interest = paren_depth.find(c)->second.size();\n\
    \        if (nesting_level + paren_depth_of_interest > nesting_level) {\n    \
    \        // The string is not nested at all so push it at level 0\n          \
    \  nesting_level_values.push_back(nesting_level);\n        } else {\n        \
    \    // The string is nested at some level so push it at level after the last\
    \ paren\n            nesting_level_values.push_back(nesting_level + paren_depth_of_interest);\n\
    \        }\n        nesting_level = nesting_level + paren_depth_of_interest;\n\
    \    }\n    return nesting_level_values;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpf10n_j1k.cpp:12:22: warning: missing terminating \" character\n\
    \   12 |     paren_depth[\"((\")\"].push_back(0);\n      |                   \
    \   ^\n/tmp/tmpf10n_j1k.cpp:12:22: error: missing terminating \" character\n \
    \  12 |     paren_depth[\"((\")\"].push_back(0);\n      |                    \
    \  ^~~~~~~~~~~~~~~~\n/tmp/tmpf10n_j1k.cpp: In function \u2018std::vector<long\
    \ int> parse_nested_parens(std::string)\u2019:\n/tmp/tmpf10n_j1k.cpp:12:21: error:\
    \ expected \u2018]\u2019 before \u2018)\u2019 token\n   12 |     paren_depth[\"\
    ((\")\"].push_back(0);\n      |                     ^\n      |               \
    \      ]\n/tmp/tmpf10n_j1k.cpp:12:21: error: expected \u2018;\u2019 before \u2018\
    )\u2019 token\n   12 |     paren_depth[\"((\")\"].push_back(0);\n      |     \
    \                ^\n      |                     ;\n/tmp/tmpf10n_j1k.cpp:14:25:\
    \ error: request for member \u2018push_back\u2019 in \u2018(& paren_depth.std::unordered_map<std::__cxx11::basic_string<char>,\
    \ std::vector<int> >::operator[](std::__cxx11::basic_string<char>(((const char*)\"\
    )\"), std::allocator<char>())))->std::vector<int>::operator[](0)\u2019, which\
    \ is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<int>, int>::value_type\u2019\
    \ {aka \u2018int\u2019}\n   14 |     paren_depth[\")\"][0].push_back(0);\n   \
    \   |                         ^~~~~~~~~\n/tmp/tmpf10n_j1k.cpp:18:31: error: no\
    \ matching function for call to \u2018std::unordered_map<std::__cxx11::basic_string<char>,\
    \ std::vector<int> >::find(char&)\u2019\n   18 |         if (paren_depth.find(c)\
    \ == paren_depth.end()) {\n      |                               ^\nIn file included\
    \ from /usr/include/c++/9/unordered_map:47,\n                 from /usr/include/c++/9/functional:61,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf10n_j1k.cpp:2:\n/usr/include/c++/9/bits/unordered_map.h:921:7:\
    \ note: candidate: \u2018std::unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator\
    \ std::unordered_map<_Key, _Tp, _Hash, _Pre"
  stdout: ''
  timestamp: 1660113174
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  // Convert parenthesis into array of strings.\n  std::vector<std::string>\
    \ paren_groups;\n  std::string current_group;\n  size_t current_group_len = 0;\n\
    \  for (size_t i = 0; i < paren_string.length(); ++i) {\n    if (paren_string[i]\
    \ == '(') {\n      current_group.push_back(paren_string[i]);\n      current_group_len++;\n\
    \    } else if (paren_string[i] == ')') {\n      // If current group is not empty,\
    \ then add it to current group and start a new group.\n      if (current_group\
    \ != \"\") {\n        paren_groups.push_back(std::move(current_group));\n    \
    \    current_group.clear();\n        current_group_len = 0;\n      }\n    } else\
    \ if (paren_string[i] == ',') {\n      // If current group is empty and end of\
    \ a group, add it to current group and start a new one.\n      if (current_group\
    \ == \"\" && current_group_len > 0) {\n        paren_groups.push_back(std::move(current_group));\n\
    \        current_group.clear();\n        current_group_len = 0;\n      }\n   \
    \ } else {\n      current_group.push_back(paren_string[i]);\n      current_group_len++;\n\
    \    }\n  }\n  // Add final group to final group.\n  if (current_group != \"\"\
    ) {\n    paren_groups.push_back(std::move(current_group));\n  }\n\n  // Compute\
    \ max depth of nested parentheses.\n  int max_depth = 0;\n  for (size_t i = 0;\
    \ i < paren_groups.size(); ++i) {\n    max_depth = (std::max(max_depth, paren_groups[i].size()));\n\
    \  }\n\n  // Return max depth and nested parentheses.\n  return {max_depth, std::vector<long>(paren_groups.size(),\
    \ 0)};\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxlrzy0hi.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpxlrzy0hi.cpp:44:60: error: no matching function for call to \u2018\
    max(int&, std::__cxx11::basic_string<char>::size_type)\u2019\n   44 |     max_depth\
    \ = (std::max(max_depth, paren_groups[i].size()));\n      |                  \
    \                                          ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpxlrzy0hi.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpxlrzy0hi.cpp:44:60: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018int\u2019\
    \ and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018long\
    \ unsigned int\u2019})\n   44 |     max_depth = (std::max(max_depth, paren_groups[i].size()));\n\
    \      |                                                            ^\nIn file\
    \ included from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpxlrzy0hi.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpxlrzy0hi.cpp:44:60:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    int\u2019 and \u2018std::__cxx11::basic_string<char>::size_type\u2019 {aka \u2018\
    long unsigned int\u2019})\n   44 |     max_depth = (std::max("
  stdout: ''
  timestamp: 1660113175
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> res;\n  long current_level = 0;\n  int\
    \ index = 0;\n  bool inside_first_paren = false;\n\n  for (char c : paren_string)\
    \ {\n    if (c == '(') inside_first_paren = true;\n    if (c == '(' && inside_first_paren\
    \ == true) current_level++;\n    else if (c == ')' && inside_first_paren == true)\
    \ {\n      if (current_level == 0) res.push_back(index);\n      current_level--;\n\
    \    }\n    index = index;\n  }\n  return res;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpktom3559: /tmp/tmpktom3559.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113175
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Your code here\n    // Complete the code here\n    std::vector<long>\
    \ result;\n    std::string opening_paren = \"(\";\n    std::string closing_paren\
    \ = \")\";\n    std::string opn = \"()\";\n    std::string cnl = \"()\";\n\n \
    \   for (size_t i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i]\
    \ == opening_paren) {\n            int counter = 0;\n            while (i < paren_string.size()\
    \ && paren_string[i] != closing_paren) {\n                i++;\n             \
    \   counter++;\n            }\n            result.push_back(counter);\n      \
    \  }\n        if (paren_string[i] == closing_paren) {\n            int counter\
    \ = 0;\n            while (i < paren_string.size() && paren_string[i] != opening_paren)\
    \ {\n                i++;\n                counter++;\n            }\n       \
    \     result.push_back(counter);\n        }\n        if (paren_string[i] == opn)\
    \ {\n            int counter = 0;\n            while (i < paren_string.size()\
    \ && paren_string[i] != cnl) {\n                i++;\n                counter++;\n\
    \            }\n            result.push_back(counter);\n        }\n        if\
    \ (paren_string[i] == cnl) {\n            int counter = 0;\n            while\
    \ (i < paren_string.size() && paren_string[i] != opn) {\n                i++;\n\
    \                counter++;\n            }\n            result.push_back(counter);\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpd2d_5err.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpd2d_5err.cpp:18:29: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   18 |         if (paren_string[i] == opening_paren) {\nIn file included\
    \ from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpd2d_5err.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpd2d_5err.cpp:18:32:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   18 |         if (paren_string[i] == opening_paren)\
    \ {\n      |                                ^~~~~~~~~~~~~\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpd2d_5err.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpd2d_5err.cpp:18:32: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>\u2019 and \u2018"
  stdout: ''
  timestamp: 1660113175
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n\tstd::vector<long> paren_levels;\n\tstd::string temp = \"\"\
    ;\n\tbool is_open = false;\n\tbool is_nested = false;\n\tfor (char c : paren_string)\
    \ {\n\t\tif (c == '(') {\n\t\t\tif (!is_nested) {\n\t\t\t\tparen_levels.push_back(0);\n\
    \t\t\t\tis_nested = true;\n\t\t\t\tis_open = true;\n\t\t\t}\n\t\t\tparen_levels.back()++;\n\
    \t\t} else if (c == ')') {\n\t\t\tparen_levels.back()--;\n\t\t\tis_nested = false;\n\
    \t\t\tis_open = false;\n\t\t\ttemp += c;\n\t\t} else if (is_open && (c == ' '\
    \ || c == '\\n' || c == '\\t')) {\n\t\t\tis_open = false;\n\t\t\ttemp += c;\n\t\
    \t}\n\t}\n\tif (is_nested) {\n\t\tthrow std::runtime_error(\"Error: nested parenthesis\
    \ unbalanced.\");\n\t}\n\treturn paren_levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpieytaag8: /tmp/tmpieytaag8.cpp:38: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> max_levels;\n  // We keep track of the\
    \ number of opening parentheses encountered in the string\n  long opening_count\
    \ = 0;\n  // We keep track of the number of closing parentheses encountered in\
    \ the string\n  long closing_count = 0;\n  for (char c : paren_string)\n    if\
    \ (c == '(') opening_count++;\n    else if (c == ')') closing_count++;\n    else\
    \ if (opening_count > closing_count) max_levels.push_back(opening_count - 1);\n\
    \    else if (opening_count == closing_count) max_levels.push_back(opening_count\
    \ - 1);\n  return max_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpu0vbrdan: /tmp/tmpu0vbrdan.cpp:23: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Store all the nested level of nesting for each parentheses.\n\
    \    std::vector<long> nesting_level;\n    long level = 0;\n    // Each new parentheses\
    \ group starts with level zero.\n    nesting_level.push_back(level);\n\n    for\
    \ (auto paren = paren_string.rbegin(); paren != paren_string.rend(); ++paren)\
    \ {\n        // Add 1 if the current parentheses group matches the nested parentheses.\n\
    \        if (*paren == ' ') {\n            nesting_level.push_back(level + 1);\n\
    \        } else if (*paren == ')') {\n            ++level;\n        }\n    }\n\
    \    return nesting_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpa8pr32yy: /tmp/tmpa8pr32yy.cpp:27: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113175
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::string opening_parens = \"(\";\n    std::string closing_parens\
    \ = \")\";\n    std::string opening_parens_count = paren_string;\n    int opening_parens_index_of_closing_parens\
    \ = 0;\n    std::string curr_open_parens;\n    std::vector<long> result;\n   \
    \ while (opening_parens_index_of_closing_parens != std::string::npos) {\n    \
    \    opening_parens_index_of_closing_parens = opening_parens_count.find(closing_parens,\
    \ opening_parens_index_of_closing_parens + 1);\n        curr_open_parens = opening_parens.substr(0,\
    \ opening_parens_index_of_closing_parens);\n        result.push_back(stoi(curr_open_parens));\n\
    \        opening_parens_count = opening_parens.substr(opening_parens_index_of_closing_parens\
    \ + closing_parens.size(), opening_parens_count.length());\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  stoi\n"
  stdout: ''
  timestamp: 1660113176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Recursive function to parse string\n    std::vector<long>\
    \ levels;\n    if (paren_string.size() == 1) {\n        levels.push_back(1);\n\
    \        return levels;\n    }\n    std::string left_paren, right_paren;\n   \
    \ std::string temp_str = paren_string;\n    std::size_t left_paren_index = paren_string.find(\"\
    (\"), right_paren_index;\n    // Remove left paren\n    temp_str = temp_str.substr(left_paren_index);\n\
    \    left_paren = temp_str.substr(0, left_paren_index);\n    temp_str = temp_str.substr(left_paren_index\
    \ + 1);\n    // Remove right paren\n    temp_str = temp_str.substr(0, right_paren_index\
    \ = temp_str.find(')'));\n    right_paren = temp_str.substr(right_paren_index\
    \ + 1);\n    std::size_t left_count = parse_nested_parens(left_paren).size();\n\
    \    std::size_t right_count = parse_nested_parens(right_paren).size();\n    if\
    \ (left_paren != right_paren) {\n        levels.push_back(left_count + right_count);\n\
    \        temp_str = temp_str.substr(left_paren_index);\n    }\n    levels.push_back(left_count\
    \ + right_count);\n    temp_str = temp_str.substr(left_paren_index + 1);\n   \
    \ while (temp_str.size() > 0) {\n        auto count = temp_str.find('(');\n  \
    \      if (count != std::string::npos) {\n            temp_str.erase(count, 1);\n\
    \        } else {\n            break;\n        }\n    }\n    if (temp_str.size()\
    \ > 0) {\n        levels.push_back(std::stoi(temp_str));\n    }\n    return levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 2) > this->size() (which is 1)\n"
  stdout: ''
  timestamp: 1660113176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> parens_level;\n    auto it = paren_string.begin();\n\
    \    long parens_level_count = 1;\n    while (it != paren_string.end()) {\n  \
    \      // Check if first character is opening and next character is closing parenthesis.\n\
    \        if (*it == '(' && parens_level_count == 0) {\n            parens_level_count++;\n\
    \        } else if (*it == ')') {\n            if (parens_level_count == 0) {\n\
    \                throw std::invalid_argument(\"Input to this function needs to\
    \ be a single group of parenthesis\");\n            }\n            parens_level_count--;\n\
    \        }\n        it++;\n    }\n    parens_level.assign(parens_level_count,\
    \ 0);\n    return parens_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::invalid_argument'\n\
    \  what():  Input to this function needs to be a single group of parenthesis\n"
  stdout: ''
  timestamp: 1660113175
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Find the first open parenthesis\n    size_t start_paren\
    \ = paren_string.find_first_of(\"(\");\n    // If no open parenthesis found, return\
    \ empty vector\n    if (start_paren == std::string::npos) return std::vector<long>();\n\
    \    // Find the first closed parenthesis\n    size_t end_paren = paren_string.find_first_of(\"\
    )\");\n    // If no closed parenthesis found, return empty vector\n    if (end_paren\
    \ == std::string::npos) return std::vector<long>();\n    // If no closed parenthesis\
    \ found after the first open parenthesis, return empty vector\n    if (end_paren\
    \ < start_paren) return std::vector<long>();\n    // Find the index of the closing\
    \ parenthesis\n    size_t parens_size = end_paren - start_paren;\n    // If no\
    \ closed parenthesis found after the first open parenthesis, return empty vector\n\
    \    if (parens_size <= 0) return std::vector<long>();\n    // Create a vector\
    \ that stores the index of each open parenthesis group\n    std::vector<long>\
    \ paren_indexes(parens_size + 1);\n    // Find the index of the corresponding\
    \ open parenthesis group\n    size_t paren_index = 0;\n    paren_indexes[0] =\
    \ paren_index;\n    for (size_t i = 1; i < paren_indexes.size(); i++) {\n    \
    \    if (paren_string[paren_index] == '(') {\n            paren_indexes[i] = paren_index;\n\
    \        }\n        if (paren_string[paren_index] == ')') {\n            paren_indexes[i]\
    \ = paren_index;\n            paren_index++;\n        }\n    }\n    // Find the\
    \ deepest nesting level among all the group\n    long deepest_level = 0;\n   \
    \ for (size_t i = 0; i < paren_indexes.size(); i++) {\n        long current_level\
    \ = paren_indexes[i] - paren_indexes[paren_indexes[i] + 1];\n        deepest_level\
    \ = std::max(deepest_level, current_level);\n    }\n    // Return the deepest\
    \ level of nesting\n    return std::vector<long>({deepest_level});\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpdvo2y0h7: /tmp/tmpdvo2y0h7.cpp:48: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  std::stringstream ss(paren_string);\n\
    \  std::string token;\n  long level = 0;\n  while (std::getline(ss, token, ' '))\
    \ {\n    if (level == 0) {\n      paren_levels.push_back(level);\n      level++;\n\
    \    }\n    if (level == 1) {\n      level++;\n    }\n  }\n  return paren_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpm9ee0url: /tmp/tmpm9ee0url.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113176
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    int level = 0;\n    std::vector<long> max_level;\n    std::vector<long>\
    \ parenthesis_level;\n    std::vector<char> parenthesis;\n    for (char ch: paren_string)\
    \ {\n        if (ch == '(') level++;\n        else if (ch == ')') level--;\n \
    \       if (level == 0 && !parenthesis.empty()) {\n            parenthesis_level.push_back(parenthesis.size());\n\
    \            if (parenthesis.size() > max_level.back()) max_level.push_back(parenthesis.size());\n\
    \        }\n        parenthesis.push_back(ch);\n    }\n    if (parenthesis.size()\
    \ == 0) return max_level;\n    std::vector<long> ans;\n    for (size_t i = 0;\
    \ i < max_level.size(); i++) {\n        if (parenthesis_level[i] < ans.size())\
    \ ans.resize(parenthesis_level[i]);\n        if (ans.back() >= max_level[i]) ans.resize(max_level[i]);\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113176
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    levels.push_back(0);\n \
    \   std::vector<bool> opened;\n    opened.push_back(false);\n    opened.push_back(true);\
    \ // add level to levels array initially\n    int max_depth = 0;\n    for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(' &&\
    \ opened[i]) {\n            opened.erase(std::find(opened.begin(), opened.end(),\
    \ true));\n            levels[levels.size() - 1] = levels.size();\n          \
    \  opened.push_back(true);\n        } else if (paren_string[i] == ')' && opened[i])\
    \ {\n            opened.erase(std::find(opened.begin(), opened.end(), true));\n\
    \            if (max_depth > levels[levels.size() - 1])\n                max_depth\
    \ = levels[levels.size() - 1];\n            opened.push_back(false);\n       \
    \ } else {\n            opened.push_back(false);\n        }\n    }\n    levels.erase(std::find(levels.begin(),\
    \ levels.end(), max_depth));\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_nesting_levels;\n  std::stack<long>\
    \ paren_nesting_levels_stack;\n  long level_counter = 1;\n  for (auto it = paren_string.begin();\
    \ it != paren_string.end(); it++) {\n    if (*it == ' ') {\n      long paren_nesting_level\
    \ = level_counter;\n      while (level_counter != paren_nesting_level) {\n   \
    \     paren_nesting_levels_stack.push(level_counter);\n        level_counter++;\n\
    \      }\n      paren_nesting_levels_stack.push(level_counter);\n      level_counter++;\n\
    \    } else {\n      level_counter++;\n    }\n  }\n  paren_nesting_levels.push_back(level_counter\
    \ - 1);\n  while (!paren_nesting_levels_stack.empty()) {\n    long paren_nesting_level\
    \ = paren_nesting_levels_stack.top();\n    paren_nesting_levels_stack.pop();\n\
    \    paren_nesting_levels.push_back(paren_nesting_level);\n  }\n  return paren_nesting_levels;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpjwt1af5_: /tmp/tmpjwt1af5_.cpp:35: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113176
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::stack<long> s;\n    std::vector<long> nestings;\n\
    \    for (char c : paren_string) {\n        if (c == '(')\n            s.push((long)\
    \ s.size());\n        else if (c == ')')\n            while (s.size() != s.pop())\n\
    \                nestings.push_back(s.size());\n    }\n    return nestings;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx0bnvr29.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpx0bnvr29.cpp:15:29: error: invalid operands of types \u2018std::stack<long\
    \ int>::size_type\u2019 {aka \u2018long unsigned int\u2019} and \u2018void\u2019\
    \ to binary \u2018operator!=\u2019\n   15 |             while (s.size() != s.pop())\n\
    \      |                    ~~~~~~~~ ^~ ~~~~~~~\n      |                     \
    \     |          |\n      |                          |          void\n      |\
    \                          std::stack<long int>::size_type {aka long unsigned\
    \ int}\n"
  stdout: ''
  timestamp: 1660113175
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Write your code here.\n    // For each character\n \
    \   std::vector<std::string> paren_list;\n    int level = 1;\n    for (int i =\
    \ 0; i < paren_string.length(); i++) {\n        // if the character is a parenthesis\n\
    \        if (paren_string[i] == '(') {\n            // increment the level\n \
    \           level++;\n            // append the level to the paren_list vector\n\
    \            paren_list.push_back(level);\n        } else if (paren_string[i]\
    \ == ')') {\n            // decrement the level\n            level--;\n      \
    \      // append the level to the paren_list vector\n            paren_list.push_back(level);\n\
    \        }\n    }\n\n    // Sort the vector from top to bottom\n    std::sort(paren_list.begin(),\
    \ paren_list.end(), std::greater<>());\n\n    std::vector<long> level_list;\n\
    \    long max_level = paren_list[0];\n\n    // Append the max_level to level_list\
    \ vector\n    level_list.push_back(max_level);\n\n    // While the level list\
    \ has elements greater than max_level\n    while (level_list.size() > 0 && max_level\
    \ > 0) {\n        // Get the max level\n        max_level = level_list.back();\n\
    \n        // Remove the first element from the list if the level is less than\
    \ max_level\n        if (level_list.front() <= max_level) {\n            level_list.pop_back();\n\
    \        }\n\n        // Increment the next level\n        level_list.push_back(level_list.back()\
    \ + 1);\n    }\n\n    return level_list;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpy2gkdp2b.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpy2gkdp2b.cpp:19:39: error: no matching function for call to \u2018\
    std::vector<std::__cxx11::basic_string<char> >::push_back(int&)\u2019\n   19 |\
    \             paren_list.push_back(level);\n      |                          \
    \             ^\nIn file included from /usr/include/c++/9/vector:67,\n       \
    \          from /usr/include/c++/9/functional:62,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpy2gkdp2b.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1184:7: note:\
    \ candidate: \u2018void std::vector<_Tp, _Alloc>::push_back(const value_type&)\
    \ [with _Tp = std::__cxx11::basic_string<char>; _Alloc = std::allocator<std::__cxx11::basic_string<char>\
    \ >; std::vector<_Tp, _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\
    \n 1184 |       push_back(const value_type& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1184:35:\
    \ note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const\
    \ value_type&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n\
    \ 1184 |       push_back(const value_type& __x)\n      |                 ~~~~~~~~~~~~~~~~~~^~~\n\
    /usr/include/c++/9/bits/stl_vector.h:1200:7: note: candidate: \u2018void std::vector<_Tp,\
    \ _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = std::__cxx11::basic_string<char>;\
    \ _Alloc = std::allocator<std::__cxx11::basic_string<char> >; std::vector<_Tp,\
    \ _Alloc>::value_type = std::__cxx11::basic_string<char>]\u2019\n 1200 |     \
    \  push_back(value_type&& __x)\n      |       ^~~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1200:30:\
    \ note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018std::vector<std::__cxx11::basic_string<char>\
    \ >::value_type&&\u2019 {aka \u2018std::__cxx11::basic_string<char>&&\u2019}\n\
    \ 1200 |       push_back(value_type&& __x)\n      |                 ~~~~~~~~~~~~~^~~\n\
    /tmp/tmp"
  stdout: ''
  timestamp: 1660113175
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  // Traverse string from right\
    \ to left\n  size_t index = 0;\n  size_t paren_index = paren_string.length();\n\
    \  for (size_t i = paren_index; i > 0; --i) {\n    if (paren_string[i] == '(')\
    \ {\n      index++;\n    } else if (paren_string[i] == ')') {\n      index--;\n\
    \    }\n    if (index == 0) {\n      // We have reached a level where there are\
    \ no more parentheses\n      // E.g. \"()()\" has 1 level of nesting while \"\
    (()\" has none.\n      result.push_back(paren_index);\n    }\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpaqxo6fpi: /tmp/tmpaqxo6fpi.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_level;\n    std::vector<long> level;\n\
    \    std::vector<long> level_count;\n    std::vector<long> stack_of_parentheses_count;\n\
    \n    // Initialize the max level to 0 as there is one level of nesting for each\
    \ bracket.\n    max_level.push_back(0);\n    // Initialize the level array and\
    \ level-count array to 1 for every bracket.\n    level.push_back(1);\n    level_count.push_back(0);\n\
    \n    // Iterate over each character of the string and increment the level-count\
    \ for every opening bracket.\n    for(char c: paren_string) {\n        if(c ==\
    \ '(') {\n            level_count.push_back(1); // level_count[level_count[level-1]\
    \ inc. for every opening bracket.\n        }\n        else if(level_count.back()\
    \ == 1) {\n            level.push_back(level_count.back());\n            level_count.pop_back();\n\
    \        }\n        else {\n            int level_diff = level_count.back() -\
    \ 1;\n            int level_level_diff = level[level_diff] - level[level_diff\
    \ - 1];\n            if(level_level_diff > 0) {\n                stack_of_parentheses_count.push_back(level_level_diff);\n\
    \            }\n            level_count.pop_back();\n            level[level_diff]\
    \ += 1;\n        }\n    }\n\n    // Iterate over each level and decrement the\
    \ level-count for every closing bracket.\n    for(size_t i = level_count.size()\
    \ - 1; i >= 0; i--) {\n        if(level_count.at(i) == 0) {\n            max_level.push_back(level.at(i));\n\
    \        }\n        level[level.size() - 1 - i] += 1;\n    }\n\n    return max_level;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'munmap_chunk(): invalid pointer

    '
  stdout: ''
  timestamp: 1660113176
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> level;\n    level.push_back(0);\n   \
    \ // This function finds the deepest level of nesting for the given string.\n\
    \    std::string curr_parens = paren_string;\n    while (curr_parens != \"()\"\
    ) {\n        auto it = curr_parens.find(\"(\", 0);\n        if (it != curr_parens.npos)\n\
    \            curr_parens.erase(it, 1);\n        auto it = curr_parens.find(\"\
    )\", 0);\n        if (it != curr_parens.npos)\n            curr_parens.erase(it,\
    \ 1);\n        level.push_back(level.size());\n        curr_parens = paren_string;\n\
    \    }\n    return level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnknvpues.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpnknvpues.cpp:17:14: error: conflicting declaration \u2018auto it\u2019\
    \n   17 |         auto it = curr_parens.find(\")\", 0);\n      |             \
    \ ^~\n/tmp/tmpnknvpues.cpp:14:14: note: previous declaration as \u2018long unsigned\
    \ int it\u2019\n   14 |         auto it = curr_parens.find(\"(\", 0);\n      |\
    \              ^~\n"
  stdout: ''
  timestamp: 1660113176
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> output_nesting;\n    output_nesting.push_back(0);\n\
    \    for (size_t i = 1; i < paren_string.size(); ++i) {\n        size_t paren_start_pos\
    \ = paren_string.find_first_of(' ', i); // find first space\n        size_t paren_end_pos\
    \ = paren_string.find_first_of('(', i); // find first open parenthesis\n     \
    \   std::string current_paren_string = paren_string.substr(i, paren_end_pos -\
    \ i); // remove leading spaces and opening parenthesis\n        bool has_open_paren\
    \ = paren_start_pos != std::string::npos;\n        bool has_close_paren = current_paren_string.find_first_of(')')\
    \ != std::string::npos;\n        if (has_open_paren && has_close_paren) {\n  \
    \          output_nesting.push_back(0);\n            output_nesting.back() +=\
    \ output_nesting[output_nesting.size() - 1] + 1; // push the deepest nesting level\n\
    \            output_nesting.back() += parse_nested_parens(current_paren_string).back();\n\
    \        } else if (has_open_paren) {\n            output_nesting.push_back(0);\n\
    \            output_nesting.back() += output_nesting[output_nesting.size() - 1]\
    \ + 1; // push the deepest nesting level\n        } else if (has_close_paren)\
    \ {\n            output_nesting.back() += parse_nested_parens(current_paren_string).back();\n\
    \        }\n        i = paren_end_pos + 1; // increase the starting position of\
    \ the next loop\n    }\n    return output_nesting;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660113181
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  long prev_level = 0;\n  long\
    \ level = 0;\n  bool prev_is_empty = true;\n  for (char ch : paren_string) {\n\
    \    // If the previous character was a parantheses and the current character\
    \ is not, then we increment the level\n    if (prev_is_empty) {\n      level++;\n\
    \      // If the level is not yet less than the previous level, then we output\
    \ the level\n      if (level > prev_level) {\n        result.push_back(level);\n\
    \      }\n    }\n    // If the current character is a parantheses, then we increase\
    \ the level\n    if (ch == '(') {\n      level++;\n      // If the level is still\
    \ greater than the previous level, then we output the level\n      if (level >\
    \ prev_level) {\n        result.push_back(level);\n      }\n    }\n    // If the\
    \ current character is a closing parantheses, then we decrease the level\n   \
    \ if (ch == ')') {\n      level--;\n      // If the level is less than the previous\
    \ level, then we output the level\n      if (level < prev_level) {\n        result.push_back(level);\n\
    \      }\n    }\n    // If the current character is a space, we can output a 0\n\
    \    if (ch == ' ') {\n      result.push_back(0);\n    }\n    // If the current\
    \ character is not a space, we can output the previous level\n    prev_level =\
    \ level;\n    prev_is_empty = ch == ' ' || ch == ')';\n  }\n  return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmphv17gy8n: /tmp/tmphv17gy8n.cpp:50: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    long max_level = 0;\n    std::vector<long> parens_level;\n\
    \    for (size_t i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i]\
    \ == '(') {\n            parens_level.push_back(max_level + 1);\n        } else\
    \ if (paren_string[i] == ')') {\n            auto prev = std::find(parens_level.begin(),\
    \ parens_level.end(), max_level);\n            if (prev != parens_level.end())\
    \ {\n                max_level = *prev;\n                parens_level.pop_back();\n\
    \            } else {\n                return std::vector<long>();\n         \
    \   }\n        }\n    }\n    parens_level.push_back(max_level + 1);\n    return\
    \ parens_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpiwv3zy94: /tmp/tmpiwv3zy94.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result_vec(paren_string.size(), 0);\n \
    \ bool isOpenBracket = false;\n  for (int i = 0; i < (int) paren_string.size();\
    \ i++) {\n    if (paren_string[i] == '(') {\n      isOpenBracket = true;\n   \
    \   result_vec[i] = 0;\n    } else if (paren_string[i] == ')') {\n      isOpenBracket\
    \ = false;\n      result_vec[i] = 1;\n    } else {\n      if (!isOpenBracket)\
    \ {\n        result_vec[i]++;\n      }\n    }\n  }\n  return result_vec;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpme0pz30h: /tmp/tmpme0pz30h.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113176
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_nesting_level;\n  if (paren_string.size()\
    \ == 0) return paren_nesting_level;\n  std::string paren_opening_parens = \"((\"\
    ;\n  std::string paren_closing_parens = \")\";\n  std::string opening_paren_count\
    \ = paren_opening_parens;\n  std::string closing_paren_count = paren_closing_parens;\n\
    \  for (int i = 0; i < paren_string.size(); i++) {\n    if (paren_string[i] ==\
    \ paren_opening_parens) opening_paren_count += 1;\n    else if (paren_string[i]\
    \ == paren_closing_parens) closing_paren_count += 1;\n    else if (opening_paren_count\
    \ == closing_paren_count) {\n      paren_nesting_level.push_back(opening_paren_count);\n\
    \      opening_paren_count = paren_opening_parens;\n      closing_paren_count\
    \ = paren_closing_parens;\n    } else {\n      opening_paren_count = paren_opening_parens;\n\
    \      closing_paren_count = paren_closing_parens;\n    }\n  }\n  return paren_nesting_level;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppui4gnto.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmppui4gnto.cpp:16:25: error: no match for \u2018operator==\u2019 (operand\
    \ types are \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019} and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   16 |     if (paren_string[i] == paren_opening_parens) opening_paren_count\
    \ += 1;\nIn file included from /usr/include/c++/9/regex:62,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n              \
    \   from /tmp/tmppui4gnto.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \ candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmppui4gnto.cpp:16:28:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018__gnu_cxx::__alloc_traits<std::allocator<char>, char>::value_type\u2019\
    \ {aka \u2018char\u2019}\n   16 |     if (paren_string[i] == paren_opening_parens)\
    \ opening_paren_count += 1;\n      |                            ^~~~~~~~~~~~~~~~~~~~\n\
    In file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmppui4gnto.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmppui4gnto.cpp:16:28: note:   mismatched types \u2018std::__cxx11::__sub"
  stdout: ''
  timestamp: 1660113176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    // Iterate over input string\
    \ one character at a time.\n    // If the current character is open parenthesis,\
    \ push its nesting level to the vector.\n    // If the current character is close\
    \ parenthesis, pop the previous nesting level from the vector.\n    // If the\
    \ current character is a closing brace, add it to the vector and continue.\n \
    \   for (auto c : paren_string) {\n        if (c == '(')\n            levels.push_back(1);\n\
    \        else if (c == ')')\n            levels.pop_back();\n        else if (c\
    \ == '{')\n            levels.push_back(levels.size());\n        else if (c ==\
    \ '}')\n            levels.push_back(levels.size() - 1);\n        else\n     \
    \       assert(false);\n    }\n    return levels;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmp_wxnyw3p: /tmp/tmp_wxnyw3p.cpp:24: std::vector<long int> parse_nested_parens(std::string):
    Assertion `false'' failed.

    '
  stdout: ''
  timestamp: 1660113176
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> ans;\n    long cur = 0;\n    // Iterate\
    \ over input string\n    for (auto c: paren_string) {\n        // If current character\
    \ is an opening parenthesis\n        if (c == '(') {\n            // If there\
    \ is already a parentheses group\n            if (cur != 0) {\n              \
    \  // Add current level of nesting to total nest level\n                ans.push_back(cur);\n\
    \            }\n            // Mark current level of nesting\n            cur++;\n\
    \        }\n        // If current character is a closing parenthesis\n       \
    \ else if (c == ')') {\n            // If there is a current level of nesting\n\
    \            if (cur != 0) {\n                // Add current level of nesting\
    \ to total nest level\n                ans.push_back(cur);\n                //\
    \ Mark current level of nesting as 0\n                cur--;\n            }\n\
    \            // Else, ignore closing parenthesis\n            else {\n       \
    \         // Just ignore closing parenthesis\n            }\n        }\n     \
    \   // Else, ignore characters\n        else {\n            // Just ignore characters\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpi3fydoof: /tmp/tmpi3fydoof.cpp:46: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113177
- exit_code: -1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> results;\n    std::string s = paren_string;\n\
    \    while (s.size() != 0) {\n        bool found = false;\n        for (auto &c:\
    \ s) {\n            found = found || (c == '(' || c == '{' || c == '}');\n   \
    \         if (found && c == '(') results.push_back(s.size());\n            if\
    \ (c == '(') found = true;\n        }\n        s = s.substr(s.size() - 1);\n \
    \   }\n    return results;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Timeout
  stderr: None
  stdout: None
  timestamp: 1660113182
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    int cnt = 0;\n    for (size_t\
    \ i = 0; i < paren_string.size(); ++i) {\n        if (isspace(paren_string[i]))\
    \ continue;\n        if (paren_string[i] == '(') {\n            ++cnt;\n     \
    \   } else if (paren_string[i] == ')') {\n            --cnt;\n        }\n    \
    \    if (cnt > 0) {\n            result.emplace_back(cnt);\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpp7bnvo5v: /tmp/tmpp7bnvo5v.cpp:26: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113177
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> levels;\n    auto current_level = levels.size();\
    \ // starting from 0 because the first parentheses is a \"(\"\n    auto next_parentheses\
    \ = '('; // parentheses inside which parenthesis will be balanced\n    for (auto\
    \ character : paren_string) {\n        if (character == '(') {\n            next_parentheses\
    \ = '(';\n        } else if (character == ')') {\n            next_parentheses\
    \ = ')';\n        } else if (character == ')' && next_parentheses == '(') {\n\
    \            current_level = levels[current_level - 1]; // go up in level\n  \
    \          next_parentheses = ')'; // go back to \")\" as we found a matching\
    \ \"(\"\n            levels[current_level] = current_level; // add new level for\
    \ parenthesis\n        } else {\n            levels[current_level] = next_parentheses;\
    \ // just insert next parentheses\n        }\n    }\n    return levels;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::string token;\n    std::vector<long> nested_paren_level;\n\
    \    bool inside_paren = false;\n    bool nested_paren_found = false;\n    for\
    \ (auto &c: paren_string) {\n        bool is_space = (c == ' ');\n        if (is_space\
    \ && !inside_paren) {\n            nested_paren_found = false;\n        }\n  \
    \      if (c == '(') {\n            if (!inside_paren)\n                nested_paren_found\
    \ = true;\n        }\n        if (nested_paren_found) {\n            nested_paren_level.push_back(long(is_space\
    \ ? 1 : 0));\n        }\n        if (c == ')') {\n            nested_paren_level.push_back(long(is_space\
    \ ? 0 : 1));\n        }\n        inside_paren = !is_space;\n    }\n    return\
    \ nested_paren_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpspjc1mk2: /tmp/tmpspjc1mk2.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  // To keep track of whether we are within parens\n  bool\
    \ paren_level = false;\n  // To keep track of the number of opening parens\n \
    \ long open_parens = 0;\n  // To keep track of the current level of nesting of\
    \ parens\n  long cur_depth = 0;\n  // To store the output\n  std::vector<long>\
    \ output;\n  // Iterate over the string to process nested parens\n  for (int i\
    \ = 0; i < paren_string.size(); i++) {\n    if (paren_level) {\n      // If we\
    \ are currently inside parens then increment the level of nesting\n      cur_depth++;\n\
    \      if (paren_string[i] == '(') {\n        // If this character is a openning\
    \ paren then set paren_level to true\n        open_parens++;\n      } else if\
    \ (paren_string[i] == ')') {\n        // If this character is a closing paren\
    \ then decrement the level of nesting\n        open_parens--;\n        // If the\
    \ level of nesting is now zero then add it to the output\n        if (open_parens\
    \ == 0) {\n          output.push_back(cur_depth);\n        }\n      }\n    } else\
    \ {\n      // Else if we are not inside parens then increment the level of nesting\n\
    \      cur_depth++;\n      if (paren_string[i] == ')') {\n        output.push_back(cur_depth);\n\
    \        // Then set paren_level to false and continue the for loop\n        paren_level\
    \ = false;\n        open_parens--;\n      }\n    }\n  }\n  // If we are currently\
    \ inside parens then increment the level of nesting\n  if (open_parens) {\n  \
    \  output.push_back(cur_depth);\n  }\n  return output;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpp81vo353: /tmp/tmpp81vo353.cpp:52: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_nesting;\n  size_t paren_len = paren_string.size();\n\
    \  std::vector<char> paren_nesting_chars;\n  paren_nesting_chars.reserve(paren_len);\n\
    \  long curr_level = 1;\n  for (size_t i = 0; i < paren_len; ++i) {\n    if (paren_string[i]\
    \ == '(') {\n      paren_nesting.push_back(curr_level);\n      curr_level++;\n\
    \      paren_nesting_chars.push_back(paren_string[i]);\n    } else if (paren_string[i]\
    \ == ')') {\n      paren_nesting.push_back(curr_level);\n      curr_level--;\n\
    \      assert(curr_level >= 0);\n      paren_nesting_chars.push_back(paren_string[i]);\n\
    \    } else if (paren_string[i] == ' ') {\n      assert(curr_level >= 0);\n  \
    \    paren_nesting.push_back(curr_level);\n      curr_level--;\n      assert(curr_level\
    \ >= 0);\n      paren_nesting_chars.push_back(paren_string[i]);\n    }\n  }\n\
    \  return paren_nesting;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpxnkej9_r: /tmp/tmpxnkej9_r.cpp:28: std::vector<long int> parse_nested_parens(std::string):
    Assertion `curr_level >= 0'' failed.

    '
  stdout: ''
  timestamp: 1660113177
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::string temp = \"\";\n    std::vector<long> temp_ret_val;\n\
    \    std::stack<std::string> stack_val;\n\n    for (const auto& char : paren_string)\
    \ {\n        if (char == '(' || char == ')')\n            stack_val.push(char);\n\
    \        else\n            temp += char;\n\n        if (stack_val.empty() || temp\
    \ == \"\") {\n            temp_ret_val.push_back(temp.length());\n           \
    \ temp = char;\n        } else {\n            while (!stack_val.empty()) {\n \
    \               long temp_idx = temp_ret_val.back();\n                long parens_level\
    \ = temp_ret_val.back();\n                temp_ret_val.pop_back();\n         \
    \       if (stack_val.top() == \"(\")\n                    parens_level++;\n \
    \               else if (stack_val.top() == \")\")\n                    parens_level--;\n\
    \n                temp_ret_val.push_back(parens_level);\n                stack_val.pop();\n\
    \            }\n            temp += char;\n        }\n    }\n    return temp_ret_val;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx2oiwnjb.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpx2oiwnjb.cpp:13:22: error: expected unqualified-id before \u2018char\u2019\
    \n   13 |     for (const auto& char : paren_string) {\n      |               \
    \       ^~~~\n/tmp/tmpx2oiwnjb.cpp:13:21: error: expected \u2018;\u2019 before\
    \ \u2018char\u2019\n   13 |     for (const auto& char : paren_string) {\n    \
    \  |                     ^~~~~\n      |                     ;\n/tmp/tmpx2oiwnjb.cpp:13:27:\
    \ error: expected unqualified-id before \u2018:\u2019 token\n   13 |     for (const\
    \ auto& char : paren_string) {\n      |                           ^\n/tmp/tmpx2oiwnjb.cpp:13:41:\
    \ error: expected \u2018;\u2019 before \u2018)\u2019 token\n   13 |     for (const\
    \ auto& char : paren_string) {\n      |                                      \
    \   ^\n      |                                         ;\n/tmp/tmpx2oiwnjb.cpp:14:18:\
    \ error: expected unqualified-id before \u2018==\u2019 token\n   14 |        \
    \ if (char == '(' || char == ')')\n      |                  ^~\n/tmp/tmpx2oiwnjb.cpp:15:28:\
    \ error: expected primary-expression before \u2018char\u2019\n   15 |        \
    \     stack_val.push(char);\n      |                            ^~~~\n/tmp/tmpx2oiwnjb.cpp:17:21:\
    \ error: expected primary-expression before \u2018char\u2019\n   17 |        \
    \     temp += char;\n      |                     ^~~~\n/tmp/tmpx2oiwnjb.cpp:21:20:\
    \ error: expected primary-expression before \u2018char\u2019\n   21 |        \
    \     temp = char;\n      |                    ^~~~\n/tmp/tmpx2oiwnjb.cpp:35:21:\
    \ error: expected primary-expression before \u2018char\u2019\n   35 |        \
    \     temp += char;\n      |                     ^~~~\n"
  stdout: ''
  timestamp: 1660113177
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    auto paren_levels = {0};\
    \ // counts how many nested parentheses in each level\n    bool seen_parentheses\
    \ = false;\n    for (auto p : paren_string) {\n        if (p == '(') {\n     \
    \       paren_levels[0]++;\n            seen_parentheses = true;\n        } else\
    \ if (p == ')') {\n            paren_levels[paren_levels[0] - 1]++;\n        \
    \    if (paren_levels[0] > 1) {\n                result.push_back(paren_levels[0]);\n\
    \                paren_levels[0] = 0;\n                seen_parentheses = false;\n\
    \            }\n        } else if (seen_parentheses) {\n            paren_levels[paren_levels[0]\
    \ - 1]++;\n        }\n    }\n    if (paren_levels[0] > 1) {\n        result.push_back(paren_levels[0]);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq5qv707g.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpq5qv707g.cpp:14:25: error: no match for \u2018operator[]\u2019 (operand\
    \ types are \u2018std::initializer_list<int>\u2019 and \u2018int\u2019)\n   14\
    \ |             paren_levels[0]++;\n      |                         ^\n/tmp/tmpq5qv707g.cpp:17:38:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::initializer_list<int>\u2019\
    \ and \u2018int\u2019)\n   17 |             paren_levels[paren_levels[0] - 1]++;\n\
    \      |                                      ^\n/tmp/tmpq5qv707g.cpp:18:29: error:\
    \ no match for \u2018operator[]\u2019 (operand types are \u2018std::initializer_list<int>\u2019\
    \ and \u2018int\u2019)\n   18 |             if (paren_levels[0] > 1) {\n     \
    \ |                             ^\n/tmp/tmpq5qv707g.cpp:19:46: error: no match\
    \ for \u2018operator[]\u2019 (operand types are \u2018std::initializer_list<int>\u2019\
    \ and \u2018int\u2019)\n   19 |                 result.push_back(paren_levels[0]);\n\
    \      |                                              ^\n/tmp/tmpq5qv707g.cpp:20:29:\
    \ error: no match for \u2018operator[]\u2019 (operand types are \u2018std::initializer_list<int>\u2019\
    \ and \u2018int\u2019)\n   20 |                 paren_levels[0] = 0;\n      |\
    \                             ^\n/tmp/tmpq5qv707g.cpp:24:38: error: no match for\
    \ \u2018operator[]\u2019 (operand types are \u2018std::initializer_list<int>\u2019\
    \ and \u2018int\u2019)\n   24 |             paren_levels[paren_levels[0] - 1]++;\n\
    \      |                                      ^\n/tmp/tmpq5qv707g.cpp:27:21: error:\
    \ no match for \u2018operator[]\u2019 (operand types are \u2018std::initializer_list<int>\u2019\
    \ and \u2018int\u2019)\n   27 |     if (paren_levels[0] > 1) {\n      |      \
    \               ^\n/tmp/tmpq5qv707g.cpp:28:38: error: no match for \u2018operator[]\u2019\
    \ (operand types are \u2018std::initializer_list<int>\u2019 and \u2018int\u2019\
    )\n   28 |         result.push_back(paren_levels[0]);\n      |               \
    \                       ^\n"
  stdout: ''
  timestamp: 1660113176
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  assert(!paren_string.empty());\n  // Create a stack of level\
    \ i.\n  std::stack<std::vector<long>> stack(paren_string.size());\n  // Push an\
    \ empty vector onto stack at level i.\n  stack.push(std::vector<long>());\n  long\
    \ level = 0;\n  while (!stack.empty()) {\n    // Pop an element from stack at\
    \ level i.\n    std::vector<long> popped_vec = stack.top();\n    stack.pop();\n\
    \    long popped_level = popped_vec.size();\n    // If the popped level is greater\
    \ than level i, then pop the last level (popped_level - 1).\n    if (popped_level\
    \ > level) {\n      level--;\n      // Append the popped level to stack.\n   \
    \   stack.push(popped_vec);\n      // Append the popped level to all previous\
    \ levels.\n      while (!stack.empty()) {\n        std::vector<long> level_vec\
    \ = stack.top();\n        stack.pop();\n        for (long i = 0; i < level_vec.size();\
    \ ++i) {\n          if (i != popped_level) {\n            level_vec.push_back(i\
    \ + 1);\n          }\n        }\n        stack.push(level_vec);\n      }\n   \
    \   // Pop an element from stack at level i.\n      std::vector<long> popped_vec\
    \ = stack.top();\n      stack.pop();\n    }\n    // If the popped level is less\
    \ than level i, then pop the next level (popped_level + 1).\n    else if (popped_level\
    \ < level) {\n      level++;\n      // Append the popped level to stack.\n   \
    \   stack.push(popped_vec);\n      // Append the popped level to all previous\
    \ levels.\n      while (!stack.empty()) {\n        std::vector<long> level_vec\
    \ = stack.top();\n        stack.pop();\n        for (long i = 0; i < level_vec.size();\
    \ ++i) {\n          if (i != popped_level) {\n            level_vec.push_back(i\
    \ + 1);\n          }\n        }\n        stack.push(level_vec);\n      }\n   \
    \ }\n  }\n  return stack;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpj1k92elq.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpj1k92elq.cpp:11:58: error: no matching function for call to \u2018\
    std::stack<std::vector<long int> >::stack(std::__cxx11::basic_string<char>::size_type)\u2019\
    \n   11 |   std::stack<std::vector<long>> stack(paren_string.size());\n      |\
    \                                                          ^\nIn file included\
    \ from /usr/include/c++/9/stack:61,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n\
    \                 from /tmp/tmpj1k92elq.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:185:2:\
    \ note: candidate: \u2018template<class _Alloc, class _Requires> std::stack<_Tp,\
    \ _Sequence>::stack(std::stack<_Tp, _Sequence>&&, const _Alloc&)\u2019\n  185\
    \ |  stack(stack&& __q, const _Alloc& __a)\n      |  ^~~~~\n/usr/include/c++/9/bits/stl_stack.h:185:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpj1k92elq.cpp:11:58:\
    \ note:   candidate expects 2 arguments, 1 provided\n   11 |   std::stack<std::vector<long>>\
    \ stack(paren_string.size());\n      |                                       \
    \                   ^\nIn file included from /usr/include/c++/9/stack:61,\n  \
    \               from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n \
    \                from /tmp/tmpj1k92elq.cpp:2:\n/usr/include/c++/9/bits/stl_stack.h:181:2:\
    \ note: candidate: \u2018template<class _Alloc, class _Requires> std::stack<_Tp,\
    \ _Sequence>::stack(const std::stack<_Tp, _Sequence>&, const _Alloc&)\u2019\n\
    \  181 |  stack(const stack& __q, const _Alloc& __a)\n      |  ^~~~~\n/usr/include/c++/9/bits/stl_stack.h:181:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpj1k92elq.cpp:11:58:\
    \ note:   candidate expects 2 arguments, 1 provided\n   11 |   std::stack<std::vector<long>>\
    \ stack(paren_string.size());\n      |                                       \
    \                   ^\nIn file included from /usr/include/c++/9/stack:61,\n  \
    \               from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:89,\n \
    \                from /tmp/tmpj1k92elq.cpp:2:\n/usr/in"
  stdout: ''
  timestamp: 1660113177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Your code goes here\n    int current_level = 1;\n  \
    \  std::vector<long> levels;\n    levels.push_back(1);\n    while (true) {\n \
    \       // If the string is empty, there is nothing to parse\n        if (paren_string.length()\
    \ == 0) {\n            return levels;\n        }\n        // If we are inside\
    \ an opening parenthesis, increment our level\n        if (paren_string[0] ==\
    \ '(') {\n            current_level++;\n            levels.push_back(current_level);\n\
    \        }\n        // If we are inside a closing parenthesis, decrement our level\n\
    \        if (paren_string[paren_string.length() - 1] == ')') {\n            if\
    \ (current_level > 0) {\n                current_level--;\n            }\n   \
    \         levels.push_back(current_level);\n        }\n        // If the current\
    \ level is less than the deepest level, \n        // then we know that this string\
    \ has nested parenthesis.\n        // Therefore, we will return the current level\n\
    \        if (current_level < levels.size() - 1) {\n            return levels;\n\
    \        }\n        // Otherwise, we will move to the next character in the string.\n\
    \        paren_string.erase(0, 1);\n        paren_string.erase(paren_string.length()\
    \ - 1);\n    }\n}\nint main() {\n    auto candidate = parse_nested_parens;\n \
    \   assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp_7tvtqam: /tmp/tmp_7tvtqam.cpp:43: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> results;\n    int left_paren = paren_string.find_first_not_of(\"\
    ()\");\n    int right_paren = paren_string.find_last_not_of(\"()\");\n    if (left_paren\
    \ < right_paren) {\n        for (int i = left_paren + 1; i <= right_paren; i++)\
    \ {\n            // if there is a substring between left and right paren, count\
    \ the level of nesting.\n            // if there is no substring between left\
    \ and right paren, count the level of nesting.\n            if (paren_string[i]\
    \ == '(') {\n                int paren_count = 1;\n                for (int j\
    \ = i - 1; j >= 0; j--) {\n                    if (paren_string[j] == ')') paren_count++;\n\
    \                    else if (paren_string[j] == '(') paren_count--;\n       \
    \         }\n                results.push_back(paren_count);\n            }\n\
    \        }\n    }\n    return results;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: 'tmpgpig34db: /tmp/tmpgpig34db.cpp:30: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113177
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  // Your code here\n  assert(!paren_string.empty());\n  std::vector<long>\
    \ nesting_level;\n  std::string temp_str = paren_string;\n  std::vector<long>\
    \ temp_long = parse_nested_parens(temp_str);\n  if (temp_long.size() > 0) {\n\
    \    nesting_level.push_back((long)temp_long.size()); // add current nesting level\n\
    \  }\n  while (temp_str.size() > 0) {\n    int i = 0;\n    while (i < temp_str.size()\
    \ && paren_string[i] == ' ') {\n      i++;\n    }\n    std::string token = temp_str.substr(0,\
    \ i);\n    temp_str = temp_str.substr(i + 1);\n    nesting_level.push_back((long)nesting_level.size());\n\
    \    if (nesting_level.size() > temp_long.size()) {\n      temp_long = parse_nested_parens(token);\n\
    \      nesting_level = nesting_level - temp_long;\n      assert(nesting_level.size()\
    \ == temp_long.size());\n    }\n  }\n  return nesting_level;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9vrhz4c4.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmp9vrhz4c4.cpp:27:37: error: no match for \u2018operator-\u2019 (operand\
    \ types are \u2018std::vector<long int>\u2019 and \u2018std::vector<long int>\u2019\
    )\n   27 |       nesting_level = nesting_level - temp_long;\n      |         \
    \              ~~~~~~~~~~~~~ ^ ~~~~~~~~~\n      |                       |    \
    \           |\n      |                       vector<[...]>   vector<[...]>\nIn\
    \ file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n            \
    \     from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp9vrhz4c4.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr\
    \ decltype ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp9vrhz4c4.cpp:27:39:\
    \ note:   \u2018std::vector<long int>\u2019 is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\
    \n   27 |       nesting_level = nesting_level - temp_long;\n      |          \
    \                             ^~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp9vrhz4c4.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1209:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr\
    \ decltype ((__x.base() - __y.base())) std::operator-(const std::move_iterator<_IteratorL>&,\
    \ const std::move_iterator<_IteratorR>&)\u2019\n 1209 |     operator-(const move_iterator<_I"
  stdout: ''
  timestamp: 1660113177
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  // Step 1: Parse the string\
    \ with stacks.\n  std::vector<std::vector<long>> stacks;\n  stacks.push_back(std::vector<long>());\n\
    \  std::stack<long> stack_top;\n  std::stack<long> stack_cur;\n  std::stack<long>\
    \ stack_next;\n  long stack_depth = 0;\n  bool is_in_cur = false;\n  for (size_t\
    \ i = 0; i < paren_string.size(); ++i) {\n    if (paren_string[i] == ')') {\n\
    \      long level_num = stack_next.size();\n      while (level_num > 0) {\n  \
    \      long level_top = stack_top.size();\n        bool is_in_top = stack_top.empty()\
    \ || stack_top.top() > level_num;\n        if (is_in_top) {\n          stack_depth\
    \ = level_top;\n          is_in_cur = true;\n        } else {\n          stack_depth--;\n\
    \        }\n        stack_top.pop();\n        if (is_in_cur) {\n          break;\n\
    \        }\n      }\n    } else {\n      if (is_in_cur) {\n        stack_cur.push(i\
    \ - 1);\n      }\n      if (paren_string[i] == '(') {\n        is_in_cur = true;\n\
    \        stack_depth++;\n        stack_next.push(i - 1);\n      } else {\n   \
    \     is_in_cur = false;\n        stack_next.pop();\n      }\n    }\n  }\n\n \
    \ // Step 2: Get the nested levels of parentheses.\n  while (stack_next.size()\
    \ > 0) {\n    result.push_back(stack_next.top());\n    stack_next.pop();\n  }\n\
    \n  while (stack_top.size() > 0) {\n    result.push_back(stack_top.top());\n \
    \   stack_top.pop();\n  }\n\n  return result;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660113177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> results;\n    std::string prev_char =\
    \ \"\";\n    long level = 0;\n    for (auto &c : paren_string) {\n        if (prev_char\
    \ == \"(\")\n            ++level;\n        else if (prev_char == \")\") {\n  \
    \          if (level > 0)\n                --level;\n            else {\n    \
    \            results.push_back(level);\n                level = 0;\n         \
    \   }\n        }\n        prev_char = c;\n    }\n    return results; // [(long)2,\
    \ (long)3, (long)1, (long)3]\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpl541vhsm: /tmp/tmpl541vhsm.cpp:29: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> ans;\n    bool seen_opening_paren = false;\n\
    \    long curr_level = 0;\n    for (auto c: paren_string) {\n        // if the\
    \ current level is greater than or equal to the length of the previous level,\n\
    \        // then we know we have not reached the correct level (since we do not\
    \ know the number\n        // of opening parentheses).\n        if (curr_level\
    \ > ans.size() || curr_level < ans.size() - 1) {\n            return ans;\n  \
    \      }\n        // if we see an opening parentheses, increment curr_level\n\
    \        if (c == '(') {\n            seen_opening_paren = true;\n           \
    \ curr_level++;\n        }\n        // if we see a closing parentheses, decrement\
    \ curr_level\n        else if (c == ')') {\n            curr_level--;\n      \
    \  }\n        // if we see a space, we know that we have reached the correct level\n\
    \        else if (c == ' ') {\n            curr_level = ans.size();\n        }\n\
    \        // otherwise, if we see the closing parentheses, we are at the correct\
    \ level\n        else if (c == ')') {\n            curr_level = ans.size();\n\
    \            ans.push_back(curr_level);\n            seen_opening_paren = false;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpjpjexg4m: /tmp/tmpjpjexg4m.cpp:43: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113177
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  // If there is nothing to parse, just return an empty vector.\n\
    \  if (paren_string == \"\") return std::vector<long>();\n  std::vector<long>\
    \ levels;\n  // Step 1: find out number of open/close parentheses in the string.\n\
    \  auto paren_counts = paren_string.find_first_of(\"()\", paren_string.find_first_not_of(\"\
    ()\"));\n  // Step 2: split string into open/close pairs, where open parentheses\
    \ come first, and close parentheses come last.\n  std::vector<std::string> paren_pairs\
    \ = paren_string.substr(0, paren_counts).split(' ', std::vector<char>{' ', '('});\n\
    \  // Step 3: iterate through the pairs and push corresponding number of levels\
    \ into a vector\n  for (size_t i = 0; i < paren_pairs.size(); ++i) {\n    if (paren_pairs[i]\
    \ == \"(\") {\n      levels.push_back(1);\n    } else if (paren_pairs[i] == \"\
    )\") {\n      levels[levels.size() - 1]++;\n    }\n  }\n  // Step 4: append the\
    \ number of levels to the vector and sort it.\n  levels.append(paren_pairs.size());\n\
    \  std::sort(levels.begin(), levels.end());\n  return levels;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkwpmeze9.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpkwpmeze9.cpp:15:79: error: \u2018class std::__cxx11::basic_string<char>\u2019\
    \ has no member named \u2018split\u2019\n   15 |   std::vector<std::string> paren_pairs\
    \ = paren_string.substr(0, paren_counts).split(' ', std::vector<char>{' ', '('});\n\
    \      |                                                                     \
    \          ^~~~~\n/tmp/tmpkwpmeze9.cpp:25:10: error: \u2018class std::vector<long\
    \ int>\u2019 has no member named \u2018append\u2019\n   25 |   levels.append(paren_pairs.size());\n\
    \      |          ^~~~~~\n"
  stdout: ''
  timestamp: 1660113177
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_depth;\n    std::string curr_paren;\n\
    \    for (auto &c: paren_string) {\n        if (curr_paren == \"\") {\n      \
    \      curr_paren = c;\n            paren_depth.push_back(0);\n        } else\
    \ {\n            long paren_depth_so_far = paren_depth[paren_depth.size() - 1];\n\
    \            if (c == \"(\") {\n                paren_depth.push_back(paren_depth_so_far\
    \ + 1);\n            } else if (c == \")\") {\n                paren_depth.pop_back();\n\
    \            }\n            curr_paren = c;\n        }\n    }\n    return paren_depth;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn5kznsfe.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpn5kznsfe.cpp:17:22: error: ISO C++ forbids comparison between pointer\
    \ and integer [-fpermissive]\n   17 |             if (c == \"(\") {\n      | \
    \                     ^~~\n/tmp/tmpn5kznsfe.cpp:19:29: error: ISO C++ forbids\
    \ comparison between pointer and integer [-fpermissive]\n   19 |             }\
    \ else if (c == \")\") {\n      |                             ^~~\n"
  stdout: ''
  timestamp: 1660113177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::string curr_paren_string\
    \ = paren_string;\n    long current_level = 0;\n    while (curr_paren_string.length()\
    \ != 0) {\n        // Check if curr_paren_string is the empty string\n       \
    \ if (curr_paren_string.empty()) return result;\n        // Check if the current\
    \ char is the closing parenthesis\n        if (curr_paren_string.back() != '(')\
    \ {\n            result.push_back(current_level);\n            return result;\n\
    \        }\n        // Increment current level by 1\n        current_level++;\n\
    \        curr_paren_string = curr_paren_string.substr(0, curr_paren_string.size()\
    \ - 1);\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmph3mb3_yu: /tmp/tmph3mb3_yu.cpp:28: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113177
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<std::string> paren_groups;\n    std::string\
    \ current_paren_group = \"\";\n\n    // If no more parenthesis groups are found,\
    \ return an empty vector.\n    auto add_paren_group = [](std::string &s) { paren_groups.emplace_back(s);\
    \ };\n    auto check_paren_group = [&](std::string &s) {\n        if (current_paren_group\
    \ != \"\") {\n            size_t index = paren_string.find(current_paren_group);\n\
    \            if (index != std::string::npos) {\n                add_paren_group(s);\n\
    \                current_paren_group = \"\";\n            }\n        }\n    };\n\
    \    // Check for a closing parenthesis group first.\n    auto check_closing =\
    \ [&](std::string &s) {\n        auto index = paren_string.find(')');\n      \
    \  if (index != std::string::npos) {\n            check_paren_group(s);\n    \
    \    }\n    };\n\n    paren_string.erase(std::remove(paren_string.begin(), paren_string.end(),\
    \ ' '), paren_string.end());\n    for (auto &s : paren_string) {\n        // Check\
    \ for a parenthesis group.\n        auto index = paren_string.find('(');\n   \
    \     if (index != std::string::npos) {\n            current_paren_group = s;\n\
    \        }\n        // Check for a closing parenthesis group.\n        index =\
    \ paren_string.find(')');\n        if (index != std::string::npos) {\n       \
    \     check_paren_group(s);\n        }\n    }\n    check_closing(paren_string);\n\
    \n    std::vector<long> results;\n    // Now go through the groups and find the\
    \ deepest level of nesting.\n    for (auto &s : paren_groups) {\n        std::stack<std::string>\
    \ parens;\n        std::stack<long> nesting;\n        std::string paren_level;\n\
    \        auto add_paren = [&](std::string &s) {\n            parens.push(s);\n\
    \            nesting.push(1);\n        };\n        auto remove_paren = [&](std::string\
    \ &s) {\n            if (parens.empty()) std::cout << \"No more parentheses groups\
    \ are found\" << std::endl;\n            else {\n                s = parens.top();\n\
    \                nesting.pop();\n                if (nesting.empty()) parens.pop();\n\
    \            }\n        };\n        // Check for an opening parenthesis group.\n\
    \        auto check_opening = [&](std::string &s) {\n            if (nesting.empty())\
    \ std::cout << \"No more parentheses groups are found\" << std::endl;\n      \
    \      else {\n                size_t index = s.find('(');\n                if\
    \ (index != std::string::npos) {\n                    nesting.push(index);\n \
    \                   add_paren_group(s);\n                    paren_level = \"\"\
    ;\n                }\n            }\n        };\n        // Check for a closing\
    \ parenthesis group.\n        auto check_closing\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpyccxiva3.cpp: In lambda function:\n/tmp/tmpyccxiva3.cpp:13:49:\
    \ error: \u2018paren_groups\u2019 is not captured\n   13 |     auto add_paren_group\
    \ = [](std::string &s) { paren_groups.emplace_back(s); };\n      |           \
    \                                      ^~~~~~~~~~~~\n/tmp/tmpyccxiva3.cpp:13:29:\
    \ note: the lambda has no capture-default\n   13 |     auto add_paren_group =\
    \ [](std::string &s) { paren_groups.emplace_back(s); };\n      |             \
    \                ^\n/tmp/tmpyccxiva3.cpp:9:30: note: \u2018std::vector<std::__cxx11::basic_string<char>\
    \ > paren_groups\u2019 declared here\n    9 |     std::vector<std::string> paren_groups;\n\
    \      |                              ^~~~~~~~~~~~\n/tmp/tmpyccxiva3.cpp: In function\
    \ \u2018std::vector<long int> parse_nested_parens(std::string)\u2019:\n/tmp/tmpyccxiva3.cpp:41:32:\
    \ error: no match for call to \u2018(parse_nested_parens(std::string)::<lambda(std::string&)>)\
    \ (char&)\u2019\n   41 |             check_paren_group(s);\n      |          \
    \                      ^\n/tmp/tmpyccxiva3.cpp:14:30: note: candidate: \u2018\
    parse_nested_parens(std::string)::<lambda(std::string&)>\u2019\n   14 |     auto\
    \ check_paren_group = [&](std::string &s) {\n      |                         \
    \     ^\n/tmp/tmpyccxiva3.cpp:14:30: note:   no known conversion for argument\
    \ 1 from \u2018char\u2019 to \u2018std::string&\u2019 {aka \u2018std::__cxx11::basic_string<char>&\u2019\
    }\n/tmp/tmpyccxiva3.cpp:78:1: error: expected initializer before \u2018}\u2019\
    \ token\n   78 | }\n      | ^\n/tmp/tmpyccxiva3.cpp:79:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   79 | int main() {\n     \
    \ |            ^\n/tmp/tmpyccxiva3.cpp:84:1: error: expected \u2018}\u2019 at\
    \ end of input\n   84 | }\n      | ^\n/tmp/tmpyccxiva3.cpp:8:65: note: to match\
    \ this \u2018{\u2019\n    8 | std::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n      |                                                   \
    \              ^\n/tmp/tmpyccxiva3.cpp:84:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   84 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660113177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> paren_level;\n    for (auto &ch: paren_string)\
    \ {\n        if (ch == ')') paren_level.back()++;\n        if (ch == '(') paren_level.push_back(0);\n\
    \    }\n    return paren_level;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmp3hmgyw8m: /tmp/tmp3hmgyw8m.cpp:18: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // For each nested group, count how many opening parenthesis\
    \ we have.\n    size_t current_level = 0;\n    size_t max_nesting_level = 0;\n\
    \    for (size_t i = 0; i < paren_string.size(); i++) {\n        // If current\
    \ character is '(', increase level\n        if (paren_string[i] == '(') {\n  \
    \          current_level++;\n            max_nesting_level = std::max(max_nesting_level,\
    \ current_level);\n        } else {\n            // Otherwise decrease level\n\
    \            current_level--;\n        }\n    }\n    // We will append the maximum\
    \ nesting level to the vector as well.\n    std::vector<long> nesting_levels(max_nesting_level);\n\
    \    current_level = 0;\n    for (size_t i = 0; i < paren_string.size(); i++)\
    \ {\n        // If current character is '(', increase level\n        if (paren_string[i]\
    \ == '(') {\n            current_level++;\n        } else {\n            // Otherwise\
    \ decrease level\n            current_level--;\n        }\n        if (current_level\
    \ != 0) {\n            nesting_levels[current_level - 1]++;\n        }\n    }\n\
    \    return nesting_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::length_error'\n  what():\
    \  cannot create std::vector larger than max_size()\n"
  stdout: ''
  timestamp: 1660113177
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::string str = paren_string;\n  std::vector<long> result;\n\
    \  // Parse the string backwards to avoid modifying the original string\n  while\
    \ (!str.empty()) {\n    bool found = false;\n    long level = 0;\n    size_t last_index\
    \ = 0;\n    for (size_t i = str.size(); i > 0; --i) {\n      if (str[i - 1] ==\
    \ '(') {\n        found = true;\n        level = level + 1;\n      } else if (str[i\
    \ - 1] == ')') {\n        level = level - 1;\n        found = true;\n      } else\
    \ if (str[i - 1] == ' ' && level > 0) {\n        last_index = i;\n      }\n  \
    \  }\n    result.emplace_back(level);\n    str = str.substr(0, last_index);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: Exception
  stderr: 'tmpule4e6rw: /tmp/tmpule4e6rw.cpp:34: int main(): Assertion `candidate(("(()())
    ((())) () ((())()())")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))''
    failed.

    '
  stdout: ''
  timestamp: 1660113177
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> paren_levels;\n  std::stack<long int> paren_counts;\n\
    \  long long total = 0;\n  for (char c : paren_string) {\n    total += std::count_if(std::begin(paren_counts),\
    \ std::end(paren_counts), [](long int count) {\n      return (count > 0) && (count\
    \ == (c == '(' ? 1 : 0));\n    });\n    if (total < 2) {\n      paren_counts.push(0);\n\
    \    }\n    paren_counts.push((paren_counts.top() == 0) ? 1 : (paren_counts.top()\
    \ == (c == '(' ? 1 : 0)));\n    total += 1;\n  }\n  while (total > 0 && paren_counts.top()\
    \ > 0) {\n    paren_levels.push_back(paren_counts.top());\n    paren_counts.pop();\n\
    \    total -= paren_counts.top();\n  }\n  return paren_levels;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgbbe4pcj.cpp: In function \u2018std::vector<long int> parse_nested_parens(std::string)\u2019\
    :\n/tmp/tmpgbbe4pcj.cpp:13:51: error: no matching function for call to \u2018\
    begin(std::stack<long int>&)\u2019\n   13 |     total += std::count_if(std::begin(paren_counts),\
    \ std::end(paren_counts), [](long int count) {\n      |                      \
    \                             ^\nIn file included from /usr/include/c++/9/bits/range_access.h:36,\n\
    \                 from /usr/include/c++/9/string:54,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n                 from\
    \ /tmp/tmpgbbe4pcj.cpp:2:\n/usr/include/c++/9/initializer_list:89:5: note: candidate:\
    \ \u2018template<class _Tp> constexpr const _Tp* std::begin(std::initializer_list<_Tp>)\u2019\
    \n   89 |     begin(initializer_list<_Tp> __ils) noexcept\n      |     ^~~~~\n\
    /usr/include/c++/9/initializer_list:89:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpgbbe4pcj.cpp:13:51: note:   \u2018std::stack<long int>\u2019\
    \ is not derived from \u2018std::initializer_list<_Tp>\u2019\n   13 |     total\
    \ += std::count_if(std::begin(paren_counts), std::end(paren_counts), [](long int\
    \ count) {\n      |                                                   ^\nIn file\
    \ included from /usr/include/c++/9/string:54,\n                 from /usr/include/c++/9/bits/locale_classes.h:40,\n\
    \                 from /usr/include/c++/9/bits/ios_base.h:41,\n              \
    \   from /usr/include/c++/9/ios:42,\n                 from /usr/include/c++/9/istream:38,\n\
    \                 from /usr/include/c++/9/sstream:38,\n                 from /usr/include/c++/9/complex:45,\n\
    \                 from /usr/include/c++/9/ccomplex:39,\n            "
  stdout: ''
  timestamp: 1660113177
