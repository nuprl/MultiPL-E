language: cpp
name: HumanEval_72_will_it_fly
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n        long max = std::numeric_limits<long>::max();\n\
    \        if (q.size() == 0) {\n                return false;\n        }\n    \
    \    long min = std::numeric_limits<long>::min();\n        long sum = 0;\n   \
    \     for (long i : q) {\n                sum += i;\n        }\n        return\
    \ sum < max && sum >= min;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp6hwfzfqh: /tmp/tmp6hwfzfqh.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // TODO: Use the assert macro\
    \ from <assert.h>. \n    // You have to include it first since it depends on other\
    \ header files.\n    // #include <assert.h>\n    bool ret = false;\n    long max_weight\
    \ = 0;\n    // TODO: Write a loop that computes the maximum possible weight.\n\
    \    for (auto elem : q) {\n        max_weight = std::max(max_weight, elem);\n\
    \    }\n    // TODO: Write a loop that checks if the vector q will fly by comparing\
    \ the sum of its elements to the maximum possible weight.\n    ret = false;\n\
    \    for (auto elem : q) {\n        long weight_sum = elem + max_weight;\n   \
    \     if (weight_sum == w) {\n            ret = true;\n        }\n    }\n    return\
    \ ret;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpzi47gebs: /tmp/tmpzi47gebs.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n\tassert(q.size() > 1);\n\tbool\
    \ valid = true;\n\tlong maxw = 0;\n\tfor (long i : q) {\n\t\tif (i > maxw) maxw\
    \ = i;\n\t}\n\tlong sum = 0;\n\tfor (long i : q) {\n\t\tsum += i;\n\t}\n\tbool\
    \ bal = false;\n\tif (sum == w) {\n\t\tbal = true;\n\t} else if (sum >= w) {\n\
    \t\tvalid = false;\n\t} else {\n\t\tvalid = (sum >= maxw);\n\t}\n\treturn valid;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpw734t7_h: /tmp/tmpw734t7_h.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int max = 0;\n    for (auto\
    \ i : q) if (i > max) max = i;\n    int size = q.size();\n    int sum = 0;\n \
    \   for (int i = 1; i <= size; i++) {\n        sum += q[size - i];\n        if\
    \ (sum < w) return false;\n    }\n    if (sum > w) return true;\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpn0pq9uwj: /tmp/tmpn0pq9uwj.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    assert(q.is_palindrino());\n\
    \    auto max_weight = std::max_element(q.begin(), q.end());\n    long sum = 0;\n\
    \    for (auto i : q) {\n        sum += i;\n        if (sum > max_weight) {\n\
    \            return false;\n        }\n    }\n    return sum == max_weight;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/cassert:44,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:33,\n               \
    \  from /tmp/tmp1c3mgcau.cpp:2:\n/tmp/tmp1c3mgcau.cpp: In function \u2018bool\
    \ will_it_fly(std::vector<long int>, long int)\u2019:\n/tmp/tmp1c3mgcau.cpp:19:14:\
    \ error: \u2018class std::vector<long int>\u2019 has no member named \u2018is_palindrino\u2019\
    \n   19 |     assert(q.is_palindrino());\n      |              ^~~~~~~~~~~~~\n\
    /tmp/tmp1c3mgcau.cpp:24:17: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018__gnu_cxx::__normal_iterator<long int*,\
    \ std::vector<long int> >\u2019)\n   24 |         if (sum > max_weight) {\n  \
    \    |             ~~~ ^ ~~~~~~~~~~\n      |             |     |\n      |    \
    \         |     __gnu_cxx::__normal_iterator<long int*, std::vector<long int>\
    \ >\n      |             long int\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp1c3mgcau.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:926:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator>(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  926 |\
    \     operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,\n    \
    \  |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:926:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp1c3mgcau.cpp:24:19: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018long int\u2019\n   24 |         if (sum > max_weight) {\n      | \
    \                  ^~~~~~~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/i"
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long m = std::accumulate(q.cbegin(),\
    \ q.cend(), 0);\n    return m <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmprsmjo47y: /tmp/tmprsmjo47y.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() > w) return\
    \ false;\n    std::reverse(q);\n    std::sort(q.begin(), q.end());\n    return\
    \ std::equal(q.begin(), q.end(), q.rbegin());\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvni6nsno.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpvni6nsno.cpp:20:19: error: no matching function\
    \ for call to \u2018reverse(std::vector<long int>&)\u2019\n   20 |     std::reverse(q);\n\
    \      |                   ^\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvni6nsno.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:1186:5:\
    \ note: candidate: \u2018template<class _BIter> void std::reverse(_BIter, _BIter)\u2019\
    \n 1186 |     reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n\
    \      |     ^~~~~~~\n/usr/include/c++/9/bits/stl_algo.h:1186:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvni6nsno.cpp:20:19: note: \
    \  candidate expects 2 arguments, 1 provided\n   20 |     std::reverse(q);\n \
    \     |                   ^\nIn file included from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvni6nsno.cpp:2:\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:249:1:\
    \ note: candidate: \u2018template<class _ExecutionPolicy, class _BidirectionalIterator>\
    \ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void> std::reverse(_ExecutionPolicy&&,\
    \ _BidirectionalIterator, _BidirectionalIterator)\u2019\n  249 | reverse(_ExecutionPolicy&&\
    \ __exec, _BidirectionalIterator __first, _BidirectionalIterator __last);\n  \
    \    | ^~~~~~~\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:249:1: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpvni6nsno.cpp:20:19: note: \
    \  candidate expects 3 arguments, 1 provided\n   20 |     std::reverse(q);\n \
    \     |                   ^\n"
  stdout: ''
  timestamp: 1660134646
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n        long sum = 0;\n     \
    \   for (auto elem : q) {\n                sum += elem;\n        }\n        if\
    \ (sum < w) {\n                return false;\n        }\n        long maxWeight\
    \ = w;\n        long maxElem = 0;\n        std::vector<long> maxWeightWeight;\n\
    \        std::vector<long> maxElemWeight;\n        for (auto elem : q) {\n   \
    \             if (elem > maxElem) {\n                        maxElem = elem;\n\
    \                        maxElemWeight = maxWeightWeight;\n                  \
    \      maxWeightWeight = maxWeight;\n                        maxElemWeight = maxElemWeight;\n\
    \                }\n                maxElemWeight.push_back(elem);\n         \
    \       maxWeightWeight += elem;\n        }\n        if (maxWeightWeight == w)\
    \ {\n                return true;\n        }\n        return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn2ijeqs6.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpn2ijeqs6.cpp:34:43: error: no match for \u2018\
    operator=\u2019 (operand types are \u2018std::vector<long int>\u2019 and \u2018\
    long int\u2019)\n   34 |                         maxWeightWeight = maxWeight;\n\
    \      |                                           ^~~~~~~~~\nIn file included\
    \ from /usr/include/c++/9/vector:72,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpn2ijeqs6.cpp:2:\n/usr/include/c++/9/bits/vector.tcc:198:5:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(const\
    \ std::vector<_Tp, _Alloc>&) [with _Tp = long int; _Alloc = std::allocator<long\
    \ int>]\u2019\n  198 |     vector<_Tp, _Alloc>::\n      |     ^~~~~~~~~~~~~~~~~~~\n\
    /usr/include/c++/9/bits/vector.tcc:199:42: note:   no known conversion for argument\
    \ 1 from \u2018long int\u2019 to \u2018const std::vector<long int>&\u2019\n  199\
    \ |     operator=(const vector<_Tp, _Alloc>& __x)\n      |               ~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpn2ijeqs6.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:706:7:\
    \ note: candidate: \u2018std::vector<_Tp, _Alloc>& std::vector<_Tp, _Alloc>::operator=(std::vector<_Tp,\
    \ _Alloc>&&) [with _Tp = long int; _Alloc = std::allocator<long int>]\u2019\n\
    \  706 |       operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())\n\
    \      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_vector.h:706:26: note:  \
    \ no known conversion for argument 1 from \u2018long int\u2019 to \u2018std::vector<long\
    \ int>&&"
  stdout: ''
  timestamp: 1660134647
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++11\n\
    \    long maxWeight = std::max(q.front(), w);\n    auto it = std::find_if(q.cbegin(),\
    \ q.cend(), [&](const long l){return l >= maxWeight; });\n    auto begin = std::find_if(q.cbegin(),\
    \ q.cend(), [&](const long l){return l < maxWeight; });\n    \n    if(q.size()\
    \ == begin) {\n        if(q.size() == 1) {\n            if((q.front() == q[q.size()-1])\
    \ && (q.back() == q[q.size()-2]) && (q.size() % 2 != 0)) {\n                return\
    \ true;\n            }\n        }\n        return false;\n    }\n    \n    auto\
    \ mid = std::distance(begin, it);\n    \n    if(q.size() % 2 == 0) {\n       \
    \ for(auto it = std::next(begin); it != it; it++) {\n            if(q[mid] !=\
    \ *it) {\n                return false;\n            }\n        }\n    } else\
    \ {\n        for(auto it = std::next(begin); it != it; it++) {\n            if(q[mid]\
    \ != *it) {\n                return false;\n            }\n        }\n    }\n\
    \    \n    return q[mid] == q[mid+1] && (q.size() % 2 == 0);\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx7foocn6.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpx7foocn6.cpp:24:17: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018std::vector<long int>::size_type\u2019\
    \ {aka \u2018long unsigned int\u2019} and \u2018__gnu_cxx::__normal_iterator<const\
    \ long int*, std::vector<long int> >\u2019)\n   24 |     if(q.size() == begin)\
    \ {\n      |        ~~~~~~~~ ^~ ~~~~~\n      |              |     |\n      | \
    \             |     __gnu_cxx::__normal_iterator<const long int*, std::vector<long\
    \ int> >\n      |              std::vector<long int>::size_type {aka long unsigned\
    \ int}\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n   \
    \              from /usr/include/c++/9/bits/specfun.h:45,\n                 from\
    \ /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpx7foocn6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:883:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR, class _Container>\
    \ bool __gnu_cxx::operator==(const __gnu_cxx::__normal_iterator<_IteratorL, _Container>&,\
    \ const __gnu_cxx::__normal_iterator<_IteratorR, _Container>&)\u2019\n  883 |\
    \     operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,\n   \
    \   |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:883:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpx7foocn6.cpp:24:20: note: \
    \  mismatched types \u2018const __gnu_cxx::__normal_iterator<_IteratorL, _Container>\u2019\
    \ and \u2018std::vector<long int>::size_type\u2019 {aka \u2018long unsigned int\u2019\
    }\n   24 |     if(q.size() == begin) {\n      |                    ^~~~~\nIn file\
    \ included from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from\
    \ /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpx7foocn6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:890:5:\
    \ note: candidate: \u2018template<class _Iterator, class _Contain"
  stdout: ''
  timestamp: 1660134647
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int len = q.size();\n   \
    \ bool ret = (len>1) && (sumOfElements(q)==w) && (len==(len/2)+1);\n    return\
    \ ret;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgbi4s9nk.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpgbi4s9nk.cpp:20:28: error: \u2018sumOfElements\u2019\
    \ was not declared in this scope\n   20 |     bool ret = (len>1) && (sumOfElements(q)==w)\
    \ && (len==(len/2)+1);\n      |                            ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int sum = 0;\n    for(int\
    \ i = 0; i<q.size(); i++){\n        sum += q[i];\n    }\n    int maxWeight = sum\
    \ + w;\n    return sum == maxWeight;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpvv0u580v: /tmp/tmpvv0u580v.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    long\
    \ min_sum = 0;\n    bool b = (q.size() <= 1);\n    for (auto i : q) {\n      \
    \  max_sum = std::max(max_sum, i);\n        min_sum = std::min(min_sum, i);\n\
    \    }\n    if ((min_sum == 0) || (max_sum == w)) {\n        b = true;\n    }\n\
    \    return b;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpbfkd1hq9: /tmp/tmpbfkd1hq9.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \    // YOUR CODE HERE\n    long max_weight;\n    int sum;\n    sum = 0;\n   \
    \ for (auto i : q) {\n        sum = sum + i;\n    }\n    if (sum > w) {\n    \
    \    return false;\n    }\n    for (auto i : q) {\n        max_weight = max_weight\
    \ > i ? max_weight : i;\n    }\n    if (max_weight == w) {\n        return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpwb7z_5mg: /tmp/tmpwb7z_5mg.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maximumWeight = q.back();\n\
    \    if(maximumWeight > w)\n    {\n        return false;\n    }\n    \n    //\
    \ check balance\n    long balance = 0;\n    for(auto element : q)\n    {\n   \
    \     balance += element;\n    }\n    if(balance < 0 || balance > w)\n    {\n\
    \        return false;\n    }\n    \n    // check sum\n    long sum = 0;\n   \
    \ for(auto element : q)\n    {\n        sum += element;\n    }\n    if(sum > maximumWeight)\n\
    \    {\n        return false;\n    }\n    \n    return true;\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpxf6zdigz: /tmp/tmpxf6zdigz.cpp:51: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134648
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  int max_w = 0;\n  for (long\
    \ i = 0; i < (long long) q.size(); i++) {\n    max_w = max(max_w, q.at(i));\n\
    \  }\n  bool ans = true;\n  for (long i = 0; i < (long long) q.size(); i++) {\n\
    \    int sum = 0;\n    for (long j = 0; j < (long long) q.size(); j++) {\n   \
    \   sum += q.at(j);\n      if (sum > max_w)\n        ans = false;\n    }\n  }\n\
    \  return ans;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptc1tyqy_.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptc1tyqy_.cpp:21:13: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   21 |    \
    \ max_w = max(max_w, q.at(i));\n      |             ^~~\n      |             std::max\n\
    In file included from /usr/include/c++/9/algorithm:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmptc1tyqy_.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5: note: \u2018\
    std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp> __l, _Compare\
    \ __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134647
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C\n\
    \    return q == std::vector< long >(q).begin() + q - std::vector< long >(q).begin()/2\
    \ + std::vector< long >(q).begin()/4;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphos598vv.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmphos598vv.cpp:20:48: error: no match for \u2018\
    operator+\u2019 (operand types are \u2018std::vector<long int>::iterator\u2019\
    \ {aka \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long int> >\u2019\
    } and \u2018std::vector<long int>\u2019)\n   20 |     return q == std::vector<\
    \ long >(q).begin() + q - std::vector< long >(q).begin()/2 + std::vector< long\
    \ >(q).begin()/4;\n      |                 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~\n\
    \      |                                             |    |\n      |         \
    \                                    |    std::vector<long int>\n      |     \
    \                                        std::vector<long int>::iterator {aka\
    \ __gnu_cxx::__normal_iterator<long int*, std::vector<long int> >}\nIn file included\
    \ from /usr/include/c++/9/bits/stl_algobase.h:67,\n                 from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmphos598vv.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:856:7:\
    \ note: candidate: \u2018__gnu_cxx::__normal_iterator<_Iterator, _Container> __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>::operator+(__gnu_cxx::__normal_iterator<_Iterator, _Container>::difference_type)\
    \ const [with _Iterator = long int*; _Container = std::vector<long int>; __gnu_cxx::__normal_iterator<_Iterator,\
    \ _Container>::difference_type = long int]\u2019\n  856 |       operator+(difference_type\
    \ __n) const _GLIBCXX_NOEXCEPT\n      |       ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:856:33:\
    \ note:   no known conversion for argument 1 from \u2018std::vector<long int>\u2019\
    \ to \u2018__gnu_cxx::__normal_iterator<long int*, std::vector<long int> >::difference_type\u2019\
    \ {aka \u2018long int\u2019}\n  856 |       operator+(difference_type __n) const\
    \ _GLIBCXX_NOEXCEPT\n      |                 ~~~~~~~~~~~~~~~~^~~\n/usr/include/c++/9/bits/stl_iterator.h:423:5:\
    \ note: candidate: \u2018template<class _Iterator> constexpr"
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    bool fly = false;\n    for\
    \ (int i = 0; i < q.size(); i++) {\n        if (q.at(i) > w) {\n            fly\
    \ = false;\n            break;\n        }\n        if (q.at(i) < -w || q.at(i)\
    \ > w) {\n            fly = true;\n            break;\n        }\n    }\n    return\
    \ fly;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpsch3hq6q: /tmp/tmpsch3hq6q.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134648
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ i = 0; i != q.size(); i++) {\n        sum += q[i];\n    }\n    long max = INT_MIN;\n\
    \    for (long i = 0; i != q.size(); i++) {\n        max = std::max(max, q[i]);\n\
    \    }\n    return sum <= w && sum == std::abs(max);\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpugpxdqc_: /tmp/tmpugpxdqc_.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ el : q) sum += el;\n    if (w > sum) return false;\n    for (auto el : q) sum\
    \ += el;\n    return sum < w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpnufg5atu: /tmp/tmpnufg5atu.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n\tassert(q.size() == q.front().size());\n\
    \tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++)\n\t\tsum += q.front()[i];\n\
    \treturn sum < w && is_palindromic(q) && is_balanced(q);\n}\nint main() {\n  \
    \  auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/cassert:44,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:33,\n               \
    \  from /tmp/tmp_s410rfy.cpp:2:\n/tmp/tmp_s410rfy.cpp: In function \u2018bool\
    \ will_it_fly(std::vector<long int>, long int)\u2019:\n/tmp/tmp_s410rfy.cpp:19:31:\
    \ error: request for member \u2018size\u2019 in \u2018q.std::vector<long int>::front()\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019}\n   19 |  assert(q.size()\
    \ == q.front().size());\n      |                               ^~~~\n/tmp/tmp_s410rfy.cpp:22:21:\
    \ error: invalid types \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>,\
    \ long int>::value_type {aka long int}[long int]\u2019 for array subscript\n \
    \  22 |   sum += q.front()[i];\n      |                     ^\n/tmp/tmp_s410rfy.cpp:23:20:\
    \ error: \u2018is_palindromic\u2019 was not declared in this scope\n   23 |  return\
    \ sum < w && is_palindromic(q) && is_balanced(q);\n      |                   \
    \ ^~~~~~~~~~~~~~\n/tmp/tmp_s410rfy.cpp:23:41: error: \u2018is_balanced\u2019 was\
    \ not declared in this scope\n   23 |  return sum < w && is_palindromic(q) &&\
    \ is_balanced(q);\n      |                                         ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    \n    long max_weight = 0;\n\
    \    int weight = 0;\n    bool bal = 0;\n    \n    for (long num : q) {\n    \
    \    \n        max_weight += num;\n        weight += num;\n        if (max_weight\
    \ > w) {\n            max_weight = w;\n            bal = 1;\n            break;\n\
    \        }\n    }\n    \n    if (bal && max_weight <= w) {\n        std::cout\
    \ << \"true\";\n        return true;\n    }\n    else {\n        std::cout <<\
    \ \"false\";\n        return false;\n    }\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp76hy5q_y: /tmp/tmp76hy5q_y.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = w;\n    for\
    \ (auto x : q) {\n        max_sum = std::max(max_sum, x);\n    }\n    std::reverse(q.begin(),\
    \ q.end());\n    return max_sum >= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp0cbfe_6m: /tmp/tmp0cbfe_6m.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxw = 0;\n    for (long\
    \ i: q) {\n        maxw = max(maxw, i);\n    }\n    for (long i: q) {\n      \
    \  if (i < maxw && i >= w) return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8x0jubwr.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp8x0jubwr.cpp:21:16: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   21 |    \
    \     maxw = max(maxw, i);\n      |                ^~~\n      |              \
    \  std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n       \
    \          from /tmp/tmp8x0jubwr.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134647
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    return is_balanced(q) &&\
    \ std::accumulate(q.begin(), q.end(), 0ULL + w) <= w;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplup0pwb1.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmplup0pwb1.cpp:19:12: error: \u2018is_balanced\u2019\
    \ was not declared in this scope\n   19 |     return is_balanced(q) && std::accumulate(q.begin(),\
    \ q.end(), 0ULL + w) <= w;\n      |            ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum=0;\n    long max_weight=0;\n\
    \    for(size_t i=0;i<q.size();i++){\n        sum+=q[i];\n        if(sum<=w)\n\
    \            return false;\n        max_weight=std::max(max_weight,sum);\n   \
    \ }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxsabsz5d: /tmp/tmpxsabsz5d.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int sum = 0;\n    for (long\
    \ i : q) {\n        sum += i;\n    }\n    if (w > sum) {\n        return true;\n\
    \    }\n    if (sum < w) {\n        return false;\n    }\n    // Write your code\
    \ here.\n    bool ans = false;\n    if (sum == 0) {\n        for (long i : q)\
    \ {\n            ans = true;\n            break;\n        }\n    } else {\n  \
    \      int left = 0;\n        int right = 0;\n        for (long i : q) {\n   \
    \         if (left == right) {\n                if (i == sum) {\n            \
    \        ans = true;\n                }\n            } else {\n              \
    \  if (i > sum) {\n                    ans = true;\n                }\n      \
    \      }\n            left++;\n            right--;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpoj7kkicd: /tmp/tmpoj7kkicd.cpp:58: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134648
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = max_element(q.cbegin(),\
    \ q.cend()) + w;\n    int n = q.size();\n    if (n > 1) {\n        // Find the\
    \ max element in each vector.\n        long max_elem = 0;\n        for (auto elem\
    \ : q) {\n            if (elem > max_elem)\n                max_elem = elem;\n\
    \        }\n        long max_weight = 0;\n        for (auto elem : q) {\n    \
    \        max_weight = std::max(max_weight, std::abs(elem - max_elem));\n     \
    \   }\n        // Check whether q can be balanced.\n        if (max_elem > max_sum\
    \ && max_weight <= w)\n            return true;\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwqrpmuw6.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpwqrpmuw6.cpp:19:54: error: cannot convert \u2018\
    __gnu_cxx::__normal_iterator<const long int*, std::vector<long int> >\u2019 to\
    \ \u2018long int\u2019 in initialization\n   19 |     long max_sum = max_element(q.cbegin(),\
    \ q.cend()) + w;\n      |                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~\n\
    \      |                                                      |\n      |     \
    \                                                 __gnu_cxx::__normal_iterator<const\
    \ long int*, std::vector<long int> >\n"
  stdout: ''
  timestamp: 1660134647
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long len = q.size();\n  \
    \  assert(len > 0 && w > 0);\n    std::vector<long> r;\n    for (long i = 0; i\
    \ < len; i++) {\n        r[len-(i+1)] = q[i];\n    }\n    return will_it_fly(r,\
    \ w);\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660134648
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n\tlong max_sum = w;\n\tlong curr_sum\
    \ = 0;\n\tfor (long i : q) {\n\t\tcurr_sum += i;\n\t\tif (curr_sum > max_sum)\
    \ {\n\t\t\tmax_sum = curr_sum;\n\t\t}\n\t}\n\n\tif (max_sum == w) {\n\t\t// The\
    \ vector is balanced, and the sum of its elements is less than or equal the maximum\
    \ possible weight.\n\t\treturn true;\n\t}\n\treturn false;\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmprpi25iu5: /tmp/tmprpi25iu5.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // TODO: Use your solution\
    \ to write this function.\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp1wlzbfbr: /tmp/tmp1wlzbfbr.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  if (q.size() == 0 || q[0].size()\
    \ == 0) {\n    return false;\n  }\n  if (q.size() == 1) {\n    return true;\n\
    \  }\n  if (q.size() > 1 && q[0].size() > 1) {\n    return false;\n  }\n  for\
    \ (long i = 0; i < q.size(); i++) {\n    long sum = 0;\n    for (long j = 0; j\
    \ < q[i].size(); j++) {\n      sum += q[i][j];\n    }\n    if (sum != w) {\n \
    \     return false;\n    }\n  }\n  return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphh3m4dt1.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmphh3m4dt1.cpp:19:29: error: request for member\
    \ \u2018size\u2019 in \u2018q.std::vector<long int>::operator[](0)\u2019, which\
    \ is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<long int>,\
    \ long int>::value_type\u2019 {aka \u2018long int\u2019}\n   19 |   if (q.size()\
    \ == 0 || q[0].size() == 0) {\n      |                             ^~~~\n/tmp/tmphh3m4dt1.cpp:25:28:\
    \ error: request for member \u2018size\u2019 in \u2018q.std::vector<long int>::operator[](0)\u2019\
    , which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019}\n   25 |   if (q.size()\
    \ > 1 && q[0].size() > 1) {\n      |                            ^~~~\n/tmp/tmphh3m4dt1.cpp:30:31:\
    \ error: request for member \u2018size\u2019 in \u2018q.std::vector<long int>::operator[](((std::vector<long\
    \ int>::size_type)i))\u2019, which is of non-class type \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019}\n   30 |     for\
    \ (long j = 0; j < q[i].size(); j++) {\n      |                              \
    \ ^~~~\n/tmp/tmphh3m4dt1.cpp:31:20: error: invalid types \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type {aka long int}[long int]\u2019 for array subscript\n\
    \   31 |       sum += q[i][j];\n      |                    ^\n"
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() % 2 != 0) {\n\
    \        // The object q must fly, otherwise there is no solution.\n        return\
    \ false;\n    }\n    std::stack<long> stack;\n    for (size_t i = 0; i < q.size();\
    \ ++i) {\n        if (stack.empty() || stack.top() > q[i])\n            stack.push(q[i]);\n\
    \        else if (stack.top() < q[i])\n            return false;\n    }\n    if\
    \ (stack.size() == 0) {\n        // The object q is balanced, so it's possible\
    \ to fly it.\n        return true;\n    }\n    size_t left = q.size() / 2;\n \
    \   size_t right = q.size() - 1;\n    long max_weight = w;\n    while (left <\
    \ right) {\n        long mid = left + (right - left) / 2;\n        if (q[mid]\
    \ > max_weight) {\n            right = mid;\n            max_weight = q[mid];\n\
    \        } else if (q[mid] < max_weight) {\n            left = mid + 1;\n    \
    \        max_weight = q[mid];\n        } else {\n            // We've already\
    \ checked mid.\n            assert(max_weight == q[mid]);\n            return\
    \ true;\n        }\n    }\n    // We've gone all the way through, but max_weight\
    \ != q[mid].\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmph_9ydy85: /tmp/tmph_9ydy85.cpp:56: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    int\
    \ max_sum = (1 << n) - 1;\n    \n    long sum = 0;\n    for (long i : q) {\n \
    \       sum += i;\n    }\n    \n    return sum < max_sum && sum == (sum % 2);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpb1umdhpg: /tmp/tmpb1umdhpg.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long long sum = 0;\n    for\
    \ (auto itr = q.rbegin(); itr != q.rend(); ++itr)\n        sum += *itr;\n    if\
    \ (sum > w)\n        return false;\n    if (sum == w)\n        return true;\n\
    \    long long max_possible_weight = 0;\n    for (auto itr = q.rbegin(); itr !=\
    \ q.rend(); ++itr)\n        max_possible_weight = max(max_possible_weight, *itr);\n\
    \    if (max_possible_weight == w)\n        return true;\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_f7c1vfv.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp_f7c1vfv.cpp:28:31: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   28 |    \
    \     max_possible_weight = max(max_possible_weight, *itr);\n      |         \
    \                      ^~~\n      |                               std::max\nIn\
    \ file included from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_f7c1vfv.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n\tlong sum = 0;\n\tfor (auto&\
    \ elem: q) sum += elem;\n\treturn (w <= sum) && (sum < (LONG_MAX / w));\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpasgkuql4: /tmp/tmpasgkuql4.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134648
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int m = q.size();\n    if\
    \ (m == 0)\n        return true;\n    else if (m == 1)\n        return q[0] ==\
    \ 0;\n    else\n        return q[0] == 0 || q[0] == 1 && will_it_fly(q.back(),\
    \ w);\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp51za_8r.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpp51za_8r.cpp:25:60: error: could not convert\
    \ \u2018q.std::vector<long int>::back()\u2019 from \u2018__gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type\u2019 {aka \u2018long int\u2019} to \u2018std::vector<long\
    \ int>\u2019\n   25 |         return q[0] == 0 || q[0] == 1 && will_it_fly(q.back(),\
    \ w);\n      |                                                      ~~~~~~^~\n\
    \      |                                                            |\n      |\
    \                                                            __gnu_cxx::__alloc_traits<std::allocator<long\
    \ int>, long int>::value_type {aka long int}\n"
  stdout: ''
  timestamp: 1660134647
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long ans = 0;\n    long max\
    \ = std::max(q.front(), q.back());\n    q.front() = max - w;\n    q.back() = max\
    \ + w;\n    long ansoff = 0;\n    for (long i = 0; i < q.size(); ++i) {\n    \
    \    if (q[i] >= max)\n            return false;\n        else {\n           \
    \ ansoff += q[i];\n        }\n    }\n    long res = ansoff % 2 == 0;\n    ansoff\
    \ /= 2;\n    if (ansoff < w)\n        return false;\n    ans += ansoff;\n    bool\
    \ res = ans >= w;\n    return res;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp1j8dbin.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpp1j8dbin.cpp:36:10: error: conflicting declaration\
    \ \u2018bool res\u2019\n   36 |     bool res = ans >= w;\n      |          ^~~\n\
    /tmp/tmpp1j8dbin.cpp:31:10: note: previous declaration as \u2018long int res\u2019\
    \n   31 |     long res = ansoff % 2 == 0;\n      |          ^~~\n"
  stdout: ''
  timestamp: 1660134646
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\n\
    \n    long min_value = q.back();\n    auto max_value = q.front();\n\n    int max_value_pos\
    \ = 0;\n    int min_value_pos = 0;\n\n    bool balancing_condition = false;\n\n\
    \    for (int i = 1; i < q.size(); i++) {\n        if (q.at(i) < min_value) {\n\
    \            min_value_pos = i;\n            min_value = q.at(i);\n        } else\
    \ if (q.at(i) > max_value) {\n            max_value_pos = i;\n            max_value\
    \ = q.at(i);\n        }\n    }\n\n    int count = 0;\n    for (int i = 0; i <\
    \ q.size(); i++) {\n        if (q.at(i) == min_value) {\n            count++;\n\
    \        }\n    }\n\n    if (count > max_value_pos - min_value_pos + 1) {\n  \
    \      balancing_condition = true;\n    } else {\n        balancing_condition\
    \ = false;\n    }\n\n    if (balancing_condition == false) {\n        return false;\n\
    \    }\n\n    bool all_equal = true;\n    for (int i = 0; i < q.size(); i++) {\n\
    \        if (q.at(i) != q.at(i - 1)) {\n            all_equal = false;\n     \
    \       break;\n        }\n    }\n\n    if (all_equal == false) {\n        return\
    \ false;\n    }\n\n    return w <= max_value + min_value;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  vector::_M_range_check: __n (which is 18446744073709551615) >= this->size()\
    \ (which is 3)\n"
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    if\
    \ (n == 0) {\n        return true;\n    }\n    if (n == 1) {\n        if (q[0]\
    \ == 0) {\n            return false;\n        }\n        return true;\n    }\n\
    \    long max_w = 0.0;\n    for (int i = 0; i < n; i++) {\n        long current_q\
    \ = q[i];\n        long temp = 0;\n        for (int j = i; j < n; j++) {\n   \
    \         temp += q[j];\n            if (temp > max_w) {\n                max_w\
    \ = temp;\n            }\n        }\n        if (max_w <= w) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpi35vp9fo: /tmp/tmpi35vp9fo.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_val = q.back() +\
    \ w;\n    if (max_val < 0)\n        return false;\n\n    for (long i = 0; i <=\
    \ max_val / 2; i++)\n        if (q.back() + i != q.front())\n            return\
    \ false;\n\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmppwrq_2iy: /tmp/tmppwrq_2iy.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n\tassert(q.size() == (w+1));\n\
    \tlong sum = 0;\n\tfor (long i = 0; i < q.size(); i++) {\n\t\tsum += q[i];\n\t\
    }\n\treturn sum <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpip2nnu1y: /tmp/tmpip2nnu1y.cpp:19: bool will_it_fly(std::vector<long
    int>, long int): Assertion `q.size() == (w+1)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  assert(q.size() == q.capacity());\n\
    \  long ans = 0;\n  long max_val = 0;\n  for (long i = 0; i < q.size(); i++) {\n\
    \    ans += q[i];\n  }\n  max_val = ans;\n  for (long i = q.size(); i > 0; i--)\
    \ {\n    ans -= q[i - 1];\n    if (ans <= w) {\n      return true;\n    }\n  }\n\
    \  return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpkfc8jhte: /tmp/tmpkfc8jhte.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134648
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max = 0, sum = 0;\n\
    \    for (long i: q) sum += i;\n    for (long i = 0; i < q.size(); i++) max +=\
    \ q[i];\n    if (sum < w) return false; // not a palindromic vector\n    if (sum\
    \ > w) {\n        max = sum;\n        for (long i = 0; i < q.size(); i++) max\
    \ -= q[i];\n    }\n    bool is_balanced = max >= w;\n    return is_balanced &&\
    \ std::equal(q.begin(), q.end(), q.begin(), [](long a, long b) {return a == b;\
    \ });\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpr6jnbcdw: /tmp/tmpr6jnbcdw.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() == 0 || w ==\
    \ 0) return false;\n    long sum = 0;\n    for(int i = 0; i < q.size(); i++) {\n\
    \        sum += q[i];\n    }\n    if (sum >= w) return false;\n    int mid = (int)q.size()/2;\n\
    \    long sum2 = sum;\n    for(int i = 0; i < mid; i++) {\n        sum2 += q[i];\n\
    \    }\n    return sum2 <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpnjotxs_n: /tmp/tmpnjotxs_n.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long ans = 0;\n    // write\
    \ your code here\n    if (q.size() > 0 && q.back() == q.front()) {\n        ans\
    \ = q.size() - 1;\n        for (auto i : q) {\n            ans += i;\n       \
    \ }\n        if (w <= ans) {\n            return true;\n        }\n    }\n   \
    \ return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp0ybnel2i: /tmp/tmp0ybnel2i.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3})),
    (5)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int l = 0;\n    int r = q.size()-1;\n\
    \    long sum = 0;\n    while (l <= r) {\n        int mid = (l+r)/2;\n       \
    \ if (q[mid] == mid) {\n            sum += q[mid];\n            if (sum > w) {\n\
    \                return false;\n            }\n            l += mid+1;\n     \
    \       r -= mid+1;\n        }\n        else if (q[mid] < mid) {\n           \
    \ l = mid + 1;\n        }\n        else {\n            r = mid - 1;\n        }\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpkczyt7l_: /tmp/tmpkczyt7l_.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134647
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C++14\
    \ (if your compiler support c++14 please use C++14)\n    // refer to this post\
    \ to see how you can write your code in C++14:\n    // https://stackoverflow.com/questions/2764797/c14-features\n\
    \    return q.empty() || (w <= 0 || q.back() == q[0]);\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp6ythw9v8: /tmp/tmp6ythw9v8.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (1)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134649
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (int\
    \ i = 0; i < q.size(); i++)\n        sum += q[i];\n    return sum <= w;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp_4swez20: /tmp/tmp_4swez20.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134650
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxWeight = w;\n   \
    \ long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >\
    \ maxWeight) return false;\n    }\n    return true;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp7vgn8aux: /tmp/tmp7vgn8aux.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134650
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int max_sum = (int)sqrt(w);\n\
    \    if (q.size() < 2) return false;\n    long sum = 0;\n    for (auto i : q)\
    \ {\n        sum += i;\n        if (sum > max_sum) return false;\n    }\n    sum\
    \ = (int)(sum * max_sum);\n    if (sum < w) return true;\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmps0zu9cg4: /tmp/tmps0zu9cg4.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134650
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here.\n    if(q.empty())\
    \ return true;\n    auto mid = q.size()/2;\n    std::vector<long> a = q;\n   \
    \ a.erase(a.begin()+mid, a.end());\n    std::vector<long> b = q;\n    b.erase(b.begin()+mid,\
    \ b.end());\n    if(q == a && w <= a.back())\n        return true;\n    else if(q\
    \ == b && w <= b.back())\n        return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp7l7ayh1n: /tmp/tmp7l7ayh1n.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134650
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if(w.bit_length() > q.size())\
    \ {\n        // This happens when the vector is too long.\n        // It's unbalanced,\
    \ and it won't fly.\n        return false;\n    }\n    long sum = 0;\n    for(const\
    \ auto& i : q) {\n        sum += i;\n    }\n    if(sum <= w) {\n        // The\
    \ sum is less than or equal to the maximum possible weight.\n        // It's balanced.\n\
    \        return true;\n    }\n    long remainder = w - sum;\n    for(const auto&\
    \ i : q) {\n        if(i % 2 == 1) {\n            // This happens when a vector\
    \ is missing an even number, and it's unbalanced.\n            // It won't fly.\n\
    \            return false;\n        }\n        sum += i;\n    }\n    if(remainder\
    \ % 2 != 0) {\n        // This happens when the vector is missing an odd number,\
    \ and it's unbalanced.\n        // It won't fly.\n        return false;\n    }\n\
    \    sum -= remainder;\n    if(sum > 0) {\n        // The sum is greater than\
    \ zero, and it's balanced.\n        return true;\n    }\n    // The sum is equal\
    \ to zero, and it's unbalanced.\n    return false;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcez2yxy3.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpcez2yxy3.cpp:19:10: error: request for member\
    \ \u2018bit_length\u2019 in \u2018w\u2019, which is of non-class type \u2018long\
    \ int\u2019\n   19 |     if(w.bit_length() > q.size()) {\n      |          ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134649
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long ans = 0;\n    long max\
    \ = pow(10, 9) + 1;\n    for (long i = 0; i < q.size(); i++) {\n        ans +=\
    \ q[i] * pow(10, i);\n        if (ans > max) return false;\n    }\n    if (ans\
    \ > w) return false;\n    if (ans == w) return true;\n    return false;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp7tlq9ht3: /tmp/tmp7tlq9ht3.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134650
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  int n = q.size();\n  assert(n\
    \ % 2 == 0);\n  int sum = 0;\n  for (int i = 0; i < n; i += 2) {\n    sum += q.at(i);\n\
    \  }\n  assert(sum >= w);\n  int max = INT_MIN;\n  for (int i = 1; i < n; ++i)\
    \ {\n    max = max(max, q.at(i) + q.at(n - i - 1));\n  }\n  return sum <= max;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi2fyw2ui.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpi2fyw2ui.cpp:28:45: error: \u2018max\u2019 cannot\
    \ be used as a function\n   28 |     max = max(max, q.at(i) + q.at(n - i - 1));\n\
    \      |                                             ^\n"
  stdout: ''
  timestamp: 1660134649
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Write your code here.\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqk40ywyb: /tmp/tmpqk40ywyb.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134650
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  long sum = 0;\n  for (auto\
    \ it : q) {\n    sum += it;\n  }\n  return (sum <= w) && (sum == (sum + q[q.size()\
    \ - 1]));\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp2jxtfxbw: /tmp/tmp2jxtfxbw.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134650
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    bool fly_q = false;\n   \
    \ long sum = 0;\n    for (auto &i : q) {\n        sum += i;\n    }\n    if (sum\
    \ >= w) {\n        fly_q = true;\n    }\n    return fly_q;\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpq2m0o7az: /tmp/tmpq2m0o7az.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (long i = 0; i < q.size(); i++) {\n        max_sum += q[i];\n    }\n    if (max_sum\
    \ == w) {\n        return true;\n    }\n    int len = q.size();\n    bool flag\
    \ = false;\n    for (int i = 0; i < len; i++) {\n        for (int j = 0; j < len;\
    \ j++) {\n            if (q[i] == q[j] && i != j) {\n                flag = true;\n\
    \                break;\n            }\n        }\n        if (flag) {\n     \
    \       break;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp7wj6bmcw: /tmp/tmp7wj6bmcw.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3})),
    (5)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134650
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = max(q);\n\
    \    if (max_weight > w) return false;\n    std::vector<long> r(q);\n    for (size_t\
    \ i = 0; i < q.size(); i++) {\n        long temp = q[i] - max_weight;\n      \
    \  if (temp > 0) r[i] += temp;\n        else r[i] -= temp;\n    }\n    if (r.size()\
    \ <= 1) return true;\n    return will_it_fly(r, w);\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3rzksegs.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp3rzksegs.cpp:19:28: error: no matching function\
    \ for call to \u2018max(std::vector<long int>&)\u2019\n   19 |     long max_weight\
    \ = max(q);\n      |                            ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp3rzksegs.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmp3rzksegs.cpp:19:28: note: \
    \  candidate expects 2 arguments, 1 provided\n   19 |     long max_weight = max(q);\n\
    \      |                            ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp3rzksegs.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp3rzksegs.cpp:19:28:\
    \ note:   candidate expects 3 arguments, 1 provided\n   19 |     long max_weight\
    \ = max(q);\n      |                            ^\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3rzksegs.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3462:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr _Tp std::max(std::initializer_list<_Tp>)\u2019\
    \n 3462 |     max(initializer"
  stdout: ''
  timestamp: 1660134650
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    std::sort(q.begin(),\
    \ q.end());\n    long sum = std::accumulate(q.begin(), q.end(), 0);\n    if (sum\
    \ < w)\n        return false;\n    std::reverse(q.begin(), q.end());\n    if (sum\
    \ == w)\n        return true;\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqlzydp15: /tmp/tmpqlzydp15.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134650
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxweight = maxsum(w);\n\
    \    return isbalanced(q) && w <= maxweight;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6lcawq9r.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp6lcawq9r.cpp:19:22: error: \u2018maxsum\u2019\
    \ was not declared in this scope\n   19 |     long maxweight = maxsum(w);\n  \
    \    |                      ^~~~~~\n/tmp/tmp6lcawq9r.cpp:20:12: error: \u2018\
    isbalanced\u2019 was not declared in this scope\n   20 |     return isbalanced(q)\
    \ && w <= maxweight;\n      |            ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134650
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Write your solution here\n\
    \    if(q.size()<=1){\n        return true;\n    }\n    std::vector<long> a=q,\
    \ c=a;\n    bool b=true;\n    for(int i=0;i<a.size();i++){\n        if(a[i]==0){\n\
    \            b=false;\n            break;\n        }\n        for(int j=i;j<a.size();j++){\n\
    \            c[i]=c[i]+a[j];\n            if(c[i]>w){\n                b=false;\n\
    \                break;\n            }\n        }\n    }\n    return b;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpiep6nnt3: /tmp/tmpiep6nnt3.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long min_weight = 0;\n  \
    \  long max_weight = 0;\n    long total_weight = 0;\n    for (long i = 0; i <\
    \ q.size(); i++)\n    {\n        total_weight += q[i];\n        if (total_weight\
    \ <= w)\n        {\n            min_weight = total_weight;\n            break;\n\
    \        }\n        max_weight = total_weight;\n    }\n    if (max_weight < w)\n\
    \        return false;\n    long s = max_weight;\n    for (long i = 0; i < q.size();\
    \ i++)\n    {\n        if (q[i] < min_weight)\n            return false;\n   \
    \     s = s - q[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpo4hhpi85: /tmp/tmpo4hhpi85.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n\tif (q.size() <= 1) {\n\t\t\
    return true;\n\t} else if (q.size() == 2 && q[0] == q[1]) {\n\t\treturn false;\n\
    \t} else {\n\t\tlong sum = 0;\n\t\tfor (int i = 0; i < q.size(); i++) {\n\t\t\t\
    sum += q.at(i);\n\t\t\tif (sum > w) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\
    \t\treturn true;\n\t}\n}\nint main() {\n    auto candidate = will_it_fly;\n  \
    \  assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpva2lwav7: /tmp/tmpva2lwav7.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = 0;\n  \
    \  for (long i : q)\n        max_weight = max(max_weight, i);\n    if (max_weight\
    \ < w)\n        return false;\n    std::vector<long> q_copy = q;\n    q_copy.reserve(q.size()\
    \ / 2);\n    for (long i : q)\n        if (i > 0)\n            q_copy.push_back(i);\n\
    \    long sum = 0;\n    for (long i : q_copy)\n        sum += i;\n    if (sum\
    \ < w)\n        return false;\n    long m = max_weight;\n    for (long i : q_copy)\
    \ {\n        long d = w - sum;\n        sum += i;\n        if (sum > w)\n    \
    \        return false;\n        if (d > max_weight - m)\n            max_weight\
    \ = m;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpau2wxhih.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpau2wxhih.cpp:21:22: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   21 |    \
    \     max_weight = max(max_weight, i);\n      |                      ^~~\n   \
    \   |                      std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpau2wxhih.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134650
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n\tstd::reverse(q.begin(), q.end());\n\
    \treturn std::equal(q.begin(), q.end(), q.begin(), [w](long i, long j) {\n\t\t\
    return std::abs(i - j) <= w;\n\t});\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpczq4jp_x: /tmp/tmpczq4jp_x.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_element = *max_element(q.begin(),\
    \ q.end());\n    long sum = 0;\n    for (size_t i = 0; i < q.size(); i++) {\n\
    \        sum += q[i];\n    }\n    return (max_element <= w && sum <= w && is_balanced(q));\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5rf0iwim.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp5rf0iwim.cpp:19:55: error: \u2018max_element\u2019\
    \ cannot be used as a function\n   19 |     long max_element = *max_element(q.begin(),\
    \ q.end());\n      |                                                       ^\n\
    /tmp/tmp5rf0iwim.cpp:24:45: error: \u2018is_balanced\u2019 was not declared in\
    \ this scope\n   24 |     return (max_element <= w && sum <= w && is_balanced(q));\n\
    \      |                                             ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134650
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Write code here\n    \n\
    \    long ans = 0;\n    \n    for (long i =0; i < q.size(); i++) {\n        ans\
    \ = ans + q[i];\n    }\n    \n    if (ans >= w) {\n        return true;\n    }\
    \ else {\n        return false;\n    }\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpm0k008ij: /tmp/tmpm0k008ij.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134652
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  long max_sum = std::accumulate(q.begin(),\
    \ q.end(), 0L);\n  if(max_sum <= w) return false;\n  \n  int n = q.size();\n \
    \ long sum = 0;\n  for(int i = 0; i < n; i++) {\n    sum += q[i];\n    if(sum\
    \ > w) return false;\n  }\n  return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpihzxppmu: /tmp/tmpihzxppmu.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int size = q.size();\n  \
    \  // write your code here\n    assert(q.size() > 0);\n    assert(w > 0);\n  \
    \  int max_sum = 0, max_weight = w;\n    for (int i = 0; i < size - 1; i++) {\n\
    \        max_sum += q[i];\n        if (max_sum > max_weight) {\n            max_sum\
    \ = max_sum - max_weight;\n            return false;\n        }\n    }\n    return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpr4hogfka: /tmp/tmpr4hogfka.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  long max_sum = 0;\n  for (long\
    \ i = 0; i < q.size(); i++) {\n    max_sum += q[i];\n  }\n  if (max_sum > w)\n\
    \    return false;\n  // We can return true because a palindromic vector is balanced\
    \ if and only if it's sum equals w\n  long sum = 0;\n  for (long i = 0; i < q.size();\
    \ i++) {\n    sum += q[i];\n  }\n  return (sum == w);\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmphjeuesz3: /tmp/tmphjeuesz3.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxw = 0;\n    for (auto&\
    \ i : q) {\n        maxw = max(maxw, i);\n    }\n    if (w == maxw) return false;\n\
    \    if (w < maxw) return true;\n    if (std::count(q.begin(), q.end(), q[q.size()\
    \ - 1]) != 0) return false;\n    long sumofelements = 0;\n    for (auto& i : q)\
    \ {\n        sumofelements += i;\n    }\n    if (sumofelements <= w) return false;\n\
    \    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkylln_k3.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpkylln_k3.cpp:21:16: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   21 |    \
    \     maxw = max(maxw, i);\n      |                ^~~\n      |              \
    \  std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n       \
    \          from /tmp/tmpkylln_k3.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134650
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long n = q.size();\n    assert(n\
    \ >= 0);\n    // We could use std::accumulate, but we don't\n    // need to because\
    \ we don't need the final result.\n    // We could also use std::for_each (but\
    \ maybe we\n    // should use std::accumulate).\n    long ans = 0;\n    for (long\
    \ i = 0; i < n; ++i)\n        ans += q[i];\n    if (ans + w <= n)\n        return\
    \ true;\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmph9ttz9vg: /tmp/tmph9ttz9vg.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max;\n    q.resize(q.size());\n\
    \    long sum = 0;\n    for(int i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if(sum > w) {\n            max++;\n            sum -= w;\n        }\n\
    \        q[i] = max;\n    }\n    if (sum >= w) {\n        return true;\n    }\n\
    \    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpurdudl_q: /tmp/tmpurdudl_q.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134652
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    std::stack<bool> stack;\n\
    \    stack.push(q.size() <= w);\n    while (!stack.empty()) {\n        if (!stack.top())\
    \ {\n            stack.pop();\n            assert(stack.empty());\n          \
    \  return false;\n        }\n        else {\n            long s = 0;\n       \
    \     long c = 0;\n            for (int i = 0; i < q.size(); i++) {\n        \
    \        s += q.at(i);\n                if (c > s - w) {\n                   \
    \ c = s - w;\n                }\n            }\n            if (c == 0 || c <\
    \ w) {\n                return true;\n            }\n            stack.push(c\
    \ == 0);\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmptzreujgp: /tmp/tmptzreujgp.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxSum = q.back() +\
    \ w;\n    for (size_t i = 0; i != q.size(); ++i) {\n        long sum = q.at(i)\
    \ + w;\n        if (sum > maxSum) return false;\n        maxSum = sum;\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpy1wtrl79: /tmp/tmpy1wtrl79.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() == 0 || w ==\
    \ 0) {\n        return false;\n    }\n    long max_length = (long) q.size();\n\
    \    long min_length = max_length;\n    if (q.size() % 2 != 0) {\n        return\
    \ will_it_fly(q, w);\n    }\n    for (size_t i = max_length; i > 0; i /= 2) {\n\
    \        min_length = i;\n    }\n    long max_sum = 0;\n    for (size_t i = 0;\
    \ i < q.size(); i++) {\n        max_sum += q[i];\n        if (max_sum > w) {\n\
    \            break;\n        }\n    }\n    if (max_sum == w) {\n        if (q.size()\
    \ % 2 == 1) {\n            // The sum of weights of the odd elements is equal\
    \ to the weight, so it's balanced.\n            return true;\n        }\n    \
    \    for (size_t i = max_sum; i > 0; i /= 2) {\n            if (max_sum == min_length)\
    \ {\n                return true;\n            }\n        }\n    }\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660134651
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    vector<int> qb(q.size());\n\
    \    long maxW = 0;\n    for (auto v : q)\n        if (v > maxW)\n           \
    \ maxW = v;\n    qb.erase(std::remove_if(qb.begin(), qb.end(), [maxW](int &v)\
    \ { return v >= maxW; }), qb.end());\n    if (q.size() % 2 == 1) {\n        if\
    \ (q[q.size() - 1] != q[0]) {\n            vector<int> pb(q.size() - 1);\n   \
    \         for (auto v : q) {\n                pb[q.size() - 1 - v] = v;\n    \
    \        }\n            qb.erase(std::remove_if(pb.begin(), pb.end(), [maxW](int\
    \ &v) { return v >= maxW; }), pb.end());\n        }\n    }\n    if (qb.size()\
    \ % 2 == 0)\n        qb.push_back(qb.back());\n    long sum = 0;\n    for (auto\
    \ v : qb) {\n        sum += v;\n    }\n    return (sum + w <= maxW);\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_9_9fqla.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp_9_9fqla.cpp:19:5: error: \u2018vector\u2019\
    \ was not declared in this scope\n   19 |     vector<int> qb(q.size());\n    \
    \  |     ^~~~~~\n/tmp/tmp_9_9fqla.cpp:19:5: note: suggested alternatives:\nIn\
    \ file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_9_9fqla.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_9_9fqla.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp_9_9fqla.cpp:19:12:\
    \ error: expected primary-expression before \u2018int\u2019\n   19 |     vector<int>\
    \ qb(q.size());\n      |            ^~~\n/tmp/tmp_9_9fqla.cpp:24:5: error: \u2018\
    qb\u2019 was not declared in this scope; did you mean \u2018q\u2019?\n   24 |\
    \     qb.erase(std::remove_if(qb.begin(), qb.end(), [maxW](int &v) { return v\
    \ >= maxW; }), qb.end());\n      |     ^~\n      |     q\n/tmp/tmp_9_9fqla.cpp:27:20:\
    \ error: expected primary-expression before \u2018int\u2019\n   27 |         \
    \    vector<int> pb(q.size() - 1);\n      |                    ^~~\n/tmp/tmp_9_9fqla.cpp:29:17:\
    \ error: \u2018pb\u2019 was not declared in this scope\n   29 |              \
    \   pb[q.size() - 1 - v] = v;\n      |                 ^~\n/tmp/tmp_9_9fqla.cpp:31:37:\
    \ error: \u2018pb\u2019 was not declared in this scope\n   31 |        "
  stdout: ''
  timestamp: 1660134650
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Fill this in.\n    return\
    \ will_it_fly(q, w);\n}\nint main() {\n    auto candidate = will_it_fly;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));\n\
    \    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660134651
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long n = q.size();\n    if(n==0)\
    \ return false;\n    long max_w = 0;\n    for(long i=0; i<n; i++) {\n        if(q[i]>max_w)\
    \ max_w = q[i];\n    }\n    // We need to check that the maximum possible weight\
    \ won't be exceeded.\n    assert(max_w <= w);\n    long max_s = 0;\n    for(long\
    \ i=0; i<n; i++) {\n        long s = q[i] + i;\n        if(s > max_s) max_s =\
    \ s;\n    }\n    return (max_s == w);\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpnhu4nae0: /tmp/tmpnhu4nae0.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134652
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = 0;\n  \
    \  for(long i = 0; i < q.size(); i++)\n        max_weight = std::max(max_weight,\
    \ q[i]);\n\n    for(long i = 0; i < q.size(); i++) {\n        if(q[i] != 0) {\n\
    \            if(q[i - 1] != 0 && q[i + 1] != 0 && will_it_fly(q, {q[i-1] + q[i]\
    \ + q[i+1]})) {\n                return false;\n            }\n        }\n   \
    \ }\n    return max_weight <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660134651
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n\tassert(q.size() == w.size());\n\
    \tassert(q == reverse(q));\n\tassert(w <= q.back());\n\tassert(q.back() <= w);\n\
    \tassert(q.size() % 2 == 1);\n\tlong sum = 0;\n\tfor (size_t i = 0; i < q.size()\
    \ / 2; i++) {\n\t\tsum += q[i * 2 + 0];\n\t\tsum += q[i * 2 + 1];\n\t}\n\treturn\
    \ sum <= w && sum == std::accumulate(q.begin(), q.end(), 0);\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/cassert:44,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:33,\n               \
    \  from /tmp/tmpgs8ih3jg.cpp:2:\n/tmp/tmpgs8ih3jg.cpp: In function \u2018bool\
    \ will_it_fly(std::vector<long int>, long int)\u2019:\n/tmp/tmpgs8ih3jg.cpp:19:23:\
    \ error: request for member \u2018size\u2019 in \u2018w\u2019, which is of non-class\
    \ type \u2018long int\u2019\n   19 |  assert(q.size() == w.size());\n      | \
    \                      ^~~~\n/tmp/tmpgs8ih3jg.cpp:20:23: error: no matching function\
    \ for call to \u2018reverse(std::vector<long int>&)\u2019\n   20 |  assert(q ==\
    \ reverse(q));\n      |                       ^\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgs8ih3jg.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:1186:5:\
    \ note: candidate: \u2018template<class _BIter> void std::reverse(_BIter, _BIter)\u2019\
    \n 1186 |     reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n\
    \      |     ^~~~~~~\n/usr/include/c++/9/bits/stl_algo.h:1186:5: note:   template\
    \ argument deduction/substitution failed:\nIn file included from /usr/include/c++/9/cassert:44,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpgs8ih3jg.cpp:2:\n/tmp/tmpgs8ih3jg.cpp:20:23: note:\
    \   candidate expects 2 arguments, 1 provided\n   20 |  assert(q == reverse(q));\n\
    \      |                       ^\nIn file included from /usr/include/c++/9/algorithm:71,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgs8ih3jg.cpp:2:\n/usr/include/c++/9/pstl/glue_algorithm_defs.h:249:1:\
    \ note: candidate: \u2018template<class _ExecutionPolicy, class _BidirectionalIterator>\
    \ __pstl::__internal::__enable_if_execution_policy<_ExecutionPolicy, void> std::reverse(_ExecutionPolicy&&,\
    \ _BidirectionalIterator, _BidirectionalIterator)\u2019\n  249 | reverse(_ExecutionPolicy&&\
    \ __exec, _BidirectionalIterator __first, _BidirectionalIterator __last);\n  \
    \    | ^~~~~~~\n/u"
  stdout: ''
  timestamp: 1660134650
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    if(q.size()\
    \ == 0){\n        return true;\n    }\n    if(q.size() == 1){\n        return\
    \ false;\n    }\n    if(q.size() == 2){\n        if(w==q[0]+q[1])\n          \
    \  return true;\n        else\n            return false;\n    }\n\n    long leftSum\
    \ = 0;\n    long rightSum = 0;\n    long maxW = 0;\n    long minW = 0;\n    long\
    \ leftQ = 0;\n    long rightQ = 0;\n    long index = 0;\n    for(auto &i : q){\n\
    \        if((index%2) == 0){\n            leftQ += i;\n            maxW += w;\n\
    \        }\n        else{\n            rightQ += i;\n            minW += w;\n\
    \        }\n        index++;\n    }\n\n    if(leftQ > maxW || rightQ < minW)\n\
    \        return false;\n    long middleW = (maxW + minW)/2;\n    for(auto &i :\
    \ q){\n        if((index%2) == 0){\n            if(middleW == leftQ + i)\n   \
    \             leftSum = leftSum + i;\n            else\n                rightSum\
    \ = rightSum + i;\n        }\n        else{\n            if(middleW == rightQ\
    \ - i)\n                leftSum = leftSum + i;\n            else\n           \
    \     rightSum = rightSum + i;\n        }\n        index++;\n    }\n    if(leftSum\
    \ < middleW && middleW - leftSum < w)\n        return true;\n    else if(rightSum\
    \ > middleW && middleW - rightSum < w)\n        return true;\n    else\n     \
    \   return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpno4h79s5: /tmp/tmpno4h79s5.cpp:79: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() == 0)\n    \
    \    return true;\n\n    bool flag = false;\n\n    // if q is palindrome then\
    \ sum of elements is less than or equal to weight\n    if (std::equal(q.rbegin(),\
    \ q.rend(), q.begin())) \n        flag = q.size() <= w;\n\n    // if q is unbalanced\
    \ then sum of elements is not less than or equal to weight\n    else if (std::equal(q.begin(),\
    \ q.end(), q.rbegin())) \n        flag = q.size() > w;\n\n    // if q is not palindrome\
    \ then sum of elements is more than equal to weight\n    else\n        flag =\
    \ q.size() >= w;\n\n    return flag;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660134651
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n        long sum = 0;\n     \
    \   // Write your code here.\n        long max_sum = 0;\n        for(int i=0;\
    \ i<q.size(); i++)\n        {\n                sum = sum + q[i];\n        }\n\
    \        if(sum < w)\n        {\n            return false;\n        }\n      \
    \  else if(sum == w)\n        {\n            return true;\n        }\n       \
    \ else\n        {\n            max_sum = sum;\n        }\n        for(int j=0;\
    \ j<q.size()-1; j++)\n        {\n            sum = sum - q[j];\n            if(sum\
    \ < w)\n            {\n                return false;\n            }\n        \
    \    else if(sum == w)\n            {\n                return true;\n        \
    \    }\n            else\n            {\n                max_sum = sum;\n    \
    \        }\n        }\n        return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp81x91k40: /tmp/tmp81x91k40.cpp:58: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134652
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  int n = q.size();\n  long max_sum\
    \ = q[n-1];\n  for (int i = 0; i <= n-2; i++) {\n    long curr_sum = q[i];\n \
    \   if (curr_sum > max_sum) {\n      max_sum = curr_sum;\n    }\n  }\n  for (int\
    \ i = n-2; i >= 0; i--) {\n    long curr_sum = q[i];\n    if (curr_sum > max_sum)\
    \ {\n      max_sum = curr_sum;\n    }\n  }\n  assert(max_sum <= w);\n  return\
    \ max_sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpyzx8zasf: /tmp/tmpyzx8zasf.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134651
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maxW = 0;\n    for (long\
    \ i = 0; i < q.size(); i++) {\n        maxW = max(maxW, q[i]);\n    }\n    long\
    \ sum = 0;\n    for (long i = 0; i < q.size(); i++) {\n        sum += q[i];\n\
    \        if (sum < 0 || sum > maxW) {\n            return false;\n        }\n\
    \    }\n    return sum <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5na6siv5.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp5na6siv5.cpp:21:16: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   21 |    \
    \     maxW = max(maxW, q[i]);\n      |                ^~~\n      |           \
    \     std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n     \
    \            from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n    \
    \             from /tmp/tmp5na6siv5.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134651
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if(q.size() == 0 || w > q.back())\n\
    \        return false;\n    long max_sum = 0;\n    long max_element = 0;\n   \
    \ for(long i = 1; i < q.size(); i++)\n        max_sum += q[i];\n    if(max_sum\
    \ != w)\n        return false;\n    for(long i = 1; i < q.size(); i++)\n    {\n\
    \        long s = q[i];\n        if(max_element < s)\n        {\n            max_element\
    \ = s;\n        }\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpcm8u9ls0: /tmp/tmpcm8u9ls0.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134652
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int sum = 0;\n    for (size_t\
    \ i = 0; i < q.size(); ++i) {\n        sum += q[i];\n        if (sum > w) return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpl9_peum7: /tmp/tmpl9_peum7.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134652
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in C or\
    \ C++14 (preferred), or C++11\n    // you may not use any standard library function\
    \ except vector and list\n    //assert(q.size() <= w);\n    //std::vector<long>\
    \ reverse = std::reverse(q.begin(), q.end());\n    long min = 0;\n    int min_idx\
    \ = 0;\n    for (int i = 0; i <= w; i++) {\n        for (int j = i; j >= 0; j--)\
    \ {\n            int count = 0;\n            if (q.at(j - i) == q.at(j - i)) {\n\
    \                count++;\n            }\n            if (count > min) {\n   \
    \             min = count;\n                min_idx = j - i;\n            }\n\
    \        }\n    }\n    if (q.size() > min_idx) {\n        return false;\n    }\
    \ else {\n        return true;\n    }\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  vector::_M_range_check: __n (which is 18446744073709551615) >= this->size()\
    \ (which is 3)\n"
  stdout: ''
  timestamp: 1660134652
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Write your code here\n\
    \    //  assert(q.size() == w);\n    std::reverse(q.begin(), q.end());\n    if\
    \ (q.size() < w) return false;\n    auto sum = 0;\n    for (auto i : q) sum +=\
    \ i;\n    return sum < w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp1inrax_h: /tmp/tmp1inrax_h.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134652
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  assert(q.size() >= 2);\n  long\
    \ long max = std::max(q.back(), q.front());\n  q.pop_back();\n  q.pop_back();\n\
    \  return q.size() >= 2 && ((q.back() == max && q.front() == max) || q == std::vector{});\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpif838kbu.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpif838kbu.cpp:23:86: error: class template argument\
    \ deduction failed:\n   23 |   return q.size() >= 2 && ((q.back() == max && q.front()\
    \ == max) || q == std::vector{});\n      |                                   \
    \                                                   ^\n/tmp/tmpif838kbu.cpp:23:86:\
    \ error: no matching function for call to \u2018vector()\u2019\nIn file included\
    \ from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpif838kbu.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:1872:5:\
    \ note: candidate: \u2018template<class _InputIterator, class _ValT, class _Allocator,\
    \ class, class> std::vector(_InputIterator, _InputIterator, _Allocator)-> std::vector<_ValT,\
    \ _Allocator>\u2019\n 1872 |     vector(_InputIterator, _InputIterator, _Allocator\
    \ = _Allocator())\n      |     ^~~~~~\n/usr/include/c++/9/bits/stl_vector.h:1872:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpif838kbu.cpp:23:86:\
    \ note:   candidate expects 3 arguments, 0 provided\n   23 |   return q.size()\
    \ >= 2 && ((q.back() == max && q.front() == max) || q == std::vector{});\n   \
    \   |                                                                        \
    \              ^\nIn file included from /usr/include/c++/9/vector:67,\n      \
    \           from /usr/include/c++/9/functional:62,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpif838kbu.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:650:2: note: candidate:\
    \ \u2018template<class _Tp, class _Alloc, class _InputIterator, class> vector(_InputIterator,\
    \ _InputIterator, const _Alloc&)-> std::v"
  stdout: ''
  timestamp: 1660134651
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() == 0 || w <=\
    \ 0) {\n        return false;\n    }\n    long max_w = 0;\n    for (auto val :\
    \ q) {\n        max_w = max(max_w, val);\n    }\n    if (max_w == 0) {\n     \
    \   return false;\n    }\n    // Write your solution here\n    long sum = 0;\n\
    \    for(auto val: q) {\n        sum+=val;\n    }\n    if(max_w>sum) {\n     \
    \   return false;\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph86rnqyi.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmph86rnqyi.cpp:24:17: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   24 |    \
    \     max_w = max(max_w, val);\n      |                 ^~~\n      |         \
    \        std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n  \
    \               from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n \
    \                from /tmp/tmph86rnqyi.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134652
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() != 0) {\n  \
    \      if (q.front() < q[q.size() - 1])\n            return false;\n        if\
    \ (q.front() == q[q.size() - 1]) {\n            std::vector<long> q1;\n      \
    \      q1.push_back(q[0]);\n            q1.push_back(q[q.size() - 1]);\n     \
    \       std::vector<long> q2 = q;\n            q2.erase(q2.begin() + q.size()\
    \ - 1);\n            if (q2 < q1)\n                return false;\n           \
    \ else\n                return true;\n        }\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpgjgxyr0j: /tmp/tmpgjgxyr0j.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134653
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto\
    \ i : q) {\n        sum += i;\n    }\n    return sum <= w;\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpdz1fg4js: /tmp/tmpdz1fg4js.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134653
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    //Your code here\n    if\
    \ (q.size() <= 1)\n        return true;\n    bool flag = false;\n    int max =\
    \ 0;\n    for (int i = 0; i < q.size() - 1; i++) {\n        if (q[i] == q[i +\
    \ 1]) {\n            if (max < q[i] + w) {\n                max = q[i] + w;\n\
    \                flag = true;\n            }\n        }\n    }\n    if (flag ==\
    \ false) {\n        if (max < q[0]) {\n            max = q[0];\n            flag\
    \ = true;\n        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpdnk_2bdw: /tmp/tmpdnk_2bdw.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134653
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  // write your code in C or\
    \ C++14 (preferred) here\n  if (q.empty() || w <= 0)\n    return false;\n  long\
    \ sum = q[0]; // Initialize sum to first element\n  for (auto x : q)\n    sum\
    \ += x;\n  if (sum > w)\n    return false;\n  return true;\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpf_gp_fib: /tmp/tmpf_gp_fib.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134653
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  // write your code in here\n\
    \  if (q.size() == 0) {\n    return w == 0;\n  }\n  int min = INT_MAX;\n  for\
    \ (long i : q) {\n    if (i == min && min > 0)\n      return true;\n    min =\
    \ i;\n  }\n  return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp7efvmlg7: /tmp/tmp7efvmlg7.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134653
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  int sum = 0;\n  for (int i\
    \ = 0; i < q.size(); i++) {\n    sum += q.at(i);\n  }\n  if (sum == w && is_palindromic(q,\
    \ w)) {\n    return true;\n  } else {\n    return false;\n  }\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyqovmda1.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpyqovmda1.cpp:23:19: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   23 |   if (sum == w && is_palindromic(q,\
    \ w)) {\n      |                   ^~~~~~~~~~~~~~\n/tmp/tmpyqovmda1.cpp:28:1:\
    \ warning: control reaches end of non-void function [-Wreturn-type]\n   28 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660134653
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int max_weight = (int) (sqrt(pow(2*q[0],\
    \ 2) + pow(2*q[1], 2) + pow(2*q[2], 2)) + 0.5) + w;\n    long sum = 0;\n    for\
    \ (int i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum <=\
    \ max_weight) {\n        return false;\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp_or7fyks: /tmp/tmp_or7fyks.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134654
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    assert(q.size() == q.size());\n\
    \    long ans = 0;\n    for (long i : q) {\n        ans += i;\n        if (ans\
    \ >= w)\n            return true;\n    }\n    return false;\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqxunbofz: /tmp/tmpqxunbofz.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134654
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int max_weight = std::max(w,\
    \ *q.rbegin());\n    if (max_weight == 0) return true;\n    int max_weight2 =\
    \ max_weight - 1;\n    bool palindromic = std::equal(q.rbegin(), q.rend(), q.rbegin());\n\
    \    if (palindromic) {\n        int sum = 0;\n        long w2 = 0;\n        for\
    \ (auto i : q) {\n            sum += i;\n            w2 += i;\n        }\n   \
    \     return sum <= w2;\n    } else {\n        // not palindromic\n        return\
    \ false;\n    }\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpxpjo1800: /tmp/tmpxpjo1800.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134653
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    assert(q.size() == 0);\n\
    \    assert(w > 0);\n    long maxW = std::abs(q.front());\n    for (int i = 1;\
    \ i < q.size(); ++i) {\n        if ((std::abs(q.at(i)) > maxW) || (std::abs(q.at(i)\
    \ - w) < maxW)) {\n            maxW += std::abs(q.at(i));\n        } else {\n\
    \            return false;\n        }\n    }\n    return true;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpcu7jxu5z: /tmp/tmpcu7jxu5z.cpp:19: bool will_it_fly(std::vector<long
    int>, long int): Assertion `q.size() == 0'' failed.

    '
  stdout: ''
  timestamp: 1660134653
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int max = (int) q[(q.size()/2)-1];\n\
    \    for(int i = q.size()/2; i > 0; i--){\n        if(max+q[i] < w) return false;\n\
    \        max = max+q[i];\n    }\n    return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp7mt6r0f9: /tmp/tmp7mt6r0f9.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134654
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  std::reverse(q.begin(), q.end());\
    \ // reverse the vector\n  if (q == std::vector(q.begin(), q.begin() + q.size()\
    \ / 2))\n    return true;\n  long max_sum = w;\n  for (long i = q.size(); i >\
    \ 1; i--)\n    max_sum = std::max({max_sum, std::accumulate(q.begin(), q.begin()\
    \ + i - 1, max_sum)});\n  return max_sum == w;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp9gs9dmg1: /tmp/tmp9gs9dmg1.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134654
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    int\
    \ s = n*(n+1)/2;\n    int max_n = INT_MIN; // INT_MAX;\n    for (int i = 0; i\
    \ <= s; ++i) {\n        max_n = max(max_n, i);\n    }\n    for (int i = 0; i <\
    \ n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            int c = (q[i]\
    \ + q[j])*w;\n            if (c <= max_n) {\n                return true;\n  \
    \          }\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6n7_n59o.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp6n7_n59o.cpp:23:17: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   23 |    \
    \     max_n = max(max_n, i);\n      |                 ^~~\n      |           \
    \      std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n    \
    \             from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n   \
    \              from /tmp/tmp6n7_n59o.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134653
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    long\
    \ max = 0;\n    for (auto x : q){\n        max = max*x + 1;\n    }\n    return\
    \ max <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqede1m_v: /tmp/tmpqede1m_v.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134654
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    assert(q.size() == 6);\n\
    \    bool flag = true;\n    for (long i = 0; i<=q.size()/2;i++) {\n        if(q[i*2]\
    \ + q[i*2+1] + q[i*2+2] <= w){\n            return false;\n        }\n    }\n\
    \    return flag;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpzorxpktf: /tmp/tmpzorxpktf.cpp:19: bool will_it_fly(std::vector<long
    int>, long int): Assertion `q.size() == 6'' failed.

    '
  stdout: ''
  timestamp: 1660134654
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() == 0)\n    \
    \    return true;\n\n    if (q.size() % 2 != 0)\n        return false;\n\n   \
    \ // Calculate the difference between the maximum and the sum of the elements\
    \ of q.\n    // If the sum of q.size() divided by 2 is greater than or equal to\
    \ the maximum, then the object q will fly.\n    if (q.size() / 2 < w)\n      \
    \  return false;\n\n    // If it balances, then the sum is less than or equal\
    \ to the maximum possible weight, so the object q will fly.\n    if (std::inner_product(q.begin(),\
    \ q.end(), q.begin(), 0LL, std::plus<long>()) <= w)\n        return true;\n\n\
    \    // It's unbalanced, but it's balanced; so we check whether each number in\
    \ q is equal to the sum of its two neighbors.\n    std::vector<long> q1(q.size()\
    \ / 2);\n    std::copy(q.begin(), q.begin() + q.size() / 2, q1.begin());\n   \
    \ std::vector<long> q2(q.size() / 2);\n    std::copy(q.begin() + q.size() / 2,\
    \ q.end(), q2.begin());\n    if (q1 == q2)\n        return true;\n\n    return\
    \ false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp0rgy0m7.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpp0rgy0m7.cpp:31:81: error: no matching function\
    \ for call to \u2018inner_product(std::vector<long int>::iterator, std::vector<long\
    \ int>::iterator, std::vector<long int>::iterator, long long int, std::plus<long\
    \ int>)\u2019\n   31 |     if (std::inner_product(q.begin(), q.end(), q.begin(),\
    \ 0LL, std::plus<long>()) <= w)\n      |                                     \
    \                                            ^\nIn file included from /usr/include/c++/9/numeric:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:84,\n\
    \                 from /tmp/tmpp0rgy0m7.cpp:2:\n/usr/include/c++/9/bits/stl_numeric.h:186:5:\
    \ note: candidate: \u2018template<class _InputIterator1, class _InputIterator2,\
    \ class _Tp> _Tp std::inner_product(_InputIterator1, _InputIterator1, _InputIterator2,\
    \ _Tp)\u2019\n  186 |     inner_product(_InputIterator1 __first1, _InputIterator1\
    \ __last1,\n      |     ^~~~~~~~~~~~~\n/usr/include/c++/9/bits/stl_numeric.h:186:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpp0rgy0m7.cpp:31:81:\
    \ note:   candidate expects 4 arguments, 5 provided\n   31 |     if (std::inner_product(q.begin(),\
    \ q.end(), q.begin(), 0LL, std::plus<long>()) <= w)\n      |                 \
    \                                                                ^\nIn file included\
    \ from /usr/include/c++/9/numeric:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:84,\n\
    \                 from /tmp/tmpp0rgy0m7.cpp:2:\n/usr/include/c++/9/bits/stl_numeric.h:218:5:\
    \ note: candidate: \u2018template<class _InputIterator1, class _InputIterator2,\
    \ class _Tp, class _BinaryOperation1, class _BinaryOperation2> _Tp std::inner_product(_InputIterator1,\
    \ _InputIterator1, _InputIterator2, _Tp, _BinaryOperation1, _BinaryOperation2)\u2019\
    \n  218 |     inner_product(_InputIterator1 __first1, _InputIterator1 __last1,\n\
    \      |     ^~~~~~~~~~~~~\n/usr/include/c++/9/bits/stl_numeric.h:218:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpp0"
  stdout: ''
  timestamp: 1660134653
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    assert(q.size() > 0);\n \
    \   assert(w > 0);\n\n    // return false;\n\n    long largest = 0;\n    for (long\
    \ i : q) if (i > largest) largest = i;\n\n    if (largest <= w) return true;\n\
    \n    long sum = 0;\n    for (long i : q) sum += i;\n\n    return sum < w;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpgqzkt6e3: /tmp/tmpgqzkt6e3.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134654
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int maxW = 0;\n    long sum\
    \ = 0;\n    for (auto v : q) {\n        sum += v;\n        maxW = max(maxW, v);\n\
    \    }\n    return (sum < w && maxW == 0);\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnb13_er_.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpnb13_er_.cpp:23:16: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   23 |    \
    \     maxW = max(maxW, v);\n      |                ^~~\n      |              \
    \  std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n        \
    \         from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n       \
    \          from /tmp/tmpnb13_er_.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134653
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.isEmpty()) {\n    \
    \    return false;\n    }\n    if (q.size() == 1) {\n        return true;\n  \
    \  }\n    // Write your code here.\n    long max = -std::numeric_limits<long>::max();\n\
    \    long sum = 0;\n    for (auto el : q) {\n        sum += el;\n        if (sum\
    \ < w) {\n            return false;\n        }\n        max = std::max(max, el);\n\
    \    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgx1p4dhd.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpgx1p4dhd.cpp:19:11: error: \u2018class std::vector<long\
    \ int>\u2019 has no member named \u2018isEmpty\u2019; did you mean \u2018empty\u2019\
    ?\n   19 |     if (q.isEmpty()) {\n      |           ^~~~~~~\n      |        \
    \   empty\n"
  stdout: ''
  timestamp: 1660134654
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int maxWeight = q.back();\n\
    \    for (int i = 0; i < q.size(); i++)\n        maxWeight = max(maxWeight, q[i]);\n\
    \    int sum = 0;\n    for (int i : q)\n        sum += i;\n    return sum < maxWeight\
    \ && isPalindromic(q, w);\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmtdq___0.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpmtdq___0.cpp:21:21: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   21 |    \
    \     maxWeight = max(maxWeight, q[i]);\n      |                     ^~~\n   \
    \   |                     std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmtdq___0.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n/tmp/tmpmtdq___0.cpp:25:31: error: \u2018\
    isPalindromic\u2019 was not declared in this scope\n   25 |     return sum < maxWeight\
    \ && isPalindromic(q, w);\n      |                               ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134654
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  std::vector<long> a = q;\n\
    \  // int sum = 0;\n  // for (long i = 0; i < a.size(); i++) {\n  //   sum +=\
    \ a[i];\n  // }\n  // if (sum >= w) return false; else return true;\n\n  long\
    \ s = 0;\n  long i = 0;\n  long r = a.size() - 1;\n  while (i <= r) {\n    s +=\
    \ a[i];\n    i++;\n    r--;\n  }\n  if (s >= w) return false; else return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpphvgzqdy: /tmp/tmpphvgzqdy.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134655
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_w = w * 2 - 1;\n\
    \    auto comp = [](long a, long b) {return a > b;};\n    \n    if(q.size() ==\
    \ 0) {\n        return false;\n    }\n    // palindromic vector\n    bool is_palindromic\
    \ = std::equal(q.begin(), q.begin() + q.size() / 2, q.rbegin(), comp);\n    //\
    \ sum of its elements <= maximum possible weight\n    auto sum_it = std::find_if(q.begin()\
    \ + q.size() / 2, q.end(), comp);\n    if(sum_it == q.end()) {\n        // if\
    \ sum_it == q.end()\n        if(q.size() <= w) {\n            // if q.size() <=\
    \ w\n            // if sum_it != q.end()\n            return is_palindromic;\n\
    \        }\n        // if sum_it != q.end()\n        // if q.size() > w\n    \
    \    // if sum_it == q.end()\n        return false;\n    }\n    // sum_it != q.end()\n\
    \    // if sum_it == q.end()\n    return is_palindromic;\n}\nint main() {\n  \
    \  auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/bits/stl_algobase.h:71,\n    \
    \             from /usr/include/c++/9/bits/specfun.h:45,\n                 from\
    \ /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp58kru0ql.cpp:2:\n/usr/include/c++/9/bits/predefined_ops.h:\
    \ In instantiation of \u2018bool __gnu_cxx::__ops::_Iter_pred<_Predicate>::operator()(_Iterator)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<long int*, std::vector<long int>\
    \ >; _Predicate = will_it_fly(std::vector<long int>, long int)::<lambda(long int,\
    \ long int)>]\u2019:\n/usr/include/c++/9/bits/stl_algo.h:120:14:   required from\
    \ \u2018_RandomAccessIterator std::__find_if(_RandomAccessIterator, _RandomAccessIterator,\
    \ _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator<long\
    \ int*, std::vector<long int> >; _Predicate = __gnu_cxx::__ops::_Iter_pred<will_it_fly(std::vector<long\
    \ int>, long int)::<lambda(long int, long int)> >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:161:23:\
    \   required from \u2018_Iterator std::__find_if(_Iterator, _Iterator, _Predicate)\
    \ [with _Iterator = __gnu_cxx::__normal_iterator<long int*, std::vector<long int>\
    \ >; _Predicate = __gnu_cxx::__ops::_Iter_pred<will_it_fly(std::vector<long int>,\
    \ long int)::<lambda(long int, long int)> >]\u2019\n/usr/include/c++/9/bits/stl_algo.h:3969:28:\
    \   required from \u2018_IIter std::find_if(_IIter, _IIter, _Predicate) [with\
    \ _IIter = __gnu_cxx::__normal_iterator<long int*, std::vector<long int> >; _Predicate\
    \ = will_it_fly(std::vector<long int>, long int)::<lambda(long int, long int)>]\u2019\
    \n/tmp/tmp58kru0ql.cpp:28:71:   required from here\n/usr/include/c++/9/bits/predefined_ops.h:283:11:\
    \ error: no match for call to \u2018(will_it_fly(std::vector<long int>, long int)::<lambda(long\
    \ int, long int)>) (long int&)\u2019\n  283 |  { return bool(_M_pred(*__it));\
    \ }\n      |           ^~~~~~~~~~~~~~~~~~~~\n/usr/include/c++/9/bits/predefined_ops.h:283:11:\
    \ note: candidate: \u2018bool (*)(long int, long int)\u2019 <conversion>\n/usr"
  stdout: ''
  timestamp: 1660134654
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int sum = 0;\n    for (auto&\
    \ x : q) {\n        sum += x;\n    }\n    if (sum < w) return false;\n    else\
    \ return sum == w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpdetfvs48: /tmp/tmpdetfvs48.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134655
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  std::vector<long> arr1 = q;\n\
    \  sort(arr1.begin(), arr1.end());\n  // if the sum of its elements is less than\
    \ or equal the maximum possible weight w\n  if (w >= arr1[0] + arr1[1] && w >=\
    \ arr1[1] + arr1[0]) {\n    return true;\n  } else {\n    return false;\n  }\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpc5re_aec: /tmp/tmpc5re_aec.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134655
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (long\
    \ &i : q) {\n        sum += i;\n    }\n    if (sum < w)\n        return true;\n\
    \    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpbcp0ll5j: /tmp/tmpbcp0ll5j.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134654
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Write your solution here\n\
    \    long ans = 0;\n    for(long i = 0;i < q.size();i++){\n        ans += q[i];\n\
    \    }\n    if(ans <= w){\n        return true;\n    }\n    return false;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp1b2fx7g2: /tmp/tmp1b2fx7g2.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134655
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    assert(q.size() <= 1000 &&\
    \ q.size() >= 10);\n    long max = 0;\n    for (auto i : q) max = std::max(max,\
    \ i);\n    if (q.size() == 1 && (q[0] == 0 || q[0] == 1)) return true;\n    if\
    \ (max <= w) return false;\n    long s = 0, r = 0;\n    for (auto i : q) r +=\
    \ i;\n    while (s < r - 1) {\n        long mid = s + (r - s) / 2;\n        if\
    \ (will_it_fly(q, mid)) return true;\n        mid = (r + s) / 2;\n        if (will_it_fly(q,\
    \ mid)) return true;\n        s = mid;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp7ifgxnhc: /tmp/tmp7ifgxnhc.cpp:19: bool will_it_fly(std::vector<long
    int>, long int): Assertion `q.size() <= 1000 && q.size() >= 10'' failed.

    '
  stdout: ''
  timestamp: 1660134655
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code\n    long\
    \ maxWeight = 0;\n    for (long i = 0; i < q.size(); i++) {\n        maxWeight\
    \ = max(maxWeight, q[i]);\n    }\n    long sum = 0;\n    for (long i = 0; i <\
    \ q.size(); i++) {\n        sum += q[i];\n    }\n    if (sum == maxWeight && maxWeight\
    \ <= w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxyjf9nix.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpxyjf9nix.cpp:22:21: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   22 |    \
    \     maxWeight = max(maxWeight, q[i]);\n      |                     ^~~\n   \
    \   |                     std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxyjf9nix.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134654
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    std::stack<int> s;\n    long\
    \ min_sum = std::min(q[0], q[q.size()-1]);\n    for(int i = 0; i<q.size(); i++)\
    \ {\n        if(s.empty() || (q[i] != q[s.size()-1] && q[i] < min_sum + w)) {\n\
    \            min_sum = q[i];\n        }\n        s.push(q[i]);\n    }\n    if(s.empty())\
    \ return false;\n    while(s.size() > 1) {\n        int sum = s.top() + s.top();\n\
    \        min_sum = std::min(min_sum, sum + s.top());\n        s.pop();\n    }\n\
    \    return min_sum == w && s.top() == 0;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpepha8erg.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpepha8erg.cpp:30:50: error: no matching function\
    \ for call to \u2018min(long int&, int)\u2019\n   30 |         min_sum = std::min(min_sum,\
    \ sum + s.top());\n      |                                                  ^\n\
    In file included from /usr/include/c++/9/bits/specfun.h:45,\n                \
    \ from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpepha8erg.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:198:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::min(const\
    \ _Tp&, const _Tp&)\u2019\n  198 |     min(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:198:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpepha8erg.cpp:30:50: note: \
    \  deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019\
    \ and \u2018int\u2019)\n   30 |         min_sum = std::min(min_sum, sum + s.top());\n\
    \      |                                                  ^\nIn file included\
    \ from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpepha8erg.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::min(const _Tp&, const _Tp&, _Compare)\u2019\n  246 |     min(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:246:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpepha8erg.cpp:30:50:\
    \ note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018\
    long int\u2019 and \u2018int\u2019)\n   30 |         min_sum = std::min(min_sum,\
    \ sum + s.top());\n      |                                                  ^\n\
    In file included from /usr/include/c++/9/algorithm:62,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:"
  stdout: ''
  timestamp: 1660134654
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    return\
    \ check_balanced(q, w);\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpp13gtcqw.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpp13gtcqw.cpp:20:12: error: \u2018check_balanced\u2019\
    \ was not declared in this scope\n   20 |     return check_balanced(q, w);\n \
    \     |            ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134654
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if(!q.isPalindromic())\n\
    \        return false;\n    if(q.size() >= w) return false;\n    long sum = 0;\n\
    \    for(long i : q)\n        sum += i;\n    return (sum<=w) && (sum>=0);\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq5cnqkk7.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpq5cnqkk7.cpp:19:11: error: \u2018class std::vector<long\
    \ int>\u2019 has no member named \u2018isPalindromic\u2019\n   19 |     if(!q.isPalindromic())\n\
    \      |           ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134654
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() == 0 || w <=\
    \ 0)\n        return false;\n    if (q.size() == 1 && q[0] == w)\n        return\
    \ true;\n    if (std::reverse(q.begin(), q.end()) == q)\n        return true;\n\
    \    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpj_zb5w8n.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpj_zb5w8n.cpp:23:42: error: no match for \u2018\
    operator==\u2019 (operand types are \u2018void\u2019 and \u2018std::vector<long\
    \ int>\u2019)\n   23 |     if (std::reverse(q.begin(), q.end()) == q)\n      |\
    \         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~ ~\n      |                     |\
    \                       |\n      |                     void                  \
    \  std::vector<long int>\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpj_zb5w8n.cpp:2:\n/usr/include/c++/9/bits/regex.h:1026:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator==(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1026 |     operator==(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1026:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpj_zb5w8n.cpp:23:45:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018void\u2019\n   23 |     if (std::reverse(q.begin(), q.end()) == q)\n\
    \      |                                             ^\nIn file included from\
    \ /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpj_zb5w8n.cpp:2:\n/usr/include/c++/9/bits/regex.h:1099:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator==(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1099 |     operator==(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1099:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpj_zb5w8n.cpp:23:45: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>\u2019 and \u2018void\u2019\n   23 |"
  stdout: ''
  timestamp: 1660134654
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n        auto is_palindromic =\
    \ [&q](int i,int j) -> bool {\n                if(q.at(i) == q.at(j)) {\n    \
    \                    int n = j+1;\n                        while(n < q.size()\
    \ && q.at(n) == q.at(i)) ++n;\n                        if(n < q.size()) return\
    \ true;\n                        else return false;\n                }\n     \
    \           return false;\n        };\n        for(auto i = 0LL; i < q.size()\
    \ && q.at(i) != 0; ++i) {\n                if(!is_palindromic(i, i - 1)) return\
    \ false;\n        }\n        if(q.size() > 1) {\n                for(auto i =\
    \ q.size() - 1L; i != 0LL && is_palindromic(i, i - 1L); --i) {\n             \
    \           if(q.at(i) != 0) return false;\n                }\n        }\n   \
    \     return q.at(0) == 0 && w <= q.size();\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  vector::_M_range_check: __n (which is 18446744073709551615) >= this->size()\
    \ (which is 3)\n"
  stdout: ''
  timestamp: 1660134655
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (auto v : q) {\n        max_sum += v;\n    }\n    return max_sum <= w;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp32egfi4a: /tmp/tmp32egfi4a.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134656
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long maximum = std::max(q.front(),\
    \ q.back());\n    for (long i = maximum; i >= 0; i--) {\n        if (std::find(q.begin(),\
    \ q.end(), i) == q.end()) {\n            return false;\n        }\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp5wloelj1: /tmp/tmp5wloelj1.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134655
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    vector<bool> isPalin(q.size());\n\
    \    vector<long> temp;\n    long sum = 0;\n    int n = q.size();\n    for(long\
    \ i = 0; i < n; i++) {\n        isPalin[i] = q[i]%2 == 1 && q[i] > 0;\n      \
    \  sum += q[i];\n        for(long j = i; j < n; j += 2) {\n            temp[sum\
    \ - q[j]] = true;\n        }\n    }\n    // if the sum of the elements is equal\
    \ to w the vector is balanced and\n    // the vector will not be able to fly.\n\
    \    if(sum == w) {\n        if(isPalin.size() == n) {\n            return true;\n\
    \        } else {\n            return false;\n        }\n    } else {\n      \
    \  return false;\n    }\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7zspge2h.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp7zspge2h.cpp:19:5: error: \u2018vector\u2019\
    \ was not declared in this scope\n   19 |     vector<bool> isPalin(q.size());\n\
    \      |     ^~~~~~\n/tmp/tmp7zspge2h.cpp:19:5: note: suggested alternatives:\n\
    In file included from /usr/include/c++/9/vector:67,\n                 from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7zspge2h.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:386:11:\
    \ note:   \u2018std::vector\u2019\n  386 |     class vector : protected _Vector_base<_Tp,\
    \ _Alloc>\n      |           ^~~~~~\nIn file included from /usr/include/c++/9/functional:62,\n\
    \                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n   \
    \              from /usr/include/c++/9/algorithm:71,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7zspge2h.cpp:2:\n/usr/include/c++/9/vector:90:13:\
    \ note:   \u2018std::pmr::vector\u2019\n   90 |       using vector = std::vector<_Tp,\
    \ polymorphic_allocator<_Tp>>;\n      |             ^~~~~~\n/tmp/tmp7zspge2h.cpp:19:12:\
    \ error: expected primary-expression before \u2018bool\u2019\n   19 |     vector<bool>\
    \ isPalin(q.size());\n      |            ^~~~\n/tmp/tmp7zspge2h.cpp:20:12: error:\
    \ expected primary-expression before \u2018long\u2019\n   20 |     vector<long>\
    \ temp;\n      |            ^~~~\n/tmp/tmp7zspge2h.cpp:24:9: error: \u2018isPalin\u2019\
    \ was not declared in this scope\n   24 |         isPalin[i] = q[i]%2 == 1 &&\
    \ q[i] > 0;\n      |         ^~~~~~~\n/tmp/tmp7zspge2h.cpp:27:13: error: \u2018\
    temp\u2019 was not declared in this scope\n   27 |             temp[sum - q[j]]\
    \ = true;\n      |             ^~~~\n/tmp/tmp7zspge2h.cpp:33:12: error: \u2018\
    isPalin\u2019 was not declared in this scope\n   33 |         if(isPalin.size()\
    \ == n) {\n      |            ^~~~~~~\n/tmp/tmp7zspge2h.cpp:41:1: warning"
  stdout: ''
  timestamp: 1660134655
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = std::max(q.front(),\
    \ q.back()) + 1;\n    long sum = 0;\n    for(size_t i = 0; i != q.size(); ++i)\
    \ {\n        sum += q[i];\n        if(sum > max_weight) return false;\n    }\n\
    \    if(sum == max_weight) return true;\n    return false;\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp6g9f0mvn: /tmp/tmp6g9f0mvn.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134656
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    assert(q.size() == (unsigned\
    \ int)w);\n    if (q.size() == 1) return true;\n    // reverse the vector\n  \
    \  std::reverse(&q[0], &q[q.size()]);\n    // if the sum is less than or equal\
    \ the maximum possible weight (not balanced), then it will\n    // fly if it is\
    \ a palindromic vector\n    return std::equal(&q[0], &q[q.size()-1], (long)0);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "In file included from /usr/include/c++/9/bits/specfun.h:45,\n         \
    \        from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpwbntukby.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:\
    \ In instantiation of \u2018bool std::__equal_aux(_II1, _II1, _II2) [with _II1\
    \ = long int*; _II2 = long int]\u2019:\n/usr/include/c++/9/bits/stl_algobase.h:1069:30:\
    \   required from \u2018bool std::equal(_II1, _II1, _II2) [with _II1 = long int*;\
    \ _II2 = long int]\u2019\n/tmp/tmpwbntukby.cpp:25:53:   required from here\n/usr/include/c++/9/bits/stl_algobase.h:844:58:\
    \ error: no type named \u2018value_type\u2019 in \u2018struct std::iterator_traits<long\
    \ int>\u2019\n  844 |       typedef typename iterator_traits<_II2>::value_type\
    \ _ValueType2;\n      |                                                      \
    \    ^~~~~~~~~~~\n/usr/include/c++/9/bits/stl_algobase.h:849:9: error: no type\
    \ named \u2018value_type\u2019 in \u2018struct std::iterator_traits<long int>\u2019\
    \n  845 |       const bool __simple = ((__is_integer<_ValueType1>::__value\n \
    \     |                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  846\
    \ |          || __is_pointer<_ValueType1>::__value)\n      |          ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \  847 |         && __is_pointer<_II1>::__value\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \  848 |         && __is_pointer<_II2>::__value\n      |         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \  849 |         && __are_same<_ValueType1, _ValueType2>::__value);\n      | \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134655
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  long sum_q = 0;\n  long max_weight\
    \ = 0;\n  for (long i : q) {\n    sum_q += i;\n    max_weight = std::max(max_weight,\
    \ i);\n  }\n  if (max_weight <= w) return false;\n  if (sum_q < max_weight) return\
    \ true;\n  return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpqma77im8: /tmp/tmpqma77im8.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134656
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in here\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp31gbn_vo: /tmp/tmp31gbn_vo.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134656
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int sum = 0;\n    for (auto\
    \ i : q) sum += i;\n    if (sum < w && q.palindrome() && q.reduce((x, y) => (x\
    \ + y) <= w)) {\n        return true;\n    }\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz4ekoebx.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpz4ekoebx.cpp:21:22: error: \u2018class std::vector<long\
    \ int>\u2019 has no member named \u2018palindrome\u2019\n   21 |     if (sum <\
    \ w && q.palindrome() && q.reduce((x, y) => (x + y) <= w)) {\n      |        \
    \              ^~~~~~~~~~\n/tmp/tmpz4ekoebx.cpp:21:40: error: \u2018class std::vector<long\
    \ int>\u2019 has no member named \u2018reduce\u2019\n   21 |     if (sum < w &&\
    \ q.palindrome() && q.reduce((x, y) => (x + y) <= w)) {\n      |             \
    \                           ^~~~~~\n/tmp/tmpz4ekoebx.cpp:21:48: error: \u2018\
    x\u2019 was not declared in this scope\n   21 |     if (sum < w && q.palindrome()\
    \ && q.reduce((x, y) => (x + y) <= w)) {\n      |                            \
    \                    ^\n/tmp/tmpz4ekoebx.cpp:21:51: error: \u2018y\u2019 was not\
    \ declared in this scope\n   21 |     if (sum < w && q.palindrome() && q.reduce((x,\
    \ y) => (x + y) <= w)) {\n      |                                            \
    \       ^\n/tmp/tmpz4ekoebx.cpp:21:55: error: expected primary-expression before\
    \ \u2018>\u2019 token\n   21 |     if (sum < w && q.palindrome() && q.reduce((x,\
    \ y) => (x + y) <= w)) {\n      |                                            \
    \           ^\n"
  stdout: ''
  timestamp: 1660134655
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  if (q.size() == 0 || w == 0)\
    \ {\n    return false;\n  }\n  auto res = q[0] == q[q.size() - 1];\n  for (size_t\
    \ i = 1; i < q.size(); i++) {\n    res &= q[i] == q[q.size() - 1 - i];\n  }\n\
    \  return res && q.back() <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660134656
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (int\
    \ i = 0; i < q.size(); i++) {\n        sum += q.at(i);\n    }\n    if (sum >=\
    \ w) {\n        return true;\n    }\n    return false;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpiy56u7ul: /tmp/tmpiy56u7ul.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134656
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  for (long i = 0; i<q.size(); i++) {\n        max_weight = max(max_weight, q[i]);\n\
    \    }\n    if (max_weight < 0) {\n        return false;\n    }\n    for (long\
    \ i = 0; i<q.size(); i++) {\n        q[i] /= max_weight;\n        if (q[i] !=\
    \ 0) {\n            return false;\n        }\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp53tiihrq.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp53tiihrq.cpp:21:22: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   21 |    \
    \     max_weight = max(max_weight, q[i]);\n      |                      ^~~\n\
    \      |                      std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp53tiihrq.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134655
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  int n = q.size();\n  assert(n\
    \ != 0 && w != 0 && n == (w+1));\n  if (n <= 1) return true;\n  long max_weight\
    \ = w;\n  std::vector<long> reversed = q;\n  std::reverse(reversed.begin(), reversed.end());\n\
    \  int sum = 0;\n  for (int i = 0; i < n; i++) {\n    if (q[i] <= max_weight)\
    \ sum += q[i];\n    else return false;\n  }\n  if (sum < max_weight) return false;\n\
    \  return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp6e6_odwu: /tmp/tmp6e6_odwu.cpp:20: bool will_it_fly(std::vector<long
    int>, long int): Assertion `n != 0 && w != 0 && n == (w+1)'' failed.

    '
  stdout: ''
  timestamp: 1660134656
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    if\
    \ (n == 0)\n        return true;\n    if (n == 1)\n        return q[0] == w;\n\
    \    if (n % 2 != 0)\n        return false;\n    int max;\n    if (n > w)\n  \
    \      max = w;\n    else\n        max = n - w;\n    int sum = 0;\n    for (int\
    \ i = 0; i < max; i++)\n        sum += q[i];\n    if (sum == 0 || sum > max)\n\
    \        return false;\n    int half = max;\n    while (half < n)\n        half\
    \ *= 2;\n    int last = n - half;\n    for (int i = 0; i < last; i++)\n      \
    \  if (q[i] != half + w - i)\n            return false;\n    return true;\n}\n\
    int main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpbz91ozbq: /tmp/tmpbz91ozbq.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  int ans = 0, maxans = 0, anw\
    \ = 0;\n  for (long i = 0; i < q.size(); i++)\n    ans = max(ans, q[i]);\n  for\
    \ (long i = 0; i < q.size() - 1; i++)\n    anw = max(anw, q[i] + q[i + 1]);\n\
    \  return ans >= w && anw == maxans && maxans + ans <= w;\n}\nint main() {\n \
    \   auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph6rnfnjx.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmph6rnfnjx.cpp:21:11: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   21 |    \
    \ ans = max(ans, q[i]);\n      |           ^~~\n      |           std::max\nIn\
    \ file included from /usr/include/c++/9/algorithm:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph6rnfnjx.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n/tmp/tmph6rnfnjx.cpp:23:11: error: \u2018\
    max\u2019 was not declared in this scope; did you mean \u2018std::max\u2019?\n\
    \   23 |     anw = max(anw, q[i] + q[i + 1]);\n      |           ^~~\n      |\
    \           std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph6rnfnjx.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134655
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() != 0)\n    {\n\
    \        long sum = 0;\n        std::for_each(q.begin(), q.end(), [&sum, &w](long\
    \ v){sum += v;});\n        if (sum >= w)\n        {\n            return true;\n\
    \        }\n    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpyhz_oo8i: /tmp/tmpyhz_oo8i.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134656
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your function here\n\
    \    auto is_balanced = [](std::vector<long> q) {\n        int max_size = q.size();\n\
    \        for (int i = 0; i < max_size; ++i) {\n            if (q[i] != (max_size\
    \ - i)) {\n                return false;\n            }\n        }\n        return\
    \ true;\n    };\n    auto sum_of_elements = [](std::vector<long> q) {\n      \
    \  int sum = 0;\n        for (int i = 0; i < q.size(); ++i) {\n            sum\
    \ += q[i];\n        }\n        return sum;\n    };\n    if (is_balanced(q) &&\
    \ sum_of_elements(q) <= w) {\n        return true;\n    } else {\n        return\
    \ false;\n    }\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpazwkx75c: /tmp/tmpazwkx75c.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // TODO: Your code here\n\
    \    if(q.size() == 1 && q.back() == w) return true;\n    std::vector<long> temp;\n\
    \    bool fly = false;\n    long maxw = 0;\n    for (long i = 0; i<q.size(); i++){\n\
    \        if(q.at(i) < (w-maxw)){\n            fly = true;\n            break;\n\
    \        }else{\n            fly = false;\n        }\n        temp = q;\n    \
    \    q.at(i) = w-maxw;\n        if(fly){\n            if(temp == q){\n       \
    \         return true;\n            }\n        }\n        maxw += q.at(i);\n \
    \   }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpbg4kiwfl: /tmp/tmpbg4kiwfl.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  int n = q.size();\n  int max_sum\
    \ = w;\n  for (int i = 1; i <= n; i++) {\n    max_sum = max(max_sum, q[i] - q[i-1]);\n\
    \  }\n  if (max_sum >= w) {\n    return true;\n  }\n  return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi9xsg0_7.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpi9xsg0_7.cpp:22:15: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   22 |    \
    \ max_sum = max(max_sum, q[i] - q[i-1]);\n      |               ^~~\n      | \
    \              std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpi9xsg0_7.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134656
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  bool is_balanced = true; //\
    \ If this is balanced, then q will fly.\n  long max_sum_of_elements = std::accumulate(q.begin(),\
    \ q.end(), (long)0);\n\n  // If q is unbalanced, then it must not fly.\n  // q\
    \ is balanced if the sum of its elements is less than or equal to max_sum_of_elements.\n\
    \  // q is unbalanced if max_sum_of_elements is greater than the sum of its elements.\n\
    \  if (max_sum_of_elements > std::accumulate(q.begin(), q.end(), (long)0))\n \
    \   is_balanced = false;\n\n  // If the sum of its elements equals max_sum_of_elements,\
    \ then q is balanced.\n  if (std::accumulate(q.begin(), q.end(), (long)0) == max_sum_of_elements)\n\
    \    is_balanced = true;\n\n  // If the sum of its elements does not equal max_sum_of_elements,\
    \ then q is unbalanced.\n  if (std::accumulate(q.begin(), q.end(), (long)0) >\
    \ max_sum_of_elements)\n    is_balanced = false;\n\n  return is_balanced && q.size()\
    \ <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpv8w9xdyv: /tmp/tmpv8w9xdyv.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    assert(q.size() > 0);\n \
    \   assert(w > 0);\n    long max_sum = 0;\n    for (long i = 0; i < (long)q.size();\
    \ i++) {\n        long sum = q[i] + max_sum;\n        if (sum > w) {\n       \
    \     return false;\n        }\n        max_sum = sum;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpl9buk9hc: /tmp/tmpl9buk9hc.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() <= 1)\n    \
    \    return false;\n    long sum = 0;\n    for (long &x : q) {\n        sum +=\
    \ x;\n    }\n    bool balanced = sum <= w;\n    if (balanced)\n        return\
    \ true;\n    // We know that the sum is not balanced, so now we check if it is\
    \ a palindrome (that is, if the sum of its elements is the same as the sum of\
    \ its elements reversed).\n    long reversed_sum = 0;\n    for (long &x : q) {\n\
    \        reversed_sum *= 10;\n        reversed_sum += x;\n    }\n    if (reversed_sum\
    \ == sum)\n        return true;\n    return false;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp2pxv39tn: /tmp/tmp2pxv39tn.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  std::vector<long> temp;\n \
    \ long max_weight = 0;\n  long sum = 0;\n  // Write your code here\n  for (int\
    \ i = 0; i < q.size(); i++) {\n    sum += q.at(i);\n  }\n  max_weight = sum +\
    \ w;\n  if (max_weight % 2 == 0) return false;\n  temp = q;\n  for (int i = 1;\
    \ i < max_weight; i++) {\n    if (temp.at(i - 1) == temp.at(i)) {\n      temp.pop_back();\n\
    \    } else {\n      return false;\n    }\n  }\n  return true;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp8tgt8f6p: /tmp/tmp8tgt8f6p.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if((q).size()==0)\n     \
    \   return true;\n    if(q[0]==(q[q.size()-1]))\n    {\n        long max=w;\n\
    \        for(long i=0;i<q.size()-1;++i)\n        {\n            if(i==q.size()-2)\n\
    \                max=std::max(max,w-q[i]-q[i+1]);\n            else\n        \
    \        max=std::max(max,w-q[i]-q[i+1]-q[i+2]);\n        }\n        return max<=w;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpk3yblq4y: /tmp/tmpk3yblq4y.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (1)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    int\
    \ sum = 0;\n    int m = INT_MAX;\n    int max_sum = INT_MIN;\n    for (int i =\
    \ 0; i < n; ++i) {\n        int x = q[i];\n        sum += x;\n        if (sum\
    \ > m) {\n            m = sum;\n        }\n        max_sum = std::max(max_sum,\
    \ sum);\n    }\n    return (sum == w && sum < w && max_sum <= w);\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmphrodd_n7: /tmp/tmphrodd_n7.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here.\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpruo2zqmt: /tmp/tmpruo2zqmt.cpp:23: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // TODO: Write your function\
    \ here.\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpxon8y8vg: /tmp/tmpxon8y8vg.cpp:25: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n\tif (q.empty() || w == 0 ||\
    \ q.size() == 1) {\n\t\treturn true;\n\t}\n\tlong min = *std::min_element(q.begin(),\
    \ q.end());\n\tlong sum = std::accumulate(q.begin(), q.end(), 0);\n\treturn sum\
    \ == w && sum < w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp_7p37179: /tmp/tmp_7p37179.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your logic here\n\
    \    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpu7hqtyvk: /tmp/tmpu7hqtyvk.cpp:24: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    if\
    \ (n <= 0) return false;\n    int s = 0;\n    for (int i = 0; i < n; i++) {\n\
    \        s = s + q[i];\n        if (s > w) return false;\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqb7cb5xv: /tmp/tmpqb7cb5xv.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if(q.size() == 0) return\
    \ false;\n    long maxSum = q.back();\n    for(size_t i=0; i<q.size()-1; ++i)\
    \ {\n        maxSum = maxSum + q[i];\n        if(maxSum >= w) return true;\n \
    \   }\n    return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpm735r8xl: /tmp/tmpm735r8xl.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int sum = 0;\n    \n    for\
    \ (int i = 0; i < q.size(); i++) {\n        sum += q[i];\n    }\n    \n    if\
    \ (sum >= w) return false;\n    \n    int max_index = 0;\n    for (int i = 0;\
    \ i < q.size(); i++) {\n        if (sum >= w) {\n            return true;\n  \
    \      } else {\n            sum -= w;\n        }\n    }\n    \n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpy608doxs: /tmp/tmpy608doxs.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n        long maxSum = 0;\n  \
    \      long sum = 0;\n        // Get the maximum sum and sum of all the vector's\
    \ elements\n        for (long i = 0; i < q.size(); ++i) {\n                maxSum\
    \ += q[i];\n                sum += q[i];\n        }\n        // If the sum is\
    \ less than or equal the maximum possible weight w\n        if (sum == w || sum\
    \ > w)\n                return false;\n        // If it isn't balanced\n     \
    \   for (long i = 0; i < q.size(); ++i) {\n                sum -= q[i];\n    \
    \            if (sum < 0) {\n                        // If it is less than or\
    \ equal the maximum possible weight w\n                        return false;\n\
    \                }\n        }\n        // It is balanced so it's true\n      \
    \  return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpgdv87pyb: /tmp/tmpgdv87pyb.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code goes here\n\
    \    long sum = 0, max_sum = 0;\n    for(long i = 0; i < q.size(); i++) {\n  \
    \      max_sum += q[i];\n    }\n    for (long i = 0; i < q.size(); i++) {\n  \
    \      if(q[i] > w) \n            return false;\n        sum += q[i];\n    }\n\
    \    if (sum >= max_sum)\n        return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpwe37ieay: /tmp/tmpwe37ieay.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n\tlong max_sum = w;\n\tbool balanced\
    \ = true;\n\tlong sum = 0;\n\tfor (long i : q) {\n\t\tsum += i;\n\t\tif (sum >\
    \ max_sum) {\n\t\t\tbalanced = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn balanced\
    \ && sum <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpds1qez69: /tmp/tmpds1qez69.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    std::reverse(q.begin(), q.end());\n\
    \    if(q[0] < w) return false;\n    long max_sum = w;\n    long sum = 0;\n  \
    \  for(auto e : q) {\n        sum += e;\n        if(sum > max_sum) {\n       \
    \     max_sum = sum;\n        }\n    }\n    return max_sum == w;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp_tjq6fp7: /tmp/tmp_tjq6fp7.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.empty() || w == 0)\n\
    \        return false;\n    // Write your code here.\n    long maxsum = w;\n \
    \   for (auto i : q) {\n        if (i > maxsum)\n            maxsum = i;\n   \
    \ }\n    for (auto i : q) {\n        if (i > maxsum || i < 0)\n            return\
    \ false;\n    }\n    return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpw0akzxg1: /tmp/tmpw0akzxg1.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  assert(q.size() == 0 || q.size()\
    \ == 5);\n  assert(q[0] == 0);\n  assert(q[4] == 1);\n  // assert(q[5] == 1);\n\
    \  // assert(q[3] == 3);\n  // assert(q[2] == 2);\n  // assert(q[1] == 1);\n \
    \ // assert(q[0] == 0);\n  // assert(q[3] == 3);\n  // assert(q[2] == 2);\n  //\
    \ assert(q[1] == 1);\n  // assert(q[0] == 0);\n  // assert(q[3] == 3);\n  // assert(q[2]\
    \ == 2);\n  // assert(q[1] == 1);\n  // assert(q[0] == 0);\n  // assert(q[3] ==\
    \ 3);\n  // assert(q[2] == 2);\n  // assert(q[1] == 1);\n  // assert(q[0] == 0);\n\
    \  // assert(q[3] == 3);\n  // assert(q[2] == 2);\n  // assert(q[1] == 1);\n \
    \ // assert(q[0] == 0);\n  // assert(q[3] == 3);\n  // assert(q[2] == 2);\n  //\
    \ assert(q[1] == 1);\n  // assert(q[0] == 0);\n  // assert(q[3] == 3);\n  // assert(q[2]\
    \ == 2);\n  // assert(q[1] == 1);\n  // assert(q[0] == 0);\n  // assert(q[3] ==\
    \ 3);\n  // assert(q[2] == 2);\n  // assert(q[1] == 1);\n  // assert(q[0] == 0);\n\
    \  // assert(q[3] == 3);\n  // assert(q[2] == 2);\n  // assert(q[1] == 1);\n \
    \ // assert(q[0] == 0);\n  // assert(q[3] == 3);\n  // assert(q[2] == 2);\n  //\
    \ assert(q[1] == 1);\n  // assert(q[0] == 0);\n  // assert(q[3] == 3);\n  // assert(q[2]\
    \ == 2);\n  // assert(q[1] == 1);\n  // assert(q[0] == 0);\n  // assert(q[3] ==\
    \ 3);\n  // assert(q[2] == 2);\n  // assert(q[1] == 1);\n  // assert(q[0] == 0);\n\
    \  // assert(q[3] == 3);\n  // assert(q[2] == 2);\n  // assert(q[1] == 1);\n \
    \ // assert(q[0] == 0);\n  // assert(q[3] == 3);\n  // assert(q[2] == 2);\n  //\
    \ assert(q[1] == 1);\n  // assert(q[0] == 0);\n  // assert(q[3] == 3);\n  // assert(q[2]\
    \ == 2);\n  // assert(q[1] == 1);\n  // assert(q[0] == 0);\n  // assert(q[3] ==\
    \ 3);\n  // assert(q[2] == 2);\n  // assert(q[1] == 1);\n  // assert(q[0] == 0);\n\
    \  // assert(q[3] == 3);\n  // assert(q[2] == 2);\n  // assert(q[1] == 1);\n \
    \ // assert(q[0] == 0);\n  // assert(q[3] == 3);\n  // assert(q[2] == 2);\n  //\
    \ assert(q[1] == 1);\n  // assert(q[0] == 0);\n  // assert(q[3] == 3);\n  // assert(q[2]\
    \ == 2);\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpqp2aekph: /tmp/tmpqp2aekph.cpp:19: bool will_it_fly(std::vector<long
    int>, long int): Assertion `q.size() == 0 || q.size() == 5'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int sum = 0;\n    for (long\
    \ i : q)\n        sum += i;\n    if (sum < 0 || w <= 0 || sum > w)\n        return\
    \ false;\n    int max_sum = sum - w;\n    for (long i : q)\n        sum += i;\n\
    \    return sum >= max_sum;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp7udjhyn_: /tmp/tmp7udjhyn_.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  int n = q.size();\n  long s\
    \ = 0;\n  for (int i = 0; i < n; i++) {\n    s += q[i];\n  }\n  return s <= w;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpeyw44_bq: /tmp/tmpeyw44_bq.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134657
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  int n = q.size();\n  if (n\
    \ == 0 || w == 0)\n    return true;\n  long max_weight = max(q);\n  if (w < 0)\n\
    \    return false;\n  for (int i = 1; i < n; i++) {\n    if (q[i] - q[i - 1] !=\
    \ max_weight - w)\n      return false;\n  }\n  return true;\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpueil1qr8.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpueil1qr8.cpp:22:26: error: no matching function\
    \ for call to \u2018max(std::vector<long int>&)\u2019\n   22 |   long max_weight\
    \ = max(q);\n      |                          ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpueil1qr8.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:222:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const\
    \ _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n \
    \     |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:222:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmpueil1qr8.cpp:22:26: note: \
    \  candidate expects 2 arguments, 1 provided\n   22 |   long max_weight = max(q);\n\
    \      |                          ^\nIn file included from /usr/include/c++/9/bits/specfun.h:45,\n\
    \                 from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpueil1qr8.cpp:2:\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp&\
    \ std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp&\
    \ __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/usr/include/c++/9/bits/stl_algobase.h:268:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpueil1qr8.cpp:22:26:\
    \ note:   candidate expects 3 arguments, 1 provided\n   22 |   long max_weight\
    \ = max(q);\n      |                          ^\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpueil1qr8.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3462:5:\
    \ note: candidate: \u2018template<class _Tp> constexpr _Tp std::max(std::initializer_list<_Tp>)\u2019\
    \n 3462 |     max(initializer_list<_Tp> _"
  stdout: ''
  timestamp: 1660134657
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int max = (int)q.size() -\
    \ 1;\n    int wsum = std::accumulate(q.begin(), q.end(), 0);\n    if (wsum > w)\
    \ {\n        return false;\n    }\n    int sum = 0;\n    bool flag = true;\n \
    \   for (int i = 0; i <= max; i++) {\n        sum += q[i];\n        if (sum ==\
    \ w) {\n            flag = true;\n        } else {\n            flag = false;\n\
    \        }\n    }\n    return flag;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpa4gxth0m: /tmp/tmpa4gxth0m.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (const\
    \ auto i : q)\n        sum += i;\n    return sum < w && is_palindrome(q) && will_it_fly(get_reverse(q),\
    \ w);\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpihk06c_b.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpihk06c_b.cpp:22:23: error: \u2018is_palindrome\u2019\
    \ was not declared in this scope\n   22 |     return sum < w && is_palindrome(q)\
    \ && will_it_fly(get_reverse(q), w);\n      |                       ^~~~~~~~~~~~~\n\
    /tmp/tmpihk06c_b.cpp:22:55: error: \u2018get_reverse\u2019 was not declared in\
    \ this scope\n   22 |     return sum < w && is_palindrome(q) && will_it_fly(get_reverse(q),\
    \ w);\n      |                                                       ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your solution here\n\
    \    std::stack<long> s;\n    long max = 0;\n    int index = 0;\n    while(index<q.size())\
    \ {\n        if(s.empty()) {\n            s.push((q.at(index))*w);\n         \
    \   max = (q.at(index)*w)>max?(q.at(index)*w):max;\n            index = index+1;\n\
    \        }\n        if(s.top()>q.at(index)) {\n            s.push((q.at(index))*w);\n\
    \            max = (q.at(index)*w)>max?(q.at(index)*w):max;\n            index\
    \ = index+1;\n        } else {\n            s.pop();\n            max = (q.at(index)*w)>max?(q.at(index)*w):max;\n\
    \            index = index+1;\n        }\n    }\n    return (!s.empty()&&(q.size()-index)<=(max/w)&&(max/w)>=0);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp7rl_a8o_: /tmp/tmp7rl_a8o_.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code\n    long\
    \ max_weight = *std::max_element(q.begin(), q.end());\n    long sum = 0;\n   \
    \ long total_weight = 0;\n    for (auto i = q.begin(); i != q.end(); i++) {\n\
    \        sum += *i;\n        total_weight += *i;\n    }\n    return max_weight\
    \ < w && sum == w && total_weight <= w;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp6xbwatce: /tmp/tmp6xbwatce.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long sum = 0;\n    for (auto&\
    \ element : q) {\n        sum += element;\n    }\n    sum += w;\n    sum = sum\
    \ % 1000000;\n    return sum < 1000000;\n}\nint main() {\n    auto candidate =\
    \ will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpoqjarz7p: /tmp/tmpoqjarz7p.cpp:30: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_weight = w;\n  \
    \  long sum = 0;\n    for (auto i : q) {\n        sum += i;\n        if (sum >=\
    \ max_weight) {\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmprneo6coy: /tmp/tmprneo6coy.cpp:32: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    assert(q.size() >= 2);\n\
    \    auto s = q.back();\n    q.pop_back();\n    int sum = 0;\n    for (const auto\
    \ &el : q) {\n        sum += el;\n    }\n    return sum <= w && is_palindromic(q);\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzbbj_j6d.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpzbbj_j6d.cpp:26:24: error: \u2018is_palindromic\u2019\
    \ was not declared in this scope\n   26 |     return sum <= w && is_palindromic(q);\n\
    \      |                        ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    assert(n\
    \ > 0);\n    assert(w > 0);\n    long max_weight = w;\n    for (int i = 0; i <\
    \ n; i++) {\n        if (max_weight - q[i] >= 0) {\n            max_weight = max_weight\
    \ - q[i];\n        } else {\n            max_weight += q[i];\n            break;\n\
    \        }\n    }\n    if (max_weight == w)\n        return true;\n    else\n\
    \        return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n \
    \   assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpzri_c1yt: /tmp/tmpzri_c1yt.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  long max_weight = 0, total_weight\
    \ = 0;\n  for (auto el : q) {\n    total_weight += el;\n    max_weight = std::max(max_weight,\
    \ el);\n  }\n  return (max_weight <= w && total_weight >= w);\n}\nint main() {\n\
    \    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp5qepvpvj: /tmp/tmp5qepvpvj.cpp:28: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    if\
    \ (n == 0)\n        return true;\n    long max_sum = 0;\n    bool first = true;\n\
    \    // max_sum = std::accumulate(q.begin(), q.end(), 0);\n    for (long i = 0;\
    \ i < n; i++) {\n        long curr = q[i];\n        long sum = 0;\n        if\
    \ (first)\n            sum = curr * w;\n        else\n            sum += curr\
    \ * w;\n        if (sum > max_sum)\n            max_sum = sum;\n        first\
    \ = false;\n    }\n    return (max_sum <= w);\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpbxy_2cwp: /tmp/tmpbxy_2cwp.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // Your code here\n    if\
    \ (q.size() == 0 || w == 0 || w > q.back())\n        return false;\n    int sum\
    \ = 0;\n    for (int i = 0; i < q.size(); i++) {\n        sum += q[i];\n     \
    \   if (sum > w) {\n            sum -= w;\n            if (sum < 0)\n        \
    \        sum = 0;\n            return false;\n        }\n    }\n    return true;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpum04q475: /tmp/tmpum04q475.cpp:36: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    return q == palindromic_vector(q)\
    \ && q.size() <= w && std::accumulate(q.begin(), q.end(), 0) <= w;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq_pt7kvx.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpq_pt7kvx.cpp:19:17: error: \u2018palindromic_vector\u2019\
    \ was not declared in this scope\n   19 |     return q == palindromic_vector(q)\
    \ && q.size() <= w && std::accumulate(q.begin(), q.end(), 0) <= w;\n      |  \
    \               ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your code in here\n\
    \    for(long i = 0;i < q.size(); ++i) {\n        if(q[i] != 0)\n            return\
    \ false;\n    }\n    long maxw = max(q.begin(), q.end()) - q.begin();\n    long\
    \ sum = 0;\n    for(auto val : q)\n        sum += val;\n    if(maxw == sum &&\
    \ sum == w)\n        return true;\n    return false;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpbsdge_m7: /tmp/tmpbsdge_m7.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if(q.size() % 2 == 0) {\n\
    \        std::reverse(q.begin(), q.end());\n    }\n    long min_w = 0;\n    long\
    \ max_w = 0;\n    for(size_t i = 0; i != q.size(); i+=2) {\n        if(q[i] <\
    \ max_w) max_w = q[i];\n        if(q[i] > min_w) min_w = q[i];\n    }\n    return\
    \ max_w >= w && min_w <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    std::sort(q.begin(), q.end());\n\
    \    if(q.size() == 0)\n        return false;\n    long n = q.size();\n    if(n\
    \ == 1)\n        return true;\n    long max_n = n-1;\n    long max_w = 0;\n  \
    \  long max_w2 = 0;\n    for(long i = 2; i < max_n; i++)\n    {\n        long\
    \ w2 = max_w * 2;\n        if(n-i >= w)\n        {\n            if(n-i >= w2)\n\
    \                max_w2 = max_w2;\n            else\n                max_w2 =\
    \ w2;\n        }\n        else\n        {\n            if(n-i >= w2)\n       \
    \     {\n                max_w2 = max_w2;\n                max_w = max_w2;\n \
    \           }\n            else\n                max_w2 = w2;\n        }\n   \
    \ }\n    if(max_w2 < max_w)\n        return true;\n    return false;\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmptgh2wm_c: /tmp/tmptgh2wm_c.cpp:55: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    long\
    \ maxWeight = w;\n    long sum = 0;\n    std::vector<long>::iterator it;\n   \
    \ long temp;\n    for (it = q.begin(); it != q.end(); it++) {\n        temp =\
    \ *it;\n        if (temp > maxWeight) {\n            maxWeight = temp;\n     \
    \   }\n        sum += temp;\n    }\n    if (sum >= maxWeight) {\n        return\
    \ true; //balanced\n    }\n    else {\n        return false; // not balanced\n\
    \    }\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpupt4hj10: /tmp/tmpupt4hj10.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() == 0 || w <=\
    \ 0 || q.back() != w)\n        return false;\n    long n = q.size();\n    long\
    \ max = 0;\n    long sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum\
    \ += q.at(i);\n        if (sum >= w)\n            max++;\n    }\n    return (sum\
    \ == w && max == n);\n}\nint main() {\n    auto candidate = will_it_fly;\n   \
    \ assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)1, (long)2})), (5)) == (false));\n\
    \    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpwdyfuq7a: /tmp/tmpwdyfuq7a.cpp:33: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n        long s = sum(q);\n  \
    \      if(s >= w) return false;\n        auto reverse = q.rbegin();\n        for(;\
    \ reverse != q.rend(); ++reverse) if(*reverse < *q) return false;\n        return\
    \ true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptm8c66ey.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmptm8c66ey.cpp:19:18: error: \u2018sum\u2019 was\
    \ not declared in this scope\n   19 |         long s = sum(q);\n      |      \
    \            ^~~\n/tmp/tmptm8c66ey.cpp:22:61: error: no match for \u2018operator*\u2019\
    \ (operand type is \u2018std::vector<long int>\u2019)\n   22 |         for(; reverse\
    \ != q.rend(); ++reverse) if(*reverse < *q) return false;\n      |           \
    \                                                  ^~\nIn file included from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmptm8c66ey.cpp:2:\n/usr/include/c++/9/complex:391:5:\
    \ note: candidate: \u2018template<class _Tp> std::complex<_Tp> std::operator*(const\
    \ std::complex<_Tp>&, const std::complex<_Tp>&)\u2019\n  391 |     operator*(const\
    \ complex<_Tp>& __x, const complex<_Tp>& __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:391:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmptm8c66ey.cpp:22:62:\
    \ note:   \u2018std::vector<long int>\u2019 is not derived from \u2018const std::complex<_Tp>\u2019\
    \n   22 |         for(; reverse != q.rend(); ++reverse) if(*reverse < *q) return\
    \ false;\n      |                                                            \
    \  ^\nIn file included from /usr/include/c++/9/ccomplex:39,\n                \
    \ from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n               \
    \  from /tmp/tmptm8c66ey.cpp:2:\n/usr/include/c++/9/complex:400:5: note: candidate:\
    \ \u2018template<class _Tp> std::complex<_Tp> std::operator*(const std::complex<_Tp>&,\
    \ const _Tp&)\u2019\n  400 |     operator*(const complex<_Tp>& __x, const _Tp&\
    \ __y)\n      |     ^~~~~~~~\n/usr/include/c++/9/complex:400:5: note:   template\
    \ argument deduction/substitution failed:\n/tmp/tmptm8c66ey.cpp:22:62: note: \
    \  \u2018std::vector<long int>\u2019 is not derived from \u2018const std::complex<_Tp>\u2019\
    \n   22 |         for(; reverse != q.rend(); ++reverse) if(*reverse < *q) return\
    \ false;\n      |                                                     "
  stdout: ''
  timestamp: 1660134658
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = 0;\n    for\
    \ (auto e: q)\n        max_sum += e;\n    if (max_sum <= w)\n        return true;\n\
    \    for (auto i = 0; i < q.size(); i++) {\n        auto s = max_sum - q[i];\n\
    \        if (s > 0)\n            return false;\n    }\n    return true;\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpnir93wyy: /tmp/tmpnir93wyy.cpp:34: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    std::reverse(q.begin(), q.end());\n\
    \    if (q.size() <= 2) return true;\n    if (q[0]+q[1] < w) return true;\n  \
    \  return false;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpwksi7af3: /tmp/tmpwksi7af3.cpp:27: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() == 1) {\n  \
    \      return q[0] == w;\n    }\n\n    std::vector<long> reversed = q;\n    reversed.push_back(q.front());\n\
    \    reversed.erase(reversed.begin(), reversed.end());\n\n    long sum = 0;\n\
    \    for (long e : reversed) {\n        sum += e;\n    }\n\n    if (sum >= w)\
    \ {\n        return true;\n    } else {\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp6gwjoe6b: /tmp/tmp6gwjoe6b.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() <= 0)\n    \
    \    return true;\n    std::reverse(q.begin(), q.end());\n    if (std::equal(q.begin(),\
    \ q.end(), q.begin()))\n        return true;\n    return static_cast<long long>(q.back())\
    \ + w <= static_cast<long long>(std::numeric_limits<long>::max());\n}\nint main()\
    \ {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpdtqnxtiz: /tmp/tmpdtqnxtiz.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2})), (5)) == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long ans = 0;\n    long m\
    \ = q.size();\n    if (m == 1)\n        return q[0] == w;\n    if (m == 0)\n \
    \       return 0;\n    for (long i = m - 1; i > 0; --i) {\n        long l = q[i];\n\
    \        ans += l;\n        if (ans > w)\n            return 0;\n    }\n    return\
    \ q[0] == w && ans <= w;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmp7_j7h58o: /tmp/tmp7_j7h58o.cpp:35: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  int n=q.size();\n  if(w<=0\
    \ || n<=0)\n    return false;\n  assert(q.size()%2==0 && \"input vector must have\
    \ even length\");\n  std::vector<long> v(q.begin(), q.end()-1);\n  std::vector<long>\
    \ v2(q.end()-1, q.end()); // v2 reverses v\n  std::reverse(&v[0], &v[n]);\n  std::reverse(&v2[0],\
    \ &v2[n]);\n  return (n==0 || std::accumulate(v.begin(), v.end(), 0)<=w) && (n==0\
    \ || std::accumulate(v2.begin(), v2.end(), 0)<=w);\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp4cuu6guo: /tmp/tmp4cuu6guo.cpp:22: bool will_it_fly(std::vector<long
    int>, long int): Assertion `q.size()%2==0 && "input vector must have even length"''
    failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    long max_sum = max_element_sum(q);\n\
    \    bool ret = max_sum <= w;\n    return ret;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmy4m4uaz.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpmy4m4uaz.cpp:19:20: error: \u2018max_element_sum\u2019\
    \ was not declared in this scope\n   19 |     long max_sum = max_element_sum(q);\n\
    \      |                    ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    //Your code here\n    \n\
    \    std::stack<long> v;\n    v.push(q[0]);\n    for(int i=1; i<q.size(); i++)\
    \ {\n        if(v.top() != q[i]) {\n            return false;\n        }\n   \
    \     v.push(q[i]);\n    }\n    while(v.size() > 1) {\n        v.push(v.top());\n\
    \        v.pop();\n    }\n    return v.top() == w;\n}\nint main() {\n    auto\
    \ candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp7w44ngmn: /tmp/tmp7w44ngmn.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    std::stack<long> st;\n  \
    \  for (long i : q) {\n        st.push(i);\n    }\n    while (!st.empty()) {\n\
    \        long v = st.top();\n        if (v == w) {\n            // If we've seen\
    \ it more than once in stack, it's unbalanced\n            if (st.size() > 2)\
    \ {\n                return false;\n            }\n            st.pop();\n   \
    \     } else {\n            long w = v;\n            long n = q[st.top()];\n \
    \           if (v + n > w) {\n                st.pop();\n                st.pop();\n\
    \            } else if (v + n <= w) {\n                st.pop();\n           \
    \ } else {\n                return false;\n            }\n        }\n    }\n \
    \   return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660134660
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (q.size() == 0) return\
    \ false;\n    \n    long max_sum = 0;\n    for (auto &v: q) {\n        max_sum\
    \ += v;\n    }\n    \n    if (max_sum <= w) return false;\n    \n    long sum\
    \ = 0;\n    for (auto &v: q) {\n        sum += v;\n    }\n    \n    return sum\
    \ == max_sum;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpl8r8wo4o: /tmp/tmpl8r8wo4o.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  assert(w > 0 && q.size() >\
    \ 0);\n  long largest = *std::max_element(q.begin(), q.end());\n  // return false;\n\
    \  long sum = 0;\n  for (auto i : q) {\n    sum += i;\n    if (sum > largest)\
    \ return false;\n  }\n  return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (9)) ==\
    \ (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})), (5))\
    \ == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5)) == (true));\n\
    \    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})), (1)) ==\
    \ (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})),\
    \ (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})), (5))\
    \ == (true));\n}\n"
  status: Exception
  stderr: 'tmpc8idq2df: /tmp/tmpc8idq2df.cpp:31: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134660
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n  if(q.size() == 0) {\n    return\
    \ false;\n  }\n  assert(q.size() <= 5);\n  std::reverse(q.begin(), q.end());\n\
    \  if(q.front() <= 0) {\n    return false;\n  }\n  if(q.back() >= w) {\n    return\
    \ false;\n  }\n  long s = q.back();\n  q.pop_back();\n  long max_sum = w;\n  for(long\
    \ i = 0; i < q.size(); i++) {\n    max_sum += q.at(i);\n    if(max_sum > w) {\n\
    \      return false;\n    }\n  }\n  return true;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmpuabg16xf: /tmp/tmpuabg16xf.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134659
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    if (w.bit_length() <= 3)\
    \ return false;\n    int n = q.size();\n    int max_n = pow(2, w);\n    int min_n\
    \ = pow(2, w - 1);\n    std::vector<bool> ans(max_n + 1);\n    for (int i = 0;\
    \ i < n; i++) {\n        ans[q[i]] = true;\n    }\n    int sum = 0;\n    for (int\
    \ i = min_n; i <= max_n; i++) {\n        sum += i;\n        if (sum == max_n)\
    \ return true;\n        if (sum < min_n) return false;\n    }\n    return false;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn9is40so.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpn9is40so.cpp:19:11: error: request for member\
    \ \u2018bit_length\u2019 in \u2018w\u2019, which is of non-class type \u2018long\
    \ int\u2019\n   19 |     if (w.bit_length() <= 3) return false;\n      |     \
    \      ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660134659
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    int n = q.size();\n    int\
    \ max_sum = 0;\n    for (size_t i = 0; i < n; i++) {\n        max_sum = max(max_sum,\
    \ q[i] + w);\n    }\n    if (max_sum < w) {\n        return false;\n    }\n  \
    \  int max_index = 0;\n    int cur = 0;\n    for (int i = 1; i < n; i++) {\n \
    \       int left = q[i - 1];\n        int right = q[i];\n        int sum = (left\
    \ + right);\n        if (sum > w) {\n            break;\n        }\n        if\
    \ (sum == w) {\n            cur = i;\n            max_index = i;\n        }\n\
    \    }\n    int max_index_1 = n - 1;\n    int cur_1 = n - 1;\n    for (int i =\
    \ n - 2; i >= 0; i--) {\n        int left = q[i - 1];\n        int right = q[i];\n\
    \        int sum = (left + right);\n        if (sum > w) {\n            break;\n\
    \        }\n        if (sum == w) {\n            cur_1 = i;\n            max_index_1\
    \ = i;\n        }\n    }\n    if (max_index_1 < cur_1) {\n        return false;\n\
    \    }\n    if (max_index_1 > max_index) {\n        return false;\n    }\n   \
    \ return true;\n}\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0tv6c0o_.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmp0tv6c0o_.cpp:22:19: error: \u2018max\u2019 was\
    \ not declared in this scope; did you mean \u2018std::max\u2019?\n   22 |    \
    \     max_sum = max(max_sum, q[i] + w);\n      |                   ^~~\n     \
    \ |                   std::max\nIn file included from /usr/include/c++/9/algorithm:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0tv6c0o_.cpp:2:\n/usr/include/c++/9/bits/stl_algo.h:3468:5:\
    \ note: \u2018std::max\u2019 declared here\n 3468 |     max(initializer_list<_Tp>\
    \ __l, _Compare __comp)\n      |     ^~~\n"
  stdout: ''
  timestamp: 1660134659
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    // write your logic here\n\
    \    long maxSum = std::accumulate(q.begin(), q.end(), 0);\n    long sum = 0;\n\
    \    for(auto i : q){\n        sum += i;\n    }\n    return sum <= maxSum - w;\n\
    }\nint main() {\n    auto candidate = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)3})), (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2})), (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})),\
    \ (5)) == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: Exception
  stderr: 'tmp32dbhzqs: /tmp/tmp32dbhzqs.cpp:29: int main(): Assertion `candidate((std::vector<long>({(long)3,
    (long)2, (long)3})), (9)) == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660134660
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Write a function that\
    \ returns true if the object q will fly, and false otherwise.\n// The object q\
    \ will fly if it's balanced (it is a palindromic vector) and the sum of its elements\
    \ is less than or equal the maximum possible weight w.\n// Example:\n// >>> will_it_fly((std::vector<long>({(long)1,\
    \ (long)2})), (5))\n// (false)\n// # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (1))\n// (false)\n// # it's balanced, but 3+2+3 is more than the\
    \ maximum possible weight.\n// >>> will_it_fly((std::vector<long>({(long)3, (long)2,\
    \ (long)3})), (9))\n// (true)\n// # 3+2+3 is less than the maximum possible weight,\
    \ and it's balanced.\n// >>> will_it_fly((std::vector<long>({(long)3})), (5))\n\
    // (true)\n// # 3 is less than the maximum possible weight, and it's balanced.\n\
    bool will_it_fly(std::vector<long> q, long w) {\n    assert(q.size() == 0 || q.size()\
    \ == 1 || q.size() == 2);\n    long max_sum = w;\n    if (q.size() == 1) {\n \
    \       return q[0] == w;\n    }\n    long left = q[0], right = q[1];\n    while\
    \ (left > 0 && right > 0 && (left + right == w || max_sum < w)) {\n        if\
    \ (left > right) {\n            long mid = left + (right - left) / 2;\n      \
    \      if (will_it_fly(std::vector<long>(q, 0, mid), w)) {\n                return\
    \ true;\n            }\n            max_sum = mid;\n            left = mid;\n\
    \        } else {\n            long mid = left + (right - left) / 2;\n       \
    \     if (will_it_fly(std::vector<long>(q, 1, mid + 1), w)) {\n              \
    \  return true;\n            }\n            max_sum = w;\n            right =\
    \ mid;\n        }\n    }\n    return false;\n}\nint main() {\n    auto candidate\
    \ = will_it_fly;\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (9)) == (true));\n    assert(candidate((std::vector<long>({(long)1, (long)2})),\
    \ (5)) == (false));\n    assert(candidate((std::vector<long>({(long)3})), (5))\
    \ == (true));\n    assert(candidate((std::vector<long>({(long)3, (long)2, (long)3})),\
    \ (1)) == (false));\n    assert(candidate((std::vector<long>({(long)1, (long)2,\
    \ (long)3})), (6)) == (false));\n    assert(candidate((std::vector<long>({(long)5})),\
    \ (5)) == (true));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxfz8n9_l.cpp: In function \u2018bool will_it_fly(std::vector<long\
    \ int>, long int)\u2019:\n/tmp/tmpxfz8n9_l.cpp:28:56: error: no matching function\
    \ for call to \u2018std::vector<long int>::vector(std::vector<long int>&, int,\
    \ long int&)\u2019\n   28 |             if (will_it_fly(std::vector<long>(q, 0,\
    \ mid), w)) {\n      |                                                       \
    \ ^\nIn file included from /usr/include/c++/9/vector:67,\n                 from\
    \ /usr/include/c++/9/functional:62,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpxfz8n9_l.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:650:2: note: candidate:\
    \ \u2018template<class _InputIterator, class> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\u2019\n  650 |  vector(_InputIterator\
    \ __first, _InputIterator __last,\n      |  ^~~~~~\n/usr/include/c++/9/bits/stl_vector.h:650:2:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpxfz8n9_l.cpp:28:56:\
    \ note:   deduced conflicting types for parameter \u2018_InputIterator\u2019 (\u2018\
    std::vector<long int>\u2019 and \u2018int\u2019)\n   28 |             if (will_it_fly(std::vector<long>(q,\
    \ 0, mid), w)) {\n      |                                                    \
    \    ^\nIn file included from /usr/include/c++/9/vector:67,\n                \
    \ from /usr/include/c++/9/functional:62,\n                 from /usr/include/c++/9/pstl/glue_algorithm_defs.h:13,\n\
    \                 from /usr/include/c++/9/algorithm:71,\n                 from\
    \ /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:65,\n                 from\
    \ /tmp/tmpxfz8n9_l.cpp:2:\n/usr/include/c++/9/bits/stl_vector.h:622:7: note: candidate:\
    \ \u2018std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&)\
    \ [with _Tp = long int; _Alloc = std::allocator<long int>; std::vector<_Tp, _Alloc>::allocator_type\
    \ = std::allocator<long int>]\u2019\n  622 |       vector(initializer_l"
  stdout: ''
  timestamp: 1660134659
