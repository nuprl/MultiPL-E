name: HumanEval_90_next_smallest
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a vector of\
  \ integers.\n// Write a function next_smallest() that returns the 2nd smallest element\
  \ of the vector.\n// Return None if there is no such element.\n// >>> next_smallest((std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5})))\n// 2\n// >>> next_smallest((std::vector<long>({(long)5,\
  \ (long)1, (long)4, (long)3, (long)2})))\n// 2\n// >>> next_smallest((std::vector<long>()))\n\
  // std::nullopt\n// >>> next_smallest((std::vector<long>({(long)1, (long)1})))\n\
  // std::nullopt\nstd::optional<long> next_smallest(std::vector<long> lst) {\n"
tests: "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5,\
  \ (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>()))\
  \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1})))\
  \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
  \ (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35,\
  \ (long)34, (long)12, (long)-45}))) == -35);\n}\n"
completions: ["    int n = lst.size();\n    if(n <= 0)\n        return std::nullopt;\n\
    \    long x = lst.front();\n    long y = x;\n    long z = x;\n    for(int i =\
    \ 0; i < n; ++i) {\n        if((lst.at(i) > z)) {\n            y = z;\n      \
    \      z = lst.at(i);\n        }\n    }\n    return y;", "    auto it = lst.begin();\n\
    \    for (; it != lst.end(); it++)\n    {\n        if ((*it) == (*(it + 1))) {\n\
    \            return *it;\n        }\n    }\n    return std::nullopt;", "    for\
    \ (size_t i = 0; i < lst.size(); ++i) {\n        if (i == 0) {\n            continue;\n\
    \        }\n        else if (lst[i - 1] < lst[i]) {\n            return lst[i\
    \ - 1];\n        }\n    }\n    return std::nullopt;", "    if (lst.empty()) return\
    \ std::nullopt;\n\n    auto min_it = lst.begin();\n    long long min_value = *min_it;\n\
    \n    for (auto it = lst.begin() + 1; it != lst.end(); ++it) {\n        if (*it\
    \ < min_value) {\n            min_value = *it;\n            min_it = it;\n   \
    \     }\n    }\n\n    return *min_it;", "    int idx = lst.size();\n    while\
    \ (idx>0) {\n        --idx;\n        long min = midx(idx, lst);\n        if (min\
    \ > lst.at(midx(idx, lst))) return min;\n    }\n    return std::nullopt;", " \
    \   auto res = std::nullopt;\n    for(auto& v:lst){\n        if( res == std::nullopt){\n\
    \            v = std::min_element(vl.begin(), vl.end());\n            res = v;\n\
    \        }\n    }\n    return res;", "    // code here\n    return std::nullopt;",
  "    //using ll=long long;\n    ll t;\n    if(lst.empty())\n        return std::nullopt;\n\
    \    t = *lst.begin();\n    for(std::vector<long>::iterator itr = lst.begin()+1;\
    \ itr != lst.end(); ++itr) {\n        if(*itr < t)\n            t = *itr;\n  \
    \  }\n    return t;", "    if(lst.size() == 0)\n        return std::nullopt;\n\
    \    long min = 0;\n    long min2 = lst[0];\n    for(long i : lst)\n        if(i\
    \ < min) {\n            min = i;\n            min2 = lst[i - 1];\n        }\n\
    \    return min2;", "    // Your code goes here\n    std::vector<int> temp;\n\
    \    for(int i=0;i<lst.size();i++)\n        temp.push_back(lst.at(i));\n    sort(temp.begin(),temp.end());\n\
    \    if(temp.size() == 0)\n        return std::nullopt;\n    temp.pop_back();\n\
    \    return temp.at(0);", "  // Use a set to keep track of all the visited element\
    \ so far\n  std::set<long> visited;\n  for (long n : lst) {\n    if (visited.find(n)\
    \ != visited.end()) {\n      continue;\n    }\n    // If we found an new smallest\
    \ element, return it\n    if (visited.find(n) == visited.end()) {\n      return\
    \ {n};\n    }\n    // If visited already has the smallest element, return it\n\
    \    if (visited.find(n) < visited.end()) {\n      return {n};\n    }\n    //\
    \ Keep going\n  }\n  // No new smallest element found\n  return {std::nullopt};",
  "  std::optional<long> opt = std::nullopt;\n  for (const auto &val : lst) {\n  \
    \  if (std::find(lst.begin(), lst.end(), val) == lst.end())\n      opt = val;\n\
    \  }\n  return opt;", "    if (lst.empty()) return std::nullopt;\n    std::sort(lst.begin(),\
    \ lst.end());\n    return lst[lst.size() - 1];", "    if (lst.size() == 0) {\n\
    \        return std::nullopt;\n    }\n\n    long largest_element = *std::max_element(lst.begin(),\
    \ lst.end());\n    std::vector<long> sublist_with_smallest_element;\n    for (auto\
    \ it = lst.begin(); it != lst.end(); ++it) {\n        if (it > largest_element)\
    \ {\n            sublist_with_smallest_element.push_back(*it);\n        }\n  \
    \  }\n\n    if (sublist_with_smallest_element.size() == 0) {\n        return std::nullopt;\n\
    \    }\n\n    if (sublist_with_smallest_element.size() == 1) {\n        return\
    \ largest_element;\n    }\n\n    long second_smallest = *std::min_element(sublist_with_smallest_element.begin(),\
    \ sublist_with_smallest_element.end());\n    return second_smallest;", "    if(lst.size()\
    \ > 1){\n        auto it = lst.begin();\n        std::advance(it, lst.size()-2);\n\
    \        return *it;\n    }else{\n        return std::nullopt;\n    }", "    if\
    \ (lst.size() == 0)\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (*it == std::numeric_limits<long>::min())\n        return\
    \ std::nullopt;\n    return it->second;", "  std::optional<long> ret = lst.front();\n\
    \  auto it = lst.begin() + 1;\n  for (int i = 1; i < lst.size(); i++) {\n    if\
    \ (*it < *lst[i]) {\n      ret = lst[i];\n      it = lst.begin() + i;\n    }\n\
    \  }\n  return ret;", "  std::sort(lst.begin(), lst.end());\n  if (lst.size()\
    \ > 2) {\n    return lst[1];\n  }\n  return std::nullopt;", "    if(lst.empty())\
    \ return std::nullopt;\n    if(lst.size()==1) return lst.front();\n    long cur_val\
    \ = lst.front();\n    for(size_t i = 1; i < lst.size(); i++) {\n        if(lst[i]\
    \ < cur_val) return std::nullopt;\n    }\n    return cur_val;", "    long n =\
    \ lst.size();\n    if (n==0) return std::nullopt;\n    std::vector<long>::iterator\
    \ it = std::lower_bound(lst.begin(), lst.end(), lst[0]);\n    if (it==lst.end()\
    \ || it==lst.begin()) return std::nullopt;\n    return std::make_optional(std::next(it,1));",
  "    auto itr = lst.begin();\n    if (itr == lst.end()) {\n        return std::nullopt;\n\
    \    }\n    int index = *itr;\n    if (index == *lst.begin()) {\n        return\
    \ std::nullopt;\n    }\n    ++itr;\n    bool found = false;\n    while (itr !=\
    \ lst.end() && !found) {\n        long index = *itr;\n        if (index == *itr)\
    \ {\n            found = true;\n        } else {\n            itr = lst.erase(itr);\n\
    \            index = *itr;\n        }\n    }\n    if (itr == lst.end()) {\n  \
    \      return std::nullopt;\n    }\n    return *itr;", "    if(lst.size() < 2\
    \ )\n        return std::nullopt;\n    auto it = lst.begin();\n    std::advance(it,\
    \ 1);\n    return *it;", "    if (lst.empty())\n        return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    auto val = *it;\n\
    \    lst.erase(it);\n    return val;", "  auto min_itr = std::min_element(lst.begin(),\
    \ lst.end());\n  if (lst.end() == min_itr)\n    return std::nullopt;\n  if (min_itr\
    \ == lst.begin())\n    return *min_itr;\n  if (*min_itr < *(min_itr - 1))\n  \
    \  return *min_itr;\n  *min_itr = *(min_itr - 1);\n  return *min_itr;", "    auto\
    \ it = lst.begin();\n    auto it_prev = std::next(it);\n    auto it_next = std::next(it_prev);\n\
    \    auto it_end = lst.end();\n    if (it_next == it_end) return std::nullopt;\n\
    \    if (*it < *it_prev)\n    {\n        ++it;\n        ++it_prev;\n    }\n  \
    \  if (*it < *it_prev)\n    {\n        ++it;\n        ++it_prev;\n    }\n    if\
    \ (*it < *it_prev)\n    {\n        ++it;\n        ++it_prev;\n    }\n    if (*it\
    \ < *it_prev)\n    {\n        ++it;\n        ++it_prev;\n    }\n    if (*it <\
    \ *it_prev)\n    {\n        ++it;\n        ++it_prev;\n    }\n    if (*it < *it_prev)\n\
    \    {\n        ++it;\n        ++it_prev;\n    }\n    if (*it < *it_prev)\n  \
    \  {\n        ++it;\n        ++it_prev;\n    }\n    if (*it < *it_prev)\n    {\n\
    \        ++it;\n        ++it_prev;\n    }\n    if (*it < *it_prev)\n    {\n  \
    \      ++it;\n        ++it_prev;\n    }\n    if (*it < *it_prev)\n    {\n    \
    \    ++it;\n        ++it_prev;\n    }\n    if (*it < *it_prev)\n    {\n      \
    \  ++it;\n        ++it_prev;\n    }\n    if (*it < *it_prev)\n    {\n        ++it;\n\
    \        ++it_prev;\n    }\n    if (*it < *it_prev)\n    {\n        ++it;\n  \
    \      ++it_prev;\n    }\n    if (*it < *it_prev)\n    {\n        ++it;\n    \
    \    ++it_prev;\n    }\n    if (*it < *it_prev)\n    {\n        ++it;\n      \
    \  ++it_prev;\n    }\n    if (*it < *it_prev)\n    {\n        ++it;\n        ++it_prev;\n\
    \    }\n    if (*it < *it_prev)\n    {\n        ++it;\n        ++it_prev;\n  \
    \  }\n    if (*it < *it_prev)\n    {\n        ++it;\n        ++it_prev;\n    }\n\
    \    if (*it < *it_prev)\n    {\n        ++it;\n        ++it_prev;\n    }\n  \
    \  if (*it < *it_prev)\n    {\n", "    // Code Here\n    if(lst.empty()) \n  \
    \      return std::nullopt;\n    if(lst.size() == 1)\n        return lst[0];\n\
    \    auto first = lst.begin();\n    auto last = lst.end();\n    --last;\n    auto\
    \ val = *first;\n    while(last != lst.begin()) {\n        if(*last < val)\n \
    \           first = last;\n        else\n            val = *first;\n        --last;\n\
    \    }\n    return val;", "    assert(lst.size() > 0);\n    auto it = lst.begin();\n\
    \    auto low = *it;\n    ++it;\n    for (; it != lst.end() && low < *it; ++it)\
    \ {\n        low = *it;\n    }\n    return std::optional<long>(low);", "  std::sort(lst.begin(),\
    \ lst.end());\n  if (lst.size() == 2) {\n    return lst[1];\n  }\n  return std::nullopt;",
  "    // Write your code here\n    auto it = lst.begin();\n    auto first = *it;\n\
    \    it = lst.begin() + 1;\n    auto second = *it;\n    if (it == lst.end()) {\n\
    \        return std::nullopt;\n    }\n    auto third = *it;\n    if (first < second\
    \ && second < third) {\n        return second;\n    } else if (first < third)\
    \ {\n        return third;\n    } else {\n        return first;\n    }", "   \
    \ auto itr = std::min_element(lst.begin(), lst.end());\n    if (itr == lst.end())\
    \ return std::nullopt;\n    auto end = lst.end();\n    --end;\n    auto itr2 =\
    \ std::min_element(lst.begin(), end);\n    if (itr2 == end) return std::nullopt;\n\
    \    return itr2;", "    if(lst.size() == 0){\n        return std::nullopt;\n\
    \    }\n    auto result = std::min(*(++lst.begin()), *lst.end());\n    lst.erase(lst.begin(),\
    \ lst.begin() + 1);\n    return std::make_optional(result );", "  if (lst.size()\
    \ == 0)\n    return std::nullopt;\n  std::map<long, std::size_t> store;\n  for\
    \ (auto i : lst)\n    store[std::min(i)] = store.size();\n  auto it = store.rbegin();\n\
    \  return it != store.rend() ? std::nullopt : it->second;", '  // code here',
  "    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\
    \ {\n        return std::nullopt;\n    }\n    auto ret = *it;\n    lst.erase(it);\n\
    \    return ret;", "    // code here\n    auto begin = lst.begin(), end = lst.end(),\
    \ min_idx = 0, min_val = *begin;\n    begin++;\n    for (; begin != end; ++begin)\
    \ {\n        if (*begin < min_val) {\n            min_val = *begin;\n        \
    \    min_idx = begin - lst.begin();\n        }\n    }\n    if (min_idx == lst.size()\
    \ - 1)\n        return min_val;\n    return lst[min_idx + 1];", '    return std::nullopt;',
  "    for(long i : lst) {\n        if(i <= lst[1]) {\n            lst[1] = i;\n \
    \           break;\n        }\n    }\n    return std::nullopt;", "\tstd::optional<long>\
    \ minval;\n\tfor (auto x : lst) {\n\t\tminval = std::min(minval, x);\n\t}\n\t\
    return minval;", "    if(lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if(*it == lst.front()) return std::nullopt;\n    if(*it < lst.front())\
    \ return *it;\n    return next_smallest({lst.begin()+1, lst.end()});", "    if\
    \ (lst.empty())\n        return std::nullopt;\n    if (lst.size() == 1)\n    \
    \    return lst[0];\n    auto it = lst.begin();\n    auto begin = it;\n    auto\
    \ end = lst.end();\n    it--;\n    for (; it != end && it != begin; it++) {\n\
    \        if (it->second < it->first)\n            return it->second;\n    }\n\
    \    return *begin;", "\tif (lst.size() == 0) return std::nullopt;\n\tlong currMin\
    \ = *min_element(lst.cbegin(), lst.cend());\n\tfor (long i=lst.size()-2; i>=0;\
    \ i--) {\n\t\tif (currMin < lst[i]) {\n\t\t\tcurrMin = lst[i];\n\t\t}\n\t}\n\t\
    return currMin;", "    if(lst.empty()) return std::nullopt;\n    std::optional<long>\
    \ min;\n    for(long &num: lst) {\n        if(min.has_value() && (min == num))\
    \ continue;\n        if(num < min.value()) {\n            min = num;\n       \
    \ }\n    }\n    return min;", "  // Your code here\n  assert(lst.size() >= 2);\n\
    \n  long first = lst[0];\n  long second = lst[1];\n\n  if (first == second)\n\
    \    return std::nullopt;\n  else if (first > second)\n  {\n    long tmp = first;\n\
    \    first = second;\n    second = tmp;\n  }\n\n  auto it = std::min_element(lst.begin(),\
    \ lst.end());\n  if (it == lst.end())\n    return std::nullopt;\n  else\n    return\
    \ *it;", "  if(lst.size() == 0)\n      return std::nullopt;\n\n  auto it1 = std::min_element(lst.begin(),\
    \ lst.end());\n  auto it2 = std::max_element(lst.begin(), lst.end());\n\n  return\
    \ std::make_optional(it1==it2 ? std::distance(it1, lst.end()) : std::distance(it2,\
    \ lst.end()));", "    // sort and get the 2nd smallest element\n    auto it =\
    \ std::min_element(lst.begin(), lst.end());\n    if (it != lst.end()) {\n    \
    \    return *it;\n    } else {\n        return std::nullopt;\n    }", "    long\
    \ first = 0;\n    long second = 0;\n    for (auto itr = lst.begin(); itr != lst.end();\
    \ ++itr) {\n        if (first > itr) {\n            first = *itr;\n        } else\
    \ if (second > itr) {\n            second = *itr;\n        }\n    }\n    if (first\
    \ > second) return std::nullopt;\n    return first;", "    if(lst.size() == 0)\
    \ return std::nullopt;\n    auto it = lst.begin();\n    long val = *it;\n    it++;\n\
    \    if(*it < val) std::swap(val, *it);\n    return it;", "    if (lst.empty())\
    \ return std::nullopt;\n    std::optional<long> result = std::min(lst);\n    lst.erase(std::next(lst.begin(),\
    \ std::distance(lst,result.value_or(std::numeric_limits<long>::max())-1)));\n\
    \    return result.value_or(std::numeric_limits<long>::max());", "    //write\
    \ your code here\n    if (lst.size() > 0)\n    {\n        if (lst.front() <= lst.back())\n\
    \        {\n            return lst.front();\n        }\n    }\n    return std::nullopt;",
  "    // Write your code here\n    if(lst.size()==0)\n        return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if(it==lst.end())\
    \ \n        return std::nullopt;\n    return *it;", "    if(lst.size() <= 1)\n\
    \        return std::nullopt;\n    auto smallest = lst.begin();\n    auto next_smallest\
    \ = lst.begin() + 1;\n    for(auto it = lst.begin() + 1; it != lst.end(); ++it)\n\
    \    {\n        if(*it < smallest)\n            smallest = it;\n        if(*it\
    \ < next_smallest)\n            next_smallest = it;\n    }\n    if(*next_smallest\
    \ < *smallest)\n        return *next_smallest;\n    else\n        return std::nullopt;",
  "    if (lst.empty()) return std::nullopt;\n    long min_val = *std::min_element(lst.begin(),\
    \ lst.end());\n    long min_pos = 0;\n    for (size_t i = 0; i + 1 < lst.size();\
    \ i++) {\n        if (lst[i] < min_val) {\n            min_val = lst[i];\n   \
    \         min_pos = i;\n        }\n    }\n    if (min_val == lst[min_pos]) {\n\
    \        return std::nullopt;\n    }\n    min_val = std::max_element(lst.begin()\
    \ + min_pos + 1, lst.end());\n    return lst.back();", "    if (lst.size() ==\
    \ 0)\n        return std::nullopt;\n    int mid = lst.size() / 2;\n    int min\
    \ = mid;\n    for (auto i = mid + 1; i < lst.size(); i++) {\n        if (lst[i]\
    \ < lst[min])\n            min = i;\n    }\n    if (min == mid)\n        return\
    \ std::nullopt;\n    return lst[min];", "    int sizeLst = lst.size();\n    if\
    \ (sizeLst < 2)\n        return {};\n    long min = lst[0];\n    long max = lst[0];\n\
    \    long ans = std::nullopt;\n    for (size_t i = 1; i < sizeLst; i++) {\n  \
    \      if (lst[i] < max) {\n            max = lst[i];\n            ans = i;\n\
    \        }\n        if (lst[i] > min) {\n            min = lst[i];\n        }\n\
    \    }\n    return ans;", "    if (lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    auto it = lst.begin();\n    auto it2 = lst.begin();\n    if (*it <\
    \ std::prev(*it)) {\n        it2 = it;\n    } else {\n        it2 = it;\n    }\n\
    \    it++;\n    while (it != lst.end()) {\n        if (*it2 < *it) {\n       \
    \     it2 = it;\n        } else {\n            it2 = it;\n        }\n        it++;\n\
    \    }\n    return *it2;", "    // Your code here\n    std::optional<long> res\
    \ = std::nullopt;\n    auto it = lst.begin();\n    if (it != lst.end()) {\n  \
    \      it = std::adjacent_find(it, lst.end(), [&](long a, long b) {\n        \
    \    return a < b;\n        });\n    }\n    if (it != lst.end()) {\n        it\
    \ = std::adjacent_find(it, lst.end(), [&](long a, long b) {\n            return\
    \ a > b;\n        });\n        if (it != lst.end()) {\n            res = *it;\n\
    \        }\n    }\n    return res;", "  int size = lst.size();\n  if(size == 0)\
    \ {\n    return std::nullopt;\n  }\n  // Use a variable to hold the 2nd smallest\
    \ number\n  // Use an unordered_map to hold the number of occurrences of a number.\n\
    \  // We can use map::emplace to add the number to the map\n  // We will find\
    \ the smallest number in the map using lower_bound\n  // If the key exists, we\
    \ can return the 2nd smallest number in the map\n  // Otherwise return std::nullopt\n\
    \  std::unordered_map<long, int> counts;\n  // Use std::find to find the smallest\
    \ number in the map\n  // If the number is in the map, return it.\n  // Otherwise,\
    \ add it as the first number in the map\n  // Return the first number in the map\n\
    \  std::optional<long> ret = std::find_if(lst.begin(), lst.end(), [&counts](long\
    \ num){\n    auto it = counts.find(num);\n    if(it != counts.end()) {\n     \
    \ ++it->second;\n    }\n    else {\n      counts[num] = 1;\n    }\n    return\
    \ it->second == 1;\n  }) == lst.end() ? std::nullopt : ret.value();\n  return\
    \ ret;", "    if (lst.size() <= 1) return std::nullopt;\n    auto it = std::min_element(std::begin(lst),\
    \ std::end(lst));\n    auto it = std::min_element(std::begin(lst), std::end(lst),\
    \ [](const long& l, const long& r) { return l < r; });\n    return *it;", "  \
    \  if(lst.empty()) {\n        return std::nullopt;\n    }\n    if(lst.size() <=\
    \ 1) {\n        return std::nullopt;\n    }\n    long long min = *lst.begin();\n\
    \    for(long long x : lst) {\n        if(x < min) {\n            min = x;\n \
    \       }\n    }\n    return min;", "    int min_idx = 0;\n    for (int i = 0;\
    \ i < lst.size(); ++i)\n        if (lst[i] < lst[min_idx])\n            min_idx\
    \ = i;\n    long min_val = lst[min_idx];\n    for (int i = 0; i < lst.size();\
    \ ++i)\n        if (lst[i] < min_val)\n            min_val = lst[i];\n    return\
    \ min_idx == lst.size() ? std::nullopt : min_val;", "    std::vector<long> sorted_list\
    \ = lst;\n    sort(sorted_list.begin(), sorted_list.end());\n    if (sorted_list.empty())\
    \ return std::nullopt;\n    size_t sz = sorted_list.size();\n    if (sz < 2) return\
    \ sorted_list.back();\n    auto it = std::next(sorted_list.begin(), 1);\n    while\
    \ (it != sorted_list.end() && it != sorted_list.begin()) {\n        if (*it <\
    \ *(--it)) break;\n    }\n    if (it == sorted_list.end()) return std::nullopt;\n\
    \    return *it;", "    if(lst.size()==0) return std::nullopt;\n    auto it =\
    \ std::begin(lst);\n    auto smallest = *it;\n    auto smallestPos = it;\n   \
    \ for(auto i = it+1; i < lst.size(); i++) {\n        smallest = std::min(smallest,\
    \ lst[i]);\n        smallestPos = i;\n    }\n    return smallestPos;", "    if\
    \ (lst.empty()) return std::nullopt;\n    long min = lst[0];\n    for (int i =\
    \ 1; i < lst.size(); ++i) {\n        if (lst[i] < min) {\n            min = lst[i];\n\
    \        }\n    }\n    return min;", "    if (lst.size() == 0)\n        return\
    \ std::nullopt;\n    auto it = lst.begin();\n    auto last = lst.end();\n    ++it;\n\
    \    while (it != last) {\n        if ((*it)<*it) {\n            --it;\n     \
    \       break;\n        }\n        ++it;\n    }\n    if (it == last) {\n     \
    \   return std::nullopt;\n    }\n    return *it;", "    if (lst.empty()) {\n \
    \       return std::nullopt;\n    }\n    auto begin = std::lower_bound(lst.begin(),\
    \ lst.end(), lst[0]);\n    if (begin == lst.end()) return std::nullopt;\n    auto\
    \ end = std::upper_bound(begin, lst.end(), lst[0]);\n    if (end == lst.end())\
    \ return std::nullopt;\n    return lst[end - 1];", "    if (lst.empty()) {\n \
    \       return std::nullopt;\n    }\n    auto it = std::lower_bound(lst.begin(),\
    \ lst.end(), lst[0]);\n    if (it == lst.end() || (*it) < lst[0]) {\n        return\
    \ std::nullopt;\n    }\n    if (it == lst.begin()) {\n        return lst[0];\n\
    \    }\n    return *--it;", "\tassert(lst.size() > 0);\n\n\tlong prev_elem = lst[0];\n\
    \tlong curr_elem = lst[0];\n\tlong next_elem = prev_elem;\n\n\tfor (int i = 0;\
    \ i < lst.size() - 1; i++) {\n\t\tcurr_elem = lst[i];\n\t\tif (curr_elem < prev_elem)\
    \ {\n\t\t\tnext_elem = curr_elem;\n\t\t\tprev_elem = curr_elem;\n\t\t} else {\n\
    \t\t\tif (next_elem > prev_elem)\n\t\t\t\tnext_elem = prev_elem;\n\t\t\telse\n\
    \t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (next_elem == prev_elem)\n\t\treturn std::nullopt;\n\
    \telse\n\t\treturn next_elem;", "    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end()) return std::nullopt;\n    auto val = *it;\n    lst.erase(it);\n\
    \    return val;", "    auto it = lst.begin();\n    if (it == lst.end()) return\
    \ std::nullopt;\n    if (*it < lst.front()) {\n        auto min_it = it;\n   \
    \     while (min_it != lst.begin() && min_it != lst.end() && *min_it < lst.front())\
    \ min_it++;\n        return *min_it;\n    }\n    std::vector<long>::iterator min_it\
    \ = lst.begin();\n    while (min_it != lst.end() && *min_it < lst.front()) min_it++;\n\
    \    return *min_it;", "    long curr = lst[0];\n    long prev = lst[0];\n   \
    \ for (long i = 1; i < lst.size(); i++) {\n        if (lst[i] < prev) {\n    \
    \        curr = lst[i];\n            prev = lst[i];\n        }\n    }\n    return\
    \ curr;", "    long smallest;\n    if (lst.empty())\n        return std::nullopt;\n\
    \    long largest = std::accumulate(lst.begin(), lst.end(), (long)std::numeric_limits<long>::min());\n\
    \    smallest = *std::min_element(lst.begin(), lst.end());\n    return std::find(lst.begin(),\
    \ lst.end(), smallest) != lst.end() ? smallest : largest;", "  assert(lst.size()\
    \ != 0);\n  if (lst.size() == 1)\n    return std::nullopt;\n  auto it = std::max_element(lst.begin(),\
    \ lst.end());\n  if (*it == *lst.begin())\n    return *lst.begin();\n  auto it2\
    \ = std::min_element(lst.begin(), lst.end());\n  return *it2;", "    // Write\
    \ your code here\n    long smallest = std::numeric_limits<long>::max();\n    if(lst.empty())\
    \ return {};\n    for(auto it : lst) {\n        if(it < smallest) smallest = it;\n\
    \    }\n    for(auto it : lst) {\n        if(it < smallest) {\n            smallest\
    \ = it;\n        }\n    }\n    return smallest;", "  int smallest = std::numeric_limits<long>::min();\n\
    \  auto it = std::find_if(lst.begin(), lst.end(),\n                         [smallest](long\
    \ l) { return l < smallest; });\n  if (it == lst.end()) return std::nullopt;\n\
    \  if (*it == smallest) {\n    it = std::find_if(lst.begin(), lst.end(),\n   \
    \                    [smallest](long l) { return l > smallest; });\n    if (it\
    \ == lst.end()) return std::nullopt;\n  }\n  auto tmp = *it;\n  it = std::find_if(lst.begin(),\
    \ lst.end(),\n                     [smallest](long l) { return l > smallest; });\n\
    \  if (it == lst.end()) {\n    it = lst.begin();\n  }\n  *it++ = smallest;\n \
    \ if (it == lst.end()) return std::nullopt;\n  tmp = *it;\n  *it++ = smallest;\n\
    \  return tmp;", "  std::vector<long> sorted_lst(std::begin(lst), std::end(lst));\n\
    \  std::sort(sorted_lst.begin(), sorted_lst.end());\n  if (sorted_lst.size() ==\
    \ 0) {\n    return std::nullopt;\n  }\n  sorted_lst.push_back(sorted_lst.front());\n\
    \  return sorted_lst.back();", "    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end()) return std::nullopt;\n    return *it;", "  std::sort(lst.begin(),\
    \ lst.end());\n  if(lst.size() == 0) return std::nullopt;\n  return lst.at(1);",
  "  // Your code here\n  auto itr = lst.begin();\n  long min = *itr;\n  if (itr !=\
    \ lst.end())\n    ++itr;\n  if (itr != lst.end())\n    min = *itr;\n  while (!lst.empty()\
    \ && min > lst.back())\n    lst.pop_back();\n  if (itr != lst.end())\n    min\
    \ = *itr;\n  return min;", "    long smallest=lst[0];\n    long index=1;\n   \
    \ if(lst.size()==0){\n        return std::nullopt;\n    }\n    for(long i=1;i<lst.size();i++){\n\
    \        if(smallest>lst[i]){\n            smallest=lst[i];\n            index=i;\n\
    \        }\n    }\n    return std::optional<long>(index);", "  std::optional<long>\
    \ ans;\n  long l = *std::min_element(lst.begin(), lst.end());\n  if (lst.size()\
    \ == 1) {\n    ans = l;\n  }\n  else {\n    ans = *std::min_element(lst.begin()\
    \ + 1, lst.begin() + lst.size());\n  }\n  return ans;", "    if (lst.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    auto itr = lst.begin();\n   \
    \ auto itr1 = itr + 1;\n    std::advance(itr1, 1);\n    if (itr == itr1) {\n \
    \       return std::nullopt;\n    }\n    if (*itr < *itr1) {\n        return *itr;\n\
    \    }\n    return *itr1;", "    int size = lst.size();\n    if (size == 0) {\n\
    \        return std::nullopt;\n    }\n    if (size % 2 != 0) {\n        return\
    \ std::nullopt;\n    }\n    std::vector<long> copy{std::begin(lst), std::begin(lst)\
    \ + size/2};\n    auto min = *std::min_element(copy.begin(), copy.end());\n  \
    \  auto second = *std::min_element(copy.begin() + size, copy.end());\n    return\
    \ std::make_optional(std::min(min, second));", "    if (lst.size() == 0) return\
    \ std::nullopt;\n    if (lst.size() == 1) return lst[0];\n    long a = lst[0];\n\
    \    long b = lst[1];\n    if (a > b) return a;\n    return b;", "    std::map<long,\
    \ int> count_map;\n    for (long i = 0; i < lst.size(); i++) {\n        int c\
    \ = count_map.count(lst[i]);\n        if (c == 0)\n            count_map[lst[i]]\
    \ = 1;\n        else if (c == 1) {\n            count_map[lst[i]]++;\n       \
    \ }\n        else if (c > 1)\n            count_map[lst[i]]++;\n    }\n    for\
    \ (auto it = count_map.begin(); it != count_map.end(); it++) {\n        if (it->second\
    \ == 1)\n            return it->first;\n    }\n    return std::nullopt;", "  \
    \  std::optional<long> min_el;\n    auto it = lst.begin();\n    if (it != lst.end())\
    \ {\n        long min_val = *it;\n        ++it;\n        for (; it != lst.end();\
    \ ++it) {\n            if (*it < min_val) {\n                min_val = *it;\n\
    \                min_el = min_val;\n            }\n        }\n    }\n    return\
    \ min_el;", "    for (auto& x : lst) {\n        if (std::find(lst.begin(), lst.end(),\
    \ x) != lst.end()) {\n            auto it = std::find(lst.begin(), lst.end(),\
    \ x);\n            if (it == lst.end()) it = lst.end();\n            return *std::next(it,\
    \ 1);\n        }\n    }\n    return std::nullopt;", "    std::optional<long> res;\n\
    \    for(auto i = lst.begin(); i != lst.end(); ++i) {\n        if(i->second <=\
    \ res->second) {\n            res = *i;\n        }\n    }\n    return res;", " \
    \   // Your code goes here\n    auto it = lst.begin();\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    if (it->second < lst.begin()->second)\n   \
    \     return std::nullopt;\n    for (++it; it != lst.end(); it++) {\n        if\
    \ (it->second < lst.begin()->second)\n            return *it;\n    }\n    return\
    \ std::nullopt;", '    return *std::min_element(lst.begin(), lst.end());', " \
    \   // Your code here\n    if(lst.empty()){\n        return std::nullopt;\n  \
    \  }\n    std::vector<std::pair<long, long>> sorted_vec(lst.begin(), lst.end());\n\
    \    std::sort(sorted_vec.begin(), sorted_vec.end(), [](const std::pair<long,\
    \ long> &a, const std::pair<long, long> &b){\n        return a.first < b.first;\n\
    \    });\n    return sorted_vec[sorted_vec.size()-2].second;", "  std::optional<long>\
    \ res;\n  long smallest = *std::min_element(lst.cbegin(), lst.cend());\n  if (smallest\
    \ == 0) {\n    return res;\n  } else {\n    lst.erase(std::remove_if(lst.begin(),\
    \ lst.end(), [smallest](int v){return v < smallest;}), lst.end());\n    if (lst.empty())\
    \ {\n      return res;\n    } else {\n      auto it = std::min_element(lst.cbegin(),\
    \ lst.cend());\n      res = *it;\n      return res;\n    }\n  }", "  // Write\
    \ your code here\n  int n = lst.size();\n  assert(n != 0);\n  long long max_val\
    \ = lst.front();\n  long long min_val = lst.back();\n  long long *p = (long long*)&min_val;\n\
    \  for(long long i = 0; i < n; ++i) {\n    if (lst[i] < max_val)\n      continue;\n\
    \    else {\n      if(*p > max_val)\n        *p = max_val;\n      break;\n   \
    \ }\n  }\n  return *p == max_val ? std::nullopt : max_val;", "    auto itr = lst.begin();\n\
    \    while(itr != lst.end()) {\n        if((*itr) > itr + 1) {\n            break;\n\
    \        }\n        ++itr;\n    }\n    return *itr;", "    long temp, min;\n \
    \   for (size_t i = 0; i < lst.size(); i++) {\n        min = lst[i];\n       \
    \ for (size_t j = i + 1; j < lst.size(); j++) {\n            if (lst[j] < min)\
    \ {\n                min = lst[j];\n                temp = j;\n            }\n\
    \        }\n        if (min) {\n            return temp;\n        }\n    }\n \
    \   return std::nullopt;", "    auto it = lst.begin();\n    long ans = *it;\n\
    \    while (it != lst.end() && (*it <= ans)) ++it;\n    if (it == lst.end()) return\
    \ std::nullopt;\n    ans = *it;\n    for (++it; it != lst.end(); ++it)\n     \
    \   if (*it <= ans)\n            ans = *it;\n    return ans;", "    int smallest\
    \ = 0;\n    int index = 0;\n    long curr = lst[0];\n\n    for (size_t i = 1;\
    \ i < lst.size(); i++) {\n        if (curr <= lst[i]) {\n            smallest\
    \ = i;\n            index = i;\n        } else {\n            if (smallest !=\
    \ 0) {\n                curr = lst[smallest];\n                smallest = 0;\n\
    \                index = 0;\n            }\n        }\n    }\n    if (smallest\
    \ != 0) {\n        curr = lst[smallest];\n    }\n    return std::optional<long>(curr);",
  "    if (lst.size() <= 0) return std::nullopt;\n    long idx = lst.size() - 1;\n\
    \    for (long i = lst.size() - 2; i >= 0; --i) {\n        if (lst[i] < lst[idx])\n\
    \            idx = i;\n    }\n    if (idx == 0) return std::nullopt;\n    return\
    \ lst[idx];", "    auto itr = lst.cbegin();\n    auto itr2 = lst.cend();\n   \
    \ if (itr == itr2) return std::nullopt;\n    \n    long val = *itr;\n    long\
    \ val2 = *itr2;\n    \n    for (++itr; itr != itr2; ++itr) {\n        long cmp\
    \ = *itr;\n        if (cmp > val2) {\n            val2 = cmp;\n        }\n   \
    \ }\n    \n    return val2;", "  if (lst.size() < 2) {\n    return std::nullopt;\n\
    \  }\n  std::sort(lst.begin(), lst.end());\n  auto it = lst.begin() + 1;\n  return\
    \ std::optional<long>(std::distance(it, lst.end()));", "    // write your code\
    \ in C++14\n    auto it = lst.begin();\n    auto last = lst.end();\n    auto result\
    \ = std::nullopt;\n    for (; it != last; ++it) {\n        if (std::next(it) ==\
    \ last) break;\n        if (*it < *(++it)) result = *it;\n    }\n    return result;",
  "    // Write your code here.\n    long smallest_val = std::numeric_limits<long>::max();\n\
    \    std::optional<long> next_val;\n    for (long elem : lst) {\n        if (elem\
    \ < smallest_val) {\n            smallest_val = elem;\n            next_val =\
    \ elem;\n        } else if (elem > smallest_val && elem != next_val.second) {\n\
    \            next_val = elem;\n        }\n    }\n    return next_val;", "    if\
    \ (lst.size() == 0)\n        return std::nullopt;\n    if (lst.size() == 1)\n\
    \        return lst[0];\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (*it < lst[1])\n        return *it;\n    auto it2 = std::max_element(lst.begin(),\
    \ lst.end());\n    return it2 != lst.end() && *it2 != *it ? it2 : std::nullopt;",
  "    if (!lst) return std::nullopt;\n    long k = 2 * (*(lst.end()) - 1);\n    for\
    \ (auto i = lst.begin(); i != lst.end(); i++)\n        if (*i >= k) {\n      \
    \      k = k * (*(i) - 1);\n        }\n    return k;", "    std::optional<long>\
    \ ret;\n    if (lst.size() >= 2) {\n        long lst_min = lst[0];\n        long\
    \ lst_max = lst[1];\n        std::vector<long> lst_rest = lst;\n        std::nth_element(lst_rest.begin(),\
    \ lst_rest.begin() + 1, lst_rest.end());\n        if (lst_rest[0] != lst_min)\
    \ {\n            ret = lst_rest[0];\n        } else if (lst_rest[1] < lst_min)\
    \ {\n            ret = lst_min;\n        } else if (lst_rest[1] > lst_max) {\n\
    \            ret = lst_max;\n        }\n    }\n    return ret;", "    sort(lst.begin(),\
    \ lst.end());\n    if(lst.size() == 2)\n        return lst[1];\n    else\n   \
    \     return std::nullopt;", "    if(lst.size() == 0) return std::nullopt;\n \
    \   std::vector<long>::iterator itr = lst.begin();\n    std::vector<long>::iterator\
    \ itr2 = lst.begin();\n    while(itr2 != lst.end()) {\n        if(itr2 == itr\
    \ + 1) {\n            itr2 = lst.end();\n            break;\n        }\n     \
    \   if(itr->second < itr2->second) {\n            itr = itr2;\n            itr2\
    \ = lst.end();\n        } else {\n            itr2++;\n        }\n    }\n    return\
    \ itr;", "  std::vector<std::pair<long, bool>> vv(lst.size());\n  for (size_t\
    \ i = 0; i < lst.size(); i++) {\n    if (lst[i] < vv[i].first) {\n      vv[i].first\
    \ = lst[i];\n      vv[i].second = true;\n    } else if (lst[i] == vv[i].first)\
    \ {\n      vv[i].second = true;\n    } else {\n      vv[i].second = false;\n \
    \   }\n  }\n  std::nullopt_t opt = std::optional<long>();\n  for (size_t i = 0;\
    \ i < vv.size(); i++) {\n    if (vv[i].second) {\n      opt = vv[i].first;\n \
    \     break;\n    }\n  }\n  return opt;", "    assert(lst.size() != 0);\n    long\
    \ a = lst.front();\n    long b = lst[1];\n    long c = lst[2];\n    long d = lst[3];\n\
    \    long e = lst[4];\n    if (a > b) {\n        if (b > c) {\n            if\
    \ (c > d) {\n                if (d > e) {\n                    return e;\n   \
    \             } else {\n                    return c;\n                }\n   \
    \         } else {\n                return d;\n            }\n        } else {\n\
    \            return b;\n        }\n    } else {\n        return a;\n    }", " \
    \   if (lst.size() == 0)\n        return std::nullopt;\n    auto it = lst.begin();\n\
    \    long temp = 0;\n    for (; it != lst.end(); ++it)\n    {\n        if (*it\
    \ < temp)\n        {\n            temp = *it;\n        }\n    }\n    return std::nullopt;",
  "    std::optional<long> smallest = std::nullopt;\n    if (lst.size() < 2) return\
    \ smallest;\n    for (long i = lst.size()-2; i >= 0; i--) {\n        if (lst.at(i)\
    \ < lst.at(i+1)) {\n            smallest = lst.at(i);\n        }\n    }\n    return\
    \ smallest;", "    if (lst.size() > 2) return std::nullopt;\n    long min = lst[0];\n\
    \    for (long i : lst) if (i < min) min = i;\n    return min;", "    if (lst.empty())\
    \ {\n        return std::nullopt;\n    }\n    long smallest = *lst.begin();\n\
    \    std::vector<long>::iterator it = lst.begin();\n    std::vector<long>::iterator\
    \ end = lst.end();\n    for (; it != end; it++) {\n        if ((*it) < smallest)\
    \ {\n            smallest = (*it);\n            it = end;\n        }\n    }\n\
    \    return smallest;", "    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    return (*it < lst.end()) ? *it : std::nullopt;", "    if (lst.size() <= 1)\
    \ return std::nullopt;\n    auto it = lst.begin() + 1;\n    auto prev = *it;\n\
    \    ++it;\n    for (; it != lst.end(); ++it) {\n        if (*it < prev) {\n \
    \           prev = *it;\n            break;\n        }\n    }\n    return prev;",
  "    std::vector<long> v;\n    for (auto& i : lst) v.push_back(i);\n    if (v.empty())\
    \ return std::nullopt;\n    std::sort(v.begin(), v.end());\n    if (v[0] != v[1])\
    \ std::swap(v[0], v[1]);\n    return v[1];", "    long min = *lst.rbegin();\n\
    \    long max = *lst.begin();\n    for (long elem : lst) {\n        if (elem <\
    \ min) {\n            min = elem;\n        }\n        if (elem > max) {\n    \
    \        max = elem;\n        }\n    }\n    return std::nullopt;", "    assert(lst.size()\
    \ > 1);\n    long long min = std::numeric_limits<long long>::max();\n    long\
    \ long max = std::numeric_limits<long long>::min();\n    for (long long i = 0;\
    \ i < lst.size(); i++) {\n        assert(lst[i] >= 0);\n        assert(lst[i]\
    \ <= max);\n        assert(lst[i] <= min);\n        min = lst[i];\n        max\
    \ = lst[i];\n    }\n    return std::nullopt;", "  if (lst.size() == 0) return\
    \ std::nullopt;\n  int idx = 1;\n  while (idx < lst.size() && lst[idx] < lst[idx\
    \ -1]) {\n    idx++;\n  }\n  if (idx == lst.size()) return std::nullopt;\n  return\
    \ lst[idx];", "    auto it = std::min_element(lst.begin(), lst.end());\n    auto\
    \ it_next = std::next(it);\n    if (it_next == lst.end()) {\n        return {};\n\
    \    }\n    return *it_next;", "    if(lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    long first = *lst.begin();\n    std::sort(lst.begin(), lst.end());\n\
    \    auto it = std::find(lst.begin(), lst.end(), first);\n    if(it != lst.end())\
    \ {\n        auto second = std::next(it);\n        if(second != lst.end()) {\n\
    \            std::nth_element(lst.begin(), second, lst.end());\n            return\
    \ *it;\n        }\n    }\n    return std::nullopt;", "  std::map<long, long> mp;\n\
    \  for (auto i : lst) {\n    mp[i] = mp.size();\n  }\n  auto it = mp.begin();\n\
    \  it--;\n  if (!mp.end())\n    return it->second;\n  else {\n    return std::nullopt;\n\
    \  }", "    auto it = std::min_element(lst.begin(), lst.end());\n    if (it ==\
    \ lst.end()) {\n        return {};\n    }\n    return *it;", "    if (lst.empty())\
    \ return std::nullopt;\n    long min_elem = *std::min_element(lst.begin(), lst.end());\n\
    \    long min_idx = std::distance(std::begin(lst), std::find(std::begin(lst),\
    \ std::end(lst), min_elem));\n    long result = lst[min_idx];\n    if (min_elem\
    \ < lst[1]) {\n        std::advance(lst.begin(), min_idx + 1);\n        return\
    \ result;\n    }\n    return std::nullopt;", "    // Complete the function.\n\
    \    return lst.empty() ? std::nullopt : lst[1];", "    auto begin = lst.begin();\n\
    \    auto end = lst.end();\n    if (begin == end)\n        return std::nullopt;\n\
    \    auto last = begin;\n    if (std::distance(begin, end) > 0)\n        --end;\n\
    \    for (;; ++last, ++end) {\n        if (*last < *end)\n            break;\n\
    \    }\n    return *last;", "    long min2 = lst[0];\n    long min1 = lst[1];\n\
    \    if (lst.size() == 2)\n        return std::nullopt;\n\n    for (size_t i =\
    \ 2; i < lst.size(); i++) {\n        if (lst[i] < min2)\n            min2 = lst[i];\n\
    \        if (lst[i] < min1)\n            min1 = lst[i];\n    }\n\n    return min1;",
  "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    long min_value\
    \ = *min_element(lst.begin(), lst.end());\n    if (lst.size() == 1) {\n      \
    \  return min_value;\n    }\n    long current_value = *min_element(lst.begin(),\
    \ lst.begin() + 1);\n    if (current_value == min_value) {\n        std::advance(lst.begin(),\
    \ 1);\n        return next_smallest(lst);\n    } else {\n        return std::nullopt;\n\
    \    }", "    if (lst.size() == 0)\n        return std::nullopt;\n    long current_min\
    \ = lst[0];\n    for (long &item : lst) {\n        if (item < current_min)\n \
    \           current_min = item;\n    }\n    if (current_min != lst[current_min])\n\
    \        return current_min;\n    return next_smallest(lst);", "  std::priority_queue<long>\
    \ q; \n  for(long i : lst) {\n    q.push(i);\n  }\n  // if queue is empty return\
    \ none \n  // if queue is full return first smallest element\n  if (q.empty()\
    \ || q.size() > 1) {\n    return std::nullopt;\n  }\n  auto res = q.top();\n \
    \ q.pop();\n  return res;", "    // Write your logic here\n    if (lst.empty())\n\
    \        return std::nullopt;\n    auto it = lst.begin();\n    while (it != lst.end())\
    \ {\n        if (it->second < it->second + 1)\n            return it;\n      \
    \  it++;\n    }\n    return std::nullopt;", "    long prev = lst[0];\n    long\
    \ min = prev;\n    for (size_t i = 1; i < lst.size(); i++)\n    {\n        if\
    \ (lst[i] < min)\n        {\n            prev = lst[i];\n            min = prev;\n\
    \        }\n        else\n        {\n            if (prev == min)\n          \
    \      return std::nullopt;\n            else\n                prev = lst[i];\n\
    \        }\n    }\n    return min;", "    // Write your code here\n    std::sort(lst.begin(),\
    \ lst.end());\n    return lst[lst.size()-2];", "    // Your code here\n    bool\
    \ flag = false;\n    std::optional<long> val = std::nullopt;\n    std::optional<long>\
    \ min = std::nullopt;\n    for (auto i : lst) {\n        if (i < val.value) {\n\
    \            flag = true;\n            val = i;\n            min = i;\n      \
    \  }\n        else if (i < min.value) {\n            min = i;\n        }\n   \
    \ }\n    return flag ? val : min;", "    auto it = std::min_element(std::begin(lst),\
    \ std::end(lst));\n    return std::optional<long>(it == std::end(lst) ? std::nullopt\
    \ : *it);", "    if(lst.empty()) \n        return std::nullopt;\n    auto it =\
    \ lst.begin();\n    long temp = 1;\n    while(it != lst.end()) {\n        if((*it)\
    \ > temp) {\n            temp = (*it);\n            ++it;\n        }\n       \
    \ ++it;\n    }\n    return temp;", "    for (long i = 0; i < lst.size(); i++)\n\
    \        if (lst[i] < lst[i + 1])\n            return std::nullopt;\n    return\
    \ std::optional<long>{lst.at(1)};", "    sort(lst.begin(), lst.end());\n    if(lst.empty())\
    \ return std::nullopt;\n    if(lst.size() == 1){\n        return lst[0];\n   \
    \ }\n    long result = std::min_element(lst.begin(), lst.end()) + 1;\n    lst.erase(std::remove(lst.begin(),\
    \ lst.end(), result), lst.end());\n    return result;", "    long min = std::numeric_limits<long>::min();\n\
    \    long index = 0;\n    for (auto it=lst.begin(); it!=lst.end(); ++it) {\n \
    \       if (*it < min) {\n            min = *it;\n            index = *it;\n \
    \       }\n    }\n    return std::optional<long>(index);", "  if(lst.empty())\n\
    \    return std::nullopt;\n  if(lst.size() == 2)\n    return lst[1];\n  long minl\
    \ = *std::min_element(lst.begin(), lst.end());\n  return lst.begin() == lst.end()\
    \ ? std::nullopt : std::optional<long>(minl);", "    long n1 = lst[0];\n    long\
    \ n2 = lst[1];\n    for (auto i = 2; i < lst.size(); i++) {\n        if (lst[i]\
    \ < n2) {\n            n2 = lst[i];\n        }\n    }\n    return n2;", "  sort(lst.begin(),\
    \ lst.end());\n  if (lst.size() <= 2) return {};\n  return lst[1];", "    auto\
    \ it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n \
    \       return {};\n    return *it;", "  if (lst.size() == 0) return std::nullopt;\n\
    \  auto it = lst.begin();\n  while (it != lst.end() && it->size() == 1) ++it;\n\
    \  if (it == lst.end()) return std::nullopt;\n  std::vector<long> reverse;\n \
    \ for (auto i = lst.rbegin(); i != lst.rend(); ++i) reverse.push_back(*i);\n \
    \ reverse.erase(reverse.begin() + it->size());\n  if (reverse.size() == 1) return\
    \ *it;\n  return next_smallest(reverse);", "    // Do not write main() function.\n\
    \    // Do not read input, instead use the arguments to the function.\n    //\
    \ Do not print the output, instead return values that you compute.\n    // Compile\
    \ with all warnings and debug info (so debug \n    // information can be run to\
    \ help find problems).\n    // Track your progress by adding cout's to cout in\
    \ the right places.\n    // Pick a meaningful variable name instead of \"a\" \n\
    \    // which won't be very meaningful outside the function.\n    long a = lst.size()\
    \ >= 2 ? lst[1] : std::nullopt;\n    for (long i = 0; i < lst.size(); i++) {\n\
    \        if (lst[i] > a)\n            a = lst[i];\n    }\n    return a;", "  \
    \  // Your code here\n    long min = *std::min_element(lst.begin(), lst.end());\n\
    \    if (min != *std::min_element(lst.begin() + 1, lst.end())) {\n        return\
    \ min;\n    } else {\n        return *std::max_element(lst.begin(), lst.end());\n\
    \    }", "    if(lst.size() >= 2) return *(std::min_element(lst.begin() + 1, lst.end()));\n\
    \    if(lst.size() == 0)\n        return std::nullopt;\n    else\n        return\
    \ *(std::max_element(lst.begin(), lst.end()));", "  if(lst.size() < 2) {\n   \
    \ return std::nullopt;\n  }\n\n  auto it = lst.begin();\n  long min = *it;\n \
    \ long second = *it;\n\n  for(++it; it != lst.end(); ++it) {\n    min = *it >\
    \ min ? min : *it;\n    second = *it < second ? second : *it;\n  }\n\n  return\
    \ it == lst.end() ? std::nullopt : std::optional<long>{min};", "    std::sort(lst.begin(),\
    \ lst.end());\n    lst.erase(lst.begin());\n    if (lst.empty()) throw std::runtime_error(\"\
    next_smallest: List is empty\");\n    else return lst.front();", "    assert(lst.size()\
    \ > 0);\n    long min_val = lst[0];\n    long max_val = lst[lst.size()-1];\n \
    \   auto it = std::upper_bound(lst.begin(), lst.end(), min_val);\n    if (it ==\
    \ lst.end()) return std::nullopt;\n    long next_element = *(it+1);\n    if (next_element\
    \ > max_val) return std::nullopt;\n    return next_element;", "  auto ret = std::nullopt;\n\
    \  long prev = lst[0];\n  for (long x : lst) {\n    if (x < prev) {\n      ret\
    \ = std::optional<long>();\n      break;\n    }\n    prev = x;\n  }\n  return\
    \ ret;", "    if (lst.empty()) {\n        return std::nullopt;\n    }\n    auto\
    \ it = lst.begin();\n    auto min_it = it;\n    for (; it != lst.end(); ++it)\
    \ {\n        if (*it < min_it->first) {\n            min_it = it;\n        }\n\
    \    }\n    if (min_it != it) {\n        lst.erase(min_it);\n    }\n    return\
    \ min_it;", "    int smallest = lst[0];\n    int second_smallest = smallest;\n\
    \    std::optional<long> result;\n\n    for (int i = 0; i < lst.size(); i++) {\n\
    \        if (lst[i] < smallest) {\n            second_smallest = smallest;\n \
    \       } else if (lst[i] < second_smallest) {\n            second_smallest =\
    \ lst[i];\n        } else {\n            result = std::nullopt;\n        }\n \
    \       smallest = lst[i];\n    }\n    return result;", '    return std::nullopt;',
  "    if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(std::begin(lst),\
    \ std::end(lst));\n    if (it != std::end(lst))\n        return *std::next(it);\n\
    \    return std::nullopt;", "    assert(lst.size() > 2);\n    long long mid =\
    \ lst.size() / 2;\n    auto it = lst.begin() + mid;\n    if (*it < *(lst.begin()\
    \ + mid)) {\n        it++;\n    }\n    if (it == lst.end()) {\n        return\
    \ std::nullopt;\n    }\n    return *it;", "  auto begin = lst.begin();\n  auto\
    \ end = lst.end();\n  auto mid = (begin + end) / 2;\n  if (begin == end) return\
    \ std::nullopt;\n  auto prev = *begin;\n  if (prev < mid) std::iter_swap(begin,\
    \ mid);\n  mid++;\n  if (mid == end) return std::nullopt;\n  if (*mid < prev)\
    \ return mid;\n  if (*mid > prev) std::iter_swap(mid, end);\n  return mid;", " \
    \   if (lst.empty())\n        return std::nullopt;\n    long largest = *std::max_element(lst.begin(),\
    \ lst.end());\n    for (auto i : lst) {\n        if (i != largest) {\n       \
    \     largest = i;\n        }\n    }\n    return largest;", "  if (lst.size()\
    \ == 0)\n    return std::nullopt;\n  long n1 = lst[0];\n  long n2 = lst[1];\n\
    \  long n3 = lst[2];\n  long n4 = lst[3];\n  long n5 = lst[4];\n  if (n1 < n2\
    \ && n1 < n3)\n    return n1;\n  else if (n2 < n1 && n2 < n3)\n    return n2;\n\
    \  else if (n3 < n1 && n3 < n2)\n    return n3;\n  else if (n4 < n1 && n4 < n3)\n\
    \    return n4;\n  else if (n5 < n1 && n5 < n4)\n    return n5;\n  else\n    return\
    \ std::nullopt;", "  if(lst.size()==0)\n    return std::nullopt;\n  \n  long min\
    \ = lst[0];\n  long idx = 0;\n  for(size_t i=1;i<lst.size();i++) {\n    if(lst[i]<min)\
    \ {\n      idx = i;\n      min = lst[idx];\n    }\n  }\n  if(idx==lst.size()-1)\
    \ idx--;\n  return idx==lst.size()-1?std::nullopt:lst[idx+1];", "    if(lst.size()\
    \ <= 1) {\n        return std::nullopt;\n    }\n    auto it = lst.begin() + 1;\n\
    \    if(*it == std::numeric_limits<long>::min()) {\n        ++it;\n    }\n   \
    \ for(; it != lst.end(); ++it) {\n        if(*it != *it) {\n            return\
    \ std::nullopt;\n        }\n    }\n    return *it;", "    long n = lst.size();\n\
    \    if (n < 2) return std::nullopt;\n    long prev = lst[0];\n    long min2 =\
    \ prev;\n    for (long i = 1; i < n; i++) {\n        long current = lst[i];\n\
    \        if (current < prev) {\n            min2 = current;\n            prev\
    \ = current;\n        } else {\n            min2 = prev;\n        }\n    }\n \
    \   return min2;", "    assert(lst.size() >= 2);\n    auto current = std::begin(lst);\n\
    \    auto prev = std::next(current, 1);\n    while (current != std::end(lst))\
    \ {\n        if (*current < prev) break;\n        if (*current == prev) return\
    \ std::nullopt;\n        prev = current;\n        current = std::next(current,\
    \ 1);\n    }\n    return *current;", "    if (lst.size() == 0) return std::nullopt;\n\
    \    auto itr = lst.begin();\n    while (itr != lst.end()) {\n        long current\
    \ = *itr;\n        ++itr;\n        if (current != *itr) {\n            itr = lst.begin();\n\
    \        }\n    }\n    return *itr;", "    sort(lst.begin(), lst.end());\n   \
    \ int pos = 0;\n    while (lst.at(pos) < lst.at(pos + 1)) {\n        pos++;\n\
    \    }\n    std::optional<long> ret = lst.at(pos + 1);\n    lst.erase(lst.begin()\
    \ + pos + 1);\n    return ret;", "    if (lst.size() == 1) {\n        return lst.front();\n\
    \    }\n    int i = (lst.size() - 1);\n    for (int j = lst.size() - 2; j >= 0;\
    \ j--) {\n        if (lst[j] < lst[j + 1]) {\n            std::swap(lst[j], lst[j\
    \ + 1]);\n            i = j;\n        }\n    }\n    if (i == lst.size() - 2) {\n\
    \        return lst.back();\n    } else {\n        return std::nullopt;\n    }",
  "    int n = lst.size();\n    if(n < 2) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    auto prev = std::max_element(lst.begin(), it);\n    if(prev\
    \ == lst.end()) return std::nullopt;\n    else return *prev;", "    assert(lst.size()\
    \ > 2);\n    int n = lst.size() - 2;\n    if (n < 0) return std::nullopt;\n  \
    \  std::vector<long> lst1 = lst;\n    auto it = std::min_element(lst1.begin()\
    \ + 1, lst1.end());\n    int i = 1;\n    while (i < n) if (*it < lst1[n]) lst1[std::next(it)]\
    \ = lst1[n];\n    else break;\n    return i == n ? std::nullopt : lst1[i + 1];",
  "    auto it = lst.begin();\n    auto next = std::next_element(it);\n    if (next\
    \ == lst.end()) {\n        return std::nullopt;\n    } else {\n        ++it;\n\
    \        return *next;\n    }", "  for (auto it = lst.begin() + 1; it != lst.end();\
    \ ++it) {\n    if (*it < *(it - 1)) {\n      return *it;\n    }\n  }\n  return\
    \ {};", "    // Your code here\n    auto it = lst.begin();\n    auto next = std::next(it);\n\
    \    if (next == lst.end()) {\n        return std::nullopt;\n    }\n\n    if (*next\
    \ < *it) {\n        return *next;\n    }\n\n    do {\n        it++;\n        next\
    \ = std::next(it);\n    } while (next == lst.end() || *next < *it);\n    return\
    \ *next;", "    long min;\n    bool flag=false;\n    for(long i=0;i<lst.size();i++)\
    \ {\n        if(lst[i]<min) {\n            min=lst[i];\n            flag=true;\n\
    \        }\n    }\n    if(flag==true) {\n        return min;\n    }\n    else\
    \ {\n        return std::nullopt;\n    }", "    if (lst.empty()) return std::nullopt;\n\
    \    auto it = lst.begin();\n    auto it = std::min_element(it, lst.end());\n\
    \    if (it == lst.end()) return std::nullopt;\n    return *it;", "    assert(lst.size()\
    \ >= 2);\n    long first = lst[0];\n    long second = lst[1];\n    long third\
    \ = lst[2];\n    for (size_t i = 3; i < lst.size(); ++i) {\n        long cur =\
    \ lst[i];\n        if (cur > first && cur > second) {\n            return cur;\n\
    \        }\n        if (cur > second && cur > third) {\n            return cur;\n\
    \        }\n        if (cur > third) {\n            second = first;\n        \
    \    third = cur;\n            first = cur;\n        }\n    }\n    return std::nullopt;",
  "    auto it=lst.begin();\n    auto it2=lst.begin();\n    if(it==lst.end() || it2==lst.end()){\n\
    \        return std::nullopt;\n    }\n    long mid=*it2++;\n    auto low=it;\n\
    \    while(low!=lst.end() && mid>*low){\n        low++;\n    }\n    long high=it2;\n\
    \    while(high!=lst.end() && mid>*high){\n        high--;\n    }\n    if(low!=lst.end()){\n\
    \        auto it3=lst.begin();\n        while(low!=lst.end()){\n            assert(low!=it3);\n\
    \            if(mid>*low){\n                it3=low;\n            }\n        \
    \    low++;\n        }\n        return *it3;\n    }\n    if(high!=lst.end()){\n\
    \        auto it3=lst.begin();\n        while(high!=lst.end()){\n            assert(high!=it3);\n\
    \            if(mid>*high){\n                it3=high;\n            }\n      \
    \      high--;\n        }\n        return *it3;\n    }\n    return std::nullopt;",
  "    sort(lst.begin(), lst.end());\n    \n    if (lst.size() > 0) {\n        int\
    \ pos = 0;\n        int len = lst.size();\n        std::optional<long> res;\n\
    \        while (pos < len - 1) {\n            if (lst[pos] > lst[pos + 1]) {\n\
    \                res = lst[pos];\n                break;\n            }\n    \
    \        pos++;\n        }\n        return res;\n    } else {\n        return\
    \ std::nullopt;\n    }", "    auto itr = lst.begin();\n    long val = *itr++;\n\
    \    if (itr == lst.end()) return std::nullopt;\n    long smallest;\n    while\
    \ (itr != lst.end() && *itr < val) {\n        smallest = val;\n        val = *itr++;\n\
    \    }\n    return smallest;", "    // Your code here\n    auto begin = lst.begin();\n\
    \    auto end = lst.end();\n    if (begin == end) {\n        return std::nullopt;\n\
    \    }\n    long cur = *begin;\n    bool flag = false;\n    for (auto it = begin\
    \ + 1; it != end; it++) {\n        if (*it < cur) {\n            flag = true;\n\
    \            break;\n        }\n    }\n    if (!flag) {\n        return std::nullopt;\n\
    \    }\n    for (auto it = begin; it != end; it++) {\n        if (*it > cur) {\n\
    \            flag = false;\n            break;\n        }\n    }\n    return cur;",
  "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n\n    int min_index\
    \ = lst.size() - 1;\n\n    // min is initialized to the last element of lst\n\
    \    long min = lst[min_index];\n    // min_index is initialized to the index\
    \ of the last element of lst\n    int min_index = lst.size() - 1;\n\n    for (int\
    \ i = 0; i < lst.size(); i++) {\n        if (lst[i] < min) {\n            // if\
    \ the current element is smaller than the current min\n            min = lst[i];\n\
    \            min_index = i;\n        }\n    }\n\n    // the current min is found\
    \ at index min_index\n    return lst[min_index];", "    // Your code here\n  \
    \  if (lst.size() <= 0) {\n        return std::nullopt;\n    }\n    auto it =\
    \ lst.begin();\n    if (*it > 0) it++;\n    if (it == lst.end()) return std::nullopt;\n\
    \    while (it < lst.end()) {\n        if (*it <= 0) return std::nullopt;\n  \
    \      it++;\n    }\n    return *it;", '  // Your code here', "    int smallest\
    \ = *lst.begin();\n    for (long & i : lst) {\n        if (i < smallest) {\n \
    \           smallest = i;\n        }\n    }\n    if (lst.empty()) {\n        return\
    \ std::nullopt;\n    }\n    for (long & i : lst) {\n        if (i == smallest)\
    \ {\n            return smallest;\n        }\n    }\n    return std::nullopt;",
  "\tif (lst.size() == 0)\n\t\treturn std::nullopt;\n\n\tauto iter = lst.begin();\n\
    \tauto iter2 = lst.begin();\n\twhile (iter != lst.end() && iter2 != lst.end()){\n\
    \t\tif (*iter < *iter2){\n\t\t\t++iter;\n\t\t}\n\t\telse{\n\t\t\t++iter2;\n\t\t\
    }\n\t}\n\tif (iter == lst.end()){\n\t\treturn std::nullopt;\n\t}\n\tif (iter2\
    \ == lst.end()){\n\t\treturn *iter;\n\t}\n\treturn *iter2;", "    // Your code\
    \ here\n    auto it=lst.begin();\n    auto it2=lst.begin();\n    long min=*it2;\n\
    \    long sum=0;\n    long temp=*it;\n    for(it2=lst.begin();it2!=lst.end();it2++)\n\
    \    {\n        sum+=*it2;\n        if(sum==temp)\n        {\n            if(min>temp)\n\
    \            {\n                min=temp;\n            }\n            if(min>*it)\n\
    \            {\n                min=*it;\n            }\n        }\n        sum-=*it;\n\
    \    }\n    return std::optional<long>(min);", "    if (lst.size() == 0)\n   \
    \     return std::nullopt;\n    auto it = lst.begin();\n    ++it;\n    while (it\
    \ != lst.end()) {\n        auto smallest = *it;\n        ++it;\n        if ((*it\
    \ < smallest)) {\n            it = lst.begin();\n            break;\n        }\n\
    \        it = lst.erase(it);\n    }\n    return *it;", "    int low = 0;\n   \
    \ int high = lst.size() - 1;\n    while (low <= high) {\n        int mid = (low\
    \ + high) / 2;\n        if (lst[mid] > lst[high]) {\n            low = mid + 1;\n\
    \        } else {\n            high = mid - 1;\n        }\n    }\n    if (low\
    \ == high) {\n        if (lst.size() > 1) {\n            return lst[low + 1];\n\
    \        }\n        return std::nullopt;\n    }\n    if (lst[low] < lst[high])\
    \ {\n        return lst[low];\n    } else {\n        return lst[high];\n    }",
  "  std::optional<long> min;\n  if (lst.empty()) {\n    return std::nullopt;\n  }\n\
    \  if (lst.size() <= 2) {\n    return min;\n  }\n  auto n = lst.back();\n  lst.pop_back();\n\
    \  if (n > lst.back()) {\n    lst.push_back(n);\n  }\n  min = lst.back();\n  auto\
    \ it = std::adjacent_find(lst.begin(), lst.end());\n  if (it != lst.end()) {\n\
    \    if (n < lst.back()) {\n      lst.pop_back();\n    }\n    if (lst.empty())\
    \ {\n      return std::nullopt;\n    }\n    if (lst.size() <= 2) {\n      return\
    \ min;\n    }\n    it = std::adjacent_find(lst.begin(), lst.end());\n    if (it\
    \ != lst.end()) {\n      min = lst.back();\n    } else {\n      it = std::adjacent_find(lst.begin(),\
    \ lst.end());\n      if (it != lst.end()) {\n        min = lst.back();\n     \
    \ }\n    }\n  }\n  return min;", "    auto it = lst.begin();\n    if (it == lst.end())\
    \ return std::nullopt;\n    auto first = *it++;\n    it = lst.begin();\n    if\
    \ (it == lst.end()) return std::nullopt;\n    auto second = *it++;\n    if (first\
    \ < second) return second;\n    return first;", "\tif (lst.empty())\n\t\treturn\
    \ std::nullopt;\n\tint idx = 0;\n\tbool swap = false;\n\twhile (idx < lst.size()\
    \ - 1) {\n\t\tif (lst.at(idx) < lst.at(idx + 1)) {\n\t\t\t++idx;\n\t\t\tcontinue;\n\
    \t\t}\n\t\tswap = true;\n\t\tbreak;\n\t}\n\tif (swap)\n\t\tstd::iter_swap(lst.begin()\
    \ + idx, lst.end());\n\treturn lst.at(idx + 1);", "  if(lst.empty())\n    return\
    \ std::nullopt;\n  // Initialize min and max with 1st element\n  auto min = lst.front();\n\
    \  auto max = lst.back();\n  \n  for(auto it = lst.begin()+1; it != lst.end();\
    \ ++it)\n  {\n    min = min*10 + std::min(min, (long)*it);\n    max = max*10 +\
    \ std::max(max, (long)*it);\n  }\n  return max == min ? std::nullopt : min;",
  "    std::optional<long> min;\n    long index = 1;\n    while (index < lst.size())\
    \ {\n        if (lst.at(index) > lst.at(index + 1)) {\n            min = lst.at(index);\n\
    \        } else if (lst.at(index) < lst.at(index + 1)) {\n            min = lst.at(index\
    \ + 1);\n        }\n        index++;\n    }\n    return min;", "    if(lst.size()\
    \ == 0) return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    return *it;", "    if (lst.size() < 2)\n        return std::nullopt;\n  \
    \  auto it = lst.begin() + 1;\n    for (size_t i = 0; i < lst.size(); ++i) {\n\
    \        if (*it < *lst)\n            it = lst.begin() + i;\n        else\n  \
    \          break;\n    }\n    return *it;", "    long min_val = std::numeric_limits<long>::max();\n\
    \    std::optional<long> opt_val;\n    for (long elem : lst)\n        if (elem\
    \ < min_val)\n            min_val = elem;\n    else if (elem < min_val + 1)\n\
    \        return opt_val;\n    else\n        opt_val = min_val;\n    return opt_val;",
  "    long minVal = lst[0];\n    long minIndx = 0;\n\n    for (long i = 0; i < lst.size();\
    \ ++i) {\n        if (lst[i] < minVal) {\n            minVal = lst[i];\n     \
    \       minIndx = i;\n        }\n    }\n\n    if (minVal == lst[minIndx])\n  \
    \      return std::nullopt;\n\n    return minIndx;", "  for (int i = 0; i < lst.size();\
    \ i++) {\n    for (int j = i + 1; j < lst.size(); j++) {\n      if (lst[i] < lst[j])\
    \ {\n        auto t = lst[i];\n        lst[i] = lst[j];\n        lst[j] = t;\n\
    \      }\n    }\n  }\n  if (lst.size() == 0) return std::nullopt;\n  return lst[1];",
  "    if (lst.size() == 0)\n        return std::nullopt;\n    auto min_it = lst.begin();\n\
    \    auto second_min_it = lst.begin();\n    for (; min_it != lst.end(); ++min_it,\
    \ ++second_min_it) {\n        if (*min_it < *second_min_it)\n            return\
    \ *min_it;\n    }\n    return *second_min_it;", "    if (lst.empty()) return std::nullopt;\n\
    \    long smallest = *lst.begin();\n    long prev = *lst.begin();\n    for (long\
    \ &el : lst) {\n        if (el < prev) {\n            smallest = el;\n       \
    \ }\n        prev = el;\n    }\n    return smallest;", "    long min_idx = lst.size()\
    \ - 1;\n    long min_val = *lst.rbegin();\n    for (size_t i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] < min_val) {\n            min_val = lst[i];\n   \
    \         min_idx = i;\n        }\n    }\n    if (min_idx == lst.size() - 1) {\n\
    \        return std::nullopt;\n    } else {\n        lst.erase(lst.begin() + min_idx\
    \ + 1);\n        return *lst.rbegin();\n    }", "  // Your code here\n  return\
    \ *std::min_element(std::begin(lst), std::end(lst));", "    bool found = false;\n\
    \    for (long val : lst) {\n        found = found || (val < lst[0]);\n      \
    \  if (found) break;\n    }\n    if (!found) return std::nullopt;\n    return\
    \ lst[std::next(lst.begin(), std::lower_bound(lst.begin(), lst.end(), val) - lst.begin())];"]
stop_tokens:
- "\n}"
