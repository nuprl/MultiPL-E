name: HumanEval_57_monotonic
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return true is vector elements\
  \ are monotonically increasing or decreasing.\n// >>> monotonic((std::vector<long>({(long)1,\
  \ (long)2, (long)4, (long)20})))\n// (true)\n// >>> monotonic((std::vector<long>({(long)1,\
  \ (long)20, (long)4, (long)10})))\n// (false)\n// >>> monotonic((std::vector<long>({(long)4,\
  \ (long)1, (long)0, (long)-10})))\n// (true)\nbool monotonic(std::vector<long> l)\
  \ {\n"
tests: "}\nint main() {\n    auto candidate = monotonic;\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)2, (long)4, (long)10}))) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)2, (long)4, (long)20}))) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)20, (long)4, (long)10}))) == (false));\n    assert(candidate((std::vector<long>({(long)4,\
  \ (long)1, (long)0, (long)-10}))) == (true));\n    assert(candidate((std::vector<long>({(long)4,\
  \ (long)1, (long)1, (long)0}))) == (true));\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)2, (long)5, (long)60}))) == (false));\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5, (long)60}))) == (true));\n    assert(candidate((std::vector<long>({(long)9,\
  \ (long)9, (long)9, (long)9}))) == (true));\n}\n"
completions: ["  if (l.size() < 2) {\n    return false;\n  }\n  long prev = l[0];\n\
    \  for (long i : l) {\n    if (i == prev) {\n      return true;\n    }\n    prev\
    \ = i;\n  }\n  return false;", "    long long int first = l.front();\n    long\
    \ long int last = l.back();\n    int cmp;\n    for (auto el : l) {\n        cmp\
    \ = el - first;\n        if (cmp > 0) {\n            if (last > first)\n     \
    \           return false;\n            first = el;\n        } else if (cmp < 0)\
    \ {\n            if (last < first)\n                return false;\n          \
    \  last = el;\n        } else {\n            // Do nothing\n        }\n    }\n\
    \    return true;", "    // Sorted list is sorted in increasing order. Find minimum\
    \ in sorted list.\n    long min = l[0];\n    for (long &i : l) {\n        if (i\
    \ < min) {\n            min = i;\n        }\n    }\n    long idx = l.size() -\
    \ 1;\n    long &i = l[idx];\n    if (i < min) {\n        // Elements of l are\
    \ in decreasing order.\n        // Find the index with minimum element value in\
    \ l and decrease all other\n        // indices by it.\n        long minIdx = l.size()\
    \ - 1;\n        for (size_t idx = 0; idx < idx; idx++) {\n            long &j\
    \ = l[idx];\n            if (j < min) {\n                minIdx = idx;\n     \
    \       }\n        }\n        for (size_t idx = 0; idx < minIdx; idx++) {\n  \
    \          l[idx] -= i;\n            i = j;\n        }\n        // Check monotonicity\
    \ by adding i to last element. If it's less than last element,\n        // then\
    \ we are done.\n        if (l[idx] + i < min) {\n            return true;\n  \
    \      }\n    }\n    return false;", "    int n = l.size();\n    int m = n;\n\
    \    int i = 0;\n    long long prev = 0;\n    long long cur = 0;\n    long long\
    \ ans = false;\n    while (i < n && m > 0) {\n        prev = cur;\n        cur\
    \ = l[i++];\n        if (prev < cur) {\n            ans = true;\n            m\
    \ = m - 1;\n        } else {\n            m = m - 1;\n        }\n    }\n    if\
    \ (ans) {\n        i = n - 1;\n        prev = 0;\n        cur = l[i++];\n    \
    \    while (i < n && m > 0) {\n            prev = cur;\n            cur = l[i++];\n\
    \            if (prev < cur) {\n                ans = false;\n               \
    \ m = m - 1;\n            } else {\n                m = m - 1;\n            }\n\
    \        }\n    }\n    return ans;", "    long n = l.size();\n    if(n<=1)\n \
    \       return true;\n    long ans = l[0];\n    long i = 1;\n    for(; i<n; i++)\
    \ {\n        long curr = l[i];\n        if(curr < ans)\n            return false;\n\
    \        ans = curr;\n    }\n    return true;", "    int n = l.size();\n    if\
    \ (n == 0)\n        return true;\n    if (n == 1)\n        return l[0] > l[1];\n\
    \    long prev = l[0], curr = l[1], diff;\n    for (int i = 1; i < n - 1; ++i)\
    \ {\n        diff = curr - prev;\n        if (diff == 0)\n            continue;\n\
    \        if (diff > 0)\n            return true;\n        if (diff < 0)\n    \
    \        return false;\n        prev = curr;\n        curr = l[i];\n    }\n  \
    \  return curr > prev;", "  long ans = 0;\n  long n = l.size();\n  assert(n >\
    \ 1);\n  for (long i = 0; i < n - 1; i++) {\n    if (l[i] > l[i + 1]) {\n    \
    \  ans = true;\n      break;\n    }\n  }\n  return ans;", "    // sort vector\
    \ by element value\n    std::sort(l.begin(), l.end(), std::greater<long>());\n\
    \    // find first decreasing element and second decreasing element\n    long\
    \ first = l.front();\n    long last = l.back();\n    // if all elements are decreasing,\
    \ return false\n    if (first > last)\n        return false;\n    // otherwise\
    \ return true if all elements are less than first\n    bool decreasing = true;\n\
    \    for (auto iter = l.begin(); iter != l.end();) {\n        long curr = *iter;\n\
    \        if (curr < first)\n            break;\n        else if (curr > first)\
    \ {\n            decreasing = false;\n            break;\n        }\n        iter\
    \ = l.erase(iter);\n    }\n    return decreasing;", "  int j = 0;\n  long min_value\
    \ = l[0];\n  long max_value = l[0];\n  for (int i = 0; i < l.size(); i++) {\n\
    \    if (l[i] < min_value) {\n      min_value = l[i];\n      j = i;\n    }\n \
    \   if (l[i] > max_value) {\n      max_value = l[i];\n      j = i;\n    }\n  }\n\
    \  return j > 0;", "    int left_idx = -1;\n    int right_idx = l.size()-1;\n\
    \    long curr_elem = l[0];\n    while (right_idx >= left_idx) {\n        int\
    \ mid_idx = right_idx + (left_idx+right_idx)/2;\n        if (curr_elem < l[mid_idx])\
    \ left_idx = mid_idx;\n        else right_idx = mid_idx;\n    }\n    return left_idx\
    \ == right_idx;", "    int n = l.size();\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = i + 1; j < n; j++) {\n            if (l[i] > l[j]) {\n \
    \               return true;\n            }\n        }\n    }\n    return false;",
  "    int size1 = l.size();\n    for (int i = 0; i < size1; ++i) {\n        int size2\
    \ = size1;\n        for (int j = i + 1; j < size2; ++j) {\n            if (l[j]\
    \ > l[i]) {\n                swap(l[i], l[j]);\n            }\n        }\n   \
    \ }\n    return (std::is_sorted(l.begin(), l.end(), [](long a, long b) { return\
    \ a > b; }));", "    assert(l.size() > 0);\n    long a = l[0];\n    for (size_t\
    \ i = 1; i < l.size(); i++) {\n        if (l[i] > a) return true;\n        if\
    \ (l[i] < a) return false;\n    }\n    return false;", "  std::pair<long, long>\
    \ p = std::min_element(l.begin(), l.end());\n  return p.second < p.first;", " \
    \   long prev = l[0];\n    bool flag = false;\n    for (long int x : l) {\n  \
    \      if (prev > x) {\n            flag = true;\n            break;\n       \
    \ }\n        prev = x;\n    }\n    return flag;", "    long ans = std::numeric_limits<long>::max();\n\
    \    long l = l.size();\n    for(int i = 0;i < l;i++) {\n        if(ans >= l[i])\n\
    \            ans++;\n        else\n            return false;\n    }\n    return\
    \ true;", "    if(l.size() < 2) return false;\n    long ans = l[0];\n    for(long\
    \ i = 1; i < l.size(); i++) {\n        if(l[i] < ans) return false;\n        ans\
    \ = l[i];\n    }\n    return true;", "    if(l.size() == 0 || l.size() == 1) return\
    \ true;\n    long cur = l.at(0); // current value of the vector\n    long prev\
    \ = l.at(0); // previous value of the vector\n    for(long i = 1; i < l.size();\
    \ i++) { // iterate through the vector\n        if(prev > l[i]) {\n          \
    \  prev = l[i];\n        } \n    }\n    bool result = true;\n    for(long i =\
    \ 0; i < l.size(); i++) { // iterate through the vector\n        if(cur < l[i])\
    \ {\n            result = false;\n            break;\n        }\n    }\n    return\
    \ result;", "  if (l.size() <= 1) {\n    return true;\n  }\n\n  auto last_el =\
    \ l.back();\n\n  bool decreasing = false;\n  for (auto el : l) {\n    if (el <\
    \ last_el) {\n      decreasing = true;\n      break;\n    }\n\n    last_el = el;\n\
    \  }\n  return decreasing;", "  if (l.size() == 0) return false;\n\n  long prev\
    \ = l[0];\n  bool first = true;\n\n  for (long i = 1, j = l.size() - 1; i < j;\
    \ ++i, --j) {\n    if (l[i] <= prev) {\n      if (first) {\n        prev = l[i];\n\
    \        first = false;\n      } else {\n        // The vector is not monotonic!\n\
    \        return false;\n      }\n    }\n  }\n  return true;", "    int j = 0;\n\
    \    long k = l[0], n = 1;\n    for (int i = 1; i < l.size(); i++) {\n       \
    \ if (l[i] > k)\n            j++;\n        else if (l[i] < k)\n            j--;\n\
    \        else\n            j = 0;\n        k = l[i];\n        n = n * j;\n   \
    \ }\n    return n == 0;", "    if (l.size() < 2) return true;\n    // First compare\
    \ first and last element of vector\n    if (l[0] < l[l.size()-1]) return false;\n\
    \    // Now compare each element to find increasing or decreasing sequence\n \
    \   for (long i = 1; i < l.size(); i++) {\n        if (l[i-1] > l[i]) return false;\n\
    \    }\n    return true;", "  if (l.size() == 0) {\n    return true;\n  }\n  //\
    \ if first element is less than all others, it must be monotonically\n  // decreasing\n\
    \  if (l[0] < l[1]) {\n    return false;\n  }\n  // find first element greater\
    \ than or equal to all others\n  size_t pos = 0;\n  for (size_t i = 2; i < l.size();\
    \ i++) {\n    if (l[i] <= l[pos]) {\n      // if current element is greater than\
    \ all others, it is monotonically\n      // decreasing\n      return false;\n\
    \    }\n    pos = i;\n  }\n  // if current element is greater than all others,\
    \ it is monotonically\n  // decreasing\n  return true;", "  auto it1 = l.begin();\n\
    \  auto it2 = l.begin();\n  for (; it1 < l.end() - 1; it2++) {\n    if (it1 ==\
    \ it2) {\n      return false;\n    }\n    if (*it1 < *it2) {\n      return false;\n\
    \    }\n  }\n  return true;", "\tif (l.empty())\n\t\treturn false;\n\t// Find\
    \ max element\n\tlong max = l[0];\n\tfor (long elem : l) {\n\t\tif (elem > max)\n\
    \t\t\tmax = elem;\n\t}\n\tlong pre = l[0];\n\t// Compare with previous max element\n\
    \tfor (long elem : l) {\n\t\tif (elem < pre)\n\t\t\treturn false;\n\t}\n\treturn\
    \ true;", "  int res = 0;\n  for (int i = 0; i < l.size(); i++) {\n    if (l[i]\
    \ < l[i - 1]) {\n      res = 1;\n      break;\n    } else if (l[i] > l[i - 1])\
    \ {\n      res = -1;\n      break;\n    }\n  }\n  if (res == 1) {\n    return\
    \ true;\n  } else {\n    return false;\n  }", "    auto x = l.front();\n    auto\
    \ y = l.back();\n    for (auto itr = l.begin() + 1; itr != l.end(); ++itr) {\n\
    \        if ((*itr) <= y) {\n            return false;\n        }\n        if\
    \ ((*itr) < x) {\n            return true;\n        }\n    }\n    return false;",
  "    int i{0};\n    int j{0};\n    for (auto it=l.begin();it!=l.end();++it){\n \
    \       if(i<j)\n            return false;\n        if (it<l.begin())\n      \
    \      return true;\n        if (it>l.end())\n            return true;\n     \
    \   ++i;\n        ++j;\n    }\n    return false;", "  int size = l.size();\n \
    \ for (int i = 1; i < size; ++i) {\n    if (l[i] < l[i - 1]) {\n      return false;\n\
    \    }\n  }\n  return true;", "  if (l.size() < 2) {\n    return false;\n  }\n\
    \  long min_val = l[0];\n  for (long i : l) {\n    if (i > min_val) {\n      return\
    \ true;\n    }\n    min_val = i;\n  }\n  return false;", "  int n = l.size();\n\
    \  for (int i = 1; i < n; i++) {\n    if (l[i] - l[i - 1] < 1) return false;\n\
    \  }\n  return true;", '    return std::adjacent_difference(l.begin(), l.end(),
    l.begin()) != l.end();', "    long prevVal = l.front();\n    long curVal = l.back();\n\
    \    if (prevVal != curVal) {\n        // We are moving from larger to smaller\n\
    \        // Therefore we return true if current element\n        // is greater\
    \ than the last element (largest)\n        return curVal > prevVal;\n    }\n\n\
    \    // We are moving from smaller to larger\n    // Therefore we return true\
    \ if current element\n    // is lesser than the previous element\n    return curVal\
    \ < prevVal;", "    int n = l.size();\n    if (n == 0)\n        return true;\n\
    \    if (n == 1) {\n        if (l[0] < l[1])\n            return false;\n    \
    \    return true;\n    }\n    for (int i = 1; i < n; i++) {\n        if (l[i -\
    \ 1] >= l[i])\n            return false;\n    }\n    return true;", "  int n =\
    \ l.size();\n  if (n <= 1)\n    return true;\n  long prev = l[0];\n  for (int\
    \ i = 1; i < n; i++) {\n    if (l[i] < prev)\n      return false;\n    prev =\
    \ l[i];\n  }\n  return true;", "\tif (l.size() == 0)\n\t\treturn false;\n\n\t\
    long first = l.at(0); // first element\n\tlong last = first;\n\tlong count = 1;\n\
    \tfor (size_t i = 0; i < l.size(); i++) {\n\t\tif (l[i] > last) {\n\t\t\tlast\
    \ = l[i];\n\t\t\tcount++;\n\t\t}\n\t}\n\n\t// if count is decreasing, then first\
    \ is decreasing\n\treturn (count < 2) && (first > last);", "    int size2 = l.size();\n\
    \    for (int i = 0; i < size2; i++) {\n        int j = i + 1;\n        while\
    \ (j < size2) {\n            if (l[i] > l[j]) {\n                return false;\n\
    \            }\n            j = j + 1;\n        }\n    }\n    return true;", " \
    \   assert(!l.empty());\n    // Find the first element and make sure it's greater\
    \ than all others.\n    auto it = std::lower_bound(l.begin(), l.end(), l.front());\n\
    \    // If first is greater, the rest must be monotonic in order to\n    // decrease\
    \ to first. Otherwise, it's already true.\n    return it == l.begin() || l[it\
    \ - 1] > l[0];", "    // initialize minimum to INT_MAX\n    long m = INT_MAX;\n\
    \    // initialize maximum to INT_MIN\n    long M = INT_MIN;\n    // Initialize\
    \ number of elements in list\n    int n = l.size();\n    // Iterate through all\
    \ elements\n    for(long i = 1; i < n; i++) {\n        // Iterate through all\
    \ elements in list\n        for(long j = i; j > 0; j--) {\n            // If the\
    \ current element is greater than the minimum, set minimum to the current element\n\
    \            if(l[i] > m) m = l[i];\n            // If the current element is\
    \ smaller than the maximum, set maximum to the current element\n            if(l[i]\
    \ < M) M = l[i];\n        }\n    }\n    // Return true if list elements are monotonically\
    \ increasing or decreasing\n    return m >= M;", "    long max = std::numeric_limits<long>::min();\n\
    \    long min = 0;\n    for (auto& i : l) {\n        if (i > max) max = i;\n \
    \       if (i < min) min = i;\n    }\n    if (max <= min) return true;\n    return\
    \ false;", "    auto it = std::max_element(l.begin(), l.end()) - l.begin();\n\
    \    long long a = *(it);\n    long long b = *(--l.end());\n    return (a <= b);",
  "  // vector start from 0\n  int start = 0;\n  int end = l.size();\n  // compare\
    \ the second element\n  int cmp = l[start] - l[end];\n  // if the first two elements\
    \ are the same\n  if (cmp == 0 && start < end) {\n    return true;\n  }\n  //\
    \ if the first two elements are not the same\n  if (cmp > 0) {\n    return false;\n\
    \  }\n  // if first two elements are the same\n  start = end;\n  // compare the\
    \ third element\n  cmp = l[start] - l[end];\n  // if the third elements are the\
    \ same\n  if (cmp == 0 && start < end) {\n    return true;\n  }\n  // if the third\
    \ elements are not the same\n  if (cmp > 0) {\n    return false;\n  }\n  // if\
    \ first two elements are the same\n  start = end;\n  // compare the fourth element\n\
    \  cmp = l[start] - l[end];\n  // if the fourth elements are the same\n  if (cmp\
    \ == 0 && start < end) {\n    return true;\n  }\n  // if the fourth elements are\
    \ not the same\n  if (cmp > 0) {\n    return false;\n  }\n  // if all elements\
    \ are the same\n  return false;", "    if (l.size() < 2) return false;\n    int\
    \ x = l[0];\n    int y = l[1];\n    bool flag = false;\n    for (int i = 1; i\
    \ < l.size(); i++) {\n        if (x > l[i]) x = l[i];\n        if (x < l[i]) y\
    \ = l[i];\n        if (y == l[i]) {\n            flag = true;\n        }\n   \
    \ }\n    return flag;", "    std::sort(l.begin(), l.end());\n    return l.front()\
    \ == l.back() && l.size() > 1;", "    long long max = std::numeric_limits<long\
    \ long>::max();\n    long long min = std::numeric_limits<long long>::min();\n\
    \    for (auto i : l) {\n        if (i == max) {\n            return true;\n \
    \       }\n        if (i == min) {\n            return false;\n        }\n   \
    \ }\n    return false;", "    // Initialize result with first element\n    long\
    \ first = l.at(0);\n    bool result = true;\n    // Iterate through remaining\
    \ elements\n    for (int i = 1; i < l.size(); i++) {\n        long current = l.at(i);\n\
    \        // If current element is greater than first element then return false\n\
    \        if (current < first) return false;\n        // Else update result to\
    \ check if current element is lesser than previous\n        first = current;\n\
    \    }\n    // Return result to indicate if vector is monotonic\n    return result;",
  "    long curr = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        long\
    \ next = l[i];\n        if (curr > next) {\n            return true;\n       \
    \ }\n        curr = next;\n    }\n    return false;", "\tif (l.size() < 2) {\n\
    \t\treturn false;\n\t}\n\t// sort vector to determine if it is increasing\n\t\
    sort(l.begin(), l.end());\n\tlong a = l[0];\n\tlong b = l[1];\n\tif (a < b) {\n\
    \t\treturn true;\n\t}\n\treturn false;", "  std::vector<bool> v(l.size());\n \
    \ std::iota(v.begin(), v.end(), true);\n  std::stable_sort(v.begin(), v.end(),\
    \ [&l](int i, int j){\n    return l[j] > l[i];\n  });\n  for (auto i=l.size()-1;\
    \ i>0; --i) {\n    if (v[i-1]) v[i-v[i-1]] = false;\n  }\n  return v[0];", " \
    \ if (l.size() == 0) return false;\n  std::sort(l.begin(), l.end());\n  if (l[0]\
    \ == l[l-1]) return false;\n  return true;", "    long long a = l[0], b = l[1],\
    \ c = l[2], d = l[3];\n    long long mid = a + (b - a) / 2;\n    if (c > mid)\
    \ {\n        if (d > mid) {\n            if (d > mid)\n                return\
    \ monotonic({c, d, b, a});\n            else\n                return monotonic({c,\
    \ d, a, mid});\n        } else {\n            if (c > mid)\n                return\
    \ monotonic({c, mid, b, a});\n            else\n                return monotonic({c,\
    \ mid, a, mid});\n        }\n    } else {\n        if (b > mid) {\n          \
    \  if (c > mid)\n                return monotonic({c, mid, b, a});\n         \
    \   else\n                return monotonic({c, mid, a, mid});\n        } else\
    \ {\n            if (b > mid)\n                return monotonic({mid, b, a, c});\n\
    \            else\n                return monotonic({mid, a, c, b});\n       \
    \ }\n    }", "  // Get max and min of first two elements.\n  long maxElem = std::max(l[0],\
    \ l[1]);\n  long minElem = std::min(l[0], l[1]);\n\n  // Check if max and min\
    \ elements are same.\n  if (maxElem == minElem)\n    return true;\n\n  // Check\
    \ if max and min elements are different.\n  bool decreasing = true;\n  for (int\
    \ i = 2; i < l.size(); i++) {\n    if (l[i] == minElem)\n      minElem = l[i];\n\
    \    else if (l[i] == maxElem)\n      maxElem = l[i];\n    else if (l[i] > maxElem)\n\
    \      decreasing = false;\n    else if (l[i] < minElem)\n      decreasing = true;\n\
    \  }\n\n  return decreasing;", "    int n = l.size();\n    for (int i = 1; i <\
    \ n; i++) {\n        if (l[i] < l[i - 1]) {\n            return false;\n     \
    \   }\n    }\n    return true;", "    long long maxVal = *max_element(l.begin(),\
    \ l.end());\n    for (auto el : l) {\n        if (el < 0 && maxVal >= el)\n  \
    \          return false;\n        else if (el > 0 && maxVal <= el)\n         \
    \   return false;\n        maxVal = el;\n    }\n    return true;", "  std::sort(l.begin(),\
    \ l.end());\n  return std::equal(l.begin(), l.end(), l.begin(), [](long l, long\
    \ r) { return l > r; });", "  if (l.empty())\n    return true;\n  std::pair<long,\
    \ long> min_v = *std::min_element(l.begin(), l.end());\n  long min_i = l.find_first_of(min_v.first);\n\
    \  long max_i = l.find_last_of(min_v.first);\n  return std::all_of(l.begin() +\
    \ min_i + 1, l.begin() + max_i, [](long i) { return i >= min_v.second; });", " \
    \   std::sort(l.begin(), l.end());\n    return std::is_sorted(l.begin(), l.end());",
  "    if (l.size() == 0) return false;\n    bool ret = l[0] > l[1];\n    long mid\
    \ = l[0] + l[1] / 2;\n    for (size_t i = 2; i < l.size(); ++i) {\n        ret\
    \ = ret || l[i] > mid;\n        mid = l[i] + mid / 2;\n    }\n    return ret;",
  "    int n = l.size();\n    if (n == 0)\n        return true;\n    if (n == 1)\n\
    \        return false;\n    long max = l[0];\n    for (int i = 1; i < n; i++)\
    \ {\n        if (l[i] > max)\n            max = l[i];\n    }\n    if (max <= 0)\n\
    \        return true;\n    long min = l[0];\n    for (int i = 1; i < n; i++) {\n\
    \        if (l[i] < min)\n            min = l[i];\n    }\n    if (min >= 0)\n\
    \        return false;\n    for (int i = 1; i < n; i++) {\n        if (l[i] >\
    \ min)\n            return false;\n        if (l[i] < max)\n            return\
    \ false;\n    }\n    return true;", "    // Find maximum element.\n    long maxVal\
    \ = std::accumulate(l.begin(), l.end(), 0);\n    // Find the smallest element.\n\
    \    long minVal = l.front();\n    for (int i = 1; i < l.size(); ++i) {\n    \
    \    if (l[i] > maxVal) {\n            maxVal = l[i];\n        }\n        if (l[i]\
    \ < minVal) {\n            minVal = l[i];\n        }\n    }\n    return maxVal\
    \ > minVal;", "    long prevVal = std::numeric_limits<long>::min();\n    bool\
    \ isMonotonic = true;\n    for (long i = 0; i < l.size() - 1; i++) {\n       \
    \ long diff = l[i + 1] - prevVal;\n        if (diff != 0)\n            isMonotonic\
    \ = false;\n        prevVal = l[i];\n    }\n    return isMonotonic;", "  long\
    \ x = 0;\n  long y = 0;\n  for (auto & elem : l) {\n    y += elem;\n    x = std::min(std::max(x,y),\
    \ x);\n  }\n  return x == y;", "    std::vector<std::pair<long, long>> v(l.size());\n\
    \    long curr = 0, prev = 0;\n    for (long i = 0; i != l.size(); ++i) {\n  \
    \      v[i].first = l[i];\n        v[i].second = prev;\n        prev = curr;\n\
    \        curr = v[i].first;\n    }\n    long max_val = prev;\n    for (long i\
    \ = 0; i != l.size(); ++i) {\n        if (v[i].first > max_val) {\n          \
    \  max_val = v[i].first;\n        }\n    }\n    return max_val >= 0;", "    long\
    \ a = l[0];\n    for (long i : l)\n        if (a != i)\n            return false;\n\
    \    return true;", "    if (l.size() == 0)\n        return false;\n    // If\
    \ first two values are same, return true\n    if (l.front() == l.back())\n   \
    \     return true;\n    // If all elements are same, return true\n    if (l.front()\
    \ == l.back())\n        return true;\n\n    long first = l.front();\n    long\
    \ last = l.back();\n\n    // If first value is increasing then set last as second\
    \ last and return\n    if (first > last)\n        return false;\n    // If last\
    \ value is increasing then set first as second first and return\n    if (last\
    \ > first)\n        return false;\n\n    // If first value is decreasing then\
    \ set last as second last and return\n    if (first < last)\n        return false;\n\
    \    // If last value is decreasing then set first as second first and return\n\
    \    if (last < first)\n        return false;\n\n    long second_last = l.back();\n\
    \    // If second last is increasing then set first as second last and return\n\
    \    if (second_last > last)\n        return false;\n    // If second last is\
    \ decreasing then set first as second first and return\n    if (second_last <\
    \ first)\n        return false;\n\n    // If all elements are same then return\
    \ true\n    return true;", "  std::sort(l.begin(), l.end());\n  return l.front()\
    \ == l.back();", "    long long ll = std::accumulate(l.begin(), l.end(), 0);\n\
    \    long long lm = std::max(l.begin(), l.end());\n    long long lmm = std::min(l.begin(),\
    \ l.end());\n    return (ll == lm) || (ll == lmm);", "\tif (l.size() == 1) {\n\
    \t\treturn true;\n\t}\n\tlong long max = std::max(l[0], l[1]);\n\tlong long min\
    \ = std::min(l[0], l[1]);\n\treturn max == min;", "    long n = l.size();\n  \
    \  long prev = l[0];\n    long curr = prev;\n    for (int i = 1; i < n; ++i) {\n\
    \        if (curr > l[i]) {\n            return false;\n        }\n        curr\
    \ = l[i];\n    }\n    return true;", "\tlong first = max(l.begin(), l.end());\n\
    \tlong last = min(l.begin(), l.end());\n\tlong count = 0;\n\tfor (long i = first;\
    \ i <= last; i++) {\n\t\tcount++;\n\t\tif (count == 1) break;\n\t}\n\tassert(count\
    \ == l.size());\n\treturn first != last;", "    int i, mid, n, k;\n    long min,\
    \ max = 0;\n    n = l.size();\n    k = n % 2; // Even n means decreasing else\
    \ increasing\n    bool isIncreasing = false;\n    for (i = 2; i <= n && i < n\
    \ / 2; i++) {\n        mid = (i + n) / 2;\n        min = l[mid];\n        max\
    \ = l[mid];\n        if (min > max) {\n            if (min < mid) {\n        \
    \        isIncreasing = true;\n            }\n        }\n        else {\n    \
    \        if (min > mid) {\n                isIncreasing = false;\n           \
    \ }\n        }\n    }\n    return (isIncreasing ^ k);", "  // Sort the input vector\n\
    \  std::sort(l.begin(), l.end());\n  // Find index of largest element and smallest\
    \ element\n  int max_idx = 0;\n  int min_idx = 0;\n  // If min and max element\
    \ are same, then vector is sorted\n  if (l[min_idx] == l[max_idx])\n    return\
    \ true;\n  // Iterate over the vector, finding the min and max elements\n  for\
    \ (int i = 0; i < l.size(); i++) {\n    if (l[i] > l[max_idx]) {\n      max_idx\
    \ = i;\n    }\n    if (l[i] < l[min_idx]) {\n      min_idx = i;\n    }\n  }\n\
    \  // Return true if the difference between the min and max elements is greater\
    \ than 1\n  return max_idx - min_idx > 1;", "    if(l.size() == 1) return false;\n\
    \    long first = l.front();\n    if(first == l[0]) return true;\n    for(long\
    \ i = 1; i < l.size(); ++i) {\n        if(l[i] > first) return false;\n    }\n\
    \    return true;", "    if(l.size() < 2) {\n        return false;\n    }\n  \
    \  long long min = l[0], max = l[0];\n    for(int i = 1; i < l.size(); ++i) {\n\
    \        if(l[i] < min) min = l[i];\n        if(l[i] > max) max = l[i];\n    }\n\
    \    if(min > max) return false;\n    if(max < l[0]) return false;\n    for(auto\
    \ e : l) {\n        if(e > l[l.size() - 1]) return false;\n    }\n    return true;",
  "    long s = std::accumulate(l.begin(), l.end(), 0ll);\n    return s == 0ll;",
  "    assert(l.size() > 0);\n    auto begin = l.begin();\n    auto end = l.end();\n\
    \    auto cur = std::next(begin, 0);\n    bool increasing = true;\n    bool decreasing\
    \ = true;\n    while (cur < end) {\n        if (cur[0] == cur[1]) {\n        \
    \    cur++;\n            continue;\n        }\n        if (cur[0] < cur[1]) {\n\
    \            increasing = false;\n        } else if (cur[0] > cur[1]) {\n    \
    \        decreasing = false;\n        }\n        break;\n    }\n    return increasing\
    \ || decreasing;", "    int n = l.size();\n    int m = INT_MAX / n;\n    std::vector<bool>\
    \ v(n);\n    for (int i = 0; i < n; i++) {\n        v[i] = l[i] < m;\n    }\n\
    \    std::vector<bool>::iterator it;\n    for (int i = 0; i < n; i++) {\n    \
    \    for (it = v.begin() + i + 1; it != v.end(); it++) {\n            if (*it)\
    \ {\n                break;\n            }\n        }\n        if (i == n / 2)\
    \ {\n            return false;\n        }\n    }\n    return true;", "    long\
    \ first = l[0];\n    bool flag = true;\n    for (long val : l) {\n        if (val\
    \ < first)\n            flag = false;\n    }\n    return flag;", "  long long\
    \ a = 0;\n  long long b = 0;\n  long long c = 0;\n  for (int i = 0; i < l.size();\
    \ i++) {\n    if (l[i] > b) b = l[i];\n    if (l[i] < c) c = l[i];\n    long long\
    \ d = b - c;\n    if (d >= a + (c - b)) {\n      a = d;\n    }\n  }\n  return\
    \ a >= b;", "    if (l.size() < 2) return false;\n    // Initialize min and max\
    \ values.\n    long minV = l[0], maxV = l[0];\n    for (long i = 1; i < l.size();\
    \ ++i) {\n        if (minV > l[i]) minV = l[i];\n        if (maxV < l[i]) maxV\
    \ = l[i];\n    }\n    if (maxV - minV >= 1) return false;\n    // If any values\
    \ are equal, sort ascending by value.\n    if (minV == l[0]) return false;\n \
    \   return !std::is_sorted(l.begin(), l.end(), [](long i, long j){ return (i <\
    \ j); });", "    long a = l[0];\n    long b = l[1];\n    long c = l[2];\n    long\
    \ d = l[3];\n    long x = a;\n    long y = b;\n    long yl = b;\n    bool y =\
    \ false;\n    bool y1 = false;\n    bool yr = false;\n\n    if (a != b) {\n  \
    \      y = false;\n    }\n    if (b != c) {\n        y = false;\n    }\n    if\
    \ (a != d) {\n        y1 = false;\n    }\n    if (b != d) {\n        y1 = false;\n\
    \    }\n    if (c != d) {\n        yr = false;\n    }\n    if (x == a) {\n   \
    \     yl = c;\n    }\n    if (x == b) {\n        yl = d;\n    }\n    if (x ==\
    \ c) {\n        yl = b;\n    }\n    if (x == d) {\n        yl = a;\n    }\n  \
    \  if (y == y1) {\n        yr = true;\n    }\n    if (y == yr) {\n        yr =\
    \ false;\n    }\n    if (y == false) {\n        return false;\n    }\n    return\
    \ true;", "    // The vector is assumed to be sorted.\n    // A monotonically\
    \ increasing vector is one where the elements are\n    // always increasing up\
    \ to the current element.\n    // A monotonically decreasing vector is one where\
    \ there is an\n    // always decreasing element at the end.\n    // A monotonically\
    \ increasing or decreasing vector is always one of\n    // the two situations.\n\
    \    long long i = l[0];\n    for (long long j = 1; j < l.size(); ++j) {\n   \
    \     if (l[j] <= i) {\n            return false;\n        }\n        i = l[j];\n\
    \    }\n    return true;", "    long last = l.back();\n    for (long i : l) {\n\
    \        if (i <= last) {\n            return false;\n        }\n        last\
    \ = i;\n    }\n    return true;", "\tfor(long i = 1; i < l.size() && l[i] < l[i-1];\
    \ i++) {}\n\treturn i == l.size() || l[i] < l[i-1];", "  std::sort(l.begin(),\
    \ l.end());\n  return l.front() == l.back();", "  int size = l.size();\n  if (size\
    \ < 3)\n    return false;\n  if (size % 2 == 0)\n    return false;\n  int start\
    \ = 0;\n  int end = size - 1;\n  while (end > start) {\n    int m = (end + start)\
    \ / 2;\n    if (l[m] <= l[start] && l[m] <= l[end])\n      start = m + 1;\n  \
    \  else if (l[m] > l[start] && l[m] > l[end])\n      end = m - 1;\n    else\n\
    \      return false;\n  }\n  return l[start] <= l[end];", "    long smallest =\
    \ std::min_element(l.begin(), l.end());\n    long largest = std::max_element(l.begin(),\
    \ l.end());\n\n    if (smallest > largest)\n        return true;\n    return false;",
  "    if (l.size() < 3) return true;\n    if (l[0] > l[1]) return true;\n    if (l[1]\
    \ < l[2]) return true;\n    if (l[0] == l[2]) return true;\n\n    if (l[0] > l[1])\
    \ {\n        if (l[2] > l[3]) return true;\n        if (l[3] > l[2]) return true;\n\
    \    }\n    return false;", "    auto it = l.begin();\n    for(auto it = l.begin();\
    \ it != l.end(); it++) {\n        if(*it >= *it - 1) {\n            return true;\n\
    \        }\n    }\n    return false;", "\tauto it = l.begin();\n\tlong long min\
    \ = *it;\n\tlong long max = min;\n\tit++;\n\tfor (; it != l.end(); it++) if (*it\
    \ > max) return false;\n\treturn true;", "    long long a = 0, b = 0;\n    long\
    \ long count = 1;\n    for (long long x : l) {\n        if (x < a) return false;\n\
    \        if (x > b) return false;\n        b += x;\n        count += 1;\n    }\n\
    \    a = b;\n    b = b;\n    bool ret = true;\n    long long sum = 0;\n    for\
    \ (long long i = 0; i <= count; i++) {\n        sum += i;\n        if (sum > count)\
    \ {\n            ret = false;\n        }\n    }\n    return ret;", "  for (long\
    \ i = l.size() - 1; i > 0; i--) {\n    if (l[i] < l[i - 1]) {\n      return false;\n\
    \    }\n  }\n  return true;", "  std::sort(l.begin(), l.end());\n  for (auto it1\
    \ = l.begin(); it1 < l.end(); ++it1)\n    if (*it1 >= *it1) return false;\n  return\
    \ true;", "    int low = 0;\n    int high = l.size()-1;\n    int mid = 0;\n  \
    \  while (low <= high) {\n        mid = (low+high)/2;\n        if (l[mid] < l[mid+1])\
    \ high = mid+1;\n        else if (l[mid] > l[mid+1]) low = mid+1;\n        else\
    \ return true;\n    }\n    return false;", "    auto it = l.begin();\n    auto\
    \ end = l.end();\n    ++it;\n    for (; it != end; ++it)\n        if ((*it) <\
    \ (*--end))\n            return true;\n    return false;", "  auto x = l[0], y\
    \ = l[0], z = l[0];\n  for (auto i : l) {\n    if (y < i || x == i) {\n      x\
    \ = i;\n      y = i;\n    } else {\n      z = i;\n    }\n  }\n  return x == z;",
  "    long long current = l.front();\n    bool is_increasing = true;\n    for (long\
    \ long n : l) {\n        if (n <= current)\n            is_increasing = false;\n\
    \        if (n > current)\n            current = n;\n    }\n    return is_increasing;",
  "    bool ret = false;\n    int i = 0;\n    while (i < l.size()) {\n        // if\
    \ first element of pair is greater than second element in pair\n        if (l[i]\
    \ >= l[i + 1]) {\n            // swap both elements\n            auto j = i;\n\
    \            i--;\n            std::swap(l[i], l[j]);\n            ret = true;\n\
    \        } else {\n            i++;\n        }\n    }\n    return ret;", "   \
    \ int len = l.size();\n    if (len < 2) return false;\n    int maxv = l[0], minv\
    \ = l[0];\n    for (int i = 1; i < len; i++) {\n        if (l[i] > maxv) return\
    \ false;\n        if (l[i] < minv) return false;\n    }\n    return true;", " \
    \ // Sort from small to large.\n  std::sort(l.begin(), l.end(), [](long a, long\
    \ b) {\n    return a > b;\n  });\n  if (l.front() <= l.back()) {\n    return true;\n\
    \  } else {\n    return false;\n  }", "    long a = l[0], b = l[1];\n    bool\
    \ c = false;\n    for (auto i : l) {\n        if (b < i) {\n            a = i;\n\
    \            b = i;\n        } else {\n            c = true;\n        }\n    }\n\
    \    if (c == true)\n        return true;\n    return false;", "    // Get max\
    \ and min elements.\n    long max_value = std::numeric_limits<long>::max();\n\
    \    long min_value = std::numeric_limits<long>::min();\n    for (auto &elem :\
    \ l){\n        if (elem > max_value)\n            max_value = elem;\n        if\
    \ (elem < min_value)\n            min_value = elem;\n    }\n\n    if (max_value\
    \ < min_value)\n        return false;\n    // If the max is less than the min,\
    \ swap them.\n    if (max_value < 0)\n        max_value = -max_value;\n\n    return\
    \ true;", "  if (l.size() == 1) {\n    return true;\n  }\n  std::unordered_map<long,\
    \ long> mp;\n  std::unordered_set<long> s;\n  for (long i : l) {\n    mp[i] =\
    \ i;\n    s.insert(i);\n  }\n  for (long i = 0; i < l.size() - 1; ++i) {\n   \
    \ if (mp[s[i]] < mp[s[i + 1]]) {\n      return false;\n    }\n  }\n  return true;",
  "    for (auto i = 1; i < l.size(); i++) {\n        if (l[i] > l[i - 1]) return\
    \ true;\n    }\n    return false;", "    assert(l.size() > 0);\n    std::vector<long>\
    \ curr = l;\n    bool increasing = true;\n    do {\n        increasing = false;\n\
    \        for (auto c : curr) {\n            if (c < curr[0]) {\n             \
    \   increasing = true;\n                break;\n            }\n        }\n   \
    \     if (!increasing) break;\n        std::swap(curr[0], curr[curr.size()-1]);\n\
    \        curr.pop_back();\n    } while (true);\n    return increasing;", "  if\
    \ (l.size() < 2) return false;\n  long m = l[0];\n  for (long i = 1; i < l.size();\
    \ i++) {\n    if (l[i] < m)\n      return false;\n    else if (l[i] > m)\n   \
    \   return true;\n    m = l[i];\n  }\n  return false;", "  if (l.size() < 2) return\
    \ false;\n  long min = l[0], max = l[0];\n  for (long i : l) {\n    if (i < min)\
    \ return false;\n    if (i > max) return false;\n    min = max;\n    max = i;\n\
    \  }\n  return true;", "    assert(l.size() >= 2);\n    long first = l[0];\n \
    \   long last = l[l.size()-1];\n    long mid = first + (last-l)/2;\n    for(long\
    \ i = 0; i < l.size()-1; i++) {\n        if(l[i+1] < mid)\n            return\
    \ false;\n        else if(l[i] > mid)\n            return true;\n    }\n    return\
    \ false;", "  // Sort vector l\n  std::sort(l.begin(), l.end());\n\n  // Find\
    \ lowest element of left side of current range\n  // If leftSideOfCurrentRange\
    \ < leftSideOfCurrentRange_2, then current range is increasing\n  long leftSideOfCurrentRange\
    \ = l[l.size() - 1];\n\n  // Find right side of current range\n  // If rightSideOfCurrentRange\
    \ > rightSideOfCurrentRange_2, then current range is decreasing\n  long rightSideOfCurrentRange\
    \ = l[0];\n\n  // Check for monotonicity of increasing or decreasing vector\n\
    \  while (rightSideOfCurrentRange != leftSideOfCurrentRange) {\n    leftSideOfCurrentRange\
    \ = l[l.size() - 1];\n    rightSideOfCurrentRange = l[0];\n  }\n\n  // If vector\
    \ is monotonic increasing, return true\n  if (leftSideOfCurrentRange < rightSideOfCurrentRange)\
    \ return true;\n\n  // If vector is monotonic decreasing, return true\n  if (leftSideOfCurrentRange\
    \ > rightSideOfCurrentRange) return false;\n\n  // If vector is monotonic and\
    \ same, return true\n  return true;", "    long i = 0;\n    bool flag = true;\n\
    \    for (auto x : l) {\n        if (i == 0) {\n            i = x;\n         \
    \   continue;\n        }\n        if (x < i) {\n            flag = false;\n  \
    \          break;\n        }\n        i += 1;\n    }\n    return flag;", "   \
    \ auto it = l.begin();\n    auto last = l.end();\n    \n    auto increasing =\
    \ [&it, &last](long l) {\n        return l > last && *it > l;\n    };\n    auto\
    \ decreasing = [&it, &last](long l) {\n        return l > last && *it < l;\n \
    \   };\n    return increasing(l.back()) || decreasing(l.front());", "    long\
    \ int l1=0;\n    long int l2=0;\n    long int l3=1;\n    long int l4=1;\n    long\
    \ int l5=1;\n    long int l6=1;\n    long int l7=1;\n    for (size_t i = 0; i\
    \ < l.size(); i++) {\n        if (l[i] < l1) {\n            l1=l[i];\n       \
    \ }\n        else if (l[i] > l2) {\n            l2=l[i];\n        }\n        else\
    \ if (l[i] < l3) {\n            l3=l[i];\n        }\n        else if (l[i] > l4)\
    \ {\n            l4=l[i];\n        }\n        else if (l[i] < l5) {\n        \
    \    l5=l[i];\n        }\n        else if (l[i] > l6) {\n            l6=l[i];\n\
    \        }\n        else if (l[i] < l7) {\n            l7=l[i];\n        }\n \
    \   }\n    // All elements of l are monotonically increasing or decreasing.\n\
    \    bool isMonotonic = l1 <= l2 && l3 <= l4 && l5 <= l6 && l7 <= l2;\n    return\
    \ isMonotonic;", "    if (l.size() < 2) return true;\n    std::vector<long> v\
    \ = l;\n    v.sort();\n    if (v[0] != v[1]) return false;\n    for (size_t i\
    \ = 2; i < v.size(); ++i) {\n        if (v[i] > v[i - 1]) return false;\n    }\n\
    \    return true;", "    int len = l.size();\n    int ind = 0;\n    while (++ind\
    \ < len) {\n        if (l[ind] <= l[ind - 1]) {\n            break;\n        }\n\
    \    }\n    return ind != len - 1;", "  if (l.size() <= 1) return false;\n\n \
    \ auto f1 = l.front();\n  auto f2 = l.back();\n  return f2 < f1;", "    for (long\
    \ i = 1; i < l.size(); i++) {\n        if (l[i] > l[i-1]) \n            return\
    \ false;\n    }\n    return true;", "    sort(l.begin(), l.end());\n    long long\
    \ m = l[0];\n    for (long i = 1; i < l.size(); i++) {\n        if (l[i] < m)\
    \ break;\n    }\n    if (i == l.size() - 1) return true;\n    if (l[i - 1] > l[i])\
    \ return false;\n    if (l[i - 1] != l[i]) return monotonic(l);\n    return false;",
  "    long x = 0;\n    for (long i = 0; i < l.size(); ++i) {\n        x = std::max(x,\
    \ l[i]);\n    }\n    for (long i = 0; i < l.size(); ++i) {\n        x = std::min(x,\
    \ l[i]);\n    }\n    return x == 0;", "    for (long i = 0; i < l.size() - 1;\
    \ ++i) {\n        if (l[i] < l[i + 1]) {\n            return false;\n        }\n\
    \    }\n    return true;", "  typedef typename std::vector<long>::const_iterator\
    \ v_iter;\n  v_iter first = l.begin();\n  v_iter last = l.end();\n  long cur_val\
    \ = *first;\n  long prev_val = *last;\n  bool decrease = true;\n  for (v_iter\
    \ iter = first+1; iter != last; ++iter) {\n    long val = *iter;\n    if (val\
    \ < cur_val) {\n      return false;\n    }\n    if (val > prev_val) {\n      return\
    \ false;\n    }\n    if (val < prev_val) {\n      decrease = false;\n    }\n \
    \   prev_val = cur_val;\n    cur_val = val;\n  }\n  return decrease;", "    long\
    \ long minValue = 0;\n    long long maxValue = 0;\n    for (long long i = 0; i\
    \ < l.size(); i++) {\n        if (l[i] < minValue)\n            minValue = l[i];\n\
    \        if (l[i] > maxValue)\n            maxValue = l[i];\n    }\n    return\
    \ (maxValue >= minValue);", "    auto it = l.begin();\n    long a = *it++;\n \
    \   long b = *it;\n    if (a == b) return false;\n    ++it;\n    a = *it;\n  \
    \  long c = *it;\n    if (c < b) return true;\n    if (b < c) return true;\n \
    \   return false;", "    assert(l.size() > 0);\n    std::sort(l.begin(), l.end());\n\
    \    for (long i = 1; i < l.size(); ++i) {\n        if (l[i] <= l[i - 1]) return\
    \ false;\n    }\n    return true;", "    int n = l.size();\n    if (n == 0) return\
    \ false;\n    long max_val = l[0];\n    for (int i = 1; i < n; i++) {\n      \
    \  long val = l[i];\n        if (val > max_val) {\n            max_val = val;\n\
    \        }\n    }\n    return max_val == l[0];", "    if (l.size() == 0) {\n \
    \       return true;\n    }\n    std::vector<long> l2 = l;\n    std::sort(l2.begin(),\
    \ l2.end());\n    if (l2.front() >= l2.back()) {\n        return true;\n    }\n\
    \    return false;", "    auto it = l.begin();\n    auto last = l.end() - 1;\n\
    \    // check increasing\n    bool increasing = true;\n    while (it < last &&\
    \ increasing) {\n        increasing = !(*it > *(++it));\n    }\n    if (increasing\
    \ && it == last)\n        return true;\n    // check decreasing\n    decreasing\
    \ = true;\n    while (it > last && decreasing) {\n        decreasing = !(*it >\
    \ *(--it));\n    }\n    if (decreasing && it == last)\n        return true;\n\
    \    return false;", "    if (l.size() == 0 || l[0] > l[l.size()-1]) {\n     \
    \   return false;\n    }\n    long first = l[0];\n    long last = l[l.size()-1];\n\
    \    for (size_t i = 1; i < l.size(); i++) {\n        if (l[i] < first || l[i]\
    \ > last) {\n            return false;\n        }\n    }\n    return true;", " \
    \ int size = l.size();\n  bool flag = true;\n  for (int i = 0; i <= size; i++)\
    \ {\n    int j = i + 1;\n    if (i == size - 1 || l[j] >= l[i]) flag = false;\n\
    \  }\n  return flag;", "    auto it = std::lower_bound(l.begin(), l.end(), l.front());\n\
    \    if (it == l.begin() || it == l.end() || (*it) < l.front())\n        return\
    \ true;\n    if (it == l.end() || (*it) > l.back())\n        return false;\n \
    \   std::vector<long> res;\n    res.push_back((*it) - 1);\n    for (auto p = it;\
    \ p != l.end() && p->back() == l.front(); ++p)\n        res.push_back((*p) - 1);\n\
    \    if (res.back() >= 0)\n        res.pop_back();\n    return monotonic(res);",
  "  long low = 0, high = l.size() - 1;\n  while (low < high) {\n    long mid = (low\
    \ + high) / 2;\n    if (l[mid] < l[low] || l[mid] < l[high]) {\n      low = mid;\n\
    \    } else {\n      high = mid;\n    }\n  }\n  return l[low] >= l[high];", " \
    \   // Use std::max_element to find the maximum element in the vector\n    long\
    \ maximum = *std::max_element(l.begin(), l.end());\n    // If vector is empty,\
    \ return true because no element has been added\n    if (l.size() == 0)\n    \
    \    return true;\n    // Iterate over the vector looking for the first non-decreasing\
    \ element\n    bool result = false;\n    for (long i : l) {\n        if (i < maximum)\
    \ {\n            result = true;\n            break;\n        }\n    }\n    return\
    \ result;", "  if (l.size() <= 1 || l.size() >= 1000) return false;\n  if (l[0]\
    \ == l[1]) return false;\n  long max_val = l[0];\n  for (long i = 1, j = l[0];\
    \ i <= l.size(); i++) {\n    if (l[i] < l[j]) {\n      if (l[i] < max_val) return\
    \ false;\n      max_val = l[i];\n    } else if (l[i] > l[j]) {\n      if (l[i]\
    \ > max_val) return false;\n      max_val = l[i];\n    }\n  }\n  return true;",
  "    // Sort vector.\n    sort(l.begin(), l.end());\n    // Iterate over sorted\
    \ vector and compare with previous element using <.\n    for (long i = l.size()-1;\
    \ i > 0; --i) {\n        if (l[i] < l[i-1]) {\n            return false;\n   \
    \     }\n    }\n    return true;", "    for (int i = 0; i < l.size(); i++) {\n\
    \        if (l[i] > l[i - 1]) {\n            return false;\n        }\n    }\n\
    \    return true;", "  int i1 = 0, i2 = l.size() - 1;\n  while (i1 < i2) {\n \
    \   if (l[i1] > l[i2]) std::swap(i1, i2);\n    ++i1;\n    --i2;\n  }\n  return\
    \ (i1 == 0 || l[i1] <= l[i2]);", "  long ln = l.size();\n  if (ln < 2) return\
    \ true;\n  if (ln > 2) return false;\n  int first = l[0];\n  int last = l[ln -\
    \ 1];\n  if (first <= last) return false;\n  for (long i = 0; i < ln; i++) {\n\
    \    if (l[i] < first) return false;\n    if (l[i] > last) return false;\n  }\n\
    \  return true;", "    // Create a vector with difference between each element\
    \ of the vector\n    // and a vector of 0 with the same size of vector.\n    std::vector<long>\
    \ diff(l.size());\n    std::vector<long> zero(l.size());\n    for (size_t i =\
    \ 0; i < l.size(); ++i) {\n        diff[i] = l[i] - l[i - 1];\n        zero[i]\
    \ = 0;\n    }\n    // Find the first zero element and last non-zero element.\n\
    \    auto it = std::find_if(zero.begin(), zero.end(), [](const auto elem) { return\
    \ elem == 0; });\n    auto it2 = std::find_if(l.begin(), l.end(), [](const auto\
    \ elem) { return elem != 0; });\n    // If there is any difference between first\
    \ non-zero and last non-zero\n    // element. Return true if they are increasing\
    \ or decreasing.\n    return std::any_of(diff.begin(), diff.end(), [](const auto\
    \ elem) { return elem > 0; });", "  int left_bound = 0;\n  int right_bound = l.size()\
    \ - 1;\n  while (left_bound <= right_bound) {\n    int mid = (left_bound + right_bound)\
    \ / 2;\n    int mid_val = l[mid];\n    if (mid_val < mid_val) {\n      right_bound\
    \ = mid - 1;\n    } else if (mid_val > mid_val) {\n      left_bound = mid + 1;\n\
    \    } else {\n      return true;\n    }\n  }\n  return false;", "    // Write\
    \ your code here\n    long long start = l[0];\n    for (size_t i = 0; i < l.size();\
    \ ++i) {\n        if (l[i] >= start) {\n            return true;\n        }\n\
    \        start = l[i];\n    }\n    return false;", "    // Find minimum element\n\
    \    auto min = *min_element(l.begin(), l.end());\n    if (l.size() > 1) {\n \
    \       long m = *max_element(l.begin(), l.end());\n        if (m == min) {\n\
    \            // All elements are equal\n            return true;\n        } else\
    \ if (m == min + 1) {\n            // Both are same and one is next\n        \
    \    return false;\n        } else if (m > min && l > l) {\n            // Both\
    \ elements are increasing\n            return true;\n        } else {\n      \
    \      // Both elements are decreasing\n            return false;\n        }\n\
    \    } else {\n        return *min_element(l.begin(), l.end()) <= min;\n    }",
  "    auto it = l.begin();\n    if (it == l.end()) return true;\n    if (std::next(it)\
    \ == l.end()) return false;\n    if (it->first <= std::next(it)->first) return\
    \ monotonic(std::next(it));\n    auto it2 = std::next(it);\n    if (it2->first\
    \ <= it->first) return false;\n    return monotonic(std::next(it2));", "  if (l.size()\
    \ < 2) return true;\n  // Compare the first and last element\n  if (l.front()\
    \ > l.back()) return false;\n  auto it = l.begin();\n  auto last = it;\n  if (it\
    \ == l.end()) return true;\n  ++it;\n  if (it == l.end()) return true;\n  ++it;\n\
    \  while (it != last) {\n    if (it == l.end()) return false;\n    ++it;\n  }\n\
    \  return true;", "    int i, j, temp;\n    if (l.size() <= 1) return true;\n\
    \    for (i = 1, j = 0, temp = l[0]; temp > l[i]; i++, j++, temp = l[i]) {\n \
    \       if (temp > l[i]) {\n            l[j] = temp;\n            return true;\n\
    \        }\n    }\n    l[j] = temp;\n    return false;", "  int n = l.size();\n\
    \  assert(n > 0);\n  bool res = true;\n  // sort and reverse the list\n  auto\
    \ it = std::stable_sort(l.begin(), l.end());\n  l += l.begin();\n  it--;\n  for\
    \ (int i = 1; i < n; i++) {\n    int cmp = it->first - l[i].first;\n    if (cmp\
    \ < 0) {\n      res = false;\n      break;\n    }\n    it--;\n  }\n  return res;",
  "    for (long i = 0; i < l.size()-1; ++i) {\n        if (l[i+1] >= l[i]) return\
    \ false;\n    }\n    return true;", "    long long sum = 0;\n    for (long i :\
    \ l) {\n        sum += i;\n    }\n\n    long long avg = sum / l.size();\n\n  \
    \  for (long i : l) {\n        if (i < avg)\n            return false;\n    }\n\
    \    return true;", "    long prev = std::numeric_limits<long>::min();\n    for\
    \ (long el : l) {\n        if (prev > el)\n            return false;\n       \
    \ prev = el;\n    }\n    return true;", "    std::sort(l.begin(), l.end());\n\
    \    long long x = 0;\n    for (long long i = 1; i < l.size(); ++i) {\n      \
    \  if (l[i] <= l[i - 1]) {\n            return false;\n        }\n        x +=\
    \ (long long)l[i] - l[i - 1];\n    }\n    return true;", "    for (size_t i =\
    \ l.size()-1; i >= 0; i--) {\n        if (l[i] > l[i+1]) return false;\n    }\n\
    \    return true;", "    if (l.size() < 2) return false;\n    long long a = l[0],\
    \ b = l[1], c = l[2];\n    if (a == b) return false;\n    if (a == c) return false;\n\
    \    if (b == c) return true;\n    if ((a - b) <= (c - a)) return true;\n    return\
    \ false;", "    long long low = l[0]; // current minimum value\n    long long\
    \ high = l[0]; // current maximum value\n    for (long long i = 0; i < l.size();\
    \ i++) {\n        if (l[i] < low)\n            low = l[i];\n        if (l[i] >\
    \ high)\n            high = l[i];\n    }\n    return low <= high;", "    auto\
    \ l = l.size();\n    long l1 = l[0];\n    long l2 = l[1];\n    long l3 = l[2];\n\
    \    long l4 = l[3];\n    for (long i = 1; i < l; i++) {\n        if (l[i] > l1)\
    \ {\n            l1 = l[i];\n        }\n        if (l[i] < l2) {\n           \
    \ l2 = l[i];\n        }\n        if (l[i] > l3) {\n            l3 = l[i];\n  \
    \      }\n        if (l[i] < l4) {\n            l4 = l[i];\n        }\n    }\n\
    \    bool res = true;\n    if (l2 < l1) {\n        res = false;\n    }\n    if\
    \ (l4 < l3) {\n        res = false;\n    }\n    if (l1 < l2) {\n        res =\
    \ false;\n    }\n    if (l3 < l4) {\n        res = false;\n    }\n    return res;",
  "    // Loop over the vector until we find a decreasing or increasing element.\n\
    \    // If one exists, break the loop and return true\n    bool increasing = false;\n\
    \    bool decreasing = false;\n    for (long i = l.size() - 1; i >= 0; --i) {\n\
    \        if (l[i] <= l[i - 1]) {\n            decreasing = true;\n        } else\
    \ if (l[i] >= l[i - 1]) {\n            increasing = true;\n            break;\n\
    \        }\n    }\n    return increasing || decreasing;", "    long previous =\
    \ l[0];\n    bool increases = true;\n    for (int i = 1; i < l.size(); i++) {\n\
    \        if (l[i] < previous) {\n            increases = false;\n            break;\n\
    \        }\n        previous = l[i];\n    }\n    return increases;", "    int\
    \ n = l.size();\n    for (int i = 0; i < n; ++i) {\n        int j = (i+1) % n;\n\
    \        if (l[i] < l[j]) {\n            return false;\n        }\n        if\
    \ (l[i] > l[j]) {\n            return true;\n        }\n    }\n    return true;",
  "    assert(l.size() >= 2);\n\n    auto lmin = *std::min_element(l.begin(), l.end());\n\
    \    auto lmax = *std::max_element(l.begin(), l.end());\n    if (lmin > lmax)\
    \ {\n        std::swap(lmin, lmax);\n    }\n\n    for (int i = 0; i < l.size();\
    \ ++i) {\n        if (l[i] < lmin) return false;\n        if (l[i] > lmax) return\
    \ false;\n    }\n\n    return true;", "    auto start = l.begin();\n    auto end\
    \ = l.end();\n    if (end - start < 2)\n        return false;\n    auto middle\
    \ = std::next(start);\n    std::advance(middle, 1);\n    return (l.back() <= std::get<0>(middle))\
    \ && (std::get<0>(start) > std::get<0>(middle));", "  for (int i = 0; i < l.size()\
    \ - 1; i++) {\n    if (l[i] > l[i + 1]) {\n      return false;\n    }\n  }\n \
    \ return true;", "    auto it = l.begin();\n    auto last = it;\n    while (it\
    \ != l.end() && (*it < *last)) {\n        last++;\n    }\n    if (it == l.end())\n\
    \        return true;\n    last = it;\n    while (it != l.end() && (*it > *last))\
    \ {\n        last++;\n    }\n    if (it == l.end())\n        return false;\n \
    \   return !(*it < *last);", "    long min = l.front();\n    long max = l.back();\n\
    \    for (auto i : l) {\n        if (i > max) {\n            max = i;\n      \
    \  }\n        if (i < min) {\n            min = i;\n        }\n    }\n    if (min\
    \ == max) {\n        return false;\n    }\n    // All elements are increasing.\n\
    \    if (min > max) {\n        return true;\n    }\n    return false;", "  long\
    \ long i = 1;\n  for (auto e : l) { i = (i*e + 1) >> 1; }\n  return i < (1LL<<31)\
    \ && i > 0;", "  for (long long i = 0; i < l.size(); ++i) {\n    if (l[i] > l[i\
    \ - 1]) return false;\n  }\n  return true;", "    // Find the first element that\
    \ isn't equal to its neighbours. We do\n    // this by iterating through both\
    \ vectors simultaneously and looking for\n    // a difference between the current\
    \ element and the neighbours. This\n    // is done using two pointers, one that\
    \ points to the current element and\n    // the other to the current neighbour\
    \ (the element it just looked at) and\n    // comparing the values at these pointers.\n\
    \    long current = l.at(0); // Current element\n    long last = l.back(); //\
    \ Previous element\n    for (long i = 1, e = l.size(); i < e; i++) {\n       \
    \ // Iterate over two consecutive elements in an array\n        if (current !=\
    \ l.at(i)) {\n            // If there is a difference we return false\n      \
    \      return false;\n        }\n        current = l.at(i); // Update current\
    \ element\n        last = l.at(i - 1); // Update previous element\n    }\n   \
    \ // Return true is there are no differences anymore\n    return true;", "   \
    \ long long x = l.front();\n    if (x == 0) return true;\n    for (size_t i =\
    \ 1; i < l.size(); i++) {\n        if (std::abs(l[i] - x) > 1) return false;\n\
    \    }\n    return true;", "    if (l.size() < 2)\n        return false;\n   \
    \ auto cmp = [&l](int x, int y) { return x < y; };\n    std::sort(l.begin(), l.end(),\
    \ cmp);\n    return l.front() == l.back();", "  int cnt = 0;\n  long max_v = *(l.end()-1);\n\
    \  for (auto v : l)\n    if (v < max_v) {\n      cnt++;\n      max_v = v;\n  \
    \  }\n  return (cnt < 2);", "    int n = l.size();\n    long lMin = l[0], lMax\
    \ = l[n-1];\n    for(int i = 1; i < n; ++i) {\n        lMin = std::min(lMin, l[i]);\n\
    \        lMax = std::max(lMax, l[i]);\n    }\n    if(lMax < lMin) {\n        return\
    \ true;\n    } else {\n        return false;\n    }", "  if (l.size() == 0) return\
    \ false;\n  long long res = 0;\n  for (int i = 0; i < l.size(); i++)\n    res\
    \ += l[i];\n  return (std::is_increasing)(res);", "  sort(l.begin(), l.end());\n\
    \  for (auto i : l) {\n    if (i < l.front())\n      return false;\n  }\n  return\
    \ true;", "    long long max = std::numeric_limits<long long>::max();\n    long\
    \ long min = std::numeric_limits<long long>::min();\n    return std::find_if(l.begin(),\
    \ l.end(), [max](long long i) {\n        return (i == max || i == min);\n    })\
    \ != l.end();", "  int n = l.size();\n  bool b = true;\n  for (int i = n-1; i\
    \ >= 0; i--) {\n    if (l[i] <= l[i+1]) {\n      b = false;\n      break;\n  \
    \  }\n  }\n  return b;", "  int size = l.size();\n  long i = 0;\n  long pre =\
    \ 0;\n  long post = 0;\n  while (i < size) {\n    pre = pre * 10 + l[i] - 1;\n\
    \    post = post * 10 + l[i] + 1;\n    i++;\n  }\n  return pre > post;", "   \
    \ if (l.size() <= 1) return true;\n\n    bool ans = true;\n\n    for (long i =\
    \ 0, j = l.size(); i < j; i++) {\n        if (l[i] < l[j]) {\n            ans\
    \ = false;\n            break;\n        }\n    }\n\n    return ans;", "    if(l.size()\
    \ == 0) return false;\n    auto it1 = l.begin(), it2 = l.begin();\n    for(; it1\
    \ != l.end(); it1++, it2++) {\n        if(*it2 > *it1) return false;\n    }\n\
    \    return true;", "    long long first = l.front(), last = l.back();\n    for(auto\
    \ i = l.begin()+2; i != l.end()-1; i++) {\n        if(*i < *(i-1)) return true;\n\
    \        if(*i > *(i+1)) return true;\n    }\n    return false;", "    auto it\
    \ = l.begin();\n    auto end = l.end();\n    auto less = [&](long a, long b) {\
    \ return a < b; };\n    for (; it != end; ++it) {\n        auto it = l.begin();\n\
    \        while (it != end && *it < *it) ++it;\n        if (it == end) {\n    \
    \        return false;\n        }\n        if ((*it > 0 && *it > it->second ||\
    \ *it < 0 && *it < it->second) ||\n            !(*it == it->second)) {\n     \
    \       return false;\n        }\n    }\n    return true;", "  int n = l.size();\n\
    \  long long int max_val = -1;\n  for (int i = 0; i < n; ++i) {\n    long long\
    \ int curr = l[i];\n    if (curr > max_val) {\n      max_val = curr;\n    }\n\
    \  }\n  if (max_val < 0) {\n    return false;\n  }\n  bool flag = true;\n  for\
    \ (int i = 1; i < n; ++i) {\n    long long int curr = l[i];\n    if (curr != max_val)\
    \ {\n      flag = false;\n    }\n  }\n  return flag;", "    // Return true if\
    \ monotonic increasing.\n    for (long i = 1; i < l.size(); i++) {\n        if\
    \ (l[i] < l[i-1]) return true;\n    }\n    // Return true if monotonic decreasing.\n\
    \    for (long i = 1; i < l.size(); i++) {\n        if (l[i] > l[i-1]) return\
    \ true;\n    }\n    return false;", '    return std::next_permutation(l.begin(),
    l.end()) == l.end();', "\tint n = l.size();\n\t// Sort list elements to decreasing\
    \ order.\n\tstd::sort(l.begin(), l.end(), std::greater<long>());\n\t// Iterate\
    \ till 1st element is increasing or n is decreasing\n\tfor (int i = 1; i < n;\
    \ i++) {\n\t\tif (l[i - 1] > l[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn\
    \ true;", "    auto s = l.size();\n    if (s == 0) {\n        return true;\n \
    \   }\n    auto m = s[s-1];\n    for (auto i = 0ll; i < s; i++){\n        if (l[i]\
    \ < m && l[i-1] > m){\n            return false;\n        }\n        if (l[i]\
    \ > m && l[i-1] < m){\n            return false;\n        }\n        m = std::max(m,\
    \ l[i]);\n    }\n    return true;", "    for (auto it1 = l.begin(), it2 = l.begin()\
    \ + 1; it2 != l.end(); ++it1, ++it2) {\n        if (*it1 > *it2) {\n         \
    \   return true;\n        }\n    }\n    return false;", "    long largest = *std::max_element(std::begin(l),\
    \ std::end(l));\n    long smallest = *std::min_element(std::begin(l), std::end(l));\n\
    \    return largest >= smallest;", "    long long min_v = *std::min_element(l.begin(),\
    \ l.end());\n    long long max_v = *std::max_element(l.begin(), l.end());\n  \
    \  return (min_v < max_v);", "    bool ok = true;\n    if (l.size() == 0) {\n\
    \        return true;\n    }\n\n    if (l.size() == 1) {\n        if (l[0] ==\
    \ 0) {\n            return false;\n        }\n        return l[0] >= l[1];\n \
    \   }\n\n    for (int i = 1; i < l.size(); i++) {\n        if (l[i] < l[i - 1])\
    \ {\n            return false;\n        }\n    }\n    return true;", "    long\
    \ long n = l.size();\n    long long gap = 0;\n    long long pos = 0;\n    long\
    \ long temp;\n    for (long long i = 0; i < n; ++i) {\n        pos = i;\n    \
    \    temp = l[i];\n        while (i + 1 < n && l[i + 1] > temp) {\n          \
    \  ++i;\n        }\n        gap = std::max(gap, i - pos);\n    }\n    return gap\
    \ == 0;", "  int n = l.size();\n  // Avoid n^2 by taking advantage of monotonicity\n\
    \  long curr = l[0];\n  for (int i = 1; i < n; ++i) {\n    if (l[i] < curr) {\n\
    \      return true;\n    }\n    curr = l[i];\n  }\n  return false;", "    long\
    \ long t = 0;\n    for (auto it = l.begin(); it != l.end(); it++) {\n        t\
    \ = t > static_cast<long long>(*it) ? t : *it;\n    }\n    return t < 0;", "\t\
    for(long i = l.size() - 1; i >= 0; i--) {\n\t\tfor(long j = i; j >= 0; j--) {\n\
    \t\t\tif(l[j] < l[i]) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;",
  "    // Sort vector using merge sort algorithm\n    mergeSort(l, l.begin(), l.end());\n\
    \    if (l[0] != l[l.size() - 1]) {\n        return true;\n    }\n    return false;",
  "    long long ans = 0;\n    int n = l.size();\n    long long largest = l[n-1];\n\
    \    for (int i = 1; i < n; i++) {\n        long long current = l[i];\n      \
    \  if (current < largest)\n            return false;\n        else\n         \
    \   ans += current - largest;\n        largest = current;\n    }\n    if (ans\
    \ > 0)\n        return true;\n    return false;", "    long start = 0;\n    long\
    \ end = std::accumulate(l.begin(), l.end(), 0);\n    if (end < start) {\n    \
    \    return false;\n    }\n    if (l.front() < end) {\n        return true;\n\
    \    }\n    return false;", "    long long start=0;\n    long long last=l.back();\n\
    \    for(auto i:l) start=max(start, last+i);\n    for(auto i:l)\n        if(last+i\
    \ < start) return false;\n    return true;", "  auto it = l.begin();\n  for (int\
    \ i = 0; i < l.size() - 1; i++) {\n    if (*it < *(it + 1)) return false;\n  \
    \  ++it;\n  }\n  return true;", "  if (l.size() < 2) return false;\n  long prev\
    \ = l[0], curr = l[0];\n  for (int i = 1; i < l.size(); ++i) {\n    if (l[i] <\
    \ prev) return false;\n    curr = l[i];\n    prev = curr;\n  }\n  return true;",
  "\tbool increasing = l.front() >= l.back();\n\tfor (auto i = l.begin() + 1; i +\
    \ 1 != l.end(); ++i) {\n\t\tif (increasing) {\n\t\t\tincreasing = *i > *(i + 1);\n\
    \t\t} else {\n\t\t\tincreasing = *i < *(i + 1);\n\t\t}\n\t}\n\treturn increasing;",
  "    // We assume that l is monotonic (a vector of monotonic increasing\n    //\
    \ or decreasing numbers), and that the last element in the list is\n    // the\
    \ largest number in the list.\n    if (l.size() == 0) {\n        return true;\n\
    \    }\n    if (l.size() == 1) {\n        return false;\n    }\n    long max =\
    \ l[0];\n    for (size_t i = 1; i < l.size(); i++) {\n        long cur = l[i];\n\
    \        if (cur > max) {\n            return false;\n        }\n        max =\
    \ cur;\n    }\n    return true;", "    if (l.size() <= 1 || l.front() <= 0) {\n\
    \        return false;\n    }\n\n    long s = l.front();\n    for (long i = 1;\
    \ i < l.size(); i++) {\n        long e1 = l.at(i);\n        long e2 = l.at(i-1);\n\
    \        if (e1 < e2 || (e1 == e2 && (e1 < 0 || e1 >= s))) {\n            return\
    \ false;\n        }\n        s = e1;\n    }\n\n    return true;", "    int n =\
    \ l.size();\n    if (n == 0) return true;\n    for (int i = 1; i < n; ++i) {\n\
    \        if (l[i - 1] > l[i]) return true;\n    }\n    return false;", "    if\
    \ (l.size() < 2) return true;\n    auto first = l.begin();\n    auto last = l.end()\
    \ - 1;\n    while (first <= last && first->second <= last->second) ++first;\n\
    \    if (first <= last) {\n        auto mid = first + (last - first) / 2;\n  \
    \      auto middle = mid->second;\n        if (middle > last->second) return monotonic(l);\n\
    \        if (middle < first->second) return false;\n        if (middle > first->second)\
    \ return monotonic(l);\n    }\n    return true;"]
stop_tokens:
- "\n}"
