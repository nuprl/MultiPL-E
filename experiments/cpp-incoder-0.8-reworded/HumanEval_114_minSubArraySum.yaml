name: HumanEval_114_minSubArraySum
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a vector of integers\
  \ nums, find the minimum sum of any non-empty sub-vector\n// of nums.\n// Example\n\
  // >>> minSubArraySum((std::vector<long>({(long)2, (long)3, (long)4, (long)1, (long)2,\
  \ (long)4})))\n// (1)\n// >>> minSubArraySum((std::vector<long>({(long)-1, (long)-2,\
  \ (long)-3})))\n// (-6)\nlong minSubArraySum(std::vector<long> nums) {\n"
tests: "}\nint main() {\n    auto candidate = minSubArraySum;\n    assert(candidate((std::vector<long>({(long)2,\
  \ (long)3, (long)4, (long)1, (long)2, (long)4}))) == (1));\n    assert(candidate((std::vector<long>({(long)-1,\
  \ (long)-2, (long)-3}))) == (-6));\n    assert(candidate((std::vector<long>({(long)-1,\
  \ (long)-2, (long)-3, (long)2, (long)-10}))) == (-14));\n    assert(candidate((std::vector<long>({(long)-9999999999999999})))\
  \ == (-9999999999999999));\n    assert(candidate((std::vector<long>({(long)0, (long)10,\
  \ (long)20, (long)1000000}))) == (0));\n    assert(candidate((std::vector<long>({(long)-1,\
  \ (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)100,\
  \ (long)-1, (long)-2, (long)-3, (long)10, (long)-5}))) == (-6));\n    assert(candidate((std::vector<long>({(long)10,\
  \ (long)11, (long)13, (long)8, (long)3, (long)4}))) == (3));\n    assert(candidate((std::vector<long>({(long)100,\
  \ (long)-33, (long)32, (long)-1, (long)0, (long)-2}))) == (-33));\n    assert(candidate((std::vector<long>({(long)-10})))\
  \ == (-10));\n    assert(candidate((std::vector<long>({(long)7}))) == (7));\n  \
  \  assert(candidate((std::vector<long>({(long)1, (long)-1}))) == (-1));\n}\n"
completions: ["    // Your code here\n    long sum = 0;\n    for(long i : nums)\n\
    \    {\n        sum += i;\n    }\n    \n    return sum;", "  long minSum = nums[0];\
    \ // to store minimal sum\n\n  // iterate through all the array\n  for (size_t\
    \ i = 0; i < nums.size(); ++i) {\n    // find minimal sum\n    minSum = std::min(minSum,\
    \ nums[i]);\n    // iterate through rest of the array and find if any sub-array\
    \ is empty\n    for (size_t j = i + 1; j < nums.size(); ++j) {\n      // if sub-array\
    \ is not empty find sum of the sub-array\n      if (nums[j] != 0) {\n        minSum\
    \ = std::min(minSum, nums[j]);\n      }\n    }\n  }\n\n  return minSum;", "  \
    \  // write your code here\n    long minSum=nums[0]+nums[1];\n    for(long i=2;i<nums.size();i++){\n\
    \        minSum=nums[i]<minSum?nums[i]:minSum;\n    }\n    return minSum;", "\t\
    // Your code goes here\n\tlong ans = INT_MAX;\n\tfor(int i = 0; i < nums.size();\
    \ i++)\n\t\tans = min(ans, nums[i] + minSubArraySum(nums.subspan(i + 1)));\n\t\
    return ans;", "  // Your code here\n  long sum = 0;\n  for (int i = 0; i < nums.size();\
    \ i++) {\n    sum += nums[i];\n  }\n  return sum;", "    long minSum = nums[0];\n\
    \    long currSum = 0;\n    for (int i = 1; i < nums.size(); i++) {\n        currSum\
    \ += nums[i];\n        if (currSum < minSum) {\n            minSum = currSum;\n\
    \        }\n    }\n    return minSum;", "  std::vector<long> subVector(nums);\n\
    \  subVector[0] = nums[0];\n  long res = subVector[0];\n  // We need to check\
    \ only if the current element exceeds the current sum till now\n  for (size_t\
    \ i = 1, curSum = 0; i < nums.size(); i++) {\n    if (nums[i] > curSum) {\n  \
    \    subVector[i] = nums[i];\n      curSum += subVector[i];\n    } else {\n  \
    \    res = std::min(res, curSum + subVector[i]);\n      subVector[i] = nums[i];\n\
    \      curSum += subVector[i];\n    }\n  }\n  return res;", "  // Complete this\
    \ function\n  assert(nums.size() != 0);\n  long min_sum = 0;\n  for (long i =\
    \ 1; i < nums.size(); i++) {\n    min_sum += nums[i-1];\n    long curSum = min_sum;\n\
    \    min_sum = curSum + nums[i];\n  }\n  return min_sum;", "    long ans = 0;\n\
    \    long min = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    // for each num\n    for(long i = 0; i < nums.size(); i++){\n        long\
    \ sum = nums[i];\n        // for each index (i + 1 .. nums.size() - 1)\n     \
    \   for(long j = i; j < nums.size(); j++){\n            sum += nums[j];\n    \
    \        min = std::min(sum, min);\n            max = std::max(sum, max);\n  \
    \      }\n        ans = std::min(ans, sum - min + max);\n    }\n    return ans;",
  "    long long ans = 0;\n    long long l = nums.size();\n    assert(l >= 1);\n \
    \   for (long i = 0; i < l - 1; i++) {\n        long long curr = nums[i];\n  \
    \      long long next = nums[i + 1];\n        // if either sum is negative we\
    \ ignore it\n        if ((curr < 0) || (next < 0)) {\n            continue;\n\
    \        }\n        // if either sum is zero we ignore it\n        if (curr +\
    \ next == 0) {\n            continue;\n        }\n        long long sum = (curr\
    \ + next);\n        // if sum is odd, we ignore it\n        if (sum % 2 == 1)\
    \ {\n            continue;\n        }\n        while (curr + next != 0) {\n  \
    \          long long next_sum = curr + (next / 2);\n            // if sum is odd,\
    \ we ignore it\n            if (next_sum % 2 == 1) {\n                curr = next_sum;\n\
    \                next /= 2;\n            } else {\n                next /= 2;\n\
    \                ans += sum;\n                sum = (curr + next);\n         \
    \       curr = next;\n                next = (sum - curr) / 2;\n            }\n\
    \        }\n    }\n    return ans;", "    std::vector<long> v(nums.size(), 0);\n\
    \    for (long i = 0; i < nums.size(); i++) {\n        v[i] = std::min(v[i], nums[i]);\n\
    \    }\n\n    long long minSum = 0;\n    for (long i = 0; i < v.size(); i++) {\n\
    \        minSum += v[i];\n    }\n\n    return minSum;", "    long sum = std::numeric_limits<long\
    \ long int>::max();\n    for (auto it : nums)\n        sum += it;\n    std::vector<long>\
    \ best;\n    long currentSum = sum;\n    long bestScore = currentSum;\n    while\
    \ (true) {\n        best.resize(best.size() + 1);\n        for (auto it : nums)\
    \ {\n            long newSum = sum - it;\n            if (newSum >= 0) {\n   \
    \             currentSum = newSum;\n                best.push_back(it);\n    \
    \            bestScore = currentSum;\n            }\n        }\n        if (currentSum\
    \ < bestScore) break;\n        sum -= best[best.size() - 1];\n        currentSum\
    \ -= best[best.size() - 1];\n        best.erase(best.begin() + best.size() - 1);\n\
    \    }\n    return bestScore;", "    long min = LONG_MAX;\n    long sum = nums[0];\n\
    \    for(long i = 1; i < nums.size(); i++) {\n        sum += nums[i];\n      \
    \  if(sum < min) {\n            min = sum;\n        }\n    }\n    return min;",
  "    long sum = 0;\n    for (int i = 0; i < nums.size(); i++)\n        sum = std::min(sum,\
    \ nums[i]);\n    return sum;", "    long sum = 0;\n    for (int i = 0; i < nums.size();\
    \ i++) {\n        sum += nums[i];\n        sum = sum % 10;\n    }\n    return\
    \ sum;", "    long ans = 0;\n    long n = nums.size();\n    std::vector<long>\
    \ v;\n    v.push_back(nums[0]);\n    for (long i = 1; i < n; i++) {\n        if\
    \ (nums[i] > 0) v.push_back(nums[i]);\n        long k = std::min_element(v.begin(),\
    \ v.end()) - v.begin();\n        ans += k;\n        v.erase(v.begin());\n    }\n\
    \    return ans;", "  int n = nums.size();\n  if (n == 0) {\n    return -1;\n\
    \  }\n  int max_sum = std::max(nums[0]);\n  for (int i = 1; i < n; i++) {\n  \
    \  max_sum = std::min(max_sum, nums[i]);\n  }\n  return max_sum;", "    // Your\
    \ code goes here\n    // assert((long)nums.size() == nums.size());\n    long sum\
    \ = 0;\n    long sum2 = 0;\n    int size = (int)nums.size();\n    for(int i =\
    \ 0; i < (int)nums.size(); i++) {\n        sum += nums[i];\n        sum2 = sum2;\n\
    \        for(int j = 0; j < size; j++) {\n            sum2 = sum2 + nums[j];\n\
    \            if(sum2 < sum) {\n                sum = sum2;\n            }\n  \
    \      }\n    }\n    return sum;", "    auto n = nums.size();\n    // This array\
    \ will store the min sum\n    long sum = 0;\n    // This will store the index\
    \ of the current min\n    long minIndex = 0;\n    long long maxSum = 0;\n    for\
    \ (int i = 0; i < n; i++) {\n        // Check if the sum of the current element\
    \ is bigger than the max sum so far\n        if (nums[i] > maxSum) {\n       \
    \     // If it is, update the max sum\n            maxSum = nums[i];\n       \
    \ }\n    }\n    // Go through all the elements and check if the sum is greater\
    \ than the max\n    // sum so far\n    for (int i = 0; i < n; i++) {\n       \
    \ sum += nums[i];\n        // Check if the sum is greater than the max sum\n \
    \       if (sum > maxSum) {\n            // If it is, update the max sum and current\
    \ min\n            maxSum = sum;\n            minIndex = i;\n        }\n    }\n\
    \    return sum;", "  std::vector<std::vector<int>> v;\n  for (auto i : nums)\
    \ {\n    v.emplace_back(i);\n  }\n  long ans = v[0][0];\n  for (auto i : v) {\n\
    \    for (auto j : i) {\n      ans += j;\n    }\n  }\n  return ans;", "    long\
    \ min = std::numeric_limits<long>::max();\n    long sum = nums[0];\n    for (size_t\
    \ i = 1; i < nums.size(); i++) {\n        sum += nums[i];\n        if (sum < min)\n\
    \            min = sum;\n    }\n    return min;", "  // Write your code here.\n\
    \  // O(n) time and O(1) space\n  long min_val = INT_MIN;\n  for (auto it : nums)\
    \ {\n    min_val += it;\n    if (min_val > INT_MAX)\n      min_val = INT_MAX;\n\
    \  }\n  return min_val;", "    std::stack<long> st;\n    st.push(0);\n    for\
    \ (long i = 0; i < nums.size(); ++i) {\n        if (st.empty()) {\n          \
    \  st.push(nums[i]);\n        } else {\n            long cur = st.top();\n   \
    \         long nxt = nums[i];\n            st.pop();\n            st.push(nxt\
    \ + cur);\n        }\n    }\n    return st.top();", "  // write your code in C++17\n\
    \  std::cout<<\"\\n\"<<\"(1) \"<<\"\\n\";\n  assert(nums.size()>=2);\n  long long\
    \ sum=0;\n  for(auto num:nums) {\n    sum+=num;\n  }\n  std::cout<<\"\\n\"<<\"\
    Sum \"<<sum<<std::endl;\n  long long minSum=sum;\n  for(auto num:nums) {\n   \
    \ sum-=num;\n    if(sum<minSum) minSum=sum;\n  }\n  std::cout<<\"\\n\"<<\"Minimum\
    \ Sum \"<<minSum<<std::endl;\n  \n  // write your code in C++11\n  std::cout<<\"\
    \\n(2) \"<<\"\\n\";\n  assert(nums.size()>=2);\n  long long sum=0;\n  for(auto\
    \ num:nums) {\n    sum+=num;\n  }\n  std::cout<<\"\\n\"<<\"Sum \"<<sum<<std::endl;\n\
    \  long long minSum=sum;\n  for(auto num:nums) {\n    sum-=num;\n    if(sum<minSum)\
    \ minSum=sum;\n  }\n  std::cout<<\"\\n\"<<\"Minimum Sum \"<<minSum<<std::endl;\n\
    \  \n  return minSum;", "    // Write your code here\n    long sum=0;\n    long\
    \ minSum=nums[0];\n    for(long i=0;i<nums.size();i++){\n        sum+=nums[i];\n\
    \        if(sum<minSum){\n            minSum=sum;\n        }\n    }\n    return\
    \ minSum;", "    long minSum = LONG_MAX;\n    for (auto &num : nums) {\n     \
    \   minSum = std::min(minSum, num);\n    }\n    return minSum;", "    auto it\
    \ = std::max_element(nums.begin(), nums.end());\n    long ans = *it;\n    for\
    \ (auto it : nums) {\n        ans = min(ans, it + ans);\n    }\n    return ans;",
  "    long min = INT_MAX;\n    for (auto x : nums) {\n        min = std::min(min,\
    \ x + nums[nums.size() - x - 1]);\n    }\n    return min;", "    // Write your\
    \ code here.\n    // Your code here\n    long min = 0, sum = 0;\n    for (long\
    \ i = 0; i < nums.size(); i++)\n        sum += nums[i];\n    if (sum < 0)\n  \
    \      return -1;\n    else\n        return min;", "    // your code goes here\n\
    \    long min = std::numeric_limits<long long >::max();\n    long long sum = 0;\n\
    \    int n = nums.size();\n    for (int i = 0; i < n; i++) {\n        if (sum\
    \ > 0 && nums[i] > sum) {\n            continue;\n        }\n        if (nums[i]\
    \ < min) {\n            sum = nums[i];\n            min = nums[i];\n        }\
    \ else {\n            sum += nums[i];\n        }\n    }\n    return sum;", " \
    \   // Write your code here\n    long sum = 0;\n    for (int i = 0; i < nums.size();\
    \ i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            sum\
    \ += nums[i] + nums[j];\n        }\n    }\n    return sum;", "    long ans = INT_MAX;\n\
    \    // TODO: vectorize the code\n    for (auto &i : nums) {\n        ans = std::min(ans,\
    \ sum(i));\n    }\n    return ans;", "\tlong ans = INT_MIN;\n\t// Iterate over\
    \ each subvector in nums\n\tfor (auto i : nums) {\n\t\t// If this subvector has\
    \ non-zero elements, find the minimum of all the elements it\n\t\t// contains\n\
    \t\tif (i != 0) {\n\t\t\tauto minOfSubvector = *std::min_element(std::begin(nums)\
    \ + i - 1, std::end(nums));\n\t\t\t// Add the sum of the elements of this subvector\
    \ and the minimum found so far\n\t\t\tans = std::min(ans, i + minOfSubvector);\n\
    \t\t}\n\t}\n\treturn ans;", "    int n = nums.size();\n    long ans = INT_MIN;\n\
    \    long k = 0;\n\n    for (int i = 0; i < n; i++) {\n        // If j is greater\
    \ than k, then we must add the sum of nums[j] to the current min sum.\n      \
    \  for (int j = i + 1; j < n; j++) {\n            // Only add the current number\
    \ to the current min sum if it is greater than the previous\n            // min\
    \ sum and it is not greater than the actual current sum.\n            if (ans\
    \ > k) {\n                ans += nums[j];\n            }\n        }\n        k\
    \ = ans;\n    }\n    return ans;", "    long ans = nums[0];\n    for (size_t i\
    \ = 1; i < nums.size(); i++) {\n        ans = std::min(ans, nums[i] + minSubArraySum(nums.substr(1,\
    \ i - 1)));\n    }\n    return ans;", "    long ans = nums[0];\n    for (auto\
    \ i : nums) {\n        if (i > 0)\n            ans = min(ans, i + minSubArraySum(nums.subvec(i)));\n\
    \    }\n    return ans;", "    // write your code here\n    long ans = 0;\n  \
    \  int ln = nums.size();\n    if(ln == 0)\n        return 0;\n    if(ln == 1)\n\
    \        return nums[0];\n    long ans = nums[0];\n    for(int i=1; i<ln; i++)\n\
    \    {\n        ans = Math.min(ans, nums[i]+minSubArraySum(nums.erase(nums.begin()+i)));\n\
    \    }\n    return ans;", "    long min = LONG_MAX;\n    for (auto i : nums) {\n\
    \        if (i > 0) {\n            if (min > i) {\n                min = i;\n\
    \            }\n        }\n    }\n    return min;", "    long sum = nums[0];\n\
    \    long minSum = nums[0];\n    int nSize = 0;\n    for(int i = 1; i < nums.size();\
    \ ++i) {\n        long curSum = sum + nums[i];\n        if(minSum > curSum) {\n\
    \            minSum = curSum;\n        }\n        if(curSum > sum) {\n       \
    \     sum += curSum;\n        }\n        ++nSize;\n    }\n    return minSum;",
  "    // code here\n    std::stack<long long> stk;\n    long ans = 0;\n    // first\
    \ element in the stack\n    stk.push(0);\n    // for each element in the vector\n\
    \    for (long i = 0; i < nums.size(); i++) {\n        // if the current number\
    \ is not the first element\n        if (i != 0) {\n            // remove the first\
    \ element from the stack\n            stk.pop();\n        }\n        // if the\
    \ current number is the last element\n        if (i == nums.size() - 1) {\n  \
    \          // remove the last element from the stack\n            stk.pop();\n\
    \        }\n        // if the current number is smaller than the stack's current\
    \ element\n        if (nums[i] < stk.top()) {\n            // remove the last\
    \ element from the stack\n            stk.pop();\n        } else {\n         \
    \   // push the new element\n            stk.push(nums[i]);\n        }\n     \
    \   // add current stack's element to the answer\n        ans += stk.top();\n\
    \    }\n    return ans;", "  long ans = 0;\n  long min_sum = INT_MIN;\n  for (long\
    \ i = 0; i < nums.size(); ++i) {\n    for (long j = i; j < nums.size(); ++j) {\n\
    \      if (i != j) {\n        min_sum = min(min_sum, nums[j] + nums[i]);\n   \
    \   }\n    }\n    if (min_sum < 0) return -1;\n    if (min_sum > ans) ans = min_sum;\n\
    \    min_sum = INT_MIN;\n  }\n  return ans;", "    long sum = *std::max_element(nums.begin(),\
    \ nums.end()) + 1;\n    long sum1 = 0;\n    for (auto it : nums) {\n        sum1\
    \ += it;\n        if (sum1 < sum) {\n            sum = sum1;\n        }\n    }\n\
    \    return sum;", "    long result = 0;\n    // Find the minimum sum in sub-vector\
    \ with index i\n    // for 0 .. (nums.size() - 1)\n    // For each index i, do\
    \ following work:\n    // 1. Sub-vector with index 'i' is nums[i:(i + 2)] or\n\
    \    // 2. Sub-vector with index 'i' is nums[i: (i + 3)] or\n    // 3. Sub-vector\
    \ with index 'i' is nums[i: (i + 4)] or\n    // 4. Sub-vector with index 'i' is\
    \ nums[i: (i + 5)] or\n    // 5. Sub-vector with index 'i' is nums[i: (i + 6)]\
    \ or\n    // 6. Sub-vector with index 'i' is nums[i: (i + 7)] or\n    // 7. Sub-vector\
    \ with index 'i' is nums[i: (i + 8)] or\n    // 8. Sub-vector with index 'i' is\
    \ nums[i: (i + 9)] or\n    // 9. Sub-vector with index 'i' is nums[i: (i + 10)]\
    \ or\n    // 10. Sub-vector with index 'i' is nums[i: (i + 11)] or\n    // 11.\
    \ Sub-vector with index 'i' is nums[i: (i + 12)] or\n    // 12. Sub-vector with\
    \ index 'i' is nums[i: (i + 13)] or\n    // 13. Sub-vector with index 'i' is nums[i:\
    \ (i + 14)]\n    // We have 4 sub-vectors of nums, each with 2 elements\n    //\
    \ The minimum sum for index i is minimum of following sub-vector sum :\n    //\
    \ 1. minimumSum(nums[0:i]), minimumSum(nums[i:(i + 2)])\n    // 2. minimumSum(nums[0:i]),\
    \ minimumSum(nums[i: (i + 3)])\n    // 3. minimumSum(nums[0:i]), minimumSum(nums[i:\
    \ (i + 4)])\n    // 4. minimumSum(nums[0:i]), minimumSum(nums[i: (i + 5)])\n\n\
    \    // Check base cases\n    if (nums.size() == 0) {\n        return 0;\n   \
    \ }\n    // For all i with i < (nums.size() - 1), minimumSum(nums[0:i] + nums[i\
    \ + 1:(i + 2)])\n    long minimumSum(std::vector<long> &nums, long i, long j =\
    \ 1) {\n        if (j == nums.size()) {\n            return nums[i];\n       \
    \ }\n        return minimumSum(nums, i + 1, j + 1) + minimumSum(nums, i + 1, j\
    \ + 2);\n    }\n    // For all i with i < (nums.size() - 1)\n    for (int i =\
    \ 0; i < nums.size() - 1; i++) {\n        // Set starting index i and ending ",
  "    std::vector<long> numsCopy(nums);\n    sort(numsCopy.begin(), numsCopy.end());\n\
    \    long result = numsCopy[0];\n    for (long i = 1, n = numsCopy.size(); i <=\
    \ n; i++) {\n        result += min(nums[i] - nums[i - 1], numsCopy[i - 1] - nums[i]);\n\
    \    }\n    return result;", "    // code here\n    long long sum = 0;\n    for\
    \ (long long int i : nums) {\n        sum += i;\n    }\n    return sum;", "  \
    \  // write your code here\n    long ans = INT_MAX;\n    int n = nums.size();\n\
    \    for(int i = 0; i < n; ++i) {\n        int currSum = 0;\n        for(int j\
    \ = i; j < n; ++j) {\n            currSum += nums[j];\n            if(currSum\
    \ < ans)\n                ans = currSum;\n        }\n    }\n    return ans;",
  "    // Write your code here.\n    assert(nums.size() == nums.capacity());\n   \
    \ long sum = 0;\n    long min = std::numeric_limits<long>::max();\n    for (auto\
    \ i : nums) {\n        sum += i;\n        if (sum < min)\n            min = sum;\n\
    \    }\n    return min;", "  int n = nums.size();\n  long sum = 0;\n  for (int\
    \ i = 0; i < n; i++) {\n    sum += nums[i];\n  }\n\n  vector<int> v(n);\n  long\
    \ cur = 0;\n  for (int i = 0; i < n; i++) {\n    v[i] = nums[i] - cur;\n    cur\
    \ += v[i];\n  }\n  long ans = INT_MAX;\n  for (int i = 0; i < n; i++) {\n    ans\
    \ = min(ans, v[i] * sum + cur);\n  }\n\n  return ans;", "    long ans = LONG_MAX;\n\
    \    for (int i = 0; i < nums.size(); i++) {\n        int sum = 0;\n        sum\
    \ += nums[i];\n        while (sum >= nums[i]) {\n            sum += nums[sum -\
    \ nums[i]];\n            ans++;\n        }\n    }\n    return ans;", "  std::vector<long>\
    \ sub_num;\n  long min_sum = 0;\n  for (auto i = 0; i < nums.size(); i++) {\n\
    \    if (sub_num.size() == 0 || sub_num.back() <= nums[i]) {\n      sub_num.push_back(nums[i]);\n\
    \    } else {\n      min_sum = std::min(min_sum, sub_num.back() + nums[i]);\n\
    \      sub_num.pop_back();\n      sub_num.push_back(nums[i]);\n    }\n  }\n  if\
    \ (sub_num.empty()) {\n    min_sum = 0;\n  }\n  return min_sum;", "    // Your\
    \ code here\n    long min_sum = 0;\n    for(auto i=nums.begin();i<nums.end();i++){\n\
    \        long sum = 0;\n        for(auto j=i;j<nums.end();j++){\n            sum\
    \ += nums[j];\n        }\n        min_sum = std::min(min_sum, sum);\n    }\n \
    \   return min_sum;", "  if (nums.empty())\n    return 0;\n  long sum = 0;\n \
    \ long min = INT_MAX;\n  long index = 0;\n  for (auto &i : nums) {\n    sum +=\
    \ i;\n    if (sum < min) {\n      min = sum;\n      index = i;\n    }\n  }\n \
    \ return sum - min;", "  if (nums.size() == 0) return 0;\n  std::stack<long long>\
    \ stkStack;\n  stkStack.push(nums[0]);\n  long ans = nums[0];\n  for (size_t i\
    \ = 1; i < nums.size(); ++i) {\n    if (stkStack.top() < nums[i]) {\n      while\
    \ (stkStack.top() < nums[i]) stkStack.pop();\n    } else {\n      ans += nums[i];\n\
    \      while (stkStack.top() > nums[i]) stkStack.pop();\n    }\n    stkStack.push(nums[i]);\n\
    \  }\n  return ans;", "    // Complete this function\n    if(nums.size()==0)\n\
    \        return 0;\n    long minSoFar=nums[0];\n    for(long i=1; i<nums.size();\
    \ i++){\n        minSoFar=min(minSoFar,nums[i]);\n    }\n    return minSoFar;",
  "    if(nums.empty())\n        return 0;\n\n    // Get size of the sub-vector to\
    \ be calculated\n    long n = nums.size();\n    long minSum = *std::min_element(nums.begin(),\
    \ nums.end());\n    long currentSum = minSum;\n    std::vector<long> subVect;\n\
    \    // Create sub-vector with size equals to number of elements in the vector\
    \ nums\n    for(int i = 0; i < n; ++i)\n        subVect.push_back(nums[i]);\n\
    \    \n    // Iterate through the elements of the vector, if the element is less\
    \ than or equal to the\n    // currentSum, then decrease the currentSum\n    for(int\
    \ i = n - 1; i >= 0; --i) {\n        if(currentSum - subVect[i] < 0)\n       \
    \     currentSum -= subVect[i];\n        else\n            currentSum -= subVect[i]\
    \ + minSum;\n        subVect[i]++;\n    }\n    return currentSum;", "    long\
    \ min = INT_MAX;\n    long sum = 0;\n    for (long i = 0; i < nums.size(); i++)\
    \ {\n        sum += nums[i];\n        if (sum < min) {\n            min = sum;\n\
    \        }\n    }\n    return min;", "    long result = std::numeric_limits<long>::max();\n\
    \    for (auto &num : nums) {\n        result = std::min(result, num);\n    }\n\
    \    return result;", "    \n    // Your code goes here\n    \n    // Write your\
    \ code here\n    long min = INT_MIN;\n    long sum = 0;\n    for(long x : nums){\n\
    \        if(x >= 0) {\n            sum += x;\n            if(sum < min){\n   \
    \             min = sum;\n            }\n        }\n        else{\n          \
    \  sum -= x;\n            if(sum < min){\n                min = sum;\n       \
    \     }\n        }\n    }\n    \n    return min;", "    assert(nums.size() ==\
    \ 4);\n    long sum = 0;\n    long temp = nums[0] + nums[1] + nums[2] + nums[3];\n\
    \    for (int i = 0; i < nums.size(); i++) {\n        if (i != 3) {\n        \
    \    sum += nums[i];\n            temp = temp - nums[i];\n        }\n    }\n \
    \   return sum;", "    long ans = std::numeric_limits<long>::max();\n    for (long\
    \ i = 0; i < nums.size(); i++) {\n        for (long j = i + 1; j < nums.size();\
    \ j++) {\n            long res = nums[i] + nums[j];\n            if (res < ans)\
    \ {\n                ans = res;\n            }\n        }\n    }\n    return ans;",
  "    // O(n)\n    if (nums.size() < 1) {\n        return 0;\n    }\n    long min\
    \ = nums[0];\n    for (size_t i = 1; i < nums.size(); i++) {\n        min = std::min(min,\
    \ nums[i]);\n    }\n    return min;", "    // your code goes here\n    long min\
    \ = nums.front();\n    long sum = 0;\n    for(int i = 0; i <nums.size(); i++)\
    \ {\n        sum += nums[i];\n        if(sum < min) {\n            min = sum;\n\
    \        }\n    }\n    return min;", "    long ans = nums[0];\n    for(long i\
    \ = 1; i < nums.size(); i++) {\n        ans = min(ans, nums[i] + minSubArraySum(nums.substr(0,\
    \ i + 1)));\n    }\n    return ans;", "    long min = INT_MAX;\n    for (long\
    \ i = 0; i < nums.size(); i++) {\n        for (long j = i; j < nums.size(); j++)\
    \ {\n            if (nums[i] + nums[j] < min)\n                min = nums[i] +\
    \ nums[j];\n        }\n    }\n    return min;", "    if (nums.empty())\n     \
    \   return 0;\n    long ans = nums.front();\n    for (int i = 1; i < nums.size();\
    \ i++)\n        ans = std::min(ans, nums[i] + minSubArraySum(nums.substr(0, i)));\n\
    \    return ans;", "    long min = std::numeric_limits<long>::max();\n    for\
    \ (long i = 1; i < nums.size(); ++i) {\n        min = std::min(min, nums[i-1]\
    \ + nums[i]);\n    }\n    return min;", "    long ans = nums[0];\n    for ( int\
    \ i = 1; i < nums.size(); i++ ) {\n        for ( long j = 0; j < nums[i]; j++\
    \ ) {\n            ans = std::min( ans, nums[i] + nums[j] );\n        }\n    }\n\
    \    return ans;", "    int len = nums.size();\n    long low = 0, high = nums[len\
    \ - 1];\n    for (long i = len - 1; i >= 0; i--) {\n        low = std::min(low,\
    \ nums[i]);\n        high = std::max(high, nums[i]);\n    }\n    return low;",
  "    std::pair<long, long> min = std::make_pair(std::numeric_limits<long>::max(),\n\
    \                                             std::numeric_limits<long>::max());\n\
    \    for (auto i : nums) {\n        auto j = 0;\n        long subSum = 0;\n  \
    \      while (i[j] >= 0) {\n            subSum += i[j];\n            j++;\n  \
    \      }\n        if (subSum > min.second) {\n            min.second = subSum;\n\
    \            min.first = i;\n        }\n    }\n    return min.first;", "  long\
    \ minSum = nums[0];\n  for (long i : nums) {\n    if (i < 0) return minSum;\n\
    \    minSum = std::min(minSum, i);\n  }\n  return minSum;", "    long res = INT_MIN;\n\
    \    for (long i = 1; i < nums.size(); i++) {\n        res += nums[i];\n    }\n\
    \    for (long i = 1; i < nums.size(); i++) {\n        res -= nums[i];\n     \
    \   if (res < 0) {\n            res = -1;\n            break;\n        }\n   \
    \ }\n    return res;", "    long minimumSum = INT_MIN;\n    long sum = 0;\n  \
    \  long firstElem = nums[0];\n    long lastElem = nums[nums.size()-1];\n\n   \
    \ for (auto num : nums) {\n        sum = sum + num;\n        if (sum < minimumSum)\n\
    \            minimumSum = sum;\n    }\n\n    long start = firstElem;\n    long\
    \ end = lastElem;\n    long currentSum = firstElem;\n    int count = 1;\n    //\
    \ Loop through each of the sub-vectors summing up its elements.\n    for (auto\
    \ num : nums) {\n        if (currentSum + num < minimumSum)\n            currentSum\
    \ = currentSum + num;\n        sum += currentSum - currentSum;\n        if (sum\
    \ > minimumSum) {\n            minimumSum = sum;\n            start = currentSum;\n\
    \            end = currentSum + num;\n            count = 1;\n        }\n    \
    \    else {\n            currentSum += num;\n            count++;\n        }\n\
    \    }\n    return minimumSum;", "    long sum = 0;\n    for (auto i : nums) {\n\
    \        sum += i;\n    }\n    return sum;", "  long low = 0;\n  long high = nums.size()\
    \ - 1;\n  long mid = low + (high - low) / 2;\n  long bestSum = 0;\n  while (low\
    \ < high) {\n    long sum = nums[mid] + nums[low] + nums[high];\n    if (sum <\
    \ bestSum) {\n      bestSum = sum;\n    } else if (sum > bestSum) {\n      low\
    \ = mid + 1;\n      mid = low + (high - low) / 2;\n    } else {\n      high =\
    \ mid;\n      mid = low + (high - low) / 2;\n    }\n  }\n  return bestSum;", " \
    \ long min_sum = INT_MIN;\n  // write your code here\n  for (int i = 0; i < nums.size();\
    \ i++) {\n    int sum = nums[i] + nums[nums.size() - 1 - i];\n    min_sum = std::min(min_sum,\
    \ sum);\n  }\n  return min_sum;", "    if(nums.empty())\n        return 0;\n \
    \   long sum = 0;\n    for(long &i : nums)\n        sum += i;\n    // Reverse\
    \ the vector to decrement sum\n    // This way, if sum is incremented by i from\
    \ last element,\n    // then the current element must be decremented by i\n  \
    \  std::vector<long> rev;\n    rev.reserve(nums.size());\n    for(long i : nums)\n\
    \        rev.push_back(-i);\n    std::reverse(rev.begin(), rev.end());\n    while(!rev.empty())\
    \ {\n        sum -= rev[0];\n        rev.erase(rev.begin());\n    }\n    return\
    \ sum;", "    //Your code here\n    long ans = -1;\n    long long minSum = std::numeric_limits<long\
    \ long>::max();\n    for (size_t i = 0; i < nums.size(); i++) {\n        if (i\
    \ != 0) {\n            long long sum = 0;\n            for (size_t j = 0; j <\
    \ i; j++) {\n                sum += nums[j];\n            }\n            sum +=\
    \ nums[i];\n            minSum = std::min(minSum, sum);\n        }\n    }\n  \
    \  ans = minSum;\n    return ans;", "    // Write your code here.\n    int size\
    \ = nums.size();\n    long ans = -INT_MAX;\n    for (int i = 0; i < size; i++)\
    \ {\n        for (int j = i; j < size; j++) {\n            ans = std::min(ans,\
    \ nums[i] + nums[j]);\n        }\n    }\n    return ans;", "    long minSum =\
    \ std::numeric_limits<long>::max();\n    long sum = 0;\n    // Your code goes\
    \ here\n    for (long element : nums) {\n        sum += element;\n        minSum\
    \ = std::min(minSum, sum);\n    }\n    return minSum;", "  int n = nums.size();\n\
    \  long min = INT_MIN;\n  for (int i = 0; i < n; i++) {\n    for (int j = i +\
    \ 1; j < n; j++) {\n      long sum = nums[i] + nums[j];\n      if (sum < min)\
    \ {\n        min = sum;\n      }\n    }\n  }\n  return min;", "    // Write your\
    \ code here\n    long ans = nums[0];\n    long sum = 0;\n    for (int i = 1; i\
    \ < nums.size(); i++) {\n        sum += nums[i];\n        if (sum < ans) {\n \
    \           ans = sum;\n        }\n    }\n    return ans;", "  int n = nums.size();\n\
    \  assert(n >= 1);\n  if (n == 1) {\n    return nums[0];\n  }\n  long ans = std::numeric_limits<long>::max();\n\
    \  int max_idx = n;\n  for (int i = 1; i < n; ++i) {\n    long current_max = nums[i];\n\
    \    int idx;\n    for (idx = 0; idx < max_idx; ++idx) {\n      current_max +=\
    \ nums[idx];\n    }\n    if (current_max > ans) {\n      ans = current_max;\n\
    \      max_idx = idx;\n    }\n  }\n  return ans;", "    if (nums.empty()) {\n\
    \        return 0;\n    }\n    long ans = nums[0];\n    for (long i = 1; i < nums.size();\
    \ i++) {\n        long subAns = nums[i] + ans;\n        if (subAns < ans) {\n\
    \            ans = subAns;\n        }\n    }\n    return ans;", "    int ans =\
    \ INT_MIN;\n    for (auto &i : nums) {\n        ans = min(ans, sumSubVector(nums,\
    \ i, 0));\n    }\n    return ans;", "    // Your code here\n    if(nums.size()==0){\n\
    \        return 0;\n    }\n\n    long low = nums.front();\n    long mid = nums.front();\n\
    \    long high = nums.front();\n\n    for(long i=1;i<nums.size();i++){\n     \
    \   mid=((low+high)/2)+nums[i];\n        if(nums[i]>mid){\n            high=mid;\n\
    \        }else{\n            low=mid;\n        }\n    }\n    \n    return low+high;",
  "    // Write your code here\n    long long min_sum = 0;\n    for (long i = 0; i\
    \ < nums.size(); i++) {\n        min_sum += nums[i];\n    }\n    return min_sum;",
  "  int n = nums.size();\n  long ans = INT_MIN;\n\n  // If vector is empty\n  if\
    \ (n == 0)\n    return ans;\n\n  vector<long> left(n - 1, nums[0]);\n  vector<long>\
    \ right(n, nums[0]);\n  int l = 0;\n  int r = 0;\n\n  while(l < n && r < n) {\n\
    \    if(left[l] > right[r])\n      right[r] = right[r] + nums[r];\n    else\n\
    \      left[l] = left[l] - nums[l];\n    l++;\n    r++;\n  }\n\n  for(int i =\
    \ 1; i <= n; i++) {\n    if(left[n - i] < right[i])\n      ans = min(ans, left[n\
    \ - i] + right[i]);\n  }\n\n  return ans;", "  // Write your code here\n  assert(nums.size()\
    \ > 1);\n  long minSum = nums[0];\n  for (size_t i = 1; i < nums.size(); i++)\
    \ {\n    minSum = std::min(minSum, nums[i]);\n  }\n  return minSum;", "  long\
    \ ans = 0, l = 0, h = nums.size();\n  while (l < h) {\n    long mid = (l + h)\
    \ / 2;\n    long curr = minSubArraySum(nums.subvector(mid, 2));\n    long left\
    \ = minSubArraySum(nums.subvector(mid + 1, 2));\n    long right = minSubArraySum(nums.subvector(mid,\
    \ 2));\n    ans = std::min(std::min(std::min(curr, left), right), ans);\n    l\
    \ = mid + 1;\n  }\n  return ans;", "  // Write your code here\n  long long min\
    \ = std::numeric_limits<long long>::max();\n  long long max = std::numeric_limits<long\
    \ long>::min();\n  int count = 1;\n  for(auto& num: nums){\n    min = std::min(min,\
    \ num);\n    max = std::max(max, num);\n    count ++;\n  }\n  if(count > 0)\n\
    \    min = std::min(min, count*max);\n  return min;", "    long long ans = std::numeric_limits<long\
    \ long>::max();\n    for (long long i = 0; i < nums.size(); i++) {\n        for\
    \ (long long j = i+1; j < nums.size(); j++) {\n            ans = std::min(ans,\
    \ nums[i] + nums[j]);\n        }\n    }\n    return ans;", "    long sum = 0;\n\
    \    long minSum = LONG_MAX;\n    for (long i = 0; i < nums.size(); i++) {\n \
    \       if (nums[i] > 0) {\n            sum += nums[i];\n            if (minSum\
    \ > sum)\n                minSum = sum;\n        }\n    }\n    return minSum;",
  "    // O(nlogn): time complexity is O(nlogn).\n    // Find length of array\n  \
    \  int n = nums.size();\n    long min_sum = std::numeric_limits<long>::max();\n\
    \    // O(n): time complexity is O(n).\n    for (int i = 0; i < n; i++) {\n  \
    \      long sub_sum = 0;\n        // O(nlogn): time complexity is O(nlogn).\n\
    \        for (int j = 0; j < i; j++) {\n            // O(n): time complexity is\
    \ O(n).\n            sub_sum += nums[j] + nums[i];\n        }\n        // O(1):\
    \ time complexity is O(1).\n        min_sum = std::min(min_sum, sub_sum);\n  \
    \  }\n    return min_sum;", "  // Write your code here\n  long min_sum = INT_MAX,\
    \ sum = 0;\n  for (auto& e : nums) {\n    sum += e;\n    min_sum = std::min(min_sum,\
    \ sum);\n  }\n  return min_sum;", "    std::sort(nums.begin(), nums.end());\n\
    \    // Sorted subarray starts from 0 to n/2, and ends at n/2 to n.\n    // So\
    \ we just need to find the difference between first and last element, and min\
    \ between them\n    long min = nums[0] - nums[nums.size() - 1];\n    // Start\
    \ traversing from n/2 to n\n    for (int i = 1; i < nums.size(); i++) {\n    \
    \    // Calculate the sum of remaining elements\n        long sum = 0;\n     \
    \   for (int j = i; j < nums.size(); j++) {\n            sum += nums[j];\n   \
    \     }\n        // Find the minimum between current sum and minimum found before\n\
    \        if (sum < min) {\n            min = sum;\n        }\n    }\n    return\
    \ min;", "  // Initialize sum \n  long sum = 0;\n  // Iterate through each element\
    \ in the array\n  for (int i = 0; i < nums.size(); i++) {\n    // If this element\
    \ is not in the array, ignore it\n    if (i == nums.size() - 1) break;\n    //\
    \ Find the sum of the element to its right \n    sum += nums[i];\n    // Update\
    \ the sum\n    nums[i + 1] -= nums[i];\n  }\n  return sum;", "  assert(nums.size()\
    \ > 0);\n  std::vector<long> res;\n  long minSum = nums[0];\n  for (size_t i =\
    \ 0; i < nums.size(); ++i) {\n    assert(nums[i] > 0);\n    long curSum = minSum;\n\
    \    for (size_t j = 0; j < i; ++j) {\n      assert(nums[j] > 0);\n      curSum\
    \ += nums[j];\n    }\n    if (curSum < minSum) {\n      res.clear();\n      minSum\
    \ = curSum;\n    } else {\n      res.push_back(curSum);\n    }\n  }\n  assert(minSum\
    \ > 0);\n  return minSum;", "    // Write your code here\n    long sum=0;\n  \
    \  long minimum=nums[0];\n    long count=0;\n    for(long i=1;i<nums.size();i++)\
    \ {\n        sum+=nums[i];\n        minimum=std::min(minimum,sum);\n        count=std::min(count,nums[i]);\n\
    \    }\n    return minimum;", "  // Your code here\n  long res = 0;\n  std::stack<long>\
    \ st;\n  for (long i = 0; i < nums.size(); ++i) {\n    while (!st.empty() && st.top()\
    \ > nums[i]) {\n      st.pop();\n    }\n    if (st.empty()) {\n      st.push(nums[i]);\n\
    \    } else {\n      st.push(std::min(nums[i], st.top()));\n    }\n    res +=\
    \ st.top();\n    st.pop();\n  }\n  return res;", "    int n = nums.size();\n \
    \   if(n < 2) return 0;\n    long s = 0;\n    for(int i = 0; i != n; ++i) {\n\
    \        s += nums[i];\n    }\n    return s;", "  assert(nums.size() > 0);\n \
    \ long ans = INT_MIN;\n  for (auto num : nums) {\n    long tmp = num;\n    ans\
    \ = std::min(ans, tmp + minSubArraySum(nums));\n  }\n  return ans;", "\tassert(nums.size()\
    \ > 0);\n\tlong ans = nums[0];\n\tfor(size_t i = 1; i < nums.size(); ++i) {\n\t\
    \tlong sum = nums[i] + ans;\n\t\tans = std::min(sum, ans);\n\t}\n\treturn ans;",
  "    int sum = nums[0];\n    for (auto i : nums) {\n        if (i <= sum) sum =\
    \ i;\n    }\n    return sum;", "    if (nums.empty()) {\n        return 0;\n \
    \   }\n    int size = nums.size();\n    int start = 0;\n    long res = 0;\n  \
    \  while (start < size) {\n        long sum = 0;\n        for (int i = start;\
    \ i < size; i++) {\n            if (nums[i] > 0) {\n                sum += nums[i];\n\
    \            }\n        }\n        if (sum < res) {\n            res = sum;\n\
    \            start = i;\n        }\n    }\n    return res;", "    // Complete\
    \ this function\n    \n    // Write your code here\n    \n    assert(nums.size()>0);\n\
    \    long sum=0,minSum=nums[0];\n    long curSum=0,curMin=nums[0];\n    for(long\
    \ i=1;i<nums.size();i++) {\n        curSum=nums[i-1]+curSum;\n        curMin=minSum+curMin;\n\
    \        if(curSum<0) {\n            sum=-sum;\n            curSum=abs(curSum);\n\
    \            curMin=-abs(curMin);\n        } else {\n            sum+=curSum;\n\
    \            curMin=minSum+curMin;\n        }\n    }\n    return sum;", "    assert(nums.size()\
    \ > 0);\n    long ans = nums.front();\n    for (size_t i = 0; i < nums.size()\
    \ - 1; i++) {\n        ans = std::min(ans, nums[i] + nums[i + 1]);\n    }\n  \
    \  return ans;", "    long minSum = (nums.empty() ? 0 : nums.front());\n    for\
    \ (auto it1 = nums.begin(), it2 = it1 + 1; it1 != nums.end(); ++it1, ++it2) {\n\
    \        long diff = *it1 - *it2;\n        minSum = std::min(minSum, std::abs(diff)\
    \ + diff);\n    }\n    return minSum;", "  // Complete the function, but you cannot\
    \ use any standard library\n  // function or macros.\n  // You can use any data\
    \ structure you want, but the complexity\n  // should be constant.\n  long min\
    \ = nums[0], sum = 0, max_sum = -1;\n  for (long n: nums)\n    sum += n;\n  max_sum\
    \ = sum;\n  for (long i: nums) {\n    if (max_sum < 0)\n      max_sum = i;\n \
    \   else if (max_sum == i)\n      continue;\n    else \n      max_sum -= i;\n\
    \  }\n  return min;", "    // your code goes here\n    long min = nums.front();\n\
    \    long sum = 0;\n    int pos = 0;\n    for (int i = 1; i < nums.size(); i++)\
    \ {\n        sum += nums[i];\n        if (min > sum) {\n            pos = i;\n\
    \            min = sum;\n        }\n    }\n    return pos + 1;", "    std::vector<bool>\
    \ vis(nums.size(), false);\n    long ans = nums[0]; // 0th element can be ignored\
    \ as it is already the minimum sum\n    long ant = nums[0];\n    long sum = nums[0];\n\
    \    long cur_sum = 0;\n\n    // find minimum sum\n    for (long i = 0; i < nums.size();\
    \ ++i) {\n        vis[i] = true;\n        for (long j = 0; j < nums.size(); ++j)\
    \ {\n            if (!vis[j]) {\n                vis[j] = true;\n            \
    \    sum += nums[j];\n                cur_sum += nums[j];\n            }\n   \
    \     }\n        if (cur_sum < ans) {\n            ans = cur_sum;\n        }\n\
    \    }\n\n    // handle corner case where all numbers are negative\n    if (ans\
    \ < 0) {\n        ans = ans * -1;\n    }\n\n    return ans;", "  int n = nums.size();\n\
    \  long sum = 0;\n  for (int i = 0; i < n; ++i) {\n    for (int j = i + 1; j <\
    \ n; ++j) {\n      sum += nums[j];\n      if (sum > 0) {\n        break;\n   \
    \   }\n    }\n  }\n  return sum;", "    int n = (int)nums.size();\n    long sum\
    \ = 0, min = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int j =\
    \ i; j < n; j++) {\n            sum += nums[i] + nums[j];\n            if (sum\
    \ < min) {\n                min = sum;\n            }\n        }\n    }\n    return\
    \ min;", "    long sum = 0, cur = 0, n = nums.size();\n    // We will maintain\
    \ three sub-vectors.\n    // 1. a sub-vector which consists of elements that are\
    \ less than current number\n    // 2. a sub-vector which consists of elements\
    \ that are greater than current number\n    // 3. a sub-vector consists of the\
    \ numbers which are smaller than current number.\n    std::vector<long> less_than_cur(nums.begin(),\
    \ nums.begin() + cur), larger_than_cur(nums.begin() + cur, nums.end());\n    //\
    \ For every number we encounter in the current sub-vector we add it to sum.\n\
    \    for (long i = 0; i < n; i++) {\n        sum += nums[i];\n        // If the\
    \ number is greater than the number we are looking at, add it to sub-vector larger_than_cur.\n\
    \        if (nums[i] >= cur) {\n            larger_than_cur.push_back(cur);\n\
    \        }\n        // If the number is less than the number we are looking at,\
    \ add it to sub-vector less_than_cur.\n        if (nums[i] <= cur) {\n       \
    \     less_than_cur.push_back(cur);\n        }\n        cur += nums[i];\n    }\n\
    \    // Return the answer if we have one such sub-vector.\n    if (less_than_cur.size()\
    \ == 1 && larger_than_cur.size() == 1) {\n        return sum - least_difference(less_than_cur,\
    \ larger_than_cur);\n    }\n    // Recurse if there are two or more sub-vectors.\n\
    \    // We know that our current sub-vector has size 2, so we have two options.\n\
    \    // 1. Add the smallest and largest numbers to sum to get the answer.\n  \
    \  // 2. Add the largest number and add it to the answer (which will add it to\
    \ the next sub-vector recursively).\n    // If there were three or more sub-vectors,\
    \ we can use the same logic as before.\n    return minSubArraySum(larger_than_cur)\
    \ + minSubArraySum(less_than_cur);", "    assert(nums.size() <= 100000);\n   \
    \ long min_sum = 0;\n    for (size_t i = 0; i < nums.size(); i++) {\n        long\
    \ sum = 0;\n        for (size_t j = i; j < nums.size(); j++) {\n            sum\
    \ += nums[j];\n        }\n        if (sum >= min_sum) {\n            min_sum =\
    \ sum;\n        }\n    }\n    return min_sum;", "    long minSum = LONG_MAX;\n\
    \    long minIndex = -1;\n    long sum = 0;\n    for(int i=0; i<nums.size(); i++)\
    \ {\n        sum += nums[i];\n        if(sum < minSum) {\n            minSum =\
    \ sum;\n            minIndex = i;\n        }\n    }\n    assert(minIndex >= 0);\n\
    \    return minSum;", "  std::sort(nums.begin(), nums.end());\n  long leftSum\
    \ = 0;\n  long rightSum = 0;\n  long currentSum = 0;\n  long curIndex = nums.size()\
    \ - 1;\n  long minSum = nums.front();\n  assert(!nums.empty());\n  while (curIndex\
    \ >= 0) {\n    currentSum = nums.at(curIndex) + leftSum;\n    leftSum = currentSum;\n\
    \    curIndex--;\n    assert(!nums.empty());\n    assert(nums.at(curIndex) >=\
    \ nums.at(0));\n    currentSum += nums.at(curIndex) - nums.at(0);\n    rightSum\
    \ = currentSum;\n  }\n  return minSum;", "    long min_sum = *std::min_element(nums.begin(),\
    \ nums.end()); //find the min element in nums\n    std::vector<long>::iterator\
    \ it_min = std::min_element(nums.begin(), nums.end()); //find the min element\
    \ in nums\n    while (it_min != nums.end() && it_min->first == min_sum) {\n  \
    \      min_sum = it_min->second;\n        it_min = std::min_element(++it_min,\
    \ nums.end());\n    }\n    return min_sum;", "  long sum = std::numeric_limits<long>::max();\n\
    \  assert(nums.size() != 0);\n\n  for (int i = 0; i < nums.size(); i++) {\n  \
    \  sum += nums[i];\n    for (int j = i; j < nums.size(); j++)\n      sum -= nums[j];\n\
    \  }\n  return sum;", "    long minSum = LONG_MIN;\n    long long numSum = 0;\n\
    \    for (long long n : nums) {\n        numSum += n;\n        if (numSum < minSum)\
    \ {\n            minSum = numSum;\n        }\n    }\n    return minSum;", "  \
    \  auto it = std::min_element(nums.begin(), nums.end()); // O(n)\n    return *it\
    \ + std::accumulate(nums.begin(), it, 0ll);", "    long ans = 0;\n    for (int\
    \ i = 1; i < nums.size(); i++) {\n        ans += nums[i] - nums[i - 1];\n    }\n\
    \    return ans;", "    // Write your code here\n    long min_sum = nums.front();\n\
    \    long sum = 0;\n    for(long i : nums) {\n        sum += i;\n        if(sum\
    \ < min_sum) min_sum = sum;\n    }\n    return min_sum;", "    long ans = nums.front();\n\
    \    for(long i = nums.size() - 1; i >= 0; i--){\n        ans = std::min(ans,\
    \ nums[i] + minSubArraySum(nums.substr(i + 1)));\n    }\n    return ans;", " \
    \   assert(nums.size() == 1 || nums.size() == nums.size() + 1);\n    return nums[0]\
    \ > 0 ? nums[0] : nums[nums.size()-1];", "    // Write your code here\n    long\
    \ sum = 0;\n    for (long i : nums) {\n        sum += i;\n    }\n    return sum;",
  "  long ans = 0;\n  long min = INT_MAX;\n  for (auto &e : nums) {\n    ans += e;\n\
    \    min = std::min(min, e);\n  }\n  return ans - min;", "    auto max_end = std::max_element(nums.begin(),\
    \ nums.end());\n    auto min_end = std::min_element(nums.begin(), nums.end());\n\
    \    auto max_begin = std::max_element(max_end + 1, min_end);\n    auto min_begin\
    \ = std::min_element(min_end + 1, max_end);\n    return (max_begin + min_begin\
    \ - 1) / 2;", "    if (nums.empty())\n        return 0;\n    std::stack<long>\
    \ stk;\n    long ans = nums[0];\n    stk.push(ans);\n    for(long i = 1; i < nums.size();\
    \ ++i) {\n        stk.push(nums[i] - stk.top());\n        if (stk.top() < ans)\n\
    \            ans = stk.top();\n        stk.pop();\n    }\n    return ans;", "\t\
    assert(nums.size() > 0);\n\tstd::vector<long> nums_copy;\n\tfor (auto i : nums)\
    \ {\n\t\tnums_copy.push_back(i);\n\t}\n\tlong min = INT_MAX;\n\tlong max_val =\
    \ INT_MIN;\n\tlong sum = 0;\n\tfor (long i = 0; i < nums_copy.size(); i++) {\n\
    \t\tlong val = nums_copy[i];\n\t\tif (val < 0) val = -val;\n\t\tif (val > max_val)\
    \ max_val = val;\n\t\tsum += val;\n\t}\n\tfor (long i = 0; i < nums_copy.size();\
    \ i++) {\n\t\tlong val = nums_copy[i];\n\t\tif (val < 0) val = -val;\n\t\tif (val\
    \ > min) min = val;\n\t}\n\treturn sum - max_val;", "    // Your code here\n \
    \   \n    long minSum = nums[0];\n    long currSum = 0;\n    \n    for (auto i\
    \ = 0; i < nums.size(); i++) {\n        currSum = currSum + nums[i];\n       \
    \ if (currSum < minSum) {\n            minSum = currSum;\n        }\n    }\n \
    \   return minSum;", "    long n = nums.size();\n    long result = 0;\n    for\
    \ (int i = 0; i < n; i++) {\n        result += nums[i];\n    }\n    return n;",
  "\t// Write your code here\n    long n = nums.size();\n    long min = LONG_MAX;\n\
    \    long sum = 0;\n\t\n    for(int i=0;i<n;i++){\n        sum+=nums[i];\n   \
    \     if(sum<min){\n            min=sum;\n        }\n    }\n    return min;",
  "    int n = nums.size();\n    long res = 0;\n    // Sum until the last index\n\
    \    for (int i = 0; i < n; ++i) {\n        long currSum = nums[i];\n        for\
    \ (int j = i; j < n; ++j) {\n            currSum += nums[j];\n        }\n    \
    \    res = min(res, currSum);\n    }\n    return res;", "    // Write your code\
    \ here\n    long long minSum = INT_MAX;\n    for(long long i = 0; i < nums.size();\
    \ i++) {\n        long long sum = nums[i];\n        for(long long j = i; j < nums.size();\
    \ j++) {\n            sum += nums[j];\n            assert(sum > 0);\n        \
    \    if(sum < minSum)\n                minSum = sum;\n        }\n    }\n    return\
    \ minSum;", "  long ans = nums.front();\n  for (auto i : nums) {\n    // i >=\
    \ ans => ans is infinity\n    while (i >= ans)\n      ans = std::numeric_limits<long>::max();\n\
    \    // i + ans < i\n    ans += i;\n  }\n  return ans;", "  // Your code here\n\
    \  assert(nums.size() > 0);\n  long ans = nums[0];\n  long sum = 0;\n  for (long\
    \ i : nums) {\n    sum += i;\n    if (sum < ans) {\n      ans = sum;\n    }\n\
    \  }\n  return ans;", "    long result = 0;\n    for (long long i : nums) {\n\
    \        result += i;\n    }\n\n    return std::min(result, std::numeric_limits<long\
    \ long>::max());", "    // write your code here\n    long ans=0;\n    for(size_t\
    \ i = 0; i< nums.size(); i++){\n        ans += nums[i];\n    }\n    return ans;",
  "    // base case\n    if (nums.size() == 0 || nums.size() == 1) {\n        return\
    \ nums[0];\n    }\n\n    // construct initial min value\n    long min = std::numeric_limits<long>::max();\n\
    \n    // loop through the subArray\n    for (size_t i = 0; i < nums.size() - 1;\
    \ i++) {\n        // add current element and all to the min\n        min = std::min(min,\
    \ nums[i] + minSubArraySum(nums.begin() + i + 1, nums.begin() + nums.size() -\
    \ 1));\n    }\n\n    // return the final min\n    return min;", "  if (nums.empty())\
    \ return 0;\n  if (nums.size() == 1) return nums.front();\n  std::vector<long>\
    \ smallerSums(nums.size(), 0);\n  for (size_t i = 1; i < nums.size(); ++i) {\n\
    \    long leftSum = nums[i - 1] + nums[i - 1];\n    long rightSum = nums[i] +\
    \ nums[i];\n    smallerSums[i] = std::min(leftSum, rightSum);\n  }\n  return smallerSums[0];",
  "    if(nums.empty())\n        return 0;\n    if(nums.size() == 1)\n        return\
    \ nums[0];\n    long sum = 0;\n    for(auto i = nums.begin(); i != nums.end();\
    \ ++i) {\n        auto it = i;\n        for(auto j = (i + 1); j != nums.end();\
    \ ++j) {\n            sum += (*j);\n            it = j;\n        }\n        if(sum\
    \ < 0)\n            sum = 0;\n    }\n    return sum;", "    // Your code here\n\
    \    long min = INT_MAX;\n    int start = 0, end = 0;\n    long sum = 0;\n   \
    \ while (start < nums.size()) {\n        end = 0;\n        while (end < nums.size()\
    \ && nums[start] <= nums[end])\n            end++;\n        sum += nums[start];\n\
    \        sum += nums[end];\n        if (sum < min)\n            min = sum;\n \
    \       sum -= nums[end];\n        start = end;\n    }\n    return min;", "  \
    \  if (nums.empty()) {\n        return 0;\n    }\n    long ans = nums[0];\n  \
    \  for (long i = 0; i < nums.size() - 1; i++) {\n        long min_sum = ans;\n\
    \        for (long j = i + 1; j < nums.size(); j++) {\n            min_sum +=\
    \ nums[j];\n        }\n        ans = min(ans, min_sum);\n    }\n    return ans;",
  "    // Your code here\n    long minSum = -10000;\n    long sum = 0;\n    for(long\
    \ i = 0;i < nums.size();++i)\n    {\n        sum += nums[i];\n        if(minSum\
    \ <= sum)\n        {\n            minSum = sum;\n        }\n    }\n    return\
    \ minSum;", "    // Code here\n    \n    long minSoFar = 0;\n    long min = std::numeric_limits<long>::max();\n\
    \    long sumOfMin = std::numeric_limits<long>::max();\n    \n    for (auto i\
    \ : nums) {\n        if (i > sumOfMin) {\n            minSoFar = sumOfMin;\n \
    \           min = i;\n            sumOfMin = i;\n        }\n        \n       \
    \ else if (i < sumOfMin) {\n            if (sumOfMin < i) {\n                minSoFar\
    \ = sumOfMin;\n                min = i;\n                sumOfMin = i;\n     \
    \       }\n            else {\n                minSoFar += i;\n              \
    \  sumOfMin += i;\n            }\n        }\n    }\n    \n    return minSoFar;",
  "  long ans = INT_MIN;\n  // Write your code here\n  long index = 0;\n  long minSum\
    \ = 0;\n  long leftSum = INT_MIN;\n  long rightSum = INT_MIN;\n  for (long i :\
    \ nums) {\n    if (i == 0) {\n      minSum = i;\n    }\n    else if (i == -1)\
    \ {\n      rightSum = i;\n    }\n    else if (i == -2) {\n      leftSum = i;\n\
    \    }\n    else {\n      leftSum = leftSum + i;\n      rightSum = rightSum +\
    \ i;\n    }\n    minSum = minSum + leftSum;\n    minSum = minSum + rightSum;\n\
    \  }\n  ans = ans + minSum;\n  return ans;", "    long ans = INT_MAX;\n    long\
    \ ans_idx = 0;\n    for (int i = 0; i < nums.size(); i++)\n        ans = min(ans,\
    \ nums[i]);\n    int left_cnt = 0;\n    for (int i = 1; i < nums.size(); i++)\
    \ {\n        long sum = nums[i] + nums[i - 1];\n        if (sum < nums[i - 1])\
    \ {\n            ans = min(ans, nums[i] - sum);\n            ans_idx = i;\n  \
    \      }\n        if (sum > ans + nums[i - 1]) {\n            ans = min(ans, nums[i\
    \ - 1] - sum);\n            ans_idx = i;\n        }\n    }\n    return ans;",
  "    long result = 0;\n    long min_sum = std::numeric_limits<long>::max();\n  \
    \  long sum = 0;\n    long n = nums.size();\n    // Check all combinations\n \
    \   for(int i = 0; i < n; ++i) {\n        sum += nums[i];\n        if(sum < min_sum)\
    \ {\n            min_sum = sum;\n            result = i;\n        }\n    }\n \
    \   return result;", "    int l = 0, r = nums.size() - 1;\n    long ans = nums[0];\n\
    \    while (r - l > 1) {\n        long mid = (l + r) / 2;\n        ans = std::min(ans,\
    \ std::max(nums[mid], nums[mid + 1]));\n        l = mid + 1;\n        r = mid\
    \ - 1;\n    }\n    return ans;", "  if (nums.empty()) {\n    return 0; // empty\
    \ vector cannot have sub-vector\n  }\n  std::vector<long> temp(nums.begin(), nums.begin()\
    \ + nums.size() - 1);\n  long sum = temp[0]; // sum of first element and last\
    \ element\n  for (long i = 1, j = 1; i < nums.size(); i++, j++) {\n    temp[i]\
    \ = temp[j] + nums[i];\n    sum += temp[i];\n  }\n  return sum;", "    // Sorting\
    \ numbers in ascending order\n    std::sort(nums.begin(), nums.end());\n    //\
    \ Checking for first number larger than 1\n    if (nums[0] > 1)\n        return\
    \ std::numeric_limits<long>::max();\n    // Storing subvector sum\n    long sum\
    \ = 0;\n    // Storing first number\n    long num1 = nums[0];\n    // Storing\
    \ index at which minimum sum occurs\n    long i = 0;\n    // Traversing the array\
    \ from right to left\n    while (i < nums.size()) {\n        // Sum of all previous\
    \ subvectors \n        long j = i;\n        while (j < nums.size() && nums[j]\
    \ < num1 + nums[j - 1])\n            ++j;\n        // Subvector sum so far\n \
    \       sum += nums[j] - num1;\n        // Current number \n        num1 = nums[j];\n\
    \        // Updating index\n        i = j - 1;\n    }\n    return sum;", "   \
    \ std::vector<long> leftSums = std::vector<long>({nums[0]});\n    std::vector<long>\
    \ rightSums = std::vector<long>({nums[0]});\n    std::vector<long> sums = std::vector<long>({nums[0]});\n\
    \    // If there are no numbers, just return 0\n    if (nums.size() == 0)\n  \
    \      return 0;\n    // Sum all numbers in the right side\n    for (long i =\
    \ 1;i < nums.size();i++) {\n        rightSums[i] += nums[i];\n    }\n    // If\
    \ there are no numbers on the right side, just return 0\n    if (rightSums[0]\
    \ == 0)\n        return 0;\n    long leftSum = 0;\n    // Sum all numbers in the\
    \ left side\n    for (long i = 0;i < nums.size();i++) {\n        leftSum += nums[i];\n\
    \        leftSums.push_back(leftSum);\n    }\n    // If there are no numbers on\
    \ the left side, just return 0\n    if (leftSum == 0)\n        return 0;\n   \
    \ // The minimum sum is the sum of all numbers from the left side\n    long minSum\
    \ = leftSums[0];\n    // Sum the rest of the numbers from the left side\n    for\
    \ (long i = 0; i < leftSums.size();i++) {\n        sums[i] = leftSums[i] - leftSums[i]\
    \ - rightSums[i];\n        // If the sum doesn't change this iteration, update\
    \ the min sum\n        if (sums[i] != 0) {\n            if (sums[i] < minSum)\
    \ {\n                minSum = sums[i];\n            }\n        }\n    }\n    //\
    \ If there are still numbers on the left side, return the min sum found so far\n\
    \    for (long i = 0;i < leftSums.size();i++) {\n        if (leftSums[i] == 0)\n\
    \            return minSum;\n        if (minSum > 0)\n            minSum = sums[i]\
    \ - leftSums[i];\n    }\n    // If there are no numbers left, return the min sum\
    \ found so far\n    return minSum;", "    std::vector<long> numsCopy = nums;\n\
    \    if (nums.size() == 0)\n        return 0;\n    long ans = numsCopy[0];\n \
    \   for (long i = 1; i < numsCopy.size(); i++)\n        ans += numsCopy[i];\n\
    \    return ans;", "    long min = std::numeric_limits<long>::max();\n    int\
    \ sum = 0;\n    // The first and last elements of the list are ignored.\n    for\
    \ (int i = 0; i < nums.size() - 1; i++) {\n        sum += nums[i];\n        //\
    \ Ignore elements which were not selected.\n        if (sum < min)\n         \
    \   min = sum;\n    }\n    // The last elements of the list are ignored.\n   \
    \ for (int i = nums.size() - 2; i >= 0; i--) {\n        sum += nums[i];\n    \
    \    if (sum < min)\n            min = sum;\n    }\n    return min;", "    //\
    \ Your code here\n    long minSum = nums[0];\n    long sum = 0;\n    for (long\
    \ i = 1; i < nums.size(); i++) {\n        sum = sum + nums[i];\n        if (sum\
    \ < minSum) {\n            minSum = sum;\n        }\n    }\n    return minSum;",
  "  long ans = 0;\n  for (long i = 0; i < nums.size(); i++) {\n    long j = (i +\
    \ 1) % nums.size();\n    long k = nums[i] + nums[j];\n    if (k > ans)\n     \
    \ ans = k;\n  }\n  return ans;", "    if (nums.size() <= 1)\n        return nums.front();\n\
    \    std::vector<long> v1(nums);\n    v1.pop_back();\n    long minValue = v1.front();\n\
    \    long minSum = minValue;\n    std::vector<long> v2(nums);\n    v2.pop_back();\n\
    \    v2.pop_back();\n    long maxSum = 0;\n    for (long i = 2; i < v2.size();\
    \ i++) {\n        long sum = (v1[i] + v2[i] + v1[i - 1] + v2[i - 1] + v1[i] +\
    \ v2[i + 1] + v1[i - 1] + v2[i + 1] + v1[i] + v2[i - 1] + v1[i + 1] + v2[i - 1])\n\
    \                / (2 * i);\n        if (sum < minSum) {\n            minSum =\
    \ sum;\n        }\n        if (sum > maxSum) {\n            maxSum = sum;\n  \
    \      }\n        v1.pop_back();\n        v2.pop_back();\n    }\n    return minSum;",
  "    int n = nums.size();\n    long long min_sum = std::numeric_limits<long long>::max();\n\
    \    long long sum = 0;\n    for (int i = 1; i <= n; i++) {\n        sum += nums[i\
    \ - 1];\n        min_sum = std::min(min_sum, sum);\n    }\n    return min_sum;",
  "    assert(nums.size() != 0);\n    int size = nums.size();\n    if (size == 1)\
    \ return nums[0];\n    std::vector<long> partialSum = nums;\n    partialSum.push_back(partialSum[0]);\n\
    \    // Find the maximum sub-array sum.\n    while (partialSum.size() > 1) {\n\
    \        partialSum[1] = partialSum[1] + partialSum[0];\n        partialSum.pop_back();\n\
    \        partialSum.push_back(partialSum[0]);\n    }\n    return partialSum[0];",
  "\tlong res = std::numeric_limits<long>::max();\n\tfor (auto x : nums)\n\t\tres\
    \ = std::min(res, x + x);\n\treturn res;", "  // Your code goes here\n  int n\
    \ = nums.size();\n  long long sum = 0;\n  for (int i=0; i<n; i++){\n    for (int\
    \ j=0; j<n; j++){\n      if (i+1 < n && j+1 < n){\n        sum+=nums[j+1]-nums[i+1];\n\
    \        sum+=nums[i+1]-nums[j];\n      }\n      sum+=nums[j];\n    }\n  }\n \
    \ return sum;", "\tassert(nums.size() > 0);\n\tstd::vector<long> ans;\n\tlong\
    \ sum = 0;\n\tfor (auto &num: nums) {\n\t\tsum += num;\n\t\tans.push_back(num);\n\
    \t}\n\tfor (auto &num: ans) {\n\t\tif (sum < 0)\n\t\t\tsum *= -1;\n\t}\n\treturn\
    \ ans.front();", "  // Your code here\n  int n = nums.size();\n  std::vector<bool>\
    \ visited(n, false);\n  long result = 0;\n  long cur = 0;\n  visited[0] = true;\n\
    \  for (int i = 1; i < n; i++) {\n    if (!visited[i]) {\n      visited[i] = true;\n\
    \      cur = i;\n      while (cur != 0) {\n        if (cur == n - 1) {\n     \
    \     result += nums[cur];\n          break;\n        } else {\n          result\
    \ += nums[cur] + nums[cur + 1];\n          cur += 2;\n        }\n      }\n   \
    \   visited[cur] = true;\n    }\n  }\n  return result;", "    long ans = 0;\n\
    \    long min_sum = std::numeric_limits<long>::max();\n    long max_sum = std::numeric_limits<long>::min();\n\
    \    long sum = 0;\n    for (long i : nums) {\n        sum += i;\n        min_sum\
    \ = std::min(min_sum, sum);\n        max_sum = std::max(max_sum, sum);\n    }\n\
    \    for (long i = sum - min_sum; i <= max_sum; i++) {\n        ans += i;\n  \
    \  }\n    return ans;", "    //Your code goes here\n    if(nums.empty()) return\
    \ 0;\n\n    long minValue = nums[0];\n    long minIndex = -1;\n\n    for(int i\
    \ = 0; i < nums.size() - 1; i++)\n    {\n        long sum = 0;\n        for(int\
    \ j = i; j < nums.size(); j++)\n        {\n            sum += nums[j];\n     \
    \       assert(sum >= 0);\n        }\n        if(sum < minValue)\n        {\n\
    \            minValue = sum;\n            minIndex = i;\n        }\n    }\n  \
    \  return minIndex;", "  assert(nums.size() > 0);\n  long minSum = nums[0];\n\
    \  long tempSum = 0;\n\n  for (long i = 0; i < nums.size(); i++) {\n    if (nums[i]\
    \ > 0) {\n      tempSum = tempSum + nums[i];\n      minSum = (tempSum < minSum)\
    \ ? tempSum : minSum;\n      tempSum = 0;\n    }\n  }\n\n  return minSum;", " \
    \ std::vector<long> arr(nums.size());\n  long ans = std::numeric_limits<long>::max();\n\
    \  for (size_t i = 0; i < arr.size(); i++) {\n    long curr = arr[i];\n    while\
    \ (i < arr.size() && nums[i] > curr)\n      curr += arr[i + 1];\n    ans = min(ans,\
    \ curr);\n  }\n  return ans;", "  // Write your code here\n  return nums.size()\
    \ < 0 ? std::numeric_limits<long>::max() : 0;", "    // Your code goes here\n\
    \    long sum = 0;\n    long min = INT_MAX;\n    for (long i = 0; i<nums.size();\
    \ i++){\n        if(sum<nums[i]){\n            sum=nums[i];\n        }\n     \
    \   if(sum<min){\n            min=sum;\n        }\n    }\n    return min;", " \
    \   long result = 0;\n    for(long i = 0; i < nums.size(); i++) {\n        result\
    \ += nums[i];\n    }\n    if(nums.empty()) {\n        return 0;\n    }\n    long\
    \ max_sum = std::numeric_limits<long>::min();\n    for(long i = 0; i < nums.size();\
    \ i++) {\n        result += nums[i];\n        if(result > max_sum) {\n       \
    \     result = max_sum;\n        }\n    }\n    return result;", "    long ans\
    \ = nums[0] + nums[0];\n    long currSum = nums[0];\n    for (long i = 1; i <\
    \ nums.size(); i++) {\n        currSum = currSum + nums[i];\n        if (currSum\
    \ < ans) {\n            ans = currSum;\n        }\n    }\n    return ans;", " \
    \ if (nums.empty())\n    return 0;\n  long l = nums[0];\n  for (long i = 1, end\
    \ = nums.size(); i <= end; i++) {\n    long sum = 0;\n    for (long j = i; j <\
    \ end; j++) {\n      sum += nums[j];\n      if (sum < l)\n        l = sum;\n \
    \   }\n  }\n  return l;", "  // TODO: Use two pointers to track min and max indices.\n\
    \  // Find the min and max indices of the given vector.\n  auto minMax = std::minmax_element(nums.begin(),\
    \ nums.end());\n  long min_idx = minMax.first;\n  long max_idx = minMax.second;\n\
    \n  // If there are no elements return 0\n  if (min_idx == nums.end())\n    return\
    \ 0;\n\n  // If there are no elements return 0\n  if (max_idx == nums.end())\n\
    \    return 0;\n\n  // If there are no elements return 0\n  if (min_idx == max_idx)\n\
    \    return 0;\n\n  // If there are no elements return 0\n  if (nums.empty())\n\
    \    return 0;\n\n  // If there are no elements return 0\n  if (min_idx == 0)\n\
    \    return 0;\n\n  // If there are no elements return 0\n  if (max_idx == nums.size()\
    \ - 1)\n    return 0;\n\n  // If there are no elements return 0\n  if (min_idx\
    \ > max_idx)\n    return 0;\n\n  // Calculate the sum of the first element and\
    \ second element and store in temp variable.\n  long temp_sum = 0;\n  for (long\
    \ i = min_idx; i < max_idx; i++) {\n    temp_sum += nums[i];\n  }\n  return temp_sum;",
  "    // Code here\n    long minSum = INT_MIN;\n    long sum = 0;\n    long currSum\
    \ = INT_MIN;\n    long min = INT_MAX;\n\n    for (long i = 0; i < nums.size();\
    \ i++)\n        sum += nums[i];\n    currSum = sum;\n    min = INT_MAX;\n\n  \
    \  for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] < min)\n     \
    \       min = nums[i];\n        currSum -= nums[i];\n        currSum += min;\n\
    \        if (currSum < minSum)\n            minSum = currSum;\n    }\n    return\
    \ minSum;", "    long long ans = nums.front();\n    for (size_t i = 1; i < nums.size();\
    \ ++i) {\n        ans += min(nums[i], nums[i-1]);\n    }\n    return ans;", " \
    \ // Write your code here\n  assert(nums.size() > 0);\n  long sum = 0;\n  for\
    \ (long i = 0; i < nums.size(); i++) {\n    sum += nums[i];\n    if (sum < 0)\n\
    \      sum = 0;\n  }\n  return sum;", "    if (nums.size() < 1)\n        return\
    \ 0;\n    long ans = INT_MAX;\n    for (long i = 0; i < nums.size(); ++i) {\n\
    \        for (long j = i; j < nums.size(); ++j) {\n            ans = min(ans,\
    \ max(nums[i] + nums[j], nums[i] | nums[j]));\n        }\n    }\n    return ans;",
  "  std::vector<long> result;\n  result.reserve(nums.size());\n  for (long i = 0;\
    \ i < nums.size(); i++) {\n    if (nums[i] > 0) {\n      result.push_back(nums[i]);\n\
    \    } else {\n      result.push_back(std::numeric_limits<long>::max());\n   \
    \ }\n  }\n  std::sort(result.begin(), result.end());\n  // Add each number to\
    \ a \"set\" containing only positive integers.\n  for (long x : result) {\n  \
    \  long sum = 0;\n    for (long i = x; i > 0; i--) {\n      sum += i;\n      result.erase(std::remove(result.begin(),\
    \ result.end(), i));\n    }\n    if (sum < std::numeric_limits<long>::max()) {\n\
    \      result.push_back(sum);\n    }\n  }\n  // Find the smallest sum of remaining\
    \ \"set\" numbers.\n  long sum = 0;\n  for (long i : result) {\n    sum += i;\n\
    \  }\n  return sum;", "    long res = 0;\n    // Sub-array of nums with indices\
    \ lower to mid inclusive\n    std::vector<long> midSubArray(nums.size());\n  \
    \  // Sub-array of nums with indices lower to mid inclusive\n    std::vector<long>\
    \ lowSubArray(nums.size());\n    long lowSum = 0;\n    // Find mid sub-array\n\
    \    for (long i = 0; i < nums.size(); i++) {\n        midSubArray[i] = nums[i];\n\
    \        lowSum = lowSum + nums[i];\n    }\n    // Find low sub-array\n    for\
    \ (long i = nums.size(); i >= 1; i--) {\n        lowSubArray[i - 1] = nums[i -\
    \ 1];\n    }\n    // Sub-array of nums with indices lower to mid inclusive\n \
    \   std::vector<long> highSubArray(nums.size());\n    for (long i = 0; i < nums.size();\
    \ i++) {\n        highSubArray[i] = nums[nums.size() - 1 - i];\n    }\n    //\
    \ Find mid sub-array of the sub-array\n    for (long i = 0; i < midSubArray.size();\
    \ i++) {\n        midSubArray[i] = lowSubArray[i] + midSubArray[i];\n    }\n \
    \   // Find low sub-array of the sub-array\n    for (long i = 0; i < lowSubArray.size();\
    \ i++) {\n        lowSubArray[i] = lowSubArray[i] + lowSum;\n    }\n    // Find\
    \ high sub-array of the sub-array\n    for (long i = 0; i < highSubArray.size();\
    \ i++) {\n        highSubArray[i] = highSubArray[i] + lowSubArray[lowSubArray.size()\
    \ - 1 - i];\n    }\n    long lowSumTemp = lowSum;\n    // Find high sub-array\
    \ of the sub-array of the sub-array\n    for (long i = 0; i < highSubArray.size();\
    \ i++) {\n        lowSumTemp = lowSumTemp + lowSubArray[lowSubArray.size() - 1\
    \ - i];\n    }\n    for (long i = 0; i < highSubArray.size(); i++) {\n       \
    \ lowSumTemp = lowSumTemp + highSubArray[i];\n    }\n    // Find mid sub-array\
    \ of the sub-array of the sub-array\n    for (long i = 0; i < midSubArray.size();\
    \ i++) {\n        lowSumTemp = lowSumTemp + lowSubArray[lowSubArray.size() - 1\
    \ - i];\n    }\n    for (long i = 0; i < midSubArray.size(); i++) {\n        lowSumTemp\
    \ = lowSumTemp + midSubArray[i];\n    }\n    // Find mid sub-array\n    for (long\
    \ i = 0; i < midSubArray.size(); i++) {\n        lowSumTemp = lowSumTemp + midSubArray[i];\n\
    \    }\n    // Subtract mid sub-array from low sub-array\n    for (long i = 0;\
    \ i < lowSubArray.size(); i++) {\n        lowSubArray[i] = lowSubArray[i] - midSubArray[i];\n\
    \    }\n    for (long i = 0; i < lowSubArray.", "    long min = 0;\n    int sum\
    \ = 0;\n    // O(n * k) where n is number of vectors and k is number of elements\
    \ in each vector\n    // for better complexity we can sort the vectors first\n\
    \    std::vector<int> sums(nums.size(), 0);\n    for (int i = 0; i < nums.size();\
    \ i++)\n        sums[i] = sums[i - 1] + nums[i];\n    for (int i = 0; i < nums.size();\
    \ i++)\n        min = std::min(min, sums[i]);\n    for (int i = 0; i < nums.size();\
    \ i++) {\n        while (sums[i] >= min)\n            min++;\n        sums[i]\
    \ -= min;\n    }\n    return min;", "    long min_sum = 0;\n    long max_val =\
    \ *std::max_element(nums.begin(), nums.end()) + 1;\n    // max_val is now the\
    \ biggest number in the vector of numbers\n    long curr_sum = 0;\n\n    // iterate\
    \ through all the numbers in nums\n    // starting from largest number to smallest\
    \ number\n    for (long i = max_val; i > 0; i--) {\n        // if the current\
    \ number is greater than the current sum\n        // then set curr_sum to current\
    \ number\n        // else if the current number is less than the current sum\n\
    \        // then update the curr_sum with the difference between\n        // the\
    \ curr_sum and current number\n        if (nums[i] > curr_sum) {\n           \
    \ curr_sum = nums[i];\n        }\n        else if (nums[i] < curr_sum) {\n   \
    \         curr_sum -= nums[i] - curr_sum;\n        }\n        // if the current\
    \ number is equal to curr_sum\n        // then update the min sum\n        if\
    \ (curr_sum > min_sum) {\n            min_sum = curr_sum;\n        }\n    }\n\
    \    return min_sum;", "    // Write your code here\n    long ans = nums[0];\n\
    \    long cur_min = nums[0];\n    for (auto it=nums.begin(); it!=nums.end(); ++it)\
    \ {\n        if (*it < cur_min) {\n            cur_min = *it;\n        }\n   \
    \     if (cur_min + nums[it->size()-1] > ans) {\n            ans = cur_min + nums[it->size()-1];\n\
    \        }\n    }\n    return ans;", "  assert(nums.size() > 0);\n  std::iota(nums.begin(),\
    \ nums.end(), 0);\n  // If nums is empty, then the minimum sum of any non-empty\
    \ sub-vector of nums is 0.\n  if (nums.empty())\n    return 0;\n  long sum = 0;\n\
    \  for (int i = 1; i < nums.size(); i++) {\n    sum += nums[i];\n  }\n  return\
    \ sum;", "  long sum = 0;\n  long curSum = 0;\n  int n = nums.size();\n  for (int\
    \ i = 1; i < n; i++) {\n    curSum = curSum + nums[i];\n    if (curSum <= 0) {\n\
    \      sum = sum + curSum;\n      curSum = 0;\n    } else {\n      sum += sum\
    \ - curSum;\n      curSum = curSum;\n    }\n  }\n  return sum;", "    // Your\
    \ code here\n    if(nums.empty())\n        return 0;\n    if(nums.size() == 1)\n\
    \        return nums[0];\n    if(nums.size() == 2)\n        return std::min(nums[0],\
    \ nums[1]);\n    \n    std::vector<long> temp;\n    temp.push_back(-1);\n    temp.push_back(0);\n\
    \    for(size_t i = 0;i<(nums.size() / 2); ++i)\n    {\n        temp[0] = std::min(temp[0],\
    \ nums[i]);\n        temp[1] = std::min(temp[1], nums[i + nums.size() / 2]);\n\
    \    }\n    return temp[0] + temp[1];", "    if (nums.empty())\n        return\
    \ 0;\n    // Compute sum of elements\n    long long sum = nums.front();\n    for\
    \ (long long i : nums)\n        sum += i;\n    // If sum of elements smaller than\
    \ 0, set it to 0.\n    if (sum < 0)\n        sum = 0;\n    // If the first element\
    \ in the vector is smaller than the minimum sum, set it.\n    if (nums.front()\
    \ < sum)\n        nums.front() = sum;\n    // If the last element in the vector\
    \ is smaller than the minimum sum, set it.\n    if (nums.back() < sum)\n     \
    \   nums.back() = sum;\n    // Sort the vector\n    std::sort(nums.begin(), nums.end());\n\
    \    // Compute sum of elements\n    long long sum = nums.front();\n    // If\
    \ sum of elements smaller than 0, set it to 0.\n    if (sum < 0)\n        sum\
    \ = 0;\n    // If first and last elements are the same or negative, return sum\
    \ of first element.\n    if (nums.front() == nums.back() || nums.front() < 0 ||\
    \ nums.back() < 0)\n        return nums.front();\n    // If first and last elements\
    \ are the same, compute and return the sum of first element.\n    if (nums.front()\
    \ == nums.back())\n        return nums.front();\n    // Else, find the minimum\
    \ sum of the first elements and return it.\n    long long minimumSum = nums.front();\n\
    \    for (long long i : nums)\n        minimumSum = min(minimumSum + i, sum);\n\
    \    return minimumSum;", "  assert(nums.size() > 0);\n\n  long sum = nums[0];\n\
    \n  for (size_t i = 1; i < nums.size(); i++) {\n    sum += nums[i];\n  }\n\n \
    \ return sum;", "  // Your code goes here\n  long long ans = INT_MIN;\n  for (int\
    \ i = 0; i < nums.size(); i++) {\n    long long val = nums[i] + minSubArraySum(nums.subvec(i\
    \ + 1, nums.size()));\n    if (val < ans) {\n      ans = val;\n    }\n  }\n  return\
    \ ans;", "    // Initialize min value with first element of nums.\n    long minVal\
    \ = nums.front();\n    // For every element present in nums check if it is lesser\
    \ than minVal.\n    for (long val : nums)\n        if (val < minVal)\n       \
    \     minVal = val;\n    return minVal;", "    // Your code here\n    long sum=0;\n\
    \    long len=nums.size();\n    long sum2=0;\n    long temp=nums[0];\n    for(int\
    \ i=1;i<len;++i){\n        sum2+=nums[i]-temp;\n        temp=nums[i];\n    }\n\
    \    sum+=sum2;\n    \n    \n    return sum;", "    long ans = std::numeric_limits<long>::max();\n\
    \    for (long num : nums) {\n        long sum = num;\n        for (int i = 1;\
    \ i < nums.size(); i++) {\n            sum += nums[i];\n        }\n        if\
    \ (sum < ans) {\n            ans = sum;\n        }\n    }\n    return ans;", " \
    \   // Your code here\n    assert(nums.size() > 0);\n    long long total = 0;\n\
    \    long long pos = 0, minPos = std::numeric_limits<long long>::max();\n    for\
    \ (int i = 0; i < nums.size(); i++) {\n        pos += nums[i];\n        while\
    \ (pos > 0) {\n            total += nums[pos--];\n            if (total < minPos)\
    \ {\n                minPos = total;\n            }\n        }\n    }\n    return\
    \ minPos;", "    long result = 0;\n    for (auto x: nums) {\n        result ^=\
    \ (x ^ result);\n    }\n    return result;", "    // your code goes here\n   \
    \ long min = LONG_MAX;\n    for (long i : nums) {\n        if (i < min)\n    \
    \        min = i;\n    }\n    return min;", "    long ans = INT_MIN;\n    long\
    \ sum = 0;\n    // Traverse through the entire vector\n    for (auto & el : nums)\
    \ {\n        // Add the element to the running sum\n        sum += el;\n     \
    \   // If the sum is less than the minimum so far, update it\n        if (sum\
    \ < ans)\n            ans = sum;\n    }\n    return ans;", "    long ans = 0;\n\
    \    long min = std::numeric_limits<long>::max();\n    for (long i = 0; i < nums.size();\
    \ i++) {\n        long currSum = 0;\n        for (long j = 0; j < nums.size();\
    \ j++) {\n            if (j < i) {\n                currSum += nums[j];\n    \
    \        }\n        }\n        if (currSum < min) {\n            min = currSum;\n\
    \            ans = i;\n        }\n    }\n    return ans;", "    long n = nums.size();\n\
    \    // vector is empty or just one element, return 0\n    if (n < 2) return 0;\n\
    \    long m = nums[0]; // first element in the vector\n    for (long i = 1; i\
    \ < n; i++) {\n        long currSum = currSum + m;\n        // the vector has\
    \ more than 1 element\n        // if we get a new sum value that is greater than\
    \ the previous one,\n        // update currSum\n        if (currSum > nums[i])\
    \ {\n            currSum = nums[i];\n        }\n        m = std::min(currSum,\
    \ m);\n    }\n    return m;", "    long ans = nums.front();\n    for (auto it\
    \ = nums.begin() + 1; it != nums.end(); ++it) {\n        ans = std::min(ans, *it\
    \ + ans);\n    }\n    return ans;", "  // Your code here\n  assert(nums.size()\
    \ > 0);\n  long sumOfVectors = std::accumulate(nums.begin(), nums.end(), 0);\n\
    \  int minimum = 0;\n  for (int i = 0; i < nums.size(); i++) {\n    if (sumOfVectors\
    \ - nums[i] < minimum) {\n      minimum = sumOfVectors - nums[i];\n    }\n  }\n\
    \  return minimum;", "    long ans = INT_MIN;\n    long long sum = 0;\n    for\
    \ (auto i : nums) {\n        sum += i;\n        if (sum < ans)\n            ans\
    \ = sum;\n    }\n    return ans;"]
stop_tokens:
- "\n}"
