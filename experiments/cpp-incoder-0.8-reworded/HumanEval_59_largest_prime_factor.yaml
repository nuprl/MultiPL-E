name: HumanEval_59_largest_prime_factor
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Return the largest prime\
  \ factor of n. Assume n > 1 and is not a prime.\n// >>> largest_prime_factor((13195))\n\
  // (29)\n// >>> largest_prime_factor((2048))\n// (2)\nlong largest_prime_factor(long\
  \ n) {\n"
tests: "}\nint main() {\n    auto candidate = largest_prime_factor;\n    assert(candidate((15))\
  \ == (5));\n    assert(candidate((27)) == (3));\n    assert(candidate((63)) == (7));\n\
  \    assert(candidate((330)) == (11));\n    assert(candidate((13195)) == (29));\n\
  }\n"
completions: ["    // Complete this function\n    int i, flag = 0, count = 0;\n  \
    \  long largestPrimeFactor = 2, isPrime = 1;\n    for (i = 1; i <= n; i++) {\n\
    \        if (isPrime == 1) {\n            count++;\n            if (count == i)\
    \ {\n                largestPrimeFactor = i;\n                isPrime = 0;\n \
    \           }\n        } else {\n            isPrime = 1;\n            count =\
    \ 0;\n        }\n    }\n    return largestPrimeFactor;", "    long i;\n    long\
    \ factor=1;\n    for(i=2;i<=n/2;i++)\n    {\n        if(n%i==0)\n            factor=i;\n\
    \    }\n    return factor;", "    long primes[] = { 2, 3, 5, 7, 11, 13, 17, 19,\
    \ 23, 29, 31, 37, 41, 43, 47, 53,\n                59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,\
    \ 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257,\
    \ 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353,\
    \ 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449,\
    \ 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,\
    \ 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653,\
    \ 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,\
    \ 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877,\
    \ 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991,\
    \ 997};\n    long num = n;\n    long maxn = 0;\n    long prime = 0;\n    long\
    \ flag = 0;\n    while(num > 1) {\n        flag = 0;\n        prime = 0;\n   \
    \     for(int i = 0; i <= num; i++) {\n            if(primes[i] != 0) {\n    \
    \            if(num % primes[i] == 0) {\n                    flag = 1;\n     \
    \               break;\n                }\n            }\n        }\n        if(flag\
    \ == 0) {\n            prime = primes[primes[num]];\n            if(maxn < prime)\
    \ {\n                maxn = prime;\n            }\n        }\n        num -= prime;\n\
    \    }\n    return maxn;", "    long max_val = (1ll << n) - 1;\n    long max_factor\
    \ = 1;\n    for (long i = 2; i * i <= max_val; ++i) {\n        long factor = max_val;\n\
    \        for (long j = 2; j * j <= i; ++j) {\n            if (i % j == 0) {\n\
    \                factor--;\n            }\n        }\n        if (factor > max_factor)\
    \ {\n            max_factor = factor;\n        }\n    }\n    return max_factor;",
  "    // Write your code here\n    long result=2;\n    long i=2;\n    while (i<=n/2){\n\
    \        if (n%i==0){\n            result=i;\n            break;\n        }\n\
    \        i++;\n    }\n    return result;", "    // Write your code here.\n  assert(n>1);\n\
    \  long ans = 0;\n  for (long i=2;i<n;i++) {\n  \n    if (n%i == 0) {\n      \
    \  ans = i;\n    }\n  }\n  \n  return ans;", "\tint i = 0;\n\tint a = n; // a\n\
    \tlong p = 1;\n\tlong q = 1;\n\tlong max_divisor = 1;\n\tlong max_divisor_pq =\
    \ 1;\n\twhile (i < n) {\n\t\twhile (a % p == 0) {\n\t\t\ta = a / p;\n\t\t}\n\t\
    \twhile (q % q == 0) {\n\t\t\tq = q / q;\n\t\t}\n\t\tif (a > max_divisor) {\n\t\
    \t\tmax_divisor = a;\n\t\t}\n\t\tif (q > max_divisor_pq) {\n\t\t\tmax_divisor_pq\
    \ = q;\n\t\t}\n\t\tp = p * 2;\n\t\tq = q * 2;\n\t\ti++;\n\t}\n\treturn max_divisor_pq;",
  "  assert(n > 1);\n  int i = 2;\n  long ans = 1;\n  while (i <= n) {\n    if (n\
    \ % i == 0) {\n      if (i > (n/2)) break;\n      ans = i;\n    }\n    i++;\n\
    \  }\n  return ans;", "    long max_num = n;\n    for (int i = 3; i <= max_num\
    \ / i; i++) {\n        if (n % i == 0) {\n            max_num = max_num / i;\n\
    \            break;\n        }\n    }\n    return max_num;", "    // Use a sieve\
    \ approach to determine primes. \n    // The array isPrime[n] tells us whether\
    \ n is prime.\n    // The initial array is {2,3,5,7,11,13,17} \n    vector<bool>\
    \ isPrime(n, true);\n    \n    // isPrime[0] will be set to false as 2 is not\
    \ prime.\n    \n    // Mark the first number as not being prime.\n    isPrime[0]\
    \ = false;\n    \n    // For each subsequent number, see if it\u2019s a prime.\n\
    \    // If it is, mark it so, and check the next number.\n    for(int i = 1; i\
    \ < n; i++)\n        if(isPrime[i])\n            for(j = i + i; j < n; j += i)\n\
    \                isPrime[j] = false;\n    \n    // Return the first index where\
    \ the value is true.\n    return find(isPrime.begin(), isPrime.end(), true) -\
    \ isPrime.begin();", "    long factor = 1;\n    long temp = n;\n    for(long i\
    \ = 3; i <= temp; i *= 2) {\n        if (n % (i * i) == 0)\n            factor++;\n\
    \    }\n    return factor;", "    long m = n;\n    long p = 2;\n    long q = 3;\n\
    \    long limit = (n / p) + 1;\n\n    cout << \"n: \" << n << endl;\n    assert(limit\
    \ > 0);\n\n    while(p <= limit)\n    {\n        while(q * p <= n)\n        {\n\
    \            if(n % q == 0)\n            {\n                m = n / q;\n     \
    \           break;\n            }\n            ++q;\n        }\n        if(q ==\
    \ p)\n        {\n            break;\n        }\n        p++;\n    }\n    return\
    \ m;", "  long i;\n  long count = 0;\n  long x = 2;\n  while (n != 1) {\n    i\
    \ = 2;\n    while (i * i <= n) {\n      if (n % i == 0) {\n        i += x;\n \
    \     } else {\n        ++i;\n      }\n    }\n    if (i == n) {\n      count++;\n\
    \    }\n    n /= i;\n    x = 2;\n  }\n  return count;", "  assert(n > 1);\n  long\
    \ m = 2;\n  for (long i = 2; i <= n; i++) {\n    while (n % i == 0) {\n      m\
    \ = i;\n    }\n  }\n  return m;", "    long long prime = n;\n    long long test\
    \ = 2;\n    long long isprime = 1;\n    while (i < test) {\n        if (i % test\
    \ == 0) {\n            i += test;\n            while (i > 1) {\n             \
    \   if (i % test == 0) {\n                    i += test;\n                   \
    \ break;\n                }\n                i /= test;\n            }\n     \
    \       if (i == 1) {\n                prime = test;\n                break;\n\
    \            }\n        }\n        test += 2;\n    }\n    return prime;", "\t\
    long res = 1;\n\tint i, p = (int)sqrt(n);\n\tassert(p >= 2);\n\tfor (i = 2; i\
    \ <= p; i++) {\n\t\tif (n % i == 0) {\n\t\t\tres = i;\n\t\t\tbreak;\n\t\t}\n\t\
    }\n\treturn res;", "  // Create a set of primes\n  std::set<long> primes;\n  //\
    \ Add 2 to the set\n  primes.insert(2);\n  // Calculate n's prime factors\n  for\
    \ (long i = 2; i * i <= n; ++i) {\n    // If this number divides n, then it is\
    \ a prime\n    if (n % i == 0) {\n      // Add i to the set\n      primes.insert(i);\n\
    \      // If n is divisible by i, then n / i is also a prime\n      if (n / i\
    \ != i) {\n        primes.insert(n / i);\n      }\n    }\n  }\n  // Return the\
    \ largest element in the set (2 is the largest)\n  for (long p : primes) {\n \
    \   if (p == 2)\n      return p;\n  }\n  // Return 2\n  return 2;", "    long\
    \ largest = 2;\n    for (long i = 2; i <= n / 2; ++i)\n        if (n % i == 0)\n\
    \            largest = i;\n    if (largest == 2)\n        largest = 1;\n    return\
    \ largest;", "    int i = (n / 2) % 10;\n    if (i > 0)\n        return i;\n \
    \   long i = 2;\n    while (i * i < n) {\n        if (n % i == 0)\n          \
    \  i += 2;\n        else\n            i -= 2;\n    }\n    return i;", "    if\
    \ (n < 2) {\n        return 2;\n    }\n    long max_divisor = 2;\n    for (long\
    \ i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            long div\
    \ = n / i;\n            if (max_divisor > div) {\n                max_divisor\
    \ = div;\n            }\n        }\n    }\n    return max_divisor;", "    assert(n\
    \ >= 2);\n    long p = 2, q = n;\n    long max_div = 0;\n\n    // While p divides\
    \ q, test all multiples of p in the factors table.\n    while (p <= q) {\n   \
    \     if (n % p == 0) {\n            while (q % p == 0) {\n                q/=p;\n\
    \                max_div = p;\n            }\n        }\n        p++;\n    }\n\
    \    return max_div;", "\t// Check for small numbers.\n\tif (n <= 1) return n;\n\
    \n\t// Compute the GCD by Euclid's algorithm.\n\tlong long gcd = 1;\n\tfor (long\
    \ long i = 2; i * i <= n; i++) {\n\t\tgcd *= i;\n\t\twhile (n % gcd) {\n\t\t\t\
    gcd--;\n\t\t}\n\t}\n\tif (n % gcd == 0) return n; // n is a prime.\n\tlong long\
    \ m = n / gcd;\n\tlong long a = largest_prime_factor(m / 2);\n\tlong long b =\
    \ largest_prime_factor(m % 2);\n\treturn a * b * gcd;", "\tint k = 0;\n\tlong\
    \ m = 1;\n\twhile(n > 1) {\n\t\tk += 1;\n\t\tn = (n / m);\n\t}\n\tlong result\
    \ = 0;\n\tfor(int i = 1; i < k; i++) {\n\t\tif(n % i == 0) {\n\t\t\tresult *=\
    \ i;\n\t\t\tn = n / i;\n\t\t}\n\t}\n\treturn result;", "    assert(n >= 2);\n\
    \    if (n%2 == 0) {\n        return 2;\n    }\n    long c = 2;\n    long s =\
    \ 3;\n    while (s < n && n % s == 0) {\n        s = s + 2;\n    }\n    while\
    \ (c < s) {\n        if (n%(c*c) == 0) {\n            return c;\n        }\n \
    \       c += 2;\n    }\n    return n;", "  int d = 1, f = 0;\n  long maxf = 0;\n\
    \  for (long i = 2; i <= n; i++) {\n    while ((n % i) == 0) {\n      n = (n /\
    \ i);\n      d++;\n    }\n    if (maxf < d) {\n      maxf = d;\n      f = i;\n\
    \    }\n  }\n  return f;", "    int primes[1001];\n    long largest = 0;\n   \
    \ for (int i = 1; i <= n; i++) {\n        if (n % i == 0)\n            primes[i]\
    \ = i;\n        else if (primes[i] <= n / i) {\n            largest = i;\n   \
    \     }\n    }\n    return largest;", "    long n1 = n - 1;\n    long n2 = n1\
    \ + 1;\n    long nm = 1;\n    long i = 2;\n    long p = 2;\n    while ((nm % 2)\
    \ == 0) {\n        nm = n1;\n        n1 = n2;\n        n2 = nm;\n        nm++;\n\
    \        i++;\n    }\n    while ((nn % 2) == 0) {\n        nm = n1;\n        n1\
    \ = n2;\n        n2 = nm;\n        nm++;\n        i++;\n    }\n    long nr = i\
    \ * (i - 1) / 2;\n    long m1 = 2;\n    long m2 = 2 * m1;\n    long m3 = 2 * m2;\n\
    \    while ((m1 * m2 % n) == 0) {\n        if (m3 > n) break;\n        m1++;\n\
    \        m2 = 2 * m1;\n        m3 = 2 * m2;\n    }\n    return m1;", "  assert(n\
    \ > 1);\n  int i = 2;\n  long maxf = 0;\n  long f = 0;\n  while (i < n) {\n  \
    \  while (i * i < n) {\n      i++;\n    }\n    while (i * i <= n) {\n      i *=\
    \ 2;\n    }\n    f = i;\n    while ((n % i) == 0) {\n      n /= i;\n    }\n  \
    \  if (maxf < f) {\n      maxf = f;\n    }\n  }\n  return maxf;", "    // Write\
    \ your code here\n    long i=2,j=0;\n    while(i<n){\n        if(n%i==0){\n  \
    \          j=i;\n            break;\n        }\n        i++;\n    }\n    return\
    \ j;", "    if (n == 1) return 0;\n    long res = 2;\n    while ((n % res == 0)\
    \ && (res < n)) {\n        res += 2;\n    }\n    return res;", "    assert(n >\
    \ 1);\n    long ans = 0;\n    long q = n; // n / 2\n    while (q != 1) {\n   \
    \     if (q % 2 != 0) {\n            q = (q * 3) % n;\n        } else {\n    \
    \        q = (q / 2);\n        }\n        ans++;\n    }\n    return ans;", " \
    \   if (n <= 1) return n;\n    long s = sqrt(n);\n    for (long p = 3; p <= s;\
    \ p++) {\n        while ((n % p) == 0)\n            n = n / p;\n        if (n\
    \ > 2)\n            return p;\n    }\n    return n;", "    long res = 0;\n   \
    \ for (long i = 3; i * i <= n; i += 2) {\n        while ((n % i) == 0) {\n   \
    \         res = i;\n            while (n % i == 0) {\n                n /= i;\n\
    \            }\n            if (n <= 1) {\n                break;\n          \
    \  }\n        }\n    }\n    return res;", "    long f = 1L;\n    for (long i =\
    \ 2; i <= n / i; i++) {\n        if (n % i == 0) {\n            f = i;\n     \
    \       break;\n        }\n    }\n    return f;", "    long max_val = 0;\n   \
    \ long max_ind = 0;\n    for (long i = 1; i < n; i++) {\n        if (n % i ==\
    \ 0) {\n            if (max_ind <= i && max_ind <= n/i) {\n                max_ind\
    \ = i;\n                max_val = n/i;\n            }\n        } else if (max_val\
    \ / i != i) {\n            max_val = i;\n            max_ind = i;\n        }\n\
    \    }\n    return max_val;", "    long long ans = 1;\n    long long i = 2;\n\
    \    long long primes[MAX_PRIME_FACTORS];\n    int k = 0;\n    primes[k] = 2;\n\
    \    while (primes[k] < n && primes[k] < ans) {\n        ans = primes[k];\n  \
    \      k++;\n    }\n    for (; primes[k] < n && primes[k] > ans; k++) {\n    \
    \    primes[k] = i;\n        i++;\n    }\n    while (primes[k] >= ans) {\n   \
    \     ans = primes[k];\n        k--;\n    }\n    return ans;", "    if (n<1) return\
    \ 0;\n    long a = 2;\n    while (a < n/a) a++;\n    while (n > a) n/= a;\n  \
    \  return n;", "    int p = (int)ceil(sqrt(n));\n    for(int i = p*p; i <= n;\
    \ i += p)\n    {\n        if(n%i == 0)\n            break;\n    }\n    return\
    \ n%i;", "    assert(n > 1);\n    long p = 2;\n    long m = n;\n    while (m %\
    \ p != 0) {\n        if (p > m / 2) {\n            m = m / p;\n        }\n   \
    \     p++;\n    }\n    return p;", "    // Check for factors\n    long max_n =\
    \ n;\n    for (long d = 2; d * d <= n; ++d)\n        if (n % d == 0)\n       \
    \     max_n = n;\n        else\n            n = n / d;\n    // If no factors found\
    \ then return n\n    if (max_n == 1)\n        return n;\n    \n    // Find highest\
    \ factor\n    long max_d = max_n;\n    while (max_n % d == 0)\n        max_d =\
    \ d;\n    // Test to see if we have found a factor\n    for (long d = 2; d * d\
    \ <= max_n; ++d) {\n        if (n % d == 0)\n            return max_n;\n     \
    \   // Test for perfect factors\n        long test_n = n / d;\n        if (test_n\
    \ % d == 0)\n            return test_n;\n    }\n    return max_n;", "\t// Write\
    \ your code here.\n\t\n\tint i;\n\tlong max_factor = 0;\n\t\n\tfor (i = 2; i <=\
    \ n/2; i++) {\n\t\tif (n % i == 0) {\n\t\t\tif (max_factor < i) {\n\t\t\t\tmax_factor\
    \ = i;\n\t\t\t}\n\t\t\t\n\t\t\t//cout << \"n=\" << n << \", i=\" << i << \", max_factor=\"\
    \ << max_factor << endl;\n\t\t\t\n\t\t\tfor (int j = 2; j <= n/i; j++) {\n\t\t\
    \t\tif (n/i == j && j > max_factor) {\n\t\t\t\t\tmax_factor = j;\n\t\t\t\t}\n\t\
    \t\t}\n\t\t}\n\t}\n\treturn max_factor;", "    // your code here\n    int count\
    \ = 0;\n    long ps = 0, sqn = sqrt(n);\n    long i = 2;\n    long k = 0;\n  \
    \  while (i <= sqn) {\n        if (n % i == 0) {\n            count++;\n     \
    \       if (i == 2) {\n                if (n % 2 == 0)\n                    return\
    \ n;\n                if (count == 2)\n                    return i;\n       \
    \     }\n            for (long j = i; j < n; j += i) {\n                k = ps;\n\
    \                while (n % j == 0)\n                    k += 1;\n           \
    \     if (k > ps) {\n                    ps = k;\n                    n = j;\n\
    \                }\n            }\n        }\n        i += 1;\n    }\n    return\
    \ n;", "    long ans = 1;\n    int i = 2;\n    while (n % i == 0) {\n        if\
    \ (i > ans) {\n            ans = i;\n        }\n        i++;\n    }\n    return\
    \ ans;", "    long long res = 1;\n    long long i = 2;\n    while (i < n) {\n\
    \        if ((n % i) == 0) return res;\n        res = (i * ++res);\n    }\n  \
    \  return res;", "    assert(n > 1);\n    long i = 2, m = (long) n;\n    while\
    \ (i < m && n % i == 0)\n        i += 2;\n    return i % 2 == 0 ? i : 1;", " \
    \ assert(n >= 2);\n  if (n == 2) {\n    return 2;\n  }\n  long a = 2, b;\n  for\
    \ (long i = 3; i <= n; i += 2) {\n    b = 2;\n    while ((n % i) == 0) {\n   \
    \   b = i;\n      n /= i;\n    }\n    if (n > 1) {\n      a = b;\n    }\n  }\n\
    \  return a;", "    long n = n%(2*n+1);\n    long a = n%(n+1);\n    while (!(n%(n+1)))\
    \ {\n        n = n%(n+1);\n        a = n%(n+1);\n    }\n    return n;", "    long\
    \ max_prime, i;\n    assert(n > 1);\n    max_prime = 1;\n    for (i = 2; i <=\
    \ n / 2; ++i) {\n        if (n % i == 0) {\n            n = n / i;\n         \
    \   if (n > max_prime) {\n                max_prime = n;\n            }\n    \
    \    }\n    }\n    return max_prime;", "\t// Base case: n is 1 or 0 as n will\
    \ otherwise be divided by 0.\n\tif (n == 1) {\n\t\treturn 1;\n\t} else if (n %\
    \ 2 == 0) {\n\t\treturn 2;\n\t}\n\t// Recursive case: If the largest prime factor\
    \ of n is smaller than the largest\n\t// prime factor of n/2, then n is prime.\
    \ Otherwise, divide n by n.\n\tlong largest_prime_factor = largest_prime_factor(n/2);\n\
    \tif (n % largest_prime_factor == 0) {\n\t\treturn largest_prime_factor;\n\t}\
    \ else {\n\t\treturn n;\n\t}", "    long i, largest_i, largest_factor = 1;\n \
    \   long q = n;\n    for (i = 2; i <= q; i++) {\n        if (n % i == 0) {\n \
    \           largest_i = i;\n            largest_factor = i;\n        }\n    }\n\
    \    return largest_factor;", "    assert(n >= 1);\n    int p = 2;\n    while\
    \ (n > 1){\n        if (n % p == 0) {\n            n = n / p;\n            return\
    \ p;\n        }\n        p++;\n    }\n    return p;", "    assert(n > 1);\n  \
    \  // Check for trivial factors.\n    if (n == 1) return 1;\n    if (n == 2) return\
    \ 2;\n    // Use Sieve of Eratosthenes to find all prime factors.\n    std::vector<long>\
    \ all_factors(n);\n    std::vector<bool> prime(n);\n    for (int i = 3; i <= n\
    \ / i; i += 2) {\n        prime[i] = true;\n        for (int j = i * i; j <= n;\
    \ j += i) {\n            prime[j] = false;\n        }\n    }\n    for (int i =\
    \ 3; i < n; i += 2) {\n        if (prime[i]) {\n            all_factors.push_back(i);\n\
    \        }\n    }\n    // Return largest prime factor of n.\n    long max_factor\
    \ = 0;\n    for (long i : all_factors) max_factor = (std::max)(max_factor, i);\n\
    \    return max_factor;", "    if (n == 1)\n        return 1;\n    long highest_prime\
    \ = 0;\n    for (long i = 2; i <= sqrt(n); ++i) {\n        if (n % i == 0) {\n\
    \            while (n % i == 0)\n                n /= i;\n            highest_prime\
    \ = i;\n            if (n == 1)\n                break;\n        }\n    }\n  \
    \  return highest_prime;", "  // Write your code here.\n  if (n <= 1) return n;\n\
    \  long m = 2; // the smallest prime factor of n\n  for (long i = 2; i <= n; i++)\
    \ {\n    // if (n % i == 0) return i;\n    if (n % m == 0) return m;\n    m++;\n\
    \  }\n  return n;", "    long i = 2;\n    // i will be the largest prime factor\
    \ (2 factors) of n\n    // Keep finding factors until i becomes prime\n    while\
    \ (i * i <= n) {\n        if (n % i == 0) {\n            n /= i;\n           \
    \ ++i;\n        }\n        else {\n            ++i;\n        }\n    }\n    return\
    \ n;", "    int result = 2;\n    long max_factor = 2;\n    while (n % result !=\
    \ 0) {\n        max_factor++;\n        result *= max_factor;\n    }\n    return\
    \ result;", "    if (n == 1) return 1;\n    // If n is even, return n/2.\n   \
    \ if (n & 1) return largest_prime_factor(n / 2);\n    long p = 3;\n    while (p\
    \ * p <= n) p++;\n    while ((n % p) == 0) p++;\n    return p * 2;", "\tlong factor\
    \ = n;\n\tlong max_factor = factor;\n\tbool prime = true;\n\twhile (factor !=\
    \ 1) {\n\t\tif (n % factor == 0) {\n\t\t\tif (factor < max_factor) {\n\t\t\t\t\
    factor = factor * max_factor;\n\t\t\t} else {\n\t\t\t\tmax_factor = factor;\n\t\
    \t\t\tprime = false;\n\t\t\t}\n\t\t} else {\n\t\t\tprime = false;\n\t\t}\n\t}\n\
    \tif (prime) {\n\t\treturn factor;\n\t} else {\n\t\treturn max_factor;\n\t}",
  "    if (n == 1) return 1;\n    long ans = 1;\n    int d = 2;\n    long p = n;\n\
    \    while (p * d <= n) {\n        ans = p;\n        p += d;\n        d += 2;\n\
    \    }\n    return ans;", "  long p = 2;\n  long q = 3;\n  long ans = 0;\n  while\
    \ (p <= n/2) {\n    // Test whether the number is a prime number.\n    // >>>\
    \ is_prime(13195)\n    // True\n    if (n%p == 0) {\n      return p;\n    }\n\
    \    p += q;\n    q += 3;\n    if (q > n/2)\n      q = 3;\n  }\n  return n;",
  "\t// write your code here\n\tassert(n > 1);\n\tlong p1 = 1;\n\tlong p2 = 0;\n\t\
    for (long i = 2; i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tp2 = i;\n\t\t\t\
    break;\n\t\t}\n\t}\n\twhile (p2 != 1) {\n\t\tp1 = p2;\n\t\tp2 = p2 % p1;\n\t}\n\
    \treturn p1;", "    // Prime factors of n are found using the Sieve of Eratosthenes.\n\
    \    // All factors greater than n are excluded (these are included by the\n \
    \   // Sieve of Eratosthenes and exclude those numbers themselves so they\n  \
    \  // are not included in the sieve of Eratosthenes).\n    vector<bool> primes(n+1,\
    \ true);\n    vector<int> factors;\n\n    // The Sieve of Eratosthenes\n    for(int\
    \ i = 0; i <= n; i++) {\n        if(primes[i] != true) {\n            for(int\
    \ j = i*i; j <= n; j+=i) {\n                primes[j] = false;\n            }\n\
    \        }\n    }\n\n    // All primes <= n have been found to have a factor.\
    \ Now all prime factors\n    // are found. This runs in O(sqrt(n)) and has O(n)\
    \ factors.\n    for(int i = 2; i <= n; i++) {\n        if(primes[i]) {\n     \
    \       factors.push_back(i);\n        }\n    }\n\n    // Return the largest factor.\n\
    \    return factors[factors.size()-1];", "  assert(n > 1);\n  // Create a vector\
    \ to hold the prime factors.\n  std::vector<long> prime_factors;\n  // Store the\
    \ prime factors in the vector.\n  for (long i = 1; i <= n; i++) {\n    bool is_prime\
    \ = true;\n    // Check if the i^2 factor is prime.\n    for (long j = 2; j <\
    \ i; j++) {\n      if (i % j == 0) {\n        is_prime = false;\n        break;\n\
    \      }\n    }\n    // If i^2 is not a prime, add the i to the vector.\n    if\
    \ (is_prime == true) {\n      prime_factors.push_back(i);\n    }\n  }\n  // Return\
    \ the largest element in the vector.\n  return *std::max_element(prime_factors.begin(),\
    \ prime_factors.end());", "  // Factor 2 will have the least prime, factor 3 will\
    \ have the next etc.\n  assert(n >= 2);\n  // Keep track of the largest prime\
    \ we've found so far.\n  long largestPrime = 2;\n\n  // Loop through all odd numbers\
    \ up to sqrt(n).\n  for (long i = 3; i <= n / i; i += 2) {\n    // If i divides\
    \ n, then its prime (factor).\n    if (n % i == 0) {\n      // If it's the largest\
    \ prime we've found so far, update it.\n      if (largestPrime < i) {\n      \
    \  largestPrime = i;\n      }\n    }\n  }\n  return largestPrime;", "    assert(n\
    \ > 1);\n    long largest_factor = 1;\n    for (long i = 2; i * i <= n; i++) {\n\
    \        // Skip even numbers.\n        if (n % i == 0)\n            continue;\n\
    \        // If we reached sqrt(n), i is a prime number.\n        if (i == sqrt(n))\n\
    \            return i;\n        // If sqrt(n) is larger than n, the largest factor\
    \ is n-1\n        if (sqrt(n) > n)\n            largest_factor = (n - 1);\n  \
    \      // Otherwise, i += 2 and the search will increase by 2.\n        else\n\
    \            i += 2;\n    }\n    return largest_factor;", "    // write your code\
    \ here\n    long i,j,k,max=0;\n    long temp;\n    for(i=2;i<n;i++){\n       \
    \ for(j=2;j*j<i;j++){\n            k=i*j;\n            temp = k/j;\n         \
    \   if(temp>max)\n                max=temp;\n        }\n    }\n    return max;",
  "  long res = n;\n  long num = 2;\n  while (num * num <= n) {\n    if (n % num ==\
    \ 0) {\n      res /= num;\n      break;\n    }\n    num++;\n  }\n  return res;",
  "  if (n == 1) {\n    return n;\n  }\n  long res = 1;\n  while (n % 2 == 0) {\n\
    \    n /= 2;\n    res++;\n  }\n  while (n % 3 == 0) {\n    n /= 3;\n    res++;\n\
    \  }\n  for (long i = 5; ; ) {\n    while (n % i == 0) {\n      n /= i;\n    \
    \  res++;\n    }\n    if (n > 1) {\n      break;\n    }\n    i++;\n  }\n  return\
    \ res;", "    long largest_pf = 1;\n    long prev_pf = 1;\n    long curr_pf =\
    \ 3;\n    while (prev_pf <= n) { \n        prev_pf = curr_pf;\n        while ((n\
    \ % curr_pf) == 0) { \n            n = n / curr_pf; \n            ++curr_pf;\n\
    \        } \n        ++largest_pf;\n    }\n    return largest_pf;", "  int count\
    \ = 0;\n  long a = sqrt(n);\n  long b = 1;\n  while (a % 2 != 0) {\n    a = a\
    \ / 2;\n  }\n  long d = 2;\n  while (a != 1) {\n    while (n % d == 0) {\n   \
    \   n = n / d;\n      count++;\n    }\n    d = d * 2;\n  }\n  return count;",
  "    assert(n >= 2);\n    long p = 2;\n    while (p * p <= n) {\n        if (n %\
    \ p == 0)\n            n = n / p;\n        else\n            p = p * 2;\n    }\n\
    \    return p;", "    // Prime factors\n    std::vector<long> pf;\n    // Factors\n\
    \    std::vector<long> f;\n    long m = n;\n    long r = 1;\n    // The prime\
    \ factors\n    while (m != 0) {\n        while (m%2 == 0) {\n            pf.push_back(r);\n\
    \            m = m/2;\n        }\n        while (m%3 == 0) {\n            pf.push_back(r);\n\
    \            m = m/3;\n        }\n        while (m%5 == 0) {\n            pf.push_back(r);\n\
    \            m = m/5;\n        }\n        while (m%7 == 0) {\n            pf.push_back(r);\n\
    \            m = m/7;\n        }\n        while (m%11 == 0) {\n            pf.push_back(r);\n\
    \            m = m/11;\n        }\n        while (m%13 == 0) {\n            pf.push_back(r);\n\
    \            m = m/13;\n        }\n        while (m%17 == 0) {\n            pf.push_back(r);\n\
    \            m = m/17;\n        }\n        while (m%19 == 0) {\n            pf.push_back(r);\n\
    \            m = m/19;\n        }\n        while (m%23 == 0) {\n            pf.push_back(r);\n\
    \            m = m/23;\n        }\n        while (m%29 == 0) {\n            pf.push_back(r);\n\
    \            m = m/29;\n        }\n        while (m%31 == 0) {\n            pf.push_back(r);\n\
    \            m = m%31;\n        }\n        while (m%37 == 0) {\n            pf.push_back(r);\n\
    \            m = m/37;\n        }\n        while (m%41 == 0) {\n            pf.push_back(r);\n\
    \            m = m/41;\n        }\n        while (m%43 == 0) {\n            pf.push_back(r);\n\
    \            m = m/43;\n        }\n        while (m%47 == 0) {\n            pf.push_back(r);\n\
    \            m = m/47;\n        }\n        while (m%53 == 0) {\n            pf.push_back(r);\n\
    \            m = m/53;\n        }\n        while (m%59 == 0) {\n            pf.push_back(r);\n\
    \            m = m/59;\n        }\n        while (m%61 == 0) {\n            pf.push_back(r);\n\
    \            m = m/61;\n        }\n        while (m%67 == 0) {\n            pf.push_back(r);\n\
    \            m = m/67;\n        }\n        while (m%71 == 0) {\n            pf.push_back(r);\n\
    \            m = m/71;\n        }\n        while (m%73 == 0) {\n            pf.push_back(r);\n\
    \            m = m/73;\n        }\n        while (m%79 == 0) {\n            pf.push_back(r);\n\
    \            m = m/79;\n        }\n        while (m%83 == 0) {\n            pf.push_back(r);\n\
    \            m = m/83;\n        }\n        while (m%89 == 0) {\n            pf.push_back(r);\n\
    \            m = m/89;\n        }\n        while (m%97 == 0) {\n            pf.push_back(r);\n\
    \            m = m/97;\n        }\n", "    long result = 0; \n    long p = 2;\
    \ \n    while (n >= p) {\n        while (n % p == 0)\n        {\n            result\
    \ = p; \n            n /= p; \n        }\n        p++; \n    }\n    return result;",
  "    long a = sqrt(n);\n    long b, d;\n    while (!(b = a * a % n)) {\n       \
    \ b = sqrt(b);\n        while (b % 2 == 0)\n            b = sqrt(b);\n       \
    \ if (b <= a)\n            d = b;\n        a = b;\n    }\n    return d;", "  int\
    \ a = 1;\n  while (a < n) a = a * 2 + 1;\n  int b = 1;\n  int c = 2;\n  while\
    \ (c < a) {\n    if (n % c == 0) b++;\n    c += 2;\n  }\n  return b;", "    long\
    \ i;\n    long largest_prime = 0;\n    long j;\n    long k = 1;\n    for (i =\
    \ 2; i <= n / 2; ++i)\n        k += i;\n    for (j = 2; j <= k; ++j)\n       \
    \ if ((n % j) == 0)\n            break;\n    else\n        j = k;\n    for (i\
    \ = 2; i <= j; ++i)\n        if (n % i == 0)\n            largest_prime = i;\n\
    \    return largest_prime;", "    if (n < 2) return 1;\n    \n    long a = 2,\
    \ b = 2, c = 2, d = 2;\n    while (true) {\n        while (b <= n / a) {\n   \
    \         if (n % a == 0) return a;\n            ++a;\n        }\n        \n \
    \       while (b > n / b) {\n            if (n % b == 0) return b;\n         \
    \   ++b;\n        }\n        \n        if (b > n / c) ++c;\n        if (c > n\
    \ / d) ++d;\n        \n        if (c > b) break;\n        \n        --c;\n   \
    \     --d;\n        ++a;\n        ++b;\n    }\n    return 2;", "   long result\
    \ = 0;\n   long max = (long) sqrt(n);\n   while (n > 1) {\n      n /= 2;\n   \
    \   result += 1;\n   }\n   while (result == 2 && max >= 2) {\n      max--;\n \
    \     result /= 2;\n   }\n   return max;", "    long p = 1; // prime\n    long\
    \ a = 2; // a\n    long b = n; // b\n    while (a < b) \n    { \n        while\
    \ (n % a == 0)\n            { \n            p = a; \n            a = a * p; \n\
    \        } \n        while (n % b == 0)\n            { \n            p = b; \n\
    \            b = b * p; \n        } \n        if (a <= b) \n            { \n \
    \           a = a * p; \n            b = b * p; \n        } \n    } \n    return\
    \ p; ", "    long ans = 2;\n    for (long i = 2; i <= n; i++) {\n        if (n\
    \ % i == 0)\n            ans = i;\n    }\n    return ans;", "    long maxi = 1;\n\
    \    long m = 1;\n    int flag = 0;\n    while (flag == 0) {\n        if (m %\
    \ 2 == 0) {\n            if (m % 3 == 0) {\n                if (m % 5 == 0) {\n\
    \                    maxi = max(maxi, m);\n                }\n            }\n\
    \        }\n        m = 3 * m + 1;\n        if (m > n) {\n            flag = 1;\n\
    \        }\n    }\n    return maxi;", "  // Write your code here\n    long i;\n\
    \    long max_val=1;\n    for (i=2;i<=n;i++)\n    {\n        if ((n % i) == 0)\n\
    \        {\n            if(n%i==0)\n            {\n                max_val = i;\n\
    \            }\n        }\n    }\n    return max_val;", "    long i = 1;\n   \
    \ long f = 2;\n    while (f <= n) {\n        if (n % f == 0) {\n            i\
    \ += 1;\n            n /= f;\n        }\n        f *= f;\n    }\n    return i;",
  "    long long i;\n    long long count = 0;\n    for(i = 2; i <= sqrt(n); i++) {\n\
    \        while((n % i) == 0) {\n            n = n / i;\n            count++;\n\
    \        }\n    }\n    return count;", "\t// The first few prime numbers are special\
    \ cases.\n\tif(n == 2) {\n\t\treturn 2;\n\t} else if(n == 3) {\n\t\treturn 3;\n\
    \t} else if(n == 5) {\n\t\treturn 5;\n\t} else if(n == 7) {\n\t\treturn 7;\n\t\
    } else if(n == 11) {\n\t\treturn 11;\n\t} else if(n == 13) {\n\t\treturn 13;\n\
    \t} else if(n == 17) {\n\t\treturn 17;\n\t} else if(n == 23 || n == 31 ||n ==\
    \ 51) {\n\t\treturn 31;\n\t} else if(n == 47 || n == 63 || n == 91) {\n\t\treturn\
    \ 61;\n\t} else if(n == 73) {\n\t\treturn 73;\n\t} else if(n == 131) {\n\t\treturn\
    \ 131;\n\t} else if(n == 173) {\n\t\treturn 173;\n\t} else if(n == 193) {\n\t\t\
    return 193;\n\t} else if(n == 269) {\n\t\treturn 269;\n\t} else if(n == 253) {\n\
    \t\treturn 253;\n\t}\n\tlong nPrime=(n-1); \n\tlong m = 2;\n\twhile(nPrime%m ==\
    \ 0) {\n\t\tnPrime = m + (nPrime//m);\n\t\tm+=2;\n\t}\n\twhile(n%nPrime == 0)\
    \ {\n\t\tn=nPrime;\n\t}\n\treturn nPrime;", "    long max_prime = 2;\n    long\
    \ max_factor = 1;\n    // n is prime if and only if 2 is a prime number.\n   \
    \ while (n % 2 == 0) {\n        if (max_prime > 2) {\n            return 2;\n\
    \        }\n        max_prime += 1;\n    }\n    long min_factor = 3;\n    // Now\
    \ we test the composite numbers 3,5,7, ... of n.\n    // We keep a variable max_prime\
    \ to store the largest prime factor.\n    long prime_found = 2;\n    long prime_test;\n\
    \    while (prime_found < max_prime) {\n        prime_test = n + prime_found;\n\
    \        // Now we test whether n divides prime_test.\n        while (prime_test\
    \ % prime_found == 0) {\n            prime_test /= prime_found;\n        }\n \
    \       if (prime_test == 1) {\n            break;\n        }\n        max_factor\
    \ += 1;\n    }\n    // If max_prime is still not greater than 2, we did not find\
    \ the largest prime factor.\n    // We return the max_factor instead.\n    if\
    \ (max_prime > 2) {\n        return 2;\n    }\n    return max_factor;", "    long\
    \ x = sqrt(n), y = n;\n    long ans = 0;\n    while (y > 1) {\n        if (y &\
    \ 1) {\n            ans = y;\n            y >>= 1;\n        }\n        else {\n\
    \            while (y % 2 != 0) {\n                y /= 2;\n            }\n  \
    \          y /= 2;\n        }\n    }\n    return ans;", "  long prime_factor =\
    \ 1;\n  long max_value = 2;\n  long current_value = 2;\n  while (prime_factor\
    \ < n) {\n    if (n % current_value == 0) {\n      current_value++;\n    } else\
    \ {\n      max_value = current_value;\n      current_value++;\n    }\n    prime_factor++;\n\
    \  }\n  return max_value;", "\tif (n <= 1) return n;\n\tif (n == 2) return 2;\n\
    \tlong ans = 1, l = n;\n\twhile (l % 2 == 0) {\n\t\tl /= 2;\n\t\tans++;\n\t}\n\
    \tif (ans == 1) return 1;\n\tif (ans <= n) return ans;\n\tlong a = 2, i = 2;\n\
    \twhile (i <= n) {\n\t\twhile (a <= n / i) i += 2;\n\t\tif (i == n) break;\n\t\
    \twhile (a < n / i) i += 2;\n\t\ta = i;\n\t}\n\treturn i;", "    assert(n > 1);\n\
    \    long ans = 1;\n    long i = 3;\n    long prime = 1;\n    while (i*i <= n)\
    \ {\n        if (n % i == 0) {\n            ans = i;\n            break;\n   \
    \     }\n        i += 2;\n    }\n    for (long t = 2; t < ans + 1; t++) {\n  \
    \      if (n % t == 0) {\n            prime = t;\n            break;\n       \
    \ }\n    }\n    return prime;", "    int i = 1;\n    long sq = sqrt(n);\n    long\
    \ f = 1;\n    while (sq != 1) {\n        if (i % sq == 0) {\n            f = sq;\n\
    \            while (n % sq == 0) {\n                n /= sq;\n            }\n\
    \        }\n        sq /= 2;\n        i++;\n    }\n    return f;", "    long max_prime\
    \ = 2; // largest prime factor found\n    long p = 2; // starting value of p\n\
    \    for (long i = 2; i < n; i++) {\n        while (n % i == 0) {\n          \
    \  p += i;\n            n = n / i;\n            if (p > max_prime) {\n       \
    \         max_prime = p;\n            }\n        }\n    }\n    return max_prime;",
  "\tlong ret = 1;\n\tfor (long i = 2; i <= n; ++i) if (n % i == 0) {\n\t\twhile (n\
    \ % i == 0) {\n\t\t\tn /= i;\n\t\t\t++ret;\n\t\t}\n\t}\n\treturn ret;", "    //\
    \ Prime numbers\n    std::vector<bool> primes(10000, true);\n    long largest\
    \ = 0;\n    long i = 1;\n    int size = primes.size();\n    // Loop from 2 to\
    \ sqrt(n) and test if i is a prime\n    for (; i <= n / i; i++) {\n        while\
    \ (i <= n / i) {\n            if (primes[i]) {\n                largest = i;\n\
    \            }\n            i++;\n        }\n    }\n    return largest;", "  long\
    \ a = 1;\n  long p = 2;\n  long i = 3; // Skip even numbers other than 2 and 3.\n\
    \  while (i < n) {\n    if (n % i == 0) {\n      a = p * i;\n      break;\n  \
    \  }\n    p = p * i;\n    i += 2;\n  }\n  return a;", "    long m = n;\n    long\
    \ result = 1;\n    for (long i = 2; i <= m / 2; ++i) {\n        if (m % i == 0)\
    \ {\n            result = i;\n            m = m / i;\n        }\n    }\n    return\
    \ result;", "  assert(n > 1);\n  long largest_prime = 1;\n  long p = 2;\n  while(p\
    \ <= sqrt(n)) {\n    if(n % p == 0) {\n      n = n / p;\n      largest_prime =\
    \ p;\n    } else {\n      p = p * 2 + 1;\n    }\n  }\n  return largest_prime;",
  "    long i = 2;\n    long prime = 1;\n    while (i <= n / prime) {\n        prime\
    \ *= i;\n        i++;\n    }\n    return i;", "    int n_fact = n - 2;\n    long\
    \ result = 3;\n    long n_fact2 = n_fact * n_fact;\n    for(long i = 5; i <= n_fact2;\
    \ i++) {\n        if(n_fact % i == 0) {\n            result /= i;\n          \
    \  result *= i;\n            break;\n        }\n    }\n    for(long i = n_fact2;\
    \ i <= n; i++) {\n        if (n % i == 0) {\n            result /= i;\n      \
    \      break;\n        }\n    }\n    return result;", "    assert(n >= 2);\n \
    \   long max_i = 2;\n    long max_p = n;\n    long p;\n    long i;\n    // Check\
    \ if n has all prime factors.\n    for (i = 3; i <= max_p; i *= 2) {\n       \
    \ if (n % i == 0) {\n            max_p = i;\n        }\n    }\n    p = 2;\n  \
    \  while (n % p == 0) {\n        p += max_p;\n        max_p += max_p;\n    }\n\
    \    while (n % p == 0) {\n        p = p + max_p;\n        max_p += max_p;\n \
    \   }\n    return p;", "    // The 'is' conditional operator is the C++ version\
    \ of '=='.\n    if (n == 1 || n == 0)\n        return 1;\n    if (n == 2)\n  \
    \      return 2;\n    long ans = 1;\n    int limit = sqrt(n);\n    for (long i\
    \ = 2; i <= limit; ++i)\n        if (n % i == 0)\n            ans = max(ans, i);\n\
    \    return ans;", "  // Use Sieve of Eratosthenes and store all prime numbers\
    \ less than n.\n  //\n  // Sieve of Eratosthenes Sieve of Eratosthenes\n  //\n\
    \  // Sieve of Eratosthenes\n  // \n  // Input: n > 1\n  // Output: prime numbers\
    \ less than n\n  // Time Complexity: O(n * log log n)\n  // Space Complexity:\
    \ O(n)\n  //\n  \n  if (n == 0 || n==1)\n    return 1;\n  \n  long max_factor\
    \ = 1;\n  long x = 2;\n  while (x < (long) sqrt(n))\n    if (n % x == 0) {\n \
    \     max_factor *= x;\n      n /= x;\n      assert(n != 0);\n    }\n    else\n\
    \      x += 2;\n  \n  return max_factor;", "  long l=n, i=1, p, flag=0;\n  while(l%2==0\
    \ && l!=1) l=l/2;\n  for(;i<l;i=i+2) if((p=(2*i)+1, i%2==0) || p+1 == l) {\n \
    \   flag=1;\n    break;\n  }\n  if(!flag) return 1;\n  while(1) {\n    if(n%(p+1)==0)\
    \ {\n      n=n/(p+1);\n    } else {\n      p=(p*2)+2;\n      flag=0;\n      break;\n\
    \    }\n  }\n  return p;", "    long i = 2;\n    long largest = 0;\n    while\
    \ (n != 1 && i != n) {\n        // n is prime and i is not. Update i to next smallest\
    \ non-prime, greater than n.\n        while (i != n && n % i == 0) {\n       \
    \     i = i * 10 + 1;\n        }\n        // n is now not prime and i is prime.\
    \ Update largest.\n        if (i == n && n > largest) {\n            largest =\
    \ n;\n        }\n        // n is prime and i is not prime. Move to the next smallest\
    \ non-prime greater than n.\n        i = i * 10 + 1;\n    }\n    // n and i are\
    \ both not prime. Return largest.\n    return largest;", "    long m = n;\n  \
    \  // Assume n is prime\n    while(m % 2 == 0) m /= 2;\n    long x = sqrt(m);\n\
    \    long y = 1;\n    for(long i = 2; i <= x; ++i)\n    {\n        while((m%i\
    \ == 0) && (y <= x))\n        {\n            m /= i;\n            ++y;\n     \
    \   }\n    }\n    return m;", "  long i = 1L, j = 2;\n  while((i * j) <= n) {\
    \ \n    if((n % i) == 0) {\n      if((j == 2) && (i % 2 == 0)) {\n        return\
    \ i;\n      }\n      else if((j * j > n) && ((n % j) == 0)) {\n        return\
    \ j;\n      }\n    }\n    i++;\n    j++;\n  }\n  return 1;", "    // Write your\
    \ code here\n  assert(n > 1);\n  long c = 1;\n  long d = 2;\n  long factor = 2;\n\
    \  while (c < n) {\n    while (n % d == 0) {\n      factor = d;\n      n = n /\
    \ d;\n    }\n    d = d + 1;\n    c = c + 1;\n  }\n  assert(n == 1);\n  return\
    \ factor;", "\t// Initialize the smallest prime factor.\n\tlong smallest_prime_factor\
    \ = 2;\n\tlong highest_factor = 1;\n\t// Initialize the largest possible prime\
    \ factor.\n\tlong largest_possible_prime_factor = n;\n\t\n\t// While we have a\
    \ non-prime factor.\n\twhile (n%2 == 0) {\n\t\t// Find the next largest factor\
    \ by trial division.\n\t\twhile (n%2 == 0 && n != 1) {\n\t\t\thighest_factor *=\
    \ 2;\n\t\t\tn /= 2;\n\t\t}\n\t\t// If we've found a new largest factor, then set\
    \ it.\n\t\tif (highest_factor > largest_possible_prime_factor)\n\t\t\tlargest_possible_prime_factor\
    \ = highest_factor;\n\t\t// Find the smallest prime factor smaller than it.\n\t\
    \tif (smallest_prime_factor > highest_factor)\n\t\t\tsmallest_prime_factor = highest_factor;\n\
    \t}\n\t// If we've found a prime factor larger than n, then it's\n\t// definitely\
    \ not prime. If n was prime then there is no large\n\t// prime factor.\n\treturn\
    \ largest_possible_prime_factor;", "    long res = 1;\n    long max_val = n;\n\
    \    // Iterate over all prime factors of n.\n    for (long i = 2; i <= max_val;\
    \ i++) {\n        // If prime factor, do nothing.\n        if (n % i == 0) {\n\
    \            long j = i;\n            while (j * j <= max_val) {\n           \
    \     if (n % j * j == 0) {\n                    max_val = max_val / j * j;\n\
    \                    res = i;\n                }\n                j++;\n     \
    \       }\n        }\n    }\n    return res;", "    long max_factor = 1;\n   \
    \ for (long i = 2; i <= sqrt(n); ++i)\n        if (n % i == 0)\n            max_factor\
    \ = i;\n    return max_factor;", "    long f=1, f1=1;\n    while (f <= n) {\n\
    \        while ((n % f) == 0) {\n            f1++;\n            n /= f;\n    \
    \    }\n        f++;\n    }\n    return f1;", "\tlong f = 1;\n\tlong a = 0, m\
    \ = n;\n\twhile(m % 2 == 0) {\n\t\tm /= 2;\n\t\t++a;\n\t}\n\tif(a * a <= n) {\n\
    \t\tn /= a;\n\t}\n\twhile(n % 2 == 0) {\n\t\tn /= 2;\n\t\t++f;\n\t}\n\twhile((n\
    \ % 6 == 0) & (f <= (n / 2)) ) {\n\t\tn /= 6;\n\t\t++f;\n\t}\n\treturn f;", " \
    \   long max_prime = 1;\n    // Loop through the numbers 1 through n/2 and stop\
    \ at the first factor\n    for (int i = 1; i < n / 2; i++) {\n        // If n\
    \ is divisible by i add 1 to max_prime\n        if (n % i == 0) {\n          \
    \  max_prime++;\n        }\n    }\n    return max_prime;", "    long ans = n;\n\
    \    long prime = 2;\n    // First prime > 2\n    while (prime*prime <= n) {\n\
    \        long curr = 1;\n        // If prime > prime*prime, skip to next composite.\n\
    \        // If curr > n, curr is prime\n        while (curr < n) {\n         \
    \   ans = curr * prime;\n            if (ans > n) {\n                break;\n\
    \            }\n            prime++;\n            curr++;\n        }\n    }\n\
    \    return ans;", "    long lp = 1;\n    long lp_old = lp;\n    for(long i =\
    \ 0; i < (n - 1); ++i) {\n        long j = (lp * 2) + 1;\n        if (j > n) break;\n\
    \        for(long k = 0; k < (j - 1); ++k) {\n            long m = ((lp * 2) +\
    \ 1) * ((lp * 2) + 1);\n            if (m > n) break;\n            if (n % m ==\
    \ 0) {\n                lp = j;\n                lp_old = lp;\n            }\n\
    \        }\n    }\n    return lp_old;", "  assert(n > 1);\n  long factor = 1;\n\
    \  while (n != 1) {\n    if (n % factor == 0) {\n      factor++;\n    }\n    n\
    \ /= factor;\n  }\n  return factor;", "    assert(n > 1);\n    long ans = n;\n\
    \    while (ans > 1) {\n        long d = ans;\n        ans = 1;\n        for (long\
    \ div = 2; div <= d; ++div) {\n            if (d % div == 0) {\n             \
    \   break;\n            }\n        }\n        if (div > n) {\n            ans\
    \ = n;\n        }\n        long r = n;\n        n = d;\n        long m = 1;\n\
    \        while (r != 1) {\n            long temp = m * (r / 2);\n            ++m;\n\
    \            if (temp >= d) {\n                m += 1;\n                temp =\
    \ m * (r / 2);\n                --m;\n            }\n            r = temp;\n \
    \       }\n        if (n > ans) {\n            ans = n;\n        }\n    }\n  \
    \  return ans;", "    long p = 0;\n    long m = n;\n    while (m % 2 == 0) {\n\
    \        m /= 2;\n        p++;\n    }\n    long t = n;\n    while (t % 3 == 0)\
    \ {\n        t /= 3;\n        p++;\n    }\n    while (t % 5 == 0) {\n        t\
    \ /= 5;\n        p++;\n    }\n    while (t % 7 == 0) {\n        t /= 7;\n    \
    \    p++;\n    }\n    while (t % 11 == 0) {\n        t /= 11;\n        p++;\n\
    \    }\n    while (t % 13 == 0) {\n        t /= 13;\n        p++;\n    }\n   \
    \ while (t % 17 == 0) {\n        t /= 17;\n        p++;\n    }\n    while (t %\
    \ 19 == 0) {\n        t /= 19;\n        p++;\n    }\n    while (t % 23 == 0) {\n\
    \        t /= 23;\n        p++;\n    }\n    while (t % 29 == 0) {\n        t /=\
    \ 29;\n        p++;\n    }\n    while (t % 31 == 0) {\n        t /= 31;\n    \
    \    p++;\n    }\n    while (t % 37 == 0) {\n        t /= 37;\n        p++;\n\
    \    }\n    while (t % 43 == 0) {\n        t /= 43;\n        p++;\n    }\n   \
    \ while (t % 47 == 0) {\n        t /= 47;\n        p++;\n    }\n    while (t %\
    \ 53 == 0) {\n        t /= 53;\n        p++;\n    }\n    while (t % 59 == 0) {\n\
    \        t /= 59;\n        p++;\n    }\n    while (t % 61 == 0) {\n        t /=\
    \ 61;\n        p++;\n    }\n    while (t % 67 == 0) {\n        t /= 67;\n    \
    \    p++;\n    }\n    while (t % 73 == 0) {\n        t /= 73;\n        p++;\n\
    \    }\n    while (t % 79 == 0) {\n        t /= 79;\n        p++;\n    }\n   \
    \ while (t % 83 == 0) {\n        t /= 83;\n        p++;\n    }\n    while (t %\
    \ 89 == 0) {\n        t /= 89;\n        p++;\n    }\n    while (t % 97 == 0) {\n\
    \        t /= 97;\n        p++;\n    }\n    while (t % 103 == 0) {\n        t\
    \ /= 103;\n        p++;\n    }\n    while (t % 107 == 0) {\n        t /= 107;\n\
    \        p++;\n    }\n    while (t % 113 == 0) {\n        t /= 113;\n        p++;\n\
    \    }\n    while (t % 119 == 0) {\n        t /= 119;\n        p++;\n    }\n \
    \   while (t % 123 == 0) {\n        t /= 123;\n        p++;\n    }\n    while\
    \ (t % 127 == 0) {\n        t /= 127;\n        p++;\n    }\n    while (t % 131\
    \ == 0) {\n        t /= ", "    long max_divisor = 0;\n    long divisor = 2;\n\
    \    while (divisor < n) {\n        if (n % divisor == 0) {\n            if (max_divisor\
    \ < divisor)\n                max_divisor = divisor;\n            divisor += 1;\n\
    \        }\n        else {\n            divisor += 2;\n        }\n    }\n    return\
    \ max_divisor;", "\t// Start off with a few odd numbers and work our way up. Also\n\
    \t// keep track of the largest prime we've seen.\n\tstd::map<long,bool> prime_factors;\n\
    \tprime_factors.insert({2,true});\n\tprime_factors.insert({3,true});\n\tprime_factors.insert({5,true});\n\
    \tlong max_factor = 1;\n\tfor(auto &p : prime_factors) {\n\t\twhile(n > 1) {\n\
    \t\t\tn--; // Working backwards from 2\n\t\t\tlong factor = 2;\n\t\t\twhile(n\
    \ % factor == 0) {\n\t\t\t\tn /= factor;\n\t\t\t\t++factor;\n\t\t\t}\n\t\t\t//\
    \ If we had a factor larger than the current max,\n\t\t\t// update it (and remember\
    \ that we had one).\n\t\t\tif(factor > max_factor) {\n\t\t\t\tmax_factor = factor;\n\
    \t\t\t\tp.second = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn max_factor;", "    //\
    \ We only need to check the odd numbers up to sqrt(n).\n    // So start by checking\
    \ that n % 4 == 0 and then test only odd numbers\n    // up to sqrt(n).\n    long\
    \ factor = 2;\n    // Use uint64_t for bitwise operations as they give the greatest\
    \ benefit.\n    uint64_t n = n;\n    while (factor * factor <= n) {\n        uint64_t\
    \ tmp = n >> 1;\n        if (tmp == 1) return factor;\n        if (tmp % 4 ==\
    \ 0) n /= 4;\n        else n *= 2;\n        factor++;\n    }\n    return factor;",
  "    long m = n, f = 1;\n    int k;\n    int l = n, m;\n    \n    // Check for trivial\
    \ factors\n    while (m % 2 == 0)\n        m /= 2;\n    if (m == 2)\n        return\
    \ 1;\n    \n    // Look for more factors\n    while (n % 2 == 0) {\n        while\
    \ (n % m == 0)\n            n /= m;\n        m *= 2;\n    }\n    \n    // Test\
    \ for non-trivial factors\n    for (k = 3; k <= (l * m) / 2; k += 2) {\n     \
    \   if (m % k == 0)\n            m /= k;\n        if (n % k == 0)\n          \
    \  n /= k;\n    }\n    \n    // If m and n are both factors, then return m\n \
    \   if (m == n)\n        return m;\n    \n    // Otherwise return n + 1\n    return\
    \ n + 1;", "    long ans = 2;\n    for (long i = 2; i <= sqrt(n); i++) {\n   \
    \     if (n % i == 0) {\n            ans = i;\n            break;\n        }\n\
    \    }\n    return ans;", "    long m = 3; // only odd numbers greater than 1\n\
    \    long i = 2; // only even numbers greater than 1\n    while (n % 2 == 0)\n\
    \    {\n        if (i <= m)\n            i += 2;\n        else\n            m\
    \ += 2;\n        n = n / 2;\n    }\n    return i;", "    long max_prime = 1;\n\
    \    long max_power = 0;\n    long factor = 1;\n    long power = 1;\n    while\
    \ (n > 1) {\n        while (n % factor == 0) {\n            n = n / factor;\n\
    \            ++max_power;\n        }\n        if (max_power > power)\n       \
    \     power = max_power;\n        ++factor;\n        max_power = 0;\n    }\n \
    \   return factor;", "  long i, max_i = 1, max_factor = n, factor;\n  for (i =\
    \ 2; i <= n; i++) {\n    factor = max_factor;\n    max_factor *= i;\n    if (max_factor\
    \ >= n) {\n      factor = max_factor;\n    }\n    if (factor > max_i) {\n    \
    \  max_factor = factor;\n      max_i = factor;\n    }\n  }\n  return max_i;",
  "    assert(n > 1);\n    long p = 2, r = n;\n    // Find the largest prime factor\
    \ of n before n.\n    while (r != 1) {\n        while (r % p != 0) {\n       \
    \     r = (r / p) + 1;\n        }\n        p++;\n    }\n    return p;", "    //\
    \ write your code here\n    \n    long a = n;\n    while (n%2 == 0) {\n      \
    \  a = a / 2;\n    }\n    long b;\n    long c = 1;\n    long count = 1;\n    long\
    \ result = 1;\n    for (long i = 3; i <= sqrt(a); i = i + 2) {\n        if (a\
    \ % i == 0) {\n            b = a/i;\n            while (a % i == 0) {\n      \
    \          b = b * i;\n                count++;\n                a = a / i;\n\
    \            }\n            if (count == c) {\n                result = i;\n \
    \               break;\n            }\n        }\n    }\n    return result;",
  "    if (n == 1)\n        return 2;\n    long largest = 2;\n    while (largest <\
    \ n/2) {\n        if (n % largest == 0)\n            return largest;\n       \
    \ if (largest*largest < n)\n            largest++;\n    }\n    return largest;",
  "    long fact = 1;\n    for (int i = 1; i <= n; ++i) {\n        fact = fact * i;\n\
    \    }\n    fact = fact > n ? fact : n;\n    return fact == 1 ? 2 : fact;", " \
    \ assert(n > 1);\n  // If n is a prime then its largest factor is n itself.\n\
    \  if (n%2 == 0) return n;\n  // If we haven't found a larger factor yet, we're\
    \ done\n  // as n has no other factors.\n  if (n % 4 == 1 || n % 8 == 1 || n %\
    \ 16 == 1) return n;\n  // Find a prime in factorization\n  // >>> largest_prime_factor((53689))\n\
    \  // 7\n  long p = 2;\n  // Scan all odd numbers <= n\n  for (long i=3; i<=n;\
    \ i+=2)\n    // If we find a factor of n, then p must be larger than that factor.\n\
    \    if (n % i == 0) {\n      p = i;\n      break;\n    }\n  // If n is not prime,\
    \ no factor > p is larger than n\n  // so p must be prime.\n  // >>> largest_prime_factor((7))\n\
    \  // 7\n  return p;", "    long factor = 1;\n    int isPrime = 1;\n    for(int\
    \ i = 2; i <= n/i; i++){\n        isPrime = 1;\n        for(int j = 2; j < i;\
    \ j++){\n            if(i%j == 0){\n                isPrime = 0;\n           \
    \     break;\n            }\n        }\n        if(isPrime == 1){\n          \
    \  factor = i;\n            break;\n        }\n    }\n    return factor;", " \
    \   long i;\n    assert(n > 1);\n    for (i = 2; i <= n / i; i++) {\n        if\
    \ (n % i == 0) {\n            return i;\n        }\n    }\n    return n;", " \
    \   if (n == 1)\n        return 2;\n    if (n == 2)\n        return 3;\n    if\
    \ (n % 2 == 0 || n % 3 == 0)\n        return 0;\n    long a = largest_prime_factor(n\
    \ / 2);\n    long b = largest_prime_factor(n / 3);\n    if (a > b) {\n       \
    \ long temp = a;\n        a = b;\n        b = temp;\n    }\n    return (b * 3)\
    \ == n ? (a + 1) : (b * 3);", "    assert(n > 1);\n    long p = 3;\n    long m\
    \ = n/p;\n    while (m % 2 == 0) {\n        m++;\n        p++;\n    }\n    if\
    \ (p == 2) {\n        return p;\n    }\n    int i = 2;\n    for (; i <= n/(p*p);\
    \ i++) {\n        if (n % i == 0) {\n            p = i;\n        }\n    }\n  \
    \  return p + 2;", "    long factor = 1;\n    long m = n;\n    while (m != 1)\
    \ {\n        while (m % 2 == 0) {\n            m = m / 2;\n        }\n       \
    \ while (m % 3 == 0) {\n            m = m / 3;\n        }\n        while (m %\
    \ 5 == 0) {\n            m = m / 5;\n        }\n        while (m % 7 == 0) {\n\
    \            m = m / 7;\n        }\n        factor = factor * m;\n        m =\
    \ m / factor;\n    }\n    return factor;", "    long factor = 2; // prime candidate\n\
    \    for (long i = 2; i < n; i++) {\n        // skip if n is prime\n        if\
    \ (n % i == 0) {\n            n = n / i;\n            factor = i;\n          \
    \  break;\n        }\n    }\n    if (n >= 1) {\n        // n was not prime so\
    \ the highest factor was already found\n        return factor;\n    }\n    return\
    \ -1;", "    // Store factor of n in an array.\n    long fact[n + 1] = {1};\n\n\
    \    for (long i = 1; i <= n; ++i) {\n        // Fact(n - i) will give us the\
    \ largest factor of n.\n        // Also consider this factor's exponent i.\n \
    \       if (n % i == 0) {\n            // Since we already computed the largest\
    \ factor by checking the condition above, \n            // we will just add the\
    \ exponent of factor to it.\n            fact[i] = fact[n - i];\n            fact[n\
    \ - i] = i;\n        }\n    }\n\n    // If n is prime, return its exponent i.e.\
    \ the largest prime factor.\n    if (n == 2) return 2;\n\n    // If n is not a\
    \ prime number then return 1.\n    // This can occur if n is a product of some\
    \ smaller number.\n    return 1;", "   long i, maxi=0;\n   long temp=1;\n   for\
    \ (i = 2; i <= n/2; i++) {\n      if (n % i == 0) {\n         if (temp>maxi)\n\
    \            maxi=temp;\n         temp=1;\n         break;\n      }\n      else\n\
    \         temp++;\n   }\n   if (temp > maxi) \n      maxi=temp;\n   return maxi;",
  "  // Write your code here.\n  long ans=1;\n  while(n>1){\n    long test=n%ans;\n\
    \    if(test==0 || test==1) return n;\n    ans++;\n    n/=ans;\n  }\n  return\
    \ n;", "\tassert(n > 1);\n\t// Sieve of Erastosthenes - http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes\n\
    \tint k = 3, t = 2;\n\tlong ans = 1;\n\twhile (n % k == 0) {\n\t\tk++;\n\t\tt++;\n\
    \t}\n\twhile (t > k) {\n\t\tk++;\n\t\tt--;\n\t}\n\tfor (int i = 3; i <= k; i +=\
    \ t) {\n\t\tif (n % i == 0) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn\
    \ ans;", "    // Prime candidates\n    static long const primes[] = { 2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23 };\n    // Sieve of Erastosthenes (by successive squarings)\n\
    \    for (int i = 2; i < n; ++i) {\n        long const temp = n;\n        for\
    \ (int j = 0; j < primes.length; ++j) {\n            while (temp % primes[j] ==\
    \ 0) {\n                temp /= primes[j];\n            }\n        }\n       \
    \ if (temp != 1) {\n            return temp;\n        }\n    }\n    return n;",
  "    if(n <= 1) return n;\n    long i = 2;\n    long ans = 0;\n    long p = 2;\n\
    \    while(i <= n / p) {\n        long q = p * i;\n        while(q <= n) q +=\
    \ p;\n        ans = q;\n        p = i;\n        i = i + 1;\n    }\n    return\
    \ ans;", "\tif (n == 1)\n\t\treturn n;\n\n\tlong p = 2, q = n;\n\n\t// Do at most\
    \ 4 iterations\n\tfor (size_t i = 0; i < 4; ++i)\n\t{\n\t\tfor (long r = p * q;\
    \ r > 1; r /= p)\n\t\t\tq = p;\n\n\t\tp = q;\n\t}\n\treturn p;", "    if (n <\
    \ 2) return 0;\n    long max_exponent = 1;\n    long max_exponent1 = 2;\n    long\
    \ prime_factor = 1;\n    while (true) {\n        if (n % prime_factor == 0) {\n\
    \            if (max_exponent < n) max_exponent = n;\n        } else {\n     \
    \       long new_exponent = (max_exponent + max_exponent1) % n;\n            if\
    \ (new_exponent == max_exponent1) break;\n            max_exponent = new_exponent;\n\
    \            max_exponent1 = max_exponent + max_exponent1;\n        }\n      \
    \  prime_factor++;\n    }\n    return prime_factor;", "    long i = 2;\n    long\
    \ maxi = n;\n    while (i != maxi) {\n        if (n % i == 0) {\n            maxi\
    \ = i;\n        }\n        i += 2;\n    }\n    return maxi;", "    long largest_factor\
    \ = 1;\n    for (long i = 1; i <= n; ++i) {\n        while (n%i == 0) {\n    \
    \        largest_factor = i;\n            n /= i;\n        }\n    }\n    return\
    \ largest_factor;", "  long res = 1;\n  for (int i = 2; i <= n / i; i++) {\n \
    \   while (n % i == 0)\n      n /= i;\n    if (n > 1)\n      res *= i;\n  }\n\
    \  return res;", "    if(n == 1) return 1;\n    long max_value = 1;\n    long\
    \ next_max_value = 2;\n    int current_value = 3;\n    long temp;\n    while(next_max_value\
    \ <= n / 2) {\n        if(n % current_value == 0) {\n            max_value = next_max_value;\n\
    \            current_value = current_value * next_max_value;\n        }\n    \
    \    next_max_value = next_max_value * current_value;\n    }\n    temp = n;\n\
    \    while(temp > 1) {\n        if(temp % current_value == 0) {\n            temp\
    \ = temp / current_value;\n        } else {\n            temp--;\n           \
    \ current_value = current_value * next_max_value;\n        }\n    }\n    return\
    \ max_value;", "  // Store all the prime factors in an array\n  std::vector<int>\
    \ p(std::sqrt(n) + 1, 1);\n  // For each i from p[1], start adding factors\n \
    \ for (int i = 2; i <= std::sqrt(n); i++) {\n    // If i divides n, then add it\
    \ to the result\n    if (i % n == 0) {\n      p.push_back(i);\n      // If any\
    \ factor of n is found, stop the loop\n      // and exit the function\n      if\
    \ (p.back() == n) return p.back();\n    }\n  }\n  // If we got this far, n was\
    \ neither prime nor composite.\n  return 1;", "  long ret = 0;\n  int i = 2;\n\
    \  while (i < n) {\n    if (n % i == 0) {\n      ret = i;\n      break;\n    }\n\
    \    ++i;\n  }\n  return ret;", "    long n = n - 1;\n    long f = 0;\n    long\
    \ s = 1;\n    long m = n;\n    long t = 2;\n    long w = 0;\n\n    while(m < n)\
    \ {\n        while(m*t < n) {\n            t = s*t; //t = (s + 1)*t\n        \
    \    m = (m*t + 1) >> 1;\n        }\n\n        w = (m + 1) >> 1;\n\n        f\
    \ += w;\n        t = (t + s) >> 1;\n        s = w;\n        m = w;\n    }\n\n\
    \    return f;", "  long m = 2;\n  while (m <= sqrt(n)) {\n    while (n%m == 0)\
    \ {\n      n = (n/m)*m;\n      ++m;\n    }\n  }\n  return n;", "    long i = 2;\n\
    \    while (i < n && n % i == 0) {\n        i += 2;\n    }\n    return i;", " \
    \   int max = n;\n    for (int i = 3; i <= max; ++i)\n    {\n        while ((n\
    \ % i) == 0)\n        {\n            max = i;\n        }\n    }\n    return max;",
  "  long s = 2;\n  while (s * s < n) {\n    ++s;\n  }\n  long long m = n;\n  while\
    \ (m % 2 == 0) {\n    m /= 2;\n  }\n  while (m % 3 == 0) {\n    m /= 3;\n  }\n\
    \  while (m % 5 == 0) {\n    m /= 5;\n  }\n  while (m % 7 == 0) {\n    m /= 7;\n\
    \  }\n  while (m % 11 == 0) {\n    m /= 11;\n  }\n  while (m % 13 == 0) {\n  \
    \  m /= 13;\n  }\n  while (m % 17 == 0) {\n    m /= 17;\n  }\n  while (m % 19\
    \ == 0) {\n    m /= 19;\n  }\n  assert(n >= 1 && n <= (long long) 1e9 && \"n too\
    \ large\");\n  return m;", "    // Write your code here.\n    \n    int primes[]\
    \ = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47};\n    \n    int max_pf\
    \ = primes[0];\n    \n    for (int i = 1; i < primes.length; i++) {\n        if\
    \ (n % primes[i] == 0) {\n            max_pf = primes[i];\n            break;\n\
    \        }\n    }\n    \n    return max_pf;", "    long x = 2;\n    long y = 3;\n\
    \    while(x > 1) {\n        if(n % x == 0) {\n            y = y * (x / y);\n\
    \            x = 2;\n        } else {\n            x = x + 1;\n        }\n   \
    \ }\n    return y;", "    // Complete this function\n    long a = 1, b = 1, c,\
    \ d = 0;\n    for (int i = 0; i < n; ++i) {\n        c = (a * b)%n;\n        if\
    \ (c == 0)\n            ++a;\n        else\n            ++b;\n        if (a %\
    \ n == 0 && b % n == 0)\n            d = n;\n    }\n    return d;", "    long\
    \ ans = n;\n    long i = 2;\n    while (i < ans) {\n        while (ans % i ==\
    \ 0) {\n            ans /= i;\n        }\n        i++;\n    }\n    return ans;",
  "\tlong maxPrime = 2, curPrime = 1;\n\t// n is prime. One is enough.\n\tif (n ==\
    \ 1) return n;\n\t// n >= 2. No need to test more numbers.\n\tif (n >= 3) {\n\t\
    \tfor (long i = 4; i <= n; ++i) if (n % i == 0) {\n\t\t\tcurPrime = i;\n\t\t\t\
    maxPrime = i;\n\t\t}\n\t}\n\t// n is composite. Find a number m with m > n and\
    \ one other prime factor.\n\tlong m = maxPrime;\n\twhile (m % 2 == 0 && m > curPrime)\
    \ m /= 2;\n\tif (m != curPrime) {\n\t\t// m is prime. Test all multiples of m\
    \ until we find one that\n\t\t// divides n.\n\t\tfor (long i = m; i <= n; i +=\
    \ m) if (n % i == 0) {\n\t\t\tcurPrime = i;\n\t\t\tmaxPrime = i;\n\t\t}\n\t}\n\
    \treturn curPrime;", "    long x = 2;\n    long maxPrime = n;\n    long y = 3;\n\
    \    while (true) {\n        if (n % x == 0) {\n            maxPrime = x;\n  \
    \          if (n % y == 0) {\n                maxPrime = y;\n                y\
    \ = n / y;\n            } else {\n                y = n / y;\n            }\n\
    \            x = x * maxPrime;\n        } else {\n            x = x * maxPrime;\n\
    \        }\n        if (y > maxPrime) {\n            break;\n        }\n    }\n\
    \    return maxPrime;", "    long result = 3; // 2\n    while (n%2 == 0) {\n \
    \       n = n/2;\n        result++;\n    }\n    while (n%3 == 0) {\n        n\
    \ = n/3;\n        result++;\n    }\n    // now n = 3\n    // result = 2\n    //\
    \ test that n is odd\n    if (n % 2 == 1)\n        result++;\n    return result;",
  "    long factor = 1;\n    long current_factor = 1;\n    while(n > 1 && current_factor\
    \ <= n){\n        factor *= current_factor;\n        current_factor++;\n     \
    \   n--;\n    }\n    while(n>1 && current_factor != factor){\n        factor *=\
    \ current_factor;\n        n--;\n    }\n    return factor;", "    long largest_prime_factor\
    \ = 0;\n    long long limit = sqrt(n);\n    for(long long i = 2; i * i <= limit;\
    \ ++i) {\n        if(n%i == 0) {\n            limit = sqrt(n);\n            if(limit\
    \ % i == 0) {\n                largest_prime_factor = i;\n            }\n    \
    \        break;\n        }\n    }\n    return largest_prime_factor;", "\t// Make\
    \ an array to hold the prime factors found.\n\tint factor[1000] = {0};\n\t// Initialize\
    \ the array to 0 to mark the end of the factors.\n\tfor (int i = 0; i < 1000;\
    \ i++)\n\t\tfactor[i] = 0;\n\t// Set the initial state of the array to 'true'.\n\
    \tfor (int i = 0; i < 1000; i++)\n\t\tfactor[i] = 1;\n\tfor (int i = 2; i <= n\
    \ / i; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tif (n % i == 0) {\n\t\t\
    \t\tfactor[i] = i;\n\t\t\t\tfactor[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\
    }\n\tlong largest_prime = 0;\n\tfor (int i = 1000; i > 0; i--) {\n\t\tif (factor[i]\
    \ == 0) {\n\t\t\tlargest_prime = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn largest_prime;",
  "    // Base Case\n    if(n == 1) return 2;\n\n    // Recursive Case\n    if(n %\
    \ 2 == 0) return 2;\n    long largest_prime = 2; // We know that this is greater\
    \ than or equal to 2\n    long next_largest_prime = largest_prime;\n    for(int\
    \ i = 3; i <= n; i += 2) {\n        while(n % i == 0) {\n            largest_prime\
    \ = i;\n            next_largest_prime = largest_prime;\n            n /= i;\n\
    \        }\n    }\n    return next_largest_prime;", "    long p = 2;\n    long\
    \ maxp = 0;\n    for(long i = 3; i <= n; i += 2) {\n        while ((n % i) ==\
    \ 0) {\n            n /= i;\n            p++;\n        }\n        if (n > maxp)\
    \ maxp = n;\n    }\n    return maxp;", "    vector<long> primes;\n    long largest_pf\
    \ = 1;\n    bool is_prime = false;\n    for (long pf = 2; pf <= n; pf++)\n   \
    \     if (n % pf == 0) {\n            is_prime = true;\n            break;\n \
    \       }\n    if (is_prime) {\n        primes.push_back(pf);\n        while (!primes.empty())\
    \ {\n            int pf = primes.back();\n            if (pf * pf > n)\n     \
    \           break;\n            else\n                primes.pop_back();\n   \
    \         for (long a = 2; a <= n; a++) {\n                if (n % a == 0) {\n\
    \                    is_prime = false;\n                    break;\n         \
    \       }\n                if (a % pf == 0) {\n                    is_prime =\
    \ false;\n                    break;\n                }\n            }\n     \
    \       if (is_prime)\n                largest_pf = pf;\n        }\n    }\n  \
    \  else\n        largest_pf = n;\n    return largest_pf;", "    std::unordered_map<long,\
    \ long> mp;\n    mp[1] = 1;\n    mp[2] = 2;\n    long ans = 1;\n    long cnt =\
    \ 0;\n    for (long i = 3; i <= n / 2; i += 2) {\n        if (mp[i] == 1) {\n\
    \            continue;\n        }\n        cnt++;\n        for (long j = 3; j\
    \ <= n / i; j += 1) {\n            if (mp[j] == 1) {\n                continue;\n\
    \            }\n            if (cnt != 1) {\n                mp[i * j] = mp[j]\
    \ * cnt;\n            }\n            else {\n                mp[i * j] = mp[j];\n\
    \            }\n        }\n        if (cnt != 1) {\n            ans = mp[cnt /\
    \ 2] * ans;\n        }\n    }\n    return ans;", "    long fp = 1;\n    long pm\
    \ = 2;\n    long fm = 1;\n    while (fp != n) {\n        long t = fp;\n      \
    \  while ((t % pm) == 0) {\n            t /= pm;\n        }\n        t *= fp;\n\
    \        while ((t % fm) == 0) {\n            t /= fm;\n        }\n        if\
    \ (fp > t) {\n            fp = t;\n        }\n        if (fm < t) {\n        \
    \    fm = t;\n        }\n        pm += 2;\n        fm += 2;\n    }\n    return\
    \ fp;", "    if(n < 2) return 1;\n    long i = 2;\n    for(; i * i <= n; ++i)\n\
    \        if(n % i == 0) return i;\n    return n;", "    long ii, m, nc, p, q,\
    \ iq;\n    nc = 0;\n    for (ii = 1; nc < n; ii++) {\n        p = nc / ii;\n \
    \       nc = (nc - p * ii);\n        if ((nc < 2) || (nc >= i)) {\n          \
    \  nc--;\n            ii--;\n        } else {\n            if (p == 2) {\n   \
    \             m = ii * p;\n                if (m > n) {\n                    m\
    \ = n;\n                }\n                return m;\n            }\n        \
    \    nc++;\n        }\n    }\n    return nc;", "    // Use prime number to calculate\
    \ factorial.\n    // http://www.geeksforgeeks.org/program-find-the-number-of-set-bits-in-an-long-integer/\n\
    \    // http://www.geeksforgeeks.org/programming-set-bits-in-a-number/\n    long\
    \ fac = 1;\n    long div = 2;\n    // Loop while the number is greater than zero.\n\
    \    while (n > 0) {\n        // If the number is even, divide it by two\n   \
    \     if (n % 2 == 0) {\n            div++;\n            n = n / 2;\n        }\
    \ else {\n            // If n is odd, multiply by three, subtract 1, and divide\
    \ by two\n            div++;\n            n = n - 1;\n        }\n        fac =\
    \ fac * div;\n    }\n    return fac;", "  int m = n;\n  while (m % 2 == 0) {\n\
    \    m /= 2;\n  }\n  // Assume n is prime\n  assert(n > 2);\n  while (m % 2 ==\
    \ 0) {\n    m /= 2;\n  }\n  long p = 2;\n  while (p < m) {\n    long q = 3;\n\
    \    while (p < q) {\n      if (m % p == 0) {\n        m /= p;\n        break;\n\
    \      }\n      q /= p;\n    }\n    if (m % p == 0) {\n      m /= p;\n      break;\n\
    \    }\n    p += 2;\n  }\n  return n;", "  long p = 0;\n  long q = n;\n  long\
    \ r = 2;\n  while (r * r <= n) {\n    while (q % r == 0) {\n      p += 1;\n  \
    \    q /= r;\n    }\n    r += 1;\n  }\n  return p;", "    long a = n, m = 2, p\
    \ = 2;\n    long b = 1;\n    long t = 1;\n    long d = 1;\n    while (b > 0) {\n\
    \        if (p % 2 == 1) {\n            if (n == 1) {\n                p = 1;\n\
    \                break;\n            }\n            p = 2;\n            while\
    \ (p < 2 * m) {\n                while (a % p == 0) {\n                    a /=\
    \ p;\n                    b *= p;\n                    d++;\n                }\n\
    \                p++;\n            }\n            if (a == 1) {\n            \
    \    p = 2;\n            }\n        } else if (m > 2) {\n            p = 2;\n\
    \            while (p < 2 * m) {\n                while (a % p == 0) {\n     \
    \               a /= p;\n                    b *= p;\n                    d++;\n\
    \                }\n                p++;\n            }\n            if (a ==\
    \ 1) {\n                p = 1;\n            }\n        } else {\n            if\
    \ (n == 1) {\n                p = 1;\n                break;\n            }\n\
    \            p = 2;\n            while (p < 2 * m) {\n                while (a\
    \ % p == 0) {\n                    a /= p;\n                    b *= p;\n    \
    \                d++;\n                }\n                p++;\n            }\n\
    \            if (a == 1) {\n                p = 2;\n            }\n        }\n\
    \        m++;\n    }\n    cout << \"d = \" << d << endl;\n    cout << \"b = \"\
    \ << b << endl;\n    if (n <= 2) {\n        return 1;\n    }\n    long l = pow(b,\
    \ pow(2, log((n + 1) / 2) - d));\n    return l;", "    assert(n > 1);\n    long\
    \ p = 2;\n    // The largest prime factor is one less than the square root of\
    \ the number.\n    while (n%p) {\n        p += 2;\n    }\n    return p;", "  \
    \  long p = 2;\n    long a = n;\n    while (a) {\n        if (a & 1) a = p/a;\n\
    \        else p++;\n    }\n    return p;", "    long f = 0;\n    long a = n;\n\
    \    while (n/a > 1) {\n        if (n % a == 0) {\n            f = a;\n      \
    \      break;\n        }\n        a = n/a;\n    }\n    return f;", "  assert(n\
    \ > 1);\n  long f = 1;\n  while (f <= n && n % f == 0) {\n    f++;\n  }\n  if\
    \ (f > n) {\n    f = n;\n  }\n  return f;", "    long long max = 1LL;\n    long\
    \ long m = 0LL;\n    for (int i = 1; i < n; i++) {\n        m = i * 2;\n     \
    \   while (m <= max) {\n            if (n % m == 0) {\n                max = m;\n\
    \            }\n            m++;\n        }\n    }\n    return max;", "    long\
    \ max_factor = 1;\n    long num_factors;\n    long divisor;\n    for (num_factors\
    \ = 2; num_factors <= n; num_factors += 2) {\n        divisor = n / num_factors;\n\
    \        if (divisor > max_factor) {\n            max_factor = divisor;\n    \
    \    }\n    }\n    return max_factor;", "    if (n < 2) {\n        return 0;\n\
    \    }\n\n    long f = 3;\n    for (long i = 2; i <= n; ++i) {\n        if ((n\
    \ % i) == 0) {\n            f = i;\n        }\n    }\n    return f;", "  // A\
    \ prime factor is defined as dividing n by any integer other than 1.\n  // A prime\
    \ factor is called a factor because it is not divisible by any number other than\
    \ 1.\n  // This also means a prime factor will never be longer than 2.\n  assert(n\
    \ > 1);\n  if (n == 1) return 2;\n\n  // Initialize factors to 2 and 3.\n  long\
    \ a = 2, b = 3;\n\n  // Find greatest common divisor.\n  // This can be computed\
    \ while iterating through all possible factors.\n  while (a < n) {\n    long c\
    \ = a % b;\n    // If any factor divides a then gcd(a, b) is equal to a.\n   \
    \ if (c != 0) {\n      // If c divides a, then a is also a factor of b.\n    \
    \  if (c != a) return c;\n    }\n    b = a;\n    a = a / b;\n  }\n\n  // If a\
    \ is greater than or equal to n-1, then n is not a prime factor.\n  return a;",
  "    vector<long long int> primes;\n    vector<long long int>::iterator it;\n  \
    \  long long int a = 1, b = 1;\n    for (long long int i = 2; i < n; ++i) {\n\
    \        long long int c = 1;\n        for (it = primes.begin(); it != primes.end();\
    \ ++it) {\n            long long int d = (*it) * (*it);\n            if (c < d)\
    \ c = d;\n        }\n        if (c != 1) {\n            primes.push_back(c / a);\n\
    \            if (n % primes.back() == 0) b = c;\n        }\n    }\n    return\
    \ b;", "\tassert(n > 1);\n\tlong result = 1;\n\tbool flag = false;\n\t// Sieve\
    \ of Erastosthenes using odd composite numbers.\n\tfor (int i = 2; i <= n; i +=\
    \ 2) {\n\t\tflag = true;\n\t\tfor (long j = 2; j < i; j += 2) {\n\t\t\tif (i %\
    \ j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag)\n\
    \t\t\tresult += i;\n\t}\n\treturn result;", "    // Initializing prime_list with\
    \ 0s makes it easy to find the largest factor\n    // without having to worry\
    \ about n's prime factors leading up to it.\n    vector<long> prime_list{0}, factor_list{2},\
    \ current_factor;\n    for (long i = 2; i * i <= n; ++i) {\n        current_factor\
    \ = 2;\n        while ((current_factor < prime_list.size()) && (n % current_factor\
    \ == 0)) {\n            factor_list.push_back(current_factor);\n            current_factor++;\n\
    \        }\n        if (current_factor < prime_list.size()) {\n            prime_list.push_back(current_factor);\n\
    \        }\n    }\n    return prime_list[prime_list.size() - 1];", "    assert(n\
    \ > 1);\n    if (n == 1) return 1;\n    long ret = largest_prime_factor(n/2);\n\
    \    if (n % 2 == 0) return ret*2;\n    if (ret % 2 == 0) return ret;\n    return\
    \ ret;", "    // Write your code here.\n    long factor = 1;\n    long prime =\
    \ n;\n    bool flag = true;\n    while (prime != 1) {\n        if (flag == true)\
    \ {\n            factor = 2;\n        }\n        else {\n            flag = false;\n\
    \            prime = prime / 2;\n            factor = prime + 1;\n        }\n\
    \    }\n    return factor;", "    long i = 2;\n    long prime = 2;\n    while\
    \ (i < n) {\n        if (n % i == 0) {\n            prime = i;\n            n\
    \ /= i;\n        }\n        i++;\n    }\n    if (n > 1)\n        prime = n;\n\
    \    return prime;", "    int max_prime = 2;\n    long max_multiple = 1;\n   \
    \ for (int i = 3; i <= n / i; i++) {\n        if (n % i == 0) {\n            while\
    \ (n % i == 0) {\n                n /= i;\n                max_multiple = i;\n\
    \            }\n            if (n > 1) {\n                max_prime = i;\n   \
    \             max_multiple = n;\n            }\n        }\n    }\n    return max_multiple;",
  "  assert(n > 1);\n  // Create a vector to hold the prime factors.\n  vector<long>\
    \ divisors(n);\n  // Set the first divisor to 1.\n  divisors[0] = 1;\n  // Loop\
    \ through each number greater than 2 and check whether it is prime or not.\n \
    \ for (long i = 2; i < n; i++) {\n    // Check if the number is divisible by any\
    \ prime factor in the vector.\n    // If yes then update the divisor for that\
    \ number.\n    if (divisors[i] == n) {\n      continue;\n    }\n    // Otherwise,\
    \ divide it by all the prime factors and add it to the vector.\n    for (long\
    \ j = i; j < n; j += i) {\n      divisors[j] /= i;\n    }\n  }\n  // Return all\
    \ the numbers that are divisible by all the numbers.\n  for (long k = 0; k < n;\
    \ k++) {\n    if (divisors[k] != n) {\n      return k;\n    }\n  }\n  // Return\
    \ n if all the numbers in the vector are divisible by n.\n  return n;", "    long\
    \ res = 1;\n    for (int i = 1; i < n; ++i) {\n        if (n % i == 0) {\n   \
    \         res = i;\n            if (res * i > n)\n                res = n;\n \
    \       }\n    }\n    return res;", "    long i = 2;\n    long result = 1;\n \
    \   // While i is less than or equal to n.\n    while (i * i < n) {\n        //\
    \ If i is divisible by any number between 2 and i-1,\n        // the factorization\
    \ is a prime\n        if (n % i == 0) {\n            result = i;\n           \
    \ break;\n        }\n        // Else, increment i.\n        ++i;\n    }\n    return\
    \ result;", "    if(n<2)\n        return 0;\n    \n    long max = n*(n+1)/2;\n\
    \    long m = n;\n    \n    for(long i=2; i<max; i++) {\n        if(m%i == 0)\
    \ {\n            m = m/i;\n        }\n    }\n    return m;", "    if (n == 2)\
    \ return 2;\n    long max_prod = 2;\n    long cur = 2;\n    while (true) {\n \
    \       if (n % cur == 0) return cur;\n        if (cur > max_prod) {\n       \
    \     max_prod = cur;\n        }\n        cur += 2;\n    }", "    long res = 2;\n\
    \    while (n > 1) {\n        if (n % res == 0)\n            return res;\n   \
    \     ++res;\n    }\n    return n;", "    long max_factor = 1;\n    long prime\
    \ = 2;\n    long count = 0;\n    while (n > 1) {\n        if (n % prime == 0)\
    \ {\n            max_factor = prime;\n        }\n        prime++;\n        n/=prime;\n\
    \        count++;\n    }\n    if (count == 1) {\n        max_factor = 1;\n   \
    \ } else {\n        max_factor = max_factor * count;\n    }\n    return max_factor;",
  "    // your code goes here\n    long largest_factor = 2;\n    int flag = 0;\n \
    \   while (n > 2) {\n        if ((n % 2) == 0) {\n            if ((n / 2) == 2)\
    \ {\n                flag = 1;\n                break;\n            }\n      \
    \  }\n        largest_factor++;\n        if (largest_factor > n) {\n         \
    \   break;\n        }\n        n /= 2;\n    }\n    return largest_factor;"]
stop_tokens:
- "\n}"
