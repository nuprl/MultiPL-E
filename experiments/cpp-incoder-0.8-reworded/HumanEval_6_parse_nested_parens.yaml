name: HumanEval_6_parse_nested_parens
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is\
  \ a string represented multiple groups for nested parentheses separated by spaces.\n\
  // For each of the group, output the deepest level of nesting of parentheses.\n\
  // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
  \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
  \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
  \ paren_string) {\n"
tests: "}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
  (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
  \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
  \ (std::vector<long>({(long)4})));\n}\n"
completions: ["  std::vector<long> max_level_of_nesting;\n  std::vector<long> level_of_nesting;\n\
    \  std::vector<long> level;\n  for (long i = 0, size = paren_string.length();\
    \ i < size; i++) {\n    if (paren_string[i] == ')') {\n      // If we reach the\
    \ end of the string, start collecting the level again\n      if (i == (size -\
    \ 1)) {\n        level_of_nesting.push_back(level.size());\n        level.clear();\n\
    \      }\n    } else {\n      // Append the new level\n      level.push_back(paren_string[i]);\n\
    \    }\n  }\n  for (long i = 0, size = level_of_nesting.size(); i < size; i++)\
    \ {\n    if (level_of_nesting[i] > max_level_of_nesting.size()) {\n      max_level_of_nesting.resize(level_of_nesting[i]);\n\
    \    }\n  }\n  return max_level_of_nesting;", "    std::vector<long> nested_parens;\n\
    \    // Iterate over all characters in the string.\n    for (size_t i = 0; i <\
    \ paren_string.length(); ++i) {\n        // If current character is space, ignore\
    \ it.\n        if (paren_string[i] == ' ') continue;\n        // If current character\
    \ is (, increase level of nesting and output it.\n        if (paren_string[i]\
    \ == '(') {\n            nested_parens.push_back(1);\n            continue;\n\
    \        }\n        // If current character is ), decrease level of nesting and\
    \ output it.\n        if (paren_string[i] == ')') {\n            auto it = nested_parens.begin();\n\
    \            for (auto level_down = it; level_down > 0 && nested_parens[level_down\
    \ - 1]; --level_down)\n                ;\n            nested_parens.erase(it);\n\
    \            continue;\n        }\n        // If current character is ), output\
    \ level of nesting.\n        if (paren_string[i] == ')' && nested_parens.back())\
    \ {\n            nested_parens.back()--;\n            continue;\n        }\n \
    \       // If current character is ), ignore it.\n        if (paren_string[i]\
    \ == ')') continue;\n        // If current character is ), increase level of nesting\
    \ and output it.\n        if (paren_string[i] == ')' && nested_parens.back())\n\
    \            nested_parens.push_back(1);\n    }\n    return nested_parens;", " \
    \   std::vector<long> nested_paren_count;\n    long level = 0;\n    std::vector<std::vector<long>>\
    \ paren_levels;\n    std::vector<std::vector<long>> paren_levels_reverse;\n  \
    \  paren_levels.push_back(std::vector<long>());\n    paren_levels_reverse.push_back(std::vector<long>());\n\
    \    std::string parens = \"\";\n    std::string current_paren = paren_string;\n\
    \    while (std::getline(std::cin, current_paren)) {\n        parens += current_paren;\n\
    \        paren_levels[level].push_back(long(parens.size()));\n        parens +=\
    \ \"(\";\n        current_paren = paren_string;\n        while (std::getline(std::cin,\
    \ current_paren)) {\n            parens += current_paren;\n            paren_levels[level].push_back(long(parens.size()));\n\
    \            parens += \")\";\n        }\n        level = paren_levels[level].size()\
    \ - 1;\n        parens += \")\";\n        paren_levels_reverse[parens.size() -\
    \ 1][level] = long(level);\n    }\n    for (auto i = 0; i < paren_levels_reverse.size();\
    \ i++) {\n        for (auto j = 0; j < paren_levels_reverse[i].size(); j++) {\n\
    \            assert(j < paren_levels_reverse[i].size() - 1);\n            nested_paren_count.push_back(paren_levels_reverse[i][j\
    \ + 1] - paren_levels_reverse[i][j]);\n        }\n    }\n    return nested_paren_count;",
  "    std::vector<long> nestings;\n    std::vector<char> paren_chars;\n    std::string\
    \ current_paren_char;\n    std::string current_nested_paren_char;\n    long current_nested_level\
    \ = 0;\n    for (auto ch : paren_string) {\n        switch (ch) {\n          \
    \  case ')': current_nested_level--;\n                break;\n            case\
    \ '(': current_nested_level++;\n                break;\n            default:\n\
    \                current_nested_level = 0;\n        }\n\n        if (current_nested_level\
    \ == 0) {\n            current_nested_paren_char += ch;\n        } else {\n  \
    \          assert(current_nested_level >= 1);\n            nestings.push_back(current_nested_level);\n\
    \            paren_chars.push_back(current_nested_paren_char);\n            current_nested_paren_char\
    \ = \"\";\n            current_nested_level = 0;\n        }\n    }\n\n    assert(current_nested_level\
    \ == 0);\n    assert(current_nested_paren_char == \"\");\n    nestings.push_back(current_nested_level);\n\
    \    paren_chars.push_back(current_nested_paren_char);\n    return nestings;",
  "    std::vector<long> level;\n    std::string cur_level;\n    for (auto c : paren_string)\
    \ {\n        if (c == '(') {\n            cur_level = cur_level + (cur_level.empty()\
    \ ? '0' : ' ');\n            level.push_back(std::stoi(cur_level));\n        \
    \    cur_level = ' ';\n        } else {\n            cur_level = cur_level + (c\
    \ == '(' ? '(' : ' ');\n            level.push_back(std::stoi(cur_level));\n \
    \       }\n    }\n    return level;", "    std::vector<long> output_nesting_level;\n\
    \    // Initialize output nesting level with the maximum nesting level.\n    output_nesting_level.reserve(2);\n\
    \    // The first time we encounter parentheses, we put 1 as nesting level.\n\
    \    output_nesting_level.push_back(1);\n    // The second time we encounter parentheses,\
    \ we put 0 as nesting level.\n    output_nesting_level.push_back(0);\n    // Iterate\
    \ over the string backwards, as if we're iterating over the string forwards.\n\
    \    // Each time we encounter a parentheses, we increase the nesting level and\
    \ decrease the output nesting level.\n    for (long i = paren_string.size() -\
    \ 1; i >= 0; i--) {\n        if (paren_string[i] == '(') {\n            output_nesting_level[output_nesting_level.size()\
    \ - 1]++;\n        } else if (paren_string[i] == ')') {\n            output_nesting_level[output_nesting_level.size()\
    \ - 1]--;\n            if (output_nesting_level[output_nesting_level.size() -\
    \ 1] == 0) {\n                output_nesting_level.pop_back();\n            }\n\
    \        }\n    }\n    return output_nesting_level;", "    std::vector<long> paren_levels(paren_string.size(),\
    \ 0);\n    std::string current_paren_string;\n    for(size_t i = 1; i < paren_string.size();\
    \ ++i) {\n        if(paren_string[i] == '(') {\n            paren_levels[i] =\
    \ paren_levels[i - 1] + 1;\n            current_paren_string = paren_string[i];\n\
    \        }\n        else if(paren_string[i] == current_paren_string) {\n     \
    \       paren_levels[i]++;\n        }\n    }\n    return paren_levels;", "   \
    \ std::vector<long> max_level;\n    std::stack<long> level;\n    long level_count\
    \ = 1;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == ')') {\n            if (level_count > max_level.back()) {\n             \
    \   max_level.resize(max_level.size() + 1, level_count);\n                level.clear();\n\
    \            }\n            level_count++;\n        }\n        if (paren_string[i]\
    \ == '(') {\n            if (level_count > max_level.back()) {\n             \
    \   max_level.resize(max_level.size() + 1, level_count);\n                level.clear();\n\
    \            }\n            level.push(level_count);\n        }\n    }\n    while\
    \ (!level.empty()) {\n        level_count = level.top();\n        level.pop();\n\
    \        max_level.push_back(level_count);\n    }\n    return max_level;", " \
    \ std::vector<long> result;\n  // Keep track of the depth of the currently opened\
    \ parantheses\n  long level = 0;\n  for (auto c : paren_string) {\n    if (c ==\
    \ '(') {\n      ++level;\n    } else if (c == ')') {\n      if (level == 0) {\n\
    \        result.push_back(-1LL);\n      } else {\n        --level;\n      }\n\
    \    }\n  }\n  return result;", "    std::vector<long> result;\n    std::string\
    \ curr_paren_string = paren_string;\n    long cur_depth = 0;\n    bool is_opening\
    \ = true;\n    bool is_closing = false;\n    for (auto it = std::begin(curr_paren_string);\n\
    \         it != std::end(curr_paren_string); ++it) {\n        if (*it == '(')\
    \ {\n            ++cur_depth;\n            is_opening = true;\n        } else\
    \ if (*it == ')') {\n            is_closing = true;\n        } else if (*it ==\
    \ ')' && is_opening) {\n            ++cur_depth;\n            is_opening = false;\n\
    \        } else if (*it == ')' && is_closing) {\n            --cur_depth;\n  \
    \          is_closing = false;\n        } else {\n            assert(is_opening\
    \ && \"mismatched parenthesis!\");\n            result.push_back(cur_depth);\n\
    \        }\n    }\n    return result;", "\t// Recursive base case\n\tif (paren_string.empty())\
    \ {\n\t\treturn std::vector<long>({0});\n\t}\n\n\t// Use a map to store the parentheses'\
    \ depth\n\tstd::map<std::string,long> paren_depth;\n\n\t// To store depth of each\
    \ parentheses\n\tstd::vector<long> paren_stack(paren_string.size(),0);\n\n\t//\
    \ Store the depth of the parentheses\n\tlong cur_depth = 0;\n\n\t// Iterate through\
    \ each parentheses\n\tauto it = paren_string.begin();\n\tfor (; it != paren_string.end();\
    \ ++it) {\n\t\tchar c = *it;\n\n\t\t// If current parentheses has depth, add parentheses'\
    \ depth\n\t\tif (paren_depth[c]) {\n\t\t\tparen_depth[c] += cur_depth;\n\t\t}\n\
    \n\t\t// Else, initialize parentheses' depth\n\t\telse {\n\t\t\tparen_depth[c]\
    \ = cur_depth;\n\t\t}\n\n\t\t// Increment depth\n\t\tcur_depth++;\n\n\t\t// Remove\
    \ parentheses depth\n\t\tif (c == '(') {\n\t\t\tparen_stack[paren_depth[c] - 1]--;\n\
    \t\t}\n\t\tif (c == ')') {\n\t\t\tparen_stack[paren_depth[c] - 1]++;\n\t\t}\n\t\
    }\n\n\t// Return parentheses' depth\n\treturn paren_depth;", "  std::vector<long>\
    \ level;\n  level.push_back(0);\n  std::stack<long> stack;\n  stack.push(0);\n\
    \  bool found = false;\n  std::string tmp;\n  std::string tmp_last;\n  for(auto\
    \ it = paren_string.begin(); it != paren_string.end(); ++it) {\n    if(*it ==\
    \ '(') {\n      found = false;\n      tmp = tmp_last;\n      stack.push(0);\n\
    \      tmp_last = *it;\n      continue;\n    }\n    if(*it == ')') {\n      found\
    \ = true;\n      long level = 0;\n      while(stack.size() > 0) {\n        level\
    \ += stack.top();\n        stack.pop();\n      }\n      if(found && level > level[level.size()\
    \ - 1]) {\n        level.push_back(level);\n      }\n      tmp_last = tmp;\n \
    \     stack.push(0);\n      tmp = \"\";\n      continue;\n    }\n    tmp = tmp\
    \ + *it;\n    stack.push(*it == '(' ? 1 : -1);\n  }\n  while(stack.size() > 0)\
    \ {\n    level += stack.top();\n    stack.pop();\n  }\n  if(!found || level[level.size()\
    \ - 1] == 0)\n    return std::vector<long>(level.begin(), level.end());\n  else\n\
    \    return std::vector<long>(level.begin() + 1, level.end());", "  std::vector<long>\
    \ paren_depths;\n  for (auto c : paren_string) {\n    if (c == '(') {\n      paren_depths.push_back(0);\n\
    \    } else if (c == ')') {\n      if (paren_depths.empty())\n        paren_depths.push_back(0);\
    \ // For empty string case\n      else {\n        // Use binary search to find\
    \ the index of the maximum depth parentheses found\n        auto index = std::lower_bound(paren_depths.begin(),\
    \ paren_depths.end(), 0);\n        paren_depths.insert(index, paren_depths.back()\
    \ + 1);\n      }\n    }\n  }\n  return paren_depths;", "    std::vector<long>\
    \ result;\n    stack<string> para_stack;\n    for (char &ch : paren_string) {\n\
    \        if (ch == '(') {\n            para_stack.push(ch);\n        }\n     \
    \   if (ch == ')') {\n            char top_of_para = para_stack.top();\n     \
    \       if (top_of_para != '(') {\n                throw std::runtime_error(\"\
    Invalid paren string\");\n            }\n            para_stack.pop();\n     \
    \       if (para_stack.size() == 0) {\n                result.push_back(para_stack.size());\n\
    \            }\n        }\n    }\n    return result;", "    std::vector<long>\
    \ result;\n    result.push_back(0); // The deepest level of nesting at index 0\
    \ is 0.\n    std::string curr_paren_string = paren_string; // The string holding\
    \ current nested parentheses.\n    bool has_left = false;\n    bool has_right\
    \ = false;\n    bool has_left_or_right = false;\n\n    while(!curr_paren_string.empty())\
    \ {\n        long curr_level_of_nesting = 1;\n        // If we have seen a left\
    \ parentheses or right parentheses, then update curr_level_of_nesting.\n     \
    \   if(curr_paren_string[0] == '(' || curr_paren_string[0] == '[') {\n       \
    \     if(has_left || has_right) {\n                curr_level_of_nesting++;\n\
    \            }\n            has_left = has_right = has_left_or_right = curr_paren_string[0]\
    \ == '(';\n        } else if(curr_paren_string[0] == ')' || curr_paren_string[0]\
    \ == ']') {\n            if(has_left || has_right) {\n                curr_level_of_nesting--;\n\
    \            }\n            has_left = has_right = has_left_or_right = curr_paren_string[0]\
    \ == ')';\n        }\n\n        if(curr_level_of_nesting > result.back()) {\n\
    \            result.push_back(curr_level_of_nesting);\n        }\n\n        //\
    \ Update the string with current parentheses.\n        curr_paren_string = curr_paren_string.substr(1,\
    \ curr_paren_string.length() - 2);\n\n        // If we have seen a left parentheses\
    \ or right parentheses, then update curr_level_of_nesting.\n        if(curr_paren_string.empty())\
    \ {\n            if(has_left || has_right) {\n                curr_level_of_nesting++;\n\
    \            }\n        }\n    }\n\n    // Sort the result to get the deepest\
    \ nesting at index 0.\n    std::sort(result.begin(), result.end());\n\n    return\
    \ result;", "  std::vector<long> result(paren_string.size(), 0);\n  // To calculate\
    \ the number of open and close parenthesis, count the number of '(' and ')'.\n\
    \  // This is done by iterating through every element in the string.\n  for (size_t\
    \ i = 0; i < paren_string.size(); ++i) {\n    if (paren_string[i] == '(') {\n\
    \      ++result[paren_string[i]];\n    }\n    else if (paren_string[i] == ')')\
    \ {\n      --result[paren_string[i]];\n    }\n  }\n  // To calculate the max level\
    \ of nesting, we need to iterate through every element in the string again.\n\
    \  for (size_t i = 0; i < paren_string.size(); ++i) {\n    if (paren_string[i]\
    \ > 0 && paren_string[paren_string[i] - 1] > 0) {\n      // This parenthesis is\
    \ nested one more level to the right, so increase the max level by one.\n    \
    \  // This is done by iterating through every element in the string again from\
    \ the end.\n      for (size_t j = paren_string.size() - 1; j >= i; j--) {\n  \
    \      // If a close parenthesis is found, we need to decrease the level of nesting\
    \ by one.\n        if (paren_string[j] == ')') {\n          --result[paren_string[j]];\n\
    \        }\n      }\n    }\n  }\n  return result;", "    std::vector<long> result;\n\
    \    std::string parens[MAX_NESTING];\n    int paren_index = 0;\n\n    bool is_parenthesis\
    \ = false;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            is_parenthesis = true;\n        } else if (paren_string[i]\
    \ == ')') {\n            is_parenthesis = false;\n        }\n        if (is_parenthesis)\
    \ {\n            parens[paren_index++] = i;\n        }\n    }\n\n    for (size_t\
    \ i = 0; i < paren_index; i++) {\n        int parens_size = paren_index - i;\n\
    \        if (parens_size >= 2) {\n            int max_parens = 0;\n          \
    \  for (int j = parens_size - 1; j < parens_size; j++) {\n                if (parens[j]\
    \ == parens[j + 1]) {\n                    max_parens = std::max(max_parens, j\
    \ - 1);\n                } else {\n                    break;\n              \
    \  }\n            }\n            result.push_back(max_parens);\n        } else\
    \ {\n            assert(parens_size == 1);\n            result.push_back(1);\n\
    \        }\n    }\n    return result;", "    // Initialize the output vector\n\
    \    std::vector<long> output_vector;\n    // Initialize the paren count of the\
    \ last level\n    long paren_count = 1;\n    // Iterate through each character\
    \ in the input string\n    for (auto c : paren_string) {\n        // If current\
    \ character is a left parenthesis\n        if (c == '(') {\n            // If\
    \ paren count is less than or equal to current level\n            // and we are\
    \ not at the end of the input\n            if (paren_count <= output_vector.size()\
    \ &&\n                c != paren_string[paren_string.size() - 1]) {\n        \
    \        // then add current level to output vector\n                output_vector.push_back(paren_count);\n\
    \                // increment the paren count\n                paren_count +=\
    \ 1;\n            }\n            // If paren count is greater than current level\n\
    \            // and we are not at the end of the input\n            else if (paren_count\
    \ > output_vector.size() &&\n                c != paren_string[paren_string.size()\
    \ - 1]) {\n                // then add current level to output vector\n      \
    \          output_vector.push_back(paren_count);\n                // increment\
    \ the paren count\n                paren_count += 1;\n            }\n        \
    \    // If paren count is greater than current level\n            // but we are\
    \ at the end of the input\n            else if (paren_count > output_vector.size()\
    \ &&\n                c == paren_string[paren_string.size() - 1]) {\n        \
    \        // then add current level to output vector\n                output_vector.push_back(paren_count);\n\
    \                // increment the paren count\n                paren_count +=\
    \ 1;\n            }\n        }\n        // If current character is a right parenthesis\n\
    \        else if (c == ')') {\n            // If the current level is greater\
    \ than the previous level\n            if (paren_count > output_vector.size())\
    \ {\n                // then add current level to output vector\n            \
    \    output_vector.push_back(paren_count);\n                // increment the paren\
    \ count\n                paren_count += 1;\n            }\n            // If the\
    \ current level is equal to the previous level\n            else if (paren_count\
    \ == output_vector.size()) {\n                // then add current level to output\
    \ vector\n                output_vector.push_back(paren_count);\n            \
    \    // increment the paren count\n                paren_count += 1;\n       \
    \     }\n            // If the current level is less than the previous level\n\
    \            else {\n                // then add the level of parenthesis to the\
    \ output vector\n                output_vector.push_back(output_vector.size()\
    \ - paren_count + 1);\n                // increment the paren count\n        \
    \        paren_count += 1;\n            }\n        }\n    }\n    // return output\
    \ vector\n    return output_vector;", "  std::vector<long> max_level_of_nesting;\n\
    \  std::string token;\n  for (char c : paren_string) {\n    if (c == '(' || c\
    \ == ')') {\n      token = token.empty() ? c : token + c;\n    } else {\n    \
    \  token = token.empty() ? token : c + token;\n      max_level_of_nesting.push_back(std::stoll(token));\n\
    \      token.clear();\n    }\n  }\n  return max_level_of_nesting;", "\tstd::vector<long>\
    \ paren_depths;\n\tparen_string.clear();\n\t\n\tlong parentheses_level = 0;\n\t\
    for (auto &c: paren_string) {\n\t\tif (c == '(' || c == '[' || c == '{' || c ==\
    \ '(') {\n\t\t\tparentheses_level += 1;\n\t\t} else if (c == ')' || c == ']' ||\
    \ c == '}' || c == ')') {\n\t\t\tparentheses_level -= 1;\n\t\t}\n\t\t\n\t\tif\
    \ (parentheses_level == 0) {\n\t\t\tparen_depths.push_back(parenthesis_level);\n\
    \t\t}\n\t}\n\t\n\treturn paren_depths;", "    std::vector<std::string> paren_groups;\n\
    \    std::size_t pos = 0;\n    std::string group_str;\n    std::vector<long> max_levels_of_interest;\n\
    \    // Iterate through the entire string\n    while (pos < paren_string.size())\
    \ {\n        // Find next opening parenthesis\n        pos = paren_string.find_first_of(\"\
    ()\", pos);\n        if (pos == std::string::npos) break;\n        // Find the\
    \ opening parenthesis group\n        group_str = paren_string.substr(0, pos);\n\
    \        paren_groups.push_back(group_str);\n        // Find the closing parenthesis\
    \ group\n        pos = paren_string.find_first_of(\")\", pos);\n        if (pos\
    \ == std::string::npos) break;\n        // Find the closing parenthesis group\n\
    \        group_str = paren_string.substr(pos + 1, paren_string.size() - pos -\
    \ 1);\n        paren_groups.push_back(group_str);\n    }\n    // Parse the groups\
    \ to find out max level of nesting\n    long max_level = 0;\n    for (size_t i\
    \ = 0; i < paren_groups.size(); ++i) {\n        std::size_t level_of_nesting =\
    \ paren_groups[i].size();\n        // If this group has same max level of nesting\
    \ as the last group, add one\n        if (level_of_nesting > max_level) {\n  \
    \          max_level = level_of_nesting;\n        }\n    }\n    // Add the current\
    \ max level of nesting to vector if max level is 0\n    if (max_level == 0) {\n\
    \        max_level = max_levels_of_interest.size();\n    }\n    // Add the current\
    \ max level of nesting to vector\n    max_levels_of_interest.push_back(max_level);\n\
    \    // Return the vector\n    return max_levels_of_interest;", "  std::vector<long>\
    \ paren_levels;\n  paren_levels_t par;\n  par.parens = paren_string.find_first_of(\"\
    ()\");\n  par.bracks = paren_string.find_first_of(\"[]\");\n  par.braces = paren_string.find_first_of(\"\
    {}\");\n  while (!par.parens.is_end() || !par.bracks.is_end() || !par.braces.is_end())\
    \ {\n    std::string temp;\n    if (par.parens.is_end() && par.bracks.is_end()\
    \ && par.braces.is_end()) {\n      throw std::runtime_error(\"Malformed parentheses\"\
    );\n    }\n    temp = paren_string.substr(0, par.parens.base());\n    temp = temp\
    \ + \")\";\n    temp = temp + paren_string.substr(par.parens.base(), par.bracks.end()\
    \ - par.parens.base());\n    temp = temp + \"[\";\n    temp = temp + paren_string.substr(par.bracks.base(),\
    \ par.braces.end() - par.bracks.base());\n    temp = temp + \"{\";\n    temp =\
    \ temp + paren_string.substr(par.braces.base(), paren_string.size() - par.braces.base());\n\
    \    paren_string = temp;\n    par.parens = paren_string.find_first_of(\"()\"\
    );\n    par.bracks = paren_string.find_first_of(\"[]\");\n    par.braces = paren_string.find_first_of(\"\
    {}\");\n  }\n  temp = paren_string.substr(0, paren_string.find_first_of(\")\"\
    ));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )\"));\n  paren_string = temp;\n  temp = paren_string.substr(0, paren_string.find_first_of(\"\
    )", "    // Count how many opening parentheses do we have in the string.\n   \
    \ int paren_count = paren_string.size();\n    // Initialize a vector to store\
    \ our results.\n    std::vector<long> paren_levels(paren_count);\n    // Initialize\
    \ the results to zero.\n    for (int i = 0; i < paren_count; i++) {\n        paren_levels[i]\
    \ = 0;\n    }\n    // Iterate over each character in string\n    for (int i =\
    \ 0, j = 0; i < paren_count; i++, j++) {\n        // If current character is '('\
    \ or '[' or '{' then\n        if (paren_string[i] == '(' || paren_string[i] ==\
    \ '[' || paren_string[i] == '{') {\n            // If we are not at last character\
    \ in string\n            if (j != (paren_count - 1)) {\n                // Increment\
    \ the level of nesting\n                paren_levels[j]++;\n            }\n  \
    \      }\n    }\n    return paren_levels;", "  // Initialize the vector\n  std::vector<long>\
    \ deepest_level;\n  // Initialize a counter that tracks how many opening parentheses\
    \ has been encountered\n  long open_parentheses = 0;\n  for (char c : paren_string)\
    \ {\n    // If the character is '(' or ')', increment the number of opened parentheses\n\
    \    if (c == '(') {\n      open_parentheses++;\n    } else if (c == ')') {\n\
    \      // If all parentheses have been opened up to the current closing parentheses,\
    \ decrement the counter\n      if (open_parentheses == 0) {\n        deepest_level.push_back(open_parentheses);\n\
    \        open_parentheses = 0;\n      }\n      open_parentheses--;\n    }\n  }\n\
    \  return deepest_level;", "\tstd::stack<long> paren_stack;\n\tstd::map<long,\
    \ long> paren_map;\n\tfor (auto itr = paren_string.rbegin(); itr != paren_string.rend();\
    \ ++itr) {\n\t\tif (*itr == '(') {\n\t\t\tparen_stack.push(*itr);\n\t\t} else\
    \ if (*itr == ')') {\n\t\t\tlong cur_level = paren_stack.top();\n\t\t\tif (paren_map.count(cur_level)\
    \ == 0) {\n\t\t\t\tparen_map[cur_level] = paren_stack.size();\n\t\t\t}\n\t\t\t\
    while (!paren_stack.empty() && paren_stack.top() != *itr) {\n\t\t\t\tparen_stack.pop();\n\
    \t\t\t}\n\t\t\twhile (!paren_stack.empty() && paren_stack.top() == *itr) {\n\t\
    \t\t\tparen_stack.pop();\n\t\t\t}\n\t\t}\n\t}\n\treturn paren_map.values();",
  "    std::vector<long> max_levels(paren_string.size());\n    std::vector<long> levels(paren_string.size());\n\
    \    // Traverse through the string and find the largest nested level recursively.\n\
    \    for(size_t i=0; i < paren_string.size(); i++) {\n        if(paren_string[i]\
    \ == '(' || paren_string[i] == ')') {\n            for(size_t j=0; j < levels.size()\
    \ ; j++) {\n                if(paren_string[i] == levels[j]) {\n             \
    \       if(max_levels[j] == 0) {\n                        max_levels[j] = j;\n\
    \                    } else {\n                        if(j+1 < levels.size()\
    \ && (levels[j+1] - max_levels[j] < levels[j] - max_levels[j+1])) {\n        \
    \                    max_levels[j] = j;\n                        }\n         \
    \           }\n                }\n            }\n        } else {\n          \
    \  max_levels[i] = 0;\n        }\n    }\n    // Print the levels up to the deepest\
    \ level.\n    for(size_t i=0; i < levels.size() ; i++) {\n        for(size_t j=0;\
    \ j < levels.size(); j++) {\n            if(max_levels[j] == i) {\n          \
    \      cout << levels[j];\n                if(j+1 < levels.size()) {\n       \
    \             cout << \", \" << levels[j+1];\n                }\n            \
    \    cout << endl;\n            }\n        }\n    }\n    return max_levels;",
  "  std::vector<long> paren_levels;\n  paren_levels = paren_string.substr(0, paren_string.find(\"\
    )\")).split(\")\");\n  long levels_sum = 0;\n  for (auto i : paren_levels) {\n\
    \    levels_sum += i;\n  }\n  std::vector<long> result;\n  for (long i = 1; i\
    \ < levels_sum; i++) {\n    long current_level_sum = 0;\n    for (long j = 0;\
    \ j < levels_sum - i; j++) {\n      current_level_sum += paren_levels[j + i];\n\
    \    }\n    result.push_back(current_level_sum);\n  }\n  return result;", "  \
    \  if (paren_string.empty()) return {};\n    std::vector<long> ans;\n    std::string\
    \ token;\n    for (auto &i : paren_string) {\n        if (i == '(') ans.push_back(-1);\n\
    \        else if (i == '(') {\n            ans.push_back(0);\n        } else if\
    \ (i == ')') {\n            ans.back()++;\n        } else if (i == ')' && ans.back()\
    \ > 0) {\n            ans.back()--;\n        }\n    }\n    return ans;", "  std::vector<long>\
    \ results;\n\n  // Initialize a stack to hold the current levels.\n  std::stack<long>\
    \ paren_levels;\n  paren_levels.emplace(0);\n\n  // Initialize the array to hold\
    \ the maximum level of nesting.\n  std::vector<long> max_level;\n  max_level.emplace(-1);\n\
    \n  // Iterate through each character in the string.\n  for (long char_index =\
    \ 0; char_index < paren_string.length(); ++char_index) {\n    // If the character\
    \ is a opening-bracket then increment the level.\n    if (paren_string[char_index]\
    \ == '(') {\n      paren_levels.emplace(paren_levels.top() + 1);\n    }\n\n  \
    \  // If the character is a closing-bracket then decrement the level.\n    else\
    \ if (paren_string[char_index] == ')') {\n      --paren_levels.top();\n    }\n\
    \n    // If the level is equal to the max level, just append the character to\
    \ the result array.\n    else if (paren_levels.top() == max_level.back()) {\n\
    \      results.emplace_back(paren_string[char_index]);\n    }\n\n    // If the\
    \ level is less than the max level, just append the character to the result array.\n\
    \    else if (paren_levels.top() < max_level.back()) {\n      results.emplace_back(paren_string[char_index]);\n\
    \    }\n\n    // If the level is greater than the max level, push the level to\
    \ the max level and append the character to the result array.\n    else {\n  \
    \    max_level.emplace_back(paren_levels.top());\n      results.emplace_back(paren_string[char_index]);\n\
    \    }\n  }\n\n  // Return the levels of nesting.\n  return results;", "    std::vector<long>\
    \ level_of_nesting(paren_string.size());\n    for(long i = 0; i < paren_string.size();\
    \ i++) {\n        long temp_level = 0;\n        for(long j = 0; j < paren_string[i].size();\
    \ j++) {\n            if(paren_string[i][j] == '(') {\n                temp_level++;\n\
    \            } else if(paren_string[i][j] == ')') {\n                temp_level--;\n\
    \            }\n        }\n        level_of_nesting[i] = temp_level;\n    }\n\
    \    return level_of_nesting;", "    std::vector<long> levels;\n    levels.push_back(0);\n\
    \    std::string::size_type i = paren_string.find('(');\n    while (i != std::string::npos)\
    \ {\n        ++i;\n        while (paren_string[i] != ' ') {\n            ++i;\n\
    \        }\n        bool has_non_space = false;\n        while (paren_string[i]\
    \ != ')' && paren_string[i] != ' ') {\n            ++i;\n            has_non_space\
    \ = true;\n        }\n        if (has_non_space) {\n            ++i;\n       \
    \ } else {\n            levels.push_back(levels[levels.size() - 1] + 1);\n   \
    \     }\n        i = paren_string.find('(', i);\n    }\n    return levels;", " \
    \ std::vector<long> max_levels;\n  for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n    if (paren_string[i] == ')') {\n      max_levels.push_back(i + 1\
    \ - paren_string.find('('));\n    }\n  }\n  return max_levels;", "  std::vector<long>\
    \ paren_depths(paren_string.size(), 0UL);\n  for (auto c : paren_string) {\n \
    \   if (c == '(') {\n      paren_depths[paren_depths.size() - 1UL] += 1;\n   \
    \ } else if (c == ')') {\n      paren_depths[paren_depths.size() - 1UL] -=1;\n\
    \    }\n  }\n  return paren_depths;", "    long max_deepest_level = 0;\n    std::vector<long>\
    \ paren_depths;\n    paren_depths.push_back(0);\n    for (char c : paren_string)\
    \ {\n        if (c == '(') {\n            paren_depths.push_back(paren_depths.back()\
    \ + 1);\n            if (paren_depths.back() > max_deepest_level) {\n        \
    \        max_deepest_level = paren_depths.back();\n            }\n        } else\
    \ if (c == ')') {\n            paren_depths.pop_back();\n        }\n    }\n  \
    \  return paren_depths;", "    // O(n) where n = number of groups of parentheses\n\
    \    std::vector<long> nested_parens_level = {0L};\n    for (auto it = paren_string.rbegin(),\
    \ end = paren_string.rend(); it != end; ++it) {\n        if (*it == '(') {\n \
    \           nested_parens_level[0]++;\n        } else if (*it == ')') {\n    \
    \        nested_parens_level[0]--;\n        }\n    }\n    return nested_parens_level;",
  "    // This table stores what is the maximum number of nesting levels one level\
    \ has.\n    // For nested parentheses (()()), the maximum level of nesting level\
    \ will be two since\n    //   1. the first pair of parentheses has no nested parentheses\
    \ within it\n    //   2. the second pair of parentheses has two nested parentheses\
    \ within it\n    // For nested parentheses (())), the maximum level of nesting\
    \ level will be one since\n    //   1. the first pair of parentheses has no nested\
    \ parentheses within it\n    //   2. the second pair of parentheses has one nested\
    \ parentheses within it\n    // For nested parentheses ((())), the maximum level\
    \ of nesting level will be zero since\n    //   1. the first pair of parentheses\
    \ has no nested parentheses within it\n    //   2. the second pair of parentheses\
    \ has one nested parentheses within it\n    std::vector<std::vector<long>> max_levels(paren_string.size(),\
    \ std::vector<long>());\n    std::vector<long> curr_level(0);\n    bool is_parenthesis\
    \ = false;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n        //\
    \ Current character is not a parentheses.\n        if (!is_parenthesis) {\n  \
    \          is_parenthesis = (paren_string[i] == ')');\n            continue;\n\
    \        }\n        // If the current character is a parentheses.\n        if\
    \ (paren_string[i] == '(') {\n            // If the current level is greater than\
    \ the max level of current pair and current pair is non-empty i.e. it has a nested\
    \ parentheses within it,\n            // then add the current level and add it\
    \ to the max levels of current pair and update the max levels of the current pair.\n\
    \            if (curr_level.size() > 0) {\n                if (curr_level.size()\
    \ > max_levels[curr_level[curr_level.size()-1]].size()) {\n                  \
    \  max_levels[curr_level[curr_level.size()-1]].push_back(curr_level.back());\n\
    \                }\n                max_levels[curr_level.back()].push_back(curr_level.back());\n\
    \            }\n            curr_level.push_back(i);\n            curr_level.push_back(-1);\n\
    \            is_parenthesis = true;\n            continue;\n        }\n      \
    \  // If the current character is a closing parentheses.\n        if (paren_string[i]\
    \ == ')') {\n            // If the current level is greater than the max level\
    \ of current pair and current pair is non-empty i.e. it has a nested parentheses\
    \ within it,\n            // then add the current level and add it to the max\
    \ levels of current pair and update the max levels of the current pair.\n    \
    \        if (curr_level.size() > 0) {\n                if (curr_level.size() >\
    \ max_levels[curr_level[curr_level.size()-1]].size()) {\n                    max_levels[curr_level[curr_level.size()-1]].push_back(curr_level.back());\n\
    \                }\n                max_levels[curr_level.back()].push_back(curr_level.back());\n\
    \            }\n            curr_level.push_back(-1);\n            is_paren",
  "    std::vector<long> paren_levels;\n    paren_levels.reserve(paren_string.size());\n\
    \    for (auto &c : paren_string) {\n        // Get rid of characters that are\
    \ not parentheses.\n        if ((c != '(') && (c != ')')) {\n            continue;\n\
    \        }\n        // Get the deepest paren_level for current character.\n  \
    \      long paren_level = paren_levels.size();\n        // Move to next index\
    \ for next iteration.\n        paren_levels.push_back(paren_level);\n        //\
    \ If we are seeing parentheses then skip to next character.\n        if (paren_level\
    \ == 0) continue;\n        // Pop current character from paren_levels vector and\
    \ decrement paren_level.\n        paren_levels.pop_back();\n        paren_level--;\n\
    \        // If paren_level is 0 then we are done processing paren_levels.\n  \
    \      if (paren_level == 0) break;\n    }\n    return paren_levels;", "    std::vector<long>\
    \ return_val;\n    long level = 1;\n    long curr = 0;\n    std::string token;\n\
    \    long curr_p = 0;\n    for (auto c : paren_string) {\n        if (c == '(')\
    \ {\n            if (curr_p != 0) {\n                return_val.emplace_back(level);\n\
    \                level++;\n            }\n            curr_p = 1;\n          \
    \  token.clear();\n        } else if (c == ')') {\n            curr_p = 0;\n \
    \           token.push_back(curr);\n            curr++;\n            level--;\n\
    \            if (level == 0)\n                return_val.emplace_back(level);\n\
    \        } else {\n            token.push_back(c);\n        }\n    }\n    if (level\
    \ != 0) {\n        return_val.emplace_back(level);\n    }\n    return return_val;",
  "    std::vector<long> paren_depths(paren_string.size() + 1, 0); // The +1 is for\
    \ the last '('\n    for (auto i : paren_string) {\n        if (i == '(') ++paren_depths[0];\n\
    \        if (i == ')') --paren_depths[paren_depths.size() - 1];\n        if (paren_depths[paren_depths.size()\
    \ - 1] == 0) return paren_depths;\n    }\n    throw std::invalid_argument(\"No\
    \ parentheses\");", "    std::vector<long> nest;\n    std::string temp_str = paren_string;\n\
    \    std::string temp_temp = \"(\";\n    int count = 0;\n    while (temp_str !=\
    \ \"\") {\n        temp_temp = temp_temp + temp_str;\n        if (temp_temp.find(\"\
    \ (\") != std::string::npos) {\n            temp_temp = temp_temp.replace(temp_temp.find(\"\
    \ (\"), 2, \"\");\n        }\n        if (temp_temp != \"\") {\n            nest.push_back(static_cast<long>(temp_temp.size())\
    \ / 2);\n            temp_temp = \"\";\n            count++;\n        }\n    \
    \    temp_str = temp_str.substr(1, temp_str.length() - 1);\n    }\n    return\
    \ nest;", "    // Using stack to solve this problem (DFS without recursion) \n\
    \    std::vector<long> result;\n    long cur_depth = 0;\n    long start_depth\
    \ = paren_string.size();\n    result.push_back(start_depth);\n    long index =\
    \ 0;\n    for(size_t i = 0; i < paren_string.size(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            cur_depth++;\n            if((cur_depth > result.back()))\
    \ {\n                result.push_back(cur_depth);\n            }\n        }\n\
    \        else if(paren_string[i] == ')') {\n            cur_depth--;\n       \
    \     if((cur_depth < result.back())) {\n                result.push_back(cur_depth);\n\
    \            }\n        }\n    }\n    return result;", "  std::string input_string\
    \ = paren_string;\n  std::vector<long> result;\n  std::string current_paren =\
    \ \" \";\n  while (input_string != \"()\") {\n    if (input_string.length() ==\
    \ 1) {\n      if (input_string[0] == '(') {\n        current_paren = \" \";\n\
    \      } else if (input_string[0] == ')') {\n        if (result.size() == 0) {\n\
    \          result.push_back(-1l);\n        } else {\n          result.back() ++;\n\
    \        }\n        current_paren = \" \";\n      }\n    } else {\n      if (input_string[0]\
    \ == '(') {\n        result.push_back(-1l);\n      } else if (input_string[0]\
    \ == ')') {\n        result.back() ++;\n      }\n      current_paren = input_string;\n\
    \      input_string = input_string.substr(1);\n    }\n  }\n  return result;",
  "    std::vector<long> levels;\n    levels.push(0);\n    std::vector<std::string>\
    \ parens = extract_parens(paren_string);\n    for (auto& paren: parens) {\n  \
    \      for (long current_level: levels) {\n            if (paren == \")\") {\n\
    \                levels.push_back(current_level);\n                break;\n  \
    \          }\n            if (paren == \"(\") {\n                levels.push_back(current_level\
    \ + 1);\n                break;\n            }\n        }\n    }\n    return levels;",
  "    std::vector<long> paren_count;\n    paren_count.push_back(0); //Add 0 for the\
    \ starting parenthesis.\n    long paren_level = 1;\n    for (auto &c : paren_string)\
    \ {\n        if (c == ')') {\n            paren_level--;\n        }\n        else\
    \ if (c == '(') {\n            paren_level++;\n        }\n        else {\n   \
    \         long index = std::max(0, std::min(paren_level.back(), paren_level.size()\
    \ - 1));\n            paren_level[index] += 1;\n            paren_count.push_back(paren_level[index]);\n\
    \        }\n    }\n    return paren_count;", "  std::vector<long> result;\n  //\
    \ We use stack to keep track of the deepest level of nesting\n  std::vector<std::vector<long>\
    \ > stack_of_paren;\n  // For each parenthesis, push its level of nesting in the\
    \ stack\n  for (auto c : paren_string) {\n    if (c == '(') {\n      stack_of_paren.emplace_back();\n\
    \    } else if (c == ')') {\n      assert(stack_of_paren.size() > 0);\n      long\
    \ max_paren_level = 0;\n      long max_paren = 0;\n      for (auto v : stack_of_paren)\
    \ {\n        assert(v.size() > 0);\n        if (v.size() > max_paren_level) {\n\
    \          max_paren_level = v.size();\n          max_paren = v.back();\n    \
    \    }\n      }\n      stack_of_paren.pop_back();\n      if (max_paren_level >\
    \ result.size()) {\n        result.resize(max_paren_level);\n      }\n      result[max_paren_level\
    \ - 1] = max_paren;\n    }\n    stack_of_paren.back().push_back((int)(c == ' '));\n\
    \  }\n  return result;", "    std::vector<long> nest_levels;\n    std::vector<long>\
    \ paren_counts;\n    long paren_start_pos = 0;\n    long paren_end_pos = 0;\n\
    \    bool open_paren = false;\n    bool close_paren = false;\n    for (long i\
    \ = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == ')') {\n\
    \            close_paren = true;\n            nest_levels.push_back((paren_end_pos\
    \ - paren_start_pos) - 1);\n        }\n        else if (paren_string[i] == '(')\
    \ {\n            open_paren = true;\n            nest_levels.push_back(0);\n \
    \       }\n        else if (close_paren && open_paren) {\n            paren_counts.push_back(1);\n\
    \            nest_levels.push_back(paren_counts.size() - 1);\n            paren_end_pos\
    \ = i;\n        }\n        else if (open_paren && close_paren) {\n           \
    \ paren_counts.push_back(1);\n            nest_levels.push_back(paren_counts.size()\
    \ - 1);\n            paren_start_pos = i;\n        }\n    }\n    return nest_levels;",
  "    // Write your code here.\n    // Write your code in main function and not in\
    \ function calls.\n    // Please add your code in main function and not in function\
    \ calls.\n\n    // write your code here\n    std::vector<long> v;\n    long max_level\
    \ = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n         \
    \   v.push_back(max_level);\n            max_level++;\n        } else if (c ==\
    \ ')') {\n            v.push_back(max_level);\n            max_level--;\n    \
    \    }\n    }\n    for (auto level : v)\n        max_level = max(max_level, level);\n\
    \    v.push_back(max_level);\n    return v;", "  // We create a map for the parenthesis.\n\
    \  // For every '(' and a ')', we increment the count by 1.\n  // For every ')'\
    \ and a ')', we decrement the count by 1.\n  // For the count of a ')', we output\
    \ the deepest level of nesting.\n  // For the count of a '(', we output the deepest\
    \ level of nesting.\n  std::map<char, std::pair<std::pair<char, long>, long>>\
    \ parenthesis;\n\n  // We keep track of the deepest level of nesting of parentheses.\n\
    \  // We initialize its value to zero.\n  // If every '(' has a matching ')',\
    \ we set it to one.\n  // Otherwise, its value will be zero.\n  long deepest_level_of_nesting\
    \ = -1;\n  for (char c : paren_string) {\n    if (c == '(') {\n      ++parenthesis[c].first;\n\
    \    } else if (c == ')') {\n      --parenthesis[c].first;\n      if (parenthesis[c].first\
    \ == 0) {\n        deepest_level_of_nesting = std::max(deepest_level_of_nesting,\
    \ parenthesis[c].second);\n      }\n    }\n  }\n  // We need to return vector\
    \ of deepest level of nestings.\n  std::vector<long> deepest_level_of_nestings;\n\
    \  deepest_level_of_nestings.push_back(deepest_level_of_nesting);\n  // For every\
    \ ')' we decrement the level of nesting.\n  for (char c : parenthesis) {\n   \
    \ if (c == ')') {\n      --deepest_level_of_nesting;\n    }\n  }\n  return deepest_level_of_nestings;",
  "    if (paren_string.empty()) return std::vector<long>{};\n    std::vector<long>\
    \ results;\n    auto open_pos = paren_string.find(\"(\");\n    auto close_pos\
    \ = paren_string.find(\")\");\n    bool is_open = false;\n    long max_count =\
    \ 0;\n    auto open = paren_string.begin(), open_size = paren_string.end() - open;\n\
    \    auto close = paren_string.end() - 1, close_size = paren_string.end() - close;\n\
    \    while(open != close) {\n        if (is_open && paren_string.find(\"(\", open)\
    \ == close_pos) {\n            results.push_back(0);\n            is_open = false;\n\
    \            max_count = 0;\n        }\n        if (is_open && (paren_string[open_pos]\
    \ == '(')) {\n            is_open = true;\n            max_count++;\n        }\n\
    \        if (is_open && (paren_string[open_pos] == ')')) {\n            max_count--;\n\
    \        }\n        open++;\n        if (max_count == 0) {\n            results.push_back(std::distance(open,\
    \ close));\n        }\n    }\n    return results;", "    if (paren_string.empty())\n\
    \        throw std::invalid_argument(\"Input string is empty.\");\n    // Initialize\
    \ result vector\n    std::vector<long> result;\n    // Initialize left and right\
    \ index\n    size_t left_index = 0;\n    size_t right_index = 0;\n    // Loop\
    \ through string until we see a closing parenthesis\n    while (left_index < paren_string.size())\
    \ {\n        // If we've reached the left of the string, add one level of nesting\
    \ by adding 1 to left_index\n        if (left_index == 0) {\n            result.push_back(1);\n\
    \            left_index++;\n            // Keep track of the current level of\
    \ nesting\n            size_t current_level = 1;\n            // Keep track of\
    \ the next level of nesting\n            size_t next_level = 1;\n            //\
    \ Keep track of whether we're currently inside a parenthesis group\n         \
    \   bool in_group = false;\n            // Iterate over string until we see an\
    \ opening parenthesis\n            while (right_index < paren_string.size() &&\
    \ !in_group) {\n                // If we've reached the right of the string, we're\
    \ done adding nesting\n                if (right_index == paren_string.size())\
    \ {\n                    result.push_back(current_level);\n                  \
    \  break;\n                }\n                // Otherwise, if the next character\
    \ is a closing parenthesis, we're done adding nesting\n                else if\
    \ (paren_string[right_index] == '(') {\n                    current_level++;\n\
    \                    next_level++;\n                    right_index++;\n     \
    \               in_group = true;\n                }\n                // Otherwise,\
    \ if we have a closing parenthesis, we're in another parenthesis group\n     \
    \           else if (paren_string[right_index] == ')') {\n                   \
    \ in_group = false;\n                    // If we're at the end of our nested\
    \ parenthesis, we'll add one more level of nesting\n                    if (current_level\
    \ == next_level)\n                        current_level++;\n                 \
    \   result.push_back(current_level);\n                    right_index++;\n   \
    \             }\n                right_index++;\n            }\n            //\
    \ If we're not done adding nesting when we reach the end of the string, we're\
    \ done adding nesting\n            if (right_index == paren_string.size())\n \
    \               break;\n        }\n        // Otherwise, if we've reached the\
    \ right of the string, add one level of nesting by adding 1 to left_index\n  \
    \      else if (right_index == paren_string.size()) {\n            result.push_back(1);\n\
    \            left_index++;\n            right_index++;\n            // Keep track\
    \ of the current level of nesting\n            size_t current_level = 1;\n   \
    \         // Keep track of the next level of nesting\n            size_t next_level\
    \ = 1;\n            // Keep track of whether we're currently inside a parenthesis\
    \ group\n            bool in_group = false;\n            // Iterate over string\
    \ until we see an opening parenthesis\n            while (right_index < paren_string.size()\
    \ && !in_group) {\n                // If we've reached the right of the string,\
    \ we're done adding nesting\n", "    std::vector<long> ans;\n    std::string temp_ans;\n\
    \    for(auto &it: paren_string) {\n        auto pos = it;\n        while(pos\
    \ != paren_string.end() && !((pos == paren_string.begin() ? it == paren_string.begin()\
    \ : pos == paren_string.end() ? it == paren_string.end() : it == paren_string.begin())))\
    \ {\n            pos = pos + 1;\n        }\n        if(pos == paren_string.begin())\n\
    \            ans.push_back(1);\n        else if(pos == paren_string.end())\n \
    \           ans.push_back(ans.size());\n        else if(it == paren_string.end()\
    \ || it == paren_string.begin())\n            ans.push_back(ans.size());\n   \
    \     else\n            ans.push_back(ans.size() + 1);\n    }\n    return ans;",
  "    std::vector<long> paren_level;\n    std::vector<long> paren_level_size;\n \
    \   // If string is empty or only contains spaces, return empty paren_level.\n\
    \    if (paren_string.empty() || paren_string.find_first_not_of(\" \") != std::string::npos)\
    \ {\n        return paren_level;\n    }\n\n    // Initialize paren_level with\
    \ deepest level of nesting.\n    paren_level.push_back(0);\n    paren_level_size.push_back(0);\n\
    \    for (auto &ch : paren_string) {\n        if (ch == '(') {\n            paren_level.push_back(paren_level.back()\
    \ + 1);\n            paren_level_size.push_back(paren_level_size.back() + 1);\n\
    \        } else if (ch == ')') {\n            paren_level.push_back(paren_level.back()\
    \ - 1);\n            paren_level_size.push_back(paren_level_size.back() - 1);\n\
    \        } else if (ch == ' ') {\n            // If we reach a space, store paren_level\
    \ as last element of paren_level_size array.\n            paren_level.back() =\
    \ std::max(paren_level.back(), paren_level_size.back());\n            paren_level_size.back()\
    \ = 1;\n        } else {\n            assert(0);\n        }\n    }\n    return\
    \ paren_level;", "    // Your code goes here\n    std::vector<long> result;\n\
    \    std::vector<long> paren_stack;\n    long level = 0;\n    bool flag = false;\n\
    \    for (size_t i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i]\
    \ != '(') continue;\n        if (flag) {\n            paren_stack.push_back(level);\n\
    \            level = 0;\n        }\n        else {\n            flag = true;\n\
    \        }\n    }\n    if (flag) {\n        paren_stack.push_back(level);\n  \
    \  }\n    for (size_t i = 0; i < paren_stack.size(); ++i) {\n        for (size_t\
    \ j = 0; j < paren_stack.size() - i; ++j) {\n            if (paren_stack[j] >=\
    \ paren_stack[j + 1]) {\n                result.push_back(paren_stack[j + 1] +\
    \ 1);\n            }\n        }\n    }\n    return result;", "    // Convert the\
    \ input string into a vector of tokens.\n    std::vector<std::vector<std::string>>\
    \ paren_tokens;\n    std::vector<std::string> tokens;\n    for (auto &x : paren_string)\
    \ {\n        if (x != ' ' && x != '(' && x != ')') {\n            tokens.push_back(x);\n\
    \        } else {\n            paren_tokens.push_back(tokens);\n            tokens.clear();\n\
    \        }\n    }\n    paren_tokens.push_back(tokens);\n\n    // For each set\
    \ of parentheses separated by space, return the deepest level of nesting.\n  \
    \  // E.g. for (((())) we return 1 as the deepest nesting level.\n    std::vector<long>\
    \ max_levels;\n    for (auto &x : paren_tokens) {\n        std::string token;\n\
    \        for (auto &y : x) {\n            token += y + \" \";\n        }\n   \
    \     long max_level = 0;\n        for (auto &y : x) {\n            if (y == \"\
    (\" || y == \"(\") {\n                max_level++;\n            } else if (y ==\
    \ \")\" || y == \")\") {\n                max_level--;\n            }\n      \
    \  }\n        max_levels.push_back((max_level == 0) ? 0 : max_level);\n    }\n\
    \    return max_levels;", "  // Get number of spaces separating the groups of\
    \ parenthesis present in the string.\n  int num_of_spaces = paren_string.find_first_of('\
    \ ');\n  // Create a vector of long type to store the output\n  std::vector<long>\
    \ levels(num_of_spaces);\n  int j = 0;\n  int i = 0;\n  while (i < paren_string.size())\
    \ {\n    // If '(' appears in the string then we get the index of the opening\
    \ brace of the group.\n    // And store the number of levels of nesting in the\
    \ vector\n    if (paren_string.at(i) == '(') {\n      levels[j] = i;\n      ++j;\n\
    \    }\n    // If ')' appears in the string then we get the index of the closing\
    \ brace of the group.\n    // And store the number of levels of nesting in the\
    \ vector\n    if (paren_string.at(i) == ')') {\n      if (j == num_of_spaces)\
    \ {\n        std::cerr << \"Error, string does not contain balanced parenthesis.\\\
    n\";\n        assert(false);\n      }\n      levels[j] = i;\n      --j;\n    }\n\
    \    ++i;\n  }\n  return levels;", "    std::vector<long> levels(paren_string.size());\n\
    \    std::vector<long>::iterator it = levels.begin();\n    std::vector<std::string>\
    \ parens = Split(paren_string, \" \");\n    long index = 0;\n    while(!parens.empty())\
    \ {\n        if(parens[index].size() > 0) {\n            ++index;\n        }\n\
    \        else {\n            assert(parens.size() >= 1);\n            std::vector<long>\
    \ levels_rest = Split(parens.back(), \")\");\n            for(long i = 0; i <\
    \ levels_rest.size(); ++i) {\n                assert(i < parens.size());\n   \
    \             std::vector<long> levels_i = Split(parens[i], \")\");\n        \
    \        assert(!levels_i.empty());\n                if(levels_i.back() != \"\
    (\") {\n                    if(levels_i.back() == \"(\") {\n                 \
    \       --i;\n                    }\n                }\n                assert(levels_i.back()\
    \ == \"(\");\n                long levels_i_index = levels_i.size() - 1;\n   \
    \             long levels_rest_index = levels_rest.size() - 1;\n             \
    \   long max_level_i = (levels_i[levels_i_index] == \"\") ? 0 : levels_i[levels_i_index];\n\
    \                long max_level_j = (levels_rest[levels_rest_index] == \"\") ?\
    \ 0 : levels_rest[levels_rest_index];\n                long level_i = max_level_i;\n\
    \                long level_j = max_level_j;\n                if(level_i < level_j)\
    \ { level_i = level_j; }\n                if(level_i > levels[it]) { levels[it]\
    \ = level_i; }\n                ++it;\n            }\n            parens.pop_back();\n\
    \        }\n    }\n    std::vector<long> result;\n    for(std::vector<long>::iterator\
    \ it = levels.begin(); it != levels.end(); ++it) { result.push_back(*it); }\n\
    \    return result;", "    std::vector<long> ret;\n    std::string temp = \"\"\
    ;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(' && paren_string[i + 1] != '(') {\n            if (temp.size() != 0) {\n\
    \                ret.push_back(stoi(temp));\n            }\n            temp =\
    \ \"\";\n        } else if (paren_string[i] == ')' && paren_string[i + 1] != '(')\
    \ {\n            long size = stoi(temp);\n            if (size > ret.size()) ret.push_back(size);\n\
    \            temp = \"\";\n        } else {\n            temp += paren_string[i];\n\
    \        }\n    }\n    if (temp.size() != 0) {\n        ret.push_back(stoi(temp));\n\
    \    }\n    return ret;", "    std::vector<long> nested_parens;\n    if (paren_string\
    \ == \"\") {\n        return nested_parens;\n    }\n    std::string::size_type\
    \ pos = 0;\n    std::string::size_type last_pos = paren_string.find_first_of(\"\
    )\", pos);\n    std::string::size_type paren_level = 0;\n    std::string curr_name\
    \ = \"\";\n    while (std::string::npos != last_pos) {\n        pos = last_pos;\n\
    \        last_pos = paren_string.find_first_of(\")\", pos);\n        std::string::size_type\
    \ cur_len = last_pos - pos;\n        if (paren_level > 0 && paren_level == cur_len)\
    \ {\n            nested_parens.push_back(paren_level);\n        }\n        paren_level++;\n\
    \        std::string curr = paren_string.substr(pos, cur_len);\n        // If\
    \ the first char of curr is '(', then it is a group.\n        if (curr[0] == '(')\
    \ {\n            std::string curr_level = curr;\n            while (std::find(curr_level.begin(),\
    \ curr_level.end(), ' ') != curr_level.end()) {\n                curr_level =\
    \ curr_level.substr(0, curr_level.find(' '));\n            }\n            if (curr_level.empty())\
    \ {\n                nested_parens.push_back(1);\n            } else {\n     \
    \           nested_parens.push_back(static_cast<long>(curr_level.size()) - 1);\n\
    \            }\n        } else {\n            curr_name = curr_name.length() >\
    \ 0 ? curr_name + \"(\" + curr : curr;\n        }\n    }\n    nested_parens.push_back(nested_parens.size());\n\
    \    return nested_parens;", "    std::vector<long> max_level;\n    std::string\
    \ curr_level;\n    for (size_t i = 0; i < paren_string.length(); ++i) {\n    \
    \    if (paren_string[i] == ')') {\n            if (curr_level.empty())\n    \
    \            curr_level = paren_string[i];\n            else\n               \
    \ curr_level += paren_string[i];\n        }\n        else if (curr_level.empty())\
    \ {\n            curr_level = paren_string[i];\n        }\n        else if (curr_level\
    \ == paren_string[i]) {\n            curr_level += paren_string[i];\n        }\n\
    \        else {\n            max_level.push_back(stoi(curr_level));\n        \
    \    curr_level.clear();\n        }\n    }\n    max_level.push_back(stoi(curr_level));\n\
    \    return max_level;", "    if (paren_string.length() == 0) {\n        return\
    \ {0};\n    }\n\n    std::vector<long> result = {0};\n    auto it = paren_string.begin();\n\
    \n    // Iterate through all of the parentheses until we hit the end of the string.\n\
    \    while (it != paren_string.end() && *it != '(') {\n        ++it;\n    }\n\n\
    \    // We have hit the end of the string. Return the result.\n    if (it == paren_string.end())\
    \ {\n        return result;\n    }\n\n    // Iterate through the string and accumulate\
    \ the result.\n    ++it;\n    for (; it != paren_string.end(); ++it) {\n     \
    \   // If the current char is '(' or ')', then accumulate the level of nesting\
    \ for the current parenthesis.\n        if (*it == '(') {\n            // If the\
    \ last element of the vector has been set, then we need to add the length of the\
    \ last element to the current level of nesting.\n            if (result.back().size()\
    \ == 0) {\n                result.back().push_back(1);\n            }\n      \
    \      else {\n                result.back().push_back(result[result.size() -\
    \ 1].size() + 1);\n            }\n        }\n        else if (*it == ')') {\n\
    \            // If the last element of the vector has been set, then we need to\
    \ subtract the length of the last element from the current level of nesting.\n\
    \            if (result.back().size() == 0) {\n                result.back().push_back(-1);\n\
    \            }\n            else {\n                result[result.size() - 1].erase(result.back().size()\
    \ - 1);\n            }\n        }\n        // If the current char is not a ')'\
    \ or '(', then we need to push a new level of nesting for the current parenthesis.\n\
    \        else {\n            result.back().push_back(1);\n        }\n    }\n\n\
    \    return result;", "\tstd::stack<long> paren_depth_stack;\n\tparen_depth_stack.push(0);\n\
    \tstd::vector<long> depth;\n\tdepth.push_back(0);\n\tfor (char ch : paren_string)\
    \ {\n\t\tif (ch == '(' || ch == '[' || ch == '{') {\n\t\t\tdepth.push_back(paren_depth_stack.top());\n\
    \t\t\tparen_depth_stack.push(0);\n\t\t}\n\t\telse if (ch == '}' || ch == ']' ||\
    \ ch == ')') {\n\t\t\tif (paren_depth_stack.top() > 0) {\n\t\t\t\tdepth.push_back(paren_depth_stack.top());\n\
    \t\t\t\tparen_depth_stack.pop();\n\t\t\t} else {\n\t\t\t\tdepth.push_back(0);\n\
    \t\t\t}\n\t\t}\n\t\telse if (ch == ' ') {\n\t\t\tif (paren_depth_stack.top() >\
    \ 0) {\n\t\t\t\tdepth.push_back(paren_depth_stack.top());\n\t\t\t\tparen_depth_stack.pop();\n\
    \t\t\t}\n\t\t}\n\t\telse if (ch == ',') {\n\t\t\tif (depth.back() > 0) {\n\t\t\
    \t\tdepth.pop_back();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdepth.back()++;\n\t\t\
    }\n\t}\n\treturn depth;", "    std::vector<long> levels;\n    std::string current_level;\n\
    \    std::string parens_count = \"\";\n    int i = 1;\n    while (true) {\n  \
    \      current_level = parens_count;\n        if (current_level == \"\") {\n \
    \           current_level = \"1\";\n        }\n        parens_count = paren_string.substr(0,\
    \ i).substr(1, i - 1);\n        if (parens_count == \"\") {\n            levels.push_back(std::stoi(current_level));\n\
    \            return levels;\n        }\n        if (parens_count == \"0\") {\n\
    \            levels.push_back(std::stoi(current_level));\n            return levels;\n\
    \        }\n        if (parens_count == \"1\") {\n            levels.push_back(std::stoi(current_level)\
    \ + 1);\n            return levels;\n        }\n        ++i;\n    }", "    std::vector<long>\
    \ ret;\n    size_t open = 0;\n    size_t close = 0;\n    size_t level = 0;\n \
    \   for (auto i = paren_string.rbegin(); i != paren_string.rend(); ++i) {\n  \
    \      // Skip the opening parens.\n        if (*i == '(') {\n            ++open;\n\
    \            ++level;\n        }\n        else if (*i == ')') {\n            ++close;\n\
    \            if (close == level) {\n                ret.emplace_back(level);\n\
    \                ++level;\n            }\n        }\n    }\n    return ret;",
  "  std::vector<long> paren_levels;\n  std::vector<long> temp;\n  // Create a vector\
    \ of paren_levels based on number of opened parentheses.\n  paren_levels.reserve(paren_string.size());\n\
    \  for (int i = 0; i < paren_string.size(); ++i) {\n    if (paren_string[i] ==\
    \ '(') {\n      paren_levels.push_back(temp.size());\n    }\n    temp.push_back(paren_string[i]);\n\
    \  }\n  // Perform depth-first search to find the deepest nested level.\n  while\
    \ (!temp.empty()) {\n    int j = temp.size()-1;\n    while (j >= 0) {\n      //\
    \ For each of the levels of parentheses just before current level,\n      // add\
    \ (temp[j]) to paren_levels.\n      assert(paren_levels[j] >= temp[j]);\n    \
    \  paren_levels[j] += (temp[j]);\n      // Swap the elements at the right position.\n\
    \      std::swap(temp[j], temp[j-1]);\n      // Pop all the elements just before\
    \ the current level.\n      j -= (temp[j]);\n    }\n    temp.clear();\n  }\n \
    \ return paren_levels;", "    std::vector<long> parens;\n    parens.reserve(paren_string.size());\n\
    \    std::string parens_str = paren_string;\n    std::size_t paren_level = 1;\n\
    \    bool has_open_paren = false;\n    bool in_parens = false;\n    while (!parens_str.empty())\
    \ {\n        bool is_open = parens_str.front() == '(';\n        bool is_close_paren\
    \ = parens_str.back() == ')';\n        if (is_open) {\n            if (in_parens)\
    \ {\n                paren_level++;\n            } else {\n                paren_level\
    \ = 1;\n            }\n            has_open_paren = true;\n        }\n       \
    \ if (is_close_paren) {\n            if (in_parens) {\n                paren_level--;\n\
    \            } else {\n                throw std::runtime_error(\"Mismatched parenthesis.\"\
    );\n            }\n            has_open_paren = false;\n        }\n        if\
    \ (has_open_paren) {\n            parens.push_back(paren_level);\n        }\n\
    \        if (parens_str.empty()) {\n            throw std::runtime_error(\"Mismatched\
    \ parenthesis.\");\n        }\n        if (is_open) {\n            parens_str\
    \ = parens_str.substr(1);\n        } else {\n            parens_str = parens_str.substr(0,\
    \ parens_str.size()-1);\n        }\n    }\n    return parens;", "    std::vector<long>\
    \ levels;\n    size_t pos = 0;\n    size_t pos_left = 0;\n    while (true) {\n\
    \        pos = paren_string.find_first_not_of(\"(()\", pos);\n        if (pos\
    \ == std::string::npos) {\n            break;\n        }\n        pos_left = pos;\n\
    \        pos = paren_string.find_first_of(\"()\", pos);\n        if (pos == std::string::npos)\
    \ {\n            break;\n        }\n        levels.push_back(long(pos_left - pos));\n\
    \        pos = paren_string.find_first_of(\"()\", pos);\n    }\n    return levels;",
  "    std::vector<long> paren_level;\n    std::string::size_type start = 0;\n   \
    \ for (std::string::size_type i = 0; (i < paren_string.length()) && (paren_string[i]\
    \ != ' ');i++) {\n        long current_level = -1;\n        for (std::string::size_type\
    \ j = 0; (j < paren_string.length()) && (paren_string[j] == paren_string[i]);\
    \ j++) {\n            current_level++;\n        }\n        // If we are at end\
    \ of string\n        if (j == paren_string.length()) {\n            paren_level.push_back(current_level);\n\
    \            break;\n        }\n        // If the previous character was not a\
    \ space\n        if (j != start && (paren_string[start] == paren_string[j])) {\n\
    \            // if the level of the previous charcter was greater than the current\
    \ level\n            if (current_level < paren_level[j - 1]) {\n             \
    \   // update previous character level\n                paren_level[j] = current_level;\n\
    \                // Update the position of previous character in string\n    \
    \            start = j;\n            } else {\n                // If level is\
    \ same, then it means that we are entering a new level\n                paren_level.push_back(current_level);\n\
    \                break;\n            }\n        }\n        // If the previous\
    \ character was a space\n        if (j != start && (paren_string[start] != paren_string[j]))\
    \ {\n            // If the level of the previous character is greater than current\
    \ level\n            if (current_level < paren_level[j - 1]) {\n             \
    \   paren_level.push_back(current_level);\n                // Update previous\
    \ character level\n                start = j;\n            }\n            // If\
    \ level is same, then it means that we are entering a new level\n            paren_level.push_back(current_level);\n\
    \            break;\n        }\n    }\n    return paren_level;", "  std::vector<long>\
    \ result;\n  std::string current_paren_level = \"\";\n  std::string current_paren_level_count\
    \ = 0;\n  for (auto it = paren_string.begin(); it != paren_string.end(); it++)\
    \ {\n    // Current paren level\n    if (*it == ' ') {\n      current_paren_level\
    \ += *it;\n    } else {\n      // Current paren level's count\n      current_paren_level_count\
    \ += *it;\n      // If current level's count is greather than current paren level's\
    \ count\n      if (current_paren_level_count > current_paren_level.size()) {\n\
    \        // Increase current level's count by 1\n        current_paren_level_count++;\n\
    \        // If current level count's length is greater than 1\n        if (current_paren_level_count\
    \ > 1) {\n          // Increase current level's count by 1\n          current_paren_level_count++;\n\
    \          // Add 1 to result vector if current level is less than current level's\
    \ count - 1\n          if (current_paren_level_count < current_paren_level.size())\
    \ {\n            result.push_back(current_paren_level_count);\n          }\n \
    \       }\n      }\n      // Reset current level's count for next level\n    \
    \  current_paren_level_count = 0;\n    }\n  }\n  return result;", "  std::vector<long>\
    \ nest_levels;\n  std::string parentheses;\n  \n  // For each group of parentheses,\
    \ append one more level of nesting if it is opened.\n  for (char paren = paren_string[0];\
    \ ; paren = paren_string[++i]) {\n    if (paren == '(') {\n      parentheses +=\
    \ paren;\n      nest_levels.push_back(nest_levels.size());\n    } else if (paren\
    \ == ')') {\n      auto n = nest_levels.size() - 1;\n      if (n >= 0) {\n   \
    \     nest_levels[n]++;\n      }\n    } else {\n      parentheses += paren;\n\
    \    }\n  }\n  \n  return nest_levels;", "    auto n = paren_string.find(\"((\"\
    );\n    auto e = paren_string.find(\")\");\n    std::vector<long> retval;\n  \
    \  long max_level = std::numeric_limits<long>::max();\n    retval.push_back(0);\n\
    \    long level = 0;\n    while (n != std::string::npos && e != std::string::npos)\
    \ {\n        auto cur_level = std::min(max_level, level);\n        retval.push_back(cur_level);\n\
    \        max_level = std::max(max_level, cur_level + 1);\n        n = paren_string.find(\"\
    ((\", e-1);\n        e = paren_string.find(\")\", e);\n        level++;\n    }\n\
    \    if (n == std::string::npos && e != std::string::npos) {\n        retval.push_back(max_level);\n\
    \    }\n    return retval;", "  std::vector<long> result;\n  std::vector<std::string>\
    \ paren_list(paren_string.begin(), paren_string.end());\n  paren_list.pop_back();\
    \ // Remove the final \")\"\n\n  for (const std::string& cur : paren_list)\n \
    \ {\n    bool found_match = false;\n    long current_level = 0;\n    std::string\
    \ current_group = \"\";\n\n    for (auto it : cur)\n    {\n      if (it == '(')\n\
    \      {\n        current_level++;\n      }\n      if (it == ')')\n      {\n \
    \       current_level--;\n      }\n      if (current_level == 0)\n      {\n  \
    \      current_group += it;\n        found_match = true;\n      }\n    }\n   \
    \ if (found_match)\n    {\n      result.emplace_back(std::stoul(current_group));\n\
    \    }\n  }\n  return result;", "  std::vector<long> result;\n  long max_depth\
    \ = 0;\n  std::stack<long> stack_of_parens;\n  std::string cur_paren = \"\";\n\
    \  for (auto cur_char : paren_string) {\n    if (cur_char == '(') {\n      stack_of_parens.push(cur_paren.size());\n\
    \      cur_paren = \"\";\n    }\n    if (cur_char == ')') {\n      long paren_len\
    \ = stack_of_parens.top();\n      if (max_depth < paren_len) {\n        max_depth\
    \ = paren_len;\n      }\n      result.push_back(max_depth);\n      stack_of_parens.pop();\n\
    \    }\n    cur_paren += cur_char;\n  }\n  if (stack_of_parens.empty()) {\n  \
    \  max_depth = 0;\n  }\n  result.push_back(max_depth);\n  return result;", " \
    \ std::vector<long> ans;\n  stack<int> open_braces;\n  std::stack<long> current_nesting;\n\
    \  long current_level = 0;\n  for (char c : paren_string) {\n    if (c == '(')\
    \ {\n      // If we are not at the lowest level, then we decrease the level of\
    \ nesting by 1.\n      // So if we have (()) which is at level 1 and we are still\
    \ at level 0, then we decrease the level of nesting by 2.\n      // That is because\
    \ we do not want to get into (())) because we already have (()) as a result.\n\
    \      current_nesting.push(current_level);\n    } else if (c == ')' && current_nesting.top()\
    \ > 0) {\n      // If we are currently not at the lowest level of nesting, then\
    \ we decrease the level of nesting by 1 which brings us to our lowest level.\n\
    \      current_nesting.pop();\n    } else {\n      // If we are not at the lowest\
    \ level of nesting, then we increase the level of nesting by 1 which brings us\
    \ to our highest level.\n      current_nesting.push(current_level + 1);\n    }\n\
    \    current_level++;\n    // We append the level of nesting to our vector result.\n\
    \    ans.push_back(current_nesting.top());\n  }\n  return ans;", "    int paren_count\
    \ = 0;\n    std::vector<long> nested_paren_counts;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == ')') {\n            nested_paren_counts.push_back(paren_count);\n\
    \            paren_count = 0;\n        } else if (paren_string[i] == ')' && paren_count\
    \ > 0) {\n            paren_count--;\n        } else if (paren_string[i] == '(')\
    \ {\n            paren_count++;\n        }\n    }\n    nested_paren_counts.push_back(paren_count);\n\
    \    return nested_paren_counts;", "    std::vector<long> max_level_of_nesting;\n\
    \    std::string parentheses;\n    long max_level = 0;\n    std::string current_string\
    \ = \"\";\n    std::vector<std::string> current_parentheses;\n    for (auto c\
    \ : paren_string) {\n        if (c == '(') {\n            current_string.push_back(c);\n\
    \            current_parentheses.push_back(current_string);\n            current_string.clear();\n\
    \        } else if (c == ')') {\n            parentheses += current_string;\n\
    \            long level = 1;\n            for (auto str : current_parentheses)\
    \ {\n                if (str == parentheses) {\n                    level = current_parentheses.size();\n\
    \                    break;\n                }\n            }\n            if\
    \ (max_level < level) {\n                max_level = level;\n                max_level_of_nesting.push_back(level);\n\
    \            }\n            current_parentheses.clear();\n            current_string.clear();\n\
    \        } else {\n            current_string.push_back(c);\n        }\n    }\n\
    \    return max_level_of_nesting;", "    std::vector<long> result;\n    long cur_depth\
    \ = 0;\n    for (size_t i = 0; i < (paren_string.size() - 1); i++) {\n       \
    \ if (paren_string[i] == paren_string[i+1]) continue;\n        if (paren_string[i]\
    \ == '(') {\n            if (cur_depth > 0) {\n                result.push_back(cur_depth);\n\
    \            }\n            cur_depth++;\n        } else if (paren_string[i] ==\
    \ ')') {\n            if (cur_depth > 0) {\n                cur_depth--;\n   \
    \         } else {\n                throw std::runtime_error(\"No matching opening\
    \ parenthesis!\");\n            }\n        } else if (paren_string[i] == ' ')\
    \ {\n            cur_depth--;\n        }\n    }\n    result.push_back(cur_depth);\n\
    \    return result;", "    std::vector<long> paren_list;\n    std::string paren_char\
    \ = \"()\";\n    for (size_t i = 0; i < paren_string.size(); i++) {\n        if\
    \ (paren_string[i] == paren_char) {\n            paren_list.push_back(paren_string.size());\n\
    \        } else if (paren_string[i] == \" \") {\n            paren_list.push_back(paren_list.back());\n\
    \        }\n    }\n    return paren_list;", "    std::vector<long> result;\n \
    \   long max_level = -1;\n    long depth = 1;\n    for (auto c : paren_string)\
    \ {\n        if (c != '(' && c != ')') {\n            result.push_back(depth);\n\
    \        }\n        ++depth;\n        if (depth > max_level) {\n            max_level\
    \ = depth;\n        }\n    }\n    if (max_level == -1) {\n        return result;\n\
    \    }\n    for (auto c : paren_string) {\n        if (c != ')') {\n         \
    \   result.push_back(max_level);\n        }\n        --depth;\n        if (depth\
    \ > max_level) {\n            max_level = depth;\n        }\n    }\n    return\
    \ result;", "  std::vector<long> result;\n  if (paren_string.length() == 0) return\
    \ result;\n  // Count the number of opening and closing parentheses occurring\
    \ in the paren_string\n  int n_parens = 0;\n  for (int i = 0, ii = paren_string.size();\
    \ i < ii; ++i) {\n    if (paren_string[i] == '(') ++n_parens;\n    if (paren_string[i]\
    \ == ')') --n_parens;\n  }\n  if (n_parens == 0) {\n    // If all the parentheses\
    \ are closed, then there are no nesting levels\n    result.push_back(0);\n   \
    \ return result;\n  }\n  // Calculate the max level of nesting by comparing the\
    \ number of opening and closing parentheses\n  long max_level = 0;\n  for (int\
    \ i = 0, ii = paren_string.size(); i < ii; ++i) {\n    if (paren_string[i] ==\
    \ '(') {\n      if (max_level < n_parens - 1) max_level = n_parens - 1;\n    }\
    \ else if (paren_string[i] == ')') {\n      if (max_level > 0) max_level--;\n\
    \    }\n  }\n  // For each level of nesting, count the number of nested parentheses\n\
    \  // If there is only one level of nesting, then there would be only one nested\
    \ parentheses.\n  for (long level = 1; level <= max_level; ++level) {\n    int\
    \ n_nested_parens = 0;\n    for (int i = 0, ii = paren_string.size(); i < ii;\
    \ ++i) {\n      if (paren_string[i] == '(') ++n_nested_parens;\n      if (paren_string[i]\
    \ == ')') --n_nested_parens;\n      if (n_nested_parens > level) break;\n    }\n\
    \    if (n_nested_parens == level) result.push_back(level);\n  }\n  return result;",
  "  std::vector<long> result;\n  long level_of_nesting = 1;\n  int paren_level =\
    \ 0;\n  for (char c : paren_string) {\n    // If this is the closing parenthesis\n\
    \    if (c == '(') {\n      paren_level--;\n    }\n    // If this is the opening\
    \ parenthesis\n    else if (c == ')') {\n      paren_level++;\n    }\n    // If\
    \ this is not the opening or closing parenthesis\n    else {\n      if (paren_level\
    \ == level_of_nesting) {\n        result.push_back(level_of_nesting);\n      }\n\
    \      level_of_nesting++;\n    }\n  }\n  return result;", "  std::stack<std::vector<long>>\
    \ nest;\n  std::vector<long> parens = {-1};\n  for (auto iter = paren_string.begin();\
    \ iter != paren_string.end(); ++iter) {\n    long paren_count = 1;\n    bool is_empty\
    \ = false;\n    while (*iter == '(' || is_empty) {\n      is_empty = false;\n\
    \      if (*iter == '(') {\n        ++paren_count;\n      }\n      ++iter;\n \
    \   }\n    if (is_empty) {\n      paren_count = -1;\n    }\n    for (; paren_count\
    \ > 0 && parens.size() < parens.size() + 1; ++parens) {\n      if (paren_count\
    \ == 0) {\n        parens.push_back(-1);\n      } else {\n        ++parens[parens.size()\
    \ - 1];\n      }\n    }\n    nest.push(parens);\n  }\n\n  std::vector<long> result;\n\
    \  while (nest.size() != 0) {\n    std::vector<long> tmp = nest.top();\n    nest.pop();\n\
    \    if (tmp.size() == 0) {\n      result.push_back(0);\n    } else {\n      long\
    \ last_index = tmp.size() - 1;\n      if (tmp[last_index] == -1) {\n        last_index--;\n\
    \      }\n      for (; last_index >= 0; --last_index) {\n        result.push_back(tmp[last_index]);\n\
    \      }\n    }\n  }\n\n  return result;", "    std::vector<long> max_level;\n\
    \    // The key is that paren_string is an unordered set of parenthesis.\n   \
    \ // We need to build a tree that represent the parenthesis nesting level for\
    \ each parenthesis.\n    // The root is denoted by a parenthesis string with only\
    \ that parenthesis.\n    // We iterate over the parenthesis to build the nested\
    \ parenthesis tree. Each iteration, we update the max_level\n    // for each previous\
    \ parenthesis string and assign the new value to the max_level with the next parenthesis.\n\
    \    for (auto it : paren_string) {\n        // We need some extra space for parenthesis\
    \ strings that end with \")\".\n        if (it == '(') {\n            max_level.push_back(1);\n\
    \        } else if (it == ')') {\n            // We need to update the max_level\
    \ for the previous parenthesis string\n            // and add the current level\
    \ to the max_level for the new parenthesis string.\n            max_level.insert(max_level.end(),\
    \ max_level[max_level.size() - 1], max_level.back() + 1);\n        } else {\n\
    \            // We only care about parenthesis strings that start \"(\" and end\
    \ \")\".\n            // We can skip the space and just update the max_level for\
    \ the parenthesis string.\n            max_level.push_back(1);\n        }\n  \
    \  }\n    return max_level;", "    // The output vector will keep a record of\
    \ which nested parenthesis has how many levels.\n    // Thus, the size of the\
    \ vector will indicate how many levels of nesting there are.\n    std::vector<long>\
    \ output_vector;\n    bool flag = false;\n    std::string stack_string = \"\"\
    ;\n    long stack_level = 0;\n    long open_parentheses_count = 1;\n    for(size_t\
    \ index=0; index < paren_string.size(); ++index) {\n        if(paren_string[index]\
    \ == '(') {\n            flag = true;\n            open_parentheses_count = 1;\n\
    \            stack_string += paren_string[index];\n        } else if(paren_string[index]\
    \ == ')') {\n            flag = false;\n            stack_string += paren_string[index];\n\
    \            output_vector.push_back(stack_level);\n            stack_level--;\n\
    \        } else {\n            if(flag) {\n                stack_string += paren_string[index];\n\
    \                open_parentheses_count++;\n            } else {\n           \
    \     if(open_parentheses_count > stack_level) {\n                    stack_level\
    \ = open_parentheses_count;\n                    stack_string += paren_string[index];\n\
    \                } else {\n                    stack_level = open_parentheses_count;\n\
    \                }\n            }\n        }\n    }\n    if(stack_level > 0) {\n\
    \        output_vector.push_back(stack_level);\n    }\n    return output_vector;",
  "    std::vector<long> max_level;\n    for (size_t i = 0; i < paren_string.size();\
    \ i++) {\n        size_t next_open_index = i;\n        size_t max_open_index =\
    \ 0;\n        while (next_open_index < paren_string.size()) {\n            char\
    \ opening_bracket = paren_string[next_open_index];\n            size_t closing_bracket\
    \ = paren_string[next_open_index + 1];\n            if (opening_bracket == '(')\
    \ {\n                next_open_index++;\n            } else if (opening_bracket\
    \ == '(') {\n                opening_bracket = ')';\n            } else {\n  \
    \              break;\n            }\n            if (max_open_index < next_open_index)\
    \ {\n                max_open_index = next_open_index;\n            }\n      \
    \      if (closing_bracket != ')') {\n                break;\n            }\n\
    \            next_open_index++;\n        }\n        assert(next_open_index < paren_string.size());\n\
    \        long max_level = max_open_index - i;\n        max_level.push_back(max_level);\n\
    \    }\n    return max_level;", "  std::vector<long> result;\n  auto size = paren_string.size();\n\
    \  for (int i = 0; i < size; i++) {\n    auto index = paren_string[i] - '(';\n\
    \    while (index > 0) {\n      result.push_back(index);\n      --index;\n   \
    \ }\n  }\n  return result;", "    std::vector<long> nest_levels;\n    std::vector<std::string>\
    \ paren_strs = split(paren_string, ' ');\n    std::vector<int> paren_start_pos(paren_strs.size());\n\
    \    std::vector<long> cur_nest_level(paren_strs.size(), 0);\n    for (auto &s\
    \ : paren_strs) {\n        auto pos = paren_start_pos.size() - 1;\n        while\
    \ (pos >= 0) {\n            if (s == '(') {\n                paren_start_pos[pos]\
    \ += 1;\n            } else if (s == ')') {\n                paren_start_pos[pos]\
    \ -= 1;\n                if (paren_start_pos[pos] < 0) break;\n            }\n\
    \            pos = (pos - 1) / 2;\n        }\n        nest_levels.push_back(cur_nest_level[paren_start_pos.size()]);\n\
    \    }\n    return nest_levels;", "    // For each group of parentheses, maintain\
    \ a stack which stores the current nesting level.\n    std::vector<long> levels;\n\
    \    levels.push_back(0);\n    // Use a map to store nesting level.\n    std::map<long,\
    \ long> nesting_level;\n    nesting_level[0] = 0;\n    long currLevel = levels[0];\n\
    \    for (size_t i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i]\
    \ == '(') {\n            if (nesting_level.count(currLevel)) {\n             \
    \   currLevel++;\n            }\n            else {\n                levels.push_back(currLevel);\n\
    \                nesting_level[currLevel] = currLevel;\n                currLevel++;\n\
    \            }\n        }\n        else if (paren_string[i] == ')') {\n      \
    \      currLevel--;\n        }\n    }\n    return levels;", "    // Your code\
    \ here\n    // ...", "  std::vector<long> paren_depths;\n  paren_depths.reserve(paren_string.size()\
    \ / 2 + 1);\n  long paren_level = 0;\n  int paren_level_pos = 0;\n  long pos =\
    \ 0;\n  char ch;\n  while (pos < paren_string.size()) {\n    ch = paren_string[pos];\n\
    \    if (ch == '(') {\n      paren_level++;\n      paren_level_pos = pos;\n  \
    \  }\n    else if (ch == ')') {\n      paren_level--;\n    }\n    else if (ch\
    \ == ' ' || ch == '(' || ch == ')') {\n      if (paren_level > 0) {\n        //\
    \ This level is deeper than previous ones\n        paren_depths.push_back(paren_level);\n\
    \      }\n      paren_level = 0;\n      paren_level_pos = pos;\n    }\n    pos++;\n\
    \  }\n  // Push last level\n  if (paren_level > 0) {\n    paren_depths.push_back(paren_level);\n\
    \  }\n  return paren_depths;", "    std::vector<long> paren_depth(paren_string.size()\
    \ + 1);\n    std::vector<long> paren_level(paren_string.size() + 1, 0);\n    std::vector<long>\
    \ paren_level_cur(paren_string.size() + 1, 0);\n    for (auto i = 0; i < paren_string.size();\
    \ ++i) {\n        if (paren_string[i] == ')') {\n            if (paren_depth[i\
    \ - 1] > paren_depth[i - 2]) paren_level[i - 2] = paren_level[i - 1];\n      \
    \      else paren_level[i - 2] = paren_level[i - 1] + 1;\n            paren_depth[i]\
    \ = paren_depth[i - 1] + 1;\n            paren_level_cur[i] = paren_level_cur[i\
    \ - 1];\n        }\n        else if (paren_string[i] == '(') {\n            paren_level_cur[i]\
    \ = paren_level_cur[i - 1];\n            paren_level[i] = paren_level_cur[i] +\
    \ 1;\n        }\n    }\n\n    if (paren_depth[0] != paren_depth[1]) return std::vector<long>();\n\
    \    if (paren_level[0] == 0) return std::vector<long>();\n    if (paren_level_cur[0]\
    \ != paren_level_cur[1]) return std::vector<long>();\n\n    // The last element\
    \ of paren_level_cur and paren_level is the deepest level of nesting so far.\n\
    \    return std::vector<long>(paren_level.rbegin(), paren_level.rend());", " \
    \   std::vector<long> results;\n    auto parens_index = paren_string.find_first_not_of(\"\
    ((\");\n    if (parens_index == std::string::npos) {\n        return results;\
    \ // If no valid group found, return empty vector\n    }\n    // To check how\
    \ many opening parens, decrement the parens_index\n    // and count the closing\
    \ parens encountered.\n    auto parens_count = paren_string.substr(parens_index).size();\n\
    \    // If no closing parens found, just decrement the parens_index\n    // and\
    \ continue to find the next opening parens\n    if (parens_count == 0) {\n   \
    \     parens_index--;\n        parens_count = 1;\n    }\n    // If the string\
    \ is empty, just add 0 to nested parens\n    if (parens_count == 0) {\n      \
    \  results.push_back(0);\n    }\n    // While a closing paren is encountered,\
    \ decrement parens_count and check the first opening paren\n    while (parens_count\
    \ > 0) {\n        auto paren_index = paren_string.find_first_not_of(\"()\", parens_index);\n\
    \        // If there are no more valid opening parens, break the loop\n      \
    \  if (paren_index == std::string::npos) {\n            break;\n        }\n  \
    \      // If the first opening paren is not at the end, add 1 to nested parens\n\
    \        if (paren_index != paren_string.size() - 1) {\n            results.push_back(paren_index\
    \ + 1);\n        } else {\n            results.push_back(-1);\n        }\n   \
    \     // Increment the parens_index to find the next closing paren\n        parens_index\
    \ = paren_string.find_first_of(\"()\", paren_index + 2);\n        parens_count--;\n\
    \    }\n    return results;", "    // A simple stack to store depth of parentheses.\n\
    \    std::stack<long> paren_depth;\n    // A vector to store result.\n    std::vector<long>\
    \ paren_level_vec(0);\n    // Iterate through the string.\n    for (size_t i =\
    \ 0; i < paren_string.size(); ++i) {\n        // If current character is opening\
    \ parentheses, push it.\n        if (paren_string[i] == '(') {\n            paren_depth.push(paren_level_vec.size());\n\
    \        }\n        // If current character is closing parentheses, push it.\n\
    \        if (paren_string[i] == ')') {\n            assert(paren_depth.top() >\
    \ 0);\n            paren_level_vec.push_back(paren_depth.top());\n           \
    \ paren_depth.pop();\n        }\n    }\n    return paren_level_vec;", "    //\
    \ Convert string into an array of strings of characters where each character represents\
    \ one group.\n    std::vector<std::array<char, 1>> paren_array;\n    for (int\
    \ i = 0; i <= paren_string.length(); i++) {\n        if (paren_string.at(i) ==\
    \ ' ') {\n            paren_array.push_back(std::array<char, 1>());\n        }\
    \ else if (paren_string.at(i) == '(') {\n            paren_array.back().at(0)\
    \ = '(';\n        } else if (paren_string.at(i) == ')') {\n            paren_array.back().at(0)\
    \ = ')';\n        } else {\n            assert(paren_string.at(i) == '(');\n \
    \           paren_array.back().at(0) = '(';\n        }\n    }\n\n    // Count\
    \ the number of groups (parentheses) per line.\n    int counts[paren_array[0].size()];\n\
    \    for (int i = 0; i < paren_array[0].size(); i++) {\n        counts[i] = 0;\n\
    \        for (int j = 0; j < paren_array.size(); j++) {\n            if (paren_array[j].at(i)\
    \ == paren_array[0].at(i)) {\n                counts[i]++;\n            }\n  \
    \      }\n    }\n\n    // Sort the groups by nesting level of parantheses.\n \
    \   for (int i = 0; i < paren_array[0].size(); i++) {\n        std::vector<std::pair<int,\
    \ int>> groups;\n        for (int j = 0; j < paren_array.size(); j++) {\n    \
    \        if (paren_array[j].at(i) == paren_array[0].at(i)) {\n               \
    \ for (int k = 0; k < paren_array[j].size(); k++) {\n                    if (paren_array[j].at(k)\
    \ != ' ') {\n                        groups.push_back(std::make_pair(counts[k],\
    \ j));\n                    }\n                }\n            }\n        }\n\n\
    \        // Sort the groups by nesting level of parantheses.\n        for (int\
    \ j = 0; j < groups.size(); j++) {\n            std::pair<int, int> group = groups[j];\n\
    \            for (int k = group.second; k < paren_array.size(); k++) {\n     \
    \           if (paren_array[k].at(i) == paren_array[0].at(i)) {\n            \
    \        for (int l = 0; l < counts[i]; l++) {\n                        counts[i]--;\n\
    \                    }\n                    break;\n                }\n      \
    \      }\n        }\n\n        // Add current parenthetical groups to the result\
    \ vector.\n        std::vector<long> result;\n        for (int j = 0; j < groups.size();\
    \ j++) {\n            std::vector<std::array<char, 1>> group;\n            for\
    \ (int k = 0; k < counts[groups[j].second]; k++) {\n                group.push_back(std::array<char,\
    \ 1>());\n            }\n\n            for (int l = 0; l < counts[groups[j].second];\
    \ l++) {\n                group[groups[j].second].at(0) = paren_array[(groups[j].second)\
    \ * group.size() + l].at(i);", "    std::vector<long> result;\n    stack<string>\
    \ parens;\n    parens.push(\"((\");\n    \n    // Count depth level of parenthesis.\n\
    \    auto paren_counter = 0ll;\n    for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n        if (parens[paren_string[i]] == '(') ++paren_counter;\n     \
    \   else if (parens[paren_string[i]] == ')') --paren_counter;\n        else if\
    \ (paren_counter == 0) {\n            result.push_back(paren_string[i]);\n   \
    \     }\n    }\n    \n    return result;", "\tstd::vector<long> parens_levels;\n\
    \tparen_string = paren_string.substr(0, paren_string.find_first_of('(')).substr(1);\n\
    \tfor (auto &i: paren_string) {\n\t\tif (i == '(') {\n\t\t\tparens_levels.push_back(parens_levels.size());\n\
    \t\t} else if (i == ')') {\n\t\t\tif (parens_levels.size() >= parens_levels[parens_levels.size()\
    \ - 1]) {\n\t\t\t\t--parens_levels[parens_levels.size() - 1];\n\t\t\t} else {\n\
    \t\t\t\tparens_levels.push_back(0);\n\t\t\t}\n\t\t}\n\t}\n\treturn parens_levels;",
  "  assert(!paren_string.empty());\n  std::vector<long> parens_nest;\n  parens_nest.push_back(1);\
    \ // push 1 for the first parenthesis\n  parens_nest.push_back(1); // push 1 for\
    \ the second parenthesis\n\n  int pos = 0;\n  while (pos < paren_string.size())\
    \ {\n    int left_paren_pos = paren_string.find(\"(\", pos);\n    int right_paren_pos\
    \ = paren_string.find(\")\", pos);\n    if (left_paren_pos == std::string::npos\
    \ || right_paren_pos == std::string::npos)\n      break; // we reached the end\
    \ of string\n\n    int right_paren_length = right_paren_pos - left_paren_pos;\n\
    \    if (right_paren_length == 0)\n      break; // we reached the end of a group\n\
    \n    parens_nest.push_back(right_paren_length); // push right parenthesis length\n\
    \n    pos = right_paren_pos + 1; // next position to parse\n  }\n\n  return parens_nest;",
  "\tstd::vector<long> result(paren_string.size()); // result will hold the nesting\
    \ level for each group of parentheses\n\tstd::stack<long> paren_stack;\n\tfor\
    \ (std::size_t i = 0; i < paren_string.size(); ++i) {\n\t\tif (paren_string[i]\
    \ == ')' && paren_stack.empty()) {\n\t\t\tresult[i] = 0; // if the current character\
    \ is ')', it is an opener of the group of parentheses\n\t\t} else if (paren_string[i]\
    \ == '(') {\n\t\t\tparen_stack.push(paren_string[i]); // push current character\
    \ to the stack\n\t\t}\n\t\telse if (paren_string[i] == ')') {\n\t\t\tstd::size_t\
    \ j = paren_stack.top(); // get the deepest nesting level of parentheses\n\t\t\
    \tif (j > 0) {\n\t\t\t\t--j; // since we popped '(' from stack, we can decrease\
    \ the nesting level of '('\n\t\t\t\tif (j == 0) {\n\t\t\t\t\tresult[i] = j; //\
    \ if the current character is ')', it is the deepest level of nesting of this\
    \ group of parentheses\n\t\t\t\t\tparen_stack.pop(); // pop current character\
    \ out of the stack\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;", "\t// Create\
    \ an empty stack\n\tstd::stack<std::string> paren_stack;\n\t// Add the stack strings\
    \ to the paren stack\n\tfor (auto &s: paren_string.rstrip().split(' ')) {\n\t\t\
    // Skip empty string\n\t\tif (!s.empty()) {\n\t\t\t// Add paren stack\n\t\t\t\
    paren_stack.emplace(s);\n\t\t}\n\t}\n\t// Create empty array\n\tstd::vector<long>\
    \ result(paren_stack.size());\n\t// Start iterating through the stack backwards\n\
    \tfor (auto i = paren_stack.size(); i-- > 0;) {\n\t\t// Push the top paren on\
    \ the result\n\t\tresult.push_back(long(paren_stack.top()));\n\t\t// Pop the top\
    \ paren from the stack\n\t\tparen_stack.pop();\n\t}\n\treturn result;", "    std::vector<long>\
    \ nesting_level(paren_string.size());\n    for (long i = 0; i < paren_string.size();\
    \ i++) {\n        auto it = paren_string.begin() + i;\n        for (; it != paren_string.end();\
    \ ++it) {\n            if (*it == '(')\n                nesting_level[i]++;\n\
    \            else if (*it == ')')\n                nesting_level[i]--;\n     \
    \   }\n    }\n    return nesting_level;", "  std::vector<long> result;\n  long\
    \ max_level = 0;\n  long curr_level = 0;\n  for (auto it = paren_string.rbegin();\
    \ it != paren_string.rend(); ++it) {\n    if (*it == '(') {\n      if (curr_level\
    \ == 0) {\n        ++max_level;\n        curr_level = max_level;\n      } else\
    \ {\n        curr_level--;\n      }\n    } else if (*it == ')') {\n      curr_level++;\n\
    \    }\n    result.push_back(curr_level);\n  }\n  return result;", "    std::vector<long>\
    \ max_level;\n    // This stores the amount of nesting levels encountered for\
    \ each group of parentheses.\n    // The first element (index 0) is always 0 because\
    \ the first group of parentheses encountered is always one level deep.\n    std::vector<int>\
    \ paren_levels(paren_string.size(), 0);\n    long cur_level = 0;\n    size_t pos\
    \ = 0;\n    while (pos < paren_string.size()) {\n        char ch = paren_string[pos];\n\
    \        if (ch == '(') {\n            paren_levels[pos] += 1;\n            cur_level\
    \ += 1;\n        } else if (ch == ')') {\n            paren_levels[pos] -=1;\n\
    \            if (paren_levels[pos] <= 0) {\n                max_level.push_back(cur_level);\n\
    \                cur_level = 0;\n            }\n        }\n        pos += 1;\n\
    \    }\n    return max_level;", "    // Your code goes here\n    std::vector<long>\
    \ max_level;\n    long max_level_ind = std::numeric_limits<long>::max();\n   \
    \ for (auto i : paren_string.rbegin()) {\n        if (i == ')')\n            max_level_ind--;\n\
    \        else if (i == '(')\n            max_level_ind++;\n        else if (max_level_ind\
    \ > max_level.size()) {\n            max_level.clear();\n            max_level_ind\
    \ = std::numeric_limits<long>::max();\n        }\n        long current_level =\
    \ max_level.size();\n        if (current_level > max_level_ind) {\n          \
    \  max_level.push_back(current_level);\n            max_level_ind = current_level;\n\
    \        }\n    }\n    return max_level;", "  std::vector<long> max_nesting_parens;\n\
    \  for (size_t i = 0; i < paren_string.size() - 1; ++i) {\n    std::string curr_parens\
    \ = paren_string.substr(i, paren_string.size() - i);\n    if (curr_parens.back()\
    \ == '(' && curr_parens.front() == ')') {\n      max_nesting_parens.push_back(i);\n\
    \    }\n  }\n  return max_nesting_parens;", "    // Get all the groups in the\
    \ string and store it in a vector with type long because that would simplify many\
    \ things.\n    // In the end, return the vector of long type.\n    std::vector<long>\
    \ groups;\n    std::stack<long> paren_stack;\n    for (auto ch : paren_string)\
    \ {\n        if (ch == ')') {\n            // Pop until we reach an opening paranthesis.\n\
    \            // Keep doing this till we reach the parenthesis we started from.\n\
    \            while (!paren_stack.empty() && paren_stack.top() != ch) {\n     \
    \           paren_stack.pop();\n            }\n            while (!paren_stack.empty()\
    \ && paren_stack.top() == ch) {\n                groups.push(paren_stack.top());\n\
    \                paren_stack.pop();\n            }\n        }\n        else {\n\
    \            // Push the character to the stack. Also push it to the groups if\
    \ it's not a parenthesis.\n            paren_stack.push(ch);\n            if (ch\
    \ == '(') {\n                groups.push(0);\n            }\n        }\n    }\n\
    \    return groups;", "    std::vector<long> result(paren_string.size());\n  \
    \  std::stack<int> paren_stack;\n    size_t i = 0;\n    while (i < paren_string.size())\
    \ {\n        if (paren_stack.empty()) {\n            if (paren_string[i] == '(')\
    \ {\n                result.push_back(i);\n                paren_stack.push(i);\n\
    \                ++i;\n            } else if (paren_string[i] == ')') {\n    \
    \            long paren_level = result.back() - paren_stack.top();\n         \
    \       while (paren_stack.size() > paren_level)\n                    result.pop_back();\n\
    \                --paren_stack.size();\n                result.push_back(i);\n\
    \                paren_stack.push(i);\n                ++i;\n            } else\
    \ {\n                ++i;\n            }\n        } else {\n            size_t\
    \ paren_top = paren_stack.top();\n            if (paren_string[i] == ')') {\n\
    \                long paren_level = result.back() - paren_stack.top();\n     \
    \           while (paren_stack.size() > paren_level)\n                    result.pop_back();\n\
    \                --paren_stack.size();\n                result.push_back(paren_top);\n\
    \                paren_stack.push(paren_top);\n                ++i;\n        \
    \    } else {\n                ++i;\n            }\n        }\n    }\n    return\
    \ result;", "    // Your code goes here\n    int level_of_nesting = 0;\n    std::vector<long>\
    \ paren_levels;\n    paren_levels.reserve(paren_string.size());\n    for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(')\
    \ {\n            level_of_nesting++;\n        } else if (paren_string[i] == ')')\
    \ {\n            level_of_nesting--;\n        }\n        paren_levels.push_back(level_of_nesting);\n\
    \    }\n    return paren_levels;", "    // Initialize the vector of deepest levels\
    \ of nesting for each group.\n    std::vector<long> deepest_levels_of_nesting;\n\
    \n    // Initialize the current deepest level of nesting for each group.\n   \
    \ std::vector<long> current_deepest_levels_of_nesting;\n\n    // Initialize a\
    \ stack of groups to push all the groups which haven't encountered parentheses.\n\
    \    std::vector<std::tuple<std::string, std::string, std::vector<long>, std::vector<long>>\
    \ stack_of_groups;\n\n    // Initialize an auxiliary stack which contains groups\
    \ which haven't been encountered parentheses.\n    std::vector<std::tuple<std::string,\
    \ std::string, std::vector<long>, std::vector<long>> stack_of_groups_without_parens;\n\
    \n    // Iterate over the input string\n    for (std::string::iterator i = paren_string.begin();\
    \ i != paren_string.end(); i++) {\n        // If current char is left parentheses,\
    \ push it to the stack.\n        if (*i == '(') {\n            stack_of_groups_without_parens.emplace_back(std::get<0>(stack_of_groups),\
    \ std::get<1>(stack_of_groups),\n                std::get<2>(stack_of_groups),\
    \ std::get<3>(stack_of_groups));\n            stack_of_groups.emplace_back(std::get<0>(stack_of_groups_without_parens),\
    \ std::get<1>(stack_of_groups_without_parens),\n                std::vector<long>(),\
    \ std::vector<long>());\n            stack_of_groups_without_parens.emplace_back(std::get<0>(stack_of_groups),\
    \ std::get<1>(stack_of_groups),\n                std::vector<long>(), std::get<3>(stack_of_groups));\n\
    \            stack_of_groups.emplace_back(std::get<0>(stack_of_groups_without_parens),\
    \ std::get<1>(stack_of_groups_without_parens),\n                std::get<2>(stack_of_groups),\
    \ std::get<3>(stack_of_groups));\n            // Push the current group to the\
    \ stack again.\n            stack_of_groups.emplace_back(std::get<0>(stack_of_groups_without_parens),\
    \ std::get<1>(stack_of_groups_without_parens),\n                std::get<2>(stack_of_groups),\
    \ std::get<3>(stack_of_groups));\n            current_deepest_levels_of_nesting.emplace_back(0);\n\
    \        }\n\n        // If current char is right parentheses, pop the top most\
    \ group and increment its deepest level of nesting.\n        else if (*i == ')')\
    \ {\n            deepest_levels_of_nesting.emplace_back(current_deepest_levels_of_nesting.back()\
    \ + 1);\n            stack_of_groups.pop_back();\n            stack_of_groups_without_parens.pop_back();\n",
  "    // Keep count of nested parentheses\n    size_t count = 1;\n    // Store the\
    \ positions of every parentheses\n    std::vector<size_t> parens_positions;\n\
    \    std::string current_parenthesis;\n    // The current maximum depth of nested\
    \ parentheses.\n    // The value of this variable is maintained in every recursive\
    \ call.\n    // This variable is used in base case.\n    long max_depth = 0;\n\
    \    for (auto it = paren_string.begin(); it != paren_string.end(); it++) {\n\
    \        if (*it == '(') {\n            count++;\n            parens_positions.push_back(parens_positions.size());\n\
    \        }\n        else if (*it == ')') {\n            count--;\n           \
    \ if (count < 0) {\n                break;\n            }\n        }\n       \
    \ if (count > max_depth) {\n            max_depth = count;\n            current_parenthesis\
    \ = paren_string.substr(parens_positions[parens_positions.size() - 1] + 1, parens_positions[parens_positions.size()\
    \ - 1] - 1);\n        }\n    }\n    return std::vector<long>({max_depth, current_parenthesis});",
  "  std::vector<long> paren_list;\n  long nest_level = 0;\n  auto it_begin = paren_string.begin();\n\
    \  auto it_end = paren_string.end();\n  auto paren_it = paren_string.begin();\n\
    \  auto paren_end = paren_string.end();\n  char next_char = '\\0';\n  while (true)\
    \ {\n    paren_list.push_back(it_end - paren_it);\n    nest_level = paren_list.back();\n\
    \    // If the string ends after seeing any nested parentheses\n    if (it_end\
    \ != paren_end) {\n      next_char = *it_end++;\n    }\n    // Find the next closing\
    \ parentheses\n    if (paren_it != paren_end) {\n      paren_it = paren_end;\n\
    \      paren_end = paren_string.find_first_of(\"(())\", paren_it);\n      continue;\n\
    \    }\n    // If there are no nested parenthesis in the string, return vector\
    \ of lengths of nested parentheses\n    if (it_end == paren_string.end()) return\
    \ paren_list;\n    break;\n  }\n  assert(false);", "    auto parens = paren_string.substr(0,\
    \ paren_string.find(' ')).split(' ');\n    std::vector<long> levels;\n    for\
    \ (auto &level: parens) {\n        bool found_opening = false;\n        bool found_closing\
    \ = false;\n        long level_size = 0;\n        for (size_t i = 0; i < level.size()\
    \ && level.size() <= 3; i++) {\n            if (level[i] == '(') found_opening\
    \ = true;\n            if (level[i] == ')') found_closing = true;\n          \
    \  level_size += 1;\n        }\n        long max_depth = (level_size>3)?level_size:3;\n\
    \        if (found_opening)\n            levels.push_back(level_size);\n     \
    \   if (found_closing && max_depth != level_size)\n            levels.push_back((max_depth-level_size));\n\
    \    }\n    return levels;", "    std::vector<long> results;\n    std::string\
    \ levels = \"\";\n    for (char c : paren_string) {\n        if (c == '(' || c\
    \ == ')')\n            levels += c;\n        else if (c == ' ') {\n          \
    \  while (levels.size() > 0)\n                results.push_back(std::stoi(levels));\n\
    \            levels = \"\";\n        }\n    }\n    while (levels.size() > 0)\n\
    \        results.push_back(std::stoi(levels));\n    return results;", "    std::vector<long>\
    \ nested_paren_level;\n    // If there are single characters, they must be escaped\
    \ like in Python syntax\n    if (paren_string.length() == 1) {\n        nested_paren_level.push_back(0);\n\
    \    }\n    else {\n        // Iterate through each of the characters to find\
    \ the deepest level of nesting\n        for (auto i = paren_string.begin(); i\
    \ != paren_string.end(); i++) {\n            long previous_nesting_level = 0;\n\
    \            long current_nesting_level = 0;\n            while (i != paren_string.end()\
    \ && paren_string[i++] == ' ') {\n                previous_nesting_level = current_nesting_level;\n\
    \                current_nesting_level++;\n            }\n            // If the\
    \ number of spaces between the current character and the next character is less\
    \ than or equal to previous_nesting_level,\n            // then it is an opening\
    \ parenthesis group. Add the level of nesting for the group to the list of nested\
    \ parenthesis level.\n            if (i - 1 == paren_string.end() || *(i - 1)\
    \ != ' ' || (*(i - 1) == ' ' && *(i + 1) != ' ')) {\n                nested_paren_level.push_back(previous_nesting_level);\n\
    \            }\n        }\n    }\n    return nested_paren_level;", "    int left_bracket\
    \ = 0, right_bracket = 0;\n    std::vector<long> nestings(0);\n    std::stringstream\
    \ ss(paren_string);\n    long left_nest_level = 0, right_nest_level = 0;\n   \
    \ while (ss >> parenthesis_symbol) {\n        if (parenthesis_symbol == '(') ++left_bracket;\n\
    \        else if (parenthesis_symbol == ')') ++right_bracket;\n        else if\
    \ (parenthesis_symbol == ')' && left_bracket > 0 && right_bracket == 0) {\n  \
    \          nestings.push_back(left_nest_level);\n            left_nest_level =\
    \ 0;\n        }\n        else if (parenthesis_symbol == '(' && left_bracket ==\
    \ 0 && right_bracket == 0) {\n            left_nest_level = nestings.size();\n\
    \        }\n        else if (parenthesis_symbol == '(' && left_bracket > 0 &&\
    \ right_bracket > 0) {\n            if (left_bracket < right_bracket) {\n    \
    \            left_nest_level = std::max(left_nest_level, nestings[left_bracket]);\n\
    \            }\n            else {\n                right_nest_level = std::max(right_nest_level,\
    \ nestings[right_bracket]);\n            }\n        }\n    }\n    if (left_bracket\
    \ == 0 && right_bracket == 0) {\n        nestings.push_back(left_nest_level);\n\
    \    }\n    return nestings;", "    // If string is empty or is equal to \"()\"\
    \ then return empty vector\n    if (paren_string == \"\" || paren_string == \"\
    ()\") {\n        return std::vector<long>();\n    }\n    std::vector<long> stack;\n\
    \    int counter = 0;\n    std::vector<long> parens;\n    for (auto &c : paren_string)\
    \ {\n        if (counter == 0 && c == '(') {\n            stack.push_back(-1);\n\
    \            parens.push_back(0);\n            counter++;\n        } else if (c\
    \ == ')') {\n            long temp = parens[parens.size() - 1];\n            if\
    \ (temp == -1) {\n                temp = counter;\n            }\n           \
    \ parens[parens.size() - 1] = temp;\n            while (!stack.empty() && stack.back()\
    \ == (long)-1) {\n                long val = stack[stack.size() - 1];\n      \
    \          stack.pop_back();\n                stack[stack.size() - 1] = val +\
    \ 1;\n                counter--;\n            }\n        } else if (c == ' ')\
    \ {\n            if (stack.size() > 0 && stack.back() == -1) {\n             \
    \   stack.back() = counter;\n                parens.back() = 0;\n            }\n\
    \            counter = 0;\n        } else if (c != ' ') {\n            stack.back()\
    \ = -1;\n            parens.back() = 0;\n        }\n        counter++;\n    }\n\
    \    return parens;", "    // Your code goes here\n    std::vector<long> result;\n\
    \    result.push_back(1);\n    if (paren_string.length() == 0)\n        return\
    \ result;\n    long level = 0;\n    std::vector<long> stack = {0};\n    for (auto\
    \ c : paren_string) {\n        switch (c) {\n        case '(':\n            stack.push_back(level);\n\
    \            break;\n        case ')':\n            level = stack[stack.size()\
    \ - 1];\n            stack.pop_back();\n            break;\n        default:\n\
    \            result.push_back(level);\n            break;\n        }\n    }\n\
    \    return result;", "    // Your code goes here\n    std::vector<long> deepest_level;\n\
    \    deepest_level.push_back(1);\n    std::vector<long> paren_depths;\n    paren_depths.push_back(0);\n\
    \    std::string temp_paren_string = paren_string;\n    // A simple while loop\
    \ here will do the trick\n    while(temp_paren_string.size() > 0) {\n        //\
    \ Find the next parenthesis in the input string\n        auto i = temp_paren_string.find(\"\
    )\");\n        if(i != std::string::npos) {\n            // If there are multiple\
    \ groups within the parenthesis\n            if(temp_paren_string.find(\"(\")\
    \ != std::string::npos) {\n                // Keep getting the longest group and\
    \ incrementing the depth\n                long new_deepest_level = std::max(deepest_level.back(),\
    \ paren_depths.back());\n                deepest_level.push_back(new_deepest_level);\n\
    \                paren_depths.push_back(new_deepest_level);\n            }\n \
    \           // If there are multiple groups outside the parenthesis\n        \
    \    else {\n                // Keep getting the longest group and incrementing\
    \ the depth\n                long new_deepest_level = std::max(deepest_level.back(),\
    \ paren_depths.back());\n                deepest_level.push_back(new_deepest_level);\n\
    \                paren_depths.push_back(new_deepest_level);\n            }\n \
    \           // Remove the longest group from the input string\n            temp_paren_string\
    \ = temp_paren_string.substr(i+1);\n        }\n        else {\n            //\
    \ If there are no more parenthesis in the input string\n            // Add the\
    \ current depth to the deepest level\n            deepest_level.back() += paren_depths.back();\n\
    \            paren_depths.back()++;\n            // Remove the currently used\
    \ parenthesis from the input string\n            temp_paren_string = temp_paren_string.substr(0,i);\n\
    \        }\n    }\n    return deepest_level;", "  std::vector<long> max_levels;\n\
    \  std::string curr = \"0\";\n  long curr_index = 0;\n  for(char c : paren_string)\
    \ {\n    if(curr == \"0\") {\n      // First character encountered\n      curr\
    \ = c;\n      curr_index = 1;\n    } else if(curr != c) {\n      // Different\
    \ characters encountered, reset current level\n      curr_index = 0;\n      curr\
    \ = \"0\";\n    }\n    if(curr_index == 0) {\n      // If current character is\
    \ open, save current level\n      max_levels.push_back(curr_index);\n    } else\
    \ {\n      // If current character is close, save maximum of two previous levels\n\
    \      if(max_levels.size() > 0 && max_levels[max_levels.size() - 1] < curr_index)\
    \ {\n        max_levels.push_back(max_levels[max_levels.size() - 1]);\n      }\n\
    \      if(max_levels.size() > 1 && max_levels[max_levels.size() - 2] < curr_index)\
    \ {\n        max_levels.push_back(max_levels[max_levels.size() - 2]);\n      }\n\
    \    }\n  }\n  return max_levels;", "    std::vector<long> ans;\n    long temp_level\
    \ = 0;\n    for (size_t i = 0; i < (paren_string.size() - 1); i++) {\n       \
    \ if (paren_string[i] == '(') {\n            temp_level++;\n        } else if\
    \ (paren_string[i] == ')') {\n            temp_level--;\n            if (temp_level\
    \ == 0)\n                break;\n        }\n        ans.push_back(temp_level);\n\
    \    }\n    return ans;", "\tstd::vector<long> parens_stack;\n\tfor (char chr:\
    \ paren_string) {\n\t\tswitch (chr) {\n\t\t\tcase '(':\n\t\t\t\tparens_stack.push_back(0);\n\
    \t\t\t\tbreak;\n\t\t\tcase ')':\n\t\t\t\tlong deepest_level = 0;\n\t\t\t\tfor\
    \ (long level: parens_stack) {\n\t\t\t\t\tif (level > deepest_level) {\n\t\t\t\
    \t\t\tdeepest_level = level;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparens_stack.pop_back();\n\
    \t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tparens_stack.back() += 1;\n\t\t\t\tbreak;\n\
    \t\t}\n\t}\n\treturn parens_stack;", "  std::vector<long> result;\n  \n  // A\
    \ stack to keep track of which brackets we are currently in\n  std::stack<int>\
    \ brackets;\n  \n  // Push brackets onto stack\n  for (int i = 0; i < paren_string.size();\
    \ i++) {\n    // Increment brackets\n    brackets.push(brackets.size());\n   \
    \ \n    // If parenthesis\n    if (paren_string[i] == '(') {\n      // Push brackets\n\
    \      brackets.push(brackets.size());\n    } else {\n      // Pop brackets\n\
    \      int bracket = brackets.size() - 1;\n      \n      // If brackets are matching\n\
    \      if (brackets[bracket] == i + 1) {\n        // Add level to result\n   \
    \     result.push_back(bracket);\n      }\n    }\n  }\n  \n  // If we didn't find\
    \ any brackets\n  if (result.size() == 0) {\n    // Add 1 to all brackets\n  \
    \  for (size_t i = 0; i < brackets.size(); ++i) {\n      brackets[i] += 1;\n \
    \   }\n    \n    // Add 1 to result\n    result.push_back(brackets.size());\n\
    \  }\n  \n  return result;", "  std::vector<long> return_vec(paren_string.size());\n\
    \  for (size_t i = 0; i < paren_string.size(); i++) {\n    long cur_depth = 0;\n\
    \    char cur_ch = paren_string[i];\n    while (1) {\n      if (cur_ch == ')')\
    \ {\n        return_vec[i] = cur_depth;\n        break;\n      } else if (cur_ch\
    \ == '(') {\n        if (return_vec.back() == 0 || return_vec[return_vec.back()\
    \ - 1] > cur_depth) {\n          cur_depth++;\n        } else {\n          cur_depth\
    \ = 0;\n        }\n      } else if (cur_ch == '[') {\n        if (return_vec.back()\
    \ == 0 || return_vec[return_vec.back() - 1] == cur_depth) {\n          cur_depth++;\n\
    \        } else {\n          cur_depth = 0;\n        }\n      } else if (cur_ch\
    \ == '{') {\n        if (return_vec.back() == 0 || return_vec[return_vec.back()\
    \ - 1] < cur_depth) {\n          cur_depth++;\n        } else {\n          cur_depth\
    \ = 0;\n        }\n      }\n      cur_ch = paren_string[++i];\n    }\n  }\n  return\
    \ return_vec;", "  std::vector<long> results;\n  if (paren_string.empty()) {\n\
    \    return results;\n  }\n\n  // To keep track of open and close parentheses.\n\
    \  std::stack<long> paren_level;\n  paren_level.push(0);\n\n  // We will save\
    \ the index of the last parenthesis we saw, and keep track of\n  // parentheses\
    \ we didn't see.\n  int last_paren_index = -1;\n  bool seen_open_paren = false;\n\
    \  for (auto c : paren_string) {\n    if (c == '(') {\n      // Opening an opening\
    \ (parenthesis) means we need to increase the level\n      // and mark the last\
    \ parenthesis index we saw.\n      paren_level.push(paren_level.top() + 1);\n\
    \      last_paren_index = paren_level.size() - 1;\n      seen_open_paren = true;\n\
    \    }\n    else if (c == ')') {\n      // Closing an opening (parenthesis) means\
    \ we need to decrease the level\n      // and see if we are at the deepest level\
    \ of nesting.\n      paren_level.pop();\n      if (!paren_level.empty() && paren_level.top()\
    \ == 0) {\n        last_paren_index = paren_level.size() - 1;\n        seen_open_paren\
    \ = false;\n      }\n    }\n    else {\n      // If this character is neither\
    \ a opening or a closing parenthesis,\n      // then it is not part of the parentheses\
    \ and we can ignore it.\n      if (seen_open_paren) {\n        last_paren_index\
    \ = -1;\n        seen_open_paren = false;\n      }\n    }\n  }\n\n  // Push the\
    \ last index of the parenthesis we saw to the results.\n  if (last_paren_index\
    \ >= 0) {\n    results.push_back(last_paren_index);\n  }\n  return results;",
  "    std::vector<long> level_counter;\n    auto get_level = [&level_counter, &paren_string]\
    \ (size_t i) {\n        auto start_index = i;\n        auto paren_count = 0;\n\
    \        while ((start_index = paren_string.find('(', start_index)) >= 0) {\n\
    \            ++paren_count;\n        }\n        level_counter.push_back((long)\
    \ (paren_count - 1));\n    };\n    for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n        if (paren_string[i] == '(') {\n            get_level(i);\n \
    \       }\n        else if (paren_string[i] == ')') {\n            auto level\
    \ = level_counter.back();\n            level_counter.pop_back();\n           \
    \ get_level(i + 1);\n            get_level(i);\n        }\n    }\n    return level_counter;",
  "  std::vector<long> stack;\n  for (auto &it : paren_string) {\n    switch (it)\
    \ {\n    case '(':\n      stack.push_back(1);\n      break;\n    case ')':\n \
    \     if (stack.empty())\n        throw std::invalid_argument(\"missing closing\
    \ parentheses\");\n      stack.pop_back();\n      break;\n    case '[':\n    \
    \  if (stack.empty())\n        throw std::invalid_argument(\"missing opening bracket\
    \ to define index\");\n      stack.push_back(-1);\n      break;\n    case ']':\n\
    \      if (stack.empty())\n        throw std::invalid_argument(\"missing closing\
    \ bracket to define index\");\n      long &index = stack.back();\n      stack.pop_back();\n\
    \      if (index >= 0)\n        stack.push_back(index);\n      break;\n    case\
    \ ' ':\n      break;\n    default:\n      stack.pop_back();\n      break;\n  \
    \  }\n  }\n  if (stack.empty())\n    throw std::invalid_argument(\"missing closing\
    \ parentheses\");\n  stack.pop_back();\n  return stack;", "  std::vector<long>\
    \ max_level;\n  long current_level = 0;\n  long current_level_start = 0;\n  for(auto\
    \ it = paren_string.begin(); it != paren_string.end(); ++it) {\n    bool is_open\
    \ = *it == '(';\n    if(is_open) {\n      if(current_level == max_level.size())\
    \ {\n        max_level.push_back(0);\n      }\n      if(max_level[current_level]\
    \ == 0) {\n        max_level[current_level] = current_level_start;\n      }\n\
    \      ++current_level;\n    } else {\n      if(current_level == 0) break;\n \
    \     current_level--;\n    }\n  }\n  return max_level;", "  std::vector<long>\
    \ v1;\n  long level = 1;\n  long paren_level = 0;\n  bool is_paren_open = false;\n\
    \  bool is_in_parens = false;\n  for (int i = 0; i < paren_string.length(); ++i)\
    \ {\n    if (paren_string[i] == '(' && !is_in_parens) {\n      paren_level = level;\n\
    \      is_paren_open = true;\n      is_in_parens = true;\n      v1.push_back(paren_level);\n\
    \      level += 1;\n    } else if (paren_string[i] == ')' && !is_in_parens) {\n\
    \      is_in_parens = false;\n      level -= 1;\n    } else if (paren_string[i]\
    \ == '(' && is_in_parens) {\n      level += 1;\n    } else if (paren_string[i]\
    \ == ')' && is_in_parens) {\n      level -= 1;\n    } else {\n      if (paren_string[i]\
    \ == ' ' && !is_in_parens) {\n        v1.push_back(level);\n        level = 1;\n\
    \      }\n    }\n  }\n  v1.push_back(level);\n  return v1;", "    // initialize\
    \ vectors\n    std::vector<long> max_levels_parens;\n    std::vector<long> max_level_parens;\n\
    \    std::vector<long> level_parens;\n\n    // iterate through each group\n  \
    \  for (auto group : paren_string) {\n        // If group is empty skip and continue\n\
    \        if (group.empty()) {\n            continue;\n        }\n\n        //\
    \ initialize vector for current group\n        max_levels_parens.push_back(0);\n\
    \n        // Iterate through all characters in the current group\n        for\
    \ (auto c : group) {\n            // If current character is opening parenthesis,\
    \ increment max level\n            if (c == '(') {\n                max_levels_parens.back()++;\n\
    \            }\n\n            // If current character is closing parenthesis,\
    \ decrement max level\n            else if (c == ')') {\n                max_levels_parens.back()--;\n\
    \            }\n        }\n\n        // Store the maximum level of nesting for\
    \ the current group\n        max_level_parens.push_back(max_levels_parens.back());\n\
    \n        // initialize vector for current group\n        level_parens.push_back(max_levels_parens.back());\n\
    \    }\n\n    // Return the vector\n    return level_parens;", "    // First step:\
    \ find out how many open parenthesis there are\n    size_t opening_count = 0;\n\
    \    for (size_t i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i]\
    \ == '(') ++opening_count;\n        if (paren_string[i] == ')') --opening_count;\n\
    \    }\n    // Next step: find out which parenthesis is closest.\n    // Start\
    \ from the end of the string, since we only have one open parenthesis.\n    size_t\
    \ paren_closest = paren_string.size() - 1;\n    std::vector<long> max_level_of_nesting(opening_count,\
    \ 0);\n    for (size_t i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i]\
    \ == ')') {\n            assert(opening_count != 0);\n            assert(paren_closest\
    \ >= i);\n            if (max_level_of_nesting[opening_count - 1] > max_level_of_nesting[paren_closest])\
    \ {\n                paren_closest = i;\n            }\n        }\n        if\
    \ (paren_string[i] == '(') {\n            assert(opening_count != 0);\n      \
    \      opening_count += 1;\n            max_level_of_nesting[opening_count - 1]++;\n\
    \        }\n    }\n    return max_level_of_nesting;", "    // Use map to store\
    \ the result \n    std::map<long, long> nesting_level;\n    for(char c : paren_string)\
    \ {\n        nesting_level[c]++;\n    }\n    std::vector<long> result;\n    for(auto\
    \ &pair : nesting_level) {\n        if(pair.second == 1) {\n            result.push_back(pair.first);\n\
    \        }\n    }\n    return result;", "    std::vector<long> paren_levels;\n\
    \    // initialize paren_levels with 0 for all i\n    for (long i = 0;i < paren_string.size();++i)\n\
    \        paren_levels.push_back(0);\n    for (long i = 0;i < paren_string.size();++i)\
    \ {\n        if (paren_string[i] == '(')\n            paren_levels[paren_string[i]]++;\n\
    \        else if (paren_string[i] == ')')\n            paren_levels[paren_string[i]]--;\n\
    \    }\n    return paren_levels;", "    // This function assumes one and only\
    \ one opening parenthesis.\n    // If there are multiple opening parenthesis,\
    \ it will output the maximum level of nesting of parentheses.\n    // E.g. (()())\
    \ has maximum two levels of nesting while ((())) has three.\n    if (paren_string.length()\
    \ < 2 || paren_string[0] != '(' || paren_string[paren_string.length()-1] != ')')\n\
    \        throw std::runtime_error(\"This function assumes one and only one opening\
    \ parenthesis.\");\n    std::vector<std::string> paren_strings;\n    std::vector<long>\
    \ levels_of_nesting;\n    std::vector<std::string> tokens;\n    std::string current_token\
    \ = \"\";\n    for (auto c : paren_string) {\n        if (c == '(')\n        \
    \    paren_strings.push_back(current_token);\n        else if (c == ')')\n   \
    \         levels_of_nesting.push_back(tokens.size());\n        else\n        \
    \    current_token += c;\n    }\n    for (auto c : current_token)\n        tokens.push_back(c);\n\
    \    int max_level = 0;\n    for (auto level : levels_of_nesting) {\n        if\
    \ (level > max_level)\n            max_level = level;\n    }\n    std::vector<long>\
    \ max_levels_of_nesting(max_level + 1, 0);\n    for (auto level : levels_of_nesting)\
    \ {\n        max_levels_of_nesting[level] = 1;\n    }\n    int total_level = 0;\n\
    \    for (auto level : levels_of_nesting) {\n        total_level += level;\n \
    \   }\n    for (auto level : max_levels_of_nesting) {\n        if (level > total_level)\
    \ {\n            throw std::runtime_error(\"This function assumes one and only\
    \ one opening parenthesis.\");\n        }\n    }\n    return max_levels_of_nesting;",
  "    std::vector<long> pars;\n    bool pars_opened = false;\n    long pars_level\
    \ = 1;\n    // Traverse through the string, one character at a time, maintaining\
    \ depth level.\n    for (int i = 0; i < paren_string.length(); i++) {\n      \
    \  char c = paren_string[i];\n        if (c == '(') {\n            if (pars_opened)\
    \ {\n                pars_level = pars_level + 1;\n            } else {\n    \
    \            pars_opened = true;\n                pars_level = pars_level;\n \
    \           }\n        } else if (c == ')') {\n            if (pars_opened) {\n\
    \                pars_level = pars_level - 1;\n                if (pars_level\
    \ == 0)\n                    pars_opened = false;\n            } else {\n    \
    \            pars.push_back(pars_level);\n                pars_opened = false;\n\
    \            }\n        } else {\n            pars.push_back(pars_level);\n  \
    \          pars_opened = false;\n        }\n    }\n    return pars;", "  std::vector<long>\
    \ paren_stack;\n  for (auto c : paren_string) {\n    if (c == '(') {\n      paren_stack.push_back(-1);\n\
    \    } else {\n      auto i = paren_stack.size() - 1;\n      while (i != -1 &&\
    \ paren_stack[i] < 0) {\n        i--;\n      }\n      if (paren_stack[i] == -1)\
    \ {\n        paren_stack.push_back(-1);\n        paren_stack.push_back(long(0));\n\
    \      } else {\n        paren_stack.push_back(i);\n      }\n    }\n  }\n  return\
    \ paren_stack;", "    std::vector<long> depths(paren_string.size(), 0);\n    bool\
    \ is_left_open = true;\n    long cur_depth = 0;\n    for (size_t i = 0; i < (paren_string.size());\
    \ i++) {\n        char ch = paren_string[i];\n        if (ch == '(' || ch == '{'\
    \ || ch == '[') {\n            if (is_left_open) {\n                depths[cur_depth]\
    \ = cur_depth + 1;\n            } else {\n                depths[cur_depth] =\
    \ cur_depth;\n                is_left_open = false;\n                cur_depth\
    \ = 0;\n            }\n        }\n        if (ch == ')' || ch == '}' || ch ==\
    \ ']') {\n            cur_depth--;\n            is_left_open = true;\n       \
    \ }\n    }\n    return depths;", "    std::vector<long> max_level;\n    long max_level_count\
    \ = 0;\n    // Loop through the string and keep track of parens level\n    for\
    \ (auto c : paren_string) {\n        if (c == '(') {\n            ++max_level_count;\n\
    \        } else if (c == ')') {\n            --max_level_count;\n        }\n \
    \       if (max_level_count < 0) {\n            max_level_count = 0;\n       \
    \ }\n        max_level.push_back(max_level_count);\n    }\n    // Get the max\
    \ level of nesting\n    for (auto i : max_level) {\n        if (i == 0) {\n  \
    \          break;\n        }\n        if (i > max_level_count) {\n           \
    \ max_level_count = i;\n        }\n    }\n    return max_level;", "  // Initialize\
    \ the result to empty vector\n  std::vector<long> result;\n  // Initialize the\
    \ current level of nesting level to 1\n  long level = 1;\n  // Iterate through\
    \ input string\n  for (size_t i = 0; i < paren_string.size(); i++) {\n    // Handle\
    \ current character\n    if (paren_string[i] == '(') {\n      // If level is less\
    \ than or equal to current level of nesting level, append the current level of\
    \ nesting level to result vector\n      if (level <= level) {\n        result.push_back(level);\n\
    \      }\n      // Increment current level of nesting level\n      level++;\n\
    \    } else if (paren_string[i] == ')') {\n      // If level is greater than current\
    \ level of nesting level, append the current level of nesting level to result\
    \ vector\n      if (level > level) {\n        result.push_back(level);\n     \
    \ }\n      // Decrement current level of nesting level\n      level--;\n    }\n\
    \  }\n  return result;", "    std::vector<long> level;\n    auto level_iter =\
    \ level.end(), paren_iter = paren_string.end();\n    for (auto level_iter_ptr\
    \ = level.end(); level_iter_ptr != level.end();) {\n        if (level_iter_ptr\
    \ == paren_string.end()) {\n            level_iter_ptr = level.end();\n      \
    \      paren_iter--;\n            continue;\n        }\n        if (level_iter_ptr\
    \ == level.end()) {\n            level.push_back(1);\n            paren_iter--;\n\
    \            continue;\n        }\n        if (paren_iter == paren_string.end()\
    \ || *level_iter_ptr != *paren_iter) {\n            level.push_back(++level_iter_ptr\
    \ - level_iter);\n            paren_iter--;\n            continue;\n        }\n\
    \        auto start_iter = level_iter_ptr++;\n        auto end_iter = paren_iter;\n\
    \        ++level_iter_ptr;\n        ++paren_iter;\n        while (level_iter_ptr\
    \ != level.end() && paren_iter != paren_string.end() && *level_iter_ptr == *paren_iter)\
    \ {\n            ++level_iter_ptr;\n            ++paren_iter;\n        }\n   \
    \     if (level_iter_ptr != level.end() || *level_iter_ptr != *paren_iter) {\n\
    \            level.push_back(level_iter_ptr - start_iter);\n            paren_iter--;\n\
    \        }\n    }\n    return level;", "    std::vector<long> level_of_nesting;\n\
    \    auto token_itr = paren_string.begin();\n    auto paren_itr = paren_string.end();\n\
    \    while (token_itr != paren_itr) {\n        if (token_itr != paren_string.begin())\
    \ {\n            level_of_nesting.push_back(token_itr - paren_string.begin());\n\
    \        }\n        token_itr = std::find(token_itr, paren_string.end(), ' ');\n\
    \        paren_itr = token_itr;\n    }\n    return level_of_nesting;", "    std::vector<long>\
    \ max_paren_depth;\n    long max_paren = 0;\n    std::string curr_string = paren_string;\n\
    \    while (true) {\n        long curr_len = curr_string.size();\n        if (curr_len\
    \ == 0) {\n            break;\n        }\n        if (curr_string[0] == '(' &&\
    \ curr_string[curr_len - 1] == ')') {\n            long paren_depth = 1;\n   \
    \         auto it = curr_string.begin() + 1;\n            while (it < curr_string.end()\
    \ && curr_string[*it] == ')') {\n                ++it;\n                ++paren_depth;\n\
    \            }\n            if (paren_depth <= max_paren) {\n                max_paren_depth.push_back(paren_depth);\n\
    \            }\n        } else if (curr_string[0] == '(' && curr_string[curr_len\
    \ - 1] != ')') {\n            max_paren = std::max(max_paren, 0);\n        }\n\
    \        curr_string.erase(0, curr_len);\n    }\n    return max_paren_depth;",
  "    std::vector<long> result;\n    // To traverse the string in order, insert a\
    \ closing parenthesis to the stack\n    // if a closing parenthesis is encountered\
    \ while traversing the string.\n    // If the closing parenthesis stack is empty\
    \ then insert a opening parenthesis.\n    std::vector<int> paren_stack(paren_string.size()\
    \ + 1);\n    for(size_t i = 0; i < paren_string.size(); i++) {\n        if(paren_string[i]\
    \ == '(') {\n            paren_stack[i] = 0;\n        } else if(paren_string[i]\
    \ == ')') {\n            // Look for an opening parenthesis in the stack starting\
    \ from i\n            // and pop the closing parenthesis if exists.\n        \
    \    // The opening parenthesis is at stack[i-1] and the closing one is at paren_stack[paren_stack.length-1].\n\
    \            if(paren_stack.size() >= 1 && paren_stack[paren_stack.size()-1] ==\
    \ paren_stack[paren_stack.size()-2]) {\n                paren_stack[paren_stack.size()-1]\
    \ = 0;\n            }\n        } else {\n            paren_stack[i] = paren_stack.size()\
    \ - 1;\n        }\n    }\n    result.push_back(paren_string.size());\n    for(size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        if(paren_string[i] == '(') {\n\
    \            // If there is a closing parenthesis at the current level,\n    \
    \        // add it to the stack. Otherwise, if there is an opening parenthesis,\n\
    \            // add it to the stack and add the level of nesting to the current\
    \ result.\n            if(paren_stack[i] != paren_stack.size()-1) {\n        \
    \        result.push_back(i);\n            }\n        } else if(paren_string[i]\
    \ == ')') {\n            // If the current level has a closing parenthesis,\n\
    \            // remove the closing parenthesis from the stack.\n            if(paren_stack[paren_stack.size()-1]\
    \ != 0) {\n                result.push_back(paren_stack[paren_stack.size()-1]);\n\
    \                paren_stack[paren_stack.size()-1] = 0;\n            }\n     \
    \   } else {\n            // If the current level has an opening parenthesis,\n\
    \            // add the level of nesting to the current result.\n            result.push_back(paren_stack[paren_stack.size()-1]);\n\
    \            paren_stack[paren_stack.size()-1]++;\n        }\n    }\n    return\
    \ result;", "  // We need to track how many parentheses we've seen, as well as\
    \ how many levels of parentheses there are\n  long num_paren = 0;\n  long num_level\
    \ = 0;\n  std::vector<long> result;\n  while(std::find_if(paren_string.begin(),\
    \ paren_string.end(), [](char c){return c == '(';}) != paren_string.end()) {\n\
    \    char c = *paren_string.find_first_of(\")\");\n    if(paren_string[paren_string.end()\
    \ - 1] == '(') {\n      ++num_level;\n    }\n    else {\n      num_level--;\n\
    \    }\n    if(num_level == 0) {\n      result.push_back(num_paren);\n      num_paren\
    \ = 0;\n    }\n    ++num_paren;\n    ++paren_string;\n  }\n  assert(num_paren\
    \ == 0);\n  assert(num_level == 0);\n  return result;", "  // Scan for the first\
    \ set of parentheses and store the number of nesting levels.\n  size_t num_opening_parens\
    \ = paren_string.find('(');\n  std::vector<long> nesting_levels;\n  nesting_levels.push_back(num_opening_parens);\
    \ // Assume that every set of parentheses has at least one level of nesting.\n\
    \  for (size_t i = 1; i < paren_string.size(); i++) {\n    if (paren_string[i\
    \ - 1] == '(') {\n      nesting_levels.push_back(nesting_levels.back() + 1); //\
    \ Each level of nesting after the first is incremented by one.\n    } else {\n\
    \      nesting_levels.back() = nesting_levels.back() - 1;\n    }\n  }\n\n  //\
    \ Now that all the parentheses have been scanned, traverse the string and count\
    \ the levels of parentheses.\n  long max_level = 0;\n  for (size_t i = 0; i <\
    \ paren_string.size(); i++) {\n    if (paren_string[i] == '(') {\n      max_level\
    \ = std::max(max_level, nesting_levels[i]); // Keep track of the maximum level\
    \ of nesting.\n    }\n  }\n\n  // Now the maximum level of nesting can be determined,\
    \ so calculate the result.\n  std::vector<long> result(max_level);\n  for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n    if (paren_string[i] == '(') {\n\
    \      result[nesting_levels[i] - 1]++;\n    } else {\n      result[nesting_levels[i]]--;\n\
    \    }\n  }\n\n  return result;", "    long highest_level = 0;\n    std::vector<long>\
    \ paren_level;\n    for (auto ch : paren_string) {\n        if (ch == '(') highest_level++;\n\
    \        else if (ch == ')') highest_level--;\n        paren_level.push_back(highest_level);\n\
    \    }\n    return paren_level;", "    std::vector<long> depths;\n    long temp_depth\
    \ = 0;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it)\
    \ {\n        if ((*it == '(') && (*( it + 1 ) == '(')) {\n            temp_depth++;\n\
    \        } else {\n            temp_depth--;\n            if (temp_depth == 0)\
    \ {\n                depths.push_back(temp_depth);\n            }\n        }\n\
    \    }\n    return depths;", "    std::vector<long> paren_level;\n    paren_level.push_back(0);\n\
    \    size_t paren_start = 0;\n    size_t paren_count = 0;\n    for (size_t i =\
    \ 0; i < paren_string.size(); ++i) {\n        if (paren_string[i] == ')') {\n\
    \            paren_count--;\n        }\n        if (paren_string[i] == '(') {\n\
    \            paren_count++;\n        }\n        if (paren_count == 0) {\n    \
    \        paren_level.push_back(paren_start - paren_count);\n        }\n      \
    \  if (paren_count == 1 && paren_string[i] == '(') {\n            paren_start\
    \ = i + 1;\n        }\n    }\n    return paren_level;", "    std::vector<long>\
    \ results;\n    auto it = paren_string.begin();\n    for ( ; !is_end(paren_string,\
    \ it); ++it) {\n        if (*it == '(') {\n            ++it;\n            for\
    \ ( ; !is_end(paren_string, it); ++it) {\n                if (*it == ')') {\n\
    \                    results.emplace_back(std::distance(paren_string.begin(),\
    \ it));\n                    break;\n                }\n            }\n      \
    \  }\n        else if (*it == ')') {\n            results.emplace_back(std::distance(paren_string.begin(),\
    \ it));\n            break;\n        }\n    }\n    return results;", "    int\
    \ open = 1;\n    int depth = 0;\n    std::vector<long> result;\n    while (open\
    \ != -1) {\n        std::vector<long> temp;\n        for (auto &c : paren_string)\
    \ {\n            if (c == '(') {\n                depth++;\n                result.push_back(depth);\n\
    \                temp.push_back(depth);\n            }\n            if (c == '(')\
    \ {\n                depth++;\n                temp.push_back(depth);\n      \
    \      }\n            if (c == ')') {\n                depth--;\n            \
    \    temp.push_back(depth);\n                if (depth <= 0) {\n             \
    \       open--;\n                }\n            }\n            if (c == ')') {\n\
    \                depth--;\n                temp.push_back(depth);\n          \
    \  }\n        }\n        paren_string = std::move(temp);\n    }\n    return result;",
  "  std::vector<long> paren_levels(paren_string.size(), 0);\n  std::vector<long>::iterator\
    \ iter;\n  iter = paren_string.begin();\n  while (iter != paren_string.end())\
    \ {\n    bool found = false;\n    iter = paren_string.begin();\n    while (iter\
    \ != paren_string.end() && !found && (*iter == *iter)) {\n      iter++;\n    \
    \  found = true;\n    }\n    if (found) {\n      std::vector<long> new_paren_levels(iter\
    \ + 1, 0);\n      std::size_t i = paren_levels.size() - 1;\n      while (i !=\
    \ paren_levels.size() - 1) {\n        new_paren_levels[i] = paren_levels[i + 1];\n\
    \        std::swap(paren_levels[i], paren_levels[i + 1]);\n        std::swap(paren_levels[i\
    \ + 1], new_paren_levels[i + 1]);\n        std::swap(paren_levels[paren_levels.size()\
    \ - 1], new_paren_levels[paren_levels.size() - 1]);\n        std::swap(paren_levels[paren_levels.size()\
    \ - 2], paren_levels[paren_levels.size() - 1]);\n        i--;\n      }\n     \
    \ paren_levels = new_paren_levels;\n    } else {\n      iter++;\n    }\n  }\n\
    \  return paren_levels;", "    std::vector<long> result;\n    result.push_back(1);\n\
    \    long cur_depth = 1;\n    std::string::size_type pos_start = 0;\n    std::string::size_type\
    \ pos_end = 0;\n\n    // Iterate over each symbol in the parenthesis string.\n\
    \    // If the symbol is a left parenthesis, increment the depth of nesting.\n\
    \    // If the symbol is a right parenthesis, decrement the depth of nesting.\n\
    \    // If the symbol is a space, ignore it.\n    // If the symbol is \"()\",\
    \ push an empty string to our vector and update the current depth.\n    // If\
    \ the symbol is \")\", pop off the empty string from the vector and update the\
    \ current depth.\n    while (pos_end != paren_string.size()) {\n        pos_start\
    \ = pos_end;\n        pos_end = paren_string.find(' ', pos_start + 1);\n     \
    \   // If we have a left parenthesis and a right parenthesis, increment the depth.\n\
    \        if (paren_string[pos_start] == '(' && paren_string[pos_end - 1] == ')')\
    \ {\n            cur_depth++;\n        // If we have a left parenthesis and a\
    \ space, decrement the depth.\n        } else if (paren_string[pos_start] == '('\
    \ && paren_string[pos_end] != ' ') {\n            cur_depth--;\n        // If\
    \ we have a right parenthesis and a space, increment the depth.\n        } else\
    \ if (paren_string[pos_end] == ')' && paren_string[pos_end - 1] != ' ') {\n  \
    \          cur_depth++;\n        // If we have a space, we ignore it.\n      \
    \  } else if (paren_string[pos_end] == ' ') {\n            pos_end++;\n      \
    \  // If we are at the end of the string, break.\n        } else if (paren_string[pos_end]\
    \ == '\\0') {\n            break;\n        }\n        // Push the depth to our\
    \ vector.\n        result.push_back(cur_depth);\n    }\n\n    return result;",
  "    std::vector<long> max_levels_of_nesting;\n    std::stack<int> paren_nesting_level;\n\
    \    long paren_nesting_level_size = 0;\n    for (char c : paren_string) {\n \
    \       if (c == ')') {\n            if (paren_nesting_level.empty()) {\n    \
    \            assert(false);\n            }\n            paren_nesting_level_size--;\n\
    \            if (paren_nesting_level_size == 0) {\n                max_levels_of_nesting.push_back(paren_nesting_level.top());\n\
    \                paren_nesting_level.pop();\n            }\n        } else if\
    \ (c == ')') {\n            paren_nesting_level.push(c);\n            paren_nesting_level_size++;\n\
    \        } else {\n            assert(false);\n        }\n    }\n    return max_levels_of_nesting;",
  "    // This hash maps strings to arrays of ints representing\n    // how deep in\
    \ nesting each string is at.\n    std::unordered_map<std::string, std::vector<int>>\
    \ paren_depth;\n    paren_depth[\"((\")\"].push_back(0);\n    paren_depth[\")(\"\
    ].push_back(0);\n    paren_depth[\")\"][0].push_back(0);\n    size_t nesting_level\
    \ = 0;\n    std::vector<long> nesting_level_values;\n    for (auto &c : paren_string)\
    \ {\n        if (paren_depth.find(c) == paren_depth.end()) {\n            // New\
    \ string and it's first character isn't a paren so keep counting parens at level\
    \ 0\n            paren_depth.insert({c, std::vector<int>()});\n        }\n   \
    \     size_t paren_depth_of_interest = paren_depth.find(c)->second.size();\n \
    \       if (nesting_level + paren_depth_of_interest > nesting_level) {\n     \
    \       // The string is not nested at all so push it at level 0\n           \
    \ nesting_level_values.push_back(nesting_level);\n        } else {\n         \
    \   // The string is nested at some level so push it at level after the last paren\n\
    \            nesting_level_values.push_back(nesting_level + paren_depth_of_interest);\n\
    \        }\n        nesting_level = nesting_level + paren_depth_of_interest;\n\
    \    }\n    return nesting_level_values;", "  // Convert parenthesis into array\
    \ of strings.\n  std::vector<std::string> paren_groups;\n  std::string current_group;\n\
    \  size_t current_group_len = 0;\n  for (size_t i = 0; i < paren_string.length();\
    \ ++i) {\n    if (paren_string[i] == '(') {\n      current_group.push_back(paren_string[i]);\n\
    \      current_group_len++;\n    } else if (paren_string[i] == ')') {\n      //\
    \ If current group is not empty, then add it to current group and start a new\
    \ group.\n      if (current_group != \"\") {\n        paren_groups.push_back(std::move(current_group));\n\
    \        current_group.clear();\n        current_group_len = 0;\n      }\n   \
    \ } else if (paren_string[i] == ',') {\n      // If current group is empty and\
    \ end of a group, add it to current group and start a new one.\n      if (current_group\
    \ == \"\" && current_group_len > 0) {\n        paren_groups.push_back(std::move(current_group));\n\
    \        current_group.clear();\n        current_group_len = 0;\n      }\n   \
    \ } else {\n      current_group.push_back(paren_string[i]);\n      current_group_len++;\n\
    \    }\n  }\n  // Add final group to final group.\n  if (current_group != \"\"\
    ) {\n    paren_groups.push_back(std::move(current_group));\n  }\n\n  // Compute\
    \ max depth of nested parentheses.\n  int max_depth = 0;\n  for (size_t i = 0;\
    \ i < paren_groups.size(); ++i) {\n    max_depth = (std::max(max_depth, paren_groups[i].size()));\n\
    \  }\n\n  // Return max depth and nested parentheses.\n  return {max_depth, std::vector<long>(paren_groups.size(),\
    \ 0)};", "  std::vector<long> res;\n  long current_level = 0;\n  int index = 0;\n\
    \  bool inside_first_paren = false;\n\n  for (char c : paren_string) {\n    if\
    \ (c == '(') inside_first_paren = true;\n    if (c == '(' && inside_first_paren\
    \ == true) current_level++;\n    else if (c == ')' && inside_first_paren == true)\
    \ {\n      if (current_level == 0) res.push_back(index);\n      current_level--;\n\
    \    }\n    index = index;\n  }\n  return res;", "    // Your code here\n    //\
    \ Complete the code here\n    std::vector<long> result;\n    std::string opening_paren\
    \ = \"(\";\n    std::string closing_paren = \")\";\n    std::string opn = \"()\"\
    ;\n    std::string cnl = \"()\";\n\n    for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n        if (paren_string[i] == opening_paren) {\n            int counter\
    \ = 0;\n            while (i < paren_string.size() && paren_string[i] != closing_paren)\
    \ {\n                i++;\n                counter++;\n            }\n       \
    \     result.push_back(counter);\n        }\n        if (paren_string[i] == closing_paren)\
    \ {\n            int counter = 0;\n            while (i < paren_string.size()\
    \ && paren_string[i] != opening_paren) {\n                i++;\n             \
    \   counter++;\n            }\n            result.push_back(counter);\n      \
    \  }\n        if (paren_string[i] == opn) {\n            int counter = 0;\n  \
    \          while (i < paren_string.size() && paren_string[i] != cnl) {\n     \
    \           i++;\n                counter++;\n            }\n            result.push_back(counter);\n\
    \        }\n        if (paren_string[i] == cnl) {\n            int counter = 0;\n\
    \            while (i < paren_string.size() && paren_string[i] != opn) {\n   \
    \             i++;\n                counter++;\n            }\n            result.push_back(counter);\n\
    \        }\n    }\n    return result;", "\tstd::vector<long> paren_levels;\n\t\
    std::string temp = \"\";\n\tbool is_open = false;\n\tbool is_nested = false;\n\
    \tfor (char c : paren_string) {\n\t\tif (c == '(') {\n\t\t\tif (!is_nested) {\n\
    \t\t\t\tparen_levels.push_back(0);\n\t\t\t\tis_nested = true;\n\t\t\t\tis_open\
    \ = true;\n\t\t\t}\n\t\t\tparen_levels.back()++;\n\t\t} else if (c == ')') {\n\
    \t\t\tparen_levels.back()--;\n\t\t\tis_nested = false;\n\t\t\tis_open = false;\n\
    \t\t\ttemp += c;\n\t\t} else if (is_open && (c == ' ' || c == '\\n' || c == '\\\
    t')) {\n\t\t\tis_open = false;\n\t\t\ttemp += c;\n\t\t}\n\t}\n\tif (is_nested)\
    \ {\n\t\tthrow std::runtime_error(\"Error: nested parenthesis unbalanced.\");\n\
    \t}\n\treturn paren_levels;", "  std::vector<long> max_levels;\n  // We keep track\
    \ of the number of opening parentheses encountered in the string\n  long opening_count\
    \ = 0;\n  // We keep track of the number of closing parentheses encountered in\
    \ the string\n  long closing_count = 0;\n  for (char c : paren_string)\n    if\
    \ (c == '(') opening_count++;\n    else if (c == ')') closing_count++;\n    else\
    \ if (opening_count > closing_count) max_levels.push_back(opening_count - 1);\n\
    \    else if (opening_count == closing_count) max_levels.push_back(opening_count\
    \ - 1);\n  return max_levels;", "    // Store all the nested level of nesting\
    \ for each parentheses.\n    std::vector<long> nesting_level;\n    long level\
    \ = 0;\n    // Each new parentheses group starts with level zero.\n    nesting_level.push_back(level);\n\
    \n    for (auto paren = paren_string.rbegin(); paren != paren_string.rend(); ++paren)\
    \ {\n        // Add 1 if the current parentheses group matches the nested parentheses.\n\
    \        if (*paren == ' ') {\n            nesting_level.push_back(level + 1);\n\
    \        } else if (*paren == ')') {\n            ++level;\n        }\n    }\n\
    \    return nesting_level;", "    std::string opening_parens = \"(\";\n    std::string\
    \ closing_parens = \")\";\n    std::string opening_parens_count = paren_string;\n\
    \    int opening_parens_index_of_closing_parens = 0;\n    std::string curr_open_parens;\n\
    \    std::vector<long> result;\n    while (opening_parens_index_of_closing_parens\
    \ != std::string::npos) {\n        opening_parens_index_of_closing_parens = opening_parens_count.find(closing_parens,\
    \ opening_parens_index_of_closing_parens + 1);\n        curr_open_parens = opening_parens.substr(0,\
    \ opening_parens_index_of_closing_parens);\n        result.push_back(stoi(curr_open_parens));\n\
    \        opening_parens_count = opening_parens.substr(opening_parens_index_of_closing_parens\
    \ + closing_parens.size(), opening_parens_count.length());\n    }\n    return\
    \ result;", "    // Recursive function to parse string\n    std::vector<long>\
    \ levels;\n    if (paren_string.size() == 1) {\n        levels.push_back(1);\n\
    \        return levels;\n    }\n    std::string left_paren, right_paren;\n   \
    \ std::string temp_str = paren_string;\n    std::size_t left_paren_index = paren_string.find(\"\
    (\"), right_paren_index;\n    // Remove left paren\n    temp_str = temp_str.substr(left_paren_index);\n\
    \    left_paren = temp_str.substr(0, left_paren_index);\n    temp_str = temp_str.substr(left_paren_index\
    \ + 1);\n    // Remove right paren\n    temp_str = temp_str.substr(0, right_paren_index\
    \ = temp_str.find(')'));\n    right_paren = temp_str.substr(right_paren_index\
    \ + 1);\n    std::size_t left_count = parse_nested_parens(left_paren).size();\n\
    \    std::size_t right_count = parse_nested_parens(right_paren).size();\n    if\
    \ (left_paren != right_paren) {\n        levels.push_back(left_count + right_count);\n\
    \        temp_str = temp_str.substr(left_paren_index);\n    }\n    levels.push_back(left_count\
    \ + right_count);\n    temp_str = temp_str.substr(left_paren_index + 1);\n   \
    \ while (temp_str.size() > 0) {\n        auto count = temp_str.find('(');\n  \
    \      if (count != std::string::npos) {\n            temp_str.erase(count, 1);\n\
    \        } else {\n            break;\n        }\n    }\n    if (temp_str.size()\
    \ > 0) {\n        levels.push_back(std::stoi(temp_str));\n    }\n    return levels;",
  "    std::vector<long> parens_level;\n    auto it = paren_string.begin();\n    long\
    \ parens_level_count = 1;\n    while (it != paren_string.end()) {\n        //\
    \ Check if first character is opening and next character is closing parenthesis.\n\
    \        if (*it == '(' && parens_level_count == 0) {\n            parens_level_count++;\n\
    \        } else if (*it == ')') {\n            if (parens_level_count == 0) {\n\
    \                throw std::invalid_argument(\"Input to this function needs to\
    \ be a single group of parenthesis\");\n            }\n            parens_level_count--;\n\
    \        }\n        it++;\n    }\n    parens_level.assign(parens_level_count,\
    \ 0);\n    return parens_level;", "    // Find the first open parenthesis\n  \
    \  size_t start_paren = paren_string.find_first_of(\"(\");\n    // If no open\
    \ parenthesis found, return empty vector\n    if (start_paren == std::string::npos)\
    \ return std::vector<long>();\n    // Find the first closed parenthesis\n    size_t\
    \ end_paren = paren_string.find_first_of(\")\");\n    // If no closed parenthesis\
    \ found, return empty vector\n    if (end_paren == std::string::npos) return std::vector<long>();\n\
    \    // If no closed parenthesis found after the first open parenthesis, return\
    \ empty vector\n    if (end_paren < start_paren) return std::vector<long>();\n\
    \    // Find the index of the closing parenthesis\n    size_t parens_size = end_paren\
    \ - start_paren;\n    // If no closed parenthesis found after the first open parenthesis,\
    \ return empty vector\n    if (parens_size <= 0) return std::vector<long>();\n\
    \    // Create a vector that stores the index of each open parenthesis group\n\
    \    std::vector<long> paren_indexes(parens_size + 1);\n    // Find the index\
    \ of the corresponding open parenthesis group\n    size_t paren_index = 0;\n \
    \   paren_indexes[0] = paren_index;\n    for (size_t i = 1; i < paren_indexes.size();\
    \ i++) {\n        if (paren_string[paren_index] == '(') {\n            paren_indexes[i]\
    \ = paren_index;\n        }\n        if (paren_string[paren_index] == ')') {\n\
    \            paren_indexes[i] = paren_index;\n            paren_index++;\n   \
    \     }\n    }\n    // Find the deepest nesting level among all the group\n  \
    \  long deepest_level = 0;\n    for (size_t i = 0; i < paren_indexes.size(); i++)\
    \ {\n        long current_level = paren_indexes[i] - paren_indexes[paren_indexes[i]\
    \ + 1];\n        deepest_level = std::max(deepest_level, current_level);\n   \
    \ }\n    // Return the deepest level of nesting\n    return std::vector<long>({deepest_level});",
  "  std::vector<long> paren_levels;\n  std::stringstream ss(paren_string);\n  std::string\
    \ token;\n  long level = 0;\n  while (std::getline(ss, token, ' ')) {\n    if\
    \ (level == 0) {\n      paren_levels.push_back(level);\n      level++;\n    }\n\
    \    if (level == 1) {\n      level++;\n    }\n  }\n  return paren_levels;", " \
    \   int level = 0;\n    std::vector<long> max_level;\n    std::vector<long> parenthesis_level;\n\
    \    std::vector<char> parenthesis;\n    for (char ch: paren_string) {\n     \
    \   if (ch == '(') level++;\n        else if (ch == ')') level--;\n        if\
    \ (level == 0 && !parenthesis.empty()) {\n            parenthesis_level.push_back(parenthesis.size());\n\
    \            if (parenthesis.size() > max_level.back()) max_level.push_back(parenthesis.size());\n\
    \        }\n        parenthesis.push_back(ch);\n    }\n    if (parenthesis.size()\
    \ == 0) return max_level;\n    std::vector<long> ans;\n    for (size_t i = 0;\
    \ i < max_level.size(); i++) {\n        if (parenthesis_level[i] < ans.size())\
    \ ans.resize(parenthesis_level[i]);\n        if (ans.back() >= max_level[i]) ans.resize(max_level[i]);\n\
    \    }\n    return ans;", "    std::vector<long> levels;\n    levels.push_back(0);\n\
    \    std::vector<bool> opened;\n    opened.push_back(false);\n    opened.push_back(true);\
    \ // add level to levels array initially\n    int max_depth = 0;\n    for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(' &&\
    \ opened[i]) {\n            opened.erase(std::find(opened.begin(), opened.end(),\
    \ true));\n            levels[levels.size() - 1] = levels.size();\n          \
    \  opened.push_back(true);\n        } else if (paren_string[i] == ')' && opened[i])\
    \ {\n            opened.erase(std::find(opened.begin(), opened.end(), true));\n\
    \            if (max_depth > levels[levels.size() - 1])\n                max_depth\
    \ = levels[levels.size() - 1];\n            opened.push_back(false);\n       \
    \ } else {\n            opened.push_back(false);\n        }\n    }\n    levels.erase(std::find(levels.begin(),\
    \ levels.end(), max_depth));\n    return levels;", "  std::vector<long> paren_nesting_levels;\n\
    \  std::stack<long> paren_nesting_levels_stack;\n  long level_counter = 1;\n \
    \ for (auto it = paren_string.begin(); it != paren_string.end(); it++) {\n   \
    \ if (*it == ' ') {\n      long paren_nesting_level = level_counter;\n      while\
    \ (level_counter != paren_nesting_level) {\n        paren_nesting_levels_stack.push(level_counter);\n\
    \        level_counter++;\n      }\n      paren_nesting_levels_stack.push(level_counter);\n\
    \      level_counter++;\n    } else {\n      level_counter++;\n    }\n  }\n  paren_nesting_levels.push_back(level_counter\
    \ - 1);\n  while (!paren_nesting_levels_stack.empty()) {\n    long paren_nesting_level\
    \ = paren_nesting_levels_stack.top();\n    paren_nesting_levels_stack.pop();\n\
    \    paren_nesting_levels.push_back(paren_nesting_level);\n  }\n  return paren_nesting_levels;",
  "    std::stack<long> s;\n    std::vector<long> nestings;\n    for (char c : paren_string)\
    \ {\n        if (c == '(')\n            s.push((long) s.size());\n        else\
    \ if (c == ')')\n            while (s.size() != s.pop())\n                nestings.push_back(s.size());\n\
    \    }\n    return nestings;", "    // Write your code here.\n    // For each\
    \ character\n    std::vector<std::string> paren_list;\n    int level = 1;\n  \
    \  for (int i = 0; i < paren_string.length(); i++) {\n        // if the character\
    \ is a parenthesis\n        if (paren_string[i] == '(') {\n            // increment\
    \ the level\n            level++;\n            // append the level to the paren_list\
    \ vector\n            paren_list.push_back(level);\n        } else if (paren_string[i]\
    \ == ')') {\n            // decrement the level\n            level--;\n      \
    \      // append the level to the paren_list vector\n            paren_list.push_back(level);\n\
    \        }\n    }\n\n    // Sort the vector from top to bottom\n    std::sort(paren_list.begin(),\
    \ paren_list.end(), std::greater<>());\n\n    std::vector<long> level_list;\n\
    \    long max_level = paren_list[0];\n\n    // Append the max_level to level_list\
    \ vector\n    level_list.push_back(max_level);\n\n    // While the level list\
    \ has elements greater than max_level\n    while (level_list.size() > 0 && max_level\
    \ > 0) {\n        // Get the max level\n        max_level = level_list.back();\n\
    \n        // Remove the first element from the list if the level is less than\
    \ max_level\n        if (level_list.front() <= max_level) {\n            level_list.pop_back();\n\
    \        }\n\n        // Increment the next level\n        level_list.push_back(level_list.back()\
    \ + 1);\n    }\n\n    return level_list;", "  std::vector<long> result;\n  //\
    \ Traverse string from right to left\n  size_t index = 0;\n  size_t paren_index\
    \ = paren_string.length();\n  for (size_t i = paren_index; i > 0; --i) {\n   \
    \ if (paren_string[i] == '(') {\n      index++;\n    } else if (paren_string[i]\
    \ == ')') {\n      index--;\n    }\n    if (index == 0) {\n      // We have reached\
    \ a level where there are no more parentheses\n      // E.g. \"()()\" has 1 level\
    \ of nesting while \"(()\" has none.\n      result.push_back(paren_index);\n \
    \   }\n  }\n  return result;", "    std::vector<long> max_level;\n    std::vector<long>\
    \ level;\n    std::vector<long> level_count;\n    std::vector<long> stack_of_parentheses_count;\n\
    \n    // Initialize the max level to 0 as there is one level of nesting for each\
    \ bracket.\n    max_level.push_back(0);\n    // Initialize the level array and\
    \ level-count array to 1 for every bracket.\n    level.push_back(1);\n    level_count.push_back(0);\n\
    \n    // Iterate over each character of the string and increment the level-count\
    \ for every opening bracket.\n    for(char c: paren_string) {\n        if(c ==\
    \ '(') {\n            level_count.push_back(1); // level_count[level_count[level-1]\
    \ inc. for every opening bracket.\n        }\n        else if(level_count.back()\
    \ == 1) {\n            level.push_back(level_count.back());\n            level_count.pop_back();\n\
    \        }\n        else {\n            int level_diff = level_count.back() -\
    \ 1;\n            int level_level_diff = level[level_diff] - level[level_diff\
    \ - 1];\n            if(level_level_diff > 0) {\n                stack_of_parentheses_count.push_back(level_level_diff);\n\
    \            }\n            level_count.pop_back();\n            level[level_diff]\
    \ += 1;\n        }\n    }\n\n    // Iterate over each level and decrement the\
    \ level-count for every closing bracket.\n    for(size_t i = level_count.size()\
    \ - 1; i >= 0; i--) {\n        if(level_count.at(i) == 0) {\n            max_level.push_back(level.at(i));\n\
    \        }\n        level[level.size() - 1 - i] += 1;\n    }\n\n    return max_level;",
  "    std::vector<long> level;\n    level.push_back(0);\n    // This function finds\
    \ the deepest level of nesting for the given string.\n    std::string curr_parens\
    \ = paren_string;\n    while (curr_parens != \"()\") {\n        auto it = curr_parens.find(\"\
    (\", 0);\n        if (it != curr_parens.npos)\n            curr_parens.erase(it,\
    \ 1);\n        auto it = curr_parens.find(\")\", 0);\n        if (it != curr_parens.npos)\n\
    \            curr_parens.erase(it, 1);\n        level.push_back(level.size());\n\
    \        curr_parens = paren_string;\n    }\n    return level;", "    std::vector<long>\
    \ output_nesting;\n    output_nesting.push_back(0);\n    for (size_t i = 1; i\
    \ < paren_string.size(); ++i) {\n        size_t paren_start_pos = paren_string.find_first_of('\
    \ ', i); // find first space\n        size_t paren_end_pos = paren_string.find_first_of('(',\
    \ i); // find first open parenthesis\n        std::string current_paren_string\
    \ = paren_string.substr(i, paren_end_pos - i); // remove leading spaces and opening\
    \ parenthesis\n        bool has_open_paren = paren_start_pos != std::string::npos;\n\
    \        bool has_close_paren = current_paren_string.find_first_of(')') != std::string::npos;\n\
    \        if (has_open_paren && has_close_paren) {\n            output_nesting.push_back(0);\n\
    \            output_nesting.back() += output_nesting[output_nesting.size() - 1]\
    \ + 1; // push the deepest nesting level\n            output_nesting.back() +=\
    \ parse_nested_parens(current_paren_string).back();\n        } else if (has_open_paren)\
    \ {\n            output_nesting.push_back(0);\n            output_nesting.back()\
    \ += output_nesting[output_nesting.size() - 1] + 1; // push the deepest nesting\
    \ level\n        } else if (has_close_paren) {\n            output_nesting.back()\
    \ += parse_nested_parens(current_paren_string).back();\n        }\n        i =\
    \ paren_end_pos + 1; // increase the starting position of the next loop\n    }\n\
    \    return output_nesting;", "  std::vector<long> result;\n  long prev_level\
    \ = 0;\n  long level = 0;\n  bool prev_is_empty = true;\n  for (char ch : paren_string)\
    \ {\n    // If the previous character was a parantheses and the current character\
    \ is not, then we increment the level\n    if (prev_is_empty) {\n      level++;\n\
    \      // If the level is not yet less than the previous level, then we output\
    \ the level\n      if (level > prev_level) {\n        result.push_back(level);\n\
    \      }\n    }\n    // If the current character is a parantheses, then we increase\
    \ the level\n    if (ch == '(') {\n      level++;\n      // If the level is still\
    \ greater than the previous level, then we output the level\n      if (level >\
    \ prev_level) {\n        result.push_back(level);\n      }\n    }\n    // If the\
    \ current character is a closing parantheses, then we decrease the level\n   \
    \ if (ch == ')') {\n      level--;\n      // If the level is less than the previous\
    \ level, then we output the level\n      if (level < prev_level) {\n        result.push_back(level);\n\
    \      }\n    }\n    // If the current character is a space, we can output a 0\n\
    \    if (ch == ' ') {\n      result.push_back(0);\n    }\n    // If the current\
    \ character is not a space, we can output the previous level\n    prev_level =\
    \ level;\n    prev_is_empty = ch == ' ' || ch == ')';\n  }\n  return result;",
  "    long max_level = 0;\n    std::vector<long> parens_level;\n    for (size_t i\
    \ = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n\
    \            parens_level.push_back(max_level + 1);\n        } else if (paren_string[i]\
    \ == ')') {\n            auto prev = std::find(parens_level.begin(), parens_level.end(),\
    \ max_level);\n            if (prev != parens_level.end()) {\n               \
    \ max_level = *prev;\n                parens_level.pop_back();\n            }\
    \ else {\n                return std::vector<long>();\n            }\n       \
    \ }\n    }\n    parens_level.push_back(max_level + 1);\n    return parens_level;",
  "  std::vector<long> result_vec(paren_string.size(), 0);\n  bool isOpenBracket =\
    \ false;\n  for (int i = 0; i < (int) paren_string.size(); i++) {\n    if (paren_string[i]\
    \ == '(') {\n      isOpenBracket = true;\n      result_vec[i] = 0;\n    } else\
    \ if (paren_string[i] == ')') {\n      isOpenBracket = false;\n      result_vec[i]\
    \ = 1;\n    } else {\n      if (!isOpenBracket) {\n        result_vec[i]++;\n\
    \      }\n    }\n  }\n  return result_vec;", "  std::vector<long> paren_nesting_level;\n\
    \  if (paren_string.size() == 0) return paren_nesting_level;\n  std::string paren_opening_parens\
    \ = \"((\";\n  std::string paren_closing_parens = \")\";\n  std::string opening_paren_count\
    \ = paren_opening_parens;\n  std::string closing_paren_count = paren_closing_parens;\n\
    \  for (int i = 0; i < paren_string.size(); i++) {\n    if (paren_string[i] ==\
    \ paren_opening_parens) opening_paren_count += 1;\n    else if (paren_string[i]\
    \ == paren_closing_parens) closing_paren_count += 1;\n    else if (opening_paren_count\
    \ == closing_paren_count) {\n      paren_nesting_level.push_back(opening_paren_count);\n\
    \      opening_paren_count = paren_opening_parens;\n      closing_paren_count\
    \ = paren_closing_parens;\n    } else {\n      opening_paren_count = paren_opening_parens;\n\
    \      closing_paren_count = paren_closing_parens;\n    }\n  }\n  return paren_nesting_level;",
  "    std::vector<long> levels;\n    // Iterate over input string one character at\
    \ a time.\n    // If the current character is open parenthesis, push its nesting\
    \ level to the vector.\n    // If the current character is close parenthesis,\
    \ pop the previous nesting level from the vector.\n    // If the current character\
    \ is a closing brace, add it to the vector and continue.\n    for (auto c : paren_string)\
    \ {\n        if (c == '(')\n            levels.push_back(1);\n        else if\
    \ (c == ')')\n            levels.pop_back();\n        else if (c == '{')\n   \
    \         levels.push_back(levels.size());\n        else if (c == '}')\n     \
    \       levels.push_back(levels.size() - 1);\n        else\n            assert(false);\n\
    \    }\n    return levels;", "    std::vector<long> ans;\n    long cur = 0;\n\
    \    // Iterate over input string\n    for (auto c: paren_string) {\n        //\
    \ If current character is an opening parenthesis\n        if (c == '(') {\n  \
    \          // If there is already a parentheses group\n            if (cur !=\
    \ 0) {\n                // Add current level of nesting to total nest level\n\
    \                ans.push_back(cur);\n            }\n            // Mark current\
    \ level of nesting\n            cur++;\n        }\n        // If current character\
    \ is a closing parenthesis\n        else if (c == ')') {\n            // If there\
    \ is a current level of nesting\n            if (cur != 0) {\n               \
    \ // Add current level of nesting to total nest level\n                ans.push_back(cur);\n\
    \                // Mark current level of nesting as 0\n                cur--;\n\
    \            }\n            // Else, ignore closing parenthesis\n            else\
    \ {\n                // Just ignore closing parenthesis\n            }\n     \
    \   }\n        // Else, ignore characters\n        else {\n            // Just\
    \ ignore characters\n        }\n    }\n    return ans;", "    std::vector<long>\
    \ results;\n    std::string s = paren_string;\n    while (s.size() != 0) {\n \
    \       bool found = false;\n        for (auto &c: s) {\n            found = found\
    \ || (c == '(' || c == '{' || c == '}');\n            if (found && c == '(') results.push_back(s.size());\n\
    \            if (c == '(') found = true;\n        }\n        s = s.substr(s.size()\
    \ - 1);\n    }\n    return results;", "    std::vector<long> result;\n    int\
    \ cnt = 0;\n    for (size_t i = 0; i < paren_string.size(); ++i) {\n        if\
    \ (isspace(paren_string[i])) continue;\n        if (paren_string[i] == '(') {\n\
    \            ++cnt;\n        } else if (paren_string[i] == ')') {\n          \
    \  --cnt;\n        }\n        if (cnt > 0) {\n            result.emplace_back(cnt);\n\
    \        }\n    }\n    return result;", "    std::vector<long> levels;\n    auto\
    \ current_level = levels.size(); // starting from 0 because the first parentheses\
    \ is a \"(\"\n    auto next_parentheses = '('; // parentheses inside which parenthesis\
    \ will be balanced\n    for (auto character : paren_string) {\n        if (character\
    \ == '(') {\n            next_parentheses = '(';\n        } else if (character\
    \ == ')') {\n            next_parentheses = ')';\n        } else if (character\
    \ == ')' && next_parentheses == '(') {\n            current_level = levels[current_level\
    \ - 1]; // go up in level\n            next_parentheses = ')'; // go back to \"\
    )\" as we found a matching \"(\"\n            levels[current_level] = current_level;\
    \ // add new level for parenthesis\n        } else {\n            levels[current_level]\
    \ = next_parentheses; // just insert next parentheses\n        }\n    }\n    return\
    \ levels;", "    std::string token;\n    std::vector<long> nested_paren_level;\n\
    \    bool inside_paren = false;\n    bool nested_paren_found = false;\n    for\
    \ (auto &c: paren_string) {\n        bool is_space = (c == ' ');\n        if (is_space\
    \ && !inside_paren) {\n            nested_paren_found = false;\n        }\n  \
    \      if (c == '(') {\n            if (!inside_paren)\n                nested_paren_found\
    \ = true;\n        }\n        if (nested_paren_found) {\n            nested_paren_level.push_back(long(is_space\
    \ ? 1 : 0));\n        }\n        if (c == ')') {\n            nested_paren_level.push_back(long(is_space\
    \ ? 0 : 1));\n        }\n        inside_paren = !is_space;\n    }\n    return\
    \ nested_paren_level;", "  // To keep track of whether we are within parens\n\
    \  bool paren_level = false;\n  // To keep track of the number of opening parens\n\
    \  long open_parens = 0;\n  // To keep track of the current level of nesting of\
    \ parens\n  long cur_depth = 0;\n  // To store the output\n  std::vector<long>\
    \ output;\n  // Iterate over the string to process nested parens\n  for (int i\
    \ = 0; i < paren_string.size(); i++) {\n    if (paren_level) {\n      // If we\
    \ are currently inside parens then increment the level of nesting\n      cur_depth++;\n\
    \      if (paren_string[i] == '(') {\n        // If this character is a openning\
    \ paren then set paren_level to true\n        open_parens++;\n      } else if\
    \ (paren_string[i] == ')') {\n        // If this character is a closing paren\
    \ then decrement the level of nesting\n        open_parens--;\n        // If the\
    \ level of nesting is now zero then add it to the output\n        if (open_parens\
    \ == 0) {\n          output.push_back(cur_depth);\n        }\n      }\n    } else\
    \ {\n      // Else if we are not inside parens then increment the level of nesting\n\
    \      cur_depth++;\n      if (paren_string[i] == ')') {\n        output.push_back(cur_depth);\n\
    \        // Then set paren_level to false and continue the for loop\n        paren_level\
    \ = false;\n        open_parens--;\n      }\n    }\n  }\n  // If we are currently\
    \ inside parens then increment the level of nesting\n  if (open_parens) {\n  \
    \  output.push_back(cur_depth);\n  }\n  return output;", "  std::vector<long>\
    \ paren_nesting;\n  size_t paren_len = paren_string.size();\n  std::vector<char>\
    \ paren_nesting_chars;\n  paren_nesting_chars.reserve(paren_len);\n  long curr_level\
    \ = 1;\n  for (size_t i = 0; i < paren_len; ++i) {\n    if (paren_string[i] ==\
    \ '(') {\n      paren_nesting.push_back(curr_level);\n      curr_level++;\n  \
    \    paren_nesting_chars.push_back(paren_string[i]);\n    } else if (paren_string[i]\
    \ == ')') {\n      paren_nesting.push_back(curr_level);\n      curr_level--;\n\
    \      assert(curr_level >= 0);\n      paren_nesting_chars.push_back(paren_string[i]);\n\
    \    } else if (paren_string[i] == ' ') {\n      assert(curr_level >= 0);\n  \
    \    paren_nesting.push_back(curr_level);\n      curr_level--;\n      assert(curr_level\
    \ >= 0);\n      paren_nesting_chars.push_back(paren_string[i]);\n    }\n  }\n\
    \  return paren_nesting;", "    std::string temp = \"\";\n    std::vector<long>\
    \ temp_ret_val;\n    std::stack<std::string> stack_val;\n\n    for (const auto&\
    \ char : paren_string) {\n        if (char == '(' || char == ')')\n          \
    \  stack_val.push(char);\n        else\n            temp += char;\n\n        if\
    \ (stack_val.empty() || temp == \"\") {\n            temp_ret_val.push_back(temp.length());\n\
    \            temp = char;\n        } else {\n            while (!stack_val.empty())\
    \ {\n                long temp_idx = temp_ret_val.back();\n                long\
    \ parens_level = temp_ret_val.back();\n                temp_ret_val.pop_back();\n\
    \                if (stack_val.top() == \"(\")\n                    parens_level++;\n\
    \                else if (stack_val.top() == \")\")\n                    parens_level--;\n\
    \n                temp_ret_val.push_back(parens_level);\n                stack_val.pop();\n\
    \            }\n            temp += char;\n        }\n    }\n    return temp_ret_val;",
  "    std::vector<long> result;\n    auto paren_levels = {0}; // counts how many\
    \ nested parentheses in each level\n    bool seen_parentheses = false;\n    for\
    \ (auto p : paren_string) {\n        if (p == '(') {\n            paren_levels[0]++;\n\
    \            seen_parentheses = true;\n        } else if (p == ')') {\n      \
    \      paren_levels[paren_levels[0] - 1]++;\n            if (paren_levels[0] >\
    \ 1) {\n                result.push_back(paren_levels[0]);\n                paren_levels[0]\
    \ = 0;\n                seen_parentheses = false;\n            }\n        } else\
    \ if (seen_parentheses) {\n            paren_levels[paren_levels[0] - 1]++;\n\
    \        }\n    }\n    if (paren_levels[0] > 1) {\n        result.push_back(paren_levels[0]);\n\
    \    }\n    return result;", "  assert(!paren_string.empty());\n  // Create a\
    \ stack of level i.\n  std::stack<std::vector<long>> stack(paren_string.size());\n\
    \  // Push an empty vector onto stack at level i.\n  stack.push(std::vector<long>());\n\
    \  long level = 0;\n  while (!stack.empty()) {\n    // Pop an element from stack\
    \ at level i.\n    std::vector<long> popped_vec = stack.top();\n    stack.pop();\n\
    \    long popped_level = popped_vec.size();\n    // If the popped level is greater\
    \ than level i, then pop the last level (popped_level - 1).\n    if (popped_level\
    \ > level) {\n      level--;\n      // Append the popped level to stack.\n   \
    \   stack.push(popped_vec);\n      // Append the popped level to all previous\
    \ levels.\n      while (!stack.empty()) {\n        std::vector<long> level_vec\
    \ = stack.top();\n        stack.pop();\n        for (long i = 0; i < level_vec.size();\
    \ ++i) {\n          if (i != popped_level) {\n            level_vec.push_back(i\
    \ + 1);\n          }\n        }\n        stack.push(level_vec);\n      }\n   \
    \   // Pop an element from stack at level i.\n      std::vector<long> popped_vec\
    \ = stack.top();\n      stack.pop();\n    }\n    // If the popped level is less\
    \ than level i, then pop the next level (popped_level + 1).\n    else if (popped_level\
    \ < level) {\n      level++;\n      // Append the popped level to stack.\n   \
    \   stack.push(popped_vec);\n      // Append the popped level to all previous\
    \ levels.\n      while (!stack.empty()) {\n        std::vector<long> level_vec\
    \ = stack.top();\n        stack.pop();\n        for (long i = 0; i < level_vec.size();\
    \ ++i) {\n          if (i != popped_level) {\n            level_vec.push_back(i\
    \ + 1);\n          }\n        }\n        stack.push(level_vec);\n      }\n   \
    \ }\n  }\n  return stack;", "    // Your code goes here\n    int current_level\
    \ = 1;\n    std::vector<long> levels;\n    levels.push_back(1);\n    while (true)\
    \ {\n        // If the string is empty, there is nothing to parse\n        if\
    \ (paren_string.length() == 0) {\n            return levels;\n        }\n    \
    \    // If we are inside an opening parenthesis, increment our level\n       \
    \ if (paren_string[0] == '(') {\n            current_level++;\n            levels.push_back(current_level);\n\
    \        }\n        // If we are inside a closing parenthesis, decrement our level\n\
    \        if (paren_string[paren_string.length() - 1] == ')') {\n            if\
    \ (current_level > 0) {\n                current_level--;\n            }\n   \
    \         levels.push_back(current_level);\n        }\n        // If the current\
    \ level is less than the deepest level, \n        // then we know that this string\
    \ has nested parenthesis.\n        // Therefore, we will return the current level\n\
    \        if (current_level < levels.size() - 1) {\n            return levels;\n\
    \        }\n        // Otherwise, we will move to the next character in the string.\n\
    \        paren_string.erase(0, 1);\n        paren_string.erase(paren_string.length()\
    \ - 1);\n    }", "    std::vector<long> results;\n    int left_paren = paren_string.find_first_not_of(\"\
    ()\");\n    int right_paren = paren_string.find_last_not_of(\"()\");\n    if (left_paren\
    \ < right_paren) {\n        for (int i = left_paren + 1; i <= right_paren; i++)\
    \ {\n            // if there is a substring between left and right paren, count\
    \ the level of nesting.\n            // if there is no substring between left\
    \ and right paren, count the level of nesting.\n            if (paren_string[i]\
    \ == '(') {\n                int paren_count = 1;\n                for (int j\
    \ = i - 1; j >= 0; j--) {\n                    if (paren_string[j] == ')') paren_count++;\n\
    \                    else if (paren_string[j] == '(') paren_count--;\n       \
    \         }\n                results.push_back(paren_count);\n            }\n\
    \        }\n    }\n    return results;", "  // Your code here\n  assert(!paren_string.empty());\n\
    \  std::vector<long> nesting_level;\n  std::string temp_str = paren_string;\n\
    \  std::vector<long> temp_long = parse_nested_parens(temp_str);\n  if (temp_long.size()\
    \ > 0) {\n    nesting_level.push_back((long)temp_long.size()); // add current\
    \ nesting level\n  }\n  while (temp_str.size() > 0) {\n    int i = 0;\n    while\
    \ (i < temp_str.size() && paren_string[i] == ' ') {\n      i++;\n    }\n    std::string\
    \ token = temp_str.substr(0, i);\n    temp_str = temp_str.substr(i + 1);\n   \
    \ nesting_level.push_back((long)nesting_level.size());\n    if (nesting_level.size()\
    \ > temp_long.size()) {\n      temp_long = parse_nested_parens(token);\n     \
    \ nesting_level = nesting_level - temp_long;\n      assert(nesting_level.size()\
    \ == temp_long.size());\n    }\n  }\n  return nesting_level;", "  std::vector<long>\
    \ result;\n  // Step 1: Parse the string with stacks.\n  std::vector<std::vector<long>>\
    \ stacks;\n  stacks.push_back(std::vector<long>());\n  std::stack<long> stack_top;\n\
    \  std::stack<long> stack_cur;\n  std::stack<long> stack_next;\n  long stack_depth\
    \ = 0;\n  bool is_in_cur = false;\n  for (size_t i = 0; i < paren_string.size();\
    \ ++i) {\n    if (paren_string[i] == ')') {\n      long level_num = stack_next.size();\n\
    \      while (level_num > 0) {\n        long level_top = stack_top.size();\n \
    \       bool is_in_top = stack_top.empty() || stack_top.top() > level_num;\n \
    \       if (is_in_top) {\n          stack_depth = level_top;\n          is_in_cur\
    \ = true;\n        } else {\n          stack_depth--;\n        }\n        stack_top.pop();\n\
    \        if (is_in_cur) {\n          break;\n        }\n      }\n    } else {\n\
    \      if (is_in_cur) {\n        stack_cur.push(i - 1);\n      }\n      if (paren_string[i]\
    \ == '(') {\n        is_in_cur = true;\n        stack_depth++;\n        stack_next.push(i\
    \ - 1);\n      } else {\n        is_in_cur = false;\n        stack_next.pop();\n\
    \      }\n    }\n  }\n\n  // Step 2: Get the nested levels of parentheses.\n \
    \ while (stack_next.size() > 0) {\n    result.push_back(stack_next.top());\n \
    \   stack_next.pop();\n  }\n\n  while (stack_top.size() > 0) {\n    result.push_back(stack_top.top());\n\
    \    stack_top.pop();\n  }\n\n  return result;", "    std::vector<long> results;\n\
    \    std::string prev_char = \"\";\n    long level = 0;\n    for (auto &c : paren_string)\
    \ {\n        if (prev_char == \"(\")\n            ++level;\n        else if (prev_char\
    \ == \")\") {\n            if (level > 0)\n                --level;\n        \
    \    else {\n                results.push_back(level);\n                level\
    \ = 0;\n            }\n        }\n        prev_char = c;\n    }\n    return results;\
    \ // [(long)2, (long)3, (long)1, (long)3]", "    std::vector<long> ans;\n    bool\
    \ seen_opening_paren = false;\n    long curr_level = 0;\n    for (auto c: paren_string)\
    \ {\n        // if the current level is greater than or equal to the length of\
    \ the previous level,\n        // then we know we have not reached the correct\
    \ level (since we do not know the number\n        // of opening parentheses).\n\
    \        if (curr_level > ans.size() || curr_level < ans.size() - 1) {\n     \
    \       return ans;\n        }\n        // if we see an opening parentheses, increment\
    \ curr_level\n        if (c == '(') {\n            seen_opening_paren = true;\n\
    \            curr_level++;\n        }\n        // if we see a closing parentheses,\
    \ decrement curr_level\n        else if (c == ')') {\n            curr_level--;\n\
    \        }\n        // if we see a space, we know that we have reached the correct\
    \ level\n        else if (c == ' ') {\n            curr_level = ans.size();\n\
    \        }\n        // otherwise, if we see the closing parentheses, we are at\
    \ the correct level\n        else if (c == ')') {\n            curr_level = ans.size();\n\
    \            ans.push_back(curr_level);\n            seen_opening_paren = false;\n\
    \        }\n    }\n    return ans;", "  // If there is nothing to parse, just\
    \ return an empty vector.\n  if (paren_string == \"\") return std::vector<long>();\n\
    \  std::vector<long> levels;\n  // Step 1: find out number of open/close parentheses\
    \ in the string.\n  auto paren_counts = paren_string.find_first_of(\"()\", paren_string.find_first_not_of(\"\
    ()\"));\n  // Step 2: split string into open/close pairs, where open parentheses\
    \ come first, and close parentheses come last.\n  std::vector<std::string> paren_pairs\
    \ = paren_string.substr(0, paren_counts).split(' ', std::vector<char>{' ', '('});\n\
    \  // Step 3: iterate through the pairs and push corresponding number of levels\
    \ into a vector\n  for (size_t i = 0; i < paren_pairs.size(); ++i) {\n    if (paren_pairs[i]\
    \ == \"(\") {\n      levels.push_back(1);\n    } else if (paren_pairs[i] == \"\
    )\") {\n      levels[levels.size() - 1]++;\n    }\n  }\n  // Step 4: append the\
    \ number of levels to the vector and sort it.\n  levels.append(paren_pairs.size());\n\
    \  std::sort(levels.begin(), levels.end());\n  return levels;", "    std::vector<long>\
    \ paren_depth;\n    std::string curr_paren;\n    for (auto &c: paren_string) {\n\
    \        if (curr_paren == \"\") {\n            curr_paren = c;\n            paren_depth.push_back(0);\n\
    \        } else {\n            long paren_depth_so_far = paren_depth[paren_depth.size()\
    \ - 1];\n            if (c == \"(\") {\n                paren_depth.push_back(paren_depth_so_far\
    \ + 1);\n            } else if (c == \")\") {\n                paren_depth.pop_back();\n\
    \            }\n            curr_paren = c;\n        }\n    }\n    return paren_depth;",
  "    std::vector<long> result;\n    std::string curr_paren_string = paren_string;\n\
    \    long current_level = 0;\n    while (curr_paren_string.length() != 0) {\n\
    \        // Check if curr_paren_string is the empty string\n        if (curr_paren_string.empty())\
    \ return result;\n        // Check if the current char is the closing parenthesis\n\
    \        if (curr_paren_string.back() != '(') {\n            result.push_back(current_level);\n\
    \            return result;\n        }\n        // Increment current level by\
    \ 1\n        current_level++;\n        curr_paren_string = curr_paren_string.substr(0,\
    \ curr_paren_string.size() - 1);\n    }\n    return result;", "    std::vector<std::string>\
    \ paren_groups;\n    std::string current_paren_group = \"\";\n\n    // If no more\
    \ parenthesis groups are found, return an empty vector.\n    auto add_paren_group\
    \ = [](std::string &s) { paren_groups.emplace_back(s); };\n    auto check_paren_group\
    \ = [&](std::string &s) {\n        if (current_paren_group != \"\") {\n      \
    \      size_t index = paren_string.find(current_paren_group);\n            if\
    \ (index != std::string::npos) {\n                add_paren_group(s);\n      \
    \          current_paren_group = \"\";\n            }\n        }\n    };\n   \
    \ // Check for a closing parenthesis group first.\n    auto check_closing = [&](std::string\
    \ &s) {\n        auto index = paren_string.find(')');\n        if (index != std::string::npos)\
    \ {\n            check_paren_group(s);\n        }\n    };\n\n    paren_string.erase(std::remove(paren_string.begin(),\
    \ paren_string.end(), ' '), paren_string.end());\n    for (auto &s : paren_string)\
    \ {\n        // Check for a parenthesis group.\n        auto index = paren_string.find('(');\n\
    \        if (index != std::string::npos) {\n            current_paren_group =\
    \ s;\n        }\n        // Check for a closing parenthesis group.\n        index\
    \ = paren_string.find(')');\n        if (index != std::string::npos) {\n     \
    \       check_paren_group(s);\n        }\n    }\n    check_closing(paren_string);\n\
    \n    std::vector<long> results;\n    // Now go through the groups and find the\
    \ deepest level of nesting.\n    for (auto &s : paren_groups) {\n        std::stack<std::string>\
    \ parens;\n        std::stack<long> nesting;\n        std::string paren_level;\n\
    \        auto add_paren = [&](std::string &s) {\n            parens.push(s);\n\
    \            nesting.push(1);\n        };\n        auto remove_paren = [&](std::string\
    \ &s) {\n            if (parens.empty()) std::cout << \"No more parentheses groups\
    \ are found\" << std::endl;\n            else {\n                s = parens.top();\n\
    \                nesting.pop();\n                if (nesting.empty()) parens.pop();\n\
    \            }\n        };\n        // Check for an opening parenthesis group.\n\
    \        auto check_opening = [&](std::string &s) {\n            if (nesting.empty())\
    \ std::cout << \"No more parentheses groups are found\" << std::endl;\n      \
    \      else {\n                size_t index = s.find('(');\n                if\
    \ (index != std::string::npos) {\n                    nesting.push(index);\n \
    \                   add_paren_group(s);\n                    paren_level = \"\"\
    ;\n                }\n            }\n        };\n        // Check for a closing\
    \ parenthesis group.\n        auto check_closing", "    std::vector<long> paren_level;\n\
    \    for (auto &ch: paren_string) {\n        if (ch == ')') paren_level.back()++;\n\
    \        if (ch == '(') paren_level.push_back(0);\n    }\n    return paren_level;",
  "    // For each nested group, count how many opening parenthesis we have.\n   \
    \ size_t current_level = 0;\n    size_t max_nesting_level = 0;\n    for (size_t\
    \ i = 0; i < paren_string.size(); i++) {\n        // If current character is '(',\
    \ increase level\n        if (paren_string[i] == '(') {\n            current_level++;\n\
    \            max_nesting_level = std::max(max_nesting_level, current_level);\n\
    \        } else {\n            // Otherwise decrease level\n            current_level--;\n\
    \        }\n    }\n    // We will append the maximum nesting level to the vector\
    \ as well.\n    std::vector<long> nesting_levels(max_nesting_level);\n    current_level\
    \ = 0;\n    for (size_t i = 0; i < paren_string.size(); i++) {\n        // If\
    \ current character is '(', increase level\n        if (paren_string[i] == '(')\
    \ {\n            current_level++;\n        } else {\n            // Otherwise\
    \ decrease level\n            current_level--;\n        }\n        if (current_level\
    \ != 0) {\n            nesting_levels[current_level - 1]++;\n        }\n    }\n\
    \    return nesting_levels;", "  std::string str = paren_string;\n  std::vector<long>\
    \ result;\n  // Parse the string backwards to avoid modifying the original string\n\
    \  while (!str.empty()) {\n    bool found = false;\n    long level = 0;\n    size_t\
    \ last_index = 0;\n    for (size_t i = str.size(); i > 0; --i) {\n      if (str[i\
    \ - 1] == '(') {\n        found = true;\n        level = level + 1;\n      } else\
    \ if (str[i - 1] == ')') {\n        level = level - 1;\n        found = true;\n\
    \      } else if (str[i - 1] == ' ' && level > 0) {\n        last_index = i;\n\
    \      }\n    }\n    result.emplace_back(level);\n    str = str.substr(0, last_index);\n\
    \  }\n  return result;", "  std::vector<long> paren_levels;\n  std::stack<long\
    \ int> paren_counts;\n  long long total = 0;\n  for (char c : paren_string) {\n\
    \    total += std::count_if(std::begin(paren_counts), std::end(paren_counts),\
    \ [](long int count) {\n      return (count > 0) && (count == (c == '(' ? 1 :\
    \ 0));\n    });\n    if (total < 2) {\n      paren_counts.push(0);\n    }\n  \
    \  paren_counts.push((paren_counts.top() == 0) ? 1 : (paren_counts.top() == (c\
    \ == '(' ? 1 : 0)));\n    total += 1;\n  }\n  while (total > 0 && paren_counts.top()\
    \ > 0) {\n    paren_levels.push_back(paren_counts.top());\n    paren_counts.pop();\n\
    \    total -= paren_counts.top();\n  }\n  return paren_levels;"]
stop_tokens:
- "\n}"
