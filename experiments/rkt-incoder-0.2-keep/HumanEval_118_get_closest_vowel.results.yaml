name: HumanEval_118_get_closest_vowel
language: racket
results:
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search start end)\n\
    \    (cond [(empty? word) \"\"]\n          [(equal? (first word) start) (vowel-search\
    \ (rest word) (+ end 1))]\n          [(equal? (first word) end) (vowel-search\
    \ (rest word) (+ start 1))]\n          [else (vowel-search (rest word) (min start\
    \ end))]))\n  (vowel-search \"a\" \"z\"))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprrihmwp5.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprrihmwp5.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprrihmwp5.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprrihmwp5.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprrihmwp5.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprrihmwp5.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprrihmwp5.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprrihmwp5.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprrihmwp5.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprrihmwp5.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprrihmwp5.rkt:36:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n \
    \       [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \        [else (get-vowel-between (rest word) (first word))]))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp43extax1.rkt:20:15: get-vowel-between: unbound identifier\n  in:\
    \ get-vowel-between\n  location...:\n   /tmp/tmp43extax1.rkt:20:15\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let ((vowels '(a e i o u)))\n\
    \    (cond ((null? word) \"\")\n          ((char=? (char-code (car word)) (first\
    \ vowels)) \n           (get_closest_vowel (cdr word)))\n          ((char=? (char-code\
    \ (car word)) (last vowels)) \n           (get_closest_vowel (cdr word)))\n  \
    \        (else (get-closest-vowel (cdr word)))))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nThis doesn't work. Try it with `(get-closest-vowel \"ab\")`.\n\
    <|/ c |>\n<| c |>\nI tested it and it works fine. Can you give me an example where\
    \ it doesn't work?\n<|/ c |>\n<| c |>\nIt doesn't work for `get-closest-vowel\
    \ \"ab\"`. Try it with `(get-closest-vowel \"ab\")`.\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works fine. Can you give me an example where it doesn't work?\n<|/\
    \ c |>\n<| c |>\nI tested it and it works fine. Can you give me an example where\
    \ it doesn't work?\n<|/ c |>\n<| a tags=racket,scheme |>\n<code>\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpns8gwpzs.rkt:24:57: read-syntax: illegal use of `.`\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(equal? (first word) 'a) (vowel-check\
    \ (rest word))]\n          [(equal? (first word) 'e) (vowel-check (rest word))]\n\
    \          [(equal? (first word) 'i) (vowel-check (rest word))]\n          [(equal?\
    \ (first word) 'o) (vowel-check (rest word))]\n          [(equal? (first word)\
    \ 'u) (vowel-check (rest word))]\n          [(equal? (first word) 'A) (vowel-check\
    \ (rest word))]\n          [(equal? (first word) 'E) (vowel-check (rest word))]\n\
    \          [(equal? (first word) 'I) (vowel-check (rest word))]\n          [(equal?\
    \ (first word) 'O) (vowel-check (rest word))]\n          [(equal? (first word)\
    \ 'U) (vowel-check (rest word))]\n          [else (vowel-check (rest word))]))\n\
    \  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6wye42s9.rkt:34:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6wye42s9.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6wye42s9.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6wye42s9.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6wye42s9.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6wye42s9.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6wye42s9.rkt:40:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6wye42s9.rkt:41:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6wye42s9.rkt:42:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6wye42s9.rkt:43:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6wye42s9.rkt:44:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n \
    \       [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \        [else (first word)]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb6csnm8z.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb6csnm8z.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb6csnm8z.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb6csnm8z.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb6csnm8z.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb6csnm8z.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb6csnm8z.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb6csnm8z.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb6csnm8z.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb6csnm8z.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb6csnm8z.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search start end)\n\
    \    (cond\n      [(null? start) \"\"]\n      [(null? end) \"\"]\n      [(char=?\
    \ (char-code start) 97) (vowel-search (cdr start) end)]\n      [(char=? (char-code\
    \ start) 65) (vowel-search start (cdr start))]\n      [(char=? (char-code start)\
    \ 97) (vowel-search start (cdr start))]\n      [(char=? (char-code start) 65)\
    \ (vowel-search start (cdr start))]\n      [(char=? (char-code start) 97) (vowel-search\
    \ start (cdr start))]\n      [(char=? (char-code start) 65) (vowel-search start\
    \ (cdr start))]\n      [(char=? (char-code start) 97) (vowel-search start (cdr\
    \ start))]\n      [(char=? (char-code start) 65) (vowel-search start (cdr start))]\n\
    \      [(char=? (char-code start) 97) (vowel-search start (cdr start))]\n    \
    \  [(char=? (char-code start) 65) (vowel-search start (cdr start))]\n      [(char=?\
    \ (char-code start) 97) (vowel-search start (cdr start))]\n      [(char=? (char-code\
    \ start) 65) (vowel-search start (cdr start))]\n      [(char=? (char-code start)\
    \ 97) (vowel-search start (cdr start))]\n      [(char=? (char-code start) 65)\
    \ (vowel-search start (cdr start))]\n      [(char=? (char-code start) 97) (vowel-search\
    \ start (cdr start))]\n      [(char=? (char-code start) 65) (vowel-search start\
    \ (cdr start))]\n      [(char=? (char-code start) 97) (vowel-search start (cdr\
    \ start))]\n      [(char=? (char-code start) 65) (vowel-search start (cdr start))]\n\
    \      [(char=? (char-code start) 97) (vowel-search start (cdr start))]\n    \
    \  [(char=? (char-code start) 65) (vowel-search start (cdr start))]\n      [(char=?\
    \ (char-code start) 97) (vowel-search start (cdr start))]\n      [(char=? (char-code\
    \ start) 65) (vowel-search start (cdr \n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpfwosjob4.rkt:39:57: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 40\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search vowel word)\n\
    \    (cond [(empty? word) empty]\n          [(equal? (first word) vowel) (vowel-search\
    \ vowel (rest word))]\n          [else (vowel-search (first vowel) (rest word))]))\n\
    \  (vowel-search vowel word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpmb6kuo_o.rkt:18:16: vowel: unbound identifier\n  in: vowel\n  location...:\n\
    \   /tmp/tmpmb6kuo_o.rkt:18:16\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpyk83g17a.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpyk83g17a.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpyk83g17a.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpyk83g17a.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpyk83g17a.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpyk83g17a.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpyk83g17a.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpyk83g17a.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpyk83g17a.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpyk83g17a.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpyk83g17a.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel)\n\
    \    (cond\n      [(char=? vowel 'a) (char=? (char-after (char-after word vowel)\
    \ 1) 'u)]\n      [(char=? vowel 'e) (char=? (char-after (char-after word vowel)\
    \ 1) 'i)]\n      [(char=? vowel 'o) (char=? (char-after (char-after word vowel)\
    \ 1) 'o)]\n      [(char=? vowel 'u) (char=? (char-after (char-after word vowel)\
    \ 1) 'u)]\n      [(char=? vowel 'y) (char=? (char-after (char-after word vowel)\
    \ 1) 'y)]\n      [(char=? vowel 'A) (char=? (char-after (char-after word vowel)\
    \ 1) 'U)]\n      [(char=? vowel 'E) (char=? (char-after (char-after word vowel)\
    \ 1) 'I)]\n      [(char=? vowel 'O) (char=? (char-after (char-after word vowel)\
    \ 1) 'O)]\n      [(char=? vowel 'U) (char=? (char-after (char-after word vowel)\
    \ 1) 'U)]\n      [(char=? vowel 'Y) (char=? (char-after (char-after word vowel)\
    \ 1) 'Y)]\n      [else (error \"Not a vowel\")]))\n  (define (consonant-check\
    \ consonant)\n    (cond\n      [(char=? consonant 'a) (char=? (char-after word\
    \ consonant) 'b)]\n      [(char=? consonant 'e) (char=? (char-after word consonant)\
    \ 'f)]\n      [(char=? consonant 'i) (char=? (char-after word consonant) 'g)]\n\
    \      [(char=? consonant 'o) (char=? (char-after word consonant) 'h)]\n     \
    \ [(char=? consonant 'u) (char=? (char-after word consonant) 'j)]\n      [(char=?\
    \ consonant 'y) (char=? (char-after word consonant) 'k)]\n      [(char=? consonant\
    \ 'A) (char=? (char-after word consonant) 'B)]\n      [(char=? consonant 'E) (char=?\
    \ (char-after word consonant\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpb7qji39q.rkt:36:37: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 37\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search vowel word)\n\
    \    (cond [(empty? word) \"\"]\n          [(equal? (first word) vowel) (vowel-search\
    \ vowel (rest word))]\n          [else (vowel-search (first word) (append (rest\
    \ word) (list vowel)))]))\n  (vowel-search (first word) (append (rest word) (list\
    \ 'u))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxh6ri65i.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpxh6ri65i.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpxh6ri65i.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpxh6ri65i.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpxh6ri65i.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpxh6ri65i.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpxh6ri65i.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpxh6ri65i.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpxh6ri65i.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpxh6ri65i.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpxh6ri65i.rkt:35:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond\n      [(empty? word) \"\"]\n     \
    \ [(member (car word) vowels) (car word)]\n      [else (loop (cdr word) (cons\
    \ (car word) vowels))])))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8reeycja.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8reeycja.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8reeycja.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8reeycja.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8reeycja.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8reeycja.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8reeycja.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8reeycja.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8reeycja.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8reeycja.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8reeycja.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8reeycja.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (cons (first\
    \ word) (vowel-check (rest word)))]\n          [(char=? (first word) 'e) (cons\
    \ (first word) (vowel-check (rest word)))]\n          [(char=? (first word) 'i)\
    \ (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first word)\
    \ 'o) (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first\
    \ word) 'u) (cons (first word) (vowel-check (rest word)))]\n          [else (vowel-check\
    \ (rest word))]))\n  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2iniszbf.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2iniszbf.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2iniszbf.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2iniszbf.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2iniszbf.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2iniszbf.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2iniszbf.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2iniszbf.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2iniszbf.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2iniszbf.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2iniszbf.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf59z688u.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpf59z688u.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpf59z688u.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpf59z688u.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpf59z688u.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpf59z688u.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpf59z688u.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpf59z688u.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpf59z688u.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpf59z688u.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpf59z688u.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpxg90hxw6.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmpxg90hxw6.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgzdz787y.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgzdz787y.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgzdz787y.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgzdz787y.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgzdz787y.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgzdz787y.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgzdz787y.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgzdz787y.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgzdz787y.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgzdz787y.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgzdz787y.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word) (vowels\
    \ '(#\\a #e #i #o #u)))\n    (cond ((null? word) \"\")\n          ((char=? (car\
    \ word) (car vowels)) (car vowels))\n          ((char=? (car word) (cadr vowels))\
    \ (loop (cdr word) vowels))\n          ((char=? (car word) (caddr vowels)) (loop\
    \ (cdr word) vowels))\n          ((char=? (car word) (caddr vowels) (loop (cdr\
    \ word) vowels))\n           (loop (cdr word) vowels))\n          (else (loop\
    \ (cdr word) vowels)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmppyzo58c4.rkt:14:39: read-syntax: no digits\n  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ count)\n    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word))\
    \ (helper (rest word) vowel (+ index 1) count)]\n      [else (helper (rest word)\
    \ (first word) (+ index 1) count)]))\n  (helper (reverse word) 'u (length word)\
    \ 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpogr9x9bk.rkt:26:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpogr9x9bk.rkt:27:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpogr9x9bk.rkt:28:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpogr9x9bk.rkt:29:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpogr9x9bk.rkt:30:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpogr9x9bk.rkt:31:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpogr9x9bk.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpogr9x9bk.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpogr9x9bk.rkt:34:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpogr9x9bk.rkt:35:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpogr9x9bk.rkt:36:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpogr9x9bk.rkt:37:4\n\
    \nreverse: contract violation\n  expected: list?"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((vowels '(a e i o u))\
    \ (word word) (vowel nil))\n    (cond ((null? word) vowel)\n          ((char=?\
    \ (car word) (car vowels)) \n           (loop (cdr vowels) (cdr word) (car vowel)))\n\
    \          ((char=? (car word) (car vowels)) \n           (loop (cdr vowels) (cdr\
    \ word) (cdr vowel)))\n          ((char=? (car word) (car vowels)) \n        \
    \   (loop (cdr vowels) (cdr word) (cons vowel (car word))))\n          (else (loop\
    \ (cdr vowels) (cdr word) vowel)))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp7a65a9gh.rkt:14:54: nil: unbound identifier\n  in: nil\n  location...:\n\
    \   /tmp/tmp7a65a9gh.rkt:14:54\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u))\n             (vowels-count 0))\n    (cond ((null?\
    \ word) \"\")\n          ((member (car word) vowels) (car word))\n          ((member\
    \ (car word) vowels) (loop (cdr word) vowels vowels-count))\n          ((member\
    \ (car word) vowels-count) (loop (cdr word) vowels vowels-count))\n          (else\
    \ (loop (cdr word) vowels vowels-count))))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nThank you so much! I really appreciate your help!\n<|/ c |>\n<|\
    \ c |>\nI added a solution that doesn't use any loops. I hope it helps.\n<|/ c\
    \ |>\n<| c |>\nThank you so much! I really appreciate your help!\n<|/ c |>\n<|\
    \ a tags=racket,scheme |>\n<code>\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpxq2o87i0.rkt:13:0: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 22\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (cons (first\
    \ word) (vowel-check (rest word)))]\n          [(char=? (first word) 'e) (cons\
    \ (first word) (vowel-check (rest word)))]\n          [(char=? (first word) 'i)\
    \ (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first word)\
    \ 'o) (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first\
    \ word) 'u) (cons (first word) (vowel-check (rest word)))]\n          [else (vowel-check\
    \ (rest word))]))\n  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprxopp8pu.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprxopp8pu.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprxopp8pu.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprxopp8pu.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprxopp8pu.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprxopp8pu.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprxopp8pu.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprxopp8pu.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprxopp8pu.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprxopp8pu.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprxopp8pu.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (cons (first\
    \ word) (vowel-check (rest word)))]\n          [(char=? (first word) 'e) (cons\
    \ (first word) (vowel-check (rest word)))]\n          [(char=? (first word) 'i)\
    \ (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first word)\
    \ 'o) (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first\
    \ word) 'u) (cons (first word) (vowel-check (rest word)))]\n          [else (vowel-check\
    \ (rest word))]))\n  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpe51_duvv.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpe51_duvv.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpe51_duvv.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpe51_duvv.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpe51_duvv.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpe51_duvv.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpe51_duvv.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpe51_duvv.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpe51_duvv.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpe51_duvv.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpe51_duvv.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search word vowel)\n\
    \    (cond [(empty? word) \"\"]\n          [(equal? vowel (first word)) (vowel-search\
    \ (rest word) vowel)]\n          [(equal? (first word) vowel) (vowel-search (rest\
    \ word) (first vowel))]\n          [else (vowel-search (rest word) (first vowel))]))\n\
    \  (vowel-search word (first word)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpiswmj2h7.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpiswmj2h7.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpiswmj2h7.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpiswmj2h7.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpiswmj2h7.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpiswmj2h7.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpiswmj2h7.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpiswmj2h7.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpiswmj2h7.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpiswmj2h7.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpiswmj2h7.rkt:36:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (cons (first\
    \ word) (vowel-check (rest word)))]\n          [(char=? (first word) 'e) (cons\
    \ (first word) (vowel-check (rest word)))]\n          [(char=? (first word) 'i)\
    \ (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first word)\
    \ 'o) (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first\
    \ word) 'u) (cons (first word) (vowel-check (rest word)))]\n          [else (vowel-check\
    \ (rest word))]))\n  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpleykepot.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpleykepot.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpleykepot.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpleykepot.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpleykepot.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpleykepot.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpleykepot.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpleykepot.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpleykepot.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpleykepot.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpleykepot.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? (first word) vowel) (helper\
    \ (rest word) vowel)]\n      [else (helper (rest word) (append vowel (first word)))]))\n\
    \  (helper word '()))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_lc5c7es.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_lc5c7es.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_lc5c7es.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_lc5c7es.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_lc5c7es.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_lc5c7es.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_lc5c7es.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_lc5c7es.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_lc5c7es.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_lc5c7es.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_lc5c7es.rkt:36:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((member\
    \ (char-code (car word)) vowels) (car word))\n          ((member (char-code (cadr\
    \ word)) vowels) (cadr word))\n          ((member (char-code (caddr word)) vowels)\
    \ (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpox027nrg.rkt:41:19: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 42\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond\n      [(empty? word) \"\"]\n      [(char=? (first word) 'a) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'e) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'i) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'o) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'u) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [else (vowel-check (rest word))]))\n\
    \  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpck8_12vs.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpck8_12vs.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpck8_12vs.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpck8_12vs.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpck8_12vs.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpck8_12vs.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpck8_12vs.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpck8_12vs.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpck8_12vs.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpck8_12vs.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpck8_12vs.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ count)\n    (cond [(null? word) \"\"]\n          [(equal? (char-code (car word))\
    \ (char-code vowel)) (helper (cdr word) vowel (+ index 1) count)]\n          [else\
    \ (helper (cdr word) vowel (+ index 1) count)]))\n  (helper (reverse word) 'u\
    \ (length word) 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp7r4nez3n.rkt:16:20: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmp7r4nez3n.rkt:16:20\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((member\
    \ (car word) vowels) (car word))\n          ((member (cdr word) vowels) (cdr word))\n\
    \          (else (loop (cdr word) (cons (car word) vowels))))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3z4ftc0.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3z4ftc0.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3z4ftc0.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3z4ftc0.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3z4ftc0.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3z4ftc0.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3z4ftc0.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3z4ftc0.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3z4ftc0.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3z4ftc0.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3z4ftc0.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3z4ftc0.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond\n      [(empty? word) empty]\n      [(equal? vowel (first word)) vowel]\n\
    \      [else (vowel-check (rest word) (first word))]))\n  (vowel-check (first\
    \ word) word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\"\
    )\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpz83c2ghm.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpz83c2ghm.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpz83c2ghm.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpz83c2ghm.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpz83c2ghm.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpz83c2ghm.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpz83c2ghm.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpz83c2ghm.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpz83c2ghm.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpz83c2ghm.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpz83c2ghm.rkt:36:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8b5p03p5.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8b5p03p5.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8b5p03p5.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8b5p03p5.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8b5p03p5.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8b5p03p5.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8b5p03p5.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8b5p03p5.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8b5p03p5.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8b5p03p5.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8b5p03p5.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((member\
    \ (car word) vowels) (car word))\n          (else (loop (cdr word) (cons (car\
    \ word) vowels)))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp2unjev4h.rkt:18:62: read-syntax: unexpected `)`\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word)) (vowel-check\
    \ vowel (rest word))]\n      [else (vowel-check vowel (rest word))]\n    ))\n\
    \  (vowel-check (first word) word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp338oo_ax.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp338oo_ax.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp338oo_ax.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp338oo_ax.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp338oo_ax.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp338oo_ax.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp338oo_ax.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp338oo_ax.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp338oo_ax.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp338oo_ax.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp338oo_ax.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search start end)\n\
    \    (cond ((null? start) \"\")\n          ((null? end) \"\")\n          ((equal?\
    \ (char-after (char-before (char-after start) start) 'a) 'a) 'a)\n          ((equal?\
    \ (char-after (char-before (char-after start) start) 'e) 'e) 'e)\n          ((equal?\
    \ (char-after (char-before (char-after start) start) 'i) 'i) 'i)\n          ((equal?\
    \ (char-after (char-before (char-after start) start) 'o) 'o) 'o)\n          ((equal?\
    \ (char-after (char-before (char-after start) start) 'u) 'u) 'u)\n          ((equal?\
    \ (char-after (char-before (char-after start) start) 'A) 'A) 'A)\n          ((equal?\
    \ (char-after (char-before (char-after start) start) 'E) 'E) 'E)\n          ((equal?\
    \ (char-after (char-before (char-after start) start) 'I) 'I) 'I)\n          ((equal?\
    \ (char-after (char-before (char-after start) start) 'O) 'O) 'O)\n          ((equal?\
    \ (char-after (char-before (char-after start) start) 'U) 'U) 'U)\n          (else\
    \ (vowel-search (char-after start) (char-before end 1)))))\n  (vowel-search (string-length\
    \ word) (string-length word)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp5t400oh_.rkt:17:20: char-after: unbound identifier\n  in: char-after\n\
    \  location...:\n   /tmp/tmp5t400oh_.rkt:17:20\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n \
    \       [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \        [else (first word)]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5z51b5v6.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5z51b5v6.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5z51b5v6.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5z51b5v6.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5z51b5v6.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5z51b5v6.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5z51b5v6.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5z51b5v6.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5z51b5v6.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5z51b5v6.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5z51b5v6.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((member\
    \ (char-code (car word)) vowels) (car word))\n          ((member (char-code (cadr\
    \ word)) vowels) (cadr word))\n          ((member (char-code (caddr word)) vowels)\
    \ (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp9kz44n6r.rkt:41:19: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 42\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond\n      [(empty? word) \"\"]\n     \
    \ [(member (first word) vowels) (first word)]\n      [else (loop (rest word) (cons\
    \ vowels (rest word)))]\n    )\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpoy5ioj4l.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoy5ioj4l.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoy5ioj4l.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoy5ioj4l.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoy5ioj4l.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoy5ioj4l.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoy5ioj4l.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoy5ioj4l.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoy5ioj4l.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoy5ioj4l.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoy5ioj4l.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond\n      [(empty? word) \"\"]\n     \
    \ [(member (first word) vowels) (first word)]\n      [else (loop (rest word) (cons\
    \ vowels (rest vowels)))]\n    )\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmppkakto1j.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmppkakto1j.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppkakto1j.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmppkakto1j.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppkakto1j.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmppkakto1j.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppkakto1j.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmppkakto1j.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppkakto1j.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmppkakto1j.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmppkakto1j.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond\n      [(equal? vowel word) vowel]\n      [else (vowel-check (cdr vowel)\
    \ word)])\n  (vowel-check 'a '(cons word '())))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp4l7uy74x.rkt:13:0: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 20\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpoywfuy_2.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoywfuy_2.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoywfuy_2.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoywfuy_2.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoywfuy_2.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoywfuy_2.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoywfuy_2.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoywfuy_2.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoywfuy_2.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoywfuy_2.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoywfuy_2.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel vowel-index)\n\
    \    (cond ((null? word) \"\")\n          ((char=? (car word) vowel) (helper (cdr\
    \ word) vowel (+ vowel-index 1)))\n          (else (helper (cdr word) vowel (+\
    \ vowel-index 1)))))\n  (helper word 'u (length word)))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6x3prwy0.rkt:25:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6x3prwy0.rkt:26:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6x3prwy0.rkt:27:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6x3prwy0.rkt:28:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6x3prwy0.rkt:29:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6x3prwy0.rkt:30:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6x3prwy0.rkt:31:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6x3prwy0.rkt:32:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6x3prwy0.rkt:33:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6x3prwy0.rkt:34:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6x3prwy0.rkt:35:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6x3prwy0.rkt:36:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"A"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel start\
    \ end)\n    (cond [(empty? word) \"\"]\n          [(equal? vowel (first word))\
    \ (first word)]\n          [(equal? (first word) vowel) (first word)]\n      \
    \    [(equal? (first word) (first vowel)) (first word)]\n          [(equal? (first\
    \ word) (first vowel) (first start)) (first word)]\n          [(equal? (first\
    \ word) (first vowel) (first end)) (first word)]\n          [(equal? (first word)\
    \ (first vowel) (second start)) (first word)]\n          [(equal? (first word)\
    \ (first vowel) (second end)) (first word)]\n          [(equal? (first word) (first\
    \ vowel) (third start)) (first word)]\n          [(equal? (first word) (first\
    \ vowel) (third end)) (first word)]\n          [(equal? (first word) (first vowel)\
    \ (fourth start)) (first word)]\n          [(equal? (first word) (first vowel)\
    \ (fourth end)) (first word)]\n          [(equal? (first word) (first vowel) (fifth\
    \ start)) (first word)]\n          [(equal? (first word) (first vowel) (fifth\
    \ end)) (first word)]\n          [(equal? (first word) (first vowel) (sixth start))\
    \ (first word)]\n          [(equal? (first word) (first vowel) (sixth end)) (first\
    \ word)]\n          [(equal? (first word) (first vowel) (seventh start)) (first\
    \ word)]\n          [(equal? (first word) (first vowel) (seventh end)) (first\
    \ word)]\n          [(equal? (first word) (first vowel) (eighth start)) (first\
    \ word)]\n          [(equal? (first word) (first vowel) (eighth end)) (first word)]\n\
    \          [(equal? (first word) (first vowel) (tenth start)) (first word)]\n\
    \          [(equal? (first word) (first vowel) (tenth end)) (first word)]\n  \
    \        [(equal? (first word) (first vowel) (eleventh start)) (first word)]\n\
    \          [(equal? (first word) (first vowel) (eleventh end)) (first word)]\n\
    \          [(equal? (first word) (first vowel) (twelfth start)) (first word)]\n\
    \          [(equal? (first word) (first vowel) (twelfth end)) (first word)]\n\
    \          [(equal? (first word) (first vowel) (thirteenth start)) (first word)]\n\
    \          [(equal? (first word) (\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpx9w1wfz4.rkt:42:32: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 43\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond\n      [(empty? word) \"\"]\n      [(char=? (first word) 'a) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'e) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'i) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'o) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'u) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [else (vowel-check (rest word))]))\n\
    \  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi9b3f1_2.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpi9b3f1_2.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpi9b3f1_2.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpi9b3f1_2.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpi9b3f1_2.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpi9b3f1_2.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpi9b3f1_2.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpi9b3f1_2.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpi9b3f1_2.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpi9b3f1_2.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpi9b3f1_2.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((member\
    \ (char-code (car word)) vowels) (car word))\n          ((member (char-code (cadr\
    \ word)) vowels) (cadr word))\n          ((member (char-code (caddr word)) vowels)\
    \ (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpkr0_ffqs.rkt:41:19: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 42\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ count)\n    (cond [(null? word) \"\"]\n          [(equal? vowel (car word))\
    \ (helper (cdr word) vowel (+ index 1) count)]\n          [(equal? (car word)\
    \ (substring vowel (+ index 1) (length vowel))) (helper (cdr word) vowel (+ index\
    \ 1) count)]\n          [else (helper (cdr word) vowel (+ index 1) count)]))\n\
    \  (helper word 'u (length word) 0))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph77l31jb.rkt:26:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph77l31jb.rkt:27:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph77l31jb.rkt:28:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph77l31jb.rkt:29:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph77l31jb.rkt:30:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph77l31jb.rkt:31:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph77l31jb.rkt:32:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph77l31jb.rkt:33:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph77l31jb.rkt:34:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph77l31jb.rkt:35:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph77l31jb.rkt:36:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph77l31jb.rkt:37:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"A"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-count vowel)\n\
    \    (cond\n      [(char=? (char-code vowel) 97) (+ 1 (vowel-count (char-code\
    \ (substring vowel 0 -1))))]\n      [(char=? (char-code vowel) 65) (+ 1 (vowel-count\
    \ (char-code (substring vowel 0 -1))))]\n      [(char=? (char-code vowel) 90)\
    \ (+ 1 (vowel-count (char-code (substring vowel 0 -1))))]\n      [(char=? (char-code\
    \ vowel) 48) (+ 1 (vowel-count (char-code (substring vowel 0 -1))))]\n      [(char=?\
    \ (char-code vowel) 57) (+ 1 (vowel-count (char-code (substring vowel 0 -1))))]\n\
    \      [else 0]))\n  (define (vowel-count vowel)\n    (cond\n      [(char=? (char-code\
    \ vowel) 97) (+ 1 (vowel-count (char-code (substring vowel 0 -1))))]\n      [(char=?\
    \ (char-code vowel) 65) (+ 1 (vowel-count (char-code (substring vowel 0 -1))))]\n\
    \      [(char=? (char-code vowel) 90) (+ 1 (vowel-count (char-code (substring\
    \ vowel 0 -1))))]\n      [(char=? (char-code vowel) 48) (+ 1 (vowel-count (char-code\
    \ (substring vowel 0 -1))))]\n      [(char=? (char-code vowel) 57) (+ 1 (vowel-count\
    \ (char-code (substring vowel 0 -1))))]\n      [else 0]))\n  (define (vowel-count\
    \ vowel)\n    (cond\n      [(char=? (char-code vowel) 97) (+ 1 (vowel-count (char-code\
    \ (substring vowel 0 -1))))]\n      [(char=? (char-code vowel) 65) (+ 1 (vowel-count\
    \ (char-code (substring vowel 0 -1))))]\n      [(char=? (char-code vowel) 90)\
    \ (+ 1 (vowel-count (char-code (substring vowel 0 -1))))]\n      [(char=? (char-code\
    \ vowel) 48) (+ 1 (vowel-count (char-code (substring vowel 0 -1))))]\n      [(char=?\
    \ (char-code vowel) 57) (+ 1 (vowel-count (char-code (substring vowel 0 -1))))]\n\
    \      [else 0]))\n  (define (vowel-count vowel)\n    (cond\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp2237nou6.rkt:39:4: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 40\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-finder start end)\n\
    \    (cond ((null? end) \"\")\n          ((char=? (char-code (substring word start))\
    \ #\\a) (substring word start))\n          ((char=? (char-code (substring word\
    \ start)) #\\e) (substring word start))\n          ((char=? (char-code (substring\
    \ word start)) #\\i) (substring word start))\n          ((char=? (char-code (substring\
    \ word start)) #\\o) (substring word start))\n          ((char=? (char-code (substring\
    \ word start)) #\\u) (substring word start))\n          (else (vowel-finder (+\
    \ start 1) end))))\n  (vowel-finder 0 (length word)))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpdryu720u.rkt:16:20: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmpdryu720u.rkt:16:20\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n \
    \       [(equal? (char-after (char-before (char-after word)) #\\a) word) \n  \
    \       (char-after (char-before (char-after word)) #\\a)]\n        [(equal? (char-after\
    \ (char-before (char-after word)) #\\e) word) \n         (char-after (char-before\
    \ (char-after word)) #\\e)]\n        [(equal? (char-after (char-before (char-after\
    \ word)) #\\i) word) \n         (char-after (char-before (char-after word)) #\\\
    i)]\n        [(equal? (char-after (char-before (char-after word)) #\\o) word)\
    \ \n         (char-after (char-before (char-after word)) #\\o)]\n        [else\
    \ (get-closest-vowel (char-after word))]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp5v1luvf_.rkt:15:18: char-after: unbound identifier\n  in: char-after\n\
    \  location...:\n   /tmp/tmp5v1luvf_.rkt:15:18\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((equal?\
    \ (char-after (car word) (car vowels)) (car vowels))\n           (loop (cdr word)\
    \ (cons (car vowels) vowels)))\n          ((equal? (char-after (car word) (car\
    \ vowels)) (cdr vowels))\n           (loop (cdr word) (cons (car vowels) vowels)))\n\
    \          (else (loop (cdr word) (cons (car vowels) vowels))))))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp_unck_by.rkt:17:20: char-after: unbound identifier\n  in: char-after\n\
    \  location...:\n   /tmp/tmp_unck_by.rkt:17:20\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp5nul6scs.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmp5nul6scs.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search vowel word)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? (first word) vowel) (vowel-search\
    \ (rest word) vowel)]\n      [(equal? (first word) (rest vowel)) (vowel-search\
    \ vowel (rest word))]\n      [else (vowel-search vowel (rest word))]))\n  (vowel-search\
    \ (first word) word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpn8bfwy_m.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpn8bfwy_m.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpn8bfwy_m.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpn8bfwy_m.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpn8bfwy_m.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpn8bfwy_m.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpn8bfwy_m.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpn8bfwy_m.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpn8bfwy_m.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpn8bfwy_m.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpn8bfwy_m.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (vowel-check\
    \ (rest word))]\n          [(char=? (first word) 'e) (vowel-check (rest word))]\n\
    \          [(char=? (first word) 'i) (vowel-check (rest word))]\n          [(char=?\
    \ (first word) 'o) (vowel-check (rest word))]\n          [(char=? (first word)\
    \ 'u) (vowel-check (rest word))]\n          [else (vowel-check (rest word))]))\n\
    \  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpl8__4dey.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpl8__4dey.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpl8__4dey.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpl8__4dey.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpl8__4dey.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpl8__4dey.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpl8__4dey.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpl8__4dey.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpl8__4dey.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpl8__4dey.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpl8__4dey.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpequb3bcu.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpequb3bcu.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpequb3bcu.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpequb3bcu.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpequb3bcu.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpequb3bcu.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpequb3bcu.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpequb3bcu.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpequb3bcu.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpequb3bcu.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpequb3bcu.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel)\n\
    \    (cond [(empty? word) \"\"]\n          [(equal? (first word) vowel) vowel]\n\
    \          [(equal? (first word) (substring (second word) 0 1)) (helper (rest\
    \ word) (first vowel))]\n          [else (helper (rest word) (first vowel))]))\n\
    \  (helper word 'a))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpg4417ydi.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpg4417ydi.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpg4417ydi.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpg4417ydi.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpg4417ydi.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpg4417ydi.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpg4417ydi.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpg4417ydi.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpg4417ydi.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpg4417ydi.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpg4417ydi.rkt:36:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond\n      [(empty? word) \"\"]\n     \
    \ [(member (first word) vowels) (first word)]\n      [else (loop (rest word) (cons\
    \ (first word) vowels))])))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwv_uuofe.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwv_uuofe.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwv_uuofe.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwv_uuofe.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwv_uuofe.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwv_uuofe.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwv_uuofe.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwv_uuofe.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwv_uuofe.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwv_uuofe.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwv_uuofe.rkt:36:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let ((vowels '(a e i o u)))\n\
    \    (cond ((null? word) \"\")\n          ((char=? (char-code (car word)) (first\
    \ vowels)) \n           (get_closest_vowel (cdr word)))\n          ((char=? (char-code\
    \ (car word)) (last vowels)) \n           (get_closest_vowel (cdr word)))\n  \
    \        (else (get_closest_vowel (cdr word)))))\n</code>\n<|/ a tags=racket,scheme\
    \ |>\n<| c |>\nI like your solution. Very elegant. Thank you for sharing it.\n\
    <|/ c |>\n<| a dscore=1 |>\n<code>\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp64fjvo_t.rkt:13:0: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 21\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u))\n             (vowel-count 0))\n    (cond ((null?\
    \ word) \"\")\n          ((char=? (car word) 'a) (loop (cdr word) (cons vowels\
    \ vowel-count))\n           (loop (cdr word) (cons vowels (- vowel-count 1))))\n\
    \          ((char=? (car word) 'e) (loop (cdr word) (cons vowels (+ vowel-count\
    \ 1)))\n           (loop (cdr word) (cons vowels (- vowel-count 1))))\n      \
    \    ((char=? (car word) 'i) (loop (cdr word) (cons vowels (+ vowel-count 1)))\n\
    \           (loop (cdr word) (cons vowels (- vowel-count 1))))\n          ((char=?\
    \ (car word) 'o) (loop (cdr word) (cons vowels (+ vowel-count 1)))\n         \
    \  (loop (cdr word) (cons vowels (- vowel-count 1))))\n          ((char=? (car\
    \ word) 'u) (loop (cdr word) (cons vowels (+ vowel-count 1)))\n           (loop\
    \ (cdr word) (cons vowels (- vowel-count 1))))\n          (else (loop (cdr word)\
    \ (cons vowels vowel-count))))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1sro7lkd.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1sro7lkd.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1sro7lkd.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1sro7lkd.rkt:38:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1sro7lkd.rkt:39:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1sro7lkd.rkt:40:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1sro7lkd.rkt:41:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1sro7lkd.rkt:42:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1sro7lkd.rkt:43:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1sro7lkd.rkt:44:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1sro7lkd.rkt:45:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1sro7lkd.rkt:46:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (char-after (char-before (char-after word) 'a) 'a) 'a) (char-after\
    \ (char-before (char-after word) 'a) 'a)]\n    [(equal? (char-after (char-before\
    \ (char-after word) 'a) 'a) 'e) (char-after (char-before (char-after word) 'a)\
    \ 'a)]\n    [(equal? (char-after (char-before (char-after word) 'a) 'a) 'i) (char-after\
    \ (char-before (char-after word) 'a) 'a)]\n    [(equal? (char-after (char-before\
    \ (char-after word) 'a) 'a) 'o) (char-after (char-before (char-after word) 'a)\
    \ 'a)]\n    [(equal? (char-after (char-before (char-after word) 'a) 'a) 'u) (char-after\
    \ (char-before (char-after word) 'a) 'a)]\n    [(equal? (char-after (char-before\
    \ (char-after word) 'a) 'a) 'y) (char-after (char-before (char-after word) 'a)\
    \ 'a)]\n    [(equal? (char-after (char-before (char-after word) 'a) 'a) 'u) (char-after\
    \ (char-before (char-after word) 'a) 'a)]\n    [(equal? (char-after (char-before\
    \ (char-after word) 'a) 'a) 'a) (char-after (char-before (char-after word) 'a)\
    \ 'a)]\n    [(equal? (char-after (char-before (char-after word) 'a) 'a) 'e) (char-after\
    \ (char-before (char-after word) 'a) 'a)]\n    [(equal? (char-after (char-before\
    \ (char-after word) 'a) 'a) 'i) (char-after (char-before (char-after word) 'a)\
    \ 'a)]\n    [(equal? (char-after (char-before (char-after word) 'a) 'a) 'o) (char-after\
    \ (char-before (char-after word) '\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmphb0imc3j.rkt:26:80: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 27\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? (first word) vowel) (second\
    \ word)]\n      [(equal? (first word) (substring (second word) 0 1)) (helper (rest\
    \ word) (substring (second word) 0 1))]\n      [(equal? (first word) (substring\
    \ (second word) 0 2)) (helper (rest word) (substring (second word) 0 2))]\n  \
    \    [(equal? (first word) (substring (second word) 0 3)) (helper (rest word)\
    \ (substring (second word) 0 3))]\n      [(equal? (first word) (substring (second\
    \ word) 0 4)) (helper (rest word) (substring (second word) 0 4))]\n      [(equal?\
    \ (first word) (substring (second word) 0 5)) (helper (rest word) (substring (second\
    \ word) 0 5))]\n      [(equal? (first word) (substring (second word) 0 6)) (helper\
    \ (rest word) (substring (second word) 0 6))]\n      [(equal? (first word) (substring\
    \ (second word) 0 7)) (helper (rest word) (substring (second word) 0 7))]))\n\
    \  (helper (reverse word) 'u))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8oo249pj.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8oo249pj.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8oo249pj.rkt:34:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8oo249pj.rkt:35:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8oo249pj.rkt:36:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8oo249pj.rkt:37:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8oo249pj.rkt:38:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8oo249pj.rkt:39:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8oo249pj.rkt:40:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8oo249pj.rkt:41:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8oo249pj.rkt:42:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8oo249pj.rkt:43:4\n\
    \nreverse: contract violation\n  expected: list?"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u))\n             (vowels-count 0))\n    (cond ((null?\
    \ word) \"\")\n          ((member (car word) vowels) (car word))\n          ((member\
    \ (car word) vowels) (loop (cdr word) vowels vowels-count))\n          ((member\
    \ (car word) vowels-count) (loop (cdr word) vowels vowels-count))\n          (else\
    \ (loop (cdr word) vowels vowels-count)))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpscpl93xk.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpscpl93xk.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpscpl93xk.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpscpl93xk.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpscpl93xk.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpscpl93xk.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpscpl93xk.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpscpl93xk.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpscpl93xk.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpscpl93xk.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpscpl93xk.rkt:38:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpscpl93xk.rkt:39:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (let ((vowels '(a e i o u)))\n      (cond\n        ((null? word) \"\")\n \
    \       ((member (char-code (car word)) vowels) (car word))\n        (else (vowel-check\
    \ (cdr word)))))\n  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpb_9662_w.rkt:13:0: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 22\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel)\n\
    \    (cond [(string=? (vowel-check vowel) word) vowel]\n          [(string=? (vowel-check\
    \ vowel) (substring (word 0 -1))) vowel]\n          [else \"\"]))\n  (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check (vowel-check\
    \ (\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpfcs40pea.rkt:18:1497: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 19\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpifiq1l46.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpifiq1l46.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpifiq1l46.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpifiq1l46.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpifiq1l46.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpifiq1l46.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpifiq1l46.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpifiq1l46.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpifiq1l46.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpifiq1l46.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpifiq1l46.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel start\
    \ end)\n    (cond ((null? word) \"\")\n          ((equal? (char-code (car word))\
    \ vowel) (helper (cdr word) vowel (+ start 1) end))\n          ((equal? (char-code\
    \ (car word)) (substring (char word end) start)) (helper (cdr word) vowel start\
    \ (- end 1)))\n          (else (helper (cdr word) vowel (+ start 1) end))))\n\
    \  (helper word 'a '(length word) '(length word)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpov6_5xd6.rkt:16:20: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmpov6_5xd6.rkt:16:20\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let ((vowels '(a e i o u)))\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(member (car word) vowels) (car\
    \ word)]\n      [else (let ((vowel (find-vowel (cdr word) vowels)))\n        \
    \      (cond\n               [(empty? vowel) \"\"]\n               [(< vowel (car\
    \ word)) (cons (car word) vowels)]\n               [else (cons (car word) vowels)]\n\
    \               )])]\n      )))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpegjmra41.rkt:23:16: read-syntax: missing `)` to close `(` on line\
    \ 18, found instead `]`\n  context...:\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond\n      [(empty? word) empty]\n      [(equal? (first word) 'a) (equal?\
    \ (second word) 'u)]\n      [(equal? (first word) 'e) (equal? (second word) 'i)]\n\
    \      [(equal? (first word) 'o) (equal? (second word) 'u)]\n      [(equal? (first\
    \ word) 'u) (equal? (second word) 'i)]\n      [(equal? (first word) 'A) (equal?\
    \ (second word) 'U)]\n      [(equal? (first word) 'E) (equal? (second word) 'I)]\n\
    \      [(equal? (first word) 'O) (equal? (second word) 'U)]\n      [(equal? (first\
    \ word) 'U) (equal? (second word) 'I)]\n      [(equal? (first word) 'y) (equal?\
    \ (second word) 'u)]\n      [(equal? (first word) 'Y) (equal? (second word) 'U)]\n\
    \      [(equal? (first word) 'g) (equal? (second word) 'u)]\n      [(equal? (first\
    \ word) 'G) (equal? (second word) 'U)]\n      [(equal? (first word) 'r) (equal?\
    \ (second word) 'u)]\n      [(equal? (first word) 'R) (equal? (second word) 'U)]\n\
    \      [(equal? (first word) 'q) (equal? (second word) 'u)]\n      [(equal? (first\
    \ word) 'Q) (equal? (second word) 'U)]\n      [(equal? (first word) 'b) (equal?\
    \ (second word) 'u)]\n      [(equal? (first word) 'B) (equal? (second word) 'U)]\n\
    \      [(equal? (first word) 'f) (equal? (second word) 'u)]\n      [(equal? (first\
    \ word) 'F) (equal? (second word) 'U)]\n      [(equal? (first word) 's) (equal?\
    \ (second word) 'u)]\n      [(equal? (first word) 'S) (equal? (second word) 'U)]\n\
    \      [(equal? (first word) 't) (equal? (second word) 'u)]\n      [(equal? (first\
    \ word) 'T) (equal? (second word) 'U)]\n      [(equal? (first word) 'h) (equal?\
    \ (second word) 'u)]\n      [(equal? (first word) 'H) (equal? (second word) 'U)]\n\
    (require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp0b54dj5x.rkt:15:4: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 43\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search start end)\n\
    \    (cond [(= start end) \"\"]\n          [(char=? (char-code (substring word\
    \ start)) #\\a) (vowel-search start (+ start 1))]\n          [(char=? (char-code\
    \ (substring word start)) #\\e) (vowel-search start (+ start 1))]\n          [(char=?\
    \ (char-code (substring word start)) #\\i) (vowel-search start (+ start 1))]\n\
    \          [(char=? (char-code (substring word start)) #\\o) (vowel-search start\
    \ (+ start 1))]\n          [(char=? (char-code (substring word start)) #\\u) (vowel-search\
    \ start (+ start 1))]\n          [else (vowel-search start (+ start 1))]))\n \
    \ (vowel-search 0 (string-length word)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpeobudn38.rkt:16:20: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmpeobudn38.rkt:16:20\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond\n      [(empty? word) \"\"]\n     \
    \ [(member (first word) vowels) (first word)]\n      [else (loop (rest word) (cons\
    \ (first word) vowels))])))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp9fdsu2t7.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp9fdsu2t7.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp9fdsu2t7.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp9fdsu2t7.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp9fdsu2t7.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp9fdsu2t7.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp9fdsu2t7.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp9fdsu2t7.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp9fdsu2t7.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp9fdsu2t7.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp9fdsu2t7.rkt:36:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond\n      [(empty? word) \"\"]\n     \
    \ [(member (first word) vowels) (first word)]\n      [else (loop (rest word) (cons\
    \ (first word) vowels))])))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpippr15ep.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpippr15ep.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpippr15ep.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpippr15ep.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpippr15ep.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpippr15ep.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpippr15ep.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpippr15ep.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpippr15ep.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpippr15ep.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpippr15ep.rkt:36:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ count)\n    (cond ((null? word) \"\")\n          ((char=? (char-code (car word))\
    \ vowel) \n           (helper (cdr word) vowel (+ index 1) count))\n         \
    \ ((char=? (char-code (car word)) #\\A) \n           (helper (cdr word) vowel\
    \ (+ index 1) count))\n          ((char=? (char-code (car word)) #\\z) \n    \
    \       (helper (cdr word) vowel (+ index 1) count))\n          ((char=? (char-code\
    \ (car word)) #\\E) \n           (helper (cdr word) vowel (+ index 1) count))\n\
    \          ((char=? (char-code (car word)) #\\I) \n           (helper (cdr word)\
    \ vowel (+ index 1) count))\n          ((char=? (char-code (car word)) #\\O) \n\
    \           (helper (cdr word) vowel (+ index 1) count))\n          ((char=? (char-code\
    \ (car word)) #\\U) \n           (helper (cdr word) vowel (+ index 1) count))\n\
    \          ((char=? (char-code (car word)) #\\a) \n           (helper (cdr word)\
    \ vowel (+ index 1) count))\n          ((char=? (char-code (car word)) #\\e) \n\
    \           (helper (cdr word) vowel (+ index 1) count))\n          ((char=? (char-code\
    \ (car word)) #\\i) \n           (helper (cdr word) vowel (+ index 1) count))\n\
    \          ((char=? (char-code (car word)) #\\o) \n           (helper (cdr word)\
    \ vowel (+ index 1) count))\n          ((char=? (char-code (car word)) #\\u) \n\
    \           (helper (cdr word) vowel (+ index 1) count))\n          ((char=? (char-code\
    \ (car word)) #\\U) \n           (helper (cdr word) vowel (+ index 1) count))\n\
    \          ((char=? (char-code (car word)) #\\U) \n           (helper (cdr word)\
    \ vowel (+ index 1) count))\n          ((char=? (char-code (car word)) #\\U) \n\
    \           (helper (cdr word) vowel (+ index 1) count))\n          ((char=? (char-code\
    \ (car word)) #\\U) \n           (helper (cdr word) vowel (+ index 1) count))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpta3nkk41.rkt:15:4: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 49\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond\n      [(string=? vowel word) vowel]\n      [else (vowel-check (cdr\
    \ vowel) word)])\n  (vowel-check (car word) word))\n  \n  (define (vowel-check\
    \ vowel word)\n    (cond\n      [(string=? vowel word) vowel]\n      [else (vowel-check\
    \ (cdr vowel) word)])\n  (vowel-check (car word) word))\n  \n  (define (vowel-check\
    \ vowel word)\n    (cond\n      [(string=? vowel word) vowel]\n      [else (vowel-check\
    \ (cdr vowel) word)])\n  (vowel-check (car word) word))\n  \n  (define (vowel-check\
    \ vowel word)\n    (cond\n      [(string=? vowel word) vowel]\n      [else (vowel-check\
    \ (cdr vowel) word)])\n  (vowel-check (car word) word))\n  \n  (define (vowel-check\
    \ vowel word)\n    (cond\n      [(string=? vowel word) vowel]\n      [else (vowel-check\
    \ (cdr vowel) word)])\n  (vowel-check (car word) word))\n  \n  (define (vowel-check\
    \ vowel word)\n    (cond\n      [(string=? vowel word) vowel]\n      [else (vowel-check\
    \ (cdr vowel) word)])\n  (vowel-check (car word) word))\n  \n  (define (vowel-check\
    \ vowel word)\n    (cond\n      [(string=? vowel word) vowel]\n      [else (vowel-check\
    \ (cdr vowel) word)])\n  (vowel-check (car word) word))\n  \n  (define (vowel-check\
    \ vowel word)\n    (cond\n      [(string=? vowel word) vowel]\n      [else (vowel-check\
    \ (cdr vowel) word)])\n  (vowel-check (car word) word))\n  \n  (define (vowel-check\
    \ vowel word)\n    (cond\n      [(string=? vowel word) vowel]\n      [else (vowel-check\
    \ (cdr vowel) word)])\n  (vowel-check (car word) word))\n  \n  (define (vowel-check\
    \ vowel word)\n    (cond\n      [(string=? vowel word) vowel]\n      [else (vowel-check\
    \ (cdr vowel\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpmj1h2w0w.rkt:71:25: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 72\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((member\
    \ (char-code (car word)) vowels) (car word))\n          ((member (char-code (cadr\
    \ word)) vowels) (cadr word))\n          ((member (char-code (caddr word)) vowels)\
    \ (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp45jq818m.rkt:41:19: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 42\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((member\
    \ (car word) vowels) (car word))\n          ((member (cdr word) vowels) (cdr word))\n\
    \          ((member (car word) vowels) (loop (cdr word) vowels))\n          ((member\
    \ (cdr word) vowels) (loop (car word) vowels))\n          (else (loop (cdr word)\
    \ (cons (car word) vowels))))))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbp7tlzt.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbp7tlzt.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbp7tlzt.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbp7tlzt.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbp7tlzt.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbp7tlzt.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbp7tlzt.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbp7tlzt.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbp7tlzt.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbp7tlzt.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbp7tlzt.rkt:38:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkbp7tlzt.rkt:39:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word)) (vowel-check\
    \ vowel (rest word))]\n      [else (vowel-check vowel (rest word))]\n    ))\n\
    \  (vowel-check (first word) (substring (last word) 0 (- (length word) 1)))\n\
    )\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpq38e7hop.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpq38e7hop.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpq38e7hop.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpq38e7hop.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpq38e7hop.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpq38e7hop.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpq38e7hop.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpq38e7hop.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpq38e7hop.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpq38e7hop.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpq38e7hop.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel)\n\
    \    (cond [(empty? word) \"\"]\n          [(char=? (first word) vowel) (helper\
    \ (rest word) vowel)]\n          [else (helper (rest word) (first vowel))]))\n\
    \  (helper word 'a))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpnpm_c_gd.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpnpm_c_gd.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpnpm_c_gd.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpnpm_c_gd.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpnpm_c_gd.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpnpm_c_gd.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpnpm_c_gd.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpnpm_c_gd.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpnpm_c_gd.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpnpm_c_gd.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpnpm_c_gd.rkt:35:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (vowel-check\
    \ (rest word))]\n          [(char=? (first word) 'e) (vowel-check (rest word))]\n\
    \          [(char=? (first word) 'i) (vowel-check (rest word))]\n          [(char=?\
    \ (first word) 'o) (vowel-check (rest word))]\n          [(char=? (first word)\
    \ 'u) (vowel-check (rest word))]\n          [else (vowel-check (rest word))]\n\
    \          ))\n  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbvbqqkxt.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbvbqqkxt.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbvbqqkxt.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbvbqqkxt.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbvbqqkxt.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbvbqqkxt.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbvbqqkxt.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbvbqqkxt.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbvbqqkxt.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbvbqqkxt.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbvbqqkxt.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((member\
    \ (car word) vowels) (car word))\n          ((member (cdr word) vowels) (cdr word))\n\
    \          ((member (car word) vowels) (loop (cdr word) vowels))\n          ((member\
    \ (cdr word) vowels) (loop (car word) vowels))\n          (else (loop (cdr word)\
    \ vowels)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\"\
    )\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptjjh_v22.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptjjh_v22.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptjjh_v22.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptjjh_v22.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptjjh_v22.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptjjh_v22.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptjjh_v22.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptjjh_v22.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptjjh_v22.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptjjh_v22.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptjjh_v22.rkt:38:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptjjh_v22.rkt:39:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word) (vowels\
    \ '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((member (char-code\
    \ (car word)) vowels) (car word))\n          ((member (char-code (cadr word))\
    \ vowels) (cadr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp3_3osxwv.rkt:40:19: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 41\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((vowels '(a e i o u))\n\
    \             (word word))\n    (cond ((null? word) \"\")\n          ((member\
    \ (char-code (car word)) vowels) (car word))\n          ((member (char-code (cadr\
    \ word)) vowels) (cadr word))\n          ((member (char-code (caddr word)) vowels)\
    \ (caddr word))\n          ((member (char-code (cadddr word)) vowels) (cadddr\
    \ word))\n          ((member (char-code (car word)) vowels) (car word))\n    \
    \      ((member (char-code (cadr word)) vowels) (cadr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (cadddr word)) vowels) (cadddr word))\n          ((member (char-code (car word))\
    \ vowels) (car word))\n          ((member (char-code (cadr word)) vowels) (cadr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (cadddr word)) vowels) (cadddr word))\n       \
    \   ((member (char-code (car word)) vowels) (car word))\n          ((member (char-code\
    \ (cadr word)) vowels) (cadr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (cadddr word)) vowels)\
    \ (cadddr word))\n          ((member (char-code (car word)) vowels) (car word))\n\
    \          ((member (char-code (cadr word)) vowels) (cadr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (cadddr word)) vowels) (cadddr word))\n          ((member (char-code (car word))\
    \ vowels) (car word))\n          ((member (char-code (cadr word)) vowels) (cadr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (cadddr word)) vowels) (cadddr word))\n       \
    \   ((\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp58pjbqxc.rkt:41:11: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 42\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (vowel-check\
    \ (rest word))]\n          [(char=? (first word) 'e) (vowel-check (rest word))]\n\
    \          [(char=? (first word) 'i) (vowel-check (rest word))]\n          [(char=?\
    \ (first word) 'o) (vowel-check (rest word))]\n          [(char=? (first word)\
    \ 'u) (vowel-check (rest word))]\n          [else (vowel-check (rest word))]))\n\
    \  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp17zw8ktu.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp17zw8ktu.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp17zw8ktu.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp17zw8ktu.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp17zw8ktu.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp17zw8ktu.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp17zw8ktu.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp17zw8ktu.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp17zw8ktu.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp17zw8ktu.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp17zw8ktu.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u))\n             (vowel-count 0))\n    (cond ((null?\
    \ word) \"\")\n          ((member (char-code (car word)) vowels) (loop (cdr word)\
    \ vowels vowel-count))\n          ((< vowel-count (length vowels)) (loop (cdr\
    \ word) vowels (+ vowel-count 1)))\n          (else (loop (cdr word) vowels (+\
    \ vowel-count 1))))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp5d2ldgy0.rkt:18:20: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmp5d2ldgy0.rkt:18:20\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond [(empty? word) \"\"]\n          [(equal? (first word) vowel) (vowel-check\
    \ vowel (rest word))]\n          [else (vowel-check (first word) (rest word))]))\n\
    \  (vowel-check (first word) (rest word)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfwwtgdjk.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfwwtgdjk.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfwwtgdjk.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfwwtgdjk.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfwwtgdjk.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfwwtgdjk.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfwwtgdjk.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfwwtgdjk.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfwwtgdjk.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfwwtgdjk.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfwwtgdjk.rkt:35:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search start end)\n\
    \    (cond [(= start end) \"\"]\n          [(char-before? (char-code start) 'a)\
    \ (vowel-search (+ start 1) end)]\n          [(char-before? (char-code start)\
    \ 'e) (vowel-search (+ start 1) end)]\n          [(char-before? (char-code start)\
    \ 'i) (vowel-search (+ start 1) end)]\n          [(char-before? (char-code start)\
    \ 'o) (vowel-search (+ start 1) end)]\n          [(char-before? (char-code start)\
    \ 'u) (vowel-search (+ start 1) end)]\n          [else (vowel-search (+ start\
    \ 1) end)]\n          ))\n  (vowel-search 0 (string-length word)))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpvcugy0co.rkt:16:12: char-before?: unbound identifier\n  in: char-before?\n\
    \  location...:\n   /tmp/tmpvcugy0co.rkt:16:12\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search vowel word)\n\
    \    (cond [(empty? word) \"\"]\n          [(char=? (car word) vowel) vowel]\n\
    \          [(char=? (car word) (cadr word)) (vowel-search (car word) (cdr word))]\n\
    \          [else (vowel-search (car word) (cdr word))]))\n  (vowel-search (car\
    \ word) (cdr word)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdgiq48d.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdgiq48d.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdgiq48d.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdgiq48d.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdgiq48d.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdgiq48d.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdgiq48d.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdgiq48d.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdgiq48d.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdgiq48d.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdgiq48d.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgdgiq48d.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpb238k2oz.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb238k2oz.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb238k2oz.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb238k2oz.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb238k2oz.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb238k2oz.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb238k2oz.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb238k2oz.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb238k2oz.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpb238k2oz.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpb238k2oz.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpy2t5_giy.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy2t5_giy.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy2t5_giy.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy2t5_giy.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy2t5_giy.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy2t5_giy.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy2t5_giy.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy2t5_giy.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy2t5_giy.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpy2t5_giy.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpy2t5_giy.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ count)\n    (cond ((null? word) \"\")\n          ((char=? (car word) vowel)\
    \ (car word))\n          ((char=? (car word) (cdr word)) (helper (cdr word) vowel\
    \ (+ index 1) count))\n          ((char=? (car word) (car word)) (helper (cdr\
    \ word) vowel (+ index 1) count))\n          ((char=? (car word) (cdr word)) (helper\
    \ (cdr word) vowel (+ index 1) count))\n          (else (helper (cdr word) vowel\
    \ (+ index 1) count))\n          ))\n  (helper word 'a '0 0))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioqueaxe.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioqueaxe.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioqueaxe.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioqueaxe.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioqueaxe.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioqueaxe.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioqueaxe.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioqueaxe.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioqueaxe.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioqueaxe.rkt:38:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioqueaxe.rkt:39:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpioqueaxe.rkt:40:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search start end)\n\
    \    (cond [(null? start) \"\"]\n          [(char=? (char-code (char start end))\
    \ #\\a) (vowel-search (cdr start) end)]\n          [(char=? (char-code (char start\
    \ end)) #\\e) (vowel-search (cdr start) end)]\n          [(char=? (char-code (char\
    \ start end)) #\\i) (vowel-search (cdr start) end)]\n          [(char=? (char-code\
    \ (char start end)) #\\o) (vowel-search (cdr start) end)]\n          [(char=?\
    \ (char-code (char start end)) #\\u) (vowel-search (cdr start) end)]\n       \
    \   [else (vowel-search (cdr start) (min end (+ start 1)))]\n          ))\n  (vowel-search\
    \ word (length word)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp7_dum462.rkt:16:20: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmp7_dum462.rkt:16:20\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpugbuyiyl.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpugbuyiyl.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpugbuyiyl.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpugbuyiyl.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpugbuyiyl.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpugbuyiyl.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpugbuyiyl.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpugbuyiyl.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpugbuyiyl.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpugbuyiyl.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpugbuyiyl.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search start end)\n\
    \    (cond ((null? start) (null? end))\n          ((char=? (char-code (car start))\
    \ #\\a) (vowel-search (cdr start) end))\n          ((char=? (char-code (car end))\
    \ #\\a) (vowel-search (cdr start) (cdr end)))\n          ((char=? (char-code (car\
    \ start)) #\\e) (vowel-search (cdr start) (cdr end)))\n          ((char=? (char-code\
    \ (car end)) #\\e) (vowel-search (cdr start) (cdr end)))\n          ((char=? (char-code\
    \ (car start)) #\\i) (vowel-search (cdr start) (cdr end)))\n          ((char=?\
    \ (char-code (car end)) #\\i) (vowel-search (cdr start) (cdr end)))\n        \
    \  ((char=? (char-code (car start)) #\\o) (vowel-search (cdr start) (cdr end)))\n\
    \          ((char=? (char-code (car end)) #\\o) (vowel-search (cdr start) (cdr\
    \ end)))\n          ((char=? (char-code (car start)) #\\u) (vowel-search (cdr\
    \ start) (cdr end)))\n          ((char=? (char-code (car end)) #\\u) (vowel-search\
    \ (cdr start) (cdr end)))\n          (else (vowel-search (cdr start) (cdr end)))))\n\
    \  (vowel-search word (substring (length word) 1)))\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpw79py7cd.rkt:16:20: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmpw79py7cd.rkt:16:20\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? (first word) vowel) (second\
    \ word)]\n      [(equal? (first word) (substring (second word) 0 1)) (helper (rest\
    \ word) (first vowel))]\n      [(equal? (first word) (substring (second word)\
    \ 0 2)) (helper (rest word) (first vowel))]\n      [(equal? (first word) (substring\
    \ (second word) 0 3)) (helper (rest word) (first vowel))]\n      [(equal? (first\
    \ word) (substring (second word) 0 4)) (helper (rest word) (first vowel))]\n \
    \     [(equal? (first word) (substring (second word) 0 5)) (helper (rest word)\
    \ (first vowel))]\n      [(equal? (first word) (substring (second word) 0 6))\
    \ (helper (rest word) (first vowel))]\n      [(equal? (first word) (substring\
    \ (second word) 0 7)) (helper (rest word) (first vowel))]\n      [(equal? (first\
    \ word) (substring (second word) 0 8)) (helper (rest word) (first vowel))]\n \
    \     [(equal? (first word) (substring (second word) 0 9)) (helper (rest word)\
    \ (first vowel))]\n      [(equal? (first word) (substring (second word) 0 10))\
    \ (helper (rest word) (first vowel))]\n      [(equal? (first word) (substring\
    \ (second word) 0 11)) (helper (rest word) (first vowel))]\n      [(equal? (first\
    \ word) (substring (second word) 0 12)) (helper (rest word) (first vowel))]\n\
    \      [(equal? (first word) (substring (second word) 0 13)) (helper (rest word)\
    \ (first vowel))]\n      [(equal? (first word) (substring (second word) 0 14))\
    \ (helper (rest word) (first vowel))]\n      [(equal? (first word) (substring\
    \ (second word) 0 15)) (helper (rest word) (first vowel))]\n      [(equal? (first\
    \ word) (substring (second word) 0 16)) (helper (rest word) (first vowel))]\n\
    \      [(equal? (first word) (substring (second word) 0 17)) (helper (rest word)\
    \ (first vowel))]\n      [(equal? (first word) (substring (second word) 0 18))\
    \ (helper (rest word) (first vowel))]\n      [(equal? (first word) (substring\
    \ (second word) 0 19)) (helper (rest word) (first vowel))]\n      [(equal? (first\
    \ word\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpx461sucs.rkt:37:15: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 38\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond [(empty? word) \"\"]\n          [(member\
    \ (first word) vowels) (first word)]\n          [else (loop (rest word) (cons\
    \ (first word) vowels))])))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpk0v7_cjn.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpk0v7_cjn.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpk0v7_cjn.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpk0v7_cjn.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpk0v7_cjn.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpk0v7_cjn.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpk0v7_cjn.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpk0v7_cjn.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpk0v7_cjn.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpk0v7_cjn.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpk0v7_cjn.rkt:35:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search start end)\n\
    \    (cond ((= end start) \"\")\n          ((char=? (char-code (char word start))\
    \ (char #\\a)) (vowel-search (+ start 1) end))\n          ((char=? (char-code\
    \ (char word start)) (char #\\e)) (vowel-search (+ start 1) (+ end 1)))\n    \
    \      ((char=? (char-code (char word start)) (char #\\i)) (vowel-search (+ start\
    \ 1) (+ end 1)))\n          ((char=? (char-code (char word start)) (char #\\o))\
    \ (vowel-search (+ start 1) (+ end 1)))\n          ((char=? (char-code (char word\
    \ start)) (char #\\u)) (vowel-search (+ start 1) (+ end 1)))\n          ((char=?\
    \ (char-code (char word start)) (char #\\y)) (vowel-search (+ start 1) (+ end\
    \ 1)))\n          ((char=? (char-code (char word start)) (char #\\h)) (vowel-search\
    \ (+ start 1) (+ end 1)))\n          ((char=? (char-code (char word start)) (char\
    \ #\\y)) (vowel-search (+ start 1) (+ end 1)))\n          ((char=? (char-code\
    \ (char word start)) (char #\\i)) (vowel-search (+ start 1) (+ end 1)))\n    \
    \      ((char=? (char-code (char word start)) (char #\\o)) (vowel-search (+ start\
    \ 1) (+ end 1)))\n          ((char=? (char-code (char word start)) (char #\\u))\
    \ (vowel-search (+ start 1) (+ end 1)))\n          ((char=? (char-code (char word\
    \ start)) (char #\\y)) (vowel-search (+ start 1) (+ end 1)))\n          ((char=?\
    \ (char-code (char word start)) (char #\\h)) (vowel-search (+ start 1) (+ end\
    \ 1)))\n          ((char=? (char-code (char word start)) (char #\\y)) (vowel-search\
    \ (+ start 1) (+ end 1)))\n          ((char=? (char-code (char word start)) (char\
    \ #\\i)) (vowel-search (+ start 1) (+ end 1)))\n          ((char=? (char-code\
    \ (char word start)) (char \n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpi3s3gnwv.rkt:31:49: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 32\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search start end)\n\
    \    (cond [(< start end) (empty)]\n          [(char=? (char-code (substring word\
    \ start)) #\\a) (cons (char-code (substring word start)) vowel-search (+ start\
    \ 1))]\n          [(char=? (char-code (substring word start)) #\\e) (cons (char-code\
    \ (substring word start)) vowel-search (+ start 1))]\n          [(char=? (char-code\
    \ (substring word start)) #\\i) (cons (char-code (substring word start)) vowel-search\
    \ (+ start 1))]\n          [(char=? (char-code (substring word start)) #\\o) (cons\
    \ (char-code (substring word start)) vowel-search (+ start 1))]\n          [(char=?\
    \ (char-code (substring word start)) #\\u) (cons (char-code (substring word start))\
    \ vowel-search (+ start 1))]\n          [else (vowel-search (+ start 1) end)]\n\
    \          ))\n  (vowel-search 0 0))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpxlkj0pmz.rkt:16:20: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmpxlkj0pmz.rkt:16:20\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel vowel-index\
    \ vowel-count)\n    (cond ((null? word) \"\")\n          ((equal? vowel (car word))\
    \ vowel)\n          ((equal? (car word) vowel) (helper (cdr word) vowel (+ vowel-index\
    \ 1) vowel-count))\n          (else (helper (cdr word) vowel (+ vowel-index 1)\
    \ vowel-count))))\n  (helper word 'a '0 0))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6mx72s5k.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6mx72s5k.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6mx72s5k.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6mx72s5k.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6mx72s5k.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6mx72s5k.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6mx72s5k.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6mx72s5k.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6mx72s5k.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6mx72s5k.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6mx72s5k.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6mx72s5k.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel)\n\
    \    (cond ((null? word) \"\")\n          ((char=? (car word) vowel) vowel)\n\
    \          ((char=? (car word) (cdr word)) (helper (cdr word) vowel))\n      \
    \    (else (helper (cdr word) vowel))))\n  (helper word 'u))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp4x40dx5.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp4x40dx5.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp4x40dx5.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp4x40dx5.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp4x40dx5.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp4x40dx5.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp4x40dx5.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp4x40dx5.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp4x40dx5.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp4x40dx5.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp4x40dx5.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpp4x40dx5.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpfqp3teul.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmpfqp3teul.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (let loop ((vowels '(a e i o u))\n               (vowel-count 0))\n      (cond\
    \ ((null? word) \"\")\n            ((char=? (car word) (car vowels)) \n      \
    \       (loop (cdr vowels) (+ vowel-count 1)))\n            (else (loop (cdr vowels)\
    \ vowel-count)))))\n  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4peaqdg7.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4peaqdg7.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4peaqdg7.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4peaqdg7.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4peaqdg7.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4peaqdg7.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4peaqdg7.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4peaqdg7.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4peaqdg7.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4peaqdg7.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4peaqdg7.rkt:38:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp4peaqdg7.rkt:39:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpgn1uyo3_.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgn1uyo3_.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgn1uyo3_.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgn1uyo3_.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgn1uyo3_.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgn1uyo3_.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgn1uyo3_.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgn1uyo3_.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgn1uyo3_.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpgn1uyo3_.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpgn1uyo3_.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp7z18_p62.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmp7z18_p62.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbe5a6grn.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbe5a6grn.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbe5a6grn.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbe5a6grn.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbe5a6grn.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbe5a6grn.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbe5a6grn.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbe5a6grn.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbe5a6grn.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbe5a6grn.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbe5a6grn.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let ((vowels '(a e i o u)))\n\
    \    (cond ((empty? word) \"\")\n          ((equal? (first word) 'a) (first vowels))\n\
    \          ((equal? (first word) 'e) (first vowels))\n          ((equal? (first\
    \ word) 'i) (first vowels))\n          ((equal? (first word) 'o) (first vowels))\n\
    \          ((equal? (first word) 'u) (first vowels))\n          ((equal? (first\
    \ word) 'A) (first vowels))\n          ((equal? (first word) 'E) (first vowels))\n\
    \          ((equal? (first word) 'I) (first vowels))\n          ((equal? (first\
    \ word) 'O) (first vowels))\n          ((equal? (first word) 'U) (first vowels))\n\
    \          (else (error \"Invalid input\")))))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpelqtco2u.rkt:33:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpelqtco2u.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpelqtco2u.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpelqtco2u.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpelqtco2u.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpelqtco2u.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpelqtco2u.rkt:39:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpelqtco2u.rkt:40:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpelqtco2u.rkt:41:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpelqtco2u.rkt:42:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpelqtco2u.rkt:43:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search word vowel)\n\
    \    (cond [(empty? word) \"\"]\n          [(char=? (first word) vowel) vowel]\n\
    \          [(char=? (second word) vowel) vowel]\n          [else (vowel-search\
    \ (rest word) vowel)]))\n  (vowel-search word 'u))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzgw7jpy3.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzgw7jpy3.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzgw7jpy3.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzgw7jpy3.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzgw7jpy3.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzgw7jpy3.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzgw7jpy3.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzgw7jpy3.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzgw7jpy3.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzgw7jpy3.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzgw7jpy3.rkt:36:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ count)\n    (cond\n      [(empty? word) \"\"]\n      [(equal? (first word) vowel)\
    \ (helper (rest word) vowel (+ index 1) count)]\n      [(equal? (first word) (substring\
    \ vowel 0 1)) (helper (rest word) (substring vowel 0 1) (+ index 1) count)]\n\
    \      [(equal? (first word) (substring vowel 0 2)) (helper (rest word) (substring\
    \ vowel 0 2) (+ index 1) count)]\n      [(equal? (first word) (substring vowel\
    \ 0 3)) (helper (rest word) (substring vowel 0 3) (+ index 1) count)]\n      [(equal?\
    \ (first word) (substring vowel 0 4)) (helper (rest word) (substring vowel 0 4)\
    \ (+ index 1) count)]\n      [(equal? (first word) (substring vowel 0 5)) (helper\
    \ (rest word) (substring vowel 0 5) (+ index 1) count)]\n      [(equal? (first\
    \ word) (substring vowel 0 6)) (helper (rest word) (substring vowel 0 6) (+ index\
    \ 1) count)]\n      [(equal? (first word) (substring vowel 0 7)) (helper (rest\
    \ word) (substring vowel 0 7) (+ index 1) count)]\n      [(equal? (first word)\
    \ (substring vowel 0 8)) (helper (rest word) (substring vowel 0 8) (+ index 1)\
    \ count)]\n      [(equal? (first word) (substring vowel 0 9)) (helper (rest word)\
    \ (substring vowel 0 9) (+ index 1) count)]\n      [(equal? (first word) (substring\
    \ vowel 0 10)) (helper (rest word) (substring vowel 0 10) (+ index 1) count)]\n\
    \      [(equal? (first word) (substring vowel 0 11)) (helper (rest word) (substring\
    \ vowel 0 11) (+ index 1) count)]\n      [(equal? (first word) (substring vowel\
    \ 0 12)) (helper (rest word) (substring vowel 0 12) (+ index 1) count)]\n    \
    \  [(equal? (first word) (substring vowel 0 13)) (helper (rest word) (substring\
    \ vowel 0 13) (+ index 1) count)]\n      [(equal? (first word) (substring vowel\
    \ 0 14)) (helper (rest word) (substring vowel 0 14) (+ index 1) count)]\n    \
    \  [(equal? (first word) (sub\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmplqn3areq.rkt:32:28: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 33\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel)\n\
    \    (cond ((null? word) \"\")\n          ((char=? (car word) vowel) vowel)\n\
    \          ((char=? (car word) (cdr word)) (helper (cdr word) vowel))\n      \
    \    (else (helper (cdr word) vowel))))\n  (helper word 'u))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi3jcf5sh.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi3jcf5sh.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi3jcf5sh.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi3jcf5sh.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi3jcf5sh.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi3jcf5sh.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi3jcf5sh.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi3jcf5sh.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi3jcf5sh.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi3jcf5sh.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi3jcf5sh.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpi3jcf5sh.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel)\n\
    \    (cond\n      [(char=? (char-code vowel) 97) (char=? (char-code vowel) 65)]\n\
    \      [(char=? (char-code vowel) 65) (char=? (char-code vowel) 97)]\n      [else\
    \ (vowel-check vowel)]))\n  (define (consonant-check consonant)\n    (cond\n \
    \     [(char=? (char-code consonant) 97) (char=? (char-code consonant) 65)]\n\
    \      [(char=? (char-code consonant) 65) (char=? (char-code consonant) 97)]\n\
    \      [else (consonant-check consonant)]))\n  (define (vowel-check vowel)\n \
    \   (cond\n      [(char=? (char-code vowel) 97) (char=? (char-code vowel) 65)]\n\
    \      [(char=? (char-code vowel) 65) (char=? (char-code vowel) 97)]\n      [else\
    \ (vowel-check vowel)]))\n  (define (consonant-check consonant)\n    (cond\n \
    \     [(char=? (char-code consonant) 97) (char=? (char-code consonant) 65)]\n\
    \      [(char=? (char-code consonant) 65) (char=? (char-code consonant) 97)]\n\
    \      [else (consonant-check consonant)]))\n  (define (vowel-check vowel)\n \
    \   (cond\n      [(char=? (char-code vowel) 97) (char=? (char-code vowel) 65)]\n\
    \      [(char=? (char-code vowel) 65) (char=? (char-code vowel) 97)]\n      [else\
    \ (vowel-check vowel)]))\n  (define (consonant-check consonant)\n    (cond\n \
    \     [(char=? (char-code consonant) 97) (char=? (char-code consonant) 65)]\n\
    \      [(char=? (char-code consonant) 65) (char=? (char-code consonant) 97)]\n\
    \      [else (consonant-check consonant)]))\n  (define (vowel-check vowel)\n \
    \   (cond\n      [(char=? (char-code vowel) 97) (char=? (char-code vowel) 65)]\n\
    \      [(char=? (char-code vowel) 65) (char=? (char-code vowel) 97\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpcxhsckc3.rkt:47:37: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 48\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((vowels '(a e i o u))\
    \ (word word) (vowel null))\n    (cond ((null? word) vowel)\n          ((char=?\
    \ (car word) (car vowels)) (loop (cdr vowels) (cdr word) (car vowel)))\n     \
    \     (else (loop (cdr vowels) (cdr word) vowel)))))\n\n(require rackunit)\n\n\
    (define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzzftv_yn.rkt:24:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzzftv_yn.rkt:25:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzzftv_yn.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzzftv_yn.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzzftv_yn.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzzftv_yn.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzzftv_yn.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzzftv_yn.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzzftv_yn.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzzftv_yn.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzzftv_yn.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzzftv_yn.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search vowel word\
    \ index)\n    (cond ((null? word) \"\")\n          ((char=? (car word) vowel)\
    \ (car word))\n          ((char=? (car word) (cdr word)) (vowel-search (cdr word)\
    \ word (cdr index)))\n          ((char=? (car word) (cdr word)) (vowel-search\
    \ (cdr word) word (cdr index)))\n          (else (vowel-search (cdr word) word\
    \ (cdr index))))\n  (vowel-search 'a word 0))\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpn8hq5azf.rkt:13:0: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 21\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? (first word) vowel) (second\
    \ word)]\n      [else (helper (rest word) (cons (first word) vowel))]\n      ))\n\
    \  (helper word '()))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp43o99_u2.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp43o99_u2.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp43o99_u2.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp43o99_u2.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp43o99_u2.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp43o99_u2.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp43o99_u2.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp43o99_u2.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp43o99_u2.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp43o99_u2.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp43o99_u2.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbh18yi3k.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbh18yi3k.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbh18yi3k.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbh18yi3k.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbh18yi3k.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbh18yi3k.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbh18yi3k.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbh18yi3k.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbh18yi3k.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbh18yi3k.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbh18yi3k.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search vowel word)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? (first word) vowel) (vowel-search\
    \ vowel (rest word))]\n      [else (vowel-search vowel (rest word))]))\n  (vowel-search\
    \ vowel (reverse word)))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp90z99odl.rkt:19:16: vowel: unbound identifier\n  in: vowel\n  location...:\n\
    \   /tmp/tmp90z99odl.rkt:19:16\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (vowel-check\
    \ (rest word))]\n          [(char=? (first word) 'e) (vowel-check (rest word))]\n\
    \          [(char=? (first word) 'i) (vowel-check (rest word))]\n          [(char=?\
    \ (first word) 'o) (vowel-check (rest word))]\n          [(char=? (first word)\
    \ 'u) (vowel-check (rest word))]\n          [else (vowel-check (rest word))]))\n\
    \  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpj6_hyaa4.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpj6_hyaa4.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpj6_hyaa4.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpj6_hyaa4.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpj6_hyaa4.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpj6_hyaa4.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpj6_hyaa4.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpj6_hyaa4.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpj6_hyaa4.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpj6_hyaa4.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpj6_hyaa4.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond ((null? word) \"\")\n          ((equal? (char-code vowel) (char-code\
    \ (car word))) (vowel-check vowel (cdr word)))\n          (else (vowel-check vowel\
    \ (cdr word))))\n  (vowel-check 'a word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpkdd2a0q4.rkt:13:0: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 20\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word vowel)\n\
    \    (cond ((null? word) \"\")\n          ((char=? (car word) vowel) vowel)\n\
    \          (else (vowel-check (cdr word) vowel))))\n  (vowel-check word 'a))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp97jdl909.rkt:25:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp97jdl909.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp97jdl909.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp97jdl909.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp97jdl909.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp97jdl909.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp97jdl909.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp97jdl909.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp97jdl909.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp97jdl909.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp97jdl909.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp97jdl909.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1rvw_ygd.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp1rvw_ygd.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp1rvw_ygd.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp1rvw_ygd.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp1rvw_ygd.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp1rvw_ygd.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp1rvw_ygd.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp1rvw_ygd.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp1rvw_ygd.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp1rvw_ygd.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp1rvw_ygd.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ count)\n    (cond ((null? word) \"\")\n          ((equal? (char-code (car word))\
    \ (char vowel)) (helper (cdr word) vowel (+ index 1) count))\n          ((equal?\
    \ (char-code (car word)) (char vowel)) (helper (cdr word) vowel (+ index 1) count))\n\
    \          ((equal? (char-code (car word)) (char vowel)) (helper (cdr word) vowel\
    \ (+ index 1) count))\n          ((equal? (char-code (car word)) (char vowel))\
    \ (helper (cdr word) vowel (+ index 1) count))\n          ((equal? (char-code\
    \ (car word)) (char vowel)) (helper (cdr word) vowel (+ index 1) count))\n   \
    \       ((equal? (char-code (car word)) (char vowel)) (helper (cdr word) vowel\
    \ (+ index 1) count))\n          ((equal? (char-code (car word)) (char vowel))\
    \ (helper (cdr word) vowel (+ index 1) count))\n          ((equal? (char-code\
    \ (car word)) (char vowel)) (helper (cdr word) vowel (+ index 1) count))\n   \
    \       ((equal? (char-code (car word)) (char vowel)) (helper (cdr word) vowel\
    \ (+ index 1) count))\n          ((equal? (char-code (car word)) (char vowel))\
    \ (helper (cdr word) vowel (+ index 1) count))\n          ((equal? (char-code\
    \ (car word)) (char vowel)) (helper (cdr word) vowel (+ index 1) count))\n   \
    \       ((equal? (char-code (car word)) (char vowel)) (helper (cdr word) vowel\
    \ (+ index 1) count))\n          ((equal? (char-code (car word)) (char vowel))\
    \ (helper (cdr word) vowel (+ index 1) count))\n          ((equal? (char-code\
    \ (car word)) (char vowel)) (helper (cdr word) vowel (+ index 1) count))\n   \
    \       ((equal? (char-code (car word)) (char vowel)) (helper (cdr word) vowel\
    \ (+ index 1) count))\n          ((equal? (char-code (car word)) (char vowel))\
    \ (helper (cdr word) vowel (+ index 1) count))\n          ((equal? (char-code\
    \ (car word)) (char vowel)) (helper (cdr word) vowel (+ index 1) count))\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpec0gazax.rkt:15:4: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 33\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word) (vowels\
    \ '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((char=? (car word)\
    \ 'a) (loop (cdr word) (cons vowels 'a)))\n          ((char=? (car word) 'e) (loop\
    \ (cdr word) (cons vowels 'e)))\n          ((char=? (car word) 'i) (loop (cdr\
    \ word) (cons vowels 'i)))\n          ((char=? (car word) 'o) (loop (cdr word)\
    \ (cons vowels 'o)))\n          ((char=? (car word) 'u) (loop (cdr word) (cons\
    \ vowels 'u)))\n          (else (loop (cdr word) (cons vowels (car word)))))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpktk783vl.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpktk783vl.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpktk783vl.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpktk783vl.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpktk783vl.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpktk783vl.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpktk783vl.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpktk783vl.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpktk783vl.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpktk783vl.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpktk783vl.rkt:38:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpktk783vl.rkt:39:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond [(empty? word) \"\"]\n          [(equal? (first word) vowel) (vowel-check\
    \ vowel (rest word))]\n          [else (vowel-check (first word) (rest word))]))\n\
    \  (vowel-check (first word) (rest word)))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmprq_izq8_.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprq_izq8_.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprq_izq8_.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprq_izq8_.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprq_izq8_.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprq_izq8_.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprq_izq8_.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprq_izq8_.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprq_izq8_.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmprq_izq8_.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmprq_izq8_.rkt:35:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpb92ion61.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmpb92ion61.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (vowel-check\
    \ (rest word))]\n          [(char=? (first word) 'e) (vowel-check (rest word))]\n\
    \          [(char=? (first word) 'i) (vowel-check (rest word))]\n          [(char=?\
    \ (first word) 'o) (vowel-check (rest word))]\n          [(char=? (first word)\
    \ 'u) (vowel-check (rest word))]\n          [else (vowel-check (rest word))]))\n\
    \  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpn_4vh7qq.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpn_4vh7qq.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpn_4vh7qq.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpn_4vh7qq.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpn_4vh7qq.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpn_4vh7qq.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpn_4vh7qq.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpn_4vh7qq.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpn_4vh7qq.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpn_4vh7qq.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpn_4vh7qq.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search vowel word\
    \ index)\n    (cond ((null? word) \"\")\n          ((char=? (car word) vowel)\
    \ \n           (vowel-search vowel (cdr word) (+ index 1)))\n          ((char=?\
    \ (car word) (cdr word)) \n           (vowel-search vowel (cdr word) (+ index\
    \ 1)))\n          (else (vowel-search vowel (cdr word) (+ index 1)))))\n  (vowel-search\
    \ 'a '(cons word '()) 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph45ggc7h.rkt:28:4\n\
    \nchar=?: contract violation\n  expected: char?\n  given: 'cons\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph45ggc7h.rkt:29:4\n\
    \nchar=?: contract violation\n  expected: char?\n  given: 'cons\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph45ggc7h.rkt:30:4\n\
    \nchar=?: contract violation\n  expected: char?\n  given: 'cons\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph45ggc7h.rkt:31:4\n\
    \nchar=?: contract violation\n  expected: char?\n  given: 'cons\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph45ggc7h.rkt:32:4\n\
    \nchar=?: contract violation\n  expected: char?\n  given: 'cons\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph45ggc7h.rkt:33:4\n\
    \nchar=?: contract violation\n  expected: char?\n  given: 'cons\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph45ggc7h.rkt:34:4\n\
    \nchar=?: contract violation\n  expected: char?\n  given: 'cons\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph45ggc7h.rkt:35:4\n\
    \nchar=?: contract violation\n  expected: char?\n  given: 'cons\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph45ggc7h.rkt:36:4\n\
    \nchar=?: contract violation\n  expected: char?\n  given: 'cons\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph45ggc7h.rkt:37:4\n\
    \nchar=?: contract violation\n  expected: char?\n  given: 'cons\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph45ggc7h.rkt:38:4\n\
    \nchar=?: contract violation\n  expected: char?\n  given: 'cons\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmph45ggc7h.rkt:39:4\n\
    \nchar=?: contract violation\n  expected: char?\n  given: 'cons\n-----"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel start\
    \ end)\n    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word))\
    \ (first word)]\n      [(equal? (first word) vowel) (first word)]\n      [(equal?\
    \ (first word) (first vowel)) (first word)]\n      [(equal? (first word) (first\
    \ vowel) (first start)) (first word)]\n      [(equal? (first word) (first vowel)\
    \ (first start) (first end)) (first word)]\n      [(equal? (first word) (first\
    \ vowel) (first start) (first end) (first start)) (first word)]\n      [(equal?\
    \ (first word) (first vowel) (first start) (first end) (first end)) (first word)]\n\
    \      [(equal? (first word) (first vowel) (first start) (first end) (first end)\
    \ (first start)) (first word)]\n      [(equal? (first word) (first vowel) (first\
    \ start) (first end) (first end) (first end)) (first word)]\n      [(equal? (first\
    \ word) (first vowel) (first start) (first end) (first end) (first end) (first\
    \ start)) (first word)]\n      [(equal? (first word) (first vowel) (first start)\
    \ (first end) (first end) (first end) (first end)) (first word)]\n      [(equal?\
    \ (first word) (first vowel) (first start) (first end) (first end) (first end)\
    \ (first end) (first start)) (first word)]\n      [(equal? (first word) (first\
    \ vowel) (first start) (first end) (first end) (first end) (first end) (first\
    \ end) (first start)) (first word)]\n      [(equal? (first word) (first vowel)\
    \ (first start) (first end) (first end) (first end) (first end) (first end) (first\
    \ end) (first start)) (first word)]\n      [(equal? (first word) (first vowel)\
    \ (first start) (first end) (first end) (first end) (first end) (first end) (first\
    \ end) (first end) (first start)) (first word)]\n      [(equal? (first word) (first\
    \ vowel) (first start) (first end) (first end) (first end) (first end) (first\
    \ end) (first end) (first end) (first end) (first start)) (first word)]\n    \
    \  [(equal? (first word) (first vowel) (first start) (first end) (first end) (first\
    \ end) (first end) (first end) (first end) (first end) (first end) (first end)\
    \ (first start)) (first word)]\n      [(equal? (\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpd4v5i5o_.rkt:34:15: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 35\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search word vowel)\n\
    \    (cond [(empty? word) \"\"]\n          [(equal? (first word) vowel) (vowel-search\
    \ (rest word) vowel)]\n          [else (vowel-search (rest word) (cons (first\
    \ word) vowel))]))\n  (vowel-search word 'u))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpux6_4p4p.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpux6_4p4p.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpux6_4p4p.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpux6_4p4p.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpux6_4p4p.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpux6_4p4p.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpux6_4p4p.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpux6_4p4p.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpux6_4p4p.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpux6_4p4p.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpux6_4p4p.rkt:35:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((member\
    \ (char-code (car word)) vowels) (car word))\n          ((member (char-code (cadr\
    \ word)) vowels) (cadr word))\n          ((member (char-code (caddr word)) vowels)\
    \ (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmplj5r1nkv.rkt:41:19: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 42\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpoz9jzcqa.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoz9jzcqa.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoz9jzcqa.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoz9jzcqa.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoz9jzcqa.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoz9jzcqa.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoz9jzcqa.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoz9jzcqa.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoz9jzcqa.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpoz9jzcqa.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpoz9jzcqa.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond\n      [(empty? word) empty]\n      [(equal? vowel (first word)) vowel]\n\
    \      [else (vowel-check (rest word) (first word))]\n    ))\n  (vowel-check (first\
    \ word) (substring (second word) 0 (- (length word) 1)))\n)\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8sdtqh88.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8sdtqh88.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8sdtqh88.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8sdtqh88.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8sdtqh88.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8sdtqh88.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8sdtqh88.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8sdtqh88.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8sdtqh88.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8sdtqh88.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8sdtqh88.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index)\n\
    \    (cond\n      [(null? word) \"\"]\n      [(equal? vowel (car word)) (helper\
    \ (cdr word) vowel (+ index 1))]\n      [else (helper (cdr word) vowel (+ index\
    \ 1))]))\n  (helper (reverse word) (car word) 0))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjmb78njp.rkt:26:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjmb78njp.rkt:27:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjmb78njp.rkt:28:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjmb78njp.rkt:29:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjmb78njp.rkt:30:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjmb78njp.rkt:31:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjmb78njp.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjmb78njp.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjmb78njp.rkt:34:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjmb78njp.rkt:35:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjmb78njp.rkt:36:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpjmb78njp.rkt:37:4\n\
    \nreverse: contract violation\n  expected: list?"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp9zg06czh.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmp9zg06czh.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpn7oy9spf.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmpn7oy9spf.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n \
    \       [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \        [else (first word)]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3ab48m4.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpv3ab48m4.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3ab48m4.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpv3ab48m4.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3ab48m4.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpv3ab48m4.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3ab48m4.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpv3ab48m4.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3ab48m4.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpv3ab48m4.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpv3ab48m4.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp52_rr7u1.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmp52_rr7u1.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (char-after (char-before (char-after word) 'a) 'a) 'a) 'a]\n \
    \   [(equal? (char-after (char-before (char-after word) 'a) 'a) 'e) 'e]\n    [(equal?\
    \ (char-after (char-before (char-after word) 'a) 'a) 'i) 'i]\n    [(equal? (char-after\
    \ (char-before (char-after word) 'a) 'a) 'o) 'o]\n    [(equal? (char-after (char-before\
    \ (char-after word) 'a) 'a) 'u) 'u]\n    [(equal? (char-after (char-before (char-after\
    \ word) 'a) 'a) 'A) 'A]\n    [(equal? (char-after (char-before (char-after word)\
    \ 'a) 'a) 'E) 'E]\n    [(equal? (char-after (char-before (char-after word) 'a)\
    \ 'a) 'I) 'I]\n    [(equal? (char-after (char-before (char-after word) 'a) 'a)\
    \ 'O) 'O]\n    [(equal? (char-after (char-before (char-after word) 'a) 'a) 'U)\
    \ 'U]\n    [else \"\"]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp58_lklls.rkt:16:14: char-after: unbound identifier\n  in: char-after\n\
    \  location...:\n   /tmp/tmp58_lklls.rkt:16:14\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? (first word) vowel) (second\
    \ word)]\n      [else (helper (rest word) (cons (first word) vowel))]\n      ))\n\
    \  (helper word '()))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n \
    \ (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfsufwpum.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfsufwpum.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfsufwpum.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfsufwpum.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfsufwpum.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfsufwpum.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfsufwpum.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfsufwpum.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfsufwpum.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfsufwpum.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfsufwpum.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond\n      [(empty? word) \"\"]\n      [(char=? (first word) 'a) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'e) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'i) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'o) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'u) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [else (vowel-check (rest word))]))\n\
    \  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptc7vh079.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptc7vh079.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptc7vh079.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptc7vh079.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptc7vh079.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptc7vh079.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptc7vh079.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptc7vh079.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptc7vh079.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptc7vh079.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptc7vh079.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0pzzqy4.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw0pzzqy4.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0pzzqy4.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw0pzzqy4.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0pzzqy4.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw0pzzqy4.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0pzzqy4.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw0pzzqy4.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0pzzqy4.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpw0pzzqy4.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpw0pzzqy4.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ count)\n    (cond [(null? word) \"\"]\n          [(equal? (char-code (car word))\
    \ (char vowel)) (helper (cdr word) vowel (+ index 1) count)]\n          [(equal?\
    \ (char-code (car word)) (char vowel)) (helper (cdr word) vowel (+ index 1) count)]\n\
    \          [(equal? (char-code (car word)) (char vowel)) (helper (cdr word) vowel\
    \ (+ index 1) count)]\n          [else (helper (cdr word) vowel (+ index 1) count)]))\n\
    \  (helper word 'a 0 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp8utx98u1.rkt:16:20: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmp8utx98u1.rkt:16:20\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search vowel word\
    \ index)\n    (cond [(null? word) \"\"]\n          [(char=? (char-code vowel)\
    \ (char-code (substring word index (+ index 1)))) vowel]\n          [else (vowel-search\
    \ (substring vowel 1) word (+ index 1))]))\n  (vowel-search (char-code (substring\
    \ word 0 (- (length word) 1))) word 0))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpt88n1hoo.rkt:16:20: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmpt88n1hoo.rkt:16:20\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n \
    \       [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \        [else (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpubbrli2a.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpubbrli2a.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpubbrli2a.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpubbrli2a.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpubbrli2a.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpubbrli2a.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpubbrli2a.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpubbrli2a.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpubbrli2a.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpubbrli2a.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpubbrli2a.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel vowel-index\
    \ vowel-count)\n    (cond [(vowel-index vowel-count) vowel]\n          [(vowel-index\
    \ (- vowel-count 1)) \"\"]\n          [else (helper (substring word vowel-index\
    \ vowel-count) (cons vowel vowels) (+ vowel-index 1) vowel-count)]))\n  (helper\
    \ word #\\A 0 0))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let\
    \ (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"\
    u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpe5f4ckqc.rkt:17:77: vowels: unbound identifier\n  in: vowels\n\
    \  location...:\n   /tmp/tmpe5f4ckqc.rkt:17:77\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ count)\n    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word))\
    \ (if (< count 1) (first word) \"\")]\n      [(equal? (first word) vowel) (if\
    \ (< count 1) (first word) \"\")]\n      [(equal? (first word) (first vowel))\
    \ (if (< count 1) (first word) \"\")]\n      [(equal? (first word) (first vowel)\
    \ (first word)) (if (< count 1) (first word) \"\")]\n      [(equal? (first word)\
    \ (first vowel) (first word) (first vowel)) (if (< count 2) (first word) \"\"\
    )]\n      [(equal? (first word) (first vowel) (first word) (first vowel) (first\
    \ word)) (if (< count 3) (first word) \"\")]\n      [(equal? (first word) (first\
    \ vowel) (first word) (first vowel) (first word) (first vowel)) (if (< count 4)\
    \ (first word) \"\")]\n      [(equal? (first word) (first vowel) (first word)\
    \ (first vowel) (first word) (first vowel) (first word)) (if (< count 5) (first\
    \ word) \"\")]\n      [(equal? (first word) (first vowel) (first word) (first\
    \ vowel) (first word) (first vowel) (first word) (first vowel)) (if (< count 6)\
    \ (first word) \"\")]\n      [(equal? (first word) (first vowel) (first word)\
    \ (first vowel) (first word) (first vowel) (first word) (first vowel) (first word))\
    \ (if (< count 7) (first word) \"\")]\n      [(equal? (first word) (first vowel)\
    \ (first word) (first vowel) (first word) (first vowel) (first word) (first vowel)\
    \ (first word) (first vowel)) (if (< count 8) (first word) \"\")]\n      [(equal?\
    \ (first word) (first vowel) (first word) (first vowel) (first word) (first vowel)\
    \ (first word) (first vowel) (first word) (first vowel) (first word)) (if (< count\
    \ 9) (first word) \"\")]\n      [(equal? (first word) (first vowel) (first word)\
    \ (first vowel) (first word) (first vowel) (first word) (first vowel) (first word)\
    \ (first vowel) (first word) (first vowel) (first word)) (if (< count 10) (first\
    \ word) \"\")]\n      [(equal? (first word) (first vowel) (first word) (first\
    \ vowel) (first word) (first vowel) (first word) (first vowel) (first word) (first\
    \ vowel) (first word) (first vowel\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpb3vydjm8.rkt:30:163: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 31\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word vowel)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word)) (vowel-check\
    \ (rest word) vowel)]\n      [else (vowel-check (rest word) vowel)]))\n  (vowel-check\
    \ word \"a\"))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\"\
    )\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpwv7ss1a5.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwv7ss1a5.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwv7ss1a5.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwv7ss1a5.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwv7ss1a5.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwv7ss1a5.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwv7ss1a5.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwv7ss1a5.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwv7ss1a5.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpwv7ss1a5.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpwv7ss1a5.rkt:36:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u))\n             (vowel-count 0))\n    (cond ((null?\
    \ word) \"\")\n          ((member (car word) vowels) (car word))\n          ((member\
    \ (cdr word) vowels) (car word))\n          ((member (car word) vowels) (cdr word))\n\
    \          ((member (cdr word) vowels) (cdr word))\n          ((member (car word)\
    \ vowels) (cdr word))\n          ((member (cdr word) vowels) (cdr word))\n   \
    \       ((member (car word) vowels) (cdr word))\n          ((member (cdr word)\
    \ vowels) (cdr word))\n          ((member (car word) vowels) (cdr word))\n   \
    \       ((member (cdr word) vowels) (cdr word))\n          ((member (car word)\
    \ vowels) (cdr word))\n          ((member (cdr word) vowels) (cdr word))\n   \
    \       ((member (car word) vowels) (cdr word))\n          ((member (cdr word)\
    \ vowels) (cdr word))\n          ((member (car word) vowels) (cdr word))\n   \
    \       ((member (cdr word) vowels) (cdr word))\n          ((member (car word)\
    \ vowels) (cdr word))\n          ((member (cdr word) vowels) (cdr word))\n   \
    \       ((member (car word) vowels) (cdr word))\n          ((member (cdr word)\
    \ vowels) (cdr word))\n          ((member (car word) vowels) (cdr word))\n   \
    \       ((member (cdr word) vowels) (cdr word))\n          ((member (car word)\
    \ vowels) (cdr word))\n          ((member (cdr word) vowels) (cdr word))\n   \
    \       ((member (car word) vowels) (cdr word))\n          ((member (cdr word)\
    \ vowels) (cdr word))\n          ((member (car word) vowels) (cdr word))\n   \
    \       ((member (cdr word) vowels) (cdr word))\n          ((member (car word)\
    \ vowels) (cdr word))\n          ((member (cdr word) vowels) (cdr word))\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpd53iki8r.rkt:17:4: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 48\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpldincwp3.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpldincwp3.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpldincwp3.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpldincwp3.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpldincwp3.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpldincwp3.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpldincwp3.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpldincwp3.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpldincwp3.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpldincwp3.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpldincwp3.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp5d5i9y_8.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmp5d5i9y_8.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpvuxgf5o4.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvuxgf5o4.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvuxgf5o4.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvuxgf5o4.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvuxgf5o4.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvuxgf5o4.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvuxgf5o4.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvuxgf5o4.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvuxgf5o4.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpvuxgf5o4.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpvuxgf5o4.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpupp9ur9w.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmpupp9ur9w.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpmi83cnko.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmpmi83cnko.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search start end)\n\
    \    (cond ((null? start) (null? end))\n          ((char=? (char-code (car start))\
    \ (char #\\a)) (vowel-search (cdr start) end))\n          ((char=? (char-code\
    \ (car end)) (char #\\a)) (vowel-search (cdr start) (cdr end)))\n          ((char=?\
    \ (char-code (car start)) (char #\\e)) (vowel-search (cdr start) (cdr end)))\n\
    \          ((char=? (char-code (car end)) (char #\\e)) (vowel-search (cdr start)\
    \ (cdr end)))\n          ((char=? (char-code (car start)) (char #\\i)) (vowel-search\
    \ (cdr start) (cdr end)))\n          ((char=? (char-code (car end)) (char #\\\
    i)) (vowel-search (cdr start) (cdr end)))\n          ((char=? (char-code (car\
    \ start)) (char #\\o)) (vowel-search (cdr start) (cdr end)))\n          ((char=?\
    \ (char-code (car end)) (char #\\o)) (vowel-search (cdr start) (cdr end)))\n \
    \         ((char=? (char-code (car start)) (char #\\u)) (vowel-search (cdr start)\
    \ (cdr end)))\n          ((char=? (char-code (car end)) (char #\\u)) (vowel-search\
    \ (cdr start) (cdr end)))\n          (else (vowel-search (cdr start) (cdr end))))\n\
    \  (vowel-search (reverse word) (reverse word)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpi6tlmmss.rkt:13:0: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 29\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let ((vowels '(a e i o u)))\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(member (car word) vowels) (car\
    \ word)]\n      [else (get-closest-vowel (cdr word) vowels)])))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpk6w8b1jw.rkt:18:13: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmpk6w8b1jw.rkt:18:13\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond ((null? word) \"\")\n          ((char=? (car word) vowel) vowel)\n\
    \          ((char=? (car word) (cdr word)) (vowel-check (cdr word) word))\n  \
    \        (else (vowel-check (cdr word) word))))\n  (vowel-check (car word) word))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxptcrt5o.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxptcrt5o.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxptcrt5o.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxptcrt5o.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxptcrt5o.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxptcrt5o.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxptcrt5o.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxptcrt5o.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxptcrt5o.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxptcrt5o.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxptcrt5o.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpxptcrt5o.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel vowel-index\
    \ vowel-count)\n    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first\
    \ word)) vowel]\n      [(equal? (first word) vowel) (helper (rest word) vowel\
    \ (+ vowel-index 1) vowel-count)]\n      [(equal? (first word) (first word)) (helper\
    \ (rest word) (first word) vowel-index vowel-count)]\n      [(equal? (first word)\
    \ (first word) (first word)) (helper (rest word) (first word) (+ vowel-index 1)\
    \ vowel-count)]\n      [(equal? (first word) (first word) (first word) (first\
    \ word)) (helper (rest word) (first word) (+ vowel-index 1) (+ vowel-count 1))]\n\
    \      [(equal? (first word) (first word) (first word) (first word) (first word))\
    \ (helper (rest word) (first word) (first word) (+ vowel-index 1) (+ vowel-count\
    \ 1))]\n      [(equal? (first word) (first word) (first word) (first word) (first\
    \ word) (first word)) (helper (rest word) (first word) (first word) (first word)\
    \ (+ vowel-index 1) (+ vowel-count 1))]\n      [(equal? (first word) (first word)\
    \ (first word) (first word) (first word) (first word) (first word)) (helper (rest\
    \ word) (first word) (first word) (first word) (first word) (first word) (+ vowel-index\
    \ 1) (+ vowel-count 1))]\n      [(equal? (first word) (first word) (first word)\
    \ (first word) (first word) (first word) (first word) (first word)) (helper (rest\
    \ word) (first word) (first word) (first word) (first word) (first word) (first\
    \ word) (+ vowel-index 1) (+ vowel-count 1))]\n      [(equal? (first word) (first\
    \ word) (first word) (first word) (first word) (first word) (first word) (first\
    \ word) (first word)) (helper (rest word) (first word) (first word) (first word)\
    \ (first word) (first word) (first word) (first word) (first word) (+ vowel-index\
    \ 1) (+ vowel-count 1))]\n      [(equal? (first word) (first word) (first word)\
    \ (first word) (first word) (first word) (first word) (first word) (first word)\
    \ (first word)) (helper (rest word) (first word) (first word) (first word) (first\
    \ word) (first word) (first word) (first \n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmph4srojdg.rkt:27:244: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 28\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word) (vowels\
    \ '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((member (char-code\
    \ (car word)) vowels) (car word))\n          ((member (char-code (cadr word))\
    \ vowels) (cadr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-code (caddr word)) vowels) (caddr word))\n\
    \          ((member (char-code (caddr word)) vowels) (caddr word))\n         \
    \ ((member (char-code (caddr word)) vowels) (caddr word))\n          ((member\
    \ (char-code (caddr word)) vowels) (caddr word))\n          ((member (char-code\
    \ (caddr word)) vowels) (caddr word))\n          ((member (char-code (caddr word))\
    \ vowels) (caddr word))\n          ((member (char-code (caddr word)) vowels) (caddr\
    \ word))\n          ((member (char-\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp62caub35.rkt:40:19: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 41\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (cons (first\
    \ word) (vowel-check (rest word)))]\n          [(char=? (first word) 'e) (cons\
    \ (first word) (vowel-check (rest word)))]\n          [(char=? (first word) 'i)\
    \ (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first word)\
    \ 'o) (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first\
    \ word) 'u) (cons (first word) (vowel-check (rest word)))]\n          [else (vowel-check\
    \ (rest word))]))\n  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp_x61hz7i.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_x61hz7i.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_x61hz7i.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_x61hz7i.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_x61hz7i.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_x61hz7i.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_x61hz7i.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_x61hz7i.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_x61hz7i.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp_x61hz7i.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp_x61hz7i.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (cons (first\
    \ word) (vowel-check (rest word)))]\n          [(char=? (first word) 'e) (cons\
    \ (first word) (vowel-check (rest word)))]\n          [(char=? (first word) 'i)\
    \ (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first word)\
    \ 'o) (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first\
    \ word) 'u) (cons (first word) (vowel-check (rest word)))]\n          [else (vowel-check\
    \ (rest word))]))\n  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp5by4b7i_.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5by4b7i_.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5by4b7i_.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5by4b7i_.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5by4b7i_.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5by4b7i_.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5by4b7i_.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5by4b7i_.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5by4b7i_.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp5by4b7i_.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp5by4b7i_.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search vowel word)\n\
    \    (cond [(empty? word) \"\"]\n          [(equal? (first word) vowel) (vowel-search\
    \ vowel (rest word))]\n          [else (vowel-search (first vowel) (rest word))]))\n\
    \  (vowel-search 'a '(cons word '())))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6p1mjk8w.rkt:25:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ 'a\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6p1mjk8w.rkt:26:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: 'a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6p1mjk8w.rkt:27:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: 'a\n\
    --------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6p1mjk8w.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: 'a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6p1mjk8w.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: 'a\n\
    --------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6p1mjk8w.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: 'a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6p1mjk8w.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: 'a\n\
    --------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6p1mjk8w.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: 'a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6p1mjk8w.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: 'a\n\
    --------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6p1mjk8w.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: 'a\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6p1mjk8w.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c li"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp7qteq8vp.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7qteq8vp.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7qteq8vp.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7qteq8vp.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7qteq8vp.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7qteq8vp.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7qteq8vp.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7qteq8vp.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7qteq8vp.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp7qteq8vp.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp7qteq8vp.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-count vowel)\n\
    \    (cond\n      [(equal? vowel (first vowel)) (+ 1 (vowel-count (rest vowel)))]\n\
    \      [else 0]))\n  (define (vowel-count vowel count)\n    (cond\n      [(equal?\
    \ vowel (first vowel)) (+ count (vowel-count (rest vowel)))]\n      [else count]))\n\
    \  (define (vowel-count vowel count count)\n    (cond\n      [(equal? vowel (first\
    \ vowel)) (+ count (vowel-count (rest vowel) count))]\n      [else count]))\n\
    \  (define (vowel-count vowel count count count)\n    (cond\n      [(equal? vowel\
    \ (first vowel)) (+ count (vowel-count (rest vowel) count count))]\n      [else\
    \ count]))\n  (define (vowel-count vowel count count count count)\n    (cond\n\
    \      [(equal? vowel (first vowel)) (+ count (vowel-count (rest vowel) count\
    \ count count))]\n      [else count]))\n  (define (vowel-count vowel count count\
    \ count count count)\n    (cond\n      [(equal? vowel (first vowel)) (+ count\
    \ (vowel-count (rest vowel) count count count count))]\n      [else count]))\n\
    \  (define (vowel-count vowel count count count count count count)\n    (cond\n\
    \      [(equal? vowel (first vowel)) (+ count (vowel-count (rest vowel) count\
    \ count count count count))]\n      [else count]))\n  (define (vowel-count vowel\
    \ count count count count count count count)\n    (cond\n      [(equal? vowel\
    \ (first vowel)) (+ count (vowel-count (rest vowel) count count count count count\
    \ count))]\n      [else count]))\n  (define (vowel-count vowel count count count\
    \ count count count count count)\n    (cond\n      [(equal? vowel (first vowel))\
    \ (+ count (vowel-count (rest vowel) count count count count count count count))]\n\
    \      [else count]))\n  (define (vowel-count vowel count count count count count\
    \ count count count count)\n    (cond\n      [(equal? vowel (first vowel)) (+\
    \ count (vowel-count (rest vowel) count count count count count count count count\
    \ count))]\n      [else count]))\n  (define (vowel-count vowel count count count\
    \ count count count count count count count count)\n    (cond\n      [(equal?\
    \ vowel (first vowel)) (+ count (vowel-count (rest \n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp_nuwchd5.rkt:56:58: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 57\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond\n      [(empty? word) \"\"]\n      [(char=? (first word) 'a) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'e) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'i) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'o) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [(char=? (first word) 'u) (cons (first\
    \ word) (vowel-check (rest word)))]\n      [else (vowel-check (rest word))]))\n\
    \  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmps4sedqh8.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmps4sedqh8.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmps4sedqh8.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmps4sedqh8.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmps4sedqh8.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmps4sedqh8.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmps4sedqh8.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmps4sedqh8.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmps4sedqh8.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmps4sedqh8.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmps4sedqh8.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpb1t7i3ze.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmpb1t7i3ze.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n \
    \       [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \        [else (first word)]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp20nwhvlu.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp20nwhvlu.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp20nwhvlu.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp20nwhvlu.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp20nwhvlu.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp20nwhvlu.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp20nwhvlu.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp20nwhvlu.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp20nwhvlu.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp20nwhvlu.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp20nwhvlu.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel)\n\
    \    (cond\n      [(char=? (char-code vowel) 97) (char=? (char-code vowel) 65)]\n\
    \      [(char=? (char-code vowel) 65) (char=? (char-code vowel) 97)]\n      [else\
    \ (vowel-check vowel)]))\n  (define (consonant-check consonant)\n    (cond\n \
    \     [(char=? (char-code consonant) 97) (char=? (char-code consonant) 65)]\n\
    \      [(char=? (char-code consonant) 65) (char=? (char-code consonant) 97)]\n\
    \      [else (consonant-check consonant)]))\n  (define (vowel-check vowel)\n \
    \   (cond\n      [(char=? (char-code vowel) 97) (char=? (char-code vowel) 65)]\n\
    \      [(char=? (char-code vowel) 65) (char=? (char-code vowel) 97)]\n      [else\
    \ (vowel-check vowel)]))\n  (define (consonant-check consonant)\n    (cond\n \
    \     [(char=? (char-code consonant) 97) (char=? (char-code consonant) 65)]\n\
    \      [(char=? (char-code consonant) 65) (char=? (char-code consonant) 97)]\n\
    \      [else (consonant-check consonant)]))\n  (define (vowel-check vowel)\n \
    \   (cond\n      [(char=? (char-code vowel) 97) (char=? (char-code vowel) 65)]\n\
    \      [(char=? (char-code vowel) 65) (char=? (char-code vowel) 97)]\n      [else\
    \ (vowel-check vowel)]))\n  (define (consonant-check consonant)\n    (cond\n \
    \     [(char=? (char-code consonant) 97) (char=? (char-code consonant) 65)]\n\
    \      [(char=? (char-code consonant) 65) (char=? (char-code consonant) 97)]\n\
    \      [else (consonant-check consonant)]))\n  (define (vowel-check vowel)\n \
    \   (cond\n      [(char=? (char-code vowel) 97) (char=? (char-code vowel) 65)]\n\
    \      [(char=? (char-code vowel) 65) (char=? (char-code vowel) 97\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp_6ozm596.rkt:47:37: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 48\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((member\
    \ (car word) vowels) (car word))\n          ((member (cdr word) vowels) (cdr word))\n\
    \          (else (loop (cdr word) (cons (car word) vowels))))))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj2pda92.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj2pda92.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj2pda92.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj2pda92.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj2pda92.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj2pda92.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj2pda92.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj2pda92.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj2pda92.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj2pda92.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj2pda92.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpcj2pda92.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (get-closest-vowel (rest word))]))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpuyrl_gbl.rkt:21:11: get-closest-vowel: unbound identifier\n  in:\
    \ get-closest-vowel\n  location...:\n   /tmp/tmpuyrl_gbl.rkt:21:11\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((vowels '(a e i o u))\
    \ (word word))\n    (cond ((null? word) \"\")\n          ((char=? (car word) (car\
    \ vowels)) (car vowels))\n          ((char=? (car word) (cadr vowels)) (loop (cdr\
    \ vowels) (cdr word)))\n          ((char=? (car word) (caddr vowels)) (loop (cdr\
    \ vowels) (caddr word)))\n          ((char=? (car word) (cadddr vowels)) (loop\
    \ (cdr vowels) (cadddr word)))\n          (else (loop (cdr vowels) (cadddr word))))))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfhy7ryhl.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfhy7ryhl.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfhy7ryhl.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfhy7ryhl.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfhy7ryhl.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfhy7ryhl.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfhy7ryhl.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfhy7ryhl.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfhy7ryhl.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfhy7ryhl.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfhy7ryhl.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfhy7ryhl.rkt:38:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ vowels)\n    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first\
    \ vowels)) vowel]\n      [(equal? (first vowels) vowel) (helper (rest word) vowel\
    \ (+ index 1) vowels)]\n      [(equal? (first vowels) (first vowels)) (helper\
    \ (rest word) (first vowels) (+ index 1) vowels)]\n      [(equal? (first vowels)\
    \ (first vowels)) (helper (rest word) (first vowels) (+ index 1) vowels)]\n  \
    \    [(equal? (first vowels) (first vowels)) (helper (rest word) (first vowels)\
    \ (+ index 1) vowels)]\n      [(equal? (first vowels) (first vowels)) (helper\
    \ (rest word) (first vowels) (+ index 1) vowels)]\n      [(equal? (first vowels)\
    \ (first vowels)) (helper (rest word) (first vowels) (+ index 1) vowels)]\n  \
    \    [(equal? (first vowels) (first vowels)) (helper (rest word) (first vowels)\
    \ (+ index 1) vowels)]\n      [(equal? (first vowels) (first vowels)) (helper\
    \ (rest word) (first vowels) (+ index 1) vowels)]\n      [(equal? (first vowels)\
    \ (first vowels)) (helper (rest word) (first vowels) (+ index 1) vowels)]\n  \
    \    [(equal? (first vowels) (first vowels)) (helper (rest word) (first vowels)\
    \ (+ index 1) vowels)]\n      [(equal? (first vowels) (first vowels)) (helper\
    \ (rest word) (first vowels) (+ index 1) vowels)]\n      [(equal? (first vowels)\
    \ (first vowels)) (helper (rest word) (first vowels) (+ index 1) vowels)]\n  \
    \    [(equal? (first vowels) (first vowels)) (helper (rest word) (first vowels)\
    \ (+ index 1) vowels)]\n      [(equal? (first vowels) (first vowels)) (helper\
    \ (rest word) (first vowels) (+ index 1) vowels)]\n      [(equal? (first vowels)\
    \ (first vowels)) (helper (rest word) (first vowels) (+ index 1) vowels)]\n  \
    \    [(equal? (first vowels) (first vowels)) (helper (rest word) (first vowels)\
    \ (+ index 1) vowels)]\n      [(equal? (first vowels) (first vowels)) (helper\
    \ (rest word) (first vowels) (+ index 1) vowels)]\n      [(equal? (first vowels)\
    \ (first vowels)) (helper (rest word) (first vowels) (+ \n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpy9z4we78.rkt:35:81: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 36\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond\n      [(char=? (char-code vowel) 97) (char=? (char-code vowel) 65)]\n\
    \      [(char=? (char-code vowel) 65) (char=? (char-code vowel) 97)]\n      [else\
    \ (vowel-check vowel (substring word 0 (- (length word) 1)))]))\n  (vowel-check\
    \ (char-code (substring word 0 (- (length word) 1))) word))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpnjjfhu79.rkt:16:16: char-code: unbound identifier\n  in: char-code\n\
    \  location...:\n   /tmp/tmpnjjfhu79.rkt:16:16\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel vowels)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first vowels)) vowel]\n\
    \      [else (helper (rest word) (first vowels) vowels)]\n    ))\n  (helper word\
    \ (first '(a e i o u)) (vowels '(a e i o u)))\n)\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmprkp3of5u.rkt:20:37: vowels: unbound identifier\n  in: vowels\n\
    \  location...:\n   /tmp/tmprkp3of5u.rkt:20:37\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (cons (first\
    \ word) (vowel-check (rest word)))]\n          [(char=? (first word) 'e) (cons\
    \ (first word) (vowel-check (rest word)))]\n          [(char=? (first word) 'i)\
    \ (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first word)\
    \ 'o) (cons (first word) (vowel-check (rest word)))]\n          [(char=? (first\
    \ word) 'u) (cons (first word) (vowel-check (rest word)))]\n          [else (vowel-check\
    \ (rest word))]))\n  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm2kelu4z.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpm2kelu4z.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpm2kelu4z.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpm2kelu4z.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpm2kelu4z.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpm2kelu4z.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpm2kelu4z.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpm2kelu4z.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpm2kelu4z.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpm2kelu4z.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpm2kelu4z.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpfpnnuqko.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfpnnuqko.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfpnnuqko.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfpnnuqko.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfpnnuqko.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfpnnuqko.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfpnnuqko.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfpnnuqko.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfpnnuqko.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpfpnnuqko.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpfpnnuqko.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (char-after (char-before (char-after word)) #\\a) word) 'a]\n\
    \    [(equal? (char-after (char-before (char-after word)) #\\e) word) 'e]\n  \
    \  [(equal? (char-after (char-before (char-after word)) #\\i) word) 'i]\n    [(equal?\
    \ (char-after (char-before (char-after word)) #\\o) word) 'o]\n    [(equal? (char-after\
    \ (char-before (char-after word)) #\\u) word) 'u]\n    [else (error \"Not a vowel\"\
    )]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp8ua5jpgn.rkt:16:14: char-after: unbound identifier\n  in: char-after\n\
    \  location...:\n   /tmp/tmp8ua5jpgn.rkt:16:14\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbkacs_fp.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbkacs_fp.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbkacs_fp.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbkacs_fp.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbkacs_fp.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbkacs_fp.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbkacs_fp.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbkacs_fp.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbkacs_fp.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbkacs_fp.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbkacs_fp.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n \
    \       [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \        [else (first word)]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpufyl0n78.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpufyl0n78.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpufyl0n78.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpufyl0n78.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpufyl0n78.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpufyl0n78.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpufyl0n78.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpufyl0n78.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpufyl0n78.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpufyl0n78.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpufyl0n78.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond\n      [(empty? word) \"\"]\n      [(char-equal? (char-after (first\
    \ word) 'a) 'a) (char-after (first word) 'a)]\n      [(char-equal? (char-after\
    \ (first word) 'e) 'e) (char-after (first word) 'e)]\n      [(char-equal? (char-after\
    \ (first word) 'i) 'i) (char-after (first word) 'i)]\n      [(char-equal? (char-after\
    \ (first word) 'o) 'o) (char-after (first word) 'o)]\n      [(char-equal? (char-after\
    \ (first word) 'u) 'u) (char-after (first word) 'u)]\n      [else (vowel-check\
    \ (rest word))]))\n  (vowel-check (reverse word)))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpzf0sk6f6.rkt:17:8: char-equal?: unbound identifier\n  in: char-equal?\n\
    \  location...:\n   /tmp/tmpzf0sk6f6.rkt:17:8\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word)) (vowel-check\
    \ vowel (rest word))]\n      [(equal? (first word) vowel) (vowel-check (rest word)\
    \ vowel)]\n      [else (vowel-check (rest word) vowel)]))\n  (vowel-check (first\
    \ word) word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\"\
    )\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpg8mzgb8p.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpg8mzgb8p.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpg8mzgb8p.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpg8mzgb8p.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpg8mzgb8p.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpg8mzgb8p.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpg8mzgb8p.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpg8mzgb8p.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpg8mzgb8p.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpg8mzgb8p.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpg8mzgb8p.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond\n      [(empty? word) \"\"]\n     \
    \ [(member (car word) vowels) (car word)]\n      [else (loop (cdr word) (cons\
    \ (car word) vowels))]\n      )))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6uoy40qk.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6uoy40qk.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6uoy40qk.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6uoy40qk.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6uoy40qk.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6uoy40qk.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6uoy40qk.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6uoy40qk.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6uoy40qk.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6uoy40qk.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6uoy40qk.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6uoy40qk.rkt:38:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8nnqk_2k.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8nnqk_2k.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8nnqk_2k.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8nnqk_2k.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8nnqk_2k.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8nnqk_2k.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8nnqk_2k.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8nnqk_2k.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8nnqk_2k.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8nnqk_2k.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8nnqk_2k.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]\n  )\n)\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmplvad5u_c.rkt:30:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplvad5u_c.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplvad5u_c.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplvad5u_c.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplvad5u_c.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplvad5u_c.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplvad5u_c.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplvad5u_c.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplvad5u_c.rkt:38:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplvad5u_c.rkt:39:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplvad5u_c.rkt:40:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ count)\n    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word))\
    \ (if (> index count) \"\" vowel)]\n      [else (helper (rest word) (first word)\
    \ (+ index 1) count)]))\n  (helper (reverse word) 'u (length word) 0))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1tfqr0dk.rkt:26:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1tfqr0dk.rkt:27:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1tfqr0dk.rkt:28:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1tfqr0dk.rkt:29:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1tfqr0dk.rkt:30:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1tfqr0dk.rkt:31:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1tfqr0dk.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1tfqr0dk.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1tfqr0dk.rkt:34:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1tfqr0dk.rkt:35:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1tfqr0dk.rkt:36:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp1tfqr0dk.rkt:37:4\n\
    \nreverse: contract violation\n  expected: list?"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ count)\n    (cond\n      [(empty? word) \"\"]\n      [(equal? (first word) vowel)\
    \ (helper (rest word) vowel (+ index 1) count)]\n      [(equal? (first word) (substring\
    \ vowel (+ index 1))) (helper (rest word) (substring vowel (+ index 1)) count\
    \ (+ count 1))]\n      [else (helper (rest word) (substring vowel (+ index 1))\
    \ count (+ count 1))]))\n  (helper word 'a 0 0))\n\n(require rackunit)\n\n(define\
    \ (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmptgjfpmj2.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptgjfpmj2.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptgjfpmj2.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptgjfpmj2.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptgjfpmj2.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptgjfpmj2.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptgjfpmj2.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptgjfpmj2.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptgjfpmj2.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmptgjfpmj2.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmptgjfpmj2.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word)) (vowel-check\
    \ vowel (rest word))]\n      [else (vowel-check vowel (rest word))]\n      ))\n\
    \  (vowel-check (first word) (substring (second word) 0 (- (length word) 1)))\n\
    \  )\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmporezs9h2.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmporezs9h2.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmporezs9h2.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmporezs9h2.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmporezs9h2.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmporezs9h2.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmporezs9h2.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmporezs9h2.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmporezs9h2.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmporezs9h2.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmporezs9h2.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel index\
    \ count)\n    (cond ((null? word) \"\")\n          ((char=? (car word) vowel)\
    \ \n           (helper (cdr word) vowel (+ index 1) count))\n          ((char=?\
    \ (car word) (cdr word)) \n           (helper (cdr word) vowel (+ index 1) count))\n\
    \          ((char=? (car word) (car word)) \n           (helper (cdr word) vowel\
    \ (+ index 1) count))\n          ((char=? (car word) (cdr word)) \n          \
    \ (helper (cdr word) vowel (+ index 1) count))\n          (else (helper (cdr word)\
    \ vowel (+ index 1) count))\n          ))\n  (helper word 'u (length word) 0))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf83t5q8h.rkt:33:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf83t5q8h.rkt:34:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf83t5q8h.rkt:35:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf83t5q8h.rkt:36:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf83t5q8h.rkt:37:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf83t5q8h.rkt:38:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf83t5q8h.rkt:39:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf83t5q8h.rkt:40:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf83t5q8h.rkt:41:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf83t5q8h.rkt:42:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf83t5q8h.rkt:43:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpf83t5q8h.rkt:44:4\n\
    \nlength: contract violation\n  expected: list?\n  given: \"A"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond\n      [(empty? word) \"\"]\n     \
    \ [(member (first word) vowels) (first word)]\n      [else (loop (rest word) (cons\
    \ (first word) vowels))])))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp8a1341y7.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8a1341y7.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8a1341y7.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8a1341y7.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8a1341y7.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8a1341y7.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8a1341y7.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8a1341y7.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8a1341y7.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp8a1341y7.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp8a1341y7.rkt:36:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-finder start end)\n\
    \    (cond [(< end start) (empty-string)] \n          [(char=? (char-code (substring\
    \ word start)) #\\a) (substring word (+ start 1))]\n          [(char=? (char-code\
    \ (substring word end)) #\\a) (substring word (- end 1))]\n          [(char=?\
    \ (char-code (substring word start)) #\\e) (substring word (+ start 1))]\n   \
    \       [(char=? (char-code (substring word end)) #\\e) (substring word (- end\
    \ 1))]\n          [(char=? (char-code (substring word start)) #\\i) (substring\
    \ word (+ start 1))]\n          [(char=? (char-code (substring word end)) #\\\
    i) (substring word (- end 1))]\n          [(char=? (char-code (substring word\
    \ start)) #\\o) (substring word (+ start 1))]\n          [(char=? (char-code (substring\
    \ word end)) #\\o) (substring word (- end 1))]\n          [(char=? (char-code\
    \ (substring word start)) #\\u) (substring word (+ start 1))]\n          [(char=?\
    \ (char-code (substring word end)) #\\u) (substring word (- end 1))]\n       \
    \   [(char=? (char-code (substring word start)) #\\A) (substring word (+ start\
    \ 1))]\n          [(char=? (char-code (substring word end)) #\\A) (substring word\
    \ (- end 1))]\n          [(char=? (char-code (substring word start)) #\\E) (substring\
    \ word (+ start 1))]\n          [(char=? (char-code (substring word end)) #\\\
    E) (substring word (- end 1))]\n          [(char=? (char-code (substring word\
    \ start)) #\\I) (substring word (+ start 1))]\n          [(char=? (char-code (substring\
    \ word end)) #\\I) (substring word (- end 1))]\n          [(char=? (char-code\
    \ (substring word start)) #\\O) (substring word (+ start 1))]\n          [(char=?\
    \ (char-code (substring word end)) #\\O) (substring word (- end 1))]\n       \
    \   [(char\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp1_84crm0.rkt:34:11: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 35\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (cond [(empty? word) \"\"]\n          [(char=? (first word) 'a) (vowel-check\
    \ (rest word))]\n          [(char=? (first word) 'e) (vowel-check (rest word))]\n\
    \          [(char=? (first word) 'i) (vowel-check (rest word))]\n          [(char=?\
    \ (first word) 'o) (vowel-check (rest word))]\n          [(char=? (first word)\
    \ 'u) (vowel-check (rest word))]\n          [else (vowel-check (rest word))]))\n\
    \  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpbqerk8xw.rkt:29:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbqerk8xw.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbqerk8xw.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbqerk8xw.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbqerk8xw.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbqerk8xw.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbqerk8xw.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbqerk8xw.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbqerk8xw.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpbqerk8xw.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpbqerk8xw.rkt:39:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (first word)]))\n\n(require rackunit)\n\n(define (test-humaneval) \n\
    \n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp6wx9sy6z.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6wx9sy6z.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6wx9sy6z.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6wx9sy6z.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6wx9sy6z.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6wx9sy6z.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6wx9sy6z.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6wx9sy6z.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6wx9sy6z.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp6wx9sy6z.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp6wx9sy6z.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel vowels)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? (first word) vowel) (second\
    \ vowels)]\n      [(equal? (first word) (first vowels)) (second vowels)]\n   \
    \   [(equal? (first word) (first vowels)) (second vowels)]\n      [else (helper\
    \ (rest word) (first vowels) vowels)]\n    )\n  )\n  (helper word 'a '(a e i o\
    \ u))\n)\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpzbsvxwdf.rkt:31:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzbsvxwdf.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzbsvxwdf.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzbsvxwdf.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzbsvxwdf.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzbsvxwdf.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzbsvxwdf.rkt:37:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzbsvxwdf.rkt:38:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzbsvxwdf.rkt:39:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpzbsvxwdf.rkt:40:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpzbsvxwdf.rkt:41:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel)\n\
    \    (cond [(empty? word) \"\"]\n          [(equal? (first word) vowel) (second\
    \ word)]\n          [(equal? (second word) vowel) (third word)]\n          [(equal?\
    \ (third word) vowel) (fourth word)]\n          [(equal? (fourth word) vowel)\
    \ (fifth word)]\n          [(equal? (fifth word) vowel) (sixth word)]\n      \
    \    [(equal? (sixth word) vowel) (seventh word)]\n          [(equal? (seventh\
    \ word) vowel) (eighth word)]\n          [(equal? (eighth word) vowel) (tenth\
    \ word)]\n          [(equal? (tenth word) vowel) (eleventh word)]\n          [(equal?\
    \ (eleventh word) vowel) (twelfth word)]\n          [(equal? (twelfth word) vowel)\
    \ (thirteenth word)]\n          [(equal? (thirteenth word) vowel) (fourteenth\
    \ word)]\n          [(equal? (fourteenth word) vowel) (fifteenth word)]\n    \
    \      [(equal? (fifteenth word) vowel) (sixteenth word)]\n          [(equal?\
    \ (sixteenth word) vowel) (seventeenth word)]\n          [(equal? (seventeenth\
    \ word) vowel) (eighteenth word)]\n          [(equal? (eighteenth word) vowel)\
    \ (tenteenth word)]\n          [(equal? (tenteenth word) vowel) (eleventeenth\
    \ word)]\n          [(equal? (eleventeenth word) vowel) (twelveteenth word)]\n\
    \          [(equal? (twelveteenth word) vowel) (thirteenteenth word)]\n      \
    \    [(equal? (thirteenteenth word) vowel) (fourteenteenth word)]\n          [(equal?\
    \ (fourteenteenth word) vowel) (fifteenteenth word)]\n          [(equal? (fifteenteenth\
    \ word) vowel) (sixteenteenth word)]\n          [(equal? (sixteenteenteenth word)\
    \ vowel) (seventeenteenth word)]\n          [(equal? (seventeenteenth word) vowel)\
    \ (eighteenteenth word)]\n          [(equal? (eighteenteenth word) vowel) (tenteenteenth\
    \ word)]\n          [(equal? (tenteenteenth word) vowel) (eleventeenteenth word)]\n\
    \          [(equal? (eleventeenteenth word) vowel) (twelveteenteenth \n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpfz4udp1a.rkt:43:50: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 44\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond\n      [(string=? vowel (substring word 0 (string-length word)))\n\
    \       (substring word 0 (string-length word))]\n      [(string=? vowel (substring\
    \ word 0 (string-length word) 1))\n       (substring word 0 (string-length word)\
    \ 1)]\n      [(string=? vowel (substring word 0 (string-length word) 2))\n   \
    \    (substring word 0 (string-length word) 2)]\n      [(string=? vowel (substring\
    \ word 0 (string-length word) 3))\n       (substring word 0 (string-length word)\
    \ 3)]\n      [(string=? vowel (substring word 0 (string-length word) 4))\n   \
    \    (substring word 0 (string-length word) 4)]\n      [(string=? vowel (substring\
    \ word 0 (string-length word) 5))\n       (substring word 0 (string-length word)\
    \ 5)]\n      [(string=? vowel (substring word 0 (string-length word) 6))\n   \
    \    (substring word 0 (string-length word) 6)]\n      [(string=? vowel (substring\
    \ word 0 (string-length word) 7))\n       (substring word 0 (string-length word)\
    \ 7)]\n      [(string=? vowel (substring word 0 (string-length word) 8))\n   \
    \    (substring word 0 (string-length word) 8)]\n      [(string=? vowel (substring\
    \ word 0 (string-length word) 9))\n       (substring word 0 (string-length word)\
    \ 9)]\n      [else\n       (substring word 0 (string-length word) 0)]))\n  (cond\n\
    \    [(empty? word)\n     (substring word 0 (string-length word) 0)]\n    [(vowel-check\
    \ (substring word 0 (string-length word) 1) word)\n     (vowel-check (substring\
    \ word 0 (string-length word) 2) word)]\n    [(vowel-check (substring word 0 (string-length\
    \ word) 3) word)\n     (vowel-check (substring word 0 (string-length word) 4)\
    \ word)]\n    [(vowel-check (substring word 0 (string-length word) 5) word)\n\
    \     (vowel-check (substring word 0 (string-length word) 6) word)]\n    [(vowel-check\
    \ (substring word 0 (string-length word) 7) word)\n     (vowel-check (substring\
    \ word 0 (string-length word) 8) word)]\n    [(vowel-check (substring word 0 (string-length\
    \ word) 9) word)\n     (vowel-check (substring word 0 (string-length word) 10)\
    \ word)]\n    [else\n     (substring word \n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmp1t4_3d2m.rkt:52:5: read-syntax: expected a `)` to close `(`\n \
    \ possible cause: indentation suggests a missing `)` before line 53\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n \
    \       [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \        [else (first word)]))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp2h9m2qu8.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2h9m2qu8.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2h9m2qu8.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2h9m2qu8.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2h9m2qu8.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2h9m2qu8.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2h9m2qu8.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2h9m2qu8.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2h9m2qu8.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmp2h9m2qu8.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmp2h9m2qu8.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (char-after (char-before (char-after word)) #\\a) (char-after\
    \ (char-before (char-after word)) #\\e)) (char-after (char-before (char-after\
    \ word)) #\\u)]\n    [(equal? (char-after (char-before (char-after word)) #\\\
    e) (char-after (char-before (char-after word)) #\\i)) (char-after (char-before\
    \ (char-after word)) #\\u)]\n    [(equal? (char-after (char-before (char-after\
    \ word)) #\\i) (char-after (char-before (char-after word)) #\\o)) (char-after\
    \ (char-before (char-after word)) #\\u)]\n    [(equal? (char-after (char-before\
    \ (char-after word)) #\\o) (char-after (char-before (char-after word)) #\\u))\
    \ (char-after (char-before (char-after word)) #\\u)]\n    [(equal? (char-after\
    \ (char-before (char-after word)) #\\u) (char-after (char-before (char-after word))\
    \ #\\a)) (char-after (char-before (char-after word)) #\\u)]\n    [else \"\"]))\n\
    \n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpvc5jd_6q.rkt:16:14: char-after: unbound identifier\n  in: char-after\n\
    \  location...:\n   /tmp/tmpvc5jd_6q.rkt:16:14\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel)\n\
    \    (cond ((null? word) \"\")\n          ((char=? (car word) vowel) vowel)\n\
    \          ((char=? (car word) (cdr word)) (helper (cdr word) vowel))\n      \
    \    (else (helper (cdr word) vowel))))\n  (helper word 'u))\n\n(require rackunit)\n\
    \n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n    (check-equal?\
    \ (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\"\
    )\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal? (candidate\
    \ \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n    (check-equal?\
    \ (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n\
    \    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate \"ba\"\
    ) \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal? (candidate\
    \ \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal?\
    \ (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpucbqtih8.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpucbqtih8.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpucbqtih8.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpucbqtih8.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpucbqtih8.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpucbqtih8.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpucbqtih8.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpucbqtih8.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpucbqtih8.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpucbqtih8.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpucbqtih8.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpucbqtih8.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel i j)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? vowel (first word)) (first\
    \ word)]\n      [(equal? (first word) vowel) (first word)]\n      [(equal? (first\
    \ word) (substring (second word) i (- i j)))\n       (helper (substring (second\
    \ word) i (- i j)) vowel (+ i 1) (+ j 1))]\n      [(equal? (first word) (substring\
    \ (second word) (+ i 1) j))\n       (helper (substring (second word) (+ i 1) j)\
    \ vowel (+ i 1) (+ j 1))]\n      [(equal? (first word) (substring (second word)\
    \ i (+ j 1)))\n       (helper (substring (second word) i (+ j 1)) vowel (+ i 1)\
    \ (+ j 1))]\n      [(equal? (first word) (substring (second word) (+ i 1) (+ j\
    \ 1)))\n       (helper (substring (second word) (+ i 1) (+ j 1)) vowel (+ i 1)\
    \ (+ j 1))]\n      [(equal? (first word) (substring (second word) i (- j 1)))\n\
    \       (helper (substring (second word) i (- j 1)) vowel (+ i 1) (+ j 1))]\n\
    \      [(equal? (first word) (substring (second word) (- i 1) j))\n       (helper\
    \ (substring (second word) (- i 1) j) vowel (+ i 1) (+ j 1))]\n      [(equal?\
    \ (first word) (substring (second word) (- i 1) (+ j 1)))\n       (helper (substring\
    \ (second word) (- i 1) (+ j 1)) vowel (+ i 1) (+ j 1))]\n      [(equal? (first\
    \ word) (substring (second word) (- i 1) (- j 1)))\n       (helper (substring\
    \ (second word) (- i 1) (- j 1)) vowel (+ i 1) (+ j 1))]\n      [(equal? (first\
    \ word) (substring (second word) (- i 1) (+ j 1)))\n       (helper (substring\
    \ (second word) (- i 1) (+ j 1)) vowel (+ i 1) (+ j 1))]\n      [(equal? (first\
    \ word) (substring (second word) (- i 1) (- j 1)))\n       (helper (substring\
    \ (second word) (- i 1) (- j 1)) vowel (+ i 1) (+ j 1))]\n      [(equal? (first\
    \ word) (substring (second word) (- i 1) (+ j 1)))\n       (helper (substring\
    \ (second word\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate\
    \ get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal?\
    \ (candidate \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n\
    \    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"\
    ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n    (check-equal?\
    \ (candidate \"most\") \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n  \
    \  (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate \"quick\"\
    ) \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal? (candidate\
    \ \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpy3tqw5v9.rkt:40:26: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 41\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check word)\n \
    \   (let ((vowels '(a e i o u)))\n      (cond ((null? word) \"\")\n          \
    \  ((char=? (car word) (car vowels)) (car vowels))\n            (else (vowel-check\
    \ (cdr word))))))\n  (vowel-check word))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkf50jycg.rkt:26:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkf50jycg.rkt:27:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkf50jycg.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkf50jycg.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkf50jycg.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkf50jycg.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkf50jycg.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkf50jycg.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkf50jycg.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkf50jycg.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkf50jycg.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkf50jycg.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word)\n     \
    \        (vowels '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((char=?\
    \ (car word) 'a) (loop (cdr word) vowels))\n          ((char=? (car word) 'e)\
    \ (loop (cdr word) vowels))\n          ((char=? (car word) 'i) (loop (cdr word)\
    \ vowels))\n          ((char=? (car word) 'o) (loop (cdr word) vowels))\n    \
    \      ((char=? (car word) 'u) (loop (cdr word) vowels))\n          (else (loop\
    \ (cdr word) vowels)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n\
    \  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\"\
    ) \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm8tuk4kw.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm8tuk4kw.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm8tuk4kw.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm8tuk4kw.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm8tuk4kw.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm8tuk4kw.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm8tuk4kw.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm8tuk4kw.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm8tuk4kw.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm8tuk4kw.rkt:38:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm8tuk4kw.rkt:39:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpm8tuk4kw.rkt:40:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-check vowel word)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? (first word) vowel) (second\
    \ word)]\n      [else (vowel-check (rest word) vowel)]))\n  (vowel-check (first\
    \ word) word))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\"\
    )\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmplk52mrt_.rkt:26:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplk52mrt_.rkt:27:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplk52mrt_.rkt:28:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplk52mrt_.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplk52mrt_.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplk52mrt_.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplk52mrt_.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplk52mrt_.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplk52mrt_.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmplk52mrt_.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmplk52mrt_.rkt:36:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (let loop ((word word) (vowels\
    \ '(a e i o u)))\n    (cond ((null? word) \"\")\n          ((char=? (car word)\
    \ (car vowels)) (car vowels))\n          ((char=? (car word) (cadr vowels)) (loop\
    \ (cdr word) vowels))\n          ((char=? (car word) (caddr vowels)) (loop (cdr\
    \ word) vowels))\n          ((char=? (car word) (caddr vowels) (loop (cdr word)\
    \ vowels))\n           (loop (cdr word) vowels))\n          (else (loop (cdr word)\
    \ vowels)))))\n\n(require rackunit)\n\n(define (test-humaneval) \n\n  (let ((\
    \ candidate get_closest_vowel))\n    (check-equal? (candidate \"yogurt\") \"u\"\
    )\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal? (candidate\
    \ \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n    (check-equal?\
    \ (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\") \"a\")\n  \
    \  (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate \"\
    ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal? (candidate\
    \ \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n    (check-equal?\
    \ (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"Above\") \"o\")\n\
    ))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx5ps56l_.rkt:28:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx5ps56l_.rkt:29:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx5ps56l_.rkt:30:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx5ps56l_.rkt:31:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx5ps56l_.rkt:32:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx5ps56l_.rkt:33:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx5ps56l_.rkt:34:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx5ps56l_.rkt:35:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx5ps56l_.rkt:36:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx5ps56l_.rkt:37:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx5ps56l_.rkt:38:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpx5ps56l_.rkt:39:4\n\
    \ncar: contract violation\n  expected: pair?\n  given: \"Asia\"\n--------------------\n\
    ----------"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (vowel-search start end)\n\
    \    (cond ((= end start) \"\")\n          ((char=? (char-code (substring word\
    \ start end)) #\\a) \n           (vowel-search (+ start 1) end))\n          ((char=?\
    \ (char-code (substring word start end)) #\\e) \n           (vowel-search (+ start\
    \ 1) (+ end 1)))\n          ((char=? (char-code (substring word start end)) #\\\
    i) \n           (vowel-search (+ start 1) (+ end 1)))\n          ((char=? (char-code\
    \ (substring word start end)) #\\o) \n           (vowel-search (+ start 1) (+\
    \ end 1)))\n          ((char=? (char-code (substring word start end)) #\\u) \n\
    \           (vowel-search (+ start 1) (+ end 1)))\n          ((char=? (char-code\
    \ (substring word start end)) #\\y) \n           (vowel-search (+ start 1) (+\
    \ end 1)))\n          ((char=? (char-code (substring word start end)) #\\a) \n\
    \           (vowel-search (+ start 1) (+ end 1)))\n          ((char=? (char-code\
    \ (substring word start end)) #\\e) \n           (vowel-search (+ start 1) (+\
    \ end 1)))\n          ((char=? (char-code (substring word start end)) #\\i) \n\
    \           (vowel-search (+ start 1) (+ end 1)))\n          ((char=? (char-code\
    \ (substring word start end)) #\\o) \n           (vowel-search (+ start 1) (+\
    \ end 1)))\n          ((char=? (char-code (substring word start end)) #\\u) \n\
    \           (vowel-search (+ start 1) (+ end 1)))\n          ((char=? (char-code\
    \ (substring word start end)) #\\y) \n           (vowel-search (+ start 1) (+\
    \ end 1)))\n          ((char=? (char-code (substring word start end)) #\\a) \n\
    \           (vowel-search (+ start 1) (+ end 1)))\n          ((char=? (char-code\
    \ (substring word start end)) #\\e) \n           (vowel-search (+ start 1) (+\
    \ end 1)))\n          ((char=? (char-code (substring word start end)) #\\i) \n\
    \           (vowel-search (+ start 1) (+ end 1)))\n          ((char=? (\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "/tmp/tmpgt60c3ft.rkt:46:19: read-syntax: expected a `)` to close `(`\n\
    \  possible cause: indentation suggests a missing `)` before line 47\n  context...:\n\
    \   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:186:17:\
    \ body\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/syntax/module-reader.rkt:183:2:\
    \ wrap-internal\n   /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/racket-8.3.0-k63hxj46zvzf4h4gps46prefkjkbgnmp/share/racket/collects/racket/../syntax/module-reader.rkt:67:9:\
    \ wrap-internal/wrapper\n"
  exit_code: 1
  status: OK
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond [(empty? word) \"\"]\n \
    \       [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n        [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n        [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n        [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n        [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \        [else (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpsz4hhqz8.rkt:27:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsz4hhqz8.rkt:28:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsz4hhqz8.rkt:29:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsz4hhqz8.rkt:30:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsz4hhqz8.rkt:31:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsz4hhqz8.rkt:32:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsz4hhqz8.rkt:33:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsz4hhqz8.rkt:34:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsz4hhqz8.rkt:35:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpsz4hhqz8.rkt:36:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpsz4hhqz8.rkt:37:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpkqiktaru.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkqiktaru.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkqiktaru.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkqiktaru.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkqiktaru.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkqiktaru.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkqiktaru.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkqiktaru.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkqiktaru.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpkqiktaru.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpkqiktaru.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (define (helper word vowel)\n\
    \    (cond\n      [(empty? word) \"\"]\n      [(equal? (first word) vowel) (second\
    \ word)]\n      [(equal? (first word) (substring (second word) 0 1)) (helper (rest\
    \ word) (substring (second word) 0 1))]\n      [(equal? (first word) (substring\
    \ (second word) 0 2)) (helper (rest word) (substring (second word) 0 2))]\n  \
    \    [(equal? (first word) (substring (second word) 0 3)) (helper (rest word)\
    \ (substring (second word) 0 3))]\n      [(equal? (first word) (substring (second\
    \ word) 0 4)) (helper (rest word) (substring (second word) 0 4))]\n      [(equal?\
    \ (first word) (substring (second word) 0 5)) (helper (rest word) (substring (second\
    \ word) 0 5))]\n      [(equal? (first word) (substring (second word) 0 6)) (helper\
    \ (rest word) (substring (second word) 0 6))]\n      [(equal? (first word) (substring\
    \ (second word) 0 7)) (helper (rest word) (substring (second word) 0 7))]))\n\
    \  (helper (reverse word) 'u))\n\n(require rackunit)\n\n(define (test-humaneval)\
    \ \n\n  (let (( candidate get_closest_vowel))\n    (check-equal? (candidate \"\
    yogurt\") \"u\")\n    (check-equal? (candidate \"full\") \"u\")\n    (check-equal?\
    \ (candidate \"easy\") \"\")\n    (check-equal? (candidate \"eAsy\") \"\")\n \
    \   (check-equal? (candidate \"ali\") \"\")\n    (check-equal? (candidate \"bad\"\
    ) \"a\")\n    (check-equal? (candidate \"most\") \"o\")\n    (check-equal? (candidate\
    \ \"ab\") \"\")\n    (check-equal? (candidate \"ba\") \"\")\n    (check-equal?\
    \ (candidate \"quick\") \"\")\n    (check-equal? (candidate \"anime\") \"i\")\n\
    \    (check-equal? (candidate \"Asia\") \"\")\n    (check-equal? (candidate \"\
    Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp62jtwr40.rkt:32:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"yogurt\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp62jtwr40.rkt:33:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"full\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp62jtwr40.rkt:34:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"easy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp62jtwr40.rkt:35:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"eAsy\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp62jtwr40.rkt:36:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ali\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp62jtwr40.rkt:37:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"bad\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp62jtwr40.rkt:38:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"most\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp62jtwr40.rkt:39:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ab\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp62jtwr40.rkt:40:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"ba\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp62jtwr40.rkt:41:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"quick\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp62jtwr40.rkt:42:4\n\
    \nreverse: contract violation\n  expected: list?\n  given: \"anime\"\n--------------------\n\
    --------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmp62jtwr40.rkt:43:4\n\
    \nreverse: contract violation\n  expected: list?"
  exit_code: 0
  status: Exception
- program: "#lang racket\n\n;; You are given a word. Your task is to find the closest\
    \ vowel that stands between \n;; two consonants from the right side of the word\
    \ (case sensitive).\n;; Vowels in the beginning and ending doesn't count. Return\
    \ empty string if you didn't\n;; find any vowel met the above condition. \n;;\
    \ You may assume that the given string contains English letter only.\n;; Example:\n\
    ;; get_closest_vowel(\"yogurt\") ==> \"u\"\n;; get_closest_vowel(\"FULL\") ==>\
    \ \"U\"\n;; get_closest_vowel(\"quick\") ==> \"\"\n;; get_closest_vowel(\"ab\"\
    ) ==> \"\"\n(define (get_closest_vowel word)\n  (cond\n    [(empty? word) \"\"\
    ]\n    [(equal? (first word) 'a) (get_closest_vowel (rest word))]\n    [(equal?\
    \ (first word) 'e) (get_closest_vowel (rest word))]\n    [(equal? (first word)\
    \ 'i) (get_closest_vowel (rest word))]\n    [(equal? (first word) 'o) (get_closest_vowel\
    \ (rest word))]\n    [(equal? (first word) 'u) (get_closest_vowel (rest word))]\n\
    \    [else (cons (first word) (get_closest_vowel (rest word)))]))\n\n(require\
    \ rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_closest_vowel))\n\
    \    (check-equal? (candidate \"yogurt\") \"u\")\n    (check-equal? (candidate\
    \ \"full\") \"u\")\n    (check-equal? (candidate \"easy\") \"\")\n    (check-equal?\
    \ (candidate \"eAsy\") \"\")\n    (check-equal? (candidate \"ali\") \"\")\n  \
    \  (check-equal? (candidate \"bad\") \"a\")\n    (check-equal? (candidate \"most\"\
    ) \"o\")\n    (check-equal? (candidate \"ab\") \"\")\n    (check-equal? (candidate\
    \ \"ba\") \"\")\n    (check-equal? (candidate \"quick\") \"\")\n    (check-equal?\
    \ (candidate \"anime\") \"i\")\n    (check-equal? (candidate \"Asia\") \"\")\n\
    \    (check-equal? (candidate \"Above\") \"o\")\n))\n\n(test-humaneval)"
  stdout: ''
  stderr: "--------------------\nERROR\nname:       check-equal?\nlocation:   /tmp/tmpdlhgq7dw.rkt:28:4\n\
    \nfirst: contract violation\n  expected: (and/c list? (not/c empty?))\n  given:\
    \ \"yogurt\"\n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpdlhgq7dw.rkt:29:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"full\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpdlhgq7dw.rkt:30:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"easy\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpdlhgq7dw.rkt:31:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"eAsy\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpdlhgq7dw.rkt:32:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ali\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpdlhgq7dw.rkt:33:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"bad\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpdlhgq7dw.rkt:34:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"most\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpdlhgq7dw.rkt:35:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"ab\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpdlhgq7dw.rkt:36:4\n\nfirst:\
    \ contract violation\n  expected: (and/c list? (not/c empty?))\n  given: \"ba\"\
    \n--------------------\n--------------------\nERROR\nname:       check-equal?\n\
    location:   /tmp/tmpdlhgq7dw.rkt:37:4\n\nfirst: contract violation\n  expected:\
    \ (and/c list? (not/c empty?))\n  given: \"quick\"\n--------------------\n--------------------\n\
    ERROR\nname:       check-equal?\nlocation:   /tmp/tmpdlhgq7dw.rkt:38:4\n\nfirst:\
    \ con"
  exit_code: 0
  status: Exception
