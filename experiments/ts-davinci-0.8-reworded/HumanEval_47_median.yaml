name: HumanEval_47_median
language: ts
prompt: "//Return median of elements in the array l.\n// >>> median([3, 1, 2, 4, 5])\n\
  // 3\n// >>> median([-10, 4, 6, 1000, 10, 20])\n// 15.0\nfunction median(l: number[]):\
  \ number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = median;\n  assert.deepEqual(candidate([3, 1, 2, 4,\
  \ 5]),3);\n  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);\n  assert.deepEqual(candidate([5]),5);\n\
  \  assert.deepEqual(candidate([6, 5]),5.5);\n  assert.deepEqual(candidate([8, 1,\
  \ 3, 9, 9, 2, 7]),7);\n}\n\ntest();"
completions: ["    //Seems a little bit redundant.\n    return avg(l);\n}\n", "  \
    \  // TODO\n    return 0;\n}\n", "    let sortedArray = l.sort((a, b) => a - b);\n\
    \    let midpoint = Math.floor(sortedArray.length / 2);\n    if (sortedArray.length\
    \ % 2 === 0) {\n        return (sortedArray[midpoint] + sortedArray[midpoint -\
    \ 1]) / 2;\n    } else {\n        return sortedArray[midpoint];\n    }\n}\n",
  "    //IMPLEMENT ME\n    if(l.length % 2 == 0){\n        return ((l[(l.length/2)]\
    \ + l[(l.length/2) - 1])/2);\n    }\n    else {\n        return l[Math.floor(l.length/2)];\n\
    \    }\n}\n", "    const sorted = l.sort((a, b) => a - b);\n    const len = sorted.length;\n\
    \    if (len % 2 === 0) {\n        const mi = len / 2;\n        return (sorted[mi\
    \ - 1] + sorted[mi]) / 2;\n    } else {\n        return sorted[(len - 1) / 2];\n\
    \    }\n}\n", "  if (l.length === 0) {\n    return 0;\n  }\n\n  const sorted =\
    \ l.sort((a, b) => a - b);\n  const middle = Math.floor(sorted.length / 2);\n\n\
    \  if (sorted.length % 2) {\n    return sorted[middle];\n  } else {\n    return\
    \ (sorted[middle - 1] + sorted[middle]) / 2.0;\n  }\n}\n", "    let mid: number\
    \ = Math.floor(l.length / 2);\n    let l1: number[] = l.slice(0, mid).sort();\n\
    \    let l2: number[] = l.slice(mid, l.length).sort();\n    if (l.length % 2 ===\
    \ 0) {\n        return (l1[mid - 1] + l2[0]) / 2;\n    } else {\n        return\
    \ l2[0];\n    }\n}\n", "  if (l.length === 0) {\n    return null;\n  }\n  if (l.length\
    \ === 1) {\n    return l[0];\n  }\n  let temp = l.slice();\n  temp.sort((a, b)\
    \ => a - b);\n  if (temp.length % 2 === 0) {\n    return (temp[temp.length / 2\
    \ - 1] + temp[temp.length / 2]) / 2;\n  } else {\n    return temp[Math.floor(temp.length\
    \ / 2)];\n  }\n}\n", "  let l1 = l.slice().sort((a, b) => a - b);\n  let len =\
    \ l1.length;\n  if (len % 2 === 0) {\n    return (l1[len / 2 - 1] + l1[len / 2])\
    \ / 2;\n  } else {\n    return l1[Math.floor(len / 2)];\n  }\n}\n", "    //YOUR\
    \ CODE HERE\n    return 0;\n}", "    let numItems = l.length;\n    if (numItems\
    \ == 0) {\n        return -1;\n    } else if (numItems % 2 == 0) {\n        let\
    \ mid = (numItems / 2) - 1;\n        return (l[mid] + l[mid + 1]) / 2;\n    }\
    \ else {\n        let mid = Math.floor(numItems / 2);\n        return l[mid];\n\
    \    }\n}\n", "    let copy = l.slice(0, l.length);\n    copy.sort(function(a,\
    \ b) {\n        return a - b;\n    });\n    let mid = Math.floor(copy.length /\
    \ 2);\n    if (copy.length % 2 === 0) {\n        return (copy[mid] + copy[mid\
    \ - 1]) / 2;\n    } else {\n        return copy[mid];\n    }\n}", "  let sortedList\
    \ = l.sort();\n  let listLength = sortedList.length;\n  if (listLength === 0)\
    \ {\n    return 0;\n  } else if (listLength % 2 !== 0) {\n    return sortedList[(listLength\
    \ - 1) / 2];\n  } else {\n    return (sortedList[listLength / 2] + sortedList[listLength\
    \ / 2 - 1]) / 2;\n  }\n}\n", "  let x = l.sort((a, b) => a - b);\n  let y = x.length\
    \ / 2;\n  if (y % 2 == 0) {\n    return x[y];\n  } else {\n    return (x[y - 0.5]\
    \ + x[y + 0.5]) / 2;\n  }\n}\n", "    l.sort();\n    let mid = Math.floor(l.length\
    \ / 2);\n    if (l.length % 2) {\n        return l[mid];\n    } else {\n     \
    \   return (l[mid - 1] + l[mid]) / 2.0;\n    }\n}\n", "    l.sort(function(a,\
    \ b) {\n        return a - b;\n    });\n    let len = l.length;\n    if (len %\
    \ 2 == 0) {\n        return (l[len / 2 - 1] + l[len / 2]) / 2;\n    } else {\n\
    \        return l[Math.floor(len / 2)];\n    }\n}\n", "  return (l[~~(l.length\
    \ / 2)] + l[Math.ceil(l.length / 2)]) / 2;\n}\n", "    if (l.length === 0) {\n\
    \        return 0;\n    }\n    let sorted = l.sort();\n    let mid = sorted.length\
    \ / 2;\n    return mid % 1 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[Math.floor(mid)];\n\
    }\n\nexport class RingBuffer<T> {\n    private buf: T[];\n    private lastIndex:\
    \ number;\n    private size: number;\n\n    constructor(size: number) {\n    \
    \    this.buf = [];\n        this.lastIndex = 0;\n        this.size = size;\n\
    \    }\n\n    //Add element elem to the end of the ring buffer. \n    //Return\
    \ true if element was added, false if there is no more space.\n    public push(elem:\
    \ T): boolean {\n        if (this.buf.length < this.size) {\n            this.buf.push(elem);\n\
    \            return true;\n        }\n        this.buf[this.lastIndex] = elem;\n\
    \        this.lastIndex++;\n        if (this.lastIndex === this.size) {\n    \
    \        this.lastIndex = 0;\n        }\n        return true;\n    }\n\n    //Return\
    \ the nth last pushed element, n >= 1. \n    //If there is no nth last pushed\
    \ element, return undefined.\n    public get(n: number): T | undefined {\n   \
    \     if (n > this.buf.length) {\n            return undefined;\n        }\n \
    \       if (this.lastIndex - n < 0) {\n            return this.buf[this.size +\
    \ this.lastIndex - n];\n        }\n        return this.buf[this.lastIndex - n];\n\
    \    }\n\n    //Return the number of elements in the ring buffer.\n    public\
    \ count(): number {\n        return this.buf.length;\n    }\n}\n", "    let m:\
    \ number = l.length / 2;\n    if (l.length % 2 === 0) {\n        return (l[m -\
    \ 1] + l[m]) / 2;\n    } else {\n        return l[Math.floor(m)];\n    }\n}\n",
  "    if (l.length === 0) {\n        return 0;\n    }\n\n    l.sort();\n    if (l.length\
    \ % 2 === 0) {\n        return (l[l.length / 2 - 1] + l[l.length / 2]) / 2;\n\
    \    }\n    return l[(l.length - 1) / 2];\n}\n", "    const n: number = l.length;\n\
    \    l.sort();\n    if (n % 2 == 0) {\n        return (l[n / 2 - 1] + l[n / 2])\
    \ / 2;\n    } else {\n        return l[(n - 1) / 2];\n    }\n}\n", "    const\
    \ n = l.length;\n    if (n % 2 == 0) {\n        return (l[Math.floor(n / 2)] +\
    \ l[Math.floor(n / 2) - 1]) / 2;\n    } else {\n        return l[Math.floor(n\
    \ / 2)];\n    }\n}\n", "    return 0;\n}\n", "  let n = l.length;\n  let sorted\
    \ = quickSort(l);\n  return n % 2 === 0 ? (sorted[n / 2 - 1] + sorted[n / 2])\
    \ / 2 : sorted[(n - 1) / 2];\n}\n", "  return NaN;\n}\n\n", "    const sorted:\
    \ number[] = l.sort();\n    const half: number = Math.floor(sorted.length / 2);\n\
    \    if (sorted.length % 2 !== 0) {\n        return sorted[half];\n    } else\
    \ {\n        return (sorted[half - 1] + sorted[half]) / 2.0;\n    }\n}\n", " \
    \ return -1;\n}\n", "    let l_ = [...l];\n    l_.sort((a, b) => a - b);\n   \
    \ if (l_.length % 2 == 0) {\n        return (l_[l_.length / 2 - 1] + l_[l_.length\
    \ / 2]) / 2;\n    } else {\n        return l_[(l_.length - 1) / 2];\n    }\n}\n",
  "  // TODO\n  let arr: number[] = l.sort(function(a, b) {\n    return a - b;\n \
    \ });\n  let mid: number = Math.floor(arr.length / 2);\n  if (arr.length % 2)\
    \ {\n    return arr[mid];\n  } else {\n    return (arr[mid - 1] + arr[mid]) /\
    \ 2;\n  }\n}\n", "    l.sort();\n    return l[Math.floor(l.length / 2)];\n}\n",
  "  const sorted = l.sort((a, b) => a - b);\n  const len = sorted.length;\n  if (len\
    \ % 2 === 0) {\n    return (sorted[len / 2 - 1] + sorted[len / 2]) / 2;\n  } else\
    \ {\n    return sorted[Math.floor(len / 2)];\n  }\n}\n", "  l.sort();\n  let half\
    \ = Math.floor(l.length / 2);\n  if (l.length % 2) {\n    return l[half];\n  }\
    \ else {\n    return (l[half - 1] + l[half]) / 2.0;\n  }\n}\n", "    const mid\
    \ = Math.floor(l.length / 2);\n    return (l.length % 2) ? l[mid] : (l[mid - 1]\
    \ + l[mid]) / 2;\n}\n", "  if (l.length == 0) return undefined;\n  let l_ = l.slice().sort((a,\
    \ b) => a - b);\n  let n = l_.length;\n  if (n % 2 == 0) return (l_[n / 2 - 1]\
    \ + l_[n / 2]) / 2;\n  else return l_[(n - 1) / 2];\n}\n", "  if (!Array.isArray(l))\
    \ {\n    throw new Error(\"argument should be an array of numbers\");\n  }\n \
    \ const length = l.length;\n  if (length === 0) {\n    throw new Error(\"array\
    \ should have a least one element\");\n  }\n  if (length === 1) {\n    return\
    \ l[0];\n  }\n  const sorted = l.sort();\n  if (length % 2 === 0) {\n    return\
    \ (sorted[length / 2 - 1] + sorted[length / 2]) / 2;\n  } else {\n    return sorted[Math.floor(length\
    \ / 2)];\n  }\n}\n", "    const n = l.length;\n    const middle = Math.floor(n\
    \ / 2);\n    if (n % 2 === 0) {\n        return (l[middle - 1] + l[middle]) /\
    \ 2;\n    } else {\n        return l[middle];\n    }\n}\n", "  return 0;\n}\n",
  "    let len = l.length;\n    let mid = len >> 1;\n    let res: number;\n    if\
    \ (len % 2 == 0) {\n        res = (l[mid - 1] + l[mid]) / 2;\n    } else {\n \
    \       res = l[mid];\n    }\n    return res;\n}\n", "    // TODO: return median\
    \ value of the array\n    let m: number;\n    let n: number;\n    let x: number;\n\
    \    l.sort();\n    if (l.length % 2 === 0) {\n        n = l.length / 2;\n   \
    \     m = (l[n - 1] + l[n]) / 2;\n    } else {\n        x = Math.floor(l.length\
    \ / 2);\n        m = l[x];\n    }\n    return m;\n}\n", "    return 0;\n}\n",
  "    //Your code here\n    return 0;\n}\n", "  // Write your code here\n  if(l.length\
    \ === 0) return 0;\n  l.sort( (a,b) => a-b );\n  const half = Math.floor(l.length\
    \ / 2);\n  if(l.length % 2 === 0) return (l[half] + l[half - 1]) / 2.0;\n  return\
    \ l[half];\n}\n", "  if (l.length % 2 === 0) {\n    return (l[l.length / 2] +\
    \ l[l.length / 2 - 1]) / 2;\n  } else {\n    return l[Math.floor(l.length / 2)];\n\
    \  }\n}", "    let n = l.length;\n    if (n === 0) return 0;\n    l.sort((a, b)\
    \ => a - b);\n    if (n % 2 == 0) return (l[n / 2 - 1] + l[n / 2]) / 2;\n    else\
    \ return l[(n - 1) / 2];\n}\n", "    let sortedList = l.sort((a, b) => a - b);\n\
    \    return (sortedList[Math.floor(sortedList.length / 2)] + sortedList[Math.ceil(sortedList.length\
    \ / 2)]) / 2;\n}\n", "  //Sort input list of numbers.\n  l.sort(compareNumbers);\n\
    \  var mid: number = Math.floor(l.length / 2);\n  if (l.length % 2 == 0) {\n \
    \   //If list length is even return average of center two elements.\n    return\
    \ (l[mid] + l[mid - 1]) / 2;\n  } else {\n    //If list length is odd return center\
    \ element.\n    return l[mid];\n  }\n}\n", "    var sorted = l.sort((a, b) =>\
    \ a - b);\n    var length = sorted.length;\n    var mid = Math.floor(length /\
    \ 2);\n    return length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) /\
    \ 2;\n}\n", "    if (l.length === 0) {\n        return undefined;\n    }\n   \
    \ if (l.length === 1) {\n        return l[0];\n    }\n    //Sort array\n    const\
    \ sorted = l.sort(function (a, b) {\n        return a - b;\n    });\n    //Check\
    \ for even length\n    if (sorted.length % 2 === 0) {\n        //Calculate the\
    \ two middle elements\n        const midLow = sorted[Math.floor(sorted.length\
    \ / 2) - 1];\n        const midHigh = sorted[Math.floor(sorted.length / 2)];\n\
    \        //Return their average\n        return (midLow + midHigh) / 2;\n    }\
    \ else {\n        //Return the middle element\n        return sorted[Math.floor(sorted.length\
    \ / 2)];\n    }\n}\n", "  l.sort();\n  return l[Math.floor(l.length / 2)];\n}\n",
  "  let midIndex = l.length / 2;\n  if (l.length % 2 === 0) {\n    return (l[midIndex]\
    \ + l[midIndex - 1]) / 2;\n  } else {\n    return l[Math.floor(midIndex)];\n \
    \ }\n}\n\nexport { ordered, max_number, min_number, median };", "  if (l.length\
    \ === 0) {\n    return 0;\n  }\n  const sorted: number[] = l.sort((a, b) => a\
    \ - b);\n  if (sorted.length % 2 === 0) {\n    return (sorted[sorted.length /\
    \ 2 - 1] + sorted[sorted.length / 2]) / 2;\n  } else {\n    return sorted[Math.floor(sorted.length\
    \ / 2)];\n  }\n}\n", "    l.sort(function(a, b) {\n        return a - b;\n   \
    \ });\n    let half = Math.floor(l.length / 2);\n    if (l.length % 2) {\n   \
    \     return l[half];\n    } else {\n        return (l[half - 1] + l[half]) /\
    \ 2.0;\n    }\n}\n", "    var middle = Math.floor(l.length / 2);\n    if (l.length\
    \ % 2 === 0) {\n        return (l[middle - 1] + l[middle]) / 2;\n    } else {\n\
    \        return l[middle];\n    }\n}\n", "  let n = l.length;\n  l.sort();\n \
    \ return (l[Math.floor(n / 2)] + l[Math.ceil(n / 2)]) / 2;\n}\n", "    let l2\
    \ = l.sort(numericSort);\n    if (l2.length % 2 == 0) {\n        return (l2[(l2.length\
    \ / 2) - 1] + l2[l2.length / 2]) / 2;\n    } else {\n        return l2[Math.floor(l2.length\
    \ / 2)];\n    }\n}\n", "  let s = l.slice().sort((a, b) => a - b);\n  let half\
    \ = Math.floor(s.length / 2);\n  if (s.length % 2) {\n    return s[half];\n  }\
    \ else {\n    return (s[half - 1] + s[half]) / 2.0;\n  }\n}\n", "    // TODO\n\
    \    return 0;\n}\n", "    const n = l.length;\n    if (n === 0) {\n        return\
    \ null;\n    } else if (n % 2 === 0) {\n        return (l[n / 2 - 1] + l[n / 2])\
    \ / 2;\n    } else {\n        return l[Math.floor(n / 2)];\n    }\n}\n", "  let\
    \ listCopy = l.slice();\n  let len = listCopy.length;\n  let index = Math.floor(len\
    \ / 2);\n  let sorted = listCopy.sort();\n  if (len % 2) {\n    return sorted[index];\n\
    \  } else {\n    return (sorted[index - 1] + sorted[index]) / 2;\n  }\n}\n", " \
    \   const n = l.length;\n    const n2 = Math.floor(n / 2);\n    const n4 = Math.floor(n\
    \ / 4);\n    const n42 = n4 + n2;\n    const r = l.sort((a, b) => a - b);\n  \
    \  if (n % 2 === 0) {\n        return (r[n2] + r[n42]) / 2;\n    } else {\n  \
    \      return r[n4];\n    }\n}\n", "  // TODO\n  let index = Math.floor(l.length\
    \ / 2);\n  if (l.length % 2 === 0) {\n    return (l[index] + l[index - 1]) / 2;\n\
    \  } else {\n    return l[index];\n  }\n}\n", "    l.sort(function(a, b) {\n \
    \       return a - b;\n    });\n    let half = Math.floor(l.length / 2);\n   \
    \ if (l.length % 2) {\n        return l[half];\n    } else {\n        return (l[half\
    \ - 1] + l[half]) / 2.0;\n    }\n}\n", "    let mid = Math.floor(l.length / 2);\n\
    \    if (l.length % 2 === 0) {\n        return (l[mid - 1] + l[mid]) / 2.0;\n\
    \    } else {\n        return l[mid];\n    }\n}\n", "    l.sort();\n    const\
    \ len = l.length;\n    if (len % 2 === 0) {\n        return (l[len / 2 - 1] +\
    \ l[len / 2]) / 2;\n    } else {\n        return l[(len - 1) / 2];\n    }\n}\n",
  "    l.sort();\n    if (l.length % 2 === 0) {\n        return (l[l.length / 2] +\
    \ l[l.length / 2 - 1]) / 2;\n    } else {\n        return l[Math.floor(l.length\
    \ / 2)];\n    }\n}\n", "  // your code here\n  const midIndex = Math.floor(l.length\
    \ / 2);\n  if (l.length % 2 == 0) {\n    return (l[midIndex] + l[midIndex - 1])\
    \ / 2;\n  } else {\n    return l[midIndex];\n  }\n}\n", "    let n = l.length;\n\
    \    let m = Math.floor(n / 2);\n    if (n % 2 == 0) {\n        return (l[m -\
    \ 1] + l[m]) / 2.0;\n    } else {\n        return l[m];\n    }\n}\n", "    const\
    \ sorted_list = l.sort((a, b) => a - b);\n    const mid = Math.floor(sorted_list.length\
    \ / 2);\n    return sorted_list.length % 2 === 0 ?\n        (sorted_list[mid]\
    \ + sorted_list[mid - 1]) / 2 :\n        sorted_list[mid];\n}\n", "    let al:\
    \ number[] = l.slice();\n    let midIndex: number = Math.floor(al.length / 2);\n\
    \    al.sort((a, b) => a - b);\n    if (al.length % 2 === 0) {\n        return\
    \ (al[midIndex] + al[midIndex - 1]) / 2;\n    } else {\n        return al[midIndex];\n\
    \    }\n}\n", "    let s = l.slice();\n    s.sort();\n    let n = s.length;\n\
    \    if (n % 2 === 0) {\n        return (s[n / 2 - 1] + s[n / 2]) / 2;\n    }\
    \ else {\n        return s[Math.floor(n / 2)];\n    }\n}\n", "    const lr = l.slice().sort((a,\
    \ b) => a - b);\n    if (l.length % 2 == 0) {\n        const i = l.length / 2;\n\
    \        return (lr[i - 1] + lr[i]) / 2;\n    } else {\n        return lr[(l.length\
    \ - 1) / 2];\n    }\n}\n", "    const max = Math.max(...l);\n    const min = Math.min(...l);\n\
    \    const mid = Math.floor((max - min) / 2);\n    return mid;\n}\n", "  const\
    \ n = l.length;\n  if (n % 2 == 0) {\n    return (l[n / 2 - 1] + l[n / 2]) / 2;\n\
    \  } else {\n    return l[(n - 1) / 2];\n  }\n}\n", "    let length = l.length;\n\
    \    if (length === 0) {\n        return NaN;\n    }\n    l.sort();\n    if (length\
    \ % 2 === 0) {\n        return (l[length / 2 - 1] + l[length / 2]) / 2;\n    }\
    \ else {\n        return l[Math.floor(length / 2)];\n    }\n}\n", "  const sorted\
    \ = l.sort((a, b) => a - b);\n  const len = sorted.length;\n  if (len % 2 ===\
    \ 0) {\n    const a = sorted[len / 2 - 1];\n    const b = sorted[len / 2];\n \
    \   return (a + b) / 2;\n  } else {\n    return sorted[Math.floor(len / 2)];\n\
    \  }\n}\n", "    return 0;\n}\n", "  // Here's a comment.\n  // . . .\n\n  //\
    \ Here's another one.\n  // . . .\n\n  // Iterate over the array l.\n  // . .\
    \ .\n\n  // Return the median.\n  // . . .\n}\n```\n\n## Lab 2\n\n### 2a\n\n```typescript",
  "    if(l.length === 0) {\n        return -1;\n    }\n    let arr = l.sort();\n\
    \    if(arr.length % 2 === 0) {\n        return (arr[arr.length / 2] + arr[arr.length\
    \ / 2 - 1]) / 2;\n    } else {\n        return arr[Math.floor(arr.length / 2)];\n\
    \    }\n}\n", "    let sorted = l.sort((a, b) => a - b);\n    let len = sorted.length;\n\
    \    if (len % 2 === 0) {\n        return (sorted[len / 2 - 1] + sorted[len /\
    \ 2]) / 2;\n    } else {\n        return sorted[(len - 1) / 2];\n    }\n}\n",
  "    let sorted = l.sort(function(a, b) {\n        return a - b;\n    });\n    let\
    \ median = 0;\n    let num = sorted.length;\n    if (num % 2 === 0) {\n      \
    \  median = (sorted[num / 2 - 1] + sorted[num / 2]) / 2;\n    } else {\n     \
    \   median = sorted[(num - 1) / 2];\n    }\n    return median;\n}\n", "  const\
    \ n = l.length;\n  if (n === 0) {\n    return 0;\n  }\n  let s = l.sort((a, b)\
    \ => a - b);\n  if (n % 2 === 0) {\n    return (s[n / 2 - 1] + s[n / 2]) / 2;\n\
    \  } else {\n    return s[Math.floor(n / 2)];\n  }\n}\n\nexport default {\n  average,\n\
    \  median,\n};", "  return (l[(l.length - 1) >> 1] + l[l.length >> 1]) / 2.0;\n\
    }\n", "    l.sort();\n    let n = l.length;\n    if (n % 2 == 0) {\n        return\
    \ (l[n / 2 - 1] + l[n / 2]) / 2;\n    } else {\n        return l[(n - 1) / 2];\n\
    \    }\n}\n", "    if (l.length < 1) {\n        return 0;\n    }\n    var sorted:\
    \ number[] = l.sort();\n    if (sorted.length % 2 === 0) {\n        return (sorted[sorted.length\
    \ / 2] + sorted[sorted.length / 2 - 1]) / 2;\n    } else {\n        return sorted[Math.floor(sorted.length\
    \ / 2)];\n    }\n}\n", "  let midPos = Math.floor(l.length / 2);\n  let sortedList\
    \ = l.sort();\n  if (l.length % 2 === 0) {\n    return (sortedList[midPos] + sortedList[midPos\
    \ - 1]) / 2;\n  } else {\n    return sortedList[midPos];\n  }\n}\n", "    l.sort();\n\
    \    let len = l.length;\n    if (len % 2 == 0) {\n        return (l[len / 2 -\
    \ 1] + l[len / 2]) / 2;\n    } else {\n        return l[len / 2 - 0.5];\n    }\n\
    }\n", "    return 0;\n}\n", "    let n = l.length;\n    let m = Math.floor(n /\
    \ 2);\n    if (n % 2 === 0) {\n        return (l[m - 1] + l[m]) / 2;\n    } else\
    \ {\n        return l[m];\n    }\n}\n", "    const length = l.length;\n    const\
    \ sortedL = l.sort();\n    const half = Math.floor(length / 2);\n    if (length\
    \ % 2 === 0) {\n        return (sortedL[half - 1] + sortedL[half]) / 2;\n    }\
    \ else {\n        return sortedL[half];\n    }\n}\n", "  let a = l.sort();\n \
    \ if (a.length % 2 === 0) {\n    return (a[a.length / 2] + a[a.length / 2 - 1])\
    \ / 2;\n  } else {\n    return a[(a.length - 1) / 2];\n  }\n}\n", "  return 0;\n\
    }\n", "  return 0;\n}\n", "    return 0;\n}\n", "  // uncomment the line below\
    \ to print some debug info\n  // print(\"Passed in list:\", l);\n  return null;\n\
    }\n", "    return 0;\n}\n\nconsole.log(median([3, 1, 2, 4, 5]));\nconsole.log(median([-10,\
    \ 4, 6, 1000, 10, 20]));\n", "    // TODO: finish this\n    return 0;\n}\n\n\n",
  "    if (l.length == 0) return 0;\n    return l.reduce((a, b) => a + b) / l.length;\n\
    }\n", "  let m = l.length / 2;\n  if (l.length % 2 == 0) {\n    return (l[m -\
    \ 1] + l[m]) / 2;\n  } else {\n    return l[Math.floor(m)];\n  }\n}\n", "  let\
    \ sortedList = l.sort((a, b) => a - b);\n  let mid = Math.floor(sortedList.length\
    \ / 2);\n  if (sortedList.length % 2 !== 0) {\n    return sortedList[mid];\n \
    \ } else {\n    return (sortedList[mid - 1] + sortedList[mid]) / 2;\n  }\n}\n",
  "    l.sort(function(a, b) {\n        return a - b;\n    });\n    let lLen = l.length;\n\
    \    if (lLen % 2 === 0) {\n        return (l[lLen / 2 - 1] + l[lLen / 2]) / 2;\n\
    \    } else {\n        return l[(lLen - 1) / 2];\n    }\n}\n", "  if (l.length\
    \ === 0) {\n    return 0;\n  }\n  // TODO: Implement me!\n  return 0;\n}\n\ntest('median',\
    \ () => {\n  expect(median([3, 1, 2, 4, 5])).toBe(3);\n  expect(median([-10, 4,\
    \ 6, 1000, 10, 20])).toBe(15);\n});\n", "    let len = l.length;\n    if (len\
    \ % 2 === 0) {\n        return (l[len / 2] + l[len / 2 - 1]) / 2;\n    } else\
    \ {\n        return l[Math.floor(len / 2)];\n    }\n}\n", "    let a = l.slice();\n\
    \    let n = a.length;\n    for (let i = 0; i < n; i++) {\n        for (let j\
    \ = 0; j < n - i - 1; j++) {\n            if (a[j] > a[j + 1]) {\n           \
    \     let tmp = a[j];\n                a[j] = a[j + 1];\n                a[j +\
    \ 1] = tmp;\n            }\n        }\n    }\n    return n % 2 === 0 ? (a[n /\
    \ 2 - 1] + a[n / 2]) / 2 : a[(n - 1) / 2];\n}\n", "    if (l.length === 0) {\n\
    \        return NaN;\n    }\n    else {\n        l.sort();\n        let medianIndex\
    \ = Math.floor(l.length / 2);\n        return l.length % 2 === 0 ? (l[medianIndex]\
    \ + l[medianIndex - 1]) / 2 : l[medianIndex];\n    }\n}\n", "  l.sort();\n  return\
    \ l[Math.floor(l.length / 2)];\n}\n", "  let m = Math.floor(l.length / 2);\n \
    \ if (l.length % 2) {\n    return l[m];\n  } else {\n    return (l[m - 1] + l[m])\
    \ / 2;\n  }\n}\n", "    return 0;\n}\n", "    return 0;\n}\n", "    return 0;\n\
    }\n", "    let len = l.length;\n    let s = l.sort((a, b) => a - b);\n    if (len\
    \ % 2 == 0) {\n        return (s[len / 2 - 1] + s[len / 2]) / 2;\n    } else {\n\
    \        return s[Math.ceil(len / 2) - 1];\n    }\n}\n", "    let sorted = l.sort((a,\
    \ b) => a - b);\n    let len = sorted.length;\n    if (len % 2 !== 0) {\n    \
    \    return sorted[(len - 1) / 2];\n    } else {\n        return (sorted[(len\
    \ / 2) - 1] + sorted[len / 2]) / 2;\n    }\n}", "  let length = l.length;\n  let\
    \ isEven = length % 2 === 0;\n  let mid = Math.floor(length / 2);\n  return isEven\
    \ ? (l[mid - 1] + l[mid]) / 2 : l[mid];\n}\n", "    let n = l.length;\n    if\
    \ (n % 2 === 0) {\n        return (l[n / 2 - 1] + l[n / 2]) / 2;\n    } else {\n\
    \        return l[(n - 1) / 2];\n    }\n}\n", "    let m = 0;\n    let s = 0;\n\
    \    if (l.length % 2 === 0) {\n        let mid = l.length / 2;\n        m = (l[mid]\
    \ + l[mid - 1]) / 2;\n    } else {\n        let mid = Math.floor(l.length / 2);\n\
    \        m = l[mid];\n    }\n    for (let v of l) {\n        s += v;\n    }\n\
    \    return m;\n}\n", "  if (l.length === 0) {\n    return 0;\n  }\n  l.sort();\n\
    \  let middle = l.length / 2;\n  if (l.length % 2 === 0) {\n    return (l[middle]\
    \ + l[middle - 1]) / 2;\n  } else {\n    return l[Math.floor(middle)];\n  }\n\
    }\n", "  let sorted = l.sort((a, b) => a - b);\n  let mid = Math.floor(sorted.length\
    \ / 2);\n  return sorted.length % 2 === 0 ? (sorted[mid] + sorted[mid - 1]) /\
    \ 2 : sorted[mid];\n}\n", "    return 0;\n}\n\n", "  if (l.length === 0) return\
    \ 0;\n  if (l.length === 1) return l[0];\n  l.sort((a, b) => a - b);\n  if (l.length\
    \ % 2 === 0) {\n    return (l[l.length / 2 - 1] + l[l.length / 2]) / 2;\n  } else\
    \ {\n    return l[(l.length - 1) / 2];\n  }\n}\n", "  l.sort();\n  const len =\
    \ l.length;\n  const middle = Math.floor(len / 2);\n  if (len % 2 === 0) {\n \
    \   return (l[middle - 1] + l[middle]) / 2;\n  } else {\n    return l[middle];\n\
    \  }\n}\n", "    l.sort(function(a, b) {\n        return a - b;\n    });\n   \
    \ let mid = Math.floor(l.length / 2);\n    return (l.length % 2 == 0) ? (l[mid]\
    \ + l[mid - 1]) / 2 : l[mid];\n}\n", "    let l1 = l.sort((a, b) => a - b);\n\
    \    let middle = Math.floor(l1.length / 2);\n    if (l1.length % 2 == 0) {\n\
    \        return (l1[middle - 1] + l1[middle]) / 2;\n    } else {\n        return\
    \ l1[middle];\n    }\n}\n", "    if (l.length === 0) {\n        return 0;\n  \
    \  }\n    let median = l[0];\n    let lLess = [];\n    let lGreater = [];\n  \
    \  let n = l.length;\n    for (let i = 1; i < n; i++) {\n        if (l[i] < median)\
    \ {\n            lLess.push(l[i]);\n        } else {\n            lGreater.push(l[i]);\n\
    \        }\n    }\n    if (lLess.length === lGreater.length) {\n        return\
    \ (median + median) / 2;\n    } else if (lLess.length === lGreater.length - 1)\
    \ {\n        return median;\n    } else if (lLess.length < lGreater.length - 1)\
    \ {\n        return median(lGreater);\n    } else {\n        return median(lLess);\n\
    \    }\n}\n", "    let mid: number = Math.floor(l.length / 2);\n    let sorted:\
    \ number[] = sort(l);\n    if (l.length % 2 === 0) {\n        let a: number =\
    \ sorted[mid - 1];\n        let b: number = sorted[mid];\n        return (a +\
    \ b) / 2;\n    } else {\n        return sorted[mid];\n    }\n}\n", "    let l2\
    \ = l.sort((a, b) => a - b);\n    let len = l2.length;\n    if (len % 2 === 0)\
    \ {\n        let mid = len / 2;\n        return (l2[mid] + l2[mid - 1]) / 2;\n\
    \    } else {\n        let mid = Math.floor(len / 2);\n        return l2[mid];\n\
    \    }\n}\n", "    let n = l.length;\n    if (n == 0) {\n        return 0;\n \
    \   }\n    let l1 = l.slice(0, Math.floor(n / 2));\n    let l2 = l.slice(Math.floor(n\
    \ / 2) + 1, n);\n    if (n % 2 == 0) {\n        return (median(l1) + median(l2))\
    \ / 2;\n    } else {\n        return median(l1);\n    }\n}\n", "    //Sort the\
    \ list\n    l.sort();\n    //Calculate the length of the list\n    let len = l.length;\n\
    \    //If length is even\n    if (len % 2 == 0) {\n        //Return average of\
    \ two values at middle of list\n        return (l[len / 2] + l[len / 2 - 1]) /\
    \ 2;\n    }\n    //If length is odd\n    else {\n        //Return value at middle\
    \ of list\n        return l[(len - 1) / 2];\n    }\n}\n", "    return (l[Math.floor(l.length\
    \ / 2)] + l[Math.ceil(l.length / 2)]) / 2;\n}\n", "    let s: number[] = l.sort();\n\
    \    let n: number = s.length;\n    let mid: number = n / 2;\n    if (n % 2 ==\
    \ 0) {\n        return (s[mid - 1] + s[mid]) / 2.0;\n    } else {\n        return\
    \ s[mid];\n    }\n}", "    const n = l.length;\n    const middle = Math.floor(n\
    \ / 2);\n    if (n === 0) {\n        return 0;\n    }\n    if (n % 2 === 0) {\n\
    \        return (l[middle - 1] + l[middle]) / 2;\n    }\n    return l[middle];\n\
    }\n", "  const half = Math.floor(l.length / 2);\n  const isOdd = l.length % 2;\n\
    \  if (isOdd) {\n    return l[half];\n  } else {\n    return (l[half - 1] + l[half])\
    \ / 2.0;\n  }\n}\n", "    return 0;\n}\n", "  var m = floor(l.length / 2);\n \
    \ if (l.length % 2 === 0) {\n    return mean([l[m], l[m - 1]]);\n  } else {\n\
    \    return l[m];\n  }\n}\n", "  let even: boolean = l.length % 2 === 0;\n  let\
    \ middle = Math.floor(l.length / 2);\n  let sorted = l.sort((a, b) => a - b);\n\
    \  return even ? (sorted[middle] + sorted[middle - 1]) / 2 : sorted[middle];\n\
    }\n", "    // TODO\n    return 0;\n}\n", "    let mid = Math.floor(l.length /\
    \ 2);\n    if (l.length % 2 == 0) {\n        return (l[mid] + l[mid - 1]) / 2;\n\
    \    } else {\n        return l[mid];\n    }\n}\n", "    // Your implementation\
    \ goes here.\n    //return null;\n    let n: number = l.length;\n    if (n % 2\
    \ === 0) {\n        let m: number = n / 2;\n        return (l[m - 1] + l[m]) /\
    \ 2;\n    } else {\n        let m: number = Math.floor(n / 2);\n        return\
    \ l[m];\n    }\n}\n", "    const sorted = l.sort();\n    const length = sorted.length;\n\
    \    if (length % 2 === 0) {\n        return (sorted[(length / 2) - 1] + sorted[length\
    \ / 2]) / 2;\n    } else {\n        return sorted[Math.floor(length / 2)];\n \
    \   }\n}\n", "    return l.sort((a, b) => a - b)[Math.floor(l.length / 2)];\n\
    }\n", "  let sum: number = 0;\n  let l1: number[] = l.sort((a, b) => a - b);\n\
    \  let l2: number[] = l1.slice(0, Math.floor(l1.length / 2));\n  let l3: number[]\
    \ = l1.slice(Math.ceil(l1.length / 2));\n  if (l1.length % 2 == 0) {\n    for\
    \ (let i: number = 0; i < l2.length; i++) {\n      sum += l2[i];\n    }\n    for\
    \ (let i: number = 0; i < l3.length; i++) {\n      sum += l3[i];\n    }\n    return\
    \ sum / l1.length;\n  } else {\n    return l1[Math.floor(l1.length / 2)];\n  }\n\
    }\n", "  l.sort((a, b) => a - b);\n  let mid = Math.floor(l.length / 2);\n  return\
    \ l.length % 2 !== 0 ? l[mid] : (l[mid - 1] + l[mid]) / 2;\n}\n", "  if (l.length\
    \ === 0) {\n    return 0;\n  }\n  const sorted = l.sort((a, b) => a - b);\n  const\
    \ mid = Math.floor(sorted.length / 2);\n  return sorted.length % 2 === 0 ?\n \
    \   (sorted[mid - 1] + sorted[mid]) / 2 :\n    sorted[mid];\n}\n\nexport {\n \
    \ lcm,\n  max,\n  min,\n  median,\n  gcd,\n  isPrime,\n  primeFactors,\n  primeFactorisation,\n\
    \  nthPrime,\n  nthFibonacciNumber,\n  factorial,\n  isPandigital,\n  isPalindrome,\n\
    \  isPermutation,\n  digits,\n  sum,\n  product,\n  numberOfDivisors,\n  properDivisors,\n\
    \  isAbundant,\n  isDeficient,\n  isPerfect,\n  isSquare,\n  isPythagoreanTriplet,\n\
    \  digSum,\n  pythagoreanTripletProduct,\n  factorials,\n  nCr,\n  nPr,\n  isCoprime,\n\
    \  totient,\n  phi,\n  isEven,\n  isOdd,\n  primeSum,\n  isCircularPrime,\n  truncateLeft,\n\
    \  truncateRight,\n  truncate\n};", "    const sorted = l.sort((a, b) => a - b);\n\
    \    const mid = Math.floor(sorted.length / 2);\n    return sorted.length % 2\
    \ === 0 ? (sorted[mid] + sorted[mid - 1]) / 2 : sorted[mid];\n}\n", "    return\
    \ (l[(l.length - 1) / 2] + l[l.length / 2]) / 2;\n}\n", "    const len = l.length;\n\
    \    if (len === 0) {\n        return 0;\n    }\n    const mid = Math.floor(len\
    \ / 2);\n    if (len % 2 === 0) {\n        return (l[mid - 1] + l[mid]) / 2;\n\
    \    }\n    return l[mid];\n}\n\nexport {\n    add,\n    multiply,\n    factorial,\n\
    \    sum,\n    product,\n    isEven,\n    isOdd,\n    isPrime,\n    nextPrime,\n\
    \    nthPrime,\n    nthPrimeAfter,\n    sumOfSquares,\n    squareOfSum,\n    difference,\n\
    \    fibonacci,\n    isPalindrome,\n    reverse,\n    sort,\n    mean,\n    median,\n\
    };", "    return 0;\n}\n", "    // Your code here.\n    return 0;\n}\n", "   \
    \ if (l.length === 0) {\n        return 0;\n    }\n\n    let medIndex = Math.floor(l.length\
    \ / 2);\n    if (l.length % 2 == 0) {\n        return (l[medIndex] + l[medIndex\
    \ - 1]) / 2;\n    } else {\n        return l[medIndex];\n    }\n}\n", "    let\
    \ h = new Heap(l.length);\n    for (let i = 0; i < l.length; i++) {\n        h.insert(l[i]);\n\
    \    }\n    let m1 = h.deleteRoot();\n    let m2 = h.deleteRoot();\n    if (l.length\
    \ % 2 == 0) {\n        return (m1 + m2) / 2;\n    } else {\n        return m2;\n\
    \    }\n}\n\nexport { median }", "  return 0;\n}\n\n", "  //TODO: Add your code\
    \ here.\n  //Hint: Use a sort method, and indexing.\n  var n = l.length;\n  var\
    \ t = 0;\n  for (var i = 0; i < n; i++) {\n    for (var j = i + 1; j < n; j++)\
    \ {\n      if (l[i] > l[j]) {\n        t = l[i];\n        l[i] = l[j];\n     \
    \   l[j] = t;\n      }\n    }\n  }\n  if (n % 2 == 0) {\n    return (l[n / 2]\
    \ + l[n / 2 - 1]) / 2;\n  } else {\n    return l[(n - 1) / 2];\n  }\n}\n", " \
    \   let arr = l.slice();\n    arr.sort(function(a, b) {\n        return a - b;\n\
    \    });\n    let idx = Math.floor(arr.length / 2);\n    if (arr.length % 2 ===\
    \ 0) {\n        return (arr[idx] + arr[idx - 1]) / 2;\n    } else {\n        return\
    \ arr[idx];\n    }\n}\n", "    let list = l.sort((a, b) => a - b);\n    if (list.length\
    \ % 2 === 0) {\n        return (list[list.length / 2] + list[list.length / 2 -\
    \ 1]) / 2;\n    } else {\n        return list[Math.floor(list.length / 2)];\n\
    \    }\n}\n", "  const length = l.length;\n  const sorted = l.sort();\n  const\
    \ half = Math.floor(length / 2);\n  return length % 2 ? sorted[half] : (sorted[half\
    \ - 1] + sorted[half]) / 2;\n}\n\nexport {\n  median,\n};", "    let list: number[]\
    \ = mergeSort(l);\n    if (list.length % 2 == 0) {\n        return (list[list.length\
    \ / 2] + list[list.length / 2 - 1]) / 2;\n    } else {\n        return list[Math.floor(list.length\
    \ / 2)];\n    }\n}\n", "  let s = l.sort();\n  if (s.length % 2 === 0) {\n   \
    \ return (s[s.length / 2] + s[s.length / 2 - 1]) / 2;\n  } else {\n    return\
    \ s[Math.floor(s.length / 2)];\n  }\n}\n", "    // TODO\n    return 15.0;\n}\n\
    \ntest('test_median', () => {\n    expect(median([1, 2, 3, 4, 5])).toBe(3);\n\
    \    expect(median([1, 2, 3, 4, 5, 6])).toBe(3.5);\n    expect(median([3, 1, 2,\
    \ 4, 5])).toBe(3);\n    expect(median([-10, 4, 6, 1000, 10, 20])).toBe(15.0);\n\
    });\n", "    //define the length of the array\n    let l_length = l.length;\n\
    \    //check if the length of the array is even, then return the mean of the two\
    \ middle elements\n    if(l_length % 2 == 0){\n        return (l[(l_length - 1)\
    \ / 2] + l[l_length / 2]) / 2;\n    }\n    //if the length of the array is odd,\
    \ then return the middle element\n    else{\n        return l[(l_length - 1) /\
    \ 2];\n    }\n}\n", "    let median = 0;\n    if (l.length % 2 == 0) {\n     \
    \   median = (l[l.length / 2] + l[l.length / 2 - 1]) / 2;\n    } else {\n    \
    \    median = l[Math.floor(l.length / 2)];\n    }\n    return median;\n}\n", " \
    \   const midPoint = Math.floor(l.length / 2);\n    if (l.length % 2 == 0) {\n\
    \        return (l[midPoint] + l[midPoint - 1]) / 2;\n    } else {\n        return\
    \ l[midPoint];\n    }\n}\n", "  let sorted = l.sort();\n  let n = sorted.length;\n\
    \  if (n % 2 == 0) {\n    return (sorted[n / 2 - 1] + sorted[n / 2]) / 2;\n  }\
    \ else {\n    return sorted[Math.floor(n / 2)];\n  }\n}\n", "    const mid = Math.floor(l.length\
    \ / 2);\n    if (l.length % 2 == 0) {\n        return (l[mid] + l[mid - 1]) /\
    \ 2;\n    } else {\n        return l[mid];\n    }\n}\n", "    let len = l.length;\n\
    \    if (len === 0) {\n        return 0;\n    }\n    let sorted = sortedCopy(l);\n\
    \    if (len % 2 === 0) {\n        return (sorted[len / 2 - 1] + sorted[len /\
    \ 2]) / 2;\n    } else {\n        return sorted[(len - 1) / 2];\n    }\n}\n",
  "    // Your code here\n    let x: number;\n    let z: number;\n    let y: number;\n\
    \    if (l.length % 2 == 0) {\n        x = (l.length / 2) - 1;\n        y = l[x];\n\
    \        z = l[x + 1];\n        return (y + z) / 2;\n    }\n    else {\n     \
    \   x = Math.floor(l.length / 2);\n        return l[x];\n    }\n}\n", "    const\
    \ l2 = l.sort();\n    const length = l2.length;\n    const half = Math.floor(length\
    \ / 2);\n    if (length % 2 === 0) {\n        return (l2[half - 1] + l2[half])\
    \ / 2;\n    } else {\n        return l2[half];\n    }\n}\n", "    var half = Math.floor(l.length\
    \ / 2);\n    if (l.length % 2 === 0) {\n        return (l[half - 1] + l[half])\
    \ / 2.0;\n    } else {\n        return l[half];\n    }\n}\n", "  return (l[Math.floor(l.length\
    \ / 2)] + l[Math.ceil(l.length / 2)]) / 2\n}\n\nexport default median", "    //Sort\
    \ the array and select the middle element.\n    l.sort();\n    let middle = Math.floor(l.length\
    \ / 2);\n    if (l.length % 2 === 0) {\n        return (l[middle] + l[middle -\
    \ 1]) / 2;\n    } else {\n        return l[middle];\n    }\n}\n", "    l.sort();\n\
    \    return l[Math.floor(l.length / 2)];\n}\n", "    l.sort((a, b) => a - b);\n\
    \    return l[Math.floor(l.length / 2)];\n}\n\nexport function problem6() {\n\
    \    const N = 10000;\n    const l = createNArray(N);\n    console.log(\"Calculating\
    \ median of \" + N + \" elements\");\n    const t0 = performance.now();\n    console.log(\"\
    Median: \" + median(l));\n    const t1 = performance.now();\n    console.log(\"\
    Time taken: \" + (t1 - t0) + \" milliseconds\");\n}", "    let l_sorted = l.sort((a,\
    \ b) => a - b);\n    if (l_sorted.length % 2 === 0) {\n        let half_length\
    \ = l_sorted.length / 2;\n        return (l_sorted[half_length] + l_sorted[half_length\
    \ - 1]) / 2;\n    } else {\n        return l_sorted[Math.floor(l_sorted.length\
    \ / 2)];\n    }\n}\n", "  let length = l.length;\n  let mid = length / 2;\n  if\
    \ (length % 2 === 0) {\n    return (l[mid - 1] + l[mid]) / 2;\n  } else {\n  \
    \  return l[Math.floor(mid)];\n  }\n}\n", "    const sortedList = l.sort((a, b)\
    \ => a - b);\n    const mid = Math.floor(sortedList.length / 2);\n    return sortedList.length\
    \ % 2 === 0 ? (sortedList[mid] + sortedList[mid - 1]) / 2 : sortedList[mid];\n\
    }\n", "    let n = l.length;\n    if (n % 2 == 0) {\n        return (l[n / 2 -\
    \ 1] + l[n / 2]) / 2;\n    } else {\n        return l[(n - 1) / 2];\n    }\n}\n\
    \nexport = {\n    mean,\n    median\n}", "    return 0;\n}\n", "    let length\
    \ = l.length;\n    if (length % 2 === 0) {\n        return (l[length / 2] + l[length\
    \ / 2 - 1]) / 2;\n    } else {\n        return l[(length - 1) / 2];\n    }\n}\n",
  "    //TODO\n    return 0;\n}\n", "  var list: number[] = quicksort(l);\n  var len:\
    \ number = list.length;\n  if (len%2 == 0) {\n    return ((list[len/2] + list[len/2-1])/2.0);\n\
    \  } else {\n    return list[(len-1)/2];\n  }\n}\n\nexport {\n  max,\n  mean,\n\
    \  median,\n  min,\n  quicksort,\n  sum\n}", "  if (l.length == 0) return 0;\n\
    \  l.sort((a, b) => a - b);\n  const half = Math.floor(l.length / 2);\n  if (l.length\
    \ % 2) return l[half];\n  return (l[half - 1] + l[half]) / 2.0;\n}\n", "  if (l.length\
    \ === 0) return 0;\n  l.sort();\n  const mid = Math.floor(l.length / 2);\n  if\
    \ (l.length % 2 === 0) {\n    return (l[mid] + l[mid - 1]) / 2;\n  } else {\n\
    \    return l[mid];\n  }\n}\n", "    if (l.length === 0) {\n        return 0;\n\
    \    }\n    const sorted = l.sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length\
    \ / 2);\n    if (sorted.length % 2 === 0) {\n        return (sorted[mid - 1] +\
    \ sorted[mid]) / 2;\n    }\n    return sorted[mid];\n}\n", "    if (l.length ==\
    \ 0) {\n        return null;\n    }\n\n    l.sort();\n    let mid: number = l.length\
    \ / 2;\n    return l.length % 2 === 0 ? (l[mid - 1] + l[mid]) / 2 : l[mid];\n\
    }\n\nconsole.log(median([3, 1, 2, 4, 5]));\nconsole.log(median([-10, 4, 6, 1000,\
    \ 10, 20]));", "  // TODO: Your code here\n  const sorted = l.sort((a, b) => a\
    \ - b);\n  const half = Math.floor(sorted.length / 2);\n  if (sorted.length %\
    \ 2) {\n    return sorted[half];\n  } else {\n    return (sorted[half - 1] + sorted[half])\
    \ / 2.0;\n  }\n}\n", "    l.sort();\n    let middle_index = Math.floor(l.length\
    \ / 2);\n    if (l.length % 2 == 0) {\n        return (l[middle_index] + l[middle_index\
    \ - 1]) / 2;\n    } else {\n        return l[middle_index];\n    }\n}\n", "  \
    \  l.sort();\n    const len = l.length;\n    const middle = Math.floor(len / 2);\n\
    \    return len % 2 !== 0 ? l[middle] : (l[middle - 1] + l[middle]) / 2;\n}\n",
  "    return quantile(l, 0.5);\n}\n", "    l.sort();\n    if (l.length % 2 == 0)\
    \ {\n        var index1 = (l.length / 2) - 1;\n        var index2 = l.length /\
    \ 2;\n        return (l[index1] + l[index2]) / 2;\n    }\n    else {\n       \
    \ var index = (l.length - 1) / 2;\n        return l[index];\n    }\n}\n", "  \
    \  // Your code here\n    let total = 0;\n    let length = l.length;\n    for\
    \ (let i = 0; i < length; i++) {\n        total += l[i];\n    }\n    return total\
    \ / length;\n}\n", "  var sorted = l.sort();\n  var len = sorted.length;\n  if\
    \ (len % 2 === 0) {\n    return (sorted[len / 2 - 1] + sorted[len / 2]) / 2;\n\
    \  } else {\n    return sorted[(len - 1) / 2];\n  }\n}\n", "    var even = 0;\n\
    \    var odd = 0;\n    var n = l.length;\n    var median;\n    if (n % 2 == 0)\
    \ {\n        even = n / 2;\n        odd = n / 2 - 1;\n        median = (l[even]\
    \ + l[odd]) / 2;\n    } else {\n        odd = (n - 1) / 2;\n        median = l[odd];\n\
    \    }\n    return median;\n}\n", "    l.sort((a, b) => a - b);\n    const l2\
    \ = l.length / 2;\n    if (Number.isInteger(l2)) {\n        return (l[l2 - 1]\
    \ + l[l2]) / 2;\n    } else {\n        return l[Math.floor(l2)];\n    }\n}\n",
  "    // TODO\n    return 0.0;\n}\n", "  var size = l.length;\n  if (size < 1) {\n\
    \    return null;\n  }\n  if (size == 1) {\n    return l[0];\n  }\n  if (size\
    \ % 2 == 0) {\n    return (l[size / 2] + l[size / 2 - 1]) / 2;\n  }\n  return\
    \ l[(size - 1) / 2];\n}\n", "    return 0;\n}\n", "    let sorted = l.sort();\n\
    \    let n = l.length;\n    let mid = Math.floor(n / 2);\n    return n % 2 ===\
    \ 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];\n}\n", "    return 0;\n\
    }\n", "    l.sort((a, b) => a - b);\n    let middle = Math.floor(l.length / 2);\n\
    \    return l.length % 2 ? l[middle] : (l[middle - 1] + l[middle]) / 2;\n}\n",
  "  return mean(l);\n}\n", "  const sorted = l.sort((a, b) => a - b);\n  const middle\
    \ = Math.floor(sorted.length / 2);\n  return sorted.length % 2 === 0\n    ? (sorted[middle\
    \ - 1] + sorted[middle]) / 2\n    : sorted[middle];\n}\n", "  const numbers =\
    \ l.sort((a, b) => a - b);\n  const middle = Math.floor(numbers.length / 2);\n\
    \  return numbers.length % 2 !== 0 ? numbers[middle] : (numbers[middle - 1] +\
    \ numbers[middle]) / 2;\n}\n", "    const sorted = l.sort((a, b) => a - b);\n\
    \    if (sorted.length % 2 === 0) {\n        return (sorted[sorted.length / 2\
    \ - 1] + sorted[sorted.length / 2]) / 2;\n    } else {\n        return sorted[Math.floor(sorted.length\
    \ / 2)];\n    }\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
