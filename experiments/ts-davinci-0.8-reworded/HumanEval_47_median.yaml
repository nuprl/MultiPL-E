name: HumanEval_47_median
language: ts
prompt: "//Return median of elements in the array l.\n// >>> median([3, 1, 2, 4, 5])\n\
  // 3\n// >>> median([-10, 4, 6, 1000, 10, 20])\n// 15.0\nfunction median(l: number[]):\
  \ number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = median;\n  assert.deepEqual(candidate([3, 1, 2, 4,\
  \ 5]),3);\n  assert.deepEqual(candidate([-10, 4, 6, 1000, 10, 20]),8.0);\n  assert.deepEqual(candidate([5]),5);\n\
  \  assert.deepEqual(candidate([6, 5]),5.5);\n  assert.deepEqual(candidate([8, 1,\
  \ 3, 9, 9, 2, 7]),7);\n}\n\ntest();"
completions: ["    //Seems a little bit redundant.\n    return avg(l);\n}\n", "  \
    \  // TODO\n    return 0;\n}\n", "    let sortedArray = l.sort((a, b) => a - b);\n\
    \    let midpoint = Math.floor(sortedArray.length / 2);\n    if (sortedArray.length\
    \ % 2 === 0) {\n        return (sortedArray[midpoint] + sortedArray[midpoint -\
    \ 1]) / 2;\n    } else {\n        return sortedArray[midpoint];\n    }\n}\n",
  "    //IMPLEMENT ME\n    if(l.length % 2 == 0){\n        return ((l[(l.length/2)]\
    \ + l[(l.length/2) - 1])/2);\n    }\n    else {\n        return l[Math.floor(l.length/2)];\n\
    \    }\n}\n", "    const sorted = l.sort((a, b) => a - b);\n    const len = sorted.length;\n\
    \    if (len % 2 === 0) {\n        const mi = len / 2;\n        return (sorted[mi\
    \ - 1] + sorted[mi]) / 2;\n    } else {\n        return sorted[(len - 1) / 2];\n\
    \    }\n}\n", "  if (l.length === 0) {\n    return 0;\n  }\n\n  const sorted =\
    \ l.sort((a, b) => a - b);\n  const middle = Math.floor(sorted.length / 2);\n\n\
    \  if (sorted.length % 2) {\n    return sorted[middle];\n  } else {\n    return\
    \ (sorted[middle - 1] + sorted[middle]) / 2.0;\n  }\n}\n", "    let mid: number\
    \ = Math.floor(l.length / 2);\n    let l1: number[] = l.slice(0, mid).sort();\n\
    \    let l2: number[] = l.slice(mid, l.length).sort();\n    if (l.length % 2 ===\
    \ 0) {\n        return (l1[mid - 1] + l2[0]) / 2;\n    } else {\n        return\
    \ l2[0];\n    }\n}\n", "  if (l.length === 0) {\n    return null;\n  }\n  if (l.length\
    \ === 1) {\n    return l[0];\n  }\n  let temp = l.slice();\n  temp.sort((a, b)\
    \ => a - b);\n  if (temp.length % 2 === 0) {\n    return (temp[temp.length / 2\
    \ - 1] + temp[temp.length / 2]) / 2;\n  } else {\n    return temp[Math.floor(temp.length\
    \ / 2)];\n  }\n}\n", "  let l1 = l.slice().sort((a, b) => a - b);\n  let len =\
    \ l1.length;\n  if (len % 2 === 0) {\n    return (l1[len / 2 - 1] + l1[len / 2])\
    \ / 2;\n  } else {\n    return l1[Math.floor(len / 2)];\n  }\n}\n", "    //YOUR\
    \ CODE HERE\n    return 0;\n}", "    let numItems = l.length;\n    if (numItems\
    \ == 0) {\n        return -1;\n    } else if (numItems % 2 == 0) {\n        let\
    \ mid = (numItems / 2) - 1;\n        return (l[mid] + l[mid + 1]) / 2;\n    }\
    \ else {\n        let mid = Math.floor(numItems / 2);\n        return l[mid];\n\
    \    }\n}\n", "    let copy = l.slice(0, l.length);\n    copy.sort(function(a,\
    \ b) {\n        return a - b;\n    });\n    let mid = Math.floor(copy.length /\
    \ 2);\n    if (copy.length % 2 === 0) {\n        return (copy[mid] + copy[mid\
    \ - 1]) / 2;\n    } else {\n        return copy[mid];\n    }\n}", "  let sortedList\
    \ = l.sort();\n  let listLength = sortedList.length;\n  if (listLength === 0)\
    \ {\n    return 0;\n  } else if (listLength % 2 !== 0) {\n    return sortedList[(listLength\
    \ - 1) / 2];\n  } else {\n    return (sortedList[listLength / 2] + sortedList[listLength\
    \ / 2 - 1]) / 2;\n  }\n}\n", "  let x = l.sort((a, b) => a - b);\n  let y = x.length\
    \ / 2;\n  if (y % 2 == 0) {\n    return x[y];\n  } else {\n    return (x[y - 0.5]\
    \ + x[y + 0.5]) / 2;\n  }\n}\n", "    l.sort();\n    let mid = Math.floor(l.length\
    \ / 2);\n    if (l.length % 2) {\n        return l[mid];\n    } else {\n     \
    \   return (l[mid - 1] + l[mid]) / 2.0;\n    }\n}\n", "    l.sort(function(a,\
    \ b) {\n        return a - b;\n    });\n    let len = l.length;\n    if (len %\
    \ 2 == 0) {\n        return (l[len / 2 - 1] + l[len / 2]) / 2;\n    } else {\n\
    \        return l[Math.floor(len / 2)];\n    }\n}\n", "  return (l[~~(l.length\
    \ / 2)] + l[Math.ceil(l.length / 2)]) / 2;\n}\n", "    if (l.length === 0) {\n\
    \        return 0;\n    }\n    let sorted = l.sort();\n    let mid = sorted.length\
    \ / 2;\n    return mid % 1 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[Math.floor(mid)];\n\
    }\n\nexport class RingBuffer<T> {\n    private buf: T[];\n    private lastIndex:\
    \ number;\n    private size: number;\n\n    constructor(size: number) {\n    \
    \    this.buf = [];\n        this.lastIndex = 0;\n        this.size = size;\n\
    \    }\n\n    //Add element elem to the end of the ring buffer. \n    //Return\
    \ true if element was added, false if there is no more space.\n    public push(elem:\
    \ T): boolean {\n        if (this.buf.length < this.size) {\n            this.buf.push(elem);\n\
    \            return true;\n        }\n        this.buf[this.lastIndex] = elem;\n\
    \        this.lastIndex++;\n        if (this.lastIndex === this.size) {\n    \
    \        this.lastIndex = 0;\n        }\n        return true;\n    }\n\n    //Return\
    \ the nth last pushed element, n >= 1. \n    //If there is no nth last pushed\
    \ element, return undefined.\n    public get(n: number): T | undefined {\n   \
    \     if (n > this.buf.length) {\n            return undefined;\n        }\n \
    \       if (this.lastIndex - n < 0) {\n            return this.buf[this.size +\
    \ this.lastIndex - n];\n        }\n        return this.buf[this.lastIndex - n];\n\
    \    }\n\n    //Return the number of elements in the ring buffer.\n    public\
    \ count(): number {\n        return this.buf.length;\n    }\n}\n", "    let m:\
    \ number = l.length / 2;\n    if (l.length % 2 === 0) {\n        return (l[m -\
    \ 1] + l[m]) / 2;\n    } else {\n        return l[Math.floor(m)];\n    }\n}\n",
  "    if (l.length === 0) {\n        return 0;\n    }\n\n    l.sort();\n    if (l.length\
    \ % 2 === 0) {\n        return (l[l.length / 2 - 1] + l[l.length / 2]) / 2;\n\
    \    }\n    return l[(l.length - 1) / 2];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
