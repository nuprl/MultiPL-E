name: HumanEval_111_histogram
language: ts
prompt: "//Given a string representing a space separated lowercase letters, return\
  \ an object\n// of the letter with the most repetition and containing the corresponding\
  \ count.\n// If several letters have the same occurrence, return all of them.\n\
  // Example:\n// >>> histogram(\"a b c\")\n// {\"a\": 1, \"b\": 1, \"c\": 1}\n//\
  \ >>> histogram(\"a b b a\")\n// {\"a\": 2, \"b\": 2}\n// >>> histogram(\"a b c\
  \ a b\")\n// {\"a\": 2, \"b\": 2}\n// >>> histogram(\"b b b b a\")\n// {\"b\": 4}\n\
  // >>> histogram(\"\")\n// {}\nfunction histogram(test: string): {[key: string]:\
  \ number} {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = histogram;\n  assert.deepEqual(candidate(\"a b b a\"\
  ),{\"a\": 2, \"b\": 2});\n  assert.deepEqual(candidate(\"a b c a b\"),{\"a\": 2,\
  \ \"b\": 2});\n  assert.deepEqual(candidate(\"a b c d g\"),{\"a\": 1, \"b\": 1,\
  \ \"c\": 1, \"d\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"r t g\"),{\"r\"\
  : 1, \"t\": 1, \"g\": 1});\n  assert.deepEqual(candidate(\"b b b b a\"),{\"b\":\
  \ 4});\n  assert.deepEqual(candidate(\"r t g\"),{\"r\": 1, \"t\": 1, \"g\": 1});\n\
  \  assert.deepEqual(candidate(\"\"),{});\n  assert.deepEqual(candidate(\"a\"),{\"\
  a\": 1});\n}\n\ntest();"
completions: ["    let count: {[key: string]: number} = {};\n    for (let i = 0; i\
    \ < test.length; i++) {\n        if (test[i] !== \" \") {\n            count[test[i]]\
    \ = count[test[i]] + 1 || 1;\n        }\n    }\n    return count;\n}\n", "   \
    \ let result = {};\n    let testArr = test.split(\" \");\n    for (let i = 0;\
    \ i < testArr.length; i++) {\n        if (testArr[i] in result) {\n          \
    \  result[testArr[i]]++;\n        } else {\n            result[testArr[i]] = 1;\n\
    \        }\n    }\n    let temp = 0;\n    let maxArr = [];\n    for (let prop\
    \ in result) {\n        if (result[prop] > temp) {\n            temp = result[prop];\n\
    \            maxArr = [];\n            maxArr.push(prop);\n        } else if (result[prop]\
    \ === temp) {\n            maxArr.push(prop);\n        }\n    }\n    let maxCount\
    \ = {};\n    for (let i = 0; i < maxArr.length; i++) {\n        maxCount[maxArr[i]]\
    \ = temp;\n    }\n    return maxCount;\n}\nconsole.log(histogram(\"a b c\"));\n\
    console.log(histogram(\"a b b a\"));\nconsole.log(histogram(\"a b c a b\"));\n\
    console.log(histogram(\"b b b b a\"));\nconsole.log(histogram(\"\"));", "  let\
    \ result = {};\n  test.split(\" \").forEach(element => {\n    result[element]\
    \ = result[element] ? result[element] + 1 : 1;\n  });\n  return result;\n}\n",
  "  let chars = test.split(\" \");\n  let map: {[key: string]: number} = {};\n  chars.forEach(char\
    \ => {\n    map[char] = map[char] + 1 || 1;\n  });\n  return map;\n}\n", "   \
    \ // Remove empty string\n    const words = test.split(\" \").filter(word => word\
    \ !== \"\");\n    // Sort list from largest to smallest\n    const sortedWords\
    \ = words.sort((a, b) => words.filter(v => v === b).length - words.filter(v =>\
    \ v === a).length);\n    // Filter largest word(s)\n    const topWords = sortedWords.filter(word\
    \ => word === sortedWords[0]);\n    // Dict of words and number of times word\
    \ appears\n    return topWords.reduce((acc: {[key: string]: number}, cur: string)\
    \ => {\n        acc[cur] = words.filter(word => word === cur).length;\n      \
    \  return acc;\n    }, {});\n}\n", "  const charMap: {[key: string]: number} =\
    \ {};\n  const maxes: {[key: string]: number} = {};\n  let maxCount = 0;\n  for\
    \ (const c of test.split(' ')) {\n    charMap[c] = charMap[c] + 1 || 1;\n    if\
    \ (charMap[c] > maxCount) {\n      maxCount = charMap[c];\n      maxes[c] = charMap[c];\n\
    \    } else if (charMap[c] === maxCount) {\n      maxes[c] = charMap[c];\n   \
    \ }\n  }\n  return maxes;\n}\n", "    const arr = test.split(\" \");\n    const\
    \ histo = {};\n    for (const x of arr) {\n        if (x in histo) {\n       \
    \     histo[x] += 1;\n        } else {\n            histo[x] = 1;\n        }\n\
    \    }\n    return histo;\n}\nconsole.log(histogram(\"a b c\"));\nconsole.log(histogram(\"\
    a b b a\"));\nconsole.log(histogram(\"a b c a b\"));\nconsole.log(histogram(\"\
    b b b b a\"));\nconsole.log(histogram(\"\"));", "  const histo: {[key: string]:\
    \ number} = {};\n  const letters = test.split(\" \");\n  letters.forEach((letter)\
    \ => {\n    if (histo[letter]) {\n      histo[letter] += 1;\n    } else {\n  \
    \    histo[letter] = 1;\n    }\n  });\n  const maxCount = Math.max(...Object.values(histo));\n\
    \  const final = {};\n  Object.keys(histo).forEach((key) => {\n    if (histo[key]\
    \ === maxCount) {\n      final[key] = maxCount;\n    }\n  });\n  return final;\n\
    }\n", "  const letters = test.split(' ');\n  const hist = {};\n  for (const letter\
    \ of letters) {\n    if (letter in hist) {\n      hist[letter]++;\n    } else\
    \ {\n      hist[letter] = 1;\n    }\n  }\n  return hist;\n}\n", "    let obj:\
    \ {[key: string]: number} = {};\n    test.split(' ').forEach(function(el) {\n\
    \        if (obj[el]) {\n            obj[el]++;\n        } else {\n          \
    \  obj[el] = 1;\n        }\n    });\n    return obj;\n}\nconsole.log(histogram(\"\
    a b c\"));\nconsole.log(histogram(\"a b b a\"));\nconsole.log(histogram(\"a b\
    \ c a b\"));\nconsole.log(histogram(\"b b b b a\"));\nconsole.log(histogram(\"\
    \"));", "    const map: {[key: string]: number} = {};\n    test.split(' ').forEach(letter\
    \ => {\n        map[letter] = (map[letter] || 0) + 1;\n    });\n    return map;\n\
    }\nconsole.log(histogram(\"a b c\"));\nconsole.log(histogram(\"a b b a\"));\n\
    console.log(histogram(\"a b c a b\"));\nconsole.log(histogram(\"b b b b a\"));\n\
    console.log(histogram(\"\"));\n", "  const histogram = {} as {[key: string]: number};\n\
    \  test.split(' ').forEach(char => {\n    if (histogram[char]) {\n      histogram[char]++;\n\
    \    } else {\n      histogram[char] = 1;\n    }\n  });\n  const max = Math.max(...Object.values(histogram));\n\
    \  return Object.keys(histogram).reduce((acc, key) => {\n    if (histogram[key]\
    \ === max) {\n      acc[key] = histogram[key];\n    }\n    return acc;\n  }, {}\
    \ as {[key: string]: number});\n}\n", "    const arr = test.split(' ');\n    const\
    \ result: {[key: string]: number} = {};\n    let max: number = 0;\n    for (let\
    \ i = 0; i < arr.length; i++) {\n        if (result[arr[i]]) {\n            result[arr[i]]++;\n\
    \        } else {\n            result[arr[i]] = 1;\n        }\n        if (result[arr[i]]\
    \ > max) {\n            max = result[arr[i]];\n        }\n    }\n    const output:\
    \ {[key: string]: number} = {};\n    for (const key in result) {\n        if (result[key]\
    \ === max) {\n            output[key] = result[key];\n        }\n    }\n    return\
    \ output;\n}\nconsole.log(histogram('a b c'));\nconsole.log(histogram('a b b a'));\n\
    console.log(histogram('a b c a b'));\nconsole.log(histogram('b b b b a'));\nconsole.log(histogram(''));",
  "    const h: {[key: string]: number} = {};\n    test.split(' ').forEach(item =>\
    \ {\n        if (item) {\n            h[item] = h[item] + 1 || 1;\n        }\n\
    \    });\n    return h;\n}\n", "    let wordList = test.split(\" \");\n    let\
    \ wordSet = new Set(wordList);\n    let wordDict: {[key: string]: number} = {};\n\
    \    let maxVal = 0;\n    let maxLetter: string[] = [];\n    for (let word of\
    \ wordSet) {\n        wordDict[word] = 0;\n    }\n    for (let i = 0; i < wordList.length;\
    \ i++) {\n        let word = wordList[i];\n        wordDict[word] += 1;\n    \
    \    if (wordDict[word] > maxVal) {\n            maxVal = wordDict[word];\n  \
    \          maxLetter = [word];\n        } else if (wordDict[word] === maxVal)\
    \ {\n            maxLetter.push(word);\n        }\n    }\n    for (let word of\
    \ wordSet) {\n        if (wordDict[word] < maxVal) {\n            delete wordDict[word];\n\
    \        }\n    }\n    return wordDict;\n}\n\nexport = histogram;", "  const result:\
    \ {[key: string]: number} = {};\n  test.split(\" \").forEach((n) => {\n    if\
    \ (result[n]) {\n      result[n] += 1;\n    } else {\n      result[n] = 1;\n \
    \   }\n  });\n  return result;\n}\n", "  const array = test.split(\" \");\n  const\
    \ result: {[key: string]: number} = {};\n  for (const item of array) {\n    if\
    \ (result[item]) {\n      result[item]++;\n    } else {\n      result[item] =\
    \ 1;\n    }\n  }\n  return result;\n}\n", "    const histogram = {}\n    test.split(\"\
    \ \").forEach(l => {\n        histogram[l] = (histogram[l] || 0) + 1\n    })\n\
    \    return histogram\n}\n", "  let map: {[key: string]: number} = {};\n  let\
    \ maxCount: number = 0;\n  let maxCountValues: string[] = [];\n  test.split(\"\
    \ \").forEach(\n    (element: string) => {\n      if (map[element] === undefined)\
    \ {\n        map[element] = 1;\n      } else {\n        map[element] += 1;\n \
    \     }\n      if (map[element] === maxCount) {\n        maxCountValues.push(element);\n\
    \      } else if (map[element] > maxCount) {\n        maxCount = map[element];\n\
    \        maxCountValues = [element];\n      }\n    }\n  );\n  maxCountValues.forEach(\n\
    \    (key: string) => {\n      map[key] = maxCount;\n    }\n  );\n  return map;\n\
    }\n\nexport const __test__ = {\n  histogram,\n};", "    let result: {[key: string]:\
    \ number} = {};\n    let max: number = 0;\n    test.split(\" \").forEach(function(x)\
    \ {\n        if(result[x] === undefined) {\n            result[x] = 1;\n     \
    \   } else {\n            result[x]++;\n        }\n        if(result[x] > max)\
    \ {\n            max = result[x];\n        }\n    });\n    let keys: string[]\
    \ = Object.keys(result);\n    for(let i = 0; i < keys.length; i++) {\n       \
    \ if(result[keys[i]] < max) {\n            delete result[keys[i]];\n        }\n\
    \    }\n    return result;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
