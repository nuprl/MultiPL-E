name: HumanEval_83_starts_one_ends
language: ts
prompt: "//Given a positive integer n, return the count of the numbers of n-digit\n\
  // positive integers that start or end with 1.\nfunction starts_one_ends(n: number):\
  \ number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = starts_one_ends;\n  assert.deepEqual(candidate(1),1);\n\
  \  assert.deepEqual(candidate(2),18);\n  assert.deepEqual(candidate(3),180);\n \
  \ assert.deepEqual(candidate(4),1800);\n  assert.deepEqual(candidate(5),18000);\n\
  }\n\ntest();"
completions: ["  if (n === 1) {\n    return 2;\n  }\n  if (n === 2) {\n    return\
    \ 4;\n  }\n  return starts_one_ends(n - 1) + starts_one_ends(n - 2);\n}\n", " \
    \ return 0;\n}\n", "    let count = 0;\n    for (let i = 1; i <= n; i++) {\n \
    \       count += Math.pow(10, i-1);\n    }\n    return count;\n}", "  if (n <=\
    \ 0) {\n    return 0;\n  }\n\n  if (n === 1) {\n    return 2;\n  }\n\n  return\
    \ starts_one_ends(n - 1) + 9 * Math.pow(10, n - 2);\n}\n", "    if (n == 1) {\n\
    \        return 1;\n    } else if (n == 2) {\n        return 20;\n    } else {\n\
    \        // The key observation is that if you drop the first or last digit from\n\
    \        // a number, you get a number with n-1 digits.\n        //\n        //\
    \ When we drop the last digit, we get a number with (n-1) digits, of\n       \
    \ // which the first digit can be any of the digits 0 through 9, except\n    \
    \    // 1. If the last digit was 1, we could still be dropping a 1, so we\n  \
    \      // must include the first-digit-one numbers again. Hence, we get 20 *\n\
    \        // (starts_one_ends(n-1) - 1)\n        //\n        // When we drop the\
    \ first digit, we get a number with (n-1) digits, of\n        // which the last\
    \ digit can be any of the digits 0 through 9, except 1.\n        // If the first\
    \ digit was 1, we could still be dropping a 1, so we must\n        // include\
    \ the last-digit-one numbers again. Hence, we get 10 *\n        // (starts_one_ends(n-1)\
    \ - 1)\n        //\n        // We have not considered the numbers where the first\
    \ digit is 1 and the\n        // last digit is 1. Those numbers have n-2 digits.\
    \ Since the first digit\n        // is 1, we can have the last digit of these\
    \ numbers be any of the\n        // digits 0 through 9, except 1. So, we get 20\
    \ * (starts_one_ends(n-2) -\n        // 1)\n        return 20 * (starts_one_ends(n-1)\
    \ - 1) + 10 * (starts_one_ends(n-1) - 1) + 20 * (starts_one_ends(n-2) - 1);\n\
    \    }\n}\n", "    if (n == 1) return 2;\n    return n * 9;\n}\n", "    let count\
    \ = 0;\n    for (let i = 1; i <= n; i++) {\n        count += Math.pow(10, i -\
    \ 1);\n    }\n    return count;\n}\n", "  // Your code here\n  return 0;\n}\n",
  "  if (n == 1) {\n    return 1;\n  }\n  return 1 + Math.pow(10, n - 1) + 9 * Math.pow(10,\
    \ n - 2);\n}\n", "    if (n === 1) {\n        return 2;\n    } else {\n      \
    \  return Math.pow(10, n - 1) + 9 * Math.pow(10, n - 2);\n    }\n}", "  // the\
    \ last digit of a number can only be 0 to 9,\n  // so the first digit can be 1\
    \ or 2 to 9.\n  // Then, there are 9 possibilities.\n\n  // Secondly, the last\
    \ digit of a number can be 1 or any number from 2 to 9.\n  // Then, the first\
    \ digit can be 0 or any number from 1 to 9.\n  // There are 10 possibilities.\n\
    \n  // Firstly, the last digit of a number can be 1.\n  // Then, the first digit\
    \ can be any number from 1 to 9.\n  // There are 9 possibilities.\n\n  // Finally,\n\
    \  // if n = 1, then numbers of 1-digit positive integers that start or end with\
    \ 1 is 1\n  // if n = 2, then numbers of 2-digit positive integers that start\
    \ or end with 1 is 9 + 10 = 19\n  // if n = 3, then numbers of 3-digit positive\
    \ integers that start or end with 1 is 9 * 10 + 10 * 9 + 9 = 189\n  // if n =\
    \ 4, then numbers of 4-digit positive integers that start or end with 1 is 9 *\
    \ 10 * 10 + 10 * 9 * 10 + 9 * 10 = 2889\n  // if n = 5, then numbers of 5-digit\
    \ positive integers that start or end with 1 is 9 * 10 * 10 * 10 + 10 * 9 * 10\
    \ * 10 + 9 * 10 * 10 = 38889\n  // if n = 6, then numbers of 6-digit positive\
    \ integers that start or end with 1 is 9 * 10 * 10 * 10 * 10 + 10 * 9 * 10 * 10\
    \ * 10 + 9 * 10 * 10 * 10 = 488889\n  // ...\n  // ...\n  // So, we can make a\
    \ recursive function that is 9 * 10^(n-2) + 10 * 9 * 10^(n-3) + 9 * 10^(n-2) =\
    \ 9 * 10^(n-2) + 9 * 10^(n-2) = 18 * 10^(n-2)\n\n  // if n = 0, then numbers of\
    \ 0-digit positive integers that start or end with 1 is 0\n  // if n = 1, then\
    \ numbers of 1-digit positive integers that start or end with 1 is 1\n  // if\
    \ n = 2, then numbers of 2-digit positive integers that start or", "  if (n ==\
    \ 1) {\n    return 1;\n  }\n  if (n < 0) {\n    return 0;\n  }\n  let result =\
    \ 1;\n  const mod = 10 ** 9 + 7;\n  const t = Math.pow(10, n);\n  for (let i =\
    \ 0; i < n - 1; i++) {\n    result = (result * 10) % mod;\n  }\n  return (result\
    \ * t) % mod;\n}\n\nconsole.log(starts_one_ends(2));\nconsole.log(starts_one_ends(3));\n\
    console.log(starts_one_ends(4));\nconsole.log(starts_one_ends(5));\nconsole.log(starts_one_ends(6));\n\
    console.log(starts_one_ends(7));\nconsole.log(starts_one_ends(8));\nconsole.log(starts_one_ends(9));\n\
    console.log(starts_one_ends(10));\nconsole.log(starts_one_ends(11));\nconsole.log(starts_one_ends(20));\n\
    console.log(starts_one_ends(50));\nconsole.log(starts_one_ends(100));\nconsole.log(starts_one_ends(200));\n\
    console.log(starts_one_ends(300));\nconsole.log(starts_one_ends(400));\nconsole.log(starts_one_ends(500));\n\
    console.log(starts_one_ends(600));\nconsole.log(starts_one_ends(700));\nconsole.log(starts_one_ends(800));\n\
    console.log(starts_one_ends(900));\nconsole.log(starts_one_ends(1000));\nconsole.log(starts_one_ends(1100));\n\
    console.log(starts_one_ends(1200));\nconsole.log(starts_one_ends(1300));\nconsole.log(starts_one_ends(1400));\n\
    console.log(starts_one_ends(1500));\nconsole.log(starts_one_ends(1600));\nconsole.log(",
  "    if (n < 1) {\n        return -1;\n    }\n    if (n === 1) {\n        return\
    \ 1;\n    }\n    return starts_one_ends(n - 1) + starts_one_ends(n - 2);\n}\n",
  "  let count = 0;\n  for (let i = 1; i <= n; i++) {\n    count += 9 * Math.pow(10,\
    \ i - 1);\n  }\n  return count;\n}\n\nconsole.log(starts_one_ends(2));\nconsole.log(starts_one_ends(3));\n\
    console.log(starts_one_ends(4));\nconsole.log(starts_one_ends(5));\nconsole.log(starts_one_ends(6));\n\
    console.log(starts_one_ends(7));\nconsole.log(starts_one_ends(8));\nconsole.log(starts_one_ends(9));\n\
    console.log(starts_one_ends(10));\n", "  if (n === 1) {\n    return 2;\n  } else\
    \ {\n    return 10 * starts_one_ends(n - 1) - 9;\n  }\n}\n", "  if (n == 1) {\n\
    \    return 1;\n  }\n  return starts_one_ends(n - 1) + 9 * Math.pow(10, n - 2);\n\
    }\n", "  // Write your code here\n  let dp = new Array(n + 1).fill(0);\n  dp[1]\
    \ = 10;\n  let mod = 1000000007;\n  for (let i = 2; i <= n; i++) {\n    dp[i]\
    \ = (dp[i - 1] * 10 - 2) % mod;\n  }\n  return dp[n];\n}\n", "  if (n == 1) {\n\
    \    return 1;\n  }\n  return 9 * Math.pow(10, n - 1) + starts_one_ends(n - 1);\n\
    }\nconsole.log(starts_one_ends(2));\nconsole.log(starts_one_ends(3));\nconsole.log(starts_one_ends(4));\n\
    console.log(starts_one_ends(5));\n", "    if (n === 1) {\n        return 1;\n\
    \    }\n    if (n === 2) {\n        return 10;\n    }\n    let count = 10;\n \
    \   for (let i = 3; i <= n; i++) {\n        count += count * 9;\n    }\n    return\
    \ count;\n}", "    let previous = [1, 1, 2];\n    for (let i = 3; i <= n; i++)\
    \ {\n        previous[i] = previous[i - 1] + previous[i - 2];\n    }\n    return\
    \ previous[n];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
