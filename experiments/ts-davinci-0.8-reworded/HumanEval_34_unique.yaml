name: HumanEval_34_unique
language: ts
prompt: "//Return sorted unique elements in an array\n// >>> unique([5, 3, 5, 2, 3,\
  \ 3, 9, 0, 123])\n// [0, 2, 3, 5, 9, 123]\nfunction unique(l: number[]): number[]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = unique;\n  assert.deepEqual(candidate([5, 3, 5, 2,\
  \ 3, 3, 9, 0, 123]),[0, 2, 3, 5, 9, 123]);\n}\n\ntest();"
completions: ["  let l2 = l.sort((a, b) => a - b);\n  let last = null;\n  let u: number[]\
    \ = [];\n  for (let i = 0; i < l2.length; i++) {\n    if (l2[i] != last) {\n \
    \     u.push(l2[i]);\n      last = l2[i];\n    }\n  }\n  return u;\n}\n", "  let\
    \ sorted = l.sort();\n  let res = [sorted[0]];\n  for (let i = 1; i < sorted.length;\
    \ i++) {\n    if (sorted[i] != sorted[i - 1]) {\n      res.push(sorted[i]);\n\
    \    }\n  }\n  return res;\n}\n", "    return l.filter((x, i) => l.indexOf(x)\
    \ === i).sort((a, b) => a - b);\n}\n", "  return l.filter((_, i) => l.indexOf(_)\
    \ === i).sort()\n}\n\nexport const areUnique = (\n  l: number[],\n  uniq = unique(l)\n\
    ): boolean => uniq.length === l.length\n", "  return [...new Set(l)];\n}\n", " \
    \   return l.filter((e, i) => i === l.indexOf(e)).sort((a, b) => a - b);\n}\n",
  "  return [...new Set(l)]\n}\n", "    return l.sort().filter((d, i) => i === 0 ||\
    \ d !== l[i - 1]);\n}\n", "  return Array.from(new Set(l))\n}\n", "    let result:\
    \ number[] = [];\n    for (let element of l) {\n        if (result.indexOf(element)\
    \ == -1) {\n            result.push(element);\n        }\n    }\n    return result.sort();\n\
    }\n", "  return l.filter((x, i) => l.indexOf(x) === i);\n}\n", "  return [...new\
    \ Set(l)].sort((a, b) => a - b);\n}\n\nexport {\n  factorial,\n  fibonacci,\n\
    \  isPrime,\n  primes,\n  range,\n  unique,\n};", "    let u = l.filter((value,\
    \ index, self) => self.indexOf(value) === index);\n    u.sort((a, b) => a - b);\n\
    \    return u;\n}\n", "  return [...new Set(l)];\n}\n", "    return l.filter((value,\
    \ index, self) => self.indexOf(value) === index);\n}\n", "    return [...new Set(l)];\n\
    }\n", "    let result: number[] = [];\n    let seen: number[] = [];\n    for (let\
    \ i = 0; i < l.length; i++) {\n        let elt = l[i];\n        if (seen.indexOf(elt)\
    \ !== -1) continue;\n        seen.push(elt);\n        result.push(elt);\n    }\n\
    \    return result;\n}\n", "  let ls = l.slice(0);\n  let result = [];\n  for\
    \ (let i = 0; i < ls.length; i++) {\n    if (result.indexOf(ls[i]) == -1) {\n\
    \      result.push(ls[i]);\n    }\n  }\n  return result;\n}\n", "    const uniqued\
    \ = [];\n    const len = l.length;\n    for (let i = 0; i < len; i++) {\n    \
    \    const item = l[i];\n        if (uniqued.indexOf(item) === -1) {\n       \
    \     uniqued.push(item);\n        }\n    }\n    return uniqued.sort();\n}\n",
  "  return [...new Set(l)];\n}\n", "    return l.filter((e, i) => l.indexOf(e) ===\
    \ i).sort((a, b) => a - b);\n}\n", "    return l.filter((v, i, a) => a.indexOf(v)\
    \ === i).sort((a, b) => a - b);\n}\n", "    return l.sort().filter((el, i, a)\
    \ => i === 0 || el !== a[i - 1]);\n}\n", "    let list = [];\n    for (let item\
    \ of l) {\n        if (list.indexOf(item) == -1) {\n            list.push(item);\n\
    \        }\n    }\n    return list.sort();\n}\n", "    return l.filter((v, i,\
    \ a) => a.indexOf(v) === i).sort((a, b) => a - b);\n}\n", "  return [...new Set(l)].sort((a,\
    \ b) => a - b);\n}\n", "    return Array.from(new Set(l));\n}\n", "    return\
    \ l.sort().filter((e, i, arr) => i === 0 || e !== arr[i - 1]);\n}\n", "    return\
    \ [...new Set(l)].sort((a, b) => a - b);\n}\n", "    return Object.keys(l.reduce((o,\
    \ k) => (o[k] = null, o), {})).map(Number);\n}\n", "    return l.sort().filter((item,\
    \ index, arr) => item !== arr[index - 1]);\n}\n", "    return l.sort().filter((el,\
    \ i, array) => {\n        return el !== array[i-1];\n    });\n}\n", "  return\
    \ [...new Set(l)];\n}\n", "    return l.filter((v, i, a) => a.indexOf(v) === i).sort((a,\
    \ b) => a - b);\n}\n", "  return l.filter((x, i) => l.indexOf(x) === i).sort((a,\
    \ b) => a - b);\n}\n", "    const res: number[] = [];\n    for (let i: number\
    \ = 0; i < l.length; i++) {\n        if (res.indexOf(l[i]) === -1) {\n       \
    \     res.push(l[i]);\n        }\n    }\n    return res.sort((a, b) => a - b);\n\
    }\n", "    return l.filter((x, i) => i === l.indexOf(x)).sort();\n}\n", "    return\
    \ l.sort().filter((el, i, arr) => i < 1 || el !== arr[i - 1]);\n}\n", "  return\
    \ Array.from(new Set(l));\n}\n", "    let v: number[] = [];\n    for (let i =\
    \ 0; i < l.length; i++) {\n        if (v.indexOf(l[i]) === -1) {\n           \
    \ v.push(l[i]);\n        }\n    }\n    return v.sort((a, b) => a - b);\n}\n",
  "  return [...new Set(l)].sort();\n}\n", "  const s = new Set(l);\n  return [...s];\n\
    }\n\nexport function getUniqueKeywords() {\n  const scanResults = getScanResults();\n\
    \  if (!scanResults) {\n    return [];\n  }\n  let keywords = [];\n  scanResults.forEach(scanResult\
    \ => {\n    keywords = keywords.concat(scanResult.keywords);\n  });\n  return\
    \ unique(keywords);\n}\n\nexport function getKeywordOccurrence(keyword: string)\
    \ {\n  const scanResults = getScanResults();\n  if (!scanResults) {\n    return\
    \ 0;\n  }\n  let occurrence = 0;\n  scanResults.forEach(scanResult => {\n    occurrence\
    \ += scanResult.keywords.filter(k => k === keyword).length;\n  });\n  return occurrence;\n\
    }\n\nexport function getKeywordDensity(keyword: string) {\n  const keywordOccurrence\
    \ = getKeywordOccurrence(keyword);\n  if (keywordOccurrence === 0) {\n    return\
    \ 0;\n  }\n  const scanResults = getScanResults();\n  if (!scanResults) {\n  \
    \  return 0;\n  }\n  let total = 0;\n  scanResults.forEach(scanResult => {\n \
    \   total += scanResult.keywords.length;\n  });\n  return parseFloat(((keywordOccurrence\
    \ / total) * 100).toFixed(2));\n}\n\nexport function getKeywordTotalRank(keyword:\
    \ string) {\n  const scanResults = getScanResults();\n  if (!scanResults) {\n\
    \    return 0;\n  }\n  let total = 0;\n  scanResults.forEach(scanResult => {\n\
    \    total += scanResult.keywords.filter(k => k === keyword).length *\n      scanResult.rank;\n\
    \  });\n  return total;\n}\n\nexport function getKeywordAverageRank(keyword: string)\
    \ {\n  const keywordOccurrence = getKeywordOccurrence(keyword);\n  if (keywordOccurrence\
    \ === 0) {\n    return 0;\n  }\n  const keywordTotalRank = getKeywordTotalRank(keyword);\n\
    \  return parseFloat((keywordTotalRank / keywordOccurrence).toFixed(2", "    var\
    \ u = {}, a = [];\n    for (var i = 0, l = l.length; i < l; ++i) {\n        if\
    \ (u.hasOwnProperty(l[i])) {\n            continue;\n        }\n        a.push(l[i]);\n\
    \        u[l[i]] = 1;\n    }\n    return a;\n}\n", "  return [...new Set(l)];\n\
    }\n", "    const s = new Set(l);\n    return [...s].sort((a, b) => a - b);\n}\n",
  "  return [...new Set(l)];\n}\n", "    return l.filter((value, index, self) => self.indexOf(value)\
    \ === index).sort()\n}\n", "    return l.sort((a, b) => a - b).filter((v, i, l)\
    \ => v !== l[i - 1]);\n}\n", "  return [...new Set(l)];\n}\n", "  return [...new\
    \ Set(l)].sort((a, b) => a - b);\n}\n", "    //TODO: Implement\n    return []\n\
    }\n", "    return Array.from(new Set(l));\n}\n", "    return l.sort((a, b) =>\
    \ a - b).filter((v, i, l) => (i === 0 || v !== l[i - 1]));\n}\n", "  let uniqueList:\
    \ number[] = [];\n  for (let i = 0; i < l.length; i++) {\n    if (uniqueList.indexOf(l[i])\
    \ == -1) {\n      uniqueList.push(l[i]);\n    }\n  }\n  return uniqueList.sort((a,\
    \ b) => {\n    return a - b;\n  });\n}\n", "    return l.sort().filter((val, index,\
    \ arr) => {\n        return index === 0 || val !== arr[index - 1];\n    });\n\
    }\n", "    const s = new Set(l);\n    return Array.from(s).sort((a, b) => a -\
    \ b);\n}\n", "    return [...(new Set(l))].sort((a, b) => a - b);\n}\n", "   \
    \ var arr = [];\n    for (var i = 0; i < l.length; i++) {\n        if (arr.indexOf(l[i])\
    \ == -1) {\n            arr.push(l[i]);\n        }\n    }\n    return arr;\n}\n",
  "    return l.sort((a, b) => a - b).filter((e, i, a) => a.indexOf(e) === i);\n}\n",
  "    let list = l.slice();\n    //TODO\n    return list;\n}\n", "  return [...new\
    \ Set(l)].sort((a, b) => a - b);\n}\n", "  let list: number[] = l.sort();\n  return\
    \ list.filter((v, i, a) => a.indexOf(v) === i);\n}\n", "    return l.sort().filter((el,\
    \ i, arr) => el !== arr[i + 1])\n}\n", "    return [...new Set(l)];\n}\n", " \
    \   return l.filter((val, index, arr) => arr.indexOf(val) === index);\n}\n", " \
    \   return l.filter((v, i, a) => a.indexOf(v) === i).sort();\n}\n", "  return\
    \ [...new Set(l)].sort();\n}\n", "  return l.filter((v, i, l) => l.indexOf(v)\
    \ === i).sort((a, b) => a - b);\n}\n", "    let u = [];\n    for (let i = 0; i\
    \ < l.length; i++) {\n        if (u.indexOf(l[i]) === -1) {\n            u.push(l[i]);\n\
    \        }\n    }\n    return u;\n}\n", "    let result: number[] = [];\n    for\
    \ (let i = 0; i < l.length; i++) {\n        if (l[i] in result) continue;\n  \
    \      result.push(l[i]);\n    }\n    return result.sort((a, b) => a - b);\n}\n\
    \nconsole.log(unique([5, 3, 5, 2, 3, 3, 9, 0, 123]));\n", "    return Array.from(new\
    \ Set(l));\n}\n", "  return [...new Set(l)];\n}\n", "  return l.filter((x, i)\
    \ => l.indexOf(x) === i);\n}\n", "  return [...new Set(l)];\n}\n", "    return\
    \ Array.from(new Set(l)).sort((a, b) => a - b);\n}\n", "    return l.filter((e,\
    \ i) => l.indexOf(e) === i);\n}\n", "    return Array.from(new Set(l)).sort((a,\
    \ b) => a - b);\n}\n", "  return [...new Set(l)].sort();\n}\n", "    const a =\
    \ new Set(l);\n    return Array.from(a);\n}\n", "    return l.filter((x, i) =>\
    \ l.indexOf(x) === i).sort((a, b) => a - b);\n}\n", "    let arr = []\n    for\
    \ (let i = 0; i < l.length; i++) {\n        if (arr.indexOf(l[i]) == -1) {\n \
    \           arr.push(l[i])\n        }\n    }\n    return arr\n}", "    const uniq\
    \ = l.reduce((a, x) => a.includes(x) ? a : [...a, x], []);\n    uniq.sort((a,\
    \ b) => a - b);\n    return uniq;\n}\n", "    return l.sort().filter((v, i, a)\
    \ => i === 0 || v !== a[i - 1]);\n}\n", "    var r: number[] = [],\n        i:\
    \ number,\n        j: number;\n    for (i = 0; i < l.length; i++) {\n        for\
    \ (j = i + 1; j < l.length; j++) {\n            if (l[i] === l[j]) {\n       \
    \         j = ++i;\n            }\n        }\n        r.push(l[i]);\n    }\n \
    \   return r;\n}", "    return l.sort().filter((v, i, l) => i == 0 || v != l[i\
    \ - 1]);\n}\n", "    const seen = {};\n    const result = [];\n    const length\
    \ = l.length;\n    for (let i = 0; i < length; i++) {\n        const x = l[i];\n\
    \        if (!(x in seen)) {\n            seen[x] = true;\n            result.push(x);\n\
    \        }\n    }\n    return result;\n}\n", "    return Array.from(new Set(l));\n\
    }\n", "  return [...new Set(l)];\n}\n", "    const seen = new Set<number>();\n\
    \    return l.filter(x => {\n        if (seen.has(x)) {\n            return false;\n\
    \        }\n        seen.add(x);\n        return true;\n    });\n}\n\nfunction*\
    \ until(x: number, up: boolean = true) {\n    for (let i = 0; i < x; i++) {\n\
    \        yield i;\n    }\n}\n\nfunction* range(x: number, y: number, up: boolean\
    \ = true) {\n    const start = up ? x : y;\n    const end = up ? y : x;\n    const\
    \ step = up ? 1 : -1;\n    for (let i = start; i < end; i += step) {\n       \
    \ yield i;\n    }\n}\n", "    return [...new Set(l)]\n}\n", "    return l.sort().filter((item,\
    \ pos, ary) => {\n        return !pos || item != ary[pos - 1];\n    });\n}\n",
  "  return l.sort().filter((v, i, a) => i === 0 || v !== a[i - 1]);\n}\n", "  return\
    \ l.sort().filter((e, i, a) => e != a[i + 1]);\n}\n", "  return [...new Set(l)].sort((a,\
    \ b) => a - b);\n}\n", "    // TODO: Implement this function\n    return [];\n\
    }\n", "    return l.sort().filter((e, i, a) => e !== a[i - 1]);\n}\n", "    const\
    \ sorted: number[] = l.sort((a, b) => a - b);\n    const result: number[] = [];\n\
    \    let previous: number = sorted[0];\n    result.push(previous);\n    for (let\
    \ i = 1; i < sorted.length; i++) {\n        if (sorted[i] !== previous) {\n  \
    \          result.push(sorted[i]);\n        }\n        previous = sorted[i];\n\
    \    }\n    return result;\n}\n", "    return Array.from(new Set(l));\n}\n", " \
    \   return l.filter((v, i, a) => a.indexOf(v) === i).sort((a, b) => a - b);\n\
    }\n", "    const s = new Set(l);\n    return [...s];\n}\n", "    return Array.from(new\
    \ Set(l));\n}\n", "    let out: number[] = [];\n    for (let i = 0; i < l.length;\
    \ i++) {\n        if (out.indexOf(l[i]) === -1) {\n            out.push(l[i]);\n\
    \        }\n    }\n    return out;\n}\n", "    var u = [];\n    for (var i = 0;\
    \ i < l.length; i++) {\n        if (u.indexOf(l[i]) == -1) {\n            u.push(l[i]);\n\
    \        }\n    }\n    return u;\n}\n", "  var a = [], b = [], prev;\n  l.sort();\n\
    \  for ( var i = 0; i < l.length; i++ ) {\n    if ( l[i] !== prev ) {\n      a.push(l[i]);\n\
    \      b.push(1);\n    } else {\n      b[b.length-1]++;\n    }\n    prev = l[i];\n\
    \  }\n  return a;\n}\n", "  return [...new Set(l)].sort((a, b) => a - b);\n}\n\
    \ndescribe(\"Testing Contest\", () => {\n  describe(\"Testing Solution\", () =>\
    \ {\n    it(\"One\", () => {\n      const answer = run();\n      console.log(\"\
    Answer\", answer);\n      expect(unique(answer)).toEqual([933, 501, 687, 313,\
    \ 983, 433, 757, 987, 231]);\n    });\n  });\n});", "    return Array.from(new\
    \ Set(l));\n}\n", "    return l.sort().filter((x, i, a) => a.indexOf(x) == i);\n\
    }\n", "    return Array.from(new Set(l));\n}\n", "    return [...new Set(l)]\n\
    }\n", "    var u = new Set(l);\n    return Array.from(u);\n}\n", "  var arr =\
    \ [];\n  for (var i = 0; i < l.length; i++) {\n    if (arr.indexOf(l[i]) == -1)\
    \ {\n      arr.push(l[i]);\n    }\n  }\n  return arr;\n}\n", "  return [...new\
    \ Set(l)].sort((a, b) => a - b);\n}\n", "    const r: number[] = [];\n    l.forEach(v\
    \ => {\n        if (r.indexOf(v) === -1) {\n            r.push(v);\n        }\n\
    \    });\n    return r.sort((a, b) => a - b);\n}\n", "    let unique = [];\n \
    \   for (let i = 0; i < l.length; i++) {\n        if (unique.indexOf(l[i]) ===\
    \ -1) {\n            unique.push(l[i]);\n        }\n    }\n    return unique.sort((a,\
    \ b) => a - b);\n}\n", "    return l.filter((v, i, l) => l.indexOf(v) === i).sort();\n\
    }\n", "  return l.sort().filter((a, i) => {\n    return !i || a !== l[i - 1];\n\
    \  });\n}\n", "    let m = {}\n    for (let i of l) {\n        m[i] = 1\n    }\n\
    \    return Object.keys(m).map(s => parseInt(s))\n}\n", "  return l.sort().filter((x,\
    \ i, array) => array.indexOf(x) === i);\n}\n", "  return Array.from(new Set(l)).sort((a,\
    \ b) => a - b);\n}\n", "    return l.filter((element, index, list) => index ===\
    \ list.indexOf(element));\n}\n", "  return [...new Set(l)];\n}\n", "    const\
    \ u = [];\n    for (const i of l) {\n        if (!u.includes(i)) {\n         \
    \   u.push(i);\n        }\n    }\n    return u.sort((a, b) => a - b);\n}\n", " \
    \   return l.filter((x, i) => l.indexOf(x) === i);\n}\n", "    return Array.from(new\
    \ Set(l));\n}\n", "    const d = new Set(l);\n    return [...d];\n}\n", "    return\
    \ [...new Set(l)].sort((a, b) => a - b);\n}\n", "  return l.filter((x, i) => l.indexOf(x)\
    \ === i).sort();\n}\n", "    let m = new Map<number, boolean>();\n    l.forEach(x\
    \ => m.set(x, true));\n    return Array.from(m.keys());\n}\n", "    return l.sort((a,\
    \ b) => a - b).filter((v, i, a) => a.indexOf(v) === i);\n}\n", "  return [...new\
    \ Set(l)].sort((a, b) => a - b);\n}\n", "    return Array.from(new Set(l));\n\
    }\n", "    return l.filter((e, i) => l.indexOf(e) === i).sort((a, b) => a - b);\n\
    }\n", "    return [...new Set(l)];\n}\n", "  const s = new Set(l);\n  return [...s];\n\
    }\n", "    let result: number[] = []\n    for (let i = 0; i < l.length; i++) {\n\
    \        if (result.indexOf(l[i]) == -1) {\n            result.push(l[i])\n  \
    \      }\n    }\n    return result\n}\n", "    const set = new Set(l);\n    return\
    \ Array.from(set);\n}\n", "    return l.filter((x, i) => l.indexOf(x) === i).sort((a,\
    \ b) => a - b);\n}\n", "    let array = l.sort((a, b) => a - b);\n    let result\
    \ = [array[0]];\n    for (let i = 1; i < array.length; i++) {\n        if (array[i]\
    \ !== array[i - 1]) {\n            result.push(array[i]);\n        }\n    }\n\
    \    return result;\n}\n\n", "  // return l.filter((v, i, a) => a.indexOf(v) ===\
    \ i).sort((a, b) => a - b);\n  return [...new Set(l)].sort((a, b) => a - b);\n\
    }\n", "    const seen = new Set();\n    return l.filter(n => !seen.has(n) && seen.add(n));\n\
    }\n", "  return [...new Set(l)];\n}\n", "  return [...new Set(l)];\n}\n", "  \
    \  const res: number[] = [];\n    for (let i = 0; i < l.length; i++) {\n     \
    \   if (res.indexOf(l[i]) === -1) {\n            res.push(l[i]);\n        }\n\
    \    }\n    return res.sort((a, b) => a - b);\n}\n", "    return Array.from(new\
    \ Set(l));\n}\n", "  return l.sort().filter((v, i, a) => i == 0 || v != a[i -\
    \ 1]);\n}\n", "    let seen: number[] = [];\n    return l.filter(function(value,\
    \ index, array) {\n        return seen.indexOf(value) === -1 && seen.push(value);\n\
    \    });\n}\n", "  return [...new Set(l)];\n}\n", "    return [...new Set(l)];\n\
    }\n", "    var ret: number[] = [];\n    var s = new Set<number>();\n    for (var\
    \ x of l) {\n        if (!s.has(x)) {\n            s.add(x);\n            ret.push(x);\n\
    \        }\n    }\n    return ret;\n}\n", "  return Array.from(new Set(l));\n\
    }\n", "    const res: number[] = []\n    l.sort()\n    let v: number\n    l.forEach(function\
    \ (e) {\n        if (e != v) {\n            res.push(e)\n            v = e\n \
    \       }\n    })\n    return res\n}\n", "    let result: number[] = [];\n   \
    \ for (let i: number = 0; i < l.length; i++) {\n        if (result.indexOf(l[i])\
    \ == -1) {\n            result.push(l[i]);\n        }\n    }\n    return result;\n\
    }\n", "    return l.sort().filter((el, i, a) => !i || el !== a[i - 1]);\n}\n",
  "    let result: number[] = []\n    for (let i = 0; i < l.length; i++) {\n     \
    \   if (result.indexOf(l[i]) == -1) {\n            result.push(l[i])\n       \
    \ }\n    }\n    return result\n}\n", "    var res: number[] = [];\n    for (var\
    \ i = 0; i < l.length; i++) {\n        var val = l[i];\n        if (res.indexOf(val)\
    \ == -1) {\n            res.push(val);\n        }\n    }\n    return res;\n}\n",
  "    return Array.from(new Set(l)).sort();\n}\n", "    let items: number[] = [];\n\
    \    for (let i = 0; i < l.length; i++) {\n        let item = l[i];\n        if\
    \ (items.indexOf(item) === -1) {\n            items.push(item);\n        }\n \
    \   }\n    return items.sort();\n}\n", "    const result: number[] = [];\n   \
    \ const sorted: number[] = l.sort();\n    let prev: number = 0;\n    for (let\
    \ i = 0; i < sorted.length; i++) {\n        if (sorted[i] !== prev) {\n      \
    \      result.push(sorted[i]);\n            prev = sorted[i];\n        }\n   \
    \ }\n    return result;\n}", "    return [...new Set(l)].sort()\n}\n", "    let\
    \ u: number[] = [];\n    let lu: number[] = [];\n    for (let i = 0; i < l.length;\
    \ i++) {\n        if (lu.indexOf(l[i]) < 0) {\n            lu.push(l[i]);\n  \
    \          u.push(l[i]);\n        }\n    }\n    return u;\n}\n", "    return _(l).sortBy().uniq().value();\n\
    }\n", "    const seen = new Set();\n    return l.filter(x => {\n        return\
    \ seen.has(x) ? false : seen.add(x);\n    });\n}\n", "    let out: number[] =\
    \ [];\n    for (let i of l) {\n        if (out.indexOf(i) == -1) {\n         \
    \   out.push(i);\n        }\n    }\n    return out.sort((a, b) => a - b);\n}\n",
  "    return [...new Set(l)];\n}\n", "    return [...new Set(l)];\n}\n", "    return\
    \ Array.from(new Set(l));\n}\n", "    let result: number[] = [];\n    for (let\
    \ i = 0; i < l.length; i++) {\n        if (result.indexOf(l[i]) == -1) {\n   \
    \         result.push(l[i]);\n        }\n    }\n    return result;\n}\n", "  \
    \  const a = l.sort();\n    let res = [a[0]];\n    for (let i = 1; i < a.length;\
    \ i++) {\n        if (a[i - 1] !== a[i]) {\n            res.push(a[i]);\n    \
    \    }\n    }\n    return res;\n}\n", "    return l.filter((v, i, a) => a.indexOf(v)\
    \ === i).sort((a, b) => a - b);\n}\n", "  return Object.keys(l.reduce((a, b) =>\
    \ { a[b] = true; return a; }, {})).map(x => parseInt(x));\n}\n", "  return Array.from(new\
    \ Set(l)).sort((a, b) => a - b);\n}\n", "    let seen: { [key: number]: boolean\
    \ } = {};\n    return l.filter(e => seen.hasOwnProperty(e) ? false : (seen[e]\
    \ = true));\n}", "    return l.sort().filter((el, i, a) => i === 0 || el !== a[i\
    \ - 1]);\n}\n", "    const u = {};\n    const res = [];\n    for (let i = 0; i\
    \ < l.length; i++) {\n        const elem = l[i];\n        if (!u[elem]) {\n  \
    \          res.push(elem);\n            u[elem] = true;\n        }\n    }\n  \
    \  return res;\n}\n", "    return Array.from(new Set(l));\n}\n", "    return Array.from(new\
    \ Set(l));\n}\n", "    return l.filter((v, i, s) => s.indexOf(v) === i).sort();\n\
    }\n", "    return Array.from(new Set(l));\n}\n", "    let a = l.slice().sort();\n\
    \    let r = [a[0]];\n    for (let i = 1; i < a.length; i++) {\n        if (a[i\
    \ - 1] !== a[i]) {\n            r.push(a[i]);\n        }\n    }\n    return r;\n\
    }\n", "    var u = {}, a = [];\n    for (var i = 0, l = l.length; i < l; ++i)\
    \ {\n        if (u.hasOwnProperty(l[i])) {\n            continue;\n        }\n\
    \        a.push(l[i]);\n        u[l[i]] = 1;\n    }\n    return a;\n}\n", "  \
    \  const out: number[] = [];\n    for (let i = 0; i < l.length; i++) {\n     \
    \   if (out.indexOf(l[i]) === -1) {\n            out.push(l[i]);\n        }\n\
    \    }\n    return out;\n}\n", "    return l.filter((e, i) => l.indexOf(e) ===\
    \ i).sort((a, b) => a - b);\n}\n", "    var u = {}, a = [];\n    for (var i =\
    \ 0, l = l.length; i < l; ++i) {\n        if (u.hasOwnProperty(l[i])) {\n    \
    \        continue;\n        }\n        a.push(l[i]);\n        u[l[i]] = 1;\n \
    \   }\n    return a;\n}\n", "  return l.sort().filter((e, i, a) => e != a[i +\
    \ 1])\n}\n", "  let u: number[] = []\n  for (let i = 0; i < l.length; i++) {\n\
    \    if (u.indexOf(l[i]) < 0) {\n      u.push(l[i])\n    }\n  }\n  return u\n\
    }\n", "  return l.filter((x, i) => l.indexOf(x) === i);\n}\n", "    return l.sort().filter((v,\
    \ i, a) => a.indexOf(v) === i);\n}\n", "    return l.filter((v, i, a) => a.indexOf(v)\
    \ === i).sort();\n}\n", "    return l.filter((v, i, l) => l.indexOf(v) === i).sort((a,\
    \ b) => a - b);\n}\n", "    let s = new Set(l);\n    return [...s];\n}\n", " \
    \   return l.sort().filter((el, i, arr) => el !== arr[i - 1]);\n}\n\nexport {\n\
    \    //Count number of 'true' elements in an array\n    countTrue,\n    //Transpose\
    \ a matrix\n    transpose,\n    //Sum numbers in an array\n    sum,\n    //Average\
    \ an array of numbers\n    average,\n    //Return sorted unique elements in an\
    \ array\n    unique\n};", "    const u: number[] = [];\n    for (let i = 0; i\
    \ < l.length; i++) {\n        if (u.indexOf(l[i]) < 0) {\n            u.push(l[i]);\n\
    \        }\n    }\n    return u;\n}\n", "    return l.sort().filter((e, i, a)\
    \ => !i || e != a[i - 1]);\n}\n", "    let r = []\n    return r.concat(l).sort((a,\
    \ b) => a - b).filter((item, pos, array) => {\n        return !pos || item !=\
    \ array[pos - 1]\n    })\n}\n", "    return Array.from(new Set(l));\n}\n", " \
    \   return [...(new Set(l))].sort((a, b) => a - b);\n}\n", "  var set = new Set(l);\n\
    \  return Array.from(set);\n}\n", "    return l.filter((e, i) => l.indexOf(e)\
    \ === i).sort((a, b) => a - b);\n}\n", "    return l.filter((x, i) => l.indexOf(x)\
    \ === i).sort();\n}\n", "    return Array.from(new Set(l))\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
