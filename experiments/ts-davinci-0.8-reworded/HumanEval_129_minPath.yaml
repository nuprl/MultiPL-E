name: HumanEval_129_minPath
language: ts
prompt: "//Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have\
  \ to find the minimum path of length k in the grid. You can start\n// from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n// in other words,\
  \ you can go to cells which share an edge with you current\n// cell.\n// Please\
  \ note that a path of length k means visiting exactly k cells (not\n// necessarily\
  \ distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered\
  \ less than a path B (of length k) if\n// after making the ordered arrays of the\
  \ values on the cells that A and B go\n// through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n// than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer\
  \ is unique.\n// Return an ordered array of the values on the cells that the minimum\
  \ path go through.\n// Examples:    \n// >>> minPath([[1, 2, 3], [4, 5, 6], [7,\
  \ 8, 9]], 3)\n// [1, 2, 1]\n// >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n\
  // [1]\nfunction minPath(grid: number[][], k: number): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = minPath;\n  assert.deepEqual(candidate([[1, 2, 3],\
  \ [4, 5, 6], [7, 8, 9]], 3),[1, 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3],\
  \ [4, 1, 6], [7, 8, 2]], 1),[1]);\n  assert.deepEqual(candidate([[1, 2, 3, 4], [5,\
  \ 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6,\
  \ 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10,\
  \ 1, 10, 1]);\n  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5,\
  \ 7, 1, 12], [3, 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11,\
  \ 8, 7, 2], [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1,\
  \ 6, 1, 6, 1]);\n  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5,\
  \ 16, 14, 4], [11, 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2,\
  \ 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1,\
  \ 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1,\
  \ 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"
completions: ["    let result: number[] = [];\n    let directionIndexes: number[][]\
    \ = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n    let gridSize: number = grid.length;\n\
    \    let pathLength: number = 0;\n    let pathStart: number = grid[0][0];\n  \
    \  let bestPath: number[] = [];\n    let minPathLength: number = gridSize * gridSize;\n\
    \    let minPathStart: number = 0;\n    let bestPathStart: number = 0;\n    let\
    \ path: number[] = [];\n    let pathString: string = \"\";\n    let gridClone:\
    \ number[][] = [];\n    let isVisited: boolean[][] = [];\n    let validPath: boolean\
    \ = false;\n    // Create a grid clone so that we can visit cells without changing\
    \ the original grid.\n    for (let i: number = 0; i < gridSize; i++) {\n     \
    \   let row: number[] = [];\n        for (let j: number = 0; j < gridSize; j++)\
    \ {\n            row.push(grid[i][j]);\n        }\n        gridClone.push(row);\n\
    \    }\n    // Initialize an array of visited cells.\n    for (let i: number =\
    \ 0; i < gridSize; i++) {\n        let row: boolean[] = [];\n        for (let\
    \ j: number = 0; j < gridSize; j++) {\n            row.push(false);\n        }\n\
    \        isVisited.push(row);\n    }\n    // Find the start and the length of\
    \ the shortest path.\n    while (pathLength < minPathLength) {\n        path =\
    \ findPath(gridClone, pathStart, pathLength, directionIndexes, isVisited);\n \
    \       if (path.length == pathLength) {\n            break;\n        }\n    \
    \    pathStart++;\n        pathLength = path.length;\n    }\n    minPathLength\
    \ = pathLength;\n    minPathStart = pathStart;\n    // Go back to the original\
    \ grid.\n    gridClone = [];\n    for (let i: number = 0; i < gridSize; i++) {\n\
    \        let row: number[] = [];\n        for (let", "  const m = grid.length;\n\
    \  const n = grid[0].length;\n  let minPath: number[] = [Infinity];\n  const dirs\
    \ = [[0, -1], [0, 1], [-1, 0], [1, 0]];\n  function dfs(row: number, col: number,\
    \ curPath: number[], curStep: number) {\n    const curValue = grid[row][col];\n\
    \    curPath.push(curValue);\n    if (curStep === k) {\n      if (curPath.slice().sort((a,\
    \ b) => a - b).join() < minPath.slice().sort((a, b) => a - b).join()) {\n    \
    \    minPath = curPath.slice();\n      }\n      return;\n    }\n    for (const\
    \ [dirRow, dirCol] of dirs) {\n      const newRow = row + dirRow;\n      const\
    \ newCol = col + dirCol;\n      if (newRow >= 0 && newRow < m && newCol >= 0 &&\
    \ newCol < n) {\n        dfs(newRow, newCol, curPath, curStep + 1);\n      }\n\
    \    }\n    curPath.pop();\n  }\n  for (let i = 0; i < m; i++) {\n    for (let\
    \ j = 0; j < n; j++) {\n      dfs(i, j, [], 1);\n    }\n  }\n  return minPath;\n\
    }\n", "  const m = grid.length;\n  const n = grid[0].length;\n  let min_path:\
    \ number[] = [];\n  let min_sum = Infinity;\n  // We store in `visited` whether\
    \ a cell is already visited or not.\n  const visited = new Array(m);\n  for (let\
    \ i = 0; i < m; i++) {\n    visited[i] = new Array(n).fill(false);\n  }\n  //\
    \ We store in `routes` all the possible routes.\n  const routes: number[][] =\
    \ [];\n  // We store in `route` a single route.\n  const route: number[] = [];\n\
    \  let sum = 0;\n  dfs(0, 0);\n  return min_path;\n\n  function dfs(i: number,\
    \ j: number) {\n    visited[i][j] = true;\n    route.push(grid[i][j]);\n    sum\
    \ += grid[i][j];\n    if (route.length === k) {\n      if (sum < min_sum) {\n\
    \        min_sum = sum;\n        min_path = route.slice();\n      }\n      visited[i][j]\
    \ = false;\n      route.pop();\n      sum -= grid[i][j];\n      return;\n    }\n\
    \    if (i > 0 && !visited[i - 1][j]) {\n      dfs(i - 1, j);\n    }\n    if (i\
    \ < m - 1 && !visited[i + 1][j]) {\n      dfs(i + 1, j);\n    }\n    if (j > 0\
    \ && !visited[i][j - 1]) {\n      dfs(i, j - 1);\n    }\n    if (j < n - 1 &&\
    \ !visited[i][j + 1]) {\n      dfs(i, j + 1);\n    }\n    visited[i][j] = false;\n\
    \    route.pop();\n    sum -= grid[i][j];\n  }\n}\n", "    // Your code goes here.\n\
    \    // Good luck :)\n}\n", "    const queue: Array<{ x: number, y: number, path:\
    \ number[] }> = [];\n    const m = grid.length;\n    const n = grid[0].length;\n\
    \    const minPath: number[] = new Array(k).fill(Infinity);\n    queue.push({\
    \ x: 0, y: 0, path: [grid[0][0]] });\n    while (queue.length > 0) {\n       \
    \ const u = queue.shift();\n        if (u.path.length < k) {\n            if (u.x\
    \ + 1 < m) {\n                queue.push({ x: u.x + 1, y: u.y, path: [...u.path,\
    \ grid[u.x + 1][u.y]] });\n            }\n            if (u.y + 1 < n) {\n   \
    \             queue.push({ x: u.x, y: u.y + 1, path: [...u.path, grid[u.x][u.y\
    \ + 1]] });\n            }\n        } else {\n            if (u.path.length ===\
    \ k) {\n                if (minPath.toString() > u.path.toString()) {\n      \
    \              minPath.splice(0, k, ...u.path);\n                }\n         \
    \   }\n        }\n    }\n    return minPath;\n}\n", "\tlet n = grid.length;\n\t\
    let m = grid[0].length;\n\tlet path = [];\n\tlet minPath = [];\n\tlet minPathSum\
    \ = Infinity;\n\tfunction dfs(i: number, j: number, k: number, sum: number) {\n\
    \t\tpath.push(grid[i][j]);\n\t\tsum += grid[i][j];\n\t\tif (sum > minPathSum)\
    \ {\n\t\t\tpath.pop();\n\t\t\treturn;\n\t\t}\n\t\tif (k == 1) {\n\t\t\tif (minPathSum\
    \ > sum) {\n\t\t\t\tminPathSum = sum;\n\t\t\t\tminPath = path.slice();\n\t\t\t\
    }\n\t\t\tpath.pop();\n\t\t\treturn;\n\t\t}\n\t\tif (i > 0) dfs(i - 1, j, k - 1,\
    \ sum);\n\t\tif (i < n - 1) dfs(i + 1, j, k - 1, sum);\n\t\tif (j > 0) dfs(i,\
    \ j - 1, k - 1, sum);\n\t\tif (j < m - 1) dfs(i, j + 1, k - 1, sum);\n\t\tpath.pop();\n\
    \t}\n\tfor (let i = 0; i < n; i++) {\n\t\tfor (let j = 0; j < m; j++) {\n\t\t\t\
    dfs(i, j, k, 0);\n\t\t}\n\t}\n\treturn minPath;\n}\n", "    let n = grid.length;\n\
    \    let bestPath = [];\n    let bestPathSum = Infinity;\n    let visited = new\
    \ Set();\n    function move(i: number, j: number, path: number[], pathSum: number)\
    \ {\n        if (i < 0 || i > n - 1 || j < 0 || j > n - 1) return;\n        if\
    \ (visited.has(grid[i][j])) return;\n        path.push(grid[i][j]);\n        pathSum\
    \ += grid[i][j];\n        visited.add(grid[i][j]);\n        if (path.length ===\
    \ k) {\n            if (pathSum < bestPathSum) {\n                bestPathSum\
    \ = pathSum;\n                bestPath = [...path];\n            }\n        }\
    \ else {\n            move(i - 1, j, path, pathSum);\n            move(i + 1,\
    \ j, path, pathSum);\n            move(i, j - 1, path, pathSum);\n           \
    \ move(i, j + 1, path, pathSum);\n        }\n        path.pop();\n        pathSum\
    \ -= grid[i][j];\n        visited.delete(grid[i][j]);\n    }\n    for (let i =\
    \ 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            move(i,\
    \ j, [], 0);\n        }\n    }\n    return bestPath;\n}\n", "    let N = grid.length;\n\
    \    let path = [];\n    for (let i = 0; i < k; i++) {\n        path.push(grid[0][0]);\n\
    \    }\n    return path;\n}\n\nlet grid1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];\n\
    let k1 = 3;\nconsole.log(minPath(grid1, k1));\n\nlet grid2 = [[5, 9, 3], [4, 1,\
    \ 6], [7, 8, 2]];\nlet k2 = 1;\nconsole.log(minPath(grid2, k2));", "    // Your\
    \ code here\n    let res: number[] = [];\n    let getMin = (i: number, j: number,\
    \ k: number): void => {\n        if (i < 0 || i >= grid.length || j < 0 || j >=\
    \ grid[0].length) {\n            return;\n        }\n        if (k < 0) {\n  \
    \          return;\n        }\n        if (k === 0) {\n            if (res.length\
    \ === 0) {\n                res.push(grid[i][j]);\n            } else {\n    \
    \            for (let l = 0; l < res.length; l++) {\n                    if (res[l]\
    \ > grid[i][j]) {\n                        res[l] = grid[i][j];\n            \
    \            return;\n                    }\n                }\n             \
    \   res.push(grid[i][j]);\n            }\n            return;\n        }\n   \
    \     getMin(i + 1, j, k - 1);\n        getMin(i - 1, j, k - 1);\n        getMin(i,\
    \ j + 1, k - 1);\n        getMin(i, j - 1, k - 1);\n    }\n    getMin(0, 0, k);\n\
    \    return res;\n}\n\nexport { minPath };", "    return [];\n}\n", "  const n\
    \ = grid.length;\n  const seen = new Set<string>();\n  const pq = new PriorityQueue<number[]>();\n\
    \  pq.insert([0, 0, 0], 0);\n  while (pq.size() > 0) {\n    const [x, y, c] =\
    \ pq.pop();\n    if (seen.has(`${x}-${y}-${c}`)) continue;\n    seen.add(`${x}-${y}-${c}`);\n\
    \    if (c == k) return grid[x][y];\n    for (const dir of [[-1, 0], [1, 0], [0,\
    \ -1], [0, 1]]) {\n      const [xx, yy] = [x + dir[0], y + dir[1]];\n      if\
    \ (xx < 0 || xx >= n || yy < 0 || yy >= n) continue;\n      pq.insert([xx, yy,\
    \ c + 1], -grid[xx][yy]);\n    }\n  }\n  return [];\n}\n", "    let [n, ans] =\
    \ [grid.length, []];\n    // init\n    let dis = new Array(n).fill(0).map(() =>\
    \ new Array(n).fill(Infinity));\n    let que = new Array(n * n + 10).fill(0).map(()\
    \ => new Array(2).fill(0));\n    let pre = new Array(n).fill(0).map(() => new\
    \ Array(n).fill(0));\n    for (let i = 0; i < n; i++) {\n        for (let j =\
    \ 0; j < n; j++) {\n            pre[i][j] = new Array(n * n + 10).fill(0).map(()\
    \ => new Array(2).fill(0));\n        }\n    }\n    let [fx, fy] = [0, 0];\n  \
    \  dis[0][0] = 0;\n    que[0][0] = 0;\n    que[0][1] = 0;\n    let head = 0, tail\
    \ = 1;\n    // search\n    while (head < tail) {\n        let [cx, cy] = [que[head][0],\
    \ que[head][1]];\n        let [fx, fy] = [cx, cy];\n        for (let [dx, dy]\
    \ of [[0, 1], [0, -1], [1, 0], [-1, 0]]) {\n            let nx = cx + dx, ny =\
    \ cy + dy;\n            if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\n\
    \            if (dis[nx][ny] > dis[cx][cy] + 1) {\n                dis[nx][ny]\
    \ = dis[cx][cy] + 1;\n                que[tail][0] = nx;\n                que[tail][1]\
    \ = ny;\n                tail++;\n                pre[nx][ny] = [...pre[cx][cy]];\n\
    \                pre[nx][ny][dis[nx][ny]] = [cx, cy];\n            } else if (dis[nx][ny]\
    \ == dis[cx][cy] + 1) {\n                let lastPre", "  const { rows, cols }\
    \ = { rows: grid.length, cols: grid[0].length };\n  let visited: boolean[][] =\
    \ new Array(rows).fill([]).map(() => new Array(cols).fill(false));\n  let current:\
    \ number[][] = [[grid[0][0], 0, 0]];\n  while (current.length > 0) {\n    let\
    \ [val, r, c] = current.shift()!;\n    if (r < 0 || r >= rows || c < 0 || c >=\
    \ cols || visited[r][c]) {\n      continue;\n    }\n    visited[r][c] = true;\n\
    \    if (k === 1) {\n      return [val];\n    }\n    current.push([grid[r][c],\
    \ r - 1, c]);\n    current.push([grid[r][c], r + 1, c]);\n    current.push([grid[r][c],\
    \ r, c - 1]);\n    current.push([grid[r][c], r, c + 1]);\n  }\n  return [];\n\
    }\n", "  return [];\n}\n\nexport { minPath };", "\tconst N = grid.length;\n\t\
    const n = N * N;\n\tif (n < k) throw new Error(\"Path is longer than the number\
    \ of cells\");\n\tif (n === k) return new Array(n).fill(0).map((_, i) => i + 1);\n\
    \tconst best = {};\n\tfunction search(i: number, j: number, path: number[]): number[]\
    \ {\n\t\tif (k === path.length) return path;\n\t\tconst key = `${i},${j}`;\n\t\
    \tconst prev = best[key];\n\t\tif (prev && compare(prev, path) <= 0) return prev;\n\
    \t\tconst value = grid[i][j];\n\t\tconst left = i > 0 ? search(i - 1, j, [...path,\
    \ value]) : null;\n\t\tconst right = i < N - 1 ? search(i + 1, j, [...path, value])\
    \ : null;\n\t\tconst up = j > 0 ? search(i, j - 1, [...path, value]) : null;\n\
    \t\tconst down = j < N - 1 ? search(i, j + 1, [...path, value]) : null;\n\t\t\
    best[key] = min([left, right, up, down]);\n\t\treturn best[key];\n\t}\n\tfunction\
    \ min(paths: number[][]): number[] {\n\t\treturn paths.reduce((a, b) => compare(a,\
    \ b) <= 0 ? a : b);\n\t}\n\tfunction compare(path1: number[], path2: number[]):\
    \ number {\n\t\tfor (let i = 0; i < k; i++) {\n\t\t\tif (path1[i] < path2[i])\
    \ return -1;\n\t\t\tif (path1[i] > path2[i]) return 1;\n\t\t}\n\t\treturn 0;\n\
    \t}\n\tconst endRow = (k - 1) % N;\n\tconst endCol = Math.floor((k - 1) / N);\n\
    \treturn search(endRow, endCol, []);\n}\n\n(function() {\n\tconsole.log(minPath([[1,\
    \ 2, 3], [", "    // your code here\n    return [];\n}\n", "    return new Path(grid,\
    \ k).find();\n}\n", "  let { height, width } = grid;\n  let valToIdx = new Map<number,\
    \ number>();\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width;\
    \ j++) {\n      valToIdx.set(grid[i][j], j + i * width);\n    }\n  }\n  let idxToVal\
    \ = new Map<number, number>();\n  for (let pair of valToIdx) {\n    idxToVal.set(pair[1],\
    \ pair[0]);\n  }\n  let ans: number[] = [];\n  let graph = new Array(height *\
    \ width);\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width;\
    \ j++) {\n      let idx = j + i * width;\n      graph[idx] = new Set<number>();\n\
    \      if (i - 1 >= 0) {\n        graph[idx].add(valToIdx.get(grid[i - 1][j]));\n\
    \      }\n      if (i + 1 < height) {\n        graph[idx].add(valToIdx.get(grid[i\
    \ + 1][j]));\n      }\n      if (j - 1 >= 0) {\n        graph[idx].add(valToIdx.get(grid[i][j\
    \ - 1]));\n      }\n      if (j + 1 < width) {\n        graph[idx].add(valToIdx.get(grid[i][j\
    \ + 1]));\n      }\n    }\n  }\n  let visited = new Set<number>();\n  let dfs\
    \ = (idx: number) => {\n    if (visited.has(idx)) {\n      return;\n    }\n  \
    \  visited.add(idx);\n    ans.push(idxToVal.get(idx));\n    if (ans.length ===\
    \ k) {\n      return;\n    }\n    let neighbors = Array.from(graph[idx]);\n  \
    \  neighbors.sort((a, b) => a - b);\n    for (let neighbor of neighbors) {\n \
    \     dfs(neighbor);", "    const n = grid.length;\n    const DIRS = [[-1, 0],\
    \ [1, 0], [0, -1], [0, 1]];\n    let visited = new Set();\n    let minPath: number[]\
    \ = [];\n    let minSum = Infinity;\n    let minSumCells: number[][] = [];\n \
    \   for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n   \
    \         let dfs = function (i: number, j: number, visited: Set<string>, path:\
    \ number[], sum: number) {\n                let key = i + \",\" + j;\n       \
    \         visited.add(key);\n                path.push(grid[i][j]);\n        \
    \        sum += grid[i][j];\n                if (path.length === k) {\n      \
    \              if (sum < minSum) {\n                        minSum = sum;\n  \
    \                      minPath = path.slice();\n                        minSumCells\
    \ = [[i, j]];\n                    } else if (sum === minSum) {\n            \
    \            minSumCells.push([i, j]);\n                    }\n              \
    \  } else {\n                    for (let dir of DIRS) {\n                   \
    \     let next_i = i + dir[0];\n                        let next_j = j + dir[1];\n\
    \                        if (0 <= next_i && next_i < n && 0 <= next_j && next_j\
    \ < n) {\n                            let next_key = next_i + \",\" + next_j;\n\
    \                            if (!visited.has(next_key)) {\n                 \
    \               dfs(next_i, next_j, visited, path, sum);\n                   \
    \         }\n                        }\n                    }\n              \
    \  }\n                path.pop();\n                visited.delete(key);\n    \
    \        }\n            dfs(i, j, visited, [], 0);\n        }\n    }\n    if (minSumCells.length\
    \ === 1) {\n        return minPath;\n    }\n    let nextMinPath: number[] = [];\n\
    \    let nextMinSum = Infinity;\n    for (let cell of minSumCells) {\n       \
    \ let path: number[] = [];\n        let sum = 0;", "    if (k < 1) return [];\n\
    \    if (k === 1) return [grid[0][0]];\n    let gridSize = grid.length;\n    let\
    \ bestPath: number[] = [];\n    let minPathLen = gridSize * gridSize;\n    let\
    \ startPoint = [0, 0];\n    let visited: boolean[][] = [];\n    for (let i = 0;\
    \ i < gridSize; i++) {\n        visited[i] = [];\n        for (let j = 0; j <\
    \ gridSize; j++) {\n            visited[i][j] = false;\n        }\n    }\n   \
    \ findPath(0, startPoint, [grid[0][0]], 1);\n    return bestPath;\n\n    function\
    \ findPath(depth: number, coords: number[], path: number[], pathLen: number) {\n\
    \        if (depth < k) {\n            visited[coords[0]][coords[1]] = true;\n\
    \            let up = [coords[0] - 1, coords[1]];\n            let right = [coords[0],\
    \ coords[1] + 1];\n            let down = [coords[0] + 1, coords[1]];\n      \
    \      let left = [coords[0], coords[1] - 1];\n            if (up[0] >= 0 && !visited[up[0]][up[1]])\
    \ {\n                let newPath = path.slice();\n                newPath.push(grid[up[0]][up[1]]);\n\
    \                let newPathLen = pathLen + 1;\n                if (newPathLen\
    \ < minPathLen) {\n                    minPathLen = newPathLen;\n            \
    \        bestPath = newPath;\n                }\n                findPath(depth\
    \ + 1, up, newPath, newPathLen);\n            }\n            if (right[1] < gridSize\
    \ && !visited[right[0]][right[1]]) {\n                let newPath = path.slice();\n\
    \                newPath.push(grid[right[0]][right[1]]);\n                let\
    \ newPathLen = pathLen + 1;\n                if (newPathLen < minPathLen) {\n\
    \                    minPathLen = newPathLen;"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
