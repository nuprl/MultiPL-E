name: HumanEval_43_pairs_sum_to_zero
language: ts
prompt: "//pairs_sum_to_zero takes an array of integers as an input.\n// it returns\
  \ true if there are two distinct elements in the array that\n// sum to zero, and\
  \ false otherwise.\n// >>> pairs_sum_to_zero([1, 3, 5, 0])\n// false\n// >>> pairs_sum_to_zero([1,\
  \ 3, -2, 1])\n// false\n// >>> pairs_sum_to_zero([1, 2, 3, 7])\n// false\n// >>>\
  \ pairs_sum_to_zero([2, 4, -5, 3, 5, 7])\n// true\n// >>> pairs_sum_to_zero([1])\n\
  // false\nfunction pairs_sum_to_zero(l: number[]): boolean {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = pairs_sum_to_zero;\n  assert.deepEqual(candidate([1,\
  \ 3, 5, 0]),false);\n  assert.deepEqual(candidate([1, 3, -2, 1]),false);\n  assert.deepEqual(candidate([1,\
  \ 2, 3, 7]),false);\n  assert.deepEqual(candidate([2, 4, -5, 3, 5, 7]),true);\n\
  \  assert.deepEqual(candidate([1]),false);\n  assert.deepEqual(candidate([-3, 9,\
  \ -1, 3, 2, 30]),true);\n  assert.deepEqual(candidate([-3, 9, -1, 3, 2, 31]),true);\n\
  \  assert.deepEqual(candidate([-3, 9, -1, 4, 2, 30]),false);\n  assert.deepEqual(candidate([-3,\
  \ 9, -1, 4, 2, 31]),false);\n}\n\ntest();"
completions: ["    if (l.length == 0) {\n        return false;\n    }\n    let s =\
    \ new Set();\n    for (let i = 0; i < l.length; i++) {\n        if (s.has(l[i]))\
    \ {\n            return true;\n        }\n        s.add(-l[i]);\n    }\n    return\
    \ false;\n}", "    const nums: number[] = [];\n    let i = 0;\n    let j = 0;\n\
    \    let pos = 0;\n    while (i < l.length) {\n        j = i + 1;\n        while\
    \ (j < l.length) {\n            if (l[i] + l[j] === 0) {\n                return\
    \ true;\n            }\n            j = j + 1;\n        }\n        i = i + 1;\n\
    \    }\n    return false;\n}\n", "  // TODO\n  if (l.length <= 1) {\n    return\
    \ false;\n  }\n  else {\n    var yes: boolean = false;\n    for (var i = 0; i\
    \ < l.length; i++) {\n      for (var j = 0; j < l.length; j++) {\n        if (l[i]\
    \ + l[j] == 0 && l[i] != l[j]) {\n          yes = true;\n        }\n      }\n\
    \    }\n    return yes;\n  }\n}\n", "  for (let i = 0; i < l.length; i++) {\n\
    \    for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n\
    \        return true;\n      }\n    }\n  }\n  return false;\n}", "    if (l.length\
    \ < 2) {\n        return false;\n    }\n    else {\n        for (let i = 0; i\
    \ < l.length; i++) {\n            for (let j = 0; j < l.length; j++) {\n     \
    \           if (i !== j && l[i] + l[j] === 0) {\n                    return true;\n\
    \                }\n            }\n        }\n        return false;\n    }\n}\n",
  "  //your code here\n  return false;\n}\n\nexport { pairs_sum_to_zero };", "  //\
    \ FILL IN HERE\n  return false;\n}\n", "    for (let i = 0; i < l.length; i++)\
    \ {\n        for (let j = i + 1; j < l.length; j++) {\n            if (l[i] +\
    \ l[j] === 0) {\n                return true;\n            }\n        }\n    }\n\
    \    return false;\n}", "    // check if array has at least 2 elements\n    if\
    \ (l.length < 2) {\n        return false;\n    }\n    // keep track of numbers\
    \ that have been seen\n    const seen: number[] = [];\n    // iterate through\
    \ each element\n    for (const elem of l) {\n        // check if the element's\
    \ negative has been seen\n        if (seen.includes(-elem)) {\n            return\
    \ true;\n        }\n        // add current element to list of elements that have\
    \ been seen\n        seen.push(elem);\n    }\n    // return false if we don't\
    \ find any pair that sums to zero\n    return false;\n}\n", "    return false;\n\
    }\n\n", "  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length;\
    \ j++) {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n\
    \  }\n  return false;\n}\n", "    let seen: { [k: number]: number } = {};\n  \
    \  for (let i = 0; i < l.length; i++) {\n        if (seen[-l[i]]) {\n        \
    \    return true;\n        }\n        seen[l[i]] = 1;\n    }\n    return false;\n\
    }\n", "  // Iterate through list until we reach halfway point\n  // check if the\
    \ opposite of each element is in the list\n  // if it is, return true\n  // if\
    \ we have iterated through the list and not returned true, return false\n  const\
    \ length = l.length;\n  const halfway = Math.ceil(length / 2);\n  for (let i =\
    \ 0; i < halfway; i++) {\n    const value = -l[i];\n    for (let x = i + 1; x\
    \ < length; x++) {\n      if (l[x] === value) {\n        return true;\n      }\n\
    \    }\n  }\n  return false;\n}\n", "    let zero_dict: Dictionary<number> = {};\n\
    \    let l_length: number = l.length;\n    let result: boolean = false;\n    if\
    \ (l_length === 1) {\n        return result;\n    }\n    for (let i: number =\
    \ 0; i < l_length; i++) {\n        if (l[i] !== 0) {\n            zero_dict[l[i]]\
    \ = l[i];\n        }\n    }\n    for (let j: number = 0; j < l_length; j++) {\n\
    \        if (l[j] === 0) {\n            if (zero_dict[0] === 0) {\n          \
    \      result = true;\n            }\n        } else {\n            if (zero_dict[-l[j]])\
    \ {\n                result = true;\n            }\n        }\n    }\n    return\
    \ result;\n}\n\n", "    const sum = 0;\n    for (let i = 0; i < l.length; i++)\
    \ {\n        for (let j = i + 1; j < l.length; j++) {\n            if (l[i] +\
    \ l[j] === sum) {\n                return true;\n            }\n        }\n  \
    \  }\n    return false;\n}\n", "    let i = 0;\n    let j = 1;\n    while (i <\
    \ l.length) {\n        while (j < l.length) {\n            if (l[i] + l[j] ===\
    \ 0) {\n                return true;\n            }\n            j += 1;\n   \
    \     }\n        i += 1;\n        j = i + 1;\n    }\n    return false;\n}\n",
  "  // loop over each element of the array\n  for (let i = 0; i < l.length; i++)\
    \ {\n    // loop over each other element of the array\n    for (let j = 0; j <\
    \ l.length; j++) {\n      // if i and j are distinct indices, and l[i] + l[j]\
    \ = 0, return true\n      if (i !== j && l[i] + l[j] === 0) {\n        return\
    \ true;\n      }\n    }\n  }\n  // no two distinct elements sum to zero, return\
    \ false\n  return false;\n}\n", "  if (l.length < 2) {\n    return false;\n  }\n\
    \n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length;\
    \ j++) {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n\
    \  }\n\n  return false;\n}\n", "  let pairs = new Set<number>();\n  for (let i\
    \ = 0; i < l.length; i++) {\n    pairs.add(l[i]);\n  }\n  return l.some(i => pairs.has(-i));\n\
    }\n", "  return true;\n}\n", "  let valuesSeen: Set<number> = new Set();\n  for\
    \ (let i = 0; i < l.length; i++) {\n    if (valuesSeen.has(l[i])) {\n      return\
    \ true;\n    }\n    valuesSeen.add(-l[i]);\n  }\n  return false;\n}\n", "  const\
    \ nums = l.sort((a, b) => a - b);\n  let i = 0;\n  let j = nums.length - 1;\n\
    \  while (i < j) {\n    if (nums[i] + nums[j] == 0) {\n      return true;\n  \
    \  } else if (nums[i] + nums[j] < 0) {\n      i++;\n    } else {\n      j--;\n\
    \    }\n  }\n  return false;\n}\n", "  const lsort = l.sort();\n  for (let i =\
    \ 0; i < lsort.length; i++) {\n    if (l.indexOf(-lsort[i]) > -1 && l.indexOf(-lsort[i])\
    \ !== i) {\n      return true;\n    }\n  }\n  return false;\n}", "  // We need\
    \ to return true if we find any pair of distinct elements that add to 0.\n  //\
    \ Therefore, we can keep track of which elements we've seen so far in a set.\n\
    \  // We can then look at each element in the list, and check if -element is in\
    \ our set.\n  // If it is, we can return true because we've found a pair that\
    \ adds to 0.\n  // Otherwise, we add the element to our set of seen elements.\n\
    \  const seen_elements: Set<number> = new Set();\n  for (const element of l) {\n\
    \    if (seen_elements.has(-element)) {\n      return true;\n    }\n    seen_elements.add(element);\n\
    \  }\n  return false;\n}\n", "  const set: Set<number> = new Set<number>();\n\
    \  for (const x of l) {\n    if (set.has(x)) {\n      return true;\n    }\n  \
    \  set.add(-x);\n  }\n  return false;\n}\n", "  // TODO: complete function\n \
    \ const set1 = new Set(l);\n  for (let i = 0; i < l.length; i++) {\n    const\
    \ num = l[i];\n    if (set1.has(-num)) {\n      return true;\n    }\n  }\n  return\
    \ false;\n}\n", "  return false;\n}\n", "  //  TODO: Implement this function.\n\
    \  return false;\n}\n", "    let hs: Map<number, number> = new Map<number, number>();\n\
    \    for (let i = 0; i < l.length; i++) {\n        if (hs.has(l[i])) {\n     \
    \       hs.set(l[i], hs.get(l[i]) + 1);\n        } else {\n            hs.set(l[i],\
    \ 1);\n        }\n    }\n    for (let i = 0; i < l.length; i++) {\n        if\
    \ (hs.has(-l[i])) {\n            if (l[i] === 0 && hs.get(l[i]) === 1) {\n   \
    \             return false;\n            } else {\n                return true;\n\
    \            }\n        }\n    }\n    return false;\n}\n", "    let s: Set<number>\
    \ = new Set<number>();\n    for (let i of l) {\n        if (s.has(i)) return true;\n\
    \        s.add(-i);\n    }\n    return false;\n}\n", "    // YOUR CODE HERE\n\
    \    return false;\n}\n", "    for (let i = 0; i < l.length; i++) {\n        for\
    \ (let j = i + 1; j < l.length; j++) {\n            if (l[i] + l[j] === 0) {\n\
    \                return true;\n            }\n        }\n    }\n    return false;\n\
    }\n", "    let found = false;\n    let set = new Set<number>();\n    for (let\
    \ i = 0; i < l.length; i++) {\n        set.add(l[i]);\n    }\n    for (let i =\
    \ 0; i < l.length; i++) {\n        if (set.has(-l[i])) {\n            found =\
    \ true;\n        }\n    }\n    return found;\n}\n", "    var seen = new Set()\n\
    \    for (let num of l) {\n        if (seen.has(-num)) {\n            return true\n\
    \        }\n        seen.add(num)\n    }\n    return false\n}\n", "  if (l.length\
    \ < 2) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n   \
    \ for (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n \
    \       return true;\n      }\n    }\n  }\n  return false;\n}\n", "  let sum_zero:\
    \ boolean = false;\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i\
    \ + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        sum_zero\
    \ = true;\n      }\n    }\n  }\n  return sum_zero;\n}\n", "  for (let i = 0; i\
    \ < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i]\
    \ + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n\
    }\n", "    let h: number[] = [];\n    for (let i = 0; i < l.length; i++) {\n \
    \       let c: number = l[i];\n        if (h.indexOf(-c) != -1) {\n          \
    \  return true;\n        }\n        h.push(c);\n    }\n    return false;\n}\n",
  "  const set = new Set(l);\n  for (const num of l) {\n    if (set.has(-num)) {\n\
    \      return true;\n    }\n  }\n  return false;\n}\n", "    // You can use these\
    \ sets to keep track of found values\n    const found_positives = new Set();\n\
    \    const found_negatives = new Set();\n    //let found_zero = false;\n    let\
    \ flag = false;\n    for (let i = 0; i < l.length; i++) {\n        if (l[i] ===\
    \ 0) {\n            //found_zero = true;\n            flag = true;\n        }\
    \ else if (l[i] > 0) {\n            found_positives.add(l[i]);\n        } else\
    \ {\n            found_negatives.add(l[i]);\n        }\n    }\n    //two values\
    \ on the array sum to zero if one is positive and the other\n    // is negative.\n\
    \    for (let i = 0; i < l.length; i++) {\n        if (l[i] > 0) {\n         \
    \   if (found_negatives.has(-l[i])) {\n                return true;\n        \
    \    }\n        } else if (l[i] < 0) {\n            if (found_positives.has(-l[i]))\
    \ {\n                return true;\n            }\n        }\n    }\n    return\
    \ flag;\n}\n", "    return (new Set(l.map(v => v * -1)).size !== new Set(l).size);\n\
    }\n", "  var max = l.length;\n  var temp = l;\n  for (var i = 0; i < max; i++)\
    \ {\n    for (var j = i + 1; j < max; j++) {\n      if (l[i] + l[j] == 0) {\n\
    \        return true;\n      }\n    }\n  }\n  return false;\n}\n", "    if (l.length\
    \ <= 1) {\n        return false;\n    }\n    for (let i = 0; i < l.length; i++)\
    \ {\n        for (let j = i + 1; j < l.length; j++) {\n            if (l[i] +\
    \ l[j] === 0) {\n                return true;\n            }\n        }\n    }\n\
    \    return false;\n}\n", "  const seen = new Set<number>();\n  for (const n of\
    \ l) {\n    if (seen.has(-n)) {\n      return true;\n    }\n    seen.add(n);\n\
    \  }\n  return false;\n}\n", "    let mymap = new Map();\n    for (let i = 0;\
    \ i < l.length; i++) {\n        if (mymap.has(l[i])) {\n            return true;\n\
    \        } else {\n            mymap.set(0 - l[i], i);\n        }\n    }\n   \
    \ return false;\n}\n", "  for (const [i, elem] of l.entries()) {\n    for (const\
    \ [j, el] of l.entries()) {\n      if (i !== j && elem + el === 0) {\n       \
    \ return true;\n      }\n    }\n  }\n  return false;\n}\n", "  const nums = new\
    \ Set(l);\n  for (const num of nums) {\n    if (nums.has(-num)) {\n      return\
    \ true;\n    }\n  }\n  return false;\n}\n", "    let elements: number[] = [];\n\
    \    let pairs: number[] = [];\n    for (let n of l) {\n        if (elements.includes(n))\
    \ {\n            pairs.push(n);\n        } else {\n            elements.push(n);\n\
    \        }\n    }\n    for (let p of pairs) {\n        if (pairs.includes(-p))\
    \ {\n            return true;\n        }\n    }\n    return false;\n}\n", "  //\
    \ start with the first two items in the list\n  let current: number = l[0];\n\
    \  let next: number = l[1];\n  // create an empty array to store the negative\
    \ values\n  let negs: number[] = [];\n  // loop through the list\n  for (let i:\
    \ number = 0; i < l.length; i++) {\n    // if the current value is negative, push\
    \ it to the negs array\n    if (current < 0) {\n      negs.push(current);\n  \
    \  }\n    // if the next value is in the negs array, return true\n    if (negs.includes(next))\
    \ {\n      return true;\n    }\n    // if the current value is the last one in\
    \ the list, break the loop\n    if (i === l.length - 1) {\n      break;\n    }\n\
    \    // if the current and next values aren't the same, shift them forward\n \
    \   if (current !== next) {\n      current = next;\n      next = l[i + 2];\n \
    \   }\n  }\n  // if nothing is found, return false\n  return false;\n}\n", " \
    \ for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length;\
    \ j++) {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n\
    \  }\n  return false;\n}\n", "    let zero_found = false;\n    for (let i = 0;\
    \ i < l.length; i++){\n        if(l[i] + l[i+1] === 0){\n            zero_found\
    \ = true;\n        }\n    }\n    return zero_found;\n}\n", "    // your code here\n\
    \    return false;\n}\n", "  let visited: { [index: number]: boolean } = {};\n\
    \  for (let elem of l) {\n    visited[elem] = true;\n  }\n  for (let elem of l)\
    \ {\n    if (visited[-elem]) {\n      return true;\n    }\n  }\n  return false;\n\
    }\n", "  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length;\
    \ j++) {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n\
    \  }\n  return false;\n}\n", "    return l.length !== 1 && l.length !== 0 && l.some((e,\
    \ i) => l.slice(i + 1).some(e2 => e + e2 === 0));\n}\n", "  let s = new Set<number>();\n\
    \  for (let i = 0; i < l.length; i++) {\n    if (s.has(l[i])) {\n      return\
    \ true;\n    }\n    s.add(-l[i]);\n  }\n  return false;\n}\n", "  let seen: Set<number>\
    \ = new Set();\n  for (let i = 0; i < l.length; i++) {\n    if (seen.has(-l[i]))\
    \ {\n      return true;\n    }\n    seen.add(l[i]);\n  }\n  return false;\n}\n",
  "  const set = new Set();\n  for (const num of l) {\n    set.add(num);\n  }\n  for\
    \ (const num of l) {\n    if (set.has(-num)) {\n      return true;\n    }\n  }\n\
    \  return false;\n}\n", "    let arr = [];\n    for (let i = 0; i < l.length;\
    \ i++) {\n        let x = l[i];\n        let c = l.filter(e => e == -x);\n   \
    \     if (c.length > 0) {\n            arr.push(x);\n        }\n    }\n    return\
    \ (arr.length > 0) ? true : false;\n}\n", "    const target = 0;\n    let isPairsSumToZero\
    \ = false;\n    let seen: number[] = [];\n    l.forEach( (n: number) => {\n  \
    \      if (n === 0) {\n            if (seen.includes(n)) {\n                isPairsSumToZero\
    \ = true;\n            } else {\n                seen.push(n);\n            }\n\
    \        } else {\n            if (seen.includes(target - n)) {\n            \
    \    isPairsSumToZero = true;\n            } else {\n                seen.push(n);\n\
    \            }\n        }\n    });\n    return isPairsSumToZero;\n}\n", "    let\
    \ a = 0;\n    let b = l.length - 1;\n    while (a < b) {\n        if (l[a] + l[b]\
    \ === 0) {\n            return true;\n        } else if (l[a] + l[b] > 0) {\n\
    \            b -= 1;\n        } else {\n            a += 1;\n        }\n    }\n\
    \    return false;\n}\n", "  const hash: { [key: number]: number } = {};\n  for\
    \ (let i = 0; i < l.length; i++) {\n    hash[l[i]] = i;\n  }\n  for (let i = 0;\
    \ i < l.length; i++) {\n    const complement = 0 - l[i];\n    if (hash[complement]\
    \ && hash[complement] !== i) {\n      return true;\n    }\n  }\n  return false;\n\
    }\n", "    let seen: { [k: number]: boolean } = {};\n    for (let e of l) {\n\
    \        if (seen[-e]) {\n            return true;\n        }\n        seen[e]\
    \ = true;\n    }\n    return false;\n}\n", "    let result: boolean = false;\n\
    \    for (let i = 0; i < l.length; i++) {\n        for (let j = 0; j < l.length;\
    \ j++) {\n            if (i !== j && l[i] + l[j] === 0) {\n                result\
    \ = true;\n            }\n        }\n    }\n    return result;\n}\n", "  // your\
    \ code here\n  return false;\n}\n", "    if (l.length === 0) {\n        return\
    \ false;\n    }\n    for (let i = 0; i < l.length; i++) {\n        for (let j\
    \ = i + 1; j < l.length; j++) {\n            if (l[i] + l[j] === 0) {\n      \
    \          return true;\n            }\n        }\n    }\n    return false;\n\
    }\n", "    // Base case\n    if (l.length <= 1) {\n        return false;\n   \
    \ }\n    // Remove the first element\n    const [_, ...tail] = l;\n    // Take\
    \ every element in the array and check if the absolute value of it is in the list\n\
    \    // if it is, return true, otherwise return the output of the function called\
    \ on the tail.\n    // this will recursively go through the list\n    return tail.indexOf(Math.abs(l[0]))\
    \ !== -1 || pairs_sum_to_zero(tail);\n}\n", "  let set = new Set<number>();\n\
    \  for (let i = 0; i < l.length; i++) {\n    if (set.has(0 - l[i])) {\n      return\
    \ true;\n    }\n    set.add(l[i]);\n  }\n  return false;\n}\n", "  let h: { [index:\
    \ number]: boolean } = {};\n  for (let i of l) {\n    h[i] = true;\n  }\n  for\
    \ (let i of l) {\n    if (h[-i]) {\n      return true;\n    }\n  }\n  return false;\n\
    }\n", "    for (let i = 0; i < l.length; i++) {\n        for (let j = i + 1; j\
    \ < l.length; j++) {\n            if (l[i] + l[j] === 0) {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}\n", "  const set:\
    \ Set<number> = new Set();\n  for (const num of l) {\n    if (set.has(num * -1))\
    \ {\n      return true;\n    }\n    set.add(num);\n  }\n  return false;\n}\n",
  "    for (let i = 0; i < l.length; i++) {\n        for (let j = i + 1; j < l.length;\
    \ j++) {\n            if (l[i] + l[j] === 0) {\n                return true;\n\
    \            }\n        }\n    }\n    return false;\n}\n", "  for (let i: number\
    \ = 0; i < l.length; i++) {\n    for (let j: number = i + 1; j < l.length; j++)\
    \ {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n\
    \  return false;\n}\n", "  if (l.length < 2) {\n    return false;\n  }\n  let\
    \ first: number;\n  let second: number;\n  let isSum = false;\n  for (let i =\
    \ 0; i < l.length; i++) {\n    first = l[i];\n    for (let j = i + 1; j < l.length;\
    \ j++) {\n      second = l[j];\n      if (first + second === 0) {\n        isSum\
    \ = true;\n      }\n    }\n  }\n  return isSum;\n}\n", "  for (let i = 0; i <\
    \ l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i]\
    \ + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n\
    }\n", "    if (l.length < 2) {\n        return false;\n    }\n    for (let i:\
    \ number = 0; i < l.length; i++) {\n        for (let j: number = i + 1; j < l.length;\
    \ j++) {\n            if (l[i] + l[j] === 0) {\n                return true;\n\
    \            }\n        }\n    }\n    return false;\n}", "  let l_set = new Set(l);\n\
    \  for (let i = 0; i < l.length; i++) {\n    if (l_set.has(-l[i])) {\n      return\
    \ true;\n    }\n  }\n  return false;\n}\n", "  let hasZero = false;\n  let negs:\
    \ number[] = [];\n  let poss: number[] = [];\n  for (let i = 0; i < l.length;\
    \ i++) {\n    if (l[i] === 0) {\n      hasZero = true;\n    } else if (l[i] <\
    \ 0) {\n      negs.push(l[i]);\n    } else {\n      poss.push(l[i]);\n    }\n\
    \  }\n  if (hasZero) {\n    for (let i = 0; i < l.length; i++) {\n      if (l[i]\
    \ === 0) {\n        return true;\n      }\n    }\n  }\n  let n = 0;\n  let p =\
    \ 0;\n  while (n < negs.length && p < poss.length) {\n    if (negs[n] + poss[p]\
    \ === 0) {\n      return true;\n    } else if (negs[n] + poss[p] < 0) {\n    \
    \  n++;\n    } else {\n      p++;\n    }\n  }\n  return false;\n}\n", "    let\
    \ n = l.length;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1;\
    \ j < n; j++) {\n            if (l[i] + l[j] === 0) {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}\n\nexport {\n \
    \   pairs_sum_to_zero\n}", "    // YOUR CODE HERE\n    for (let i of l) {\n  \
    \      for (let j of l) {\n            if (j + i === 0) {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n    // return raise\
    \ NotImplementedError();\n}\n", "  let s = new Set<number>();\n  for (let i of\
    \ l) {\n    if (s.has(-i)) {\n      return true;\n    }\n    s.add(i);\n  }\n\
    \  return false;\n}\n", "  let length = l.length;\n  if (length <= 1) {\n    return\
    \ false;\n  }\n  let last_1 = l[length - 1];\n  let last_2 = l[length - 2];\n\
    \  if (last_1 === -last_2) {\n    return true;\n  }\n  return pairs_sum_to_zero(l.slice(0,\
    \ -1));\n}\n", "  if (l.length <= 1) {\n    return false;\n  }\n\n  let s = new\
    \ Set<number>();\n  for (let n of l) {\n    if (s.has(n)) {\n      return true;\n\
    \    }\n    s.add(-n);\n  }\n  return false;\n}\n", "    // TODO: Replace me with\
    \ your code.\n    return false;\n}\n", "    let m: { [key: number]: boolean }\
    \ = {};\n    for (let i = 0; i < l.length; i++) {\n        if (m[-l[i]]) {\n \
    \           return true;\n        }\n        m[l[i]] = true;\n    }\n    return\
    \ false;\n}\n", "    for (let i = 0; i < l.length; i++) {\n        for (let j\
    \ = i + 1; j < l.length; j++) {\n            if (l[i] + l[j] === 0) {\n      \
    \          return true;\n            }\n        }\n    }\n    return false;\n\
    }\n", "  const set = new Set<number>();\n  for (const num of l) {\n    if (set.has(num))\
    \ {\n      return true;\n    }\n    set.add(-num);\n  }\n  return false;\n}\n",
  "    let c: boolean = false;\n    for (let i: number = 0; i < l.length; i++) {\n\
    \        for (let j: number = 0; j < l.length; j++) {\n            if (i != j\
    \ && l[i] + l[j] == 0) {\n                c = true;\n            }\n        }\n\
    \    }\n    return c;\n}\n", "    for (let i = 0; i < l.length; i++) {\n     \
    \   for (let j = i + 1; j < l.length; j++) {\n            if (l[i] + l[j] ===\
    \ 0) {\n                return true;\n            }\n        }\n    }\n    return\
    \ false;\n}", "  if (l.length <= 1) {\n    return false;\n  }\n  let s = new Set();\n\
    \  for (let item of l) {\n    s.add(item);\n  }\n  for (let item of l) {\n   \
    \ if (s.has(-item)) {\n      return true;\n    }\n  }\n  return false;\n}\n",
  "  // YOUR CODE HERE\n  return true;\n}\n", "  let lookup = new Set<number>();\n\
    \  for (let i = 0; i < l.length; i++) {\n    lookup.add(l[i]);\n  }\n  for (let\
    \ i = 0; i < l.length; i++) {\n    if (lookup.has(-l[i])) {\n      return true;\n\
    \    }\n  }\n  return false;\n}\n", "    if (l.length < 2) {\n        return false;\n\
    \    }\n    let absList = l.map(Math.abs);\n    let sumList = l.reduce((a,b) =>\
    \ a + b);\n    return (Math.max(...absList) > sumList);\n}\n", "  let zeros: number[]\
    \ = l.filter(x => x === 0);\n  if (zeros.length >= 2) {\n    return true;\n  }\
    \ else {\n    for (let i: number = 0; i < l.length; i++) {\n      for (let j:\
    \ number = i + 1; j < l.length; j++) {\n        if (l[i] + l[j] === 0) {\n   \
    \       return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n", " \
    \ return false;\n}\n", "  // Your code here!\n  return true;\n}\n", "    for (let\
    \ i of l) {\n        for (let j of l) {\n            if (i !== j && i + j ===\
    \ 0) {\n                return true;\n            }\n        }\n    }\n    return\
    \ false;\n}\n", "  for (const i of l) {\n    for (const j of l) {\n      if (i\
    \ + j === 0 && i !== j) {\n        return true;\n      }\n    }\n  }\n  return\
    \ false;\n}\n", "    // You must implement this function.\n    // Do not change\
    \ the function name or signature.\n    let result: boolean = false;\n    let length\
    \ = l.length;\n    for (let i = 0; i < length; i++) {\n        for (let j = i\
    \ + 1; j < length; j++) {\n            if (l[i] + l[j] === 0) {\n            \
    \    result = true;\n                break;\n            }\n        }\n    }\n\
    \    return result;\n}\n", "    let hashmap: { [id: number]: number } = {};\n\
    \    for (let i = 0; i < l.length; i++) {\n        let target = 0 - l[i];\n  \
    \      if (hashmap[target] !== undefined) {\n            return true;\n      \
    \  }\n        hashmap[l[i]] = i;\n    }\n    return false;\n}\n", "    // your\
    \ solution here\n    const visited: Set<number> = new Set();\n    for (const i\
    \ of l) {\n        if (visited.has(-i)) {\n            return true;\n        }\n\
    \        visited.add(i);\n    }\n    return false;\n}", "  if (l.length <= 1)\
    \ {\n    return false;\n  }\n  const hash = new Hash();\n  for (let i = 0; i <\
    \ l.length; i++) {\n    const v = l[i];\n    if (hash.hasValue(v)) {\n      return\
    \ true;\n    }\n    hash.setValue(v, i);\n  }\n  return false;\n}\n", "  // your\
    \ code here\n  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j\
    \ < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n        return true;\n \
    \     }\n    }\n  }\n  return false;\n}\n", "    let map = new Map();\n    l.forEach(e\
    \ => {\n        if (map.has(e)) {\n            return true;\n        } else {\n\
    \            map.set(-e, 1);\n        }\n    });\n    return false;\n}\nconsole.log(pairs_sum_to_zero([1,\
    \ 3, 5, 0]));\nconsole.log(pairs_sum_to_zero([1, 3, -2, 1]));\nconsole.log(pairs_sum_to_zero([1,\
    \ 2, 3, 7]));\nconsole.log(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]));\nconsole.log(pairs_sum_to_zero([1]));\n",
  "    let result: boolean = false;\n    for (let i: number = 0; i < l.length; i++)\
    \ {\n        for (let j: number = 0; j < l.length; j++) {\n            if (l[i]\
    \ + l[j] === 0 && i !== j) {\n                result = true;\n            }\n\
    \        }\n    }\n    return result;\n}\n", "    for (let i = 0; i < l.length;\
    \ i++) {\n        for (let j = i + 1; j < l.length; j++) {\n            if (l[i]\
    \ + l[j] === 0) {\n                return true;\n            }\n        }\n  \
    \  }\n    return false;\n}\n", "    const s = new Set<number>();\n    for (const\
    \ i of l) {\n        if (s.has(-i)) {\n            return true;\n        }\n \
    \       s.add(i);\n    }\n    return false;\n}\n", "  return l.length > 1\n  \
    \  ? l.slice(1).reduce((acc, el) => acc || l.slice(0, l.length - 1).includes(-el),\
    \ false)\n    : false;\n}\n", "  if (l.length < 2) {\n    return false;\n  }\n\
    \n  let nums: Set<number> = new Set(l);\n  for (let n of nums) {\n    if (nums.has(-n))\
    \ {\n      return true;\n    }\n  }\n  return false;\n}\n", "    // Implement\
    \ this function here.\n    return false;\n}\n", "  for (const i of l) {\n    if\
    \ (l.indexOf(-i) > -1) {\n      return true;\n    }\n  }\n  return false;\n}\n",
  "    for (let i: number = 0; i < l.length; i++) {\n        for (let j: number =\
    \ i + 1; j < l.length; j++) {\n            if (l[i] + l[j] === 0) {\n        \
    \        return true;\n            }\n        }\n    }\n    return false;\n}\n",
  "  for (let i = 0; i < l.length; i += 1) {\n    for (let j = i + 1; j < l.length;\
    \ j += 1) {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n \
    \   }\n  }\n  return false;\n}\n\ntest('pairs_sum_to_zero', () => {\n  expect(pairs_sum_to_zero([1,\
    \ 3, 5, 0])).toBe(false);\n  expect(pairs_sum_to_zero([1, 3, -2, 1])).toBe(false);\n\
    \  expect(pairs_sum_to_zero([1, 2, 3, 7])).toBe(false);\n  expect(pairs_sum_to_zero([2,\
    \ 4, -5, 3, 5, 7])).toBe(true);\n  expect(pairs_sum_to_zero([1])).toBe(false);\n\
    });\n", "    let visited: Set<number> = new Set<number>();\n    for (let el of\
    \ l) {\n        if (visited.has(-el)) {\n            return true;\n        }\n\
    \        visited.add(el);\n    }\n    return false;\n}\n", "    // TODO\n    return\
    \ true;\n}\n\n", "    // first, check that this list has two or more elements\
    \ in it\n    if (l.length < 2) {\n        return false;\n    }\n    // now, iterate\
    \ through the list from beginning to end\n    for (let i = 0; i < l.length; i++)\
    \ {\n        // check if the negative of this element exists in the rest of the\
    \ list\n        // we have to iterate through the rest of the list to do this\n\
    \        for (let j = i + 1; j < l.length; j++) {\n            if (l[i] === -l[j])\
    \ {\n                return true;\n            }\n        }\n    }\n    return\
    \ false;\n}\n", "    const seen = new Set<number>();\n    for (const num of l)\
    \ {\n        if (seen.has(-num)) {\n            return true;\n        }\n    \
    \    seen.add(num);\n    }\n    return false;\n}\n", "  let m: number = 0;\n \
    \ let n: number = l.length - 1;\n  while (m < n) {\n    let sum: number = l[m]\
    \ + l[n];\n    if (sum === 0) {\n      return true;\n    } else if (sum > 0) {\n\
    \      n -= 1;\n    } else {\n      m += 1;\n    }\n  }\n  return false;\n}\n",
  "  // if the array is empty, there are no pairs\n  if (l.length === 0) {\n    return\
    \ false;\n  }\n  // if the array has only one element, there are no pairs\n  if\
    \ (l.length === 1) {\n    return false;\n  }\n  // otherwise, for every element\
    \ in the array, check if the\n  // rest of the array has a complementary element\n\
    \  for (let i = 0; i < l.length; i++) {\n    for (let j = 0; j < l.length; j++)\
    \ {\n      if (l[i] + l[j] === 0 && i !== j) {\n        return true;\n      }\n\
    \    }\n  }\n  return false;\n}\n", "  const seen = new Set();\n  for (const i\
    \ of l) {\n    if (seen.has(-i)) {\n      return true;\n    }\n    seen.add(i);\n\
    \  }\n  return false;\n}\n", "    var a = new Set(l);\n    for (var i of a) {\n\
    \        if (a.has(-i)) return true;\n    }\n    return false;\n}\n", "  let dict:\
    \ { [key: number]: number } = {};\n  for (let i = 0; i < l.length; i++) {\n  \
    \  let num = l[i];\n    if (dict[num]) {\n      return true;\n    } else {\n \
    \     dict[-num] = num;\n    }\n  }\n  return false;\n}\n", "    //Base case -\
    \ list is empty\n    if (l.length == 0) {\n        return false;\n    }\n    //Base\
    \ case - list has 1 element\n    else if (l.length == 1) {\n        return false;\n\
    \    }\n    //Base case - list has 2 elements\n    else if (l.length == 2) {\n\
    \        return (l[0] + l[1] == 0);\n    }\n    //Inductive case\n    else {\n\
    \        //First, check first two elements of list\n        if (l[0] + l[1] ==\
    \ 0) {\n            return true;\n        }\n        //Next, check all other pairs\
    \ in the list\n        else {\n            return pairs_sum_to_zero(l.slice(1));\n\
    \        }\n    }\n}", "    let hashtable = {};\n    for (let i = 0; i < l.length;\
    \ i++) {\n        if (hashtable[l[i]]) {\n            hashtable[l[i]]++;\n   \
    \     } else {\n            hashtable[l[i]] = 1;\n        }\n    }\n    for (let\
    \ i = 0; i < l.length; i++) {\n        if (hashtable[-l[i]]) {\n            return\
    \ true;\n        }\n    }\n    return false;\n}\n", "  return false;\n}\n", " \
    \ for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length;\
    \ j++) {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n\
    \  }\n  return false;\n}\n", "    let check: boolean = false;\n    let num: number\
    \ = 0;\n    while (num < l.length && !check) {\n        let num2: number = 0;\n\
    \        while (num2 < l.length && !check) {\n            if (num !== num2 &&\
    \ l[num] + l[num2] === 0) {\n                check = true;\n            }\n  \
    \          num2++;\n        }\n        num++;\n    }\n    return check;\n}\n",
  "  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++)\
    \ {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n\
    \  return false;\n}\n", "  for (let i: number = 0; i < l.length; i++) {\n    for\
    \ (let j: number = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n\
    \        return true;\n      }\n    }\n  }\n  return false;\n}\n", "    for (let\
    \ i = 0; i < l.length; i++) {\n        for (let j = i + 1; j < l.length; j++)\
    \ {\n            if (l[i] + l[j] === 0) {\n                return true;\n    \
    \        }\n        }\n    }\n    return false;\n}\n\ntest(pairs_sum_to_zero([1,\
    \ 3, 5, 0]), false);\ntest(pairs_sum_to_zero([1, 3, -2, 1]), false);\ntest(pairs_sum_to_zero([1,\
    \ 2, 3, 7]), false);\ntest(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]), true);\ntest(pairs_sum_to_zero([1]),\
    \ false);\n", "    // your code here\n    return true;\n}\n\n\n", "  return false;\n\
    }\n", "    const len = l.length;\n    for (let i = 0; i < len; i++) {\n      \
    \  for (let j = i + 1; j < len; j++) {\n            if (l[i] + l[j] === 0) {\n\
    \                return true;\n            }\n        }\n    }\n    return false;\n\
    }\n", "  for (const i of l) {\n    for (const j of l) {\n      if (i + j === 0\
    \ && i !== j) {\n        return true;\n      }\n    }\n  }\n  return false;\n\
    }\n", "    for (let i of l) {\n        for (let j of l) {\n            if (i +\
    \ j === 0 && i !== j) {\n                return true;\n            }\n       \
    \ }\n    }\n    return false;\n}\n", "    const neg_set = new Set();\n    for\
    \ (const n of l) {\n        if (neg_set.has(n)) {\n            return true;\n\
    \        }\n        neg_set.add(-n);\n    }\n    return false;\n}\n\n", "  let\
    \ bs = new Set<number>();\n  for (let i of l) {\n    if (bs.has(-i)) {\n     \
    \ return true;\n    }\n    bs.add(i);\n  }\n  return false;\n}\n", "    return\
    \ false;\n}\n", "  return false;\n}\n", "  let set = new Set(l);\n  for (let i\
    \ = 0; i < l.length; i++) {\n    if (set.has(-l[i])) {\n      return true;\n \
    \   }\n  }\n  return false;\n}\n", "    if (l.length < 2) {\n        return false;\n\
    \    }\n    for (let i = 0; i < l.length; i++) {\n        for (let j = i + 1;\
    \ j < l.length; j++) {\n            if (l[i] + l[j] === 0) {\n               \
    \ return true;\n            }\n        }\n    }\n    return false;\n}\nconsole.log(pairs_sum_to_zero([2,\
    \ 4, -5, 3, 5, 7]));\n", "    // YOUR CODE HERE\n    throw new Error(\"unimplemented\"\
    );\n}\n", "    return false;\n}\n\ndescribe(\"pairs_sum_to_zero\", function()\
    \ {\n    it(\"returns false if there are no pairs that sum to zero\", function()\
    \ {\n        assert.equal(pairs_sum_to_zero([1, 3, 5, 0]), false);\n        assert.equal(pairs_sum_to_zero([1,\
    \ 3, -2, 1]), false);\n        assert.equal(pairs_sum_to_zero([1, 2, 3, 7]), false);\n\
    \        assert.equal(pairs_sum_to_zero([1]), false);\n    });\n    it(\"returns\
    \ true if there are two distinct elements that sum to zero\", function() {\n \
    \       assert.equal(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]), true);\n    });\n\
    });\n", "  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length;\
    \ j++) {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n\
    \  }\n  return false;\n}\n", "    let set: Set<number> = new Set(l);\n    for\
    \ (let n of set) {\n        if (set.has(-n)) {\n            return true;\n   \
    \     }\n    }\n    return false;\n}\nconsole.log(pairs_sum_to_zero([1, 3, 5,\
    \ 0]));\nconsole.log(pairs_sum_to_zero([1, 3, -2, 1]));\nconsole.log(pairs_sum_to_zero([1,\
    \ 2, 3, 7]));\nconsole.log(pairs_sum_to_zero([2, 4, -5, 3, 5, 7]));\nconsole.log(pairs_sum_to_zero([1]));\n",
  "  // YOUR CODE HERE\n  throw new Error(\"Not implemented\");\n}\n", "  var zeros\
    \ = 0;\n  var length = l.length;\n  for (var i = 0; i < length; i++) {\n    for\
    \ (var j = i + 1; j < length; j++) {\n      if (l[i] + l[j] === 0) {\n       \
    \ return true;\n      }\n    }\n  }\n  return false;\n}\n", "    if (l.length\
    \ <= 1) {\n        return false;\n    }\n    for (let i = 0; i < l.length; i++)\
    \ {\n        for (let j = i + 1; j < l.length; j++) {\n            if (l[i] +\
    \ l[j] === 0) {\n                return true;\n            }\n        }\n    }\n\
    \    return false;\n}", "    if (l.length <= 1) {\n        return false;\n   \
    \ }\n    let storage = {};\n    for (let i = 0; i < l.length; i++) {\n       \
    \ storage[l[i]] = 1;\n    }\n    for (let i = 0; i < l.length; i++) {\n      \
    \  if (storage[-l[i]]) {\n            return true;\n        }\n    }\n    return\
    \ false;\n}", "    // your code here\n    return false;\n}\n\n", "    let seen\
    \ = new Set();\n    for (let num of l) {\n        if (seen.has(-num)) {\n    \
    \        return true;\n        }\n        seen.add(num);\n    }\n    return false;\n\
    }\n", "  if (l.length < 2) {\n    return false;\n  }\n\n  let s = new Set<number>();\n\
    \  for (let i = 0; i < l.length; i++) {\n    if (s.has(l[i])) {\n      return\
    \ true;\n    } else {\n      s.add(-l[i]);\n    }\n  }\n  return false;\n}\n",
  "  var a: number[] = [];\n  var b: number[] = [];\n  var j: number = 0;\n  var sum:\
    \ number = 0;\n  while (l.length > 0) {\n    a[j] = l.pop();\n    b[j] = a[j];\n\
    \    j = j + 1;\n  }\n  j = 0;\n  while (a.length > 0) {\n    if (b.indexOf(-a[j])\
    \ != -1) {\n      return true;\n    }\n    a.splice(j, 1);\n  }\n  return false;\n\
    }\n", "  let numset = new Set(l);\n  for (let x of numset) {\n    if (numset.has(-x))\
    \ {\n      return true;\n    }\n  }\n  return false;\n}\n", "  for (let i = 0;\
    \ i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if\
    \ (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n\
    }\n", "    let f: boolean = false;\n    for (let n of l) {\n        if (l.includes(-n))\
    \ {\n            f = true;\n        }\n    }\n    return f;\n}\n", "  return false;\n\
    }\n\nexport {\n  is_factor,\n  is_even,\n  is_odd,\n  even_sum,\n  sum_of_digits,\n\
    \  factorial,\n  sum_digits_factorial,\n  pairs_sum_to_zero\n};", "    let i:\
    \ number = 0;\n    let j: number = 1;\n    let pair: number[] = [];\n    while\
    \ (i < l.length && j < l.length) {\n        pair = [l[i], l[j]];\n        if (sum(pair)\
    \ === 0) {\n            return true;\n        }\n        j++;\n        if (j ===\
    \ l.length) {\n            i++;\n            j = i + 1;\n        }\n    }\n  \
    \  return false;\n}\n", "    let result: boolean = false;\n    for (let i: number\
    \ = 0; i < l.length; i++) {\n        for (let j: number = i + 1; j < l.length;\
    \ j++) {\n            if (l[i] + l[j] === 0) {\n                result = true;\n\
    \            }\n        }\n    }\n    return result;\n}\n", "  if (l.length <=\
    \ 1) {\n    return false;\n  }\n  for (let i = 0; i < l.length; i++) {\n    for\
    \ (let j = i + 1; j < l.length; j++) {\n      if (l[i] + l[j] === 0) {\n     \
    \   return true;\n      }\n    }\n  }\n  return false;\n}\n", "  if (l.length\
    \ <= 1) {\n    return false;\n  }\n  let nums = new Set(l);\n  let numArr = Array.from(nums);\n\
    \  for (let i = 0; i < numArr.length; i++) {\n    if (nums.has(-numArr[i])) {\n\
    \      return true;\n    }\n  }\n  return false;\n}\n", "  for (let i = 0; i <\
    \ l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i]\
    \ + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n\
    }\n", "    for (let i = 0; i < l.length; i++) {\n        for (let j = i + 1; j\
    \ < l.length; j++) {\n            if (l[i] + l[j] === 0) {\n                return\
    \ true;\n            }\n        }\n    }\n    return false;\n}\n", "    let i:\
    \ number;\n    let j: number;\n    for (i = 0; i < l.length; i++) {\n        for\
    \ (j = i + 1; j < l.length; j++) {\n            if (l[i] + l[j] === 0) {\n   \
    \             return true;\n            }\n        }\n    }\n    return false;\n\
    }\n", "  // check for a special case\n  if (l.length < 2) {\n    return false;\n\
    \  }\n  // sort the input\n  const sorted = l.sort((a, b) => a - b);\n  // use\
    \ two indices to check the solution\n  let start = 0;\n  let end = sorted.length\
    \ - 1;\n  while (start < end) {\n    const current_sum = sorted[start] + sorted[end];\n\
    \    if (current_sum === 0) {\n      return true;\n    } else if (current_sum\
    \ < 0) {\n      start++;\n    } else {\n      end--;\n    }\n  }\n  return false;\n\
    }\n", "    if (l.length < 2) {\n        return false;\n    }\n\n    // two pointers.\n\
    \    // one starts at the begining, one at the end.\n    // if they sum to 0,\
    \ then we can return true,\n    // otherwise, we move them in until the array\
    \ is sorted.\n    // since we are always moving the pointers in, we are eventually\
    \ going to\n    // have them meet, at which point we know that the array does\
    \ not have a pair\n    // that sums to 0.\n    let left_pointer = 0;\n    let\
    \ right_pointer = l.length - 1;\n\n    l.sort();\n\n    while (left_pointer <\
    \ right_pointer) {\n        if (l[left_pointer] + l[right_pointer] === 0) {\n\
    \            return true;\n        } else if (l[left_pointer] + l[right_pointer]\
    \ < 0) {\n            left_pointer++;\n        } else {\n            right_pointer--;\n\
    \        }\n    }\n\n    return false;\n}\n", "    let i: number;\n    let j:\
    \ number;\n    let zeroPair: boolean = false;\n    let n: number = l.length;\n\
    \    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n      \
    \      if (l[i] + l[j] === 0) {\n                zeroPair = true;\n          \
    \  }\n        }\n    }\n    return zeroPair;\n}\n", "  let found = false;\n  for\
    \ (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++)\
    \ {\n      if (l[i] + l[j] === 0) {\n        found = true;\n      }\n    }\n \
    \ }\n  return found;\n}", "  const map = {}\n  let result = false\n  for (let\
    \ i = 0; i < l.length; i++) {\n    if (map[l[i]]) {\n      map[l[i]]++\n    }\
    \ else {\n      map[l[i]] = 1\n    }\n  }\n  for (let i = 0; i < l.length; i++)\
    \ {\n    if (map[-l[i]]) {\n      result = true\n    }\n  }\n  return result\n\
    }\n", "    var arr = [];\n    for (var i = 0; i < l.length; i++) {\n        if\
    \ (arr.indexOf(Math.abs(l[i])) > -1) {\n            return true;\n        }\n\
    \        arr.push(l[i]);\n    }\n    return false;\n}\n", "    for (let i = 0;\
    \ i < l.length; i++) {\n        for (let j = i + 1; j < l.length; j++) {\n   \
    \         if (l[i] + l[j] === 0) {\n                return true;\n           \
    \ }\n        }\n    }\n    return false;\n}\n", "    for (let i = 0; i < l.length;\
    \ i++) {\n        for (let j = i + 1; j < l.length; j++) {\n            if (l[i]\
    \ + l[j] === 0) {\n                return true;\n            }\n        }\n  \
    \  }\n    return false;\n}\n", "  if (l.length < 2) {\n    return false;\n  }\n\
    \  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length;\
    \ j++) {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n\
    \  }\n  return false;\n}\n", "    var flag: boolean = false;\n    var pair: boolean\
    \ = false;\n    var flag1: boolean = false;\n    var pair1: boolean = false;\n\
    \    for (var i = 0; i < l.length; i++) {\n        for (var j = 0; j < l.length;\
    \ j++) {\n            if (i != j) {\n                if (l[i] + l[j] == 0) {\n\
    \                    flag = true;\n                    if (i < j) {\n        \
    \                pair = true;\n                    }\n                }\n    \
    \        }\n        }\n    }\n    if (flag == true && pair == true) {\n      \
    \  return true;\n    }\n    else {\n        return false;\n    }\n}\n", "    let\
    \ set = new Set<number>();\n    for (let elem of l) {\n        if (set.has(elem\
    \ * -1)) {\n            return true;\n        }\n        set.add(elem);\n    }\n\
    \    return false;\n}\n", "    if (l.length < 2) {\n        return false;\n  \
    \  }\n    let allPairs: number[][] = [];\n    for (let i = 0; i < l.length; i++)\
    \ {\n        for (let j = i + 1; j < l.length; j++) {\n            allPairs.push([l[i],\
    \ l[j]]);\n        }\n    }\n    return allPairs.some(pair => {\n        return\
    \ pair[0] + pair[1] === 0;\n    });\n}", "  // Write your code here.\n  // \u4F7F\
    \u7528\u53CC\u5C42\u5FAA\u73AF\n  // for (const index_a in l) {\n  //   for (const\
    \ index_b in l) {\n  //     if (index_a !== index_b && Number(index_a) + Number(index_b)\
    \ === 0) {\n  //       return true;\n  //     }\n  //   }\n  // }\n  // return\
    \ false;\n\n  // \u4F7F\u7528set\n  // const set = new Set(l);\n  // for (const\
    \ index in l) {\n  //   if (set.has(-l[index])) {\n  //     return true;\n  //\
    \   }\n  // }\n  // return false;\n\n  // \u4F7F\u7528hash\n  const hash = {};\n\
    \  for (const item of l) {\n    if (hash[-item]) {\n      return true;\n    }\n\
    \    hash[item] = true;\n  }\n  return false;\n}\n", "    if (l.length === 0)\
    \ {\n        return false;\n    } else {\n        let s: Set<number> = new Set();\n\
    \        let result: boolean = false;\n        for (let i = 0; i < l.length; i++)\
    \ {\n            if (s.has(l[i])) {\n                result = true;\n        \
    \    } else {\n                s.add(-l[i]);\n            }\n        }\n     \
    \   return result;\n    }\n}", "    // since we've not talked about sets yet,\
    \ we'll use what we know\n    // to solve this with a double loop.\n    for (let\
    \ i = 0; i < l.length; i++) {\n        for (let j = i + 1; j < l.length; j++)\
    \ {\n            if (l[i] + l[j] === 0) {\n                return true;\n    \
    \        }\n        }\n    }\n    return false;\n}\n", "  // Your solution goes\
    \ here\n  if (l.length < 2) {\n    return false;\n  }\n  let isFound = false;\n\
    \  for (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length;\
    \ j++) {\n      if (l[i] + l[j] === 0) {\n        isFound = true;\n      }\n \
    \   }\n  }\n  return isFound;\n}\n", "  return false;\n}\n\nexport {\n  num_ones,\n\
    \  num_to_list,\n  list_to_num,\n  prefixes,\n  suffixes,\n  longest_common_prefix,\n\
    \  pairs_sum_to_zero,\n};", "    const length = l.length;\n    let j = 0;\n  \
    \  for (let i = 0; i < length; i++) {\n        j = i + 1;\n        while (j <\
    \ length) {\n            if (l[i] + l[j] === 0) {\n                return true;\n\
    \            }\n            j++;\n        }\n    }\n    return false;\n}\n\n",
  "    // TODO: implement\n    return true;\n}\n", "  let seen: number[] = [];\n \
    \ for (let n of l) {\n    if (seen.includes(-n)) {\n      return true;\n    }\n\
    \    seen.push(n);\n  }\n  return false;\n}\n", "  let l1 = l.slice();\n  l1.sort();\n\
    \  let l2 = l1.slice();\n  while (l1.length > 0) {\n    let curr = l1.pop();\n\
    \    if (l2.includes(-curr)) {\n      return true;\n    }\n  }\n  return false;\n\
    }\n\n", "  // YOUR CODE HERE\n  throw new Error(\"Not implemented yet.\");\n}\n",
  "    let result: number = 0;\n    for (let i: number = 0; i < l.length; i++) {\n\
    \        for (let j: number = i + 1; j < l.length; j++) {\n            if (l[i]\
    \ + l[j] === 0) {\n                result = 1;\n            }\n        }\n   \
    \ }\n    if (result === 1) {\n        return true;\n    } else {\n        return\
    \ false;\n    }\n}\nconsole.log(pairs_sum_to_zero([1, 3, 5, 0]));\nconsole.log(pairs_sum_to_zero([1,\
    \ 3, -2, 1]));\nconsole.log(pairs_sum_to_zero([1, 2, 3, 7]));\nconsole.log(pairs_sum_to_zero([2,\
    \ 4, -5, 3, 5, 7]));\nconsole.log(pairs_sum_to_zero([1]));", "    if (l.length\
    \ < 2) {\n        return false;\n    }\n    l.sort((x, y) => x - y);\n    if (l[0]\
    \ > 0 || l[l.length - 1] < 0) {\n        return false;\n    }\n    let i = 0;\n\
    \    let j = l.length - 1;\n    while (i < j) {\n        if (l[i] + l[j] === 0)\
    \ {\n            return true;\n        } else if (l[i] + l[j] > 0) {\n       \
    \     j--;\n        } else {\n            i++;\n        }\n    }\n    return false;\n\
    }\n", "    // Implement this function\n    //Question: what is the run time complexity\
    \ of this?\n    for (let i = 0; i < l.length; i++) {\n        if (list_contains(l,\
    \ i, -l[i])) {\n            return true;\n        }\n    }\n    return false;\n\
    }\n", "  if (l.length === 0) {\n    return false;\n  }\n  for (let i = 0; i <\
    \ l.length; i++) {\n    for (let j = i + 1; j < l.length; j++) {\n      if (l[i]\
    \ + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n  return false;\n\
    }\n", "  if (l.length == 0) {\n    return false;\n  }\n  // Pull out the first\
    \ element\n  const first = l[0];\n  const rest = l.slice(1);\n  // if it's in\
    \ rest, then return true\n  if (rest.includes(-first)) {\n    return true;\n \
    \ }\n  // otherwise, try the rest\n  return pairs_sum_to_zero(rest);\n}\n", " \
    \   //uses a set to keep track of the number of duplicates of each element in\
    \ the array\n    let s: Set<number> = new Set<number>();\n    //adds all elements\
    \ in the array to the set\n    for (let i: number = 0; i < l.length; i++) {\n\
    \        s.add(l[i]);\n    }\n    //goes through the array and checks if the negation\
    \ of each element is in the set\n    for (let i: number = 0; i < l.length; i++)\
    \ {\n        if (s.has(-l[i])) {\n            return true;\n        }\n    }\n\
    \    return false;\n}\n", "    // base case\n    if (l.length <= 1) {\n      \
    \  return false;\n    }\n    let map: Map<number, boolean> = new Map();\n    //\
    \ loop\n    for (let i: number = 0; i < l.length; i++) {\n        if (map.has(l[i]))\
    \ {\n            return true;\n        }\n        map.set(-l[i], true);\n    }\n\
    \    return false;\n}\nconsole.log(pairs_sum_to_zero([1, 3, 5, 0]));\nconsole.log(pairs_sum_to_zero([1,\
    \ 3, -2, 1]));\nconsole.log(pairs_sum_to_zero([1, 2, 3, 7]));\nconsole.log(pairs_sum_to_zero([2,\
    \ 4, -5, 3, 5, 7]));\nconsole.log(pairs_sum_to_zero([1]));\n", "  const lst =\
    \ l.sort((a, b) => a - b);\n  for (let i = 0; i < lst.length; i++) {\n    for\
    \ (let j = i + 1; j < lst.length; j++) {\n      if (lst[i] + lst[j] === 0) {\n\
    \        return true;\n      }\n    }\n  }\n  return false;\n}\n", "  const seen:\
    \ number[] = [];\n  for (const x of l) {\n    if (seen.includes(-x)) {\n     \
    \ return true;\n    }\n    seen.push(x);\n  }\n  return false;\n}\n", "  var seen:\
    \ number[] = [];\n  for (var i = 0; i < l.length; i++) {\n    if (seen.indexOf(-l[i])\
    \ != -1) {\n      return true;\n    }\n    seen.push(l[i]);\n  }\n  return false;\n\
    }\n\n", "  let arr: Set<number> = new Set(l);\n  let bool: boolean = false;\n\
    \  let i: number = 0;\n  while (i < l.length) {\n    if (arr.has(-l[i])) {\n \
    \     bool = true;\n    }\n    i++;\n  }\n  return bool;\n}\n", "    let sum =\
    \ 0;\n    let unique = {};\n    let i = 0;\n    while (i < l.length) {\n     \
    \   let x = l[i];\n        if (unique[x]) {\n            return true;\n      \
    \  }\n        sum += x;\n        unique[-sum] = true;\n        i++;\n    }\n \
    \   return false;\n}\n", "  if (l.length < 2) {\n    return false;\n  }\n  for\
    \ (let i = 0; i < l.length; i++) {\n    for (let j = i + 1; j < l.length; j++)\
    \ {\n      if (l[i] + l[j] === 0) {\n        return true;\n      }\n    }\n  }\n\
    \  return false;\n}\n", "    if (l.length < 2) {\n        return false;\n    }\n\
    \    if (l.length === 2) {\n        return l[0] + l[1] === 0;\n    }\n    for\
    \ (let i = 0; i < l.length; i++) {\n        for (let j = i + 1; j < l.length;\
    \ j++) {\n            if (l[i] + l[j] === 0) {\n                return true;\n\
    \            }\n        }\n    }\n    return false;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
