name: HumanEval_153_Strongest_Extension
language: ts
prompt: "//You will be given the name of a class (a string) and an array of extensions.\n\
  // The extensions are to be used to load additional classes to the class. The\n\
  // strength of the extension is as follows: Let CAP be the number of the uppercase\n\
  // letters in the extension's name, and let SM be the number of lowercase letters\
  \ \n// in the extension's name, the strength is given by the fraction CAP - SM.\
  \ \n// You should find the strongest extension and return a string in this \n//\
  \ format: ClassName.StrongestExtensionName.\n// If there are two or more extensions\
  \ with the same strength, you should\n// choose the one that comes first in the\
  \ array.\n// For example, if you are given \"Slices\" as the class and an array\
  \ of the\n// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
  // return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
  \ \n// (its strength is -1).\n// Example:\n// >>> Strongest_Extension(\"my_class\"\
  , [\"AA\", \"Be\", \"CC\"])\n// \"my_class.AA\"\nfunction Strongest_Extension(class_name:\
  \ string, extensions: string[]): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = Strongest_Extension;\n  assert.deepEqual(candidate(\"\
  Watashi\", [\"tEN\", \"niNE\", \"eIGHt8OKe\"]),\"Watashi.eIGHt8OKe\");\n  assert.deepEqual(candidate(\"\
  Boku123\", [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]),\"Boku123.YEs.WeCaNe\"\
  );\n  assert.deepEqual(candidate(\"__YESIMHERE\", [\"t\", \"eMptY\", \"nothing\"\
  , \"zeR00\", \"NuLl__\", \"123NoooneB321\"]),\"__YESIMHERE.NuLl__\");\n  assert.deepEqual(candidate(\"\
  K\", [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]),\"K.TAR\");\n  assert.deepEqual(candidate(\"\
  __HAHA\", [\"Tab\", \"123\", \"781345\", \"-_-\"]),\"__HAHA.123\");\n  assert.deepEqual(candidate(\"\
  YameRore\", [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]),\"YameRore.okIWILL123\"\
  );\n  assert.deepEqual(candidate(\"finNNalLLly\", [\"Die\", \"NowW\", \"Wow\", \"\
  WoW\"]),\"finNNalLLly.WoW\");\n  assert.deepEqual(candidate(\"_\", [\"Bb\", \"91245\"\
  ]),\"_.Bb\");\n  assert.deepEqual(candidate(\"Sp\", [\"671235\", \"Bb\"]),\"Sp.671235\"\
  );\n}\n\ntest();"
completions: ["  return \"\";\n}\n", "    let strength: number = 0, strongest_extension:\
    \ string = \"\";\n    extensions.forEach(function (extension) {\n        let current_strength:\
    \ number = 0;\n        extension.split(\"\").forEach(function (char) {\n     \
    \       if (char.match(/[A-Z]/)) {\n                current_strength++;\n    \
    \        } else if (char.match(/[a-z]/)) {\n                current_strength--;\n\
    \            }\n        });\n        if (current_strength > strength) {\n    \
    \        strength = current_strength;\n            strongest_extension = extension;\n\
    \        }\n    });\n    return `${class_name}.${strongest_extension}`;\n}\n",
  "    let all_extensions = extensions.map(ext => ext.toLowerCase())\n    let strengths\
    \ = all_extensions.map(ext => ext.match(/[A-Z]/g).length - ext.match(/[a-z]/g).length)\n\
    \    let max = Math.max(...strengths)\n    let index = strengths.indexOf(max)\n\
    \    return class_name + \".\" + extensions[index]\n}\nconsole.log(Strongest_Extension(\"\
    my_class\", [\"AA\", \"Be\", \"CC\"]))\n\n", "    let strongest = extensions[0]\n\
    \    let maximum = strength(strongest)\n    extensions.forEach(extension => {\n\
    \        let strengthVal = strength(extension)\n        if (strengthVal > maximum)\
    \ {\n            maximum = strengthVal\n            strongest = extension\n  \
    \      }\n    })\n    return class_name + \".\" + strongest\n}\n", "    let result:\
    \ [string, number] = [extensions[0], 0];\n    let extension_strength: [string,\
    \ number][] = [];\n    extensions.forEach(extension => {\n        let strength:\
    \ number = 0;\n        for (let char of extension) {\n            if (char >=\
    \ 'A' && char <= 'Z') strength++;\n            else if (char >= 'a' && char <=\
    \ 'z') strength--;\n        }\n        extension_strength.push([extension, strength]);\n\
    \    });\n    extension_strength.forEach(extension => {\n        if (extension[1]\
    \ > result[1]) result = extension;\n    });\n    return class_name + '.' + result[0];\n\
    }\n", "  let strongest_extension: string = \"\";\n  let strongest_strength: number\
    \ = -1000;\n  for (let i: number = 0; i < extensions.length; i++) {\n    let strength:\
    \ number = get_strength(extensions[i]);\n    if (strength > strongest_strength)\
    \ {\n      strongest_strength = strength;\n      strongest_extension = extensions[i];\n\
    \    }\n  }\n  return class_name + \".\" + strongest_extension;\n}\n", "    let\
    \ strongest = extensions[0];\n    let strongest_strength = (() => {\n        let\
    \ upper = extensions[0].match(/[A-Z]/g);\n        let lower = extensions[0].match(/[a-z]/g);\n\
    \        return upper.length - lower.length;\n    })();\n    for (let i = 1; i\
    \ < extensions.length; i++) {\n        let strength = (() => {\n            let\
    \ upper = extensions[i].match(/[A-Z]/g);\n            let lower = extensions[i].match(/[a-z]/g);\n\
    \            return upper.length - lower.length;\n        })();\n        if (strength\
    \ > strongest_strength) {\n            strongest = extensions[i];\n          \
    \  strongest_strength = strength;\n        }\n    }\n    return class_name + \"\
    .\" + strongest;\n}\n", "  let strong_ext = extensions[0]\n  for (let i = 1; i\
    \ < extensions.length; i++) {\n    if (strength(extensions[i]) > strength(strong_ext))\
    \ {\n      strong_ext = extensions[i]\n    }\n  }\n  return class_name + \".\"\
    \ + strong_ext\n}", "  return \"\";\n}\n", "    let strongest: string = extensions[0];\n\
    \    let strong_numerator: number = 0;\n    let strong_denominator: number = 0;\n\
    \    extensions.forEach(extension => {\n        let cap: number = 0;\n       \
    \ let sm: number = 0;\n        extension.split('').forEach(letter => {\n     \
    \       if (letter == letter.toUpperCase()) {\n                cap++;\n      \
    \      } else {\n                sm++;\n            }\n        });\n        let\
    \ strength: number = cap - sm;\n        if (strength > strong_numerator / strong_denominator)\
    \ {\n            strongest = extension;\n            strong_numerator = cap;\n\
    \            strong_denominator = sm;\n        }\n    });\n    return class_name\
    \ + '.' + strongest;\n}", "    return class_name + \".\" + extensions.sort((x,\
    \ y) => {\n        const cap_x = x.replace(/[^A-Z]/g, \"\").length;\n        const\
    \ sm_x = x.replace(/[^a-z]/g, \"\").length;\n        const cap_y = y.replace(/[^A-Z]/g,\
    \ \"\").length;\n        const sm_y = y.replace(/[^a-z]/g, \"\").length;\n   \
    \     const result = (cap_x - sm_x) - (cap_y - sm_y);\n        return result ==\
    \ 0 ? 1 : result;\n    })[0];\n}\n", "    let strongest_extension: string = \"\
    \";\n    let strongest_extension_strength: number = -1;\n    for (let i = 0; i\
    \ < extensions.length; i++) {\n        let strength: number = extensions[i].split(\"\
    \").filter(c => c.match(/[A-Z]/)).length - extensions[i].split(\"\").filter(c\
    \ => c.match(/[a-z]/)).length;\n        if (strength > strongest_extension_strength)\
    \ {\n            strongest_extension_strength = strength;\n            strongest_extension\
    \ = extensions[i];\n        }\n    }\n    return class_name + \".\" + strongest_extension;\n\
    }\n\nconsole.log(Strongest_Extension(\"Slices\", [\"SErviNGSliCes\", \"Cheese\"\
    , \"StuFfed\"]));", "    let max_score = 0;\n    let curr_score = 0;\n    let\
    \ max_index = 0;\n    for (let i = 0; i < extensions.length; i++) {\n        for\
    \ (let j = 0; j < extensions[i].length; j++) {\n            if (extensions[i][j]\
    \ === extensions[i][j].toUpperCase()) {\n                curr_score += 1;\n  \
    \          } else {\n                curr_score -= 1;\n            }\n       \
    \ }\n        if (curr_score > max_score) {\n            max_score = curr_score;\n\
    \            max_index = i;\n        }\n        curr_score = 0;\n    }\n    return\
    \ `${class_name}.${extensions[max_index]}`;\n}\n", "    let temp: string;\n  \
    \  let strength: number;\n    let max_strength: number = 0;\n    let max_strength_index:\
    \ number = 0;\n    for (let i = 0; i < extensions.length; i++) {\n        temp\
    \ = extensions[i];\n        strength = 0;\n        for (let j = 0; j < temp.length;\
    \ j++) {\n            if (temp[j] >= 'A' && temp[j] <= 'Z') {\n              \
    \  strength++;\n            }\n            else if (temp[j] >= 'a' && temp[j]\
    \ <= 'z') {\n                strength--;\n            }\n        }\n        if\
    \ (strength > max_strength) {\n            max_strength = strength;\n        \
    \    max_strength_index = i;\n        }\n    }\n    return `${class_name}.${extensions[max_strength_index]}`;\n\
    }\n", "    let myDict: { [k: string]: number } = {};\n    let strongest = 0;\n\
    \    let strongestName = \"\";\n    for (let item of extensions) {\n        let\
    \ uppercase = 0;\n        let lowercase = 0;\n        for (let char of item) {\n\
    \            if (char === char.toUpperCase()) {\n                uppercase++;\n\
    \            } else {\n                lowercase++;\n            }\n        }\n\
    \        let strength = uppercase - lowercase;\n        myDict[item] = strength;\n\
    \        if (strength > strongest) {\n            strongest = strength;\n    \
    \        strongestName = item;\n        }\n    }\n    return class_name + \".\"\
    \ + strongestName;\n}\n", "    let strongest_ext: string;\n    let strongest_strength:\
    \ number = 0;\n    let strength: number;\n    let class_name_ext: string;\n  \
    \  let uppercase_count: number;\n    let lowercase_count: number;\n    let x:\
    \ number;\n    for (let ext of extensions) {\n        uppercase_count = 0;\n \
    \       lowercase_count = 0;\n        for (x = 0; x < ext.length; x++) {\n   \
    \         if (ext[x] >= 'A' && ext[x] <= 'Z')\n                uppercase_count++;\n\
    \            else if (ext[x] >= 'a' && ext[x] <= 'z')\n                lowercase_count++;\n\
    \        }\n        strength = uppercase_count - lowercase_count;\n        if\
    \ (strength > strongest_strength) {\n            strongest_strength = strength;\n\
    \            strongest_ext = ext;\n        }\n    }\n    class_name_ext = class_name\
    \ + \".\" + strongest_ext;\n    return class_name_ext;\n}", "    let strongest:\
    \ string = \"\";\n    let strongestValue: number = 0;\n    extensions.forEach(extension\
    \ => {\n        let cap = extension.replace(/[^A-Z]/g, \"\").length;\n       \
    \ let sm = extension.replace(/[^a-z]/g, \"\").length;\n        let strength =\
    \ cap - sm;\n        if (strength > strongestValue) {\n            strongest =\
    \ extension;\n            strongestValue = strength;\n        }\n    });\n   \
    \ return class_name + \".\" + strongest;\n}\n\n", "    let class_with_extension:\
    \ string = \"\";\n    let strength: number = 0;\n    for (let i = 0; i < extensions.length;\
    \ i++) {\n        let extension_strength: number = (extensions[i].match(/[A-Z]/g)||[]).length\
    \ - (extensions[i].match(/[a-z]/g)||[]).length;\n        if (extension_strength\
    \ >= strength) {\n            strength = extension_strength;\n            class_with_extension\
    \ = class_name + \".\" + extensions[i];\n        }\n    }\n    return class_with_extension;\n\
    }\n", "    let _ext = {};\n    let _max = -1;\n    let _max_name = \"\";\n   \
    \ extensions.forEach(e => {\n        let cap = 0;\n        let sm = 0;\n     \
    \   for (let i = 0; i < e.length; i++) {\n            if (e[i] >= 'A' && e[i]\
    \ <= 'Z') {\n                cap++;\n            } else {\n                sm++;\n\
    \            }\n        }\n        let _strength = cap - sm;\n        if (_strength\
    \ > _max) {\n            _max = _strength;\n            _max_name = e;\n     \
    \   }\n    });\n    return class_name + \".\" + _max_name;\n}\n", "  // your code\
    \ here\n  let strongest = null;\n  let strongest_name = \"\";\n  for (let ext\
    \ of extensions) {\n    let lower = ext.toLowerCase();\n    let upper = ext.toUpperCase();\n\
    \    let up_count = 0;\n    let low_count = 0;\n    for (let i = 0; i < ext.length;\
    \ i++) {\n      if (ext[i] === upper[i]) {\n        up_count++;\n      } else\
    \ {\n        low_count++;\n      }\n    }\n    let difference = up_count - low_count;\n\
    \    if (strongest === null || difference > strongest) {\n      strongest = difference;\n\
    \      strongest_name = ext;\n    }\n  }\n  return class_name + \".\" + strongest_name;\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
