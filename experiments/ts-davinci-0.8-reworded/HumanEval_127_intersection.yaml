name: HumanEval_127_intersection
language: ts
prompt: "//You are given two intervals,\n// where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
  \ which means that the interval (start, end)\n// includes both start and end.\n\
  // For each given interval, it is assumed that its start is less or equal its end.\n\
  // Your task is to determine whether the length of intersection of these two \n\
  // intervals is a prime number.\n// Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n//\
  \ If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
  \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output]\
  \ samples:\n// >>> intersection([1, 2], [2, 3])\n// \"NO\"\n// >>> intersection([-1,\
  \ 1], [0, 4])\n// \"NO\"\n// >>> intersection([-3, -1], [-5, 5])\n// \"YES\"\nfunction\
  \ intersection(interval1: [number, number], interval2: [number, number]): string\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = intersection;\n  assert.deepEqual(candidate([1, 2],\
  \ [2, 3]),\"NO\");\n  assert.deepEqual(candidate([-1, 1], [0, 4]),\"NO\");\n  assert.deepEqual(candidate([-3,\
  \ -1], [-5, 5]),\"YES\");\n  assert.deepEqual(candidate([-2, 2], [-4, 0]),\"YES\"\
  );\n  assert.deepEqual(candidate([-11, 2], [-1, -1]),\"NO\");\n  assert.deepEqual(candidate([1,\
  \ 2], [3, 5]),\"NO\");\n  assert.deepEqual(candidate([1, 2], [1, 2]),\"NO\");\n\
  \  assert.deepEqual(candidate([-2, -2], [-3, -2]),\"NO\");\n}\n\ntest();"
completions: ["  const [min, max] = [Math.max(interval1[0], interval2[0]), Math.min(interval1[1],\
    \ interval2[1])];\n  const length = Math.abs(max - min);\n  const primes = [2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n  if (length < 0) {\n    return \"NO\";\n  }\n  return primes.includes(length)\
    \ ? \"YES\" : \"NO\";\n}\n", "    const [a, b] = interval1;\n    const [c, d]\
    \ = interval2;\n    if (d < a || b < c) return \"NO\";\n    const len = Math.min(b,\
    \ d) - Math.max(a, c) + 1;\n    return isPrime(len) ? \"YES\" : \"NO\";\n}\n",
  "    // it is possible to reduce the solution down to \n    //  return isPrime(Math.abs(interval1[0]\
    \ - interval2[0])) ? \"YES\" : \"NO\";\n    // but it's probably better to make\
    \ sure the numbers are actually intersecting\n    const topLeft = interval1[0]\
    \ > interval2[0] ? interval1[0] : interval2[0];\n    const bottomRight = interval1[1]\
    \ < interval2[1] ? interval1[1] : interval2[1];\n    if (topLeft <= bottomRight)\
    \ {\n        return isPrime(bottomRight - topLeft + 1) ? \"YES\" : \"NO\";\n \
    \   }\n    return \"NO\";\n}\n", "  const start = Math.max(interval1[0], interval2[0]);\n\
    \  const end = Math.min(interval1[1], interval2[1]);\n  if (start > end) {\n \
    \   return \"NO\";\n  }\n  return isPrime(end - start + 1) ? \"YES\" : \"NO\"\
    ;\n}\n", "    let is_prime: boolean = true;\n    const start: number = Math.max(interval1[0],\
    \ interval2[0]);\n    const end: number = Math.min(interval1[1], interval2[1]);\n\
    \    const len: number = end - start;\n    for (let i: number = 2; i < len; i++)\
    \ {\n        if (len % i === 0) {\n            is_prime = false;\n           \
    \ break;\n        }\n    }\n    return is_prime && len > 1 ? \"YES\" : \"NO\"\
    ;\n}\n", "    var [start1, end1] = interval1;\n    var [start2, end2] = interval2;\n\
    \    var start = Math.max(start1, start2);\n    var end = Math.min(end1, end2);\n\
    \    if (start > end) return \"NO\";\n    if (isPrime(end - start + 1)) return\
    \ \"YES\";\n    return \"NO\";\n}", "  let largerStart = 0;\n  let smallerEnd\
    \ = 0;\n  if (interval1[0] > interval2[0]) {\n    largerStart = interval1[0];\n\
    \  } else {\n    largerStart = interval2[0];\n  }\n  if (interval1[1] < interval2[1])\
    \ {\n    smallerEnd = interval1[1];\n  } else {\n    smallerEnd = interval2[1];\n\
    \  }\n  if (largerStart >= smallerEnd) {\n    return \"NO\";\n  }\n  if (isPrime(smallerEnd\
    \ - largerStart + 1)) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n\
    \  }\n}\n", "  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n\
    \  if (start1 <= start2 && start2 <= end1) {\n    return isPrime(end1 - start2\
    \ + 1) ? \"YES\" : \"NO\";\n  }\n  if (start2 <= start1 && start1 <= end2) {\n\
    \    return isPrime(end2 - start1 + 1) ? \"YES\" : \"NO\";\n  }\n  return \"NO\"\
    ;\n}\n", "    let result = \"NO\";\n    if (interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]) return result;\n    let start = interval1[0] > interval2[0]\
    \ ? interval1[0] : interval2[0];\n    let end = interval1[1] < interval2[1] ?\
    \ interval1[1] : interval2[1];\n    for (let i = start; i <= end; i++) {\n   \
    \     for (let j = 2; j < i; j++) {\n            if (i % j === 0) {\n        \
    \        result = \"NO\";\n                break;\n            }\n           \
    \ result = \"YES\";\n        }\n    }\n    return result;\n}", "  const start\
    \ = Math.max(interval1[0], interval2[0]);\n  const end = Math.min(interval1[1],\
    \ interval2[1]);\n  if (start > end) {\n    return \"NO\";\n  }\n  const length\
    \ = end - start + 1;\n  for (let i = 2; i < length; i++) {\n    if (length % i\
    \ === 0) {\n      return \"NO\";\n    }\n  }\n  return \"YES\";\n}\n", "  const\
    \ [minI1, maxI1] = interval1.sort((a, b) => a - b);\n  const [minI2, maxI2] =\
    \ interval2.sort((a, b) => a - b);\n  if (minI1 <= minI2 && maxI1 >= minI2) {\n\
    \    const length = maxI1 <= maxI2 ? maxI1 - minI2 : maxI2 - minI2;\n    if (length\
    \ === 1) return \"NO\";\n    for (let i = 2; i < length; i++) {\n      if (length\
    \ % i === 0) return \"NO\";\n    }\n    return \"YES\";\n  }\n  return \"NO\"\
    ;\n}\n", "    let start: number = Math.max(interval1[0], interval2[0]);\n    let\
    \ end: number = Math.min(interval1[1], interval2[1]);\n    let diff: number =\
    \ end - start;\n    if (diff < 0) {\n        return \"NO\";\n    }\n    else if\
    \ (diff === 0) {\n        return \"YES\";\n    }\n    return isPrime(diff + 1)\
    \ ? \"YES\" : \"NO\";\n}", "    let [min, max] = [Math.max(interval1[0], interval2[0]),\
    \ Math.min(interval1[1], interval2[1])];\n    if (min > max) return \"NO\";\n\
    \    if (min == max) return \"YES\";\n    if (min + 1 == max) return \"YES\";\n\
    \    if (isPrime(max - min - 1)) return \"YES\";\n    return \"NO\";\n}\n", " \
    \   // get the lowest start number\n    let start = Math.max(interval1[0], interval2[0]);\n\
    \    // get the highest end number\n    let end = Math.min(interval1[1], interval2[1]);\n\
    \    // if the two intervals don't intersect return \"NO\"\n    if (start > end)\
    \ {\n        return \"NO\";\n    }\n    // if the length of the intersection is\
    \ a prime number, return \"YES\", otherwise, return \"NO\".\n    return isPrime(end\
    \ - start + 1) ? \"YES\" : \"NO\";\n}", "    if(interval1[0] >= interval2[1] ||\
    \ interval2[0] >= interval1[1]) return \"NO\";\n    let lower: number = Math.max(interval1[0],\
    \ interval2[0]);\n    let upper: number = Math.min(interval1[1], interval2[1]);\n\
    \    let dist: number = upper - lower;\n    return isPrime(dist) ? \"YES\" : \"\
    NO\";\n}", "    let result: number[] = [interval1[0], interval1[1], interval2[0],\
    \ interval2[1]].sort((a, b) => a - b);\n    let start: number = result[1];\n \
    \   let end: number = result[2];\n    if (start > end) return \"NO\";\n    return\
    \ isPrime(end - start + 1) ? \"YES\" : \"NO\";\n}\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));\n", "    let small = interval1[0] > interval2[0] ? interval1[0]\
    \ : interval2[0];\n    let big = interval1[1] < interval2[1] ? interval1[1] :\
    \ interval2[1];\n    if (small > big) {\n        return \"NO\";\n    }\n    if\
    \ (small < 2) {\n        return \"NO\";\n    }\n    let len = big - small + 1;\n\
    \    let isPrime = true;\n    for (let i = 2; i < len; i++) {\n        if (len\
    \ % i === 0) {\n            isPrime = false;\n            break;\n        }\n\
    \    }\n    return isPrime ? \"YES\" : \"NO\";\n}\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));", "  let isPrime = (a: number) => {\n    if (a === 1) return\
    \ false;\n    for (let i = 2; i < a; i++) {\n      if (a % i === 0) return false;\n\
    \    }\n    return true;\n  }\n  let a = Math.max(interval1[0], interval2[0]);\n\
    \  let b = Math.min(interval1[1], interval2[1]);\n  if (a > b) return \"NO\";\n\
    \  return isPrime(b - a + 1) ? \"YES\" : \"NO\";\n}\n", "    const start = Math.max(interval1[0],\
    \ interval2[0]);\n    const end = Math.min(interval1[1], interval2[1]);\n    const\
    \ interval = [start, end];\n    const length = interval[1] - interval[0];\n  \
    \  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    const index = primes.indexOf(length);\n\
    \    return (length < 0 || index === -1) ? \"NO\" : \"YES\";\n}\n", "    const\
    \ from: number = Math.max(interval1[0], interval2[0]);\n    const to: number =\
    \ Math.min(interval1[1], interval2[1]);\n    const diff: number = to - from;\n\
    \    if (diff < 0) {\n        return \"NO\";\n    }\n    return (isPrime(diff))\
    \ ? \"YES\" : \"NO\";\n}\n", "    const from = Math.max(interval1[0], interval2[0]);\n\
    \    const to = Math.min(interval1[1], interval2[1]);\n    if (from > to) return\
    \ \"NO\";\n    const length = to - from + 1;\n    return isPrime(length) ? \"\
    YES\" : \"NO\";\n}\n", "    let start = Math.max(interval1[0], interval2[0]);\n\
    \    let end = Math.min(interval1[1], interval2[1]);\n    let length = end - start;\n\
    \    if (length < 0) {\n        return \"NO\";\n    }\n    if (length === 0) {\n\
    \        return \"YES\";\n    }\n    if (length === 1) {\n        return \"NO\"\
    ;\n    }\n    for (let i = 2; i < length; i++) {\n        if (length % i === 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}", " \
    \   let [start, end] = interval1;\n    let [start2, end2] = interval2;\n    if\
    \ (start2 < start) {\n        [start, end] = [start2, end2];\n        [start2,\
    \ end2] = [start, end];\n    }\n    if (start2 > end) {\n        return \"NO\"\
    ;\n    }\n    let max1 = Math.max(start, start2);\n    let min2 = Math.min(end,\
    \ end2);\n    let length = min2 - max1 + 1;\n    if (length == 1) {\n        return\
    \ \"NO\";\n    }\n    for (let i = 2; i < length; i++) {\n        if (length %\
    \ i == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\n", "    let start1 = interval1[0];\n    let end1 = interval1[1];\n    let\
    \ start2 = interval2[0];\n    let end2 = interval2[1];\n    let minStart = Math.max(start1,\
    \ start2);\n    let maxEnd = Math.min(end1, end2);\n    if (minStart > maxEnd)\
    \ {\n        return \"NO\";\n    }\n    let length = maxEnd - minStart + 1;\n\
    \    if (length === 1) {\n        return \"NO\";\n    }\n    for (let i = 2; i\
    \ < length; i++) {\n        if (length % i === 0) {\n            return \"NO\"\
    ;\n        }\n    }\n    return \"YES\";\n}\n\nconsole.log(intersection([1, 2],\
    \ [2, 3]));\nconsole.log(intersection([-1, 1], [0, 4]));\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));", "    let start = Math.max(interval1[0], interval2[0]);\n \
    \   let end = Math.min(interval1[1], interval2[1]);\n    let length = end - start;\n\
    \    let flag = true;\n    if (length < 2) {\n        return \"NO\";\n    }\n\
    \    for (let i = 2; i < length; i++) {\n        if (length % i === 0) {\n   \
    \         flag = false;\n            break;\n        }\n    }\n    return flag\
    \ ? \"YES\" : \"NO\";\n}\n\nexport { intersection };", "  if (interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]) {\n    return \"NO\";\n  }\n  const [start,\
    \ end] = [Math.max(interval1[0], interval2[0]), Math.min(interval1[1], interval2[1])];\n\
    \  if (start === end) {\n    return \"NO\";\n  }\n  for (let i = 2; i < start;\
    \ i++) {\n    if (start % i === 0 && end % i === 0) {\n      return \"NO\";\n\
    \    }\n  }\n  return \"YES\";\n}\n\nconsole.log(intersection([1, 2], [2, 3]));\n\
    console.log(intersection([-1, 1], [0, 4]));\nconsole.log(intersection([-3, -1],\
    \ [-5, 5]));", "  let start = Math.max(interval1[0], interval2[0]);\n  let end\
    \ = Math.min(interval1[1], interval2[1]);\n  let length = end - start;\n  if (length\
    \ < 0) {\n    return \"NO\";\n  }\n  return isPrime(length) ? \"YES\" : \"NO\"\
    ;\n}\n", "    let max = Math.max(interval1[0], interval2[0]);\n    let min = Math.min(interval1[1],\
    \ interval2[1]);\n    if (max > min) {\n        return \"NO\";\n    }\n    let\
    \ interval = min - max;\n    let primeNumbers = [2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    if (primeNumbers.includes(interval))\
    \ {\n        return \"YES\";\n    }\n    return \"NO\";\n}", "  // check that\
    \ intervals intersect\n  if (interval1[1] < interval2[0] || interval2[1] < interval1[0])\
    \ return \"NO\";\n  // find overlapping interval\n  const start = Math.max(interval1[0],\
    \ interval2[0]);\n  const end = Math.min(interval1[1], interval2[1]);\n  // iterate\
    \ through interval looking for prime number\n  for (let i = start; i <= end; i++)\
    \ {\n    if (isPrime(i)) return \"YES\";\n  }\n  return \"NO\";\n}", "    const\
    \ intersectionLength = Math.min(interval1[1], interval2[1]) - Math.max(interval1[0],\
    \ interval2[0]);\n    if (intersectionLength <= 0) return \"NO\";\n    if (isPrime(intersectionLength))\
    \ return \"YES\";\n    return \"NO\";\n}\n", "    if(interval1[0] < interval2[0])\
    \ {\n        const temp: [number, number] = interval1;\n        interval1 = interval2;\n\
    \        interval2 = temp;\n    }\n    if(interval1[0] > interval2[1]) return\
    \ \"NO\";\n    const start: number = interval1[0];\n    const end: number = Math.min(interval1[1],\
    \ interval2[1]);\n    return isPrime((end - start) + 1) ? \"YES\" : \"NO\";\n\
    }\n", "    let max = interval1[0] > interval2[0] ? interval1[0] : interval2[0];\n\
    \    let min = interval1[1] < interval2[1] ? interval1[1] : interval2[1];\n  \
    \  let newInterval = [max, min];\n    if (newInterval[0] > newInterval[1]) return\
    \ \"NO\";\n    if (newInterval[0] === newInterval[1]) return (newInterval[0] ===\
    \ 1 || newInterval[0] === 2) ? \"YES\" : \"NO\";\n    let flag = true;\n    for\
    \ (let i = 2; i < newInterval[1]; i++) {\n        if (newInterval[0] % i === 0\
    \ && newInterval[1] % i === 0) {\n            flag = false;\n            break;\n\
    \        }\n    }\n    return flag ? \"YES\" : \"NO\";\n}\n", "    const [start,\
    \ end] = [(interval1[0] > interval2[0]) ? interval1[0] : interval2[0], (interval1[1]\
    \ < interval2[1]) ? interval1[1] : interval2[1]];\n    if (start < end) {\n  \
    \      if (start <= 2 && end >= 2) {\n            return \"YES\";\n        }\n\
    \        for (let i = 3; i <= end; i += 2) {\n            if (start <= i && end\
    \ >= i) {\n                for (let j = 3; j < i; j += 2) {\n                \
    \    if (i % j === 0) {\n                        return \"NO\";\n            \
    \        }\n                }\n                return \"YES\";\n            }\n\
    \        }\n    }\n    return \"NO\";\n}\n\nconsole.log(intersection([1, 2], [2,\
    \ 3]));\nconsole.log(intersection([-1, 1], [0, 4]));\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));\n", "    let min = Math.max(interval1[0], interval2[0]);\n \
    \   let max = Math.min(interval1[1], interval2[1]);\n    if (min > max) return\
    \ \"NO\";\n    else return isPrime(max - min + 1) ? \"YES\" : \"NO\";\n}\n", " \
    \   if (interval1[0] > interval2[1] || interval2[0] > interval1[1]) {\n      \
    \  return \"NO\";\n    }\n    let min = Math.max(interval1[0], interval2[0]);\n\
    \    let max = Math.min(interval1[1], interval2[1]);\n    let result = max - min\
    \ + 1;\n    let sqrt = Math.floor(Math.sqrt(result));\n    for (let i = 2; i <=\
    \ sqrt; i++) {\n        if (result % i === 0) {\n            return \"NO\";\n\
    \        }\n    }\n    return \"YES\";\n}\n", "    let [x1, y1] = interval1;\n\
    \    let [x2, y2] = interval2;\n    if (x1 > y1) {\n        [x1, y1] = [y1, x1];\n\
    \    }\n    if (x2 > y2) {\n        [x2, y2] = [y2, x2];\n    }\n    if (y1 <\
    \ x2 || y2 < x1) {\n        return \"NO\";\n    }\n    if (x1 <= x2 && y1 <= y2)\
    \ {\n        return isPrime(y1 - x2 + 1) ? \"YES\" : \"NO\";\n    }\n    if (x1\
    \ <= x2 && y1 >= y2) {\n        return isPrime(y2 - x2 + 1) ? \"YES\" : \"NO\"\
    ;\n    }\n    if (x1 >= x2 && y1 <= y2) {\n        return isPrime(y1 - x1 + 1)\
    \ ? \"YES\" : \"NO\";\n    }\n    if (x1 >= x2 && y1 >= y2) {\n        return\
    \ isPrime(y2 - x1 + 1) ? \"YES\" : \"NO\";\n    }\n}", "    let start = Math.max(interval1[0],\
    \ interval2[0]);\n    let end = Math.min(interval1[1], interval2[1]);\n    if\
    \ (start <= end) {\n        if (start === end) return \"YES\";\n        let min\
    \ = Math.min(start, end);\n        let max = Math.max(start, end);\n        for\
    \ (let i = 2; i <= max; i++) {\n            if (max % i === 0 && min % i === 0)\
    \ return \"NO\";\n        }\n        return \"YES\";\n    }\n    return \"NO\"\
    ;\n}\n", "    let m = interval1[0];\n    let n = interval1[1];\n    let o = interval2[0];\n\
    \    let p = interval2[1];\n    let q = Math.max(m, o);\n    let r = Math.min(n,\
    \ p);\n    if (q > r) {\n        return \"NO\";\n    }\n    let isPrime = true;\n\
    \    for (let i = 2; i < r - q + 1; i++) {\n        if ((r - q + 1) % i === 0)\
    \ {\n            isPrime = false;\n            break;\n        }\n    }\n    return\
    \ isPrime ? \"YES\" : \"NO\";\n}\n", "  let [start1, end1] = interval1;\n  let\
    \ [start2, end2] = interval2;\n  let result = \"NO\";\n  if (start1 <= start2\
    \ && start2 <= end1) {\n    if (start2 <= end2 && end2 <= end1) {\n      if (isPrime(end2\
    \ - start2 + 1)) {\n        result = \"YES\";\n      }\n    } else {\n      if\
    \ (isPrime(end1 - start2 + 1)) {\n        result = \"YES\";\n      }\n    }\n\
    \  } else if (start2 <= start1 && start1 <= end2) {\n    if (start1 <= end1 &&\
    \ end1 <= end2) {\n      if (isPrime(end1 - start1 + 1)) {\n        result = \"\
    YES\";\n      }\n    } else {\n      if (isPrime(end2 - start1 + 1)) {\n     \
    \   result = \"YES\";\n      }\n    }\n  }\n  return result;\n}\n", "    let max\
    \ = Math.max(interval1[0], interval2[0])\n    let min = Math.min(interval1[1],\
    \ interval2[1])\n    let length = min - max;\n    if (length < 0) {\n        return\
    \ \"NO\"\n    }\n    else {\n        for (let i = 2; i < length; i++) {\n    \
    \        if (length % i == 0) {\n                return \"NO\"\n            }\n\
    \        }\n        return \"YES\"\n    }\n}\n\n", "    const start = Math.max(interval1[0],\
    \ interval2[0]);\n    const end = Math.min(interval1[1], interval2[1]);\n    if\
    \ (start >= end) {\n        return \"NO\";\n    }\n    const length = end - start;\n\
    \    if (length == 1) {\n        return \"NO\";\n    }\n    for (let i = 2; i\
    \ < length; i++) {\n        if (length % i == 0) {\n            return \"NO\"\
    ;\n        }\n    }\n    return \"YES\";\n}\n", "    let start = Math.max(interval1[0],\
    \ interval2[0]);\n    let end = Math.min(interval1[1], interval2[1]);\n    if\
    \ (start > end) {\n        return \"NO\";\n    }\n    let length = end - start\
    \ + 1;\n    if (length < 2) {\n        return \"NO\";\n    }\n    for (let i =\
    \ 2; i < length; i++) {\n        if (length % i === 0) {\n            return \"\
    NO\";\n        }\n    }\n    return \"YES\";\n}\nconsole.log(intersection([1,\
    \ 2], [2, 3]));\nconsole.log(intersection([-1, 1], [0, 4]));\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));", "    const intersectionStart = Math.max(interval1[0], interval2[0]);\n\
    \    const intersectionEnd = Math.min(interval1[1], interval2[1]);\n    const\
    \ intersectionLength = intersectionEnd - intersectionStart;\n    if (intersectionLength\
    \ < 0) {\n        return \"NO\";\n    }\n    return isPrime(intersectionLength)\
    \ ? \"YES\" : \"NO\";\n}\n", "  const start = Math.max(interval1[0], interval2[0]);\n\
    \  const end = Math.min(interval1[1], interval2[1]);\n  if (start > end) {\n \
    \   return \"NO\";\n  }\n  const length = end - start + 1;\n  return isPrime(length)\
    \ ? \"YES\" : \"NO\";\n}\n", "    const min = Math.max(interval1[0], interval2[0]);\n\
    \    const max = Math.min(interval1[1], interval2[1]);\n    const x = max - min;\n\
    \    if (x <= 0) {\n        return \"NO\";\n    }\n    if (isPrime(x)) {\n   \
    \     return \"YES\";\n    }\n    return \"NO\";\n}\n", "    let isIntersected\
    \ = false;\n    let a = Math.max(interval1[0], interval2[0]);\n    let b = Math.min(interval1[1],\
    \ interval2[1]);\n    if (a <= b) {\n        if (isPrime(b - a + 1)) {\n     \
    \       return \"YES\";\n        }\n    }\n    return \"NO\";\n}\n", "  const\
    \ x = (interval1[0] < interval2[0]) ? interval2[0] : interval1[0];\n  const y\
    \ = (interval1[1] < interval2[1]) ? interval1[1] : interval2[1];\n  return x >\
    \ y ? \"NO\" : isPrime(y - x) ? \"YES\" : \"NO\";\n}\n", "  const [start1, end1]\
    \ = interval1;\n  const [start2, end2] = interval2;\n  const [start, end] = [Math.max(start1,\
    \ start2), Math.min(end1, end2)];\n  if (start > end) {\n    return \"NO\";\n\
    \  }\n  if (isPrime(end - start + 1)) {\n    return \"YES\";\n  }\n  return \"\
    NO\";\n}", "  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n\
    \  const start = Math.max(start1, start2);\n  const end = Math.min(end1, end2);\n\
    \  const diff = end - start;\n  if (diff < 0) {\n    return \"NO\";\n  }\n  return\
    \ isPrime(diff) ? \"YES\" : \"NO\";\n}\n", "  let start = Math.max(interval1[0],\
    \ interval2[0]);\n  let end = Math.min(interval1[1], interval2[1]);\n  let result\
    \ = end - start + 1;\n  return isPrime(result) ? \"YES\" : \"NO\";\n}\n", "  \
    \  const start = Math.max(interval1[0], interval2[0]);\n    const end = Math.min(interval1[1],\
    \ interval2[1]);\n    if (start > end) return \"NO\";\n    const length = end\
    \ - start + 1;\n    if (length === 1) return \"NO\";\n    for (let i = 2; i <=\
    \ Math.sqrt(length); i++) {\n        if (length % i === 0) return \"NO\";\n  \
    \  }\n    return \"YES\";\n}\n\nexport function main() {\n    const inputs = [\n\
    \        [[1, 2], [2, 3]],\n        [[-1, 1], [0, 4]],\n        [[-3, -1], [-5,\
    \ 5]],\n        [[-7, -1], [-5, 5]],\n        [[-2, 0], [5, 10]],\n        [[1,\
    \ 2], [1, 2]],\n        [[1, 2], [2, 4]],\n        [[2, 3], [4, 5]],\n       \
    \ [[2, 3], [6, 7]],\n        [[3, 4], [5, 6]],\n        [[3, 4], [7, 8]],\n  \
    \      [[10, 15], [17, 20]],\n        [[1, 10], [2, 3]],\n        [[1, 10], [1,\
    \ 10]],\n        [[1, 10], [1, 5]],\n        [[2, 3], [1, 10]],\n        [[2,\
    \ 4], [3, 5]],\n        [[3, 4], [2, 5]],\n        [[5, 10], [1, 15]],\n     \
    \   [[5, 10], [5, 15]],\n        [[5, 10], [7, 15]],\n        [[7, 15], [5, 10]],\n\
    \        [[1, 15], [5, 10]],\n        [[5, 15], [1, 10]],\n        [[5, 15], [5,\
    \ 10]],\n        [[1, 15], [5, 15]],\n        [[5, 15], [1, 15]],\n        [[1,\
    \ 15], [1, 15]],\n        [[1, 15], [", "  const [start1, end1] = interval1;\n\
    \  const [start2, end2] = interval2;\n  if (start1 > end2 || start2 > end1) {\n\
    \    return \"NO\";\n  }\n  let isPrime: boolean = true;\n  for (let i = 2; i\
    \ < Math.abs(end1 - start2) - 1; i++) {\n    if (Math.abs(end1 - start2) % i ===\
    \ 0) {\n      isPrime = false;\n      break;\n    }\n  }\n  return isPrime ? \"\
    YES\" : \"NO\";\n}\n", "  let start = Math.max(interval1[0], interval2[0]);\n\
    \  let end = Math.min(interval1[1], interval2[1]);\n  if (start > end) {\n   \
    \ return \"NO\";\n  }\n  let length = end - start + 1;\n  return isPrime(length)\
    \ ? \"YES\" : \"NO\";\n}\n", "  const [interval1A, interval1B] = interval1;\n\
    \  const [interval2A, interval2B] = interval2;\n  const max = Math.max(interval1A,\
    \ interval2A);\n  const min = Math.min(interval1B, interval2B);\n  const res =\
    \ min - max;\n  if (res < 0) {\n    return \"NO\";\n  }\n  return isPrime(res)\
    \ ? \"YES\" : \"NO\";\n}\n\nconsole.log(intersection([1, 2], [2, 3]));\nconsole.log(intersection([-1,\
    \ 1], [0, 4]));\nconsole.log(intersection([-3, -1], [-5, 5]));", "    const start\
    \ = Math.max(interval1[0], interval2[0]);\n    const end = Math.min(interval1[1],\
    \ interval2[1]);\n    const isPrime = (n: number) => {\n        if (n <= 1) return\
    \ false;\n        for (let i = 2; i <= Math.sqrt(n); i++) {\n            if (n\
    \ % i === 0) return false;\n        }\n        return true;\n    }\n    if (start\
    \ <= end) {\n        return isPrime(end - start + 1) ? \"YES\" : \"NO\";\n   \
    \ } else {\n        return \"NO\";\n    }\n}\nconsole.log(intersection([1, 2],\
    \ [2, 3]));\nconsole.log(intersection([-1, 1], [0, 4]));\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));\n", "    // write your code here\n    let start = Math.max(interval1[0],\
    \ interval2[0]);\n    let end = Math.min(interval1[1], interval2[1]);\n    if\
    \ (start >= end) {\n        return \"NO\";\n    }\n    let length = end - start;\n\
    \    return length === 1 || length === 2 || length === 3 || length === 5 || length\
    \ === 7 || length === 11 || length === 13 || length === 17 || length === 19 ?\
    \ \"YES\" : \"NO\";\n}\n", "    const [s1, e1] = interval1;\n    const [s2, e2]\
    \ = interval2;\n    let ss = 0;\n    let ee = 0;\n    if (s1 < s2) {\n       \
    \ ss = s2;\n    } else {\n        ss = s1;\n    }\n    if (e1 < e2) {\n      \
    \  ee = e1;\n    } else {\n        ee = e2;\n    }\n    if (ss > ee) {\n     \
    \   return \"NO\";\n    }\n    const len = ee - ss + 1;\n    let isPrime = true;\n\
    \    for (let i = 2; i <= Math.sqrt(len); i++) {\n        if (len % i === 0) {\n\
    \            isPrime = false;\n            break;\n        }\n    }\n    if (isPrime)\
    \ {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n",
  "  if (interval1[0] > interval2[1] || interval2[0] > interval1[1]) {\n    return\
    \ \"NO\";\n  }\n  const min = Math.max(interval1[0], interval2[0]);\n  const max\
    \ = Math.min(interval1[1], interval2[1]);\n  const interval = [min, max];\n  if\
    \ (interval[0] === interval[1]) {\n    return \"NO\";\n  }\n  if (isPrime(interval[1]\
    \ - interval[0])) {\n    return \"YES\";\n  }\n  return \"NO\";\n}\n", "    let\
    \ maxStart = Math.max(interval1[0], interval2[0]);\n    let minEnd = Math.min(interval1[1],\
    \ interval2[1]);\n    let intersectionLength = Math.abs(maxStart - minEnd) + 1;\n\
    \    if(intersectionLength <= 1) return \"NO\";\n    return isPrime(intersectionLength)\
    \ ? \"YES\" : \"NO\";\n}\n", "    let intersection = [];\n    let [left1, right1]\
    \ = interval1;\n    let [left2, right2] = interval2;\n    let counter = 0;\n \
    \   let answer = \"NO\";\n    let prime = 2;\n    while (prime <= 7) {\n     \
    \   counter = 0;\n        for (let i = left1; i <= right1; i++) {\n          \
    \  if (left2 <= i && i <= right2) {\n                counter++;\n            }\n\
    \        }\n        if (counter === prime) {\n            answer = \"YES\";\n\
    \        }\n        prime++;\n    }\n    return answer;\n}\n", "    let smaller1\
    \ = interval1[0] <= interval1[1] ? interval1[0] : interval1[1];\n    let larger1\
    \ = interval1[0] >= interval1[1] ? interval1[0] : interval1[1];\n    let smaller2\
    \ = interval2[0] <= interval2[1] ? interval2[0] : interval2[1];\n    let larger2\
    \ = interval2[0] >= interval2[1] ? interval2[0] : interval2[1];\n    let intersection;\n\
    \    if (smaller1 >= smaller2 && smaller1 <= larger2) {\n        intersection\
    \ = smaller1;\n    } else if (smaller2 >= smaller1 && smaller2 <= larger1) {\n\
    \        intersection = smaller2;\n    } else {\n        return \"NO\";\n    }\n\
    \    if (larger1 <= larger2) {\n        if (larger1 > intersection) {\n      \
    \      larger1 = larger1;\n        } else {\n            return \"NO\";\n    \
    \    }\n    } else {\n        if (larger2 > intersection) {\n            larger1\
    \ = larger2;\n        } else {\n            return \"NO\";\n        }\n    }\n\
    \    return isPrime(larger1 - intersection) ? \"YES\" : \"NO\";\n}", "  let answer\
    \ = true;\n  let low = interval1[0] > interval2[0] ? interval1[0] : interval2[0];\n\
    \  let high = interval1[1] < interval2[1] ? interval1[1] : interval2[1];\n  if\
    \ (low > high) {\n    answer = false;\n  } else {\n    for (let i = 2; i < (high\
    \ - low); i++) {\n      if ((high - low) % i === 0) {\n        answer = false;\n\
    \        break;\n      }\n    }\n  }\n  return answer ? \"YES\" : \"NO\";\n}\n",
  "  const start = Math.max(interval1[0], interval2[0]);\n  const end = Math.min(interval1[1],\
    \ interval2[1]);\n  const isPrime = (num: number) => {\n    for (let i = 2; i\
    \ < num; i++) {\n      if (num % i === 0) {\n        return false;\n      }\n\
    \    }\n    return num > 1;\n  };\n  return end - start > 0 && isPrime(end - start)\
    \ ? \"YES\" : \"NO\";\n}\n", "  const start = Math.max(interval1[0], interval2[0]);\n\
    \  const end = Math.min(interval1[1], interval2[1]);\n  if (start >= end) {\n\
    \    return \"NO\";\n  }\n  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n  const len =\
    \ end - start;\n  return primes.includes(len) ? \"YES\" : \"NO\";\n}\n\nconsole.log(intersection([1,\
    \ 2], [2, 3]));\nconsole.log(intersection([-1, 1], [0, 4]));\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));\n", "    const first = interval1[0];\n    const second = interval1[1];\n\
    \    const third = interval2[0];\n    const fourth = interval2[1];\n    if (first\
    \ <= third && second <= third) {\n        return \"NO\";\n    }\n    if (third\
    \ <= first && fourth <= first) {\n        return \"NO\";\n    }\n    let result\
    \ = \"\";\n    let counter = 0;\n    let max = Math.max(first, third);\n    let\
    \ min = Math.min(second, fourth);\n    for (let i = max; i <= min; i++) {\n  \
    \      counter++;\n    }\n    for (let i = 1; i <= counter; i++) {\n        if\
    \ (counter % i === 0) {\n            result += i + \" \";\n        }\n    }\n\
    \    if (result.length > 2) {\n        return \"NO\";\n    }\n    return \"YES\"\
    ;\n}", "  let start = interval1[0] > interval2[0] ? interval1[0] : interval2[0];\n\
    \  let end = interval1[1] < interval2[1] ? interval1[1] : interval2[1];\n  let\
    \ length = end - start;\n  let isPrime = false;\n  if (length < 2) return \"NO\"\
    ;\n  for (let i = 2; i < length; i++) {\n    if (length % i === 0) {\n      isPrime\
    \ = true;\n      break;\n    }\n  }\n  return isPrime ? \"NO\" : \"YES\";\n}\n",
  "    const start1 = interval1[0];\n    const end1 = interval1[1];\n    const start2\
    \ = interval2[0];\n    const end2 = interval2[1];\n    const start = Math.max(start1,\
    \ start2);\n    const end = Math.min(end1, end2);\n    if (start > end) {\n  \
    \      return \"NO\";\n    }\n    const length = end - start + 1;\n    const primes\
    \ = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,\
    \ 73, 79, 83, 89, 97];\n    if (primes.includes(length)) {\n        return \"\
    YES\";\n    }\n    return \"NO\";\n}\n", "  // Intervals don't intersect\n  if(interval1[1]\
    \ < interval2[0] || interval2[1] < interval1[0]) {\n    return \"NO\";\n  }\n\
    \  const start: number = Math.max(interval1[0], interval2[0]);\n  const end: number\
    \ = Math.min(interval1[1], interval2[1]);\n  const length: number = end - start\
    \ + 1;\n  return (isPrime(length)) ? \"YES\" : \"NO\";\n}\n", "    // Intervals\
    \ don't intersect\n    if (interval1[1] < interval2[0] || interval2[1] < interval1[0])\
    \ {\n        return \"NO\";\n    }\n\n    let interval1Start = interval1[0];\n\
    \    let interval1End = interval1[1];\n    let interval2Start = interval2[0];\n\
    \    let interval2End = interval2[1];\n\n    // Swap intervals\n    if (interval1[0]\
    \ > interval2[0]) {\n        interval1Start = interval2[0];\n        interval1End\
    \ = interval2[1];\n        interval2Start = interval1[0];\n        interval2End\
    \ = interval1[1];\n    }\n\n    let start: number;\n    let end: number;\n\n \
    \   if (interval1End > interval2Start) {\n        start = interval2Start;\n  \
    \      end = interval1End;\n    } else {\n        start = interval1End;\n    \
    \    end = interval2Start;\n    }\n\n    // start > end if the intervals don't\
    \ intersect\n    if (start > end) {\n        return \"NO\";\n    }\n\n    const\
    \ length = end - start + 1;\n\n    return isPrime(length) ? \"YES\" : \"NO\";\n\
    }\n", "    let start: number = 0;\n    let end: number = 0;\n    let length: number\
    \ = 0;\n    if (interval1[0] <= interval2[0] && interval1[1] >= interval2[0])\
    \ {\n        start = interval2[0];\n        if (interval1[1] <= interval2[1])\
    \ {\n            end = interval1[1];\n        } else {\n            end = interval2[1];\n\
    \        }\n    } else if (interval2[0] <= interval1[0] && interval2[1] >= interval1[0])\
    \ {\n        start = interval1[0];\n        if (interval2[1] <= interval1[1])\
    \ {\n            end = interval2[1];\n        } else {\n            end = interval1[1];\n\
    \        }\n    } else {\n        return \"NO\";\n    }\n    length = end - start;\n\
    \    if (length === 1) {\n        return \"NO\";\n    }\n    if (length === 2)\
    \ {\n        return \"YES\";\n    }\n    let i: number = 2;\n    while (i < length)\
    \ {\n        if (length % i === 0) {\n            return \"NO\";\n        }\n\
    \        i++;\n    }\n    return \"YES\";\n}\n", "    let newInterval = [-1, -1];\n\
    \    if (interval1[0] >= interval2[0] && interval1[0] <= interval2[1]) {\n   \
    \     newInterval[0] = interval1[0];\n    } else if (interval2[0] >= interval1[0]\
    \ && interval2[0] <= interval1[1]) {\n        newInterval[0] = interval2[0];\n\
    \    }\n    if (interval1[1] >= interval2[0] && interval1[1] <= interval2[1])\
    \ {\n        newInterval[1] = interval1[1];\n    } else if (interval2[1] >= interval1[0]\
    \ && interval2[1] <= interval1[1]) {\n        newInterval[1] = interval2[1];\n\
    \    }\n    if (newInterval[0] === -1 && newInterval[1] === -1) {\n        return\
    \ \"NO\";\n    }\n    let intervalLength = newInterval[1] - newInterval[0] + 1;\n\
    \    if (intervalLength === 1) {\n        return \"NO\";\n    }\n    if (intervalLength\
    \ === 2) {\n        return \"YES\";\n    }\n    let sqrt = Math.floor(Math.sqrt(intervalLength));\n\
    \    for (let i = 2; i <= sqrt; i++) {\n        if (intervalLength % i === 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));\nconsole.log(intersection([1, 2], [2, 3]));\nconsole.log(intersection([-1,\
    \ 1], [0, 4]));\n", "  const intersection: [number, number] = [\n    Math.max(interval1[0],\
    \ interval2[0]),\n    Math.min(interval1[1], interval2[1])\n  ];\n  const length\
    \ = intersection[1] - intersection[0];\n  if (length < 0) {\n    return \"NO\"\
    ;\n  }\n  for (let i = 2; i < length; i++) {\n    if (length % i === 0) {\n  \
    \    return \"NO\";\n    }\n  }\n  return \"YES\";\n}\n", "  const [start1, end1]\
    \ = interval1;\n  const [start2, end2] = interval2;\n  if (end1 < start2 || end2\
    \ < start1) {\n    return \"NO\";\n  }\n  let prime = true;\n  let start = start1\
    \ > start2 ? start1 : start2;\n  let end = end1 < end2 ? end1 : end2;\n  let num\
    \ = start;\n  while (num < end) {\n    if (num === 1) {\n      num++;\n      continue;\n\
    \    }\n    for (let i = 2; i < num; i++) {\n      if (num % i === 0) {\n    \
    \    prime = false;\n        break;\n      }\n    }\n    if (!prime) {\n     \
    \ break;\n    }\n    num++;\n  }\n  return prime ? \"YES\" : \"NO\";\n}\n", " \
    \   const [start1, end1] = interval1\n    const [start2, end2] = interval2\n \
    \   const intersection: [number, number] = [Math.max(start1, start2), Math.min(end1,\
    \ end2)]\n    const [interStart, interEnd] = intersection\n    if (interStart\
    \ > interEnd) return \"NO\"\n    const isPrime = (number: number): boolean =>\
    \ {\n        for (let i = 2; i < number; i++) {\n            if (number % i ===\
    \ 0) return false\n        }\n        return number > 1\n    }\n    return isPrime(interEnd\
    \ - interStart + 1) ? \"YES\" : \"NO\"\n}\n", "    const int1: [number, number]\
    \ = interval1[0] < interval1[1] ? interval1 : [interval1[1], interval1[0]];\n\
    \    const int2: [number, number] = interval2[0] < interval2[1] ? interval2 :\
    \ [interval2[1], interval2[0]];\n    const start: number = Math.max(int1[0], int2[0]);\n\
    \    const end: number = Math.min(int1[1], int2[1]);\n    if (start >= end) {\n\
    \        return \"NO\";\n    }\n    if (start == 1) {\n        return \"YES\"\
    ;\n    }\n    for (let i: number = 2; i < start; i++) {\n        if (start % i\
    \ == 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n\
    }\n", "  let i1 = interval1[0];\n  let e1 = interval1[1];\n  let i2 = interval2[0];\n\
    \  let e2 = interval2[1];\n  if (i1 > e1) {\n    let temp = i1;\n    i1 = e1;\n\
    \    e1 = temp;\n  }\n  if (i2 > e2) {\n    let temp = i2;\n    i2 = e2;\n   \
    \ e2 = temp;\n  }\n  if (i1 > e2 || i2 > e1) {\n    return \"NO\";\n  }\n  let\
    \ r1 = Math.max(i1, i2);\n  let r2 = Math.min(e1, e2);\n  return isPrime(r2 -\
    \ r1 + 1) ? \"YES\" : \"NO\";\n}", "  const isPrime = (num: number): boolean =>\
    \ {\n    for (let i = 2; i < num; i++) {\n      if (num % i === 0) {\n       \
    \ return false;\n      }\n    }\n    return num > 1;\n  };\n\n  const start1 =\
    \ interval1[0];\n  const end1 = interval1[1];\n  const start2 = interval2[0];\n\
    \  const end2 = interval2[1];\n\n  const start = Math.max(start1, start2);\n \
    \ const end = Math.min(end1, end2);\n\n  if (start > end) {\n    return \"NO\"\
    ;\n  }\n\n  const diff = end - start;\n\n  return isPrime(diff) ? \"YES\" : \"\
    NO\";\n}\n\nexport { intersection };", "  const commonPart: [number, number] =\
    \ [\n    Math.max(interval1[0], interval2[0]),\n    Math.min(interval1[1], interval2[1])\n\
    \  ];\n  if (commonPart[0] > commonPart[1]) {\n    return \"NO\";\n  }\n  const\
    \ length: number = commonPart[1] - commonPart[0] + 1;\n  for (let i: number =\
    \ 2; i < length; i++) {\n    if (length % i === 0) {\n      return \"NO\";\n \
    \   }\n  }\n  return \"YES\";\n}", "    const a = Math.max(interval1[0], interval2[0]);\n\
    \    const b = Math.min(interval1[1], interval2[1]);\n    if (a > b) {\n     \
    \   return \"NO\";\n    }\n    if (isPrime(a - b)) {\n        return \"YES\";\n\
    \    }\n    return \"NO\";\n}\n", "    let interval = [Math.max(interval1[0],\
    \ interval2[0]), Math.min(interval1[1], interval2[1])];\n    if (interval[0] >\
    \ interval[1]) return \"NO\";\n    let len = interval[1] - interval[0] + 1;\n\
    \    for (let i = 2; i < len; i++) {\n        if (len % i === 0) return \"NO\"\
    ;\n    }\n    return \"YES\";\n}", "    if (interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]) {\n        return \"NO\";\n    }\n    const start = Math.max(interval1[0],\
    \ interval2[0]);\n    const end = Math.min(interval1[1], interval2[1]);\n    if\
    \ (isPrime(end - start + 1)) {\n        return \"YES\";\n    }\n    return \"\
    NO\";\n}\n", "  const maxStart = Math.max(interval1[0], interval2[0]);\n  const\
    \ minEnd = Math.min(interval1[1], interval2[1]);\n  if (maxStart > minEnd) {\n\
    \    return \"NO\";\n  }\n  return Math.abs(maxStart - minEnd) == 2 ? \"YES\"\
    \ : \"NO\";\n}\n", "  let [left, right] = interval1;\n  let [left2, right2] =\
    \ interval2;\n  if (right < left2 || right2 < left) return \"NO\";\n  let r1 =\
    \ Math.max(left, left2);\n  let r2 = Math.min(right, right2);\n  if (r1 > r2)\
    \ return \"NO\";\n  let len = r2 - r1 + 1;\n  if (len < 2) return \"NO\";\n  let\
    \ max = Math.floor(Math.sqrt(len));\n  for (let i = 2; i <= max; i++) {\n    if\
    \ (len % i === 0) return \"NO\";\n  }\n  return \"YES\";\n}\n\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));", "  const intersect = intersectionOf([interval1, interval2]);\n\
    \  if (!intersect) {\n    return \"NO\";\n  }\n  return isPrime(intersect[1] -\
    \ intersect[0]) ? \"YES\" : \"NO\";\n}", "    let result: number = 0;\n    let\
    \ checkInterval1: boolean = false;\n    let checkInterval2: boolean = false;\n\
    \    let checkInterval3: boolean = false;\n    let checkInterval4: boolean = false;\n\
    \    if (interval1[0] > interval2[0]) {\n        if (interval1[0] > interval2[1])\
    \ {\n            checkInterval1 = true;\n        }\n    } else {\n        if (interval2[0]\
    \ > interval1[1]) {\n            checkInterval2 = true;\n        }\n    }\n  \
    \  if (interval1[1] < interval2[1]) {\n        if (interval1[1] < interval2[0])\
    \ {\n            checkInterval3 = true;\n        }\n    } else {\n        if (interval2[1]\
    \ < interval1[0]) {\n            checkInterval4 = true;\n        }\n    }\n  \
    \  if (checkInterval1 || checkInterval2 || checkInterval3 || checkInterval4) {\n\
    \        return \"NO\";\n    }\n    if (interval1[0] > interval2[0]) {\n     \
    \   if (interval1[0] > interval2[1]) {\n            result = 0;\n        } else\
    \ {\n            result = interval2[1] - interval1[0];\n        }\n    } else\
    \ {\n        if (interval2[0] > interval1[1]) {\n            result = 0;\n   \
    \     } else {\n            result = interval1[1] - interval2[0];\n        }\n\
    \    }\n    if (result == 0) {\n        return \"NO\";\n    }\n    if (result\
    \ == 1) {\n        return \"NO\";\n    }\n    if (result == 2) {\n        return\
    \ \"YES\";\n    }\n    if (result % 2 == 0) {\n        return \"NO\";\n    }\n\
    \    for (let i = 3; i < result; i++) {\n        if (result % i == 0) {\n    \
    \        return \"NO\";\n        }\n    }\n    return \"YES\";\n}\n", "  let [start1,\
    \ end1] = interval1;\n  let [start2, end2] = interval2;\n  if (end1 < start2 ||\
    \ end2 < start1) {\n    return \"NO\";\n  } else {\n    let start = Math.max(start1,\
    \ start2);\n    let end = Math.min(end1, end2);\n    let prime = true;\n    for\
    \ (let i = 2; i < end - start; i++) {\n      if ((end - start) % i === 0) {\n\
    \        prime = false;\n        break;\n      }\n    }\n    return prime ? \"\
    YES\" : \"NO\";\n  }\n}\n", "    const [a, b] = interval1;\n    const [c, d] =\
    \ interval2;\n    if (a > d || b < c) return \"NO\";\n    const intersection =\
    \ [Math.max(a, c), Math.min(b, d)];\n    const len = intersection[1] - intersection[0]\
    \ + 1;\n    return isPrime(len) ? \"YES\" : \"NO\";\n}\nconst isPrime = (n: number):\
    \ boolean => {\n    if (n < 2) return false;\n    if (n == 2) return true;\n \
    \   for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n % i == 0) return\
    \ false;\n    }\n    return true;\n}\n", "    if (interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]) {\n        return \"NO\";\n    }\n    let start\
    \ = Math.max(interval1[0], interval2[0]);\n    let end = Math.min(interval1[1],\
    \ interval2[1]);\n    let len = end - start + 1;\n    return len === 2 || len\
    \ === 3 || len === 5 || len === 7 ? \"YES\" : \"NO\";\n}\n", "  var answer: string\
    \ = \"\";\n  //call function prime with the resulting value of getIntersectionLength\
    \ to see if it is prime\n  var inseclength = getIntersectionLength(interval1,\
    \ interval2);\n  if (inseclength === -1) {\n    answer = \"NO\";\n  } else if\
    \ (prime(inseclength)) {\n    answer = \"YES\";\n  } else {\n    answer = \"NO\"\
    ;\n  }\n  return answer;\n}\n", "    let biggerStart, smallerEnd, intersectionStart,\
    \ intersectionEnd;\n    let biggerInterval, smallerInterval;\n    if (interval1[0]\
    \ <= interval2[0]) {\n        biggerStart = interval2[0];\n        smallerEnd\
    \ = interval1[1];\n        biggerInterval = interval2;\n        smallerInterval\
    \ = interval1;\n    } else {\n        biggerStart = interval1[0];\n        smallerEnd\
    \ = interval2[1];\n        biggerInterval = interval1;\n        smallerInterval\
    \ = interval2;\n    }\n    if (biggerStart > smallerEnd) {\n        return \"\
    NO\";\n    } else {\n        intersectionStart = biggerStart;\n        if (smallerInterval[1]\
    \ >= biggerInterval[1]) {\n            intersectionEnd = biggerInterval[1];\n\
    \        } else {\n            intersectionEnd = smallerInterval[1];\n       \
    \ }\n        return intersectLenPrime(intersectionStart, intersectionEnd);\n \
    \   }\n}\n", "    const min1 = interval1[0] < interval2[0] ? interval1[0] : interval2[0];\n\
    \    const max1 = interval1[1] > interval2[1] ? interval1[1] : interval2[1];\n\
    \    const min2 = interval1[0] > interval2[0] ? interval1[0] : interval2[0];\n\
    \    const max2 = interval1[1] < interval2[1] ? interval1[1] : interval2[1];\n\
    \    if (min1 > max2 || min2 > max1) {\n        return \"NO\";\n    }\n    const\
    \ length = max2 - min1;\n    for (let i = 2; i < length; i++) {\n        if (length\
    \ % i === 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\"\
    ;\n}\n", "    const int1 = [interval1[0], interval1[1]];\n    const int2 = [interval2[0],\
    \ interval2[1]];\n    int1.sort((a, b) => a - b);\n    int2.sort((a, b) => a -\
    \ b);\n    if (int1[1] < int2[0] || int2[1] < int1[0]) return \"NO\";\n    let\
    \ start = Math.max(int1[0], int2[0]);\n    let end = Math.min(int1[1], int2[1]);\n\
    \    let length = end - start + 1;\n    return (length > 1 && !isPrime(length))\
    \ ? \"NO\" : \"YES\";\n}\nconst isPrime = (num: number): boolean => {\n    for\
    \ (let i = 2; i < num; i++) {\n        if (num % i === 0) return false;\n    }\n\
    \    return num > 1;\n}\n", "    const intersect: [number, number] = [Math.max(interval1[0],\
    \ interval2[0]), Math.min(interval1[1], interval2[1])];\n    if (intersect[0]\
    \ > intersect[1]) {\n        return \"NO\";\n    }\n    return isPrime(intersect[1]\
    \ - intersect[0] + 1) ? \"YES\" : \"NO\";\n}\n\nconst isPrime = (n: number): boolean\
    \ => {\n    if (n === 1) {\n        return false;\n    }\n    for (let i = 2;\
    \ i <= Math.sqrt(n); i++) {\n        if (n % i === 0) {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n\nconsole.log(intersection([1, 2], [2,\
    \ 3]));\nconsole.log(intersection([-1, 1], [0, 4]));\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));", "    const start = Math.max(interval1[0], interval2[0]);\n\
    \    const end = Math.min(interval1[1], interval2[1]);\n    if (start >= end)\
    \ {\n        return \"NO\";\n    }\n    const diff = end - start;\n    if (diff\
    \ < 2) {\n        return \"NO\";\n    }\n    if (diff === 2) {\n        return\
    \ \"YES\";\n    }\n    for (let i = 2; i <= Math.floor(Math.sqrt(diff)); i++)\
    \ {\n        if (diff % i === 0) {\n            return \"NO\";\n        }\n  \
    \  }\n    return \"YES\";\n}", "    return '';\n}\n\nexport { intersection }",
  "  const [firstStart, firstEnd] = interval1;\n  const [secondStart, secondEnd] =\
    \ interval2;\n  const intersection: [number, number] = [Math.max(firstStart, secondStart),\
    \ Math.min(firstEnd, secondEnd)];\n  return isPrime(Math.abs(intersection[0] -\
    \ intersection[1])) ? \"YES\" : \"NO\";\n}\n", "    //// input: two intervals,\
    \ output: \"YES\" or \"NO\"\n    //// edge cases: if intervals don't intersect,\
    \ return \"NO\"\n    //// if the length of the intersection is a prime number,\
    \ return \"YES\"\n    //// otherwise, return \"NO\"\n    //// iterate through\
    \ numbers between the intervals, check if prime\n    //// check length of iterated\
    \ list\n    //// iterate through numbers in list\n    //// check if prime number\n\
    \n    //// generate a list of numbers between the intervals\n    //// check if\
    \ they are a prime number\n    let minNum = Math.max(interval1[0], interval2[0]);\n\
    \    let maxNum = Math.min(interval1[1], interval2[1]);\n    let count = 0;\n\
    \    for (let i = minNum; i <= maxNum; i++) {\n        if (isPrime(i)) {\n   \
    \         count++;\n        }\n    }\n    return isPrime(count) ? \"YES\" : \"\
    NO\";\n}\n", "  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n\
    \  const intersect = [Math.max(start1, start2), Math.min(end1, end2)];\n  const\
    \ intersectLength = intersect[1] - intersect[0];\n  if (intersectLength <= 0)\
    \ {\n    return \"NO\";\n  }\n  const isPrime = (n: number) => {\n    if (n <\
    \ 2) {\n      return false;\n    }\n    for (let i = 2; i < n; i++) {\n      if\
    \ (n % i === 0) {\n        return false;\n      }\n    }\n    return true;\n \
    \ };\n  return isPrime(intersectLength) ? \"YES\" : \"NO\";\n}\n", "    let left\
    \ = interval1[0] > interval2[0] ? interval1[0] : interval2[0];\n    let right\
    \ = interval1[1] < interval2[1] ? interval1[1] : interval2[1];\n    if (left >\
    \ right) return \"NO\";\n    if (left == right) return \"YES\";\n    let i = 2;\n\
    \    while (i < right) {\n        if (left % i == 0 && right % i == 0) {\n   \
    \         return \"NO\";\n        }\n        i++;\n    }\n    return \"YES\";\n\
    }", "    var x = Math.max(interval1[0], interval2[0]);\n    var y = Math.min(interval1[1],\
    \ interval2[1]);\n    if (x > y) {\n        return \"NO\";\n    }\n    for (var\
    \ i = 2; i < y; i++) {\n        if (x % i == 0) {\n            return \"NO\";\n\
    \        }\n    }\n    return \"YES\";\n}\n", "  // find the range of intersection,\
    \ if there is one\n  const start = Math.max(interval1[0], interval2[0]);\n  const\
    \ end = Math.min(interval1[1], interval2[1]);\n  if (start >= end) {\n    return\
    \ \"NO\";\n  }\n  // check if the length of the intersection is prime\n  let isPrime\
    \ = true;\n  const length = end - start;\n  for (let i = 2; i < length; i++) {\n\
    \    if (length % i === 0) {\n      isPrime = false;\n      break;\n    }\n  }\n\
    \  return isPrime ? \"YES\" : \"NO\";\n}\n", "    const start: number = Math.max(interval1[0],\
    \ interval2[0]);\n    const end: number = Math.min(interval1[1], interval2[1]);\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    if (start === end)\
    \ {\n        return isPrime(start) ? \"YES\" : \"NO\";\n    }\n    return isPrime(end\
    \ - start + 1) ? \"YES\" : \"NO\";\n}\n", "    const start = Math.max(interval1[0],\
    \ interval2[0]);\n    const end = Math.min(interval1[1], interval2[1]);\n    if\
    \ (start > end) {\n        return \"NO\";\n    }\n    const length = end - start\
    \ + 1;\n    if (length < 2) {\n        return \"NO\";\n    }\n    for (let i =\
    \ 2; i < length; i++) {\n        if (length % i === 0) {\n            return \"\
    NO\";\n        }\n    }\n    return \"YES\";\n}\n", "    const first = Math.max(interval1[0],\
    \ interval2[0]);\n    const second = Math.min(interval1[1], interval2[1]);\n \
    \   if (first > second) {\n        return \"NO\";\n    }\n    if (first === second)\
    \ {\n        return isPrime(first) ? \"YES\" : \"NO\";\n    }\n    return isPrime(second\
    \ - first + 1) ? \"YES\" : \"NO\";\n}\n", "    let start = Math.max(interval1[0],\
    \ interval2[0]);\n    let end = Math.min(interval1[1], interval2[1]);\n    if\
    \ (start >= end) return \"NO\";\n    if (start === end) return \"YES\";\n    let\
    \ length = end - start;\n    let divisible = false;\n    for (let i = 2; i < length;\
    \ i++) {\n        if (length % i === 0) {\n            divisible = true;\n   \
    \         break;\n        }\n    }\n    return divisible ? \"NO\" : \"YES\";\n\
    }\n", "  // // define intervals for each number\n  const first: number[] = [interval1[0],\
    \ interval1[1]];\n  const second: number[] = [interval2[0], interval2[1]];\n \
    \ const check: number[] = [];\n  // // check the intersection\n  if (first[0]\
    \ >= second[0] && first[0] <= second[1]) {\n    check.push(first[0]);\n  }\n \
    \ if (first[1] >= second[0] && first[1] <= second[1]) {\n    check.push(first[1]);\n\
    \  }\n  if (second[0] >= first[0] && second[0] <= first[1]) {\n    check.push(second[0]);\n\
    \  }\n  if (second[1] >= first[0] && second[1] <= first[1]) {\n    check.push(second[1]);\n\
    \  }\n  // // if there is no intersection return \"NO\"\n  if (check.length ===\
    \ 0) {\n    return \"NO\";\n  }\n  // // if there is an intersection, get its\
    \ length\n  let length: number = 0;\n  // // if the interval is the same, return\
    \ \"YES\"\n  if (check.length === 1) {\n    return \"YES\";\n  }\n  if (check.length\
    \ === 2) {\n    length = check[1] - check[0];\n  }\n  // // check if the length\
    \ is a prime number\n  let prime: boolean = true;\n  if (length <= 1) {\n    prime\
    \ = false;\n  }\n  for (let i: number = 2; i < length; i++) {\n    if (length\
    \ % i === 0) {\n      prime = false;\n    }\n  }\n  // // return the final result\n\
    \  if (prime) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n  }\n}\n\
    \nexport { intersection };", "    const a1 = interval1[0], a2 = interval1[1];\n\
    \    const b1 = interval2[0], b2 = interval2[1];\n    const x1 = Math.max(a1,\
    \ b1), x2 = Math.min(a2, b2);\n    if (x1 > x2) {\n        return \"NO\";\n  \
    \  }\n    if (x1 == x2) {\n        return \"YES\";\n    }\n    return isPrime(x2\
    \ - x1 + 1) ? \"YES\" : \"NO\";\n}\n", "  var arr = [];\n  for (var i = interval1[0];\
    \ i <= interval1[1]; i++) {\n    arr.push(i);\n  }\n  for (var j = interval2[0];\
    \ j <= interval2[1]; j++) {\n    if (arr.indexOf(j) != -1) {\n      return \"\
    YES\";\n    }\n  }\n  return \"NO\";\n}\n\nconsole.log(intersection([1, 2], [2,\
    \ 3]));\nconsole.log(intersection([-1, 1], [0, 4]));\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));", "    let result = [];\n    for (let index = 0; index < arguments.length;\
    \ index++) {\n        const element = arguments[index];\n        if (element[0]\
    \ >= element[1]) {\n            return \"NO\";\n        }\n        result.push(element);\n\
    \    }\n    let intersection = [];\n    for (let i = 0; i < result.length; i++)\
    \ {\n        const element = result[i];\n        intersection.push(Math.max(...element));\n\
    \        intersection.push(Math.min(...element));\n    }\n    intersection = intersection.sort((a,\
    \ b) => a - b);\n    let prime = (intersection[1] - intersection[0]) / 2 + intersection[0];\n\
    \    for (let index = 2; index < prime; index++) {\n        if (prime % index\
    \ === 0) {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n\
    }\nconsole.log(intersection([1, 2], [2, 3]));\nconsole.log(intersection([-1, 1],\
    \ [0, 4]));\nconsole.log(intersection([-3, -1], [-5, 5]));\n", "    let start\
    \ = Math.max(interval1[0], interval2[0]);\n    let end = Math.min(interval1[1],\
    \ interval2[1]);\n    if (start >= end) return \"NO\";\n    return isPrime(end\
    \ - start) ? \"YES\" : \"NO\";\n}\n", "    let start = Math.max(interval1[0],\
    \ interval2[0]);\n    let end = Math.min(interval1[1], interval2[1]);\n    if\
    \ (start >= end) {\n        return \"NO\";\n    }\n    else {\n        let res\
    \ = end - start;\n        for (let i = 2; i < res; i++) {\n            if (res\
    \ % i === 0) {\n                return \"NO\";\n            }\n        }\n   \
    \     return \"YES\";\n    }\n}\n", "    let start = Math.max(interval1[0], interval2[0]);\n\
    \    let end = Math.min(interval1[1], interval2[1]);\n    let len = end - start;\n\
    \    if (len < 0) return \"NO\";\n    let arr = [];\n    for (let i = 2; i <=\
    \ len; i++) {\n        if (len % i === 0) arr.push(i);\n    }\n    return (arr.length\
    \ === 0) ? \"YES\" : \"NO\";\n}\n", "    const start = Math.max(interval1[0],\
    \ interval2[0]);\n    const end = Math.min(interval1[1], interval2[1]);\n    const\
    \ result = end - start;\n    if (result > 0) {\n        if (isPrime(result)) {\n\
    \            return \"YES\";\n        }\n    }\n    return \"NO\";\n}\n", "  let\
    \ [x, y] = interval1\n  let [m, n] = interval2\n  if (y <= m || n <= x) return\
    \ \"NO\"\n  let [start, end] = [Math.max(x, m), Math.min(y, n)]\n  for (let i\
    \ = 2; i <= Math.floor(Math.sqrt(end)); i++) {\n    if (start % i === 0 || end\
    \ % i === 0) return \"NO\"\n  }\n  return \"YES\"\n}\nexport default intersection",
  "    // if the two intervals don't intersect return \"NO\"\n    if (interval1[1]\
    \ < interval2[0] || interval2[1] < interval1[0]) {\n        return \"NO\";\n \
    \   }\n\n    // set up the interval in the numerator\n    const start = Math.max(interval1[0],\
    \ interval2[0]);\n    const end = Math.min(interval1[1], interval2[1]);\n\n  \
    \  // set up the interval in the denominator\n    const interval = interval1[1]\
    \ > interval2[1] ? interval1 : interval2;\n\n    // if the numerator is less than\
    \ the denominator, return \"NO\"\n    if (start > end) {\n        return \"NO\"\
    ;\n    }\n\n    const length = end - start + 1;\n\n    for (let i = 2; i < length;\
    \ i++) {\n        if (length % i === 0) {\n            return \"NO\";\n      \
    \  }\n    }\n\n    return \"YES\";\n}\n", "    const lengths = [\n        Math.abs(interval1[0]\
    \ - interval1[1]),\n        Math.abs(interval2[0] - interval2[1])\n    ];\n  \
    \  if (interval1[0] < interval2[0]) {\n        return isPrime(interval2[0] - interval1[1])\
    \ ? \"YES\" : \"NO\";\n    } else {\n        return isPrime(interval1[0] - interval2[1])\
    \ ? \"YES\" : \"NO\";\n    }\n}\n", "    const intStart = Math.max(interval1[0],\
    \ interval2[0]);\n    const intEnd = Math.min(interval1[1], interval2[1]);\n \
    \   const intLength = intEnd - intStart;\n    if (intLength <= 0) {\n        return\
    \ \"NO\";\n    }\n    const isPrime = (n: number) => {\n        if (n <= 1) {\n\
    \            return false;\n        }\n        for (let i = 2; i < n; i++) {\n\
    \            if (n % i === 0) {\n                return false;\n            }\n\
    \        }\n        return true;\n    }\n    return isPrime(intLength) ? \"YES\"\
    \ : \"NO\";\n}", "  const start = Math.max(interval1[0], interval2[0]);\n  const\
    \ end = Math.min(interval1[1], interval2[1]);\n  if (start > end) {\n    return\
    \ \"NO\";\n  }\n  if (start === end) {\n    return isPrime(start) ? \"YES\" :\
    \ \"NO\";\n  }\n  for (let i = start; i <= end; i++) {\n    if (isPrime(i)) {\n\
    \      return \"YES\";\n    }\n  }\n  return \"NO\";\n}\n", "    let [minA, maxA]\
    \ = interval1;\n    let [minB, maxB] = interval2;\n    let intersectStart = Math.max(minA,\
    \ minB);\n    let intersectEnd = Math.min(maxA, maxB);\n    if (intersectStart\
    \ > intersectEnd) return \"NO\";\n    let diff = intersectEnd - intersectStart;\n\
    \    return (diff === 1 || diff === 3 || diff === 5 || diff === 7 || diff ===\
    \ 11 || diff === 13 || diff === 17 || diff === 19) ? \"YES\" : \"NO\";\n}\n\n\
    export { intersection };", "  if (interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]) {\n    return \"NO\";\n  }\n  let start: number = 0;\n  let\
    \ end: number = 0;\n  if (interval1[0] < interval2[0]) {\n    start = interval2[0];\n\
    \  } else {\n    start = interval1[0];\n  }\n  if (interval1[1] < interval2[1])\
    \ {\n    end = interval1[1];\n  } else {\n    end = interval2[1];\n  }\n  let\
    \ length: number = end - start;\n  if (length === 1) {\n    return \"NO\";\n \
    \ }\n  for (let i: number = 2; i < length; i++) {\n    if (length % i === 0) {\n\
    \      return \"NO\";\n    }\n  }\n  return \"YES\";\n}\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));\nconsole.log(intersection([1, 2], [2, 3]));\nconsole.log(intersection([-1,\
    \ 1], [0, 4]));", "    let start, end;\n    if(interval1[0] > interval2[0]) {\n\
    \        start = interval1[0];\n    } else {\n        start = interval2[0];\n\
    \    }\n    if(interval1[1] < interval2[1]) {\n        end = interval1[1];\n \
    \   } else {\n        end = interval2[1];\n    }\n    if(start <= end) {\n   \
    \     if(isPrime(end - start + 1)) {\n            return \"YES\";\n        } else\
    \ {\n            return \"NO\";\n        }\n    } else {\n        return \"NO\"\
    ;\n    }\n}\n", "  // get the maximum start and the minimum end\n  const start:\
    \ number = Math.max(interval1[0], interval2[0]);\n  const end: number = Math.min(interval1[1],\
    \ interval2[1]);\n  // if there is an intersection\n  if (start <= end) {\n  \
    \  // if the length of the intersection is a prime number, return \"YES\",\n \
    \   // otherwise, return \"NO\".\n    return isPrime(end - start + 1) ? \"YES\"\
    \ : \"NO\";\n  }\n  // if the two intervals don't intersect, return \"NO\".\n\
    \  return \"NO\";\n}\n", "    const [start, end] = [Math.max(interval1[0], interval2[0]),\
    \ Math.min(interval1[1], interval2[1])];\n    if (start >= end) return \"NO\"\
    ;\n    for (let i = 2; i < end - start; i++) {\n        if ((end - start) % i\
    \ === 0) return \"NO\";\n    }\n    return \"YES\";\n}\n\nconst tests: [number,\
    \ number, number, number, string][] = [\n    [[1, 2], [2, 3], \"NO\"],\n    [[-1,\
    \ 1], [0, 4], \"NO\"],\n    [[-3, -1], [-5, 5], \"YES\"],\n    [[-1, 1], [-2,\
    \ 2], \"NO\"],\n    [[-3, 3], [-5, 5], \"YES\"],\n    [[5, 7], [1, 4], \"NO\"\
    ],\n    [[0, 1], [0, 1], \"YES\"],\n    [[-1, -1], [0, 0], \"NO\"],\n    [[3,\
    \ 10], [5, 8], \"YES\"],\n    [[3, 8], [4, 8], \"YES\"],\n    [[-1, -1], [0, 0],\
    \ \"NO\"],\n    [[-1, 0], [0, 1], \"NO\"],\n    [[10, 20], [1, 30], \"NO\"],\n\
    \    [[1, 10], [15, 30], \"NO\"],\n    [[-2, -1], [1, 2], \"NO\"],\n    [[-3,\
    \ -1], [2, 5], \"NO\"],\n    [[1, 2], [3, 4], \"NO\"],\n    [[-1, -1], [0, 0],\
    \ \"NO\"],\n    [[-3, -1], [2, 5], \"NO\"],\n    [[5, 10], [1, 5], \"NO\"],\n\
    \    [[0, 1], [0, 2], \"NO\"],\n    [[-10, -5], [-20, -30], \"NO\"],\n    [[-1,\
    \ 1], [0, 1], \"NO\"],\n    [[-2, 0], [2, 4], \"NO\"],\n    [[0, 1], [1, 2", " \
    \ // Your code is here...\n  let res = \"\";\n  let arr = [];\n  let arr2 = [];\n\
    \  if (interval1[0] > interval2[0]) {\n    arr = [interval1[0], interval2[1]];\n\
    \  } else {\n    arr = [interval2[0], interval1[1]];\n  }\n  if (arr[0] > arr[1])\
    \ {\n    res = \"NO\";\n  } else {\n    for (let i = 2; i < arr[1]; i++) {\n \
    \     if (arr[1] % i === 0) {\n        arr2.push(i);\n      }\n    }\n    if (arr2.length\
    \ === 0) {\n      res = \"YES\";\n    } else {\n      res = \"NO\";\n    }\n \
    \ }\n  return res;\n}\n", "    if (interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]) {\n        return \"NO\";\n    }\n    let intersection = 0;\n\
    \    if (interval1[0] < interval2[0]) {\n        intersection = interval2[0] -\
    \ interval1[1];\n    } else {\n        intersection = interval1[0] - interval2[1];\n\
    \    }\n    return isPrime(intersection) ? \"YES\" : \"NO\";\n}\n", "  let intersectionLength\
    \ = 0;\n  if (interval1[0] <= interval2[0] && interval2[0] <= interval1[1]) {\n\
    \    if (interval1[1] <= interval2[1]) {\n      intersectionLength = interval1[1]\
    \ - interval2[0] + 1;\n    } else {\n      intersectionLength = interval2[1] -\
    \ interval2[0] + 1;\n    }\n  } else if (interval2[0] <= interval1[0] && interval1[0]\
    \ <= interval2[1]) {\n    if (interval2[1] <= interval1[1]) {\n      intersectionLength\
    \ = interval2[1] - interval1[0] + 1;\n    } else {\n      intersectionLength =\
    \ interval1[1] - interval1[0] + 1;\n    }\n  }\n  if (intersectionLength === 0)\
    \ {\n    return \"NO\";\n  }\n  for (let i = 2; i < intersectionLength; i++) {\n\
    \    if (intersectionLength % i === 0) {\n      return \"NO\";\n    }\n  }\n \
    \ return \"YES\";\n}\n", "    const x1 = interval1[0], y1 = interval1[1];\n  \
    \  const x2 = interval2[0], y2 = interval2[1];\n    const left = Math.max(x1,\
    \ x2);\n    const right = Math.min(y1, y2);\n    if (left > right) {\n       \
    \ return \"NO\";\n    }\n    return (right - left + 1) in primes ? \"YES\" : \"\
    NO\";\n}\n", "  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n\
    \  const start3 = Math.max(start1, start2);\n  const end3 = Math.min(end1, end2);\n\
    \  if (start3 > end3) {\n    return \"NO\";\n  }\n  const len = end3 - start3\
    \ + 1;\n  if (isPrime(len)) {\n    return \"YES\";\n  }\n  return \"NO\";\n}\n",
  "    let intersectionStart = Math.max(interval1[0], interval2[0]);\n    let intersectionEnd\
    \ = Math.min(interval1[1], interval2[1]);\n    if (intersectionStart > intersectionEnd)\
    \ {\n        return \"NO\";\n    }\n    let length = intersectionEnd - intersectionStart\
    \ + 1;\n    let isPrime = length > 1 && !Array.from(Array(length), (_, x) => x\
    \ + 2).some(i => length % i === 0);\n    return isPrime ? \"YES\" : \"NO\";\n}",
  "    if(interval1[0]>interval2[1] || interval2[0]>interval1[1]){\n        return\
    \ \"NO\";\n    }\n    const maxStart = Math.max(interval1[0], interval2[0]);\n\
    \    const minEnd = Math.min(interval1[1], interval2[1]);\n    const length =\
    \ minEnd - maxStart + 1;\n    return isPrime(length) ? \"YES\" : \"NO\";\n}\n",
  "    // let x1 = interval1[0];\n    // let x2 = interval1[1];\n    // let y1 = interval2[0];\n\
    \    // let y2 = interval2[1];\n    let [x1, x2] = interval1;\n    let [y1, y2]\
    \ = interval2;\n    if (x1 > x2) [x1, x2] = [x2, x1];\n    if (y1 > y2) [y1, y2]\
    \ = [y2, y1];\n    if (x2 < y1 || y2 < x1) return \"NO\";\n    let min = Math.max(x1,\
    \ y1);\n    let max = Math.min(x2, y2);\n    for (let i = 2; i < max; i++) {\n\
    \        if (min % i === 0 && max % i === 0) return \"NO\";\n    }\n    return\
    \ \"YES\";\n}\n", "  let min = Math.max(interval1[0], interval2[0]);\n  let max\
    \ = Math.min(interval1[1], interval2[1]);\n  if (min > max) {\n    return \"NO\"\
    ;\n  }\n  return isPrime(max - min + 1) ? \"YES\" : \"NO\";\n}", "    const min\
    \ = Math.max(interval1[0], interval2[0]);\n    const max = Math.min(interval1[1],\
    \ interval2[1]);\n    if (min > max) return \"NO\";\n    return isPrime(max -\
    \ min + 1) ? \"YES\" : \"NO\";\n}\n", "  const [start1, end1] = interval1;\n \
    \ const [start2, end2] = interval2;\n  const x = Math.max(start1, start2);\n \
    \ const y = Math.min(end1, end2);\n  const temp = y - x;\n  const prime = (num:\
    \ number) => {\n    if (num <= 1) return false;\n    for (let i = 2; i < num;\
    \ i++) {\n      if (num % i === 0) return false;\n    }\n    return true;\n  };\n\
    \  if (temp <= 0) return \"NO\";\n  if (prime(temp)) return \"YES\";\n  return\
    \ \"NO\";\n}\nconsole.log(intersection([1, 2], [2, 3]));\nconsole.log(intersection([-1,\
    \ 1], [0, 4]));\nconsole.log(intersection([-3, -1], [-5, 5]));", "  const start\
    \ = Math.max(interval1[0], interval2[0]);\n  const end = Math.min(interval1[1],\
    \ interval2[1]);\n  const difference = end - start;\n  if (difference < 0) {\n\
    \    return \"NO\";\n  }\n  if (difference === 0) {\n    return \"YES\";\n  }\n\
    \  return primes.includes(difference) ? \"YES\" : \"NO\";\n}\n", "    // write\
    \ your code here\n    let [start1, end1] = interval1;\n    let [start2, end2]\
    \ = interval2;\n    const isPrime = n => n < 2 ? false : [...Array(n).keys()].filter(i\
    \ => n % i === 0).length === 1;\n    let maxStart = Math.max(start1, start2);\n\
    \    let minEnd = Math.min(end1, end2);\n    if (maxStart > minEnd) {\n      \
    \  return \"NO\";\n    }\n    return isPrime(minEnd - maxStart + 1) ? \"YES\"\
    \ : \"NO\";\n}\n", "    // If the two intervals don't intersect, return \"NO\"\
    .\n    if (interval1[1] < interval2[0] || interval2[1] < interval1[0]) {\n   \
    \     return \"NO\";\n    }\n    const start = Math.max(interval1[0], interval2[0]);\n\
    \    const end = Math.min(interval1[1], interval2[1]);\n    const length = end\
    \ - start + 1;\n    return (length > 1 && isPrime(length)) ? \"YES\" : \"NO\"\
    ;\n}\nconst isPrime = (n: number): boolean => {\n    if (n === 1) {\n        return\
    \ false;\n    }\n    for (let i = 2; i <= Math.sqrt(n); i++) {\n        if (n\
    \ % i === 0) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n", "    let intersecting = getIntersection(interval1, interval2);\n    if (intersecting\
    \ == null) {\n        return \"NO\";\n    }\n    return isPrime(Math.abs(intersecting[0]\
    \ - intersecting[1])) ? \"YES\" : \"NO\";\n}\n", "    let intersectionLength:\
    \ number = getIntersectionLength(interval1, interval2);\n    if(intersectionLength\
    \ === 0) {\n        return \"NO\";\n    }\n    return isPrime(intersectionLength)\
    \ ? \"YES\" : \"NO\";\n}\n", "  let min: number = Math.max(interval1[0], interval2[0]);\n\
    \  let max: number = Math.min(interval1[1], interval2[1]);\n  if (min > max) {\n\
    \    return \"NO\";\n  }\n  let len = max - min + 1;\n  if (len == 1) {\n    return\
    \ \"NO\";\n  }\n  let m: number = 2;\n  while (m * m <= len) {\n    if (len %\
    \ m == 0) {\n      return \"NO\";\n    }\n    m++;\n  }\n  return \"YES\";\n}\n",
  "  // intersections\n  const start: number = Math.max(interval1[0], interval2[0]);\n\
    \  const end: number = Math.min(interval1[1], interval2[1]);\n  if (start >= end)\
    \ {\n    return \"NO\";\n  }\n\n  // length of intersection\n  const len: number\
    \ = end - start;\n  // check prime\n  const isPrime: boolean = isPrimeHelper(len);\n\
    \  return isPrime ? \"YES\" : \"NO\";\n}\n", "  let [start1, end1] = interval1;\n\
    \  let [start2, end2] = interval2;\n  let start3 = Math.max(start1, start2);\n\
    \  let end3 = Math.min(end1, end2);\n  if (start3 >= end3) {\n    return \"NO\"\
    ;\n  }\n  let len = end3 - start3;\n  let i = 2;\n  while (i < len) {\n    if\
    \ (len % i === 0) {\n      return \"NO\";\n    }\n    i++;\n  }\n  return \"YES\"\
    ;\n}\n", "    // return \"NO\";\n    let intersection = [Math.max(interval1[0],\
    \ interval2[0]), Math.min(interval1[1], interval2[1])];\n    return intersection[0]\
    \ > intersection[1] ? 'NO' : isPrime(intersection[1] - intersection[0] + 1) ?\
    \ 'YES' : 'NO';\n}\n", "    const start = Math.max(interval1[0], interval2[0]);\n\
    \    const end = Math.min(interval1[1], interval2[1]);\n    if (start > end) {\n\
    \        return \"NO\";\n    }\n    if (isPrime(end - start + 1)) {\n        return\
    \ \"YES\";\n    }\n    return \"NO\";\n}\n\nconst isPrime = (num: number): boolean\
    \ => {\n    for (let i = 2; i < num; i++) {\n        if (num % i === 0) {\n  \
    \          return false;\n        }\n    }\n    return num > 1;\n}\n\nconsole.log(intersection([1,\
    \ 2], [2, 3])); // \"NO\"\nconsole.log(intersection([-1, 1], [0, 4])); // \"NO\"\
    \nconsole.log(intersection([-3, -1], [-5, 5])); // \"YES\"", "    const [n1, n2]\
    \ = interval1;\n    const [n3, n4] = interval2;\n    if (n1 > n4 || n3 > n2) return\
    \ \"NO\";\n    const intersection = Math.min(n2, n4) - Math.max(n1, n3) + 1;\n\
    \    return (isPrime(intersection)) ? \"YES\" : \"NO\";\n}\n", "    return \"\"\
    ;\n}", "    // -3, -1\n    // -5, 5\n    let result: [number, number] = [0, 0];\n\
    \    if (interval1[0] >= interval2[0] && interval1[0] <= interval2[1]) {\n   \
    \     result[0] = interval1[0];\n    } else if (interval2[0] >= interval1[0] &&\
    \ interval2[0] <= interval1[1]) {\n        result[0] = interval2[0];\n    } else\
    \ {\n        return \"NO\";\n    }\n    if (interval1[1] >= interval2[0] && interval1[1]\
    \ <= interval2[1]) {\n        result[1] = interval1[1];\n    } else if (interval2[1]\
    \ >= interval1[0] && interval2[1] <= interval1[1]) {\n        result[1] = interval2[1];\n\
    \    } else {\n        return \"NO\";\n    }\n    if (result[0] >= result[1])\
    \ {\n        return \"NO\";\n    }\n    let range: number = Math.abs(result[1]\
    \ - result[0]);\n    if (range === 1) {\n        return \"NO\";\n    }\n    for\
    \ (let i: number = 2; i < range; i++) {\n        if (range % i === 0) {\n    \
    \        return \"NO\";\n        }\n    }\n    return \"YES\";\n}\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));", "  let [i1_start, i1_end] = interval1;\n  let [i2_start, i2_end]\
    \ = interval2;\n  let start = Math.max(i1_start, i2_start);\n  let end = Math.min(i1_end,\
    \ i2_end);\n  let diff = Math.abs(end - start);\n  if (diff === 0) return \"NO\"\
    ;\n  for (let i = 2; i < diff; i++) {\n    if (diff % i === 0) return \"NO\";\n\
    \  }\n  return \"YES\";\n}\n\nconsole.log(intersection([1, 2], [2, 3])); // \"\
    NO\"\nconsole.log(intersection([-1, 1], [0, 4])); // \"NO\"\nconsole.log(intersection([-3,\
    \ -1], [-5, 5])); // \"YES\"", "  let x1 = interval1[0];\n  let x2 = interval1[1];\n\
    \  let y1 = interval2[0];\n  let y2 = interval2[1];\n  if (x1 >= y2 || y1 >= x2)\
    \ {\n    return \"NO\";\n  }\n  else {\n    let length: number = 0;\n    if (x1\
    \ <= y1) {\n      length = x2 - y1;\n    }\n    else {\n      length = y2 - x1;\n\
    \    }\n    if (length <= 2) {\n      return \"NO\";\n    }\n    else {\n    \
    \  for (let i = 2; i < length; i++) {\n        if (length % i === 0) {\n     \
    \     return \"NO\";\n        }\n      }\n      return \"YES\";\n    }\n  }\n\
    }\n", "    const range1: Array<number> = Array.from(Array(interval1[1] - interval1[0]\
    \ + 1), (x, i) => i + interval1[0]);\n    const range2: Array<number> = Array.from(Array(interval2[1]\
    \ - interval2[0] + 1), (x, i) => i + interval2[0]);\n    const result: Array<number>\
    \ = range1.filter(x => range2.includes(x));\n    if (result.length === 0) {\n\
    \        return \"NO\";\n    }\n    const prime: boolean = checkPrime(result.length);\n\
    \    return prime ? \"YES\" : \"NO\";\n}\n", "    const interval3 = interval1[0]\
    \ > interval2[0] ? interval1 : interval2;\n    const interval4 = interval1[0]\
    \ > interval2[0] ? interval2 : interval1;\n    if (interval3[0] <= interval4[1])\
    \ {\n        if (interval3[0] < interval4[1]) {\n            if (interval3[0]\
    \ === interval4[1]) {\n                return \"NO\";\n            }\n       \
    \     const l = interval4[1] - interval3[0] + 1;\n            for (let i = 2;\
    \ i < l; i++) {\n                if (l % i === 0) {\n                    return\
    \ \"NO\";\n                }\n            }\n            return \"YES\";\n   \
    \     }\n        return \"NO\";\n    }\n    return \"NO\";\n}\n\nconsole.log(intersection([1,\
    \ 2], [2, 3]));\nconsole.log(intersection([-1, 1], [0, 4]));\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));", "  let i1 = interval1[0];\n  let i2 = interval1[1];\n  let\
    \ i3 = interval2[0];\n  let i4 = interval2[1];\n  if (i1 > i2) {\n    [i1, i2]\
    \ = [i2, i1];\n  }\n  if (i3 > i4) {\n    [i3, i4] = [i4, i3];\n  }\n  const maxStart\
    \ = Math.max(i1, i3);\n  const minEnd = Math.min(i2, i4);\n  if (maxStart > minEnd)\
    \ {\n    return \"NO\";\n  }\n  const len = minEnd - maxStart + 1;\n  if (len\
    \ <= 1) {\n    return \"NO\";\n  }\n  for (let i = 2; i <= Math.sqrt(len); i++)\
    \ {\n    if (len % i === 0) {\n      return \"NO\";\n    }\n  }\n  return \"YES\"\
    ;\n}\n", "    const sortedIntervals = [interval1, interval2].sort((a, b) => a[0]\
    \ - b[0]);\n    const intersection = [\n        Math.max(sortedIntervals[0][0],\
    \ sortedIntervals[1][0]),\n        Math.min(sortedIntervals[0][1], sortedIntervals[1][1])\n\
    \    ];\n    if (intersection[0] > intersection[1]) {\n        return \"NO\";\n\
    \    }\n\n    return isPrime(intersection[1] - intersection[0] + 1) ? \"YES\"\
    \ : \"NO\";\n}\n", "    let p = interval1[0] > interval2[0] ? interval1[0] : interval2[0];\n\
    \    let q = interval1[1] < interval2[1] ? interval1[1] : interval2[1];\n    if\
    \ (q < p) {\n        return \"NO\";\n    }\n    let interval = (q - p) + 1;\n\
    \    return isPrime(interval) ? \"YES\" : \"NO\";\n}\n", "    if (interval1[0]\
    \ < interval2[0]) {\n        if (interval1[1] > interval2[0]) {\n            return\
    \ isPrime(interval1[1] - interval2[0]) ? \"YES\" : \"NO\";\n        }\n    } else\
    \ {\n        if (interval2[1] > interval1[0]) {\n            return isPrime(interval2[1]\
    \ - interval1[0]) ? \"YES\" : \"NO\";\n        }\n    }\n    return \"NO\";\n\
    }\n", "    const [s1, e1] = interval1;\n    const [s2, e2] = interval2;\n    if\
    \ (s1 > e2 || s2 > e1) {\n        return \"NO\";\n    }\n\n    const start = Math.max(s1,\
    \ s2);\n    const end = Math.min(e1, e2);\n    if (start === end) {\n        return\
    \ start === 2 ? \"YES\" : \"NO\";\n    }\n\n    for (let i = start; i <= end;\
    \ i++) {\n        if (i === 2 || i === 3 || i === 5 || i === 7) {\n          \
    \  return \"YES\";\n        }\n    }\n\n    return \"NO\";\n}\n", "    const length:\
    \ number = getIntersectionLength(interval1, interval2);\n    if (length < 0) {\n\
    \        return \"NO\";\n    }\n    return isPrime(length) ? \"YES\" : \"NO\"\
    ;\n}", "    let r: [number, number] = [Math.max(interval1[0], interval2[0]), Math.min(interval1[1],\
    \ interval2[1])];\n    if (r[0] > r[1]) {\n        return \"NO\";\n    } else\
    \ {\n        return isPrime(r[1] - r[0] + 1) ? \"YES\" : \"NO\";\n    }\n}\n",
  "  const isIntersecting = interval1[0] <= interval2[1] && interval2[0] <= interval1[1];\n\
    \  if (!isIntersecting) {\n    return \"NO\";\n  }\n  const lowerBound = Math.max(interval1[0],\
    \ interval2[0]);\n  const upperBound = Math.min(interval1[1], interval2[1]);\n\
    \  const length = upperBound - lowerBound + 1;\n  for (let i = 2; i < length;\
    \ i++) {\n    if (length % i === 0) {\n      return \"NO\";\n    }\n  }\n  return\
    \ \"YES\";\n}\n", "    let [start1, end1] = interval1;\n    let [start2, end2]\
    \ = interval2;\n    if (start1 > end1) {\n        [start1, end1] = [end1, start1];\n\
    \    }\n    if (start2 > end2) {\n        [start2, end2] = [end2, start2];\n \
    \   }\n    const intersectionStart = Math.max(start1, start2);\n    const intersectionEnd\
    \ = Math.min(end1, end2);\n    const length = intersectionEnd - intersectionStart;\n\
    \    return length < 0 ? \"NO\" : primes.includes(length) ? \"YES\" : \"NO\";\n\
    }\n\nexport { intersection };", "    let start = interval1[0] < interval2[0] ?\
    \ interval2[0] : interval1[0];\n    let end = interval1[1] < interval2[1] ? interval1[1]\
    \ : interval2[1];\n    let len = end - start;\n    if (len < 0) {\n        return\
    \ \"NO\";\n    } else {\n        return isPrime(len) ? \"YES\" : \"NO\";\n   \
    \ }\n}", "    let int1: Interval = new Interval(interval1[0], interval1[1]);\n\
    \    let int2: Interval = new Interval(interval2[0], interval2[1]);\n    let int3:\
    \ Interval = int1.intersect(int2);\n    return (int3) ? isPrime(int3.length())\
    \ ? \"YES\" : \"NO\" : \"NO\";\n}\nconsole.log(intersection([1, 2], [2, 3]));\
    \ // \"NO\"\nconsole.log(intersection([-1, 1], [0, 4])); // \"NO\"\nconsole.log(intersection([-3,\
    \ -1], [-5, 5])); // \"YES\"", "    const maxStart = Math.max(interval1[0], interval2[0]);\n\
    \    const minEnd = Math.min(interval1[1], interval2[1]);\n    if (maxStart <=\
    \ minEnd) {\n        const difference = minEnd - maxStart;\n        if (difference\
    \ === 0) {\n            return \"YES\";\n        }\n        for (let i = 2; i\
    \ < difference; i++) {\n            if (difference % i === 0) {\n            \
    \    return \"NO\";\n            }\n        }\n        return \"YES\";\n    }\n\
    \    return \"NO\";\n}\n", "    if (interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]) {\n        return \"NO\";\n    }\n    const intersect = [Math.max(interval1[0],\
    \ interval2[0]), Math.min(interval1[1], interval2[1])];\n    const distance =\
    \ intersect[1] - intersect[0];\n    return distance > 1 && ![2, 3, 5, 7].includes(distance)\
    \ ? \"NO\" : \"YES\";\n}\n", "    let start = Math.max(interval1[0], interval2[0]);\n\
    \    let end = Math.min(interval1[1], interval2[1]);\n    if (start > end) return\
    \ \"NO\";\n    if (start == end) return (Math.abs(start) % 2 == 0) ? \"NO\" :\
    \ \"YES\";\n    return isPrime(end - start + 1) ? \"YES\" : \"NO\";\n}", "   \
    \ let max = Math.max(interval1[0], interval2[0]);\n    let min = Math.min(interval1[1],\
    \ interval2[1]);\n    if (max > min) {\n        return \"NO\";\n    }\n    let\
    \ dif = min - max;\n    if (dif < 2) {\n        return \"NO\";\n    }\n    for\
    \ (let i = 2; i < dif; i++) {\n        if (dif % i === 0) {\n            return\
    \ \"NO\";\n        }\n    }\n    return \"YES\";\n}\nconsole.log(intersection([1,\
    \ 2], [2, 3]));\nconsole.log(intersection([-1, 1], [0, 4]));\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));", "  const start = Math.max(interval1[0], interval2[0]);\n \
    \ const end = Math.min(interval1[1], interval2[1]);\n  if (start > end) {\n  \
    \  return \"NO\";\n  }\n  const length = end - start + 1;\n  if (length <= 1)\
    \ {\n    return \"NO\";\n  }\n  for (let i = 2; i < length; i++) {\n    if (length\
    \ % i === 0) {\n      return \"NO\";\n    }\n  }\n  return \"YES\";\n}\n", " \
    \   let intersectionLength: number = 0;\n    let prime: boolean = true;\n    if\
    \ (interval1[0] > interval2[0]) {\n        if (interval1[0] > interval2[1]) {\n\
    \            return \"NO\";\n        } else {\n            if (interval1[1] >\
    \ interval2[1]) {\n                intersectionLength = interval2[1] - interval1[0];\n\
    \            } else {\n                intersectionLength = interval1[1] - interval1[0];\n\
    \            }\n        }\n    } else {\n        if (interval2[0] > interval1[1])\
    \ {\n            return \"NO\";\n        } else {\n            if (interval2[1]\
    \ > interval1[1]) {\n                intersectionLength = interval1[1] - interval2[0];\n\
    \            } else {\n                intersectionLength = interval2[1] - interval2[0];\n\
    \            }\n        }\n    }\n    for (let i = 2; i < intersectionLength;\
    \ i++) {\n        if (intersectionLength % i === 0) {\n            prime = false;\n\
    \            break;\n        }\n    }\n    if (prime) {\n        return \"YES\"\
    ;\n    } else {\n        return \"NO\";\n    }\n}\n\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));\nconsole.log(intersection([1, 2], [2, 3]));\nconsole.log(intersection([-1,\
    \ 1], [0, 4]));", "    const lower = Math.max(interval1[0], interval2[0]);\n \
    \   const upper = Math.min(interval1[1], interval2[1]);\n    if (lower > upper)\
    \ {\n        return \"NO\";\n    }\n    return isPrime(upper - lower + 1) ? \"\
    YES\" : \"NO\";\n}\n", "  const intersectionInterval = getIntersectionInterval(interval1,\
    \ interval2);\n  if (intersectionInterval === undefined) {\n    return \"NO\"\
    ;\n  }\n  const intersectionLength = intersectionInterval[1] - intersectionInterval[0]\
    \ + 1;\n  return isPrime(intersectionLength) ? \"YES\" : \"NO\";\n}\n", "  const\
    \ start = Math.max(interval1[0], interval2[0]);\n  const end = Math.min(interval1[1],\
    \ interval2[1]);\n  const len = end - start;\n  if (len < 0) {\n    return \"\
    NO\";\n  }\n  const isPrime = (n: number) => {\n    for (let i = 2; i < n; i++)\
    \ {\n      if (n % i === 0) {\n        return false;\n      }\n    }\n    return\
    \ n !== 1;\n  };\n  return isPrime(len) ? \"YES\" : \"NO\";\n}\n\nconsole.log(intersection([1,\
    \ 2], [2, 3]));\nconsole.log(intersection([-1, 1], [0, 4]));\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));", "    let res = [];\n    let set1 = new Set(interval1);\n \
    \   let set2 = new Set(interval2);\n    let length = set1.size > set2.size ? set1.size\
    \ : set2.size;\n    for (let i = 0; i < length; i++) {\n        if (set1.has(i)\
    \ && set2.has(i)) {\n            res.push(i);\n        }\n    }\n    return isPrime(res.length)\
    \ ? \"YES\" : \"NO\";\n}\n", "    let range1 = Math.abs(interval1[0] - interval1[1]);\n\
    \    let range2 = Math.abs(interval2[0] - interval2[1]);\n    let start = Math.max(interval1[0],\
    \ interval2[0]);\n    let end = Math.min(interval1[1], interval2[1]);\n    if\
    \ (start >= end) return \"NO\";\n    let intersectionRange = Math.abs(start -\
    \ end);\n    return isPrime(intersectionRange) ? \"YES\" : \"NO\";\n}\n", "  const\
    \ commonInterval = [Math.max(interval1[0], interval2[0]), Math.min(interval1[1],\
    \ interval2[1])];\n  return commonInterval[0] > commonInterval[1] ? 'NO' : isPrime(commonInterval[1]\
    \ - commonInterval[0] + 1) ? 'YES' : 'NO';\n}\n", "    let totalArray = [];\n\
    \    for (let i = interval1[0]; i <= interval1[1]; i++) {\n        totalArray.push(i);\n\
    \    }\n    for (let i = interval2[0]; i <= interval2[1]; i++) {\n        totalArray.push(i);\n\
    \    }\n    let uniqueArray = [];\n    for (let i = 0; i < totalArray.length;\
    \ i++) {\n        if (uniqueArray.indexOf(totalArray[i]) === -1) {\n         \
    \   uniqueArray.push(totalArray[i]);\n        }\n    }\n    let min = Math.min(...uniqueArray);\n\
    \    let max = Math.max(...uniqueArray);\n    let isPrime = function (num: number):\
    \ boolean {\n        for (let i = 2; i < num; i++) {\n            if (num % i\
    \ === 0) {\n                return false;\n            }\n        }\n        return\
    \ num > 1;\n    }\n    return (max - min <= 1) ? \"NO\" : isPrime(max - min) ?\
    \ \"YES\" : \"NO\";\n}\n", "  let left = 0;\n  let right = 0;\n  let start1 =\
    \ interval1[0];\n  let end1 = interval1[1];\n  let start2 = interval2[0];\n  let\
    \ end2 = interval2[1];\n  if (start1 <= start2 && end1 >= start2) {\n    left\
    \ = start2;\n  } else if (start2 <= start1 && end2 >= start1) {\n    left = start1;\n\
    \  } else {\n    return \"NO\";\n  }\n  if (end1 <= end2) {\n    right = end1;\n\
    \  } else {\n    right = end2;\n  }\n  if (left > right) {\n    return \"NO\"\
    ;\n  }\n  return isPrime(right - left + 1) ? \"YES\" : \"NO\";\n}\n", "    let\
    \ start: number = Math.max(interval1[0], interval2[0]);\n    let end: number =\
    \ Math.min(interval1[1], interval2[1]);\n    let len: number = end - start;\n\
    \    if (len < 0) {\n        return \"NO\";\n    }\n    if (len <= 1) {\n    \
    \    return \"NO\";\n    }\n    if (len === 2) {\n        return \"YES\";\n  \
    \  }\n    for (let i: number = 2; i < len; i++) {\n        if (len % i === 0)\
    \ {\n            return \"NO\";\n        }\n    }\n    return \"YES\";\n}\n",
  "  let start: number;\n  let end: number;\n  if (interval1[0] <= interval2[0]) {\n\
    \    start = interval2[0];\n  } else {\n    start = interval1[0];\n  }\n  if (interval1[1]\
    \ >= interval2[1]) {\n    end = interval2[1];\n  } else {\n    end = interval1[1];\n\
    \  }\n  if (start >= end) {\n    return \"NO\";\n  }\n  let diff = end - start;\n\
    \  if (diff === 1) {\n    return \"NO\";\n  }\n  if (diff === 2) {\n    return\
    \ \"YES\";\n  }\n  if (diff % 2 === 0) {\n    return \"NO\";\n  }\n  for (let\
    \ i = 3; i <= Math.sqrt(diff); i++) {\n    if (diff % i === 0) {\n      return\
    \ \"NO\";\n    }\n  }\n  return \"YES\";\n}\n\nconsole.log(intersection([-3, -1],\
    \ [-5, 5]));", "  const isPrime = (n: number) => {\n    for (let i = 2; i < n;\
    \ i++) {\n      if (n % i === 0) {\n        return false;\n      }\n    }\n  \
    \  return n > 1;\n  };\n\n  const x1 = interval1[0];\n  const x2 = interval1[1];\n\
    \  const y1 = interval2[0];\n  const y2 = interval2[1];\n\n  if (x1 <= y1 && y1\
    \ <= x2 && x2 <= y2) {\n    return isPrime(x2 - y1 + 1) ? \"YES\" : \"NO\";\n\
    \  }\n  if (y1 <= x1 && x1 <= y2 && y2 <= x2) {\n    return isPrime(y2 - x1 +\
    \ 1) ? \"YES\" : \"NO\";\n  }\n  if (x1 <= y1 && y2 <= x2) {\n    return isPrime(y2\
    \ - y1 + 1) ? \"YES\" : \"NO\";\n  }\n  if (y1 <= x1 && x2 <= y2) {\n    return\
    \ isPrime(x2 - x1 + 1) ? \"YES\" : \"NO\";\n  }\n  return \"NO\";\n}\n\nexport\
    \ default intersection;", "  const [i1Start, i1End] = interval1;\n  const [i2Start,\
    \ i2End] = interval2;\n  const iStart = Math.max(i1Start, i2Start);\n  const iEnd\
    \ = Math.min(i1End, i2End);\n  return iStart <= iEnd ? isPrime(iEnd - iStart +\
    \ 1) ? \"YES\" : \"NO\" : \"NO\";\n}\n", "    const intersection = [Math.max(interval1[0],\
    \ interval2[0]), Math.min(interval1[1], interval2[1])];\n    const diff = Math.abs(intersection[0]\
    \ - intersection[1]);\n    if (diff < 2) return \"NO\";\n    const isPrime = diff\
    \ % 2 !== 0 && diff % 3 !== 0 && diff % 5 !== 0 && diff % 7 !== 0;\n    return\
    \ isPrime ? \"YES\" : \"NO\";\n}\n", "    const intersectionArr = [];\n    for\
    \ (let i = interval1[0]; i <= interval1[1]; i++) {\n        for (let j = interval2[0];\
    \ j <= interval2[1]; j++) {\n            if (i === j) {\n                intersectionArr.push(i);\n\
    \            }\n        }\n    }\n    if (intersectionArr.length === 0) {\n  \
    \      return \"NO\";\n    }\n    if (intersectionArr.length === 1) {\n      \
    \  return \"YES\";\n    }\n    for (let i = 2; i < intersectionArr.length; i++)\
    \ {\n        if (intersectionArr[0] % i === 0) {\n            return \"NO\";\n\
    \        }\n    }\n    return \"YES\";\n}\n", "    const start: number = interval1[0]\
    \ >= interval2[0] ? interval1[0] : interval2[0];\n    const end: number = interval1[1]\
    \ <= interval2[1] ? interval1[1] : interval2[1];\n    if (start >= end) {\n  \
    \      return \"NO\";\n    }\n    const length: number = end - start;\n    return\
    \ isPrime(length) ? \"YES\" : \"NO\";\n}\n", "    if (interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]) {\n        return \"NO\";\n    }\n    let start\
    \ = Math.max(interval1[0], interval2[0]);\n    let end = Math.min(interval1[1],\
    \ interval2[1]);\n    let len = end - start + 1;\n    return isPrime(len) ? \"\
    YES\" : \"NO\";\n}\n", "  const [min, max] = [Math.max(interval1[0], interval2[0]),\
    \ Math.min(interval1[1], interval2[1])];\n  return min > max ? \"NO\" : isPrime(max\
    \ - min + 1) ? \"YES\" : \"NO\";\n}\n", "    let minStart = Math.max(interval1[0],\
    \ interval2[0]);\n    let maxEnd = Math.min(interval1[1], interval2[1]);\n   \
    \ let intersection = maxEnd - minStart;\n    if (intersection <= 0) {\n      \
    \  return \"NO\";\n    }\n    let isPrime = true;\n    for (let i = 2; i < intersection;\
    \ i++) {\n        if (intersection % i === 0) {\n            isPrime = false;\n\
    \            break;\n        }\n    }\n    return isPrime ? \"YES\" : \"NO\";\n\
    }\n\nconsole.log(intersection([1, 2], [2, 3]));\nconsole.log(intersection([-1,\
    \ 1], [0, 4]));\nconsole.log(intersection([-3, -1], [-5, 5]));", "    const start\
    \ = Math.max(interval1[0], interval2[0]);\n    const end = Math.min(interval1[1],\
    \ interval2[1]);\n    if (start >= end) {\n        return \"NO\";\n    }\n   \
    \ const length = end - start;\n    return isPrime(length) ? \"YES\" : \"NO\";\n\
    }\n", "    let start = interval1[0] > interval2[0] ? interval1[0] : interval2[0];\n\
    \    let end = interval1[1] < interval2[1] ? interval1[1] : interval2[1];\n  \
    \  if (end < start) {\n        return \"NO\";\n    }\n    let range = end - start\
    \ + 1;\n    if (range === 2) {\n        return \"YES\";\n    }\n    if (range\
    \ > 2) {\n        for (let i = 2; i < range; i++) {\n            if (range % i\
    \ === 0) {\n                return \"NO\";\n            }\n        }\n       \
    \ return \"YES\";\n    }\n}\n", "    const commonStart = Math.max(interval1[0],\
    \ interval2[0]);\n    const commonEnd = Math.min(interval1[1], interval2[1]);\n\
    \    const commonLength = commonEnd - commonStart + 1;\n    if (commonLength <=\
    \ 0) {\n        return \"NO\";\n    }\n    if (commonLength < 3) {\n        return\
    \ \"YES\";\n    }\n    return (commonLength % 2 !== 0) ? \"YES\" : \"NO\";\n}\n",
  "    var [first, second] = [interval1, interval2].sort((a, b) => a[0] - b[0]);\n\
    \    var isPrime = (n: number) => n >= 2 && !new Array(n - 1).fill(0).map((_,\
    \ i) => n % (i + 2)).some(v => v === 0);\n    if (first[1] <= second[0]) return\
    \ \"NO\";\n    var len = second[0] - first[1];\n    if (len < 0) return \"NO\"\
    ;\n    return isPrime(len) ? \"YES\" : \"NO\";\n}\n", "    let int = Math.min(interval1[1],\
    \ interval2[1]) - Math.max(interval1[0], interval2[0]);\n    if (int < 0) {\n\
    \        return \"NO\";\n    }\n    for (let i = 2; i < int; i++) {\n        if\
    \ (int % i === 0) {\n            return \"NO\";\n        }\n    }\n    return\
    \ \"YES\";\n}\nconsole.log(intersection([1, 2], [2, 3]));\nconsole.log(intersection([-1,\
    \ 1], [0, 4]));\nconsole.log(intersection([-3, -1], [-5, 5]));", "  let start\
    \ = Math.max(interval1[0], interval2[0]);\n  let end = Math.min(interval1[1],\
    \ interval2[1]);\n  let intersection = end - start;\n  if (intersection < 0) {\n\
    \    return \"NO\";\n  }\n  else if (isPrime(intersection)) {\n    return \"YES\"\
    ;\n  }\n  else {\n    return \"NO\";\n  }\n}\n", "    let [start1, end1] = interval1;\n\
    \    let [start2, end2] = interval2;\n    if (start1 >= end2 || start2 >= end1)\
    \ {\n        return \"NO\";\n    }\n    let intStart = Math.max(start1, start2);\n\
    \    let intEnd = Math.min(end1, end2);\n    let intLength = intEnd - intStart;\n\
    \    return isPrime(intLength) ? \"YES\" : \"NO\";\n}\n", "    let intersection\
    \ = getIntersection(interval1, interval2);\n    if (intersection[0] === intersection[1])\
    \ {\n        return \"NO\";\n    }\n    let difference = intersection[1] - intersection[0];\n\
    \    return isPrime(difference) ? \"YES\" : \"NO\";\n}", "  let start = Math.max(interval1[0],\
    \ interval2[0]);\n  let end = Math.min(interval1[1], interval2[1]);\n  let length\
    \ = end - start;\n  if (length <= 0) {\n    return \"NO\";\n  }\n  if (length\
    \ === 1) {\n    return \"NO\";\n  }\n  if (length === 2) {\n    return \"YES\"\
    ;\n  }\n  for (let i = 2; i < length; i++) {\n    if (length % i === 0) {\n  \
    \    return \"NO\";\n    }\n  }\n  return \"YES\";\n}\n\nconsole.log(intersection([1,\
    \ 2], [2, 3]));\nconsole.log(intersection([-1, 1], [0, 4]));\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));", "    const intersection = [Math.max(interval1[0], interval2[0]),\
    \ Math.min(interval1[1], interval2[1])];\n    return isPrime(intersection[1] -\
    \ intersection[0] + 1) ? \"YES\" : \"NO\";\n}\n", "    let [start, end] = getIntersectionInterval(interval1,\
    \ interval2);\n    let size = Math.abs(end - start);\n    if (size === 0) {\n\
    \        return \"NO\";\n    }\n    return isPrime(size) ? \"YES\" : \"NO\";\n\
    }\n", "  if (interval1[0] >= interval2[1] || interval2[0] >= interval1[1]) return\
    \ \"NO\";\n  let start = Math.max(interval1[0], interval2[0]);\n  let end = Math.min(interval1[1],\
    \ interval2[1]);\n  if (end - start <= 1) return \"NO\";\n  return primeCheck(end\
    \ - start) ? \"YES\" : \"NO\";\n}\n", "    const start: number = Math.max(interval1[0],\
    \ interval2[0]);\n    const end: number = Math.min(interval1[1], interval2[1]);\n\
    \    if (start > end) {\n        return \"NO\";\n    }\n    if ((end - start)\
    \ < 2) {\n        return \"YES\";\n    }\n    return isPrime(end - start) ? \"\
    YES\" : \"NO\";\n}\n", "    if (interval1[0] > interval2[1] || interval2[0] >\
    \ interval1[1]) return \"NO\";\n    if (interval1[0] > interval2[0]) {\n     \
    \   const temp = interval1;\n        interval1 = interval2;\n        interval2\
    \ = temp;\n    }\n    const start = interval2[0];\n    const end = Math.min(interval1[1],\
    \ interval2[1]);\n    const len = end - start + 1;\n    for (let i = 2; i < len;\
    \ i++) {\n        if (len % i === 0) return \"NO\";\n    }\n    return \"YES\"\
    ;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
