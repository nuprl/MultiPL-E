name: HumanEval_127_intersection
language: ts
prompt: "//You are given two intervals,\n// where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
  \ which means that the interval (start, end)\n// includes both start and end.\n\
  // For each given interval, it is assumed that its start is less or equal its end.\n\
  // Your task is to determine whether the length of intersection of these two \n\
  // intervals is a prime number.\n// Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n//\
  \ If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
  \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output]\
  \ samples:\n// >>> intersection([1, 2], [2, 3])\n// \"NO\"\n// >>> intersection([-1,\
  \ 1], [0, 4])\n// \"NO\"\n// >>> intersection([-3, -1], [-5, 5])\n// \"YES\"\nfunction\
  \ intersection(interval1: [number, number], interval2: [number, number]): string\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = intersection;\n  assert.deepEqual(candidate([1, 2],\
  \ [2, 3]),\"NO\");\n  assert.deepEqual(candidate([-1, 1], [0, 4]),\"NO\");\n  assert.deepEqual(candidate([-3,\
  \ -1], [-5, 5]),\"YES\");\n  assert.deepEqual(candidate([-2, 2], [-4, 0]),\"YES\"\
  );\n  assert.deepEqual(candidate([-11, 2], [-1, -1]),\"NO\");\n  assert.deepEqual(candidate([1,\
  \ 2], [3, 5]),\"NO\");\n  assert.deepEqual(candidate([1, 2], [1, 2]),\"NO\");\n\
  \  assert.deepEqual(candidate([-2, -2], [-3, -2]),\"NO\");\n}\n\ntest();"
completions: ["  const [min, max] = [Math.max(interval1[0], interval2[0]), Math.min(interval1[1],\
    \ interval2[1])];\n  const length = Math.abs(max - min);\n  const primes = [2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97];\n  if (length < 0) {\n    return \"NO\";\n  }\n  return primes.includes(length)\
    \ ? \"YES\" : \"NO\";\n}\n", "    const [a, b] = interval1;\n    const [c, d]\
    \ = interval2;\n    if (d < a || b < c) return \"NO\";\n    const len = Math.min(b,\
    \ d) - Math.max(a, c) + 1;\n    return isPrime(len) ? \"YES\" : \"NO\";\n}\n",
  "    // it is possible to reduce the solution down to \n    //  return isPrime(Math.abs(interval1[0]\
    \ - interval2[0])) ? \"YES\" : \"NO\";\n    // but it's probably better to make\
    \ sure the numbers are actually intersecting\n    const topLeft = interval1[0]\
    \ > interval2[0] ? interval1[0] : interval2[0];\n    const bottomRight = interval1[1]\
    \ < interval2[1] ? interval1[1] : interval2[1];\n    if (topLeft <= bottomRight)\
    \ {\n        return isPrime(bottomRight - topLeft + 1) ? \"YES\" : \"NO\";\n \
    \   }\n    return \"NO\";\n}\n", "  const start = Math.max(interval1[0], interval2[0]);\n\
    \  const end = Math.min(interval1[1], interval2[1]);\n  if (start > end) {\n \
    \   return \"NO\";\n  }\n  return isPrime(end - start + 1) ? \"YES\" : \"NO\"\
    ;\n}\n", "    let is_prime: boolean = true;\n    const start: number = Math.max(interval1[0],\
    \ interval2[0]);\n    const end: number = Math.min(interval1[1], interval2[1]);\n\
    \    const len: number = end - start;\n    for (let i: number = 2; i < len; i++)\
    \ {\n        if (len % i === 0) {\n            is_prime = false;\n           \
    \ break;\n        }\n    }\n    return is_prime && len > 1 ? \"YES\" : \"NO\"\
    ;\n}\n", "    var [start1, end1] = interval1;\n    var [start2, end2] = interval2;\n\
    \    var start = Math.max(start1, start2);\n    var end = Math.min(end1, end2);\n\
    \    if (start > end) return \"NO\";\n    if (isPrime(end - start + 1)) return\
    \ \"YES\";\n    return \"NO\";\n}", "  let largerStart = 0;\n  let smallerEnd\
    \ = 0;\n  if (interval1[0] > interval2[0]) {\n    largerStart = interval1[0];\n\
    \  } else {\n    largerStart = interval2[0];\n  }\n  if (interval1[1] < interval2[1])\
    \ {\n    smallerEnd = interval1[1];\n  } else {\n    smallerEnd = interval2[1];\n\
    \  }\n  if (largerStart >= smallerEnd) {\n    return \"NO\";\n  }\n  if (isPrime(smallerEnd\
    \ - largerStart + 1)) {\n    return \"YES\";\n  } else {\n    return \"NO\";\n\
    \  }\n}\n", "  const [start1, end1] = interval1;\n  const [start2, end2] = interval2;\n\
    \  if (start1 <= start2 && start2 <= end1) {\n    return isPrime(end1 - start2\
    \ + 1) ? \"YES\" : \"NO\";\n  }\n  if (start2 <= start1 && start1 <= end2) {\n\
    \    return isPrime(end2 - start1 + 1) ? \"YES\" : \"NO\";\n  }\n  return \"NO\"\
    ;\n}\n", "    let result = \"NO\";\n    if (interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]) return result;\n    let start = interval1[0] > interval2[0]\
    \ ? interval1[0] : interval2[0];\n    let end = interval1[1] < interval2[1] ?\
    \ interval1[1] : interval2[1];\n    for (let i = start; i <= end; i++) {\n   \
    \     for (let j = 2; j < i; j++) {\n            if (i % j === 0) {\n        \
    \        result = \"NO\";\n                break;\n            }\n           \
    \ result = \"YES\";\n        }\n    }\n    return result;\n}", "  const start\
    \ = Math.max(interval1[0], interval2[0]);\n  const end = Math.min(interval1[1],\
    \ interval2[1]);\n  if (start > end) {\n    return \"NO\";\n  }\n  const length\
    \ = end - start + 1;\n  for (let i = 2; i < length; i++) {\n    if (length % i\
    \ === 0) {\n      return \"NO\";\n    }\n  }\n  return \"YES\";\n}\n", "  const\
    \ [minI1, maxI1] = interval1.sort((a, b) => a - b);\n  const [minI2, maxI2] =\
    \ interval2.sort((a, b) => a - b);\n  if (minI1 <= minI2 && maxI1 >= minI2) {\n\
    \    const length = maxI1 <= maxI2 ? maxI1 - minI2 : maxI2 - minI2;\n    if (length\
    \ === 1) return \"NO\";\n    for (let i = 2; i < length; i++) {\n      if (length\
    \ % i === 0) return \"NO\";\n    }\n    return \"YES\";\n  }\n  return \"NO\"\
    ;\n}\n", "    let start: number = Math.max(interval1[0], interval2[0]);\n    let\
    \ end: number = Math.min(interval1[1], interval2[1]);\n    let diff: number =\
    \ end - start;\n    if (diff < 0) {\n        return \"NO\";\n    }\n    else if\
    \ (diff === 0) {\n        return \"YES\";\n    }\n    return isPrime(diff + 1)\
    \ ? \"YES\" : \"NO\";\n}", "    let [min, max] = [Math.max(interval1[0], interval2[0]),\
    \ Math.min(interval1[1], interval2[1])];\n    if (min > max) return \"NO\";\n\
    \    if (min == max) return \"YES\";\n    if (min + 1 == max) return \"YES\";\n\
    \    if (isPrime(max - min - 1)) return \"YES\";\n    return \"NO\";\n}\n", " \
    \   // get the lowest start number\n    let start = Math.max(interval1[0], interval2[0]);\n\
    \    // get the highest end number\n    let end = Math.min(interval1[1], interval2[1]);\n\
    \    // if the two intervals don't intersect return \"NO\"\n    if (start > end)\
    \ {\n        return \"NO\";\n    }\n    // if the length of the intersection is\
    \ a prime number, return \"YES\", otherwise, return \"NO\".\n    return isPrime(end\
    \ - start + 1) ? \"YES\" : \"NO\";\n}", "    if(interval1[0] >= interval2[1] ||\
    \ interval2[0] >= interval1[1]) return \"NO\";\n    let lower: number = Math.max(interval1[0],\
    \ interval2[0]);\n    let upper: number = Math.min(interval1[1], interval2[1]);\n\
    \    let dist: number = upper - lower;\n    return isPrime(dist) ? \"YES\" : \"\
    NO\";\n}", "    let result: number[] = [interval1[0], interval1[1], interval2[0],\
    \ interval2[1]].sort((a, b) => a - b);\n    let start: number = result[1];\n \
    \   let end: number = result[2];\n    if (start > end) return \"NO\";\n    return\
    \ isPrime(end - start + 1) ? \"YES\" : \"NO\";\n}\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));\n", "    let small = interval1[0] > interval2[0] ? interval1[0]\
    \ : interval2[0];\n    let big = interval1[1] < interval2[1] ? interval1[1] :\
    \ interval2[1];\n    if (small > big) {\n        return \"NO\";\n    }\n    if\
    \ (small < 2) {\n        return \"NO\";\n    }\n    let len = big - small + 1;\n\
    \    let isPrime = true;\n    for (let i = 2; i < len; i++) {\n        if (len\
    \ % i === 0) {\n            isPrime = false;\n            break;\n        }\n\
    \    }\n    return isPrime ? \"YES\" : \"NO\";\n}\nconsole.log(intersection([-3,\
    \ -1], [-5, 5]));", "  let isPrime = (a: number) => {\n    if (a === 1) return\
    \ false;\n    for (let i = 2; i < a; i++) {\n      if (a % i === 0) return false;\n\
    \    }\n    return true;\n  }\n  let a = Math.max(interval1[0], interval2[0]);\n\
    \  let b = Math.min(interval1[1], interval2[1]);\n  if (a > b) return \"NO\";\n\
    \  return isPrime(b - a + 1) ? \"YES\" : \"NO\";\n}\n", "    const start = Math.max(interval1[0],\
    \ interval2[0]);\n    const end = Math.min(interval1[1], interval2[1]);\n    const\
    \ interval = [start, end];\n    const length = interval[1] - interval[0];\n  \
    \  const primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    const index = primes.indexOf(length);\n\
    \    return (length < 0 || index === -1) ? \"NO\" : \"YES\";\n}\n", "    const\
    \ from: number = Math.max(interval1[0], interval2[0]);\n    const to: number =\
    \ Math.min(interval1[1], interval2[1]);\n    const diff: number = to - from;\n\
    \    if (diff < 0) {\n        return \"NO\";\n    }\n    return (isPrime(diff))\
    \ ? \"YES\" : \"NO\";\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
