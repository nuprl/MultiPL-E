name: HumanEval_136_largest_smallest_integers
language: ts
prompt: "//Create a function that returns an array (a, b), where 'a' is\n// the largest\
  \ of negative integers, and 'b' is the smallest\n// of positive integers in an array.\n\
  // If there is no negative or positive integers, return them as undefined.\n// Examples:\n\
  // >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n// [undefined, 1]\n// >>>\
  \ largest_smallest_integers([])\n// [undefined, undefined]\n// >>> largest_smallest_integers([0])\n\
  // [undefined, undefined]\nfunction largest_smallest_integers(lst: number[]): [number\
  \ | undefined, number | undefined] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = largest_smallest_integers;\n  assert.deepEqual(candidate([2,\
  \ 4, 1, 3, 5, 7]),[undefined, 1]);\n  assert.deepEqual(candidate([2, 4, 1, 3, 5,\
  \ 7, 0]),[undefined, 1]);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2,\
  \ 1]);\n  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);\n  assert.deepEqual(candidate([7,\
  \ 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);\n  assert.deepEqual(candidate([]),[undefined,\
  \ undefined]);\n  assert.deepEqual(candidate([0]),[undefined, undefined]);\n  assert.deepEqual(candidate([-1,\
  \ -3, -5, -6]),[-1, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6,\
  \ 0]),[-1, undefined]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3,\
  \ 1]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);\n}\n\n\
  test();"
completions: ["    let a: number | undefined = undefined\n    let b: number | undefined\
    \ = undefined\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i]\
    \ > 0) {\n            if (b === undefined) {\n                b = lst[i]\n   \
    \         } else if (lst[i] < b) {\n                b = lst[i]\n            }\n\
    \        } else if (lst[i] < 0) {\n            if (a === undefined) {\n      \
    \          a = lst[i]\n            } else if (lst[i] > a) {\n                a\
    \ = lst[i]\n            }\n        }\n    }\n    return [a, b]\n}\n", "    if\
    \ (lst.length === 0) return [undefined, undefined];\n    return [Math.max(...lst.filter(x\
    \ => x < 0)), Math.min(...lst.filter(x => x > 0))];\n}\n", "    // Your code here\n\
    \    let max_neg: number | undefined = undefined;\n    let min_pos: number | undefined\
    \ = undefined;\n    for (let i of lst) {\n        if (i < 0) {\n            if\
    \ (max_neg == undefined) {\n                max_neg = i;\n            } else if\
    \ (i > max_neg) {\n                max_neg = i;\n            }\n        } else\
    \ if (i > 0) {\n            if (min_pos == undefined) {\n                min_pos\
    \ = i;\n            } else if (i < min_pos) {\n                min_pos = i;\n\
    \            }\n        }\n    }\n    return [max_neg, min_pos];\n}\n", "    const\
    \ mapped = lst.map( x => [x > 0, x]);\n    let smallest: number | undefined;\n\
    \    let largest: number | undefined;\n    for (const pair of mapped) {\n    \
    \    if (pair[0]) {\n            if (smallest === undefined || pair[1] < smallest)\
    \ {\n                smallest = pair[1];\n            }\n        } else {\n  \
    \          if (largest === undefined || pair[1] > largest) {\n               \
    \ largest = pair[1];\n            }\n        }\n    }\n    return [largest, smallest];\n\
    }\n", "    var largest_negative: number | undefined;\n    var smallest_positive:\
    \ number | undefined;\n    for (var i = 0; i < lst.length; i++) {\n        if\
    \ (lst[i] < 0) {\n            if (largest_negative === undefined) {\n        \
    \        largest_negative = lst[i];\n            } else if (lst[i] > largest_negative)\
    \ {\n                largest_negative = lst[i];\n            }\n        } else\
    \ if (lst[i] > 0) {\n            if (smallest_positive === undefined) {\n    \
    \            smallest_positive = lst[i];\n            } else if (lst[i] < smallest_positive)\
    \ {\n                smallest_positive = lst[i];\n            }\n        }\n \
    \   }\n    return [largest_negative, smallest_positive];\n}\n\n", "  let max_negative:\
    \ number | undefined = undefined;\n  let min_positive: number | undefined = undefined;\n\
    \  for (let num of lst) {\n    if (num < 0) {\n      if (max_negative == undefined\
    \ || num > max_negative) {\n        max_negative = num;\n      }\n    } else if\
    \ (num > 0) {\n      if (min_positive == undefined || num < min_positive) {\n\
    \        min_positive = num;\n      }\n    }\n  }\n  return [max_negative, min_positive];\n\
    }", "    // create two variables for tracking the highest negative and lowest\
    \ positive\n    let highestNegative = undefined;\n    let lowestPositive = undefined;\n\
    \    // loop through the array, updating the variables as necessary\n    for (let\
    \ i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n            if (highestNegative\
    \ === undefined || lst[i] > highestNegative) {\n                highestNegative\
    \ = lst[i];\n            }\n        } else if (lst[i] > 0) {\n            if (lowestPositive\
    \ === undefined || lst[i] < lowestPositive) {\n                lowestPositive\
    \ = lst[i];\n            }\n        }\n    }\n    // return a tuple (immutable\
    \ ordered list of length 2) containing the variables\n    return [highestNegative,\
    \ lowestPositive];\n}\n", "    const pos = lst.filter(x => x > 0);\n    const\
    \ neg = lst.filter(x => x < 0);\n    return [neg.length > 0 ? Math.max(...neg)\
    \ : undefined, pos.length > 0 ? Math.min(...pos) : undefined];\n}\n\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));\n",
  "    if (lst.length == 0) {\n        return [undefined, undefined];\n    }\n   \
    \ if (lst.length == 1) {\n        return [undefined, undefined];\n    }\n    if\
    \ (lst.length == 2) {\n        return [undefined, undefined];\n    }\n    let\
    \ neg = -Number.MAX_VALUE;\n    let pos = Number.MAX_VALUE;\n    let flag1 = false;\n\
    \    let flag2 = false;\n    for (let i = 0; i < lst.length; i++) {\n        if\
    \ (lst[i] > 0) {\n            if (lst[i] < pos) {\n                pos = lst[i];\n\
    \                flag2 = true;\n            }\n        }\n        if (lst[i] <\
    \ 0) {\n            if (lst[i] > neg) {\n                neg = lst[i];\n     \
    \           flag1 = true;\n            }\n        }\n    }\n    return [flag1\
    \ ? neg : undefined, flag2 ? pos : undefined];\n}\n", "    let min: number | undefined\
    \ = undefined;\n    let max: number | undefined = undefined;\n    for (let n of\
    \ lst) {\n        if (min === undefined && n > 0) {\n            min = n;\n  \
    \      }\n        if (max === undefined && n < 0) {\n            max = n;\n  \
    \      }\n        if (n > 0 && n < min) {\n            min = n;\n        }\n \
    \       if (n < 0 && n > max) {\n            max = n;\n        }\n    }\n    return\
    \ [max, min];\n}\n", "  let negative: number[] = [];\n  let positive: number[]\
    \ = [];\n  lst.forEach(function (num) {\n    if (num > 0) {\n      positive.push(num);\n\
    \    } else if (num < 0) {\n      negative.push(num);\n    }\n  });\n  negative.sort(function\
    \ (a, b) {\n    return a - b;\n  });\n  positive.sort(function (a, b) {\n    return\
    \ a - b;\n  });\n  if (negative.length > 0 && positive.length > 0) {\n    return\
    \ [negative[0], positive[0]];\n  } else if (negative.length > 0) {\n    return\
    \ [negative[0], undefined];\n  } else if (positive.length > 0) {\n    return [undefined,\
    \ positive[0]];\n  } else {\n    return [undefined, undefined];\n  }\n}\n", " \
    \   //TODO: implement function\n    return [undefined, undefined];\n}\n", "  const\
    \ positive = lst.filter(i => i > 0);\n  const negative = lst.filter(i => i < 0);\n\
    \  return [\n    negative.length == 0 ? undefined : Math.max(...negative),\n \
    \   positive.length == 0 ? undefined : Math.min(...positive)\n  ];\n}", "    if\
    \ (lst.length == 0) {\n        return [undefined, undefined];\n    }\n    let\
    \ highestNegative = Number.MIN_SAFE_INTEGER;\n    let lowestPositive = Number.MAX_SAFE_INTEGER;\n\
    \    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0 && lst[i]\
    \ > highestNegative) {\n            highestNegative = lst[i];\n        }\n   \
    \     if (lst[i] > 0 && lst[i] < lowestPositive) {\n            lowestPositive\
    \ = lst[i];\n        }\n    }\n    if (highestNegative == Number.MIN_SAFE_INTEGER)\
    \ {\n        highestNegative = undefined;\n    }\n    if (lowestPositive == Number.MAX_SAFE_INTEGER)\
    \ {\n        lowestPositive = undefined;\n    }\n    return [highestNegative,\
    \ lowestPositive];\n}\n", "    return [undefined, undefined];\n}\n", "    if (lst.length\
    \ === 0) {\n        return [undefined, undefined];\n    }\n    let high = Math.max(...lst);\n\
    \    let low = Math.min(...lst);\n    let lowCheck = 0;\n    let highCheck = 0;\n\
    \    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n     \
    \       lowCheck++;\n        }\n        if (lst[i] > 0) {\n            highCheck++;\n\
    \        }\n    }\n    if (lowCheck === 0) {\n        low = undefined;\n    }\n\
    \    if (highCheck === 0) {\n        high = undefined;\n    }\n    return [high,\
    \ low];\n}\n", "    let largestNegativeInteger: number | undefined;\n    let smallestPositiveInteger:\
    \ number | undefined;\n    for (let i = 0; i < lst.length; i++) {\n        if\
    \ (lst[i] < 0) {\n            if (largestNegativeInteger === undefined) {\n  \
    \              largestNegativeInteger = lst[i];\n            } else if (lst[i]\
    \ > largestNegativeInteger) {\n                largestNegativeInteger = lst[i];\n\
    \            }\n        } else if (lst[i] > 0) {\n            if (smallestPositiveInteger\
    \ === undefined) {\n                smallestPositiveInteger = lst[i];\n      \
    \      } else if (lst[i] < smallestPositiveInteger) {\n                smallestPositiveInteger\
    \ = lst[i];\n            }\n        }\n    }\n    return [largestNegativeInteger,\
    \ smallestPositiveInteger];\n}\n", "    return [undefined, undefined];\n}\n",
  "    var small = 0;\n    var big = 0;\n    if (lst.length == 0) {\n        return\
    \ [undefined, undefined];\n    }\n    if (lst.length == 1) {\n        return [undefined,\
    \ undefined];\n    }\n    small = lst[0];\n    big = lst[0];\n    for (var i =\
    \ 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (small\
    \ > lst[i]) {\n                small = lst[i];\n            }\n        }\n   \
    \     if (lst[i] < 0) {\n            if (big < lst[i]) {\n                big\
    \ = lst[i];\n            }\n        }\n    }\n    return [big, small];\n}\n",
  "    // CODE GOES HERE\n    if (lst.length === 0) {\n        return [undefined,\
    \ undefined];\n    }\n    if (lst.length === 1) {\n        return [undefined,\
    \ undefined];\n    }\n    if (lst.length === 2) {\n        if (lst[0] < 0 && lst[1]\
    \ > 0) {\n            return [lst[0], lst[1]];\n        }\n        if (lst[0]\
    \ > 0 && lst[1] < 0) {\n            return [lst[1], lst[0]];\n        }\n    \
    \    return [undefined, undefined];\n    }\n    const positives = lst.filter(function\
    \ (x) {\n        return x > 0;\n    });\n    const negatives = lst.filter(function\
    \ (x) {\n        return x < 0;\n    });\n    if (positives.length === 0 || negatives.length\
    \ === 0) {\n        return [undefined, undefined];\n    }\n    return [Math.max(...negatives),\
    \ Math.min(...positives)];\n}\n", "    if (lst.length === 0) {\n        return\
    \ [undefined, undefined];\n    }\n    const pos = lst.filter(x => x > 0);\n  \
    \  const neg = lst.filter(x => x < 0);\n    return [\n        neg.length > 0 ?\
    \ neg.reduce((x, y) => Math.max(x, y)) : undefined,\n        pos.length > 0 ?\
    \ pos.reduce((x, y) => Math.min(x, y)) : undefined\n    ];\n}\n", "    const asc\
    \ = lst.slice().sort((a, b) => a - b);\n    const desc = lst.slice().sort((a,\
    \ b) => b - a);\n    const smallest = asc.find(i => i > 0);\n    const largest\
    \ = desc.find(i => i < 0);\n    return [largest, smallest];\n}\n", "    // Write\
    \ code here to return the answer.\n    return [undefined, undefined];\n}\n", " \
    \   let neg_min = Number.MIN_SAFE_INTEGER;\n    let pos_max = Number.MAX_SAFE_INTEGER;\n\
    \    let neg_max: number | undefined = undefined;\n    let pos_min: number | undefined\
    \ = undefined;\n    for (let i = 0; i < lst.length; i++) {\n        let item =\
    \ lst[i];\n        if (item > 0) {\n            if (item < pos_max) {\n      \
    \          pos_max = item;\n                pos_min = item;\n            }\n \
    \       } else if (item < 0) {\n            if (item > neg_min) {\n          \
    \      neg_min = item;\n                neg_max = item;\n            }\n     \
    \   }\n    }\n    return [neg_max, pos_min];\n}\n", "    let smallest_positive:\
    \ number | undefined = undefined;\n    let largest_negative: number | undefined\
    \ = undefined;\n    for (let n of lst) {\n        if (n > 0) {\n            if\
    \ (smallest_positive === undefined || n < smallest_positive) {\n             \
    \   smallest_positive = n;\n            }\n        } else if (n < 0) {\n     \
    \       if (largest_negative === undefined || n > largest_negative) {\n      \
    \          largest_negative = n;\n            }\n        }\n    }\n    return\
    \ [largest_negative, smallest_positive];\n}\n\nassert_equals(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]), [undefined, 1]);\nassert_equals(largest_smallest_integers([]),\
    \ [undefined, undefined]);\nassert_equals(largest_smallest_integers([0]), [undefined,\
    \ undefined]);\nassert_equals(largest_smallest_integers([-1, -2, -3, -4, -5]),\
    \ [-1, undefined]);\nassert_equals(largest_smallest_integers([1, 2, 3, 4, 5]),\
    \ [undefined, 1]);\nassert_equals(largest_smallest_integers([-1, -1, -1, -1, -1]),\
    \ [-1, undefined]);\nassert_equals(largest_smallest_integers([1, 1, 1, 1, 1]),\
    \ [undefined, 1]);\n", "    let min: number | undefined;\n    let max: number\
    \ | undefined;\n    for (let item of lst) {\n        if (item > 0) {\n       \
    \     if (max == undefined || item > max) {\n                max = item;\n   \
    \         }\n        } else if (item < 0) {\n            if (min == undefined\
    \ || item < min) {\n                min = item;\n            }\n        }\n  \
    \  }\n    return [min, max];\n}\n", "    return [undefined, undefined];\n}\n",
  "    if (lst.length === 0) return [undefined, undefined];\n    const sorted = lst.sort((a,\
    \ b) => a - b);\n    return [sorted[0], sorted[sorted.length - 1]];\n}\n", " \
    \   let smallest = undefined;\n    let largest = undefined;\n    for (let n of\
    \ lst) {\n        if (n > 0) {\n            if (smallest === undefined || n <\
    \ smallest) {\n                smallest = n;\n            }\n        } else if\
    \ (n < 0) {\n            if (largest === undefined || n > largest) {\n       \
    \         largest = n;\n            }\n        }\n    }\n    return [largest,\
    \ smallest];\n}\n", "  let smallest = undefined;\n  let largest = undefined;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (smallest === undefined && lst[i]\
    \ > 0) {\n      smallest = lst[i];\n    }\n    if (lst[i] > 0 && lst[i] < smallest)\
    \ {\n      smallest = lst[i];\n    }\n    if (largest === undefined && lst[i]\
    \ < 0) {\n      largest = lst[i];\n    }\n    if (lst[i] < 0 && lst[i] > largest)\
    \ {\n      largest = lst[i];\n    }\n  }\n  return [largest, smallest];\n}\n\n\
    console.log(largest_smallest_integers([2, 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\n\
    console.log(largest_smallest_integers([0]));\n", "    let a: number | undefined;\n\
    \    let b: number | undefined;\n    for (let i of lst) {\n        if (i > 0)\
    \ {\n            if (b === undefined) {\n                b = i;\n            }\
    \ else if (i < b) {\n                b = i;\n            }\n        } else if\
    \ (i < 0) {\n            if (a === undefined) {\n                a = i;\n    \
    \        } else if (i > a) {\n                a = i;\n            }\n        }\n\
    \    }\n    return [a, b];\n}\n", "  if (lst.length === 0) {\n    return [undefined,\
    \ undefined];\n  }\n  if (lst.length === 1) {\n    return [undefined, undefined];\n\
    \  }\n  if (lst.length === 2) {\n    if (lst[0] > 0 && lst[1] > 0) {\n      return\
    \ [undefined, Math.min(lst[0], lst[1])];\n    }\n    if (lst[0] < 0 && lst[1]\
    \ < 0) {\n      return [Math.max(lst[0], lst[1]), undefined];\n    }\n    if (lst[0]\
    \ > 0 && lst[1] < 0) {\n      return [lst[1], lst[0]];\n    }\n    if (lst[0]\
    \ < 0 && lst[1] > 0) {\n      return [lst[0], lst[1]];\n    }\n  }\n  if (lst.length\
    \ > 2) {\n    let neg: number[] = [];\n    let pos: number[] = [];\n    for (let\
    \ i = 0; i < lst.length; i++) {\n      if (lst[i] > 0) {\n        pos.push(lst[i]);\n\
    \      }\n      if (lst[i] < 0) {\n        neg.push(lst[i]);\n      }\n    }\n\
    \    if (neg.length === 0) {\n      return [undefined, Math.min(...pos)];\n  \
    \  }\n    if (pos.length === 0) {\n      return [Math.max(...neg), undefined];\n\
    \    }\n    return [Math.max(...neg), Math.min(...pos)];\n  }\n}\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));\n\
    console.log(largest_smallest_integers([0, 0]));\nconsole.log(largest_smallest_integers([-1,\
    \ 0]));\n", "    let min_pos = Number.MAX_VALUE;\n    let max_neg = Number.MIN_VALUE;\n\
    \    lst.forEach(element => {\n        if (element > 0 && element < min_pos) {\n\
    \            min_pos = element;\n        }\n        if (element < 0 && element\
    \ > max_neg) {\n            max_neg = element;\n        }\n    });\n    if (min_pos\
    \ != Number.MAX_VALUE && max_neg != Number.MIN_VALUE) {\n        return [max_neg,\
    \ min_pos];\n    }\n    return [undefined, undefined];\n}\n", "    // replace\
    \ me\n    return [undefined, undefined];\n}\n", "    let largest_negative = Number.NEGATIVE_INFINITY;\n\
    \    let smallest_positive = Number.POSITIVE_INFINITY;\n    for (let value of\
    \ lst) {\n        if (value < 0 && value > largest_negative) {\n            largest_negative\
    \ = value;\n        }\n        if (value > 0 && value < smallest_positive) {\n\
    \            smallest_positive = value;\n        }\n    }\n    return [largest_negative\
    \ == Number.NEGATIVE_INFINITY ? undefined : largest_negative, smallest_positive\
    \ == Number.POSITIVE_INFINITY ? undefined : smallest_positive];\n}\n", "  let\
    \ neg: number | undefined;\n  let pos: number | undefined;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (neg) {\n        neg\
    \ = Math.max(neg, lst[i]);\n      } else {\n        neg = lst[i];\n      }\n \
    \   } else if (lst[i] > 0) {\n      if (pos) {\n        pos = Math.min(pos, lst[i]);\n\
    \      } else {\n        pos = lst[i];\n      }\n    }\n  }\n  return [neg, pos];\n\
    }\n", "  return [\n    lst.length === 0 ? undefined : lst.reduce((acc: number,\
    \ curr: number) => curr < 0 && acc < curr ? curr : acc),\n    lst.length === 0\
    \ ? undefined : lst.reduce((acc: number, curr: number) => curr > 0 && acc > curr\
    \ ? curr : acc)\n  ];\n}\n", "    if (!lst || lst.length === 0) {\n        return\
    \ [undefined, undefined];\n    }\n\n    const positive = [];\n    const negative\
    \ = [];\n\n    for (const x of lst) {\n        if (x >= 0) {\n            positive.push(x);\n\
    \        } else {\n            negative.push(x);\n        }\n    }\n\n    return\
    \ [negative.length > 0 ? Math.max(...negative) : undefined, positive.length >\
    \ 0 ? Math.min(...positive) : undefined];\n}\n", "    let a: number | undefined\
    \ = undefined;\n    let b: number | undefined = undefined;\n    let len = lst.length;\n\
    \    if (len === 0) {\n        return [a, b];\n    }\n    a = lst[0];\n    b =\
    \ lst[0];\n    for (let i = 1; i < len; i++) {\n        if (lst[i] > 0) {\n  \
    \          if (b === undefined || lst[i] < b) {\n                b = lst[i];\n\
    \            }\n        } else {\n            if (a === undefined || lst[i] >\
    \ a) {\n                a = lst[i];\n            }\n        }\n    }\n    return\
    \ [a, b];\n}\n", "    //First, we want to filter out all the negative numbers.\n\
    \    // Then, we want to filter out all the non-negative numbers.\n    // After\
    \ that, we need to get the largest of the negatives, and the smallest of the positives.\n\
    \    // Then, we need to return the result in an array as [largest of negatives,\
    \ smallest of positives].\n    const negatives = lst.filter(i => i < 0);\n   \
    \ const positives = lst.filter(i => i >= 0);\n    if (negatives.length > 0 &&\
    \ positives.length > 0) {\n        const largest_of_negatives = negatives.reduce((acc,\
    \ val) => Math.max(acc, val));\n        const smallest_of_positives = positives.reduce((acc,\
    \ val) => Math.min(acc, val));\n        return [largest_of_negatives, smallest_of_positives];\n\
    \    } else {\n        return [undefined, undefined];\n    }\n}", "    let negative:\
    \ number | undefined = undefined;\n    let positive: number | undefined = undefined;\n\
    \    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n     \
    \       if (negative == undefined) {\n                negative = lst[i];\n   \
    \         } else if (lst[i] > negative) {\n                negative = lst[i];\n\
    \            }\n        } else if (lst[i] > 0) {\n            if (positive ==\
    \ undefined) {\n                positive = lst[i];\n            } else if (lst[i]\
    \ < positive) {\n                positive = lst[i];\n            }\n        }\n\
    \    }\n    return [negative, positive];\n}\n", "    // TODO: Implement the function\n\
    \    throw new Error(\"Not implemented\");\n}\n\n", "  const negative = lst.filter(x\
    \ => x < 0);\n  const positive = lst.filter(x => x > 0);\n  return [negative.length\
    \ > 0 ? Math.max(...negative) : undefined, positive.length > 0 ? Math.min(...positive)\
    \ : undefined];\n}\n", "    let biggest_neg = undefined;\n    let smallest_pos\
    \ = undefined;\n    for (let i = 0; i < lst.length; i++) {\n        let x = lst[i];\n\
    \        if (x < 0) {\n            if (biggest_neg == undefined || x > biggest_neg)\
    \ {\n                biggest_neg = x;\n            }\n        } else if (x > 0)\
    \ {\n            if (smallest_pos == undefined || x < smallest_pos) {\n      \
    \          smallest_pos = x;\n            }\n        }\n    }\n    return [biggest_neg,\
    \ smallest_pos];\n}\n", "    let smallest: number | undefined = undefined;\n \
    \   let largest: number | undefined = undefined;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        if (lst[i] < 0) {\n            if (largest === undefined ||\
    \ lst[i] > largest) {\n                largest = lst[i];\n            }\n    \
    \    } else if (lst[i] > 0) {\n            if (smallest === undefined || lst[i]\
    \ < smallest) {\n                smallest = lst[i];\n            }\n        }\n\
    \    }\n    return [largest, smallest];\n}\n", "    let minPos: number | undefined\
    \ = undefined;\n    let maxNeg: number | undefined = undefined;\n    for (let\
    \ i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (minPos\
    \ == undefined || lst[i] < minPos) {\n                minPos = lst[i];\n     \
    \       }\n        } else if (lst[i] < 0) {\n            if (maxNeg == undefined\
    \ || lst[i] > maxNeg) {\n                maxNeg = lst[i];\n            }\n   \
    \     }\n    }\n    return [maxNeg, minPos];\n}\n", "    let max: number = Number.MIN_SAFE_INTEGER;\n\
    \    let min: number = Number.MAX_SAFE_INTEGER;\n    for (let num of lst) {\n\
    \        if (num > 0 && num < min) {\n            min = num;\n        }\n    \
    \    if (num < 0 && num > max) {\n            max = num;\n        }\n    }\n \
    \   return [max === Number.MIN_SAFE_INTEGER ? undefined : max, min === Number.MAX_SAFE_INTEGER\
    \ ? undefined : min];\n}\n\n", "    const negatives = lst.filter(value => value\
    \ < 0).sort((a, b) => a - b);\n    const positives = lst.filter(value => value\
    \ > 0).sort((a, b) => a - b);\n    if (negatives.length > 0 && positives.length\
    \ > 0) {\n        return [negatives[negatives.length - 1], positives[0]];\n  \
    \  } else {\n        return [undefined, undefined];\n    }\n}\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));",
  "    const sortedPositiveNumbers = lst.filter(n => n > 0).sort((a, b) => a - b);\n\
    \    const sortedNegativeNumbers = lst.filter(n => n < 0).sort((a, b) => b - a);\n\
    \    return [sortedNegativeNumbers[0], sortedPositiveNumbers[0]];\n}\n", "  let\
    \ small: number | undefined;\n  let large: number | undefined;\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    if (small === undefined && lst[i] < 0) {\n  \
    \    small = lst[i];\n    } else if (lst[i] < 0 && lst[i] > small) {\n      small\
    \ = lst[i];\n    }\n    if (large === undefined && lst[i] > 0) {\n      large\
    \ = lst[i];\n    } else if (lst[i] > 0 && lst[i] < large) {\n      large = lst[i];\n\
    \    }\n  }\n  return [small, large];\n}\n", "    let l = new Array<number>();\n\
    \    let s = new Array<number>();\n    for (let i = 0; i < lst.length; i++) {\n\
    \        if (lst[i] < 0) {\n            l.push(lst[i]);\n        }\n        if\
    \ (lst[i] > 0) {\n            s.push(lst[i]);\n        }\n    }\n    l.sort(function\
    \ (a, b) { return b - a });\n    s.sort(function (a, b) { return a - b });\n \
    \   return [l[0], s[0]];\n}\n", "    const negative_max: number | undefined =\
    \ Math.max(...lst.filter(x => x < 0));\n    const positive_min: number | undefined\
    \ = Math.min(...lst.filter(x => x > 0));\n    return [negative_max, positive_min];\n\
    }\n\nconsole.log(largest_smallest_integers([2, 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\n\
    console.log(largest_smallest_integers([0]));\n", "  const negatives = lst.filter(x\
    \ => x < 0).sort((a, b) => a - b);\n  const positives = lst.filter(x => x > 0).sort((a,\
    \ b) => a - b);\n  if (negatives.length > 0 && positives.length > 0) {\n    return\
    \ [negatives[negatives.length - 1], positives[0]];\n  } else {\n    return [undefined,\
    \ undefined];\n  }\n}\n", "    if (lst.length == 0) {\n        return [undefined,\
    \ undefined];\n    }\n    if (lst.length == 1) {\n        return [undefined, undefined];\n\
    \    }\n    if (lst.length == 2) {\n        return [undefined, undefined];\n \
    \   }\n    let max_negative: number | undefined = undefined;\n    let min_positive:\
    \ number | undefined = undefined;\n    for (let i = 0; i < lst.length; i++) {\n\
    \        if (lst[i] < 0) {\n            if (max_negative == undefined) {\n   \
    \             max_negative = lst[i];\n            } else {\n                if\
    \ (lst[i] > max_negative) {\n                    max_negative = lst[i];\n    \
    \            }\n            }\n        }\n        if (lst[i] > 0) {\n        \
    \    if (min_positive == undefined) {\n                min_positive = lst[i];\n\
    \            } else {\n                if (lst[i] < min_positive) {\n        \
    \            min_positive = lst[i];\n                }\n            }\n      \
    \  }\n    }\n    return [max_negative, min_positive];\n}\n", "    if (lst.length\
    \ === 0) {\n        return [undefined, undefined];\n    }\n    let pos_min = lst[0];\n\
    \    let neg_max = lst[0];\n    for (let i = 0; i < lst.length; i++) {\n     \
    \   if (lst[i] > 0) {\n            if (lst[i] < pos_min) {\n                pos_min\
    \ = lst[i];\n            }\n        } else {\n            if (lst[i] > neg_max)\
    \ {\n                neg_max = lst[i];\n            }\n        }\n    }\n    return\
    \ [neg_max === 0 ? undefined : neg_max, pos_min === 0 ? undefined : pos_min];\n\
    }\n", "    let small = lst[0];\n    let big = lst[0];\n    let status = true;\n\
    \    let hasNeg = false;\n    let hasPos = false;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        if (lst[i] < 0) {\n            hasNeg = true;\n            if\
    \ (lst[i] > big) {\n                big = lst[i];\n            }\n        }\n\
    \        if (lst[i] > 0) {\n            hasPos = true;\n            if (lst[i]\
    \ < small) {\n                small = lst[i];\n            }\n        }\n    }\n\
    \    if (hasNeg && hasPos) {\n        return [big, small];\n    } else if (hasNeg)\
    \ {\n        return [big, undefined];\n    } else if (hasPos) {\n        return\
    \ [undefined, small];\n    } else {\n        return [undefined, undefined];\n\
    \    }\n}\n", "    const negatives = lst.filter(n => n < 0);\n    const positives\
    \ = lst.filter(n => n > 0);\n    const negativesMax = negatives.length ? Math.max(...negatives)\
    \ : undefined;\n    const positivesMin = positives.length ? Math.min(...positives)\
    \ : undefined;\n    return [negativesMax, positivesMin];\n}\n", "    return [undefined,\
    \ undefined];\n}\n", "  let smallest_pos: number | undefined = undefined;\n  let\
    \ largest_neg: number | undefined = undefined;\n  lst.forEach(i => {\n    if (i\
    \ > 0) {\n      if (smallest_pos === undefined || i < smallest_pos) {\n      \
    \  smallest_pos = i;\n      }\n    } else if (i < 0) {\n      if (largest_neg\
    \ === undefined || i > largest_neg) {\n        largest_neg = i;\n      }\n   \
    \ }\n  });\n  return [largest_neg, smallest_pos];\n}\n", "  // if the list is\
    \ empty, return [undefined, undefined]\n  if (lst.length === 0) {\n    return\
    \ [undefined, undefined];\n  }\n\n  let smallest: number | undefined = undefined;\n\
    \  let largest: number | undefined = undefined;\n\n  for (let num of lst) {\n\
    \    if (num > 0) {\n      if (smallest === undefined || num < smallest) {\n \
    \       smallest = num;\n      }\n    } else if (num < 0) {\n      if (largest\
    \ === undefined || num > largest) {\n        largest = num;\n      }\n    }\n\
    \  }\n\n  return [largest, smallest];\n}\n", "    let pos_arr: number[] = []\n\
    \    let neg_arr: number[] = []\n    let output: [number | undefined, number |\
    \ undefined] = [undefined, undefined]\n    if (lst.length === 0) {\n        return\
    \ output\n    }\n    for (let i of lst) {\n        if (i > 0) {\n            pos_arr.push(i)\n\
    \        } else if (i < 0) {\n            neg_arr.push(i)\n        }\n    }\n\
    \    if (pos_arr.length > 0) {\n        output[1] = Math.min(...pos_arr)\n   \
    \ }\n    if (neg_arr.length > 0) {\n        output[0] = Math.max(...neg_arr)\n\
    \    }\n    return output\n}\n", "    let n = lst.length;\n    let a = undefined;\n\
    \    let b = undefined;\n    if (n == 0) {\n        return [a, b];\n    } else\
    \ {\n        lst.sort((x, y) => x - y);\n        for (let i = 0; i < n; i++) {\n\
    \            if (lst[i] < 0) {\n                a = lst[i];\n            } else\
    \ {\n                b = lst[i];\n                break;\n            }\n    \
    \    }\n        return [a, b];\n    }\n}\n\nconsole.log(largest_smallest_integers([]));\n\
    console.log(largest_smallest_integers([0]));\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([-2, -4, -1, -3, -5,\
    \ -7]));\nconsole.log(largest_smallest_integers([-2, -4, -1, -3, -5, -7, 2, 4,\
    \ 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([-2, -4, -1, -3, -5, -7,\
    \ 2, 4, 1, 3, 5, 7, -2, -4, -1, -3, -5, -7, 2, 4, 1, 3, 5, 7]));\n", "    return\
    \ [lst.reduce((r, c) => c < 0 && r < c ? c : r, lst[0]), lst.reduce((r, c) =>\
    \ c > 0 && r > c ? c : r, lst[0])];\n}\n", "    // TODO: implement function\n\
    \    return [undefined, undefined];\n}\n", "    const pos = lst.filter(n => n\
    \ > 0);\n    const neg = lst.filter(n => n < 0);\n    return [neg.length > 0 ?\
    \ Math.max(...neg) : undefined, pos.length > 0 ? Math.min(...pos) : undefined];\n\
    }\n", "  const negs = lst.filter(x => x < 0).sort((a, b) => b - a);\n  const pos\
    \ = lst.filter(x => x > 0).sort((a, b) => a - b);\n  return [negs[0], pos[0]];\n\
    }\n", "    let largest = undefined;\n    let smallest = undefined;\n    for (let\
    \ num of lst) {\n        if (num < 0) {\n            if (largest == undefined\
    \ || num > largest) {\n                largest = num;\n            }\n       \
    \ } else if (num > 0) {\n            if (smallest == undefined || num < smallest)\
    \ {\n                smallest = num;\n            }\n        }\n    }\n    return\
    \ [largest, smallest];\n}\n", "    if (lst.length === 0) {\n        return [undefined,\
    \ undefined];\n    }\n    if (lst.length === 1) {\n        return [undefined,\
    \ undefined];\n    }\n    let currentMaxNeg = undefined;\n    let currentMinPos\
    \ = undefined;\n    for (let elem of lst) {\n        if (elem < 0) {\n       \
    \     if (currentMaxNeg === undefined) {\n                currentMaxNeg = elem;\n\
    \            } else {\n                if (elem > currentMaxNeg) {\n         \
    \           currentMaxNeg = elem;\n                }\n            }\n        }\
    \ else {\n            if (currentMinPos === undefined) {\n                currentMinPos\
    \ = elem;\n            } else {\n                if (elem < currentMinPos) {\n\
    \                    currentMinPos = elem;\n                }\n            }\n\
    \        }\n    }\n    return [currentMaxNeg, currentMinPos];\n}\ntest(\"test\
    \ largest_smallest_integers\", () => {\n    expect(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])).toEqual([undefined, 1]);\n    expect(largest_smallest_integers([])).toEqual([undefined,\
    \ undefined]);\n    expect(largest_smallest_integers([0])).toEqual([undefined,\
    \ undefined]);\n    expect(largest_smallest_integers([1, 4, -2, 3, 5, -7])).toEqual([-2,\
    \ 1]);\n    expect(largest_smallest_integers([-1, -4, -2, -3, -5, -7])).toEqual([-1,\
    \ undefined]);\n    expect(largest_smallest_integers([1, 4, 2, 3, 5, 7])).toEqual([undefined,\
    \ 1]);\n});\n", "    let smallest_positive: number | undefined;\n    let largest_negative:\
    \ number | undefined;\n    for (let i = 0; i < lst.length; i++) {\n        const\
    \ element = lst[i];\n        if (element > 0) {\n            if (smallest_positive\
    \ === undefined || element < smallest_positive) {\n                smallest_positive\
    \ = element;\n            }\n        } else if (element < 0) {\n            if\
    \ (largest_negative === undefined || element > largest_negative) {\n         \
    \       largest_negative = element;\n            }\n        }\n    }\n    return\
    \ [largest_negative, smallest_positive];\n}\n", "  const positives = lst.filter(x\
    \ => x > 0);\n  const negatives = lst.filter(x => x < 0);\n  const smallest_positive\
    \ = positives.length > 0 ? Math.min(...positives) : undefined;\n  const largest_negative\
    \ = negatives.length > 0 ? Math.max(...negatives) : undefined;\n  return [largest_negative,\
    \ smallest_positive];\n}\n", "    let smallestPositiveInteger: number | undefined\
    \ = undefined;\n    let largestNegativeInteger: number | undefined = undefined;\n\
    \    let seenPositive: boolean = false;\n    let seenNegative: boolean = false;\n\
    \    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n     \
    \       if (!seenNegative) {\n                largestNegativeInteger = lst[i];\n\
    \                seenNegative = true;\n            } else {\n                if\
    \ (lst[i] > largestNegativeInteger) {\n                    largestNegativeInteger\
    \ = lst[i];\n                }\n            }\n        } else if (lst[i] > 0)\
    \ {\n            if (!seenPositive) {\n                smallestPositiveInteger\
    \ = lst[i];\n                seenPositive = true;\n            } else {\n    \
    \            if (lst[i] < smallestPositiveInteger) {\n                    smallestPositiveInteger\
    \ = lst[i];\n                }\n            }\n        }\n    }\n    return [largestNegativeInteger,\
    \ smallestPositiveInteger];\n}\n\n", "    // Write your code here\n    let smallest:\
    \ number | undefined;\n    let largest: number | undefined;\n    let check: boolean\
    \ = false;\n    let check1: boolean = false;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        if (lst[i] < 0) {\n            if (largest === undefined) {\n\
    \                largest = lst[i];\n            } else if (largest < lst[i]) {\n\
    \                largest = lst[i];\n            }\n            check = true;\n\
    \        } else if (lst[i] > 0) {\n            if (smallest === undefined) {\n\
    \                smallest = lst[i];\n            } else if (smallest > lst[i])\
    \ {\n                smallest = lst[i];\n            }\n            check1 = true;\n\
    \        }\n    }\n    if (check === false) {\n        largest = undefined;\n\
    \    }\n    if (check1 === false) {\n        smallest = undefined;\n    }\n  \
    \  return [largest, smallest];\n}\n", "    let largestNeg: number | undefined;\n\
    \    let smallestPos: number | undefined;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        if (lst[i] < 0) {\n            if (largestNeg === undefined\
    \ || lst[i] > largestNeg) {\n                largestNeg = lst[i];\n          \
    \  }\n        } else if (lst[i] > 0) {\n            if (smallestPos === undefined\
    \ || lst[i] < smallestPos) {\n                smallestPos = lst[i];\n        \
    \    }\n        }\n    }\n    return [largestNeg, smallestPos];\n}\n", "    if\
    \ (lst.length === 0) {\n        return [undefined, undefined];\n    }\n    if\
    \ (lst.length === 1) {\n        return [undefined, undefined];\n    }\n    let\
    \ list_p: number[] = [];\n    let list_n: number[] = [];\n    let result: [number\
    \ | undefined, number | undefined] = [undefined, undefined];\n    lst.forEach(element\
    \ => {\n        if (element > 0) {\n            list_p.push(element);\n      \
    \  }\n        if (element < 0) {\n            list_n.push(element);\n        }\n\
    \    });\n    if (list_p.length > 0) {\n        result[1] = list_p.reduce((a,\
    \ b) => Math.min(a, b));\n    }\n    if (list_n.length > 0) {\n        result[0]\
    \ = list_n.reduce((a, b) => Math.max(a, b));\n    }\n    return result;\n}\n",
  "    let min = 0;\n    let max = 0;\n    let largest = undefined;\n    let smallest\
    \ = undefined;\n    for (let item of lst) {\n        if (item > 0) {\n       \
    \     min = Math.min(min, item);\n            if (smallest === undefined) {\n\
    \                smallest = min;\n            }\n        } else if (item < 0)\
    \ {\n            max = Math.max(max, item);\n            if (largest === undefined)\
    \ {\n                largest = max;\n            }\n        }\n    }\n    return\
    \ [largest, smallest];\n}\nconsole.log(largest_smallest_integers([1, -3, 2, -5,\
    \ 4, -7]));\n", "    let retVal = [undefined, undefined];\n    lst.forEach(item\
    \ => {\n        if (item < 0) {\n            if (retVal[0] == undefined || item\
    \ > retVal[0])\n                retVal[0] = item;\n        }\n        else if\
    \ (item > 0) {\n            if (retVal[1] == undefined || item < retVal[1])\n\
    \                retVal[1] = item;\n        }\n    });\n    return retVal;\n}\n",
  "    let largest = undefined;\n    let smallest = undefined;\n    for (let i = 0;\
    \ i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (smallest\
    \ === undefined) {\n                smallest = lst[i];\n            } else if\
    \ (lst[i] < smallest) {\n                smallest = lst[i];\n            }\n \
    \       } else if (lst[i] < 0) {\n            if (largest === undefined) {\n \
    \               largest = lst[i];\n            } else if (lst[i] > largest) {\n\
    \                largest = lst[i];\n            }\n        }\n    }\n    return\
    \ [largest, smallest];\n}\n\n", "    let a: number | undefined = undefined\n \
    \   let b: number | undefined = undefined\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        if (lst[i] > 0) {\n            if (b == undefined) b = lst[i]\n\
    \            else if (lst[i] < b) b = lst[i]\n        }\n        else if (lst[i]\
    \ < 0) {\n            if (a == undefined) a = lst[i]\n            else if (lst[i]\
    \ > a) a = lst[i]\n        }\n    }\n    return [a, b]\n}\n", "  let largest:\
    \ number | undefined;\n  let smallest: number | undefined;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] > 0) {\n      if (smallest === undefined\
    \ || lst[i] < smallest) {\n        smallest = lst[i];\n      }\n    } else if\
    \ (lst[i] < 0) {\n      if (largest === undefined || lst[i] > largest) {\n   \
    \     largest = lst[i];\n      }\n    }\n  }\n  return [largest, smallest];\n\
    }\n", "    // your code goes here\n    let max = undefined;\n    let min = undefined;\n\
    \    lst.forEach(function (num) {\n        if (num < 0) {\n            if (max\
    \ === undefined) {\n                max = num;\n            } else if (num > max)\
    \ {\n                max = num;\n            }\n        } else if (num > 0) {\n\
    \            if (min === undefined) {\n                min = num;\n          \
    \  } else if (num < min) {\n                min = num;\n            }\n      \
    \  }\n    });\n    return [max, min];\n}\n\n", "    return lst.reduce((acc, v)\
    \ => {\n        if (v >= 0) {\n            if (acc[1] === undefined || v < acc[1])\
    \ {\n                acc[1] = v;\n            }\n        } else {\n          \
    \  if (acc[0] === undefined || v > acc[0]) {\n                acc[0] = v;\n  \
    \          }\n        }\n        return acc;\n    }, [undefined, undefined]);\n\
    }\n", "  const pos_lst = lst.filter(num => num > 0);\n  const neg_lst = lst.filter(num\
    \ => num < 0);\n  return [\n    neg_lst.length ? Math.max(...neg_lst) : undefined,\n\
    \    pos_lst.length ? Math.min(...pos_lst) : undefined\n  ];\n}\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));",
  "    const positive_arr = [];\n    const negative_arr = [];\n    for (let i = 0;\
    \ i < lst.length; i++) {\n        if (lst[i] > 0) {\n            positive_arr.push(lst[i]);\n\
    \        } else if (lst[i] < 0) {\n            negative_arr.push(lst[i]);\n  \
    \      }\n    }\n    if (positive_arr.length === 0) {\n        return [undefined,\
    \ undefined];\n    } else if (negative_arr.length === 0) {\n        return [undefined,\
    \ positive_arr[0]];\n    } else {\n        return [Math.max(...negative_arr),\
    \ Math.min(...positive_arr)];\n    }\n}\n", "    if (lst.length == 0) {\n    \
    \    return [undefined, undefined];\n    }\n    let negative = -Infinity;\n  \
    \  let positive = Infinity;\n    for (let i = 0; i < lst.length; i++) {\n    \
    \    if (lst[i] < 0) {\n            negative = Math.max(negative, lst[i]);\n \
    \       }\n        if (lst[i] > 0) {\n            positive = Math.min(positive,\
    \ lst[i]);\n        }\n    }\n    return [negative, positive];\n}\n", "    let\
    \ smallest: number | undefined;\n    let largest: number | undefined;\n    lst.forEach(e\
    \ => {\n        if (e > 0) {\n            if (smallest === undefined || e < smallest)\
    \ {\n                smallest = e;\n            }\n        } else if (e < 0) {\n\
    \            if (largest === undefined || e > largest) {\n                largest\
    \ = e;\n            }\n        }\n    });\n    return [largest, smallest];\n}\n\
    \n", "    if (lst.length == 0) {\n        return [undefined, undefined];\n   \
    \ }\n\n    let minVal = lst[0];\n    let maxVal = lst[0];\n\n    for (let i =\
    \ 1; i < lst.length; i++) {\n        const num = lst[i];\n        if (num < minVal)\
    \ {\n            minVal = num;\n        } else if (num > maxVal) {\n         \
    \   maxVal = num;\n        }\n    }\n\n    return [maxVal, minVal];\n}\n", " \
    \ return [undefined, undefined];\n}\n", "    var a = undefined;\n    var b = undefined;\n\
    \    for (var i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n     \
    \       if (a == undefined) {\n                a = lst[i];\n            } else\
    \ if (lst[i] > a) {\n                a = lst[i];\n            }\n        } else\
    \ if (lst[i] > 0) {\n            if (b == undefined) {\n                b = lst[i];\n\
    \            } else if (lst[i] < b) {\n                b = lst[i];\n         \
    \   }\n        }\n    }\n    return [a, b];\n}", "  let largest: number | undefined;\n\
    \  let smallest: number | undefined;\n  for (let i = 0; i < lst.length; i++) {\n\
    \    if (lst[i] > 0) {\n      if (smallest == undefined) {\n        smallest =\
    \ lst[i];\n      } else if (lst[i] < smallest) {\n        smallest = lst[i];\n\
    \      }\n    } else if (lst[i] < 0) {\n      if (largest == undefined) {\n  \
    \      largest = lst[i];\n      } else if (lst[i] > largest) {\n        largest\
    \ = lst[i];\n      }\n    }\n  }\n  return [largest, smallest];\n}\n", "    let\
    \ largestNegative: number | undefined = undefined;\n    let smallestPositive:\
    \ number | undefined = undefined;\n    for (let item of lst) {\n        if (item\
    \ < 0) {\n            if (largestNegative == undefined || item > largestNegative)\
    \ {\n                largestNegative = item;\n            }\n        } else if\
    \ (item > 0) {\n            if (smallestPositive == undefined || item < smallestPositive)\
    \ {\n                smallestPositive = item;\n            }\n        }\n    }\n\
    \    return [largestNegative, smallestPositive];\n}\n", "  let largest_negative\
    \ = undefined;\n  let smallest_positive = undefined;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] < 0) {\n      if (largest_negative === undefined || lst[i]\
    \ > largest_negative) {\n        largest_negative = lst[i];\n      }\n    } else\
    \ if (lst[i] > 0) {\n      if (smallest_positive === undefined || lst[i] < smallest_positive)\
    \ {\n        smallest_positive = lst[i];\n      }\n    }\n  }\n  return [largest_negative,\
    \ smallest_positive];\n}\n", "    let largest_negative: number | undefined = undefined;\n\
    \    let smallest_positive: number | undefined = undefined;\n    for (let i =\
    \ 0; i < lst.length; i++) {\n        let cur = lst[i];\n        if (cur < 0) {\n\
    \            if (largest_negative == undefined || cur > largest_negative) {\n\
    \                largest_negative = cur;\n            }\n        } else if (cur\
    \ > 0) {\n            if (smallest_positive == undefined || cur < smallest_positive)\
    \ {\n                smallest_positive = cur;\n            }\n        }\n    }\n\
    \    return [largest_negative, smallest_positive];\n}\n", "  return [largest_negative_integer(lst),\
    \ smallest_positive_integer(lst)];\n}\n", "    let largest_neg: number | undefined\
    \ = undefined;\n    let smallest_pos: number | undefined = undefined;\n    for\
    \ (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n            if\
    \ (largest_neg == undefined) {\n                largest_neg = lst[i];\n      \
    \      } else if (lst[i] > largest_neg) {\n                largest_neg = lst[i];\n\
    \            }\n        } else if (lst[i] > 0) {\n            if (smallest_pos\
    \ == undefined) {\n                smallest_pos = lst[i];\n            } else\
    \ if (lst[i] < smallest_pos) {\n                smallest_pos = lst[i];\n     \
    \       }\n        }\n    }\n    return [largest_neg, smallest_pos];\n}\n\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));\n",
  "  let lowest: number | undefined = undefined;\n  let highest: number | undefined\
    \ = undefined;\n  lst.forEach(num => {\n    if (num >= 0) {\n      if (lowest\
    \ === undefined || num < lowest) {\n        lowest = num;\n      }\n    } else\
    \ {\n      if (highest === undefined || num > highest) {\n        highest = num;\n\
    \      }\n    }\n  });\n  return [highest, lowest];\n}", "  let maxNegative =\
    \ -Infinity;\n  let minPositive = Infinity;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] < 0 && lst[i] > maxNegative) {\n      maxNegative = lst[i];\n\
    \    }\n    if (lst[i] > 0 && lst[i] < minPositive) {\n      minPositive = lst[i];\n\
    \    }\n  }\n  return maxNegative === -Infinity ? [undefined, minPositive] : [maxNegative,\
    \ minPositive === Infinity ? undefined : minPositive];\n}\n", "    let smallest\
    \ = undefined;\n    let largest = undefined;\n    for (let x of lst) {\n     \
    \   if (x > 0) {\n            if (smallest === undefined || x < smallest) {\n\
    \                smallest = x;\n            }\n        } else if (x < 0) {\n \
    \           if (largest === undefined || x > largest) {\n                largest\
    \ = x;\n            }\n        }\n    }\n    return [largest, smallest];\n}\n\n",
  "  if (lst.length == 0) {\n    return [undefined, undefined];\n  }\n  if (lst.length\
    \ == 1) {\n    return [undefined, undefined];\n  }\n  let min = lst[0];\n  let\
    \ max = lst[0];\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < min)\
    \ {\n      min = lst[i];\n    }\n    if (lst[i] > max) {\n      max = lst[i];\n\
    \    }\n  }\n  if (min > 0) {\n    min = undefined;\n  }\n  if (max < 0) {\n \
    \   max = undefined;\n  }\n  return [max, min];\n}\n", "  return [0, 0];\n}\n",
  "  let positiveSmallest = undefined;\n  let negativeLargest = undefined;\n  for\
    \ (let x of lst) {\n    if (x > 0) {\n      if (positiveSmallest === undefined\
    \ || x < positiveSmallest) {\n        positiveSmallest = x;\n      }\n    } else\
    \ if (x < 0) {\n      if (negativeLargest === undefined || x > negativeLargest)\
    \ {\n        negativeLargest = x;\n      }\n    }\n  }\n  return [negativeLargest,\
    \ positiveSmallest];\n}\n", "    if (lst.length === 0) {\n        return [undefined,\
    \ undefined];\n    }\n\n    let neg = undefined;\n    let pos = undefined;\n\n\
    \    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n     \
    \       if (neg === undefined || lst[i] > neg) {\n                neg = lst[i];\n\
    \            }\n        } else if (lst[i] > 0) {\n            if (pos === undefined\
    \ || lst[i] < pos) {\n                pos = lst[i];\n            }\n        }\n\
    \    }\n\n    return [neg, pos];\n}\n", "  //Write your code here!\n  return [1,\
    \ 2];\n}\n", "  let largestNegative = undefined;\n  let smallestPositive = undefined;\n\
    \  lst.forEach(int => {\n    if (int < 0) {\n      if (largestNegative === undefined\
    \ || int > largestNegative) {\n        largestNegative = int;\n      }\n    }\
    \ else if (int > 0) {\n      if (smallestPositive === undefined || int < smallestPositive)\
    \ {\n        smallestPositive = int;\n      }\n    }\n  });\n  return [largestNegative,\
    \ smallestPositive];\n}\n", "    let max = undefined;\n    let min = undefined;\n\
    \    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n     \
    \       if (max === undefined || lst[i] > max) {\n                max = lst[i];\n\
    \            }\n        } else if (lst[i] > 0) {\n            if (min === undefined\
    \ || lst[i] < min) {\n                min = lst[i];\n            }\n        }\n\
    \    }\n    return [max, min];\n}\n", "  let min_pos: number | undefined = undefined;\n\
    \  let max_neg: number | undefined = undefined;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > 0) {\n      if (min_pos === undefined || lst[i] < min_pos)\
    \ {\n        min_pos = lst[i];\n      }\n    } else if (lst[i] < 0) {\n      if\
    \ (max_neg === undefined || lst[i] > max_neg) {\n        max_neg = lst[i];\n \
    \     }\n    }\n  }\n  return [max_neg, min_pos];\n}\n\nexport const solution\
    \ = {\n  d: `\n    https://www.codewars.com/kata/smallest-possible-array-product\n\
    \n    Given an array of integers, find the smallest possible\n    product of its\
    \ elements.\n  `,\n  fn: smallest_possible_array_product,\n};", "    return [undefined,\
    \ undefined];\n}\n", "    let min = lst[0];\n    let max = lst[0];\n    for (let\
    \ i = 0; i < lst.length; i++) {\n        if (lst[i] < min) {\n            min\
    \ = lst[i];\n        }\n        if (lst[i] > max) {\n            max = lst[i];\n\
    \        }\n    }\n    return [max, min];\n}\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));\n",
  "  let low: number | undefined;\n  let high: number | undefined;\n  let foundLow\
    \ = false;\n  let foundHigh = false;\n  lst.forEach(function (value) {\n    if\
    \ (value > 0) {\n      if (!foundHigh) {\n        high = value;\n        foundHigh\
    \ = true;\n      } else if (value < high) {\n        high = value;\n      }\n\
    \    } else if (value < 0) {\n      if (!foundLow) {\n        low = value;\n \
    \       foundLow = true;\n      } else if (value > low) {\n        low = value;\n\
    \      }\n    }\n  });\n  return [low, high];\n}\n", "    let max_negative = undefined;\n\
    \    let min_positive = undefined;\n    for (let elt of lst) {\n        if (elt\
    \ > 0) {\n            if (min_positive === undefined || elt < min_positive) {\n\
    \                min_positive = elt;\n            }\n        } else if (elt <\
    \ 0) {\n            if (max_negative === undefined || elt > max_negative) {\n\
    \                max_negative = elt;\n            }\n        }\n    }\n    return\
    \ [max_negative, min_positive];\n}\n", "  return [undefined, undefined];\n}\n",
  "    if (lst.length == 0) {\n        return [undefined, undefined];\n    }\n   \
    \ let largest_neg = undefined;\n    let smallest_pos = undefined;\n    for (let\
    \ i = 0; i < lst.length; i++) {\n        let curr = lst[i];\n        if (curr\
    \ > 0) {\n            if (smallest_pos == undefined || curr < smallest_pos) {\n\
    \                smallest_pos = curr;\n            }\n        } else if (curr\
    \ < 0) {\n            if (largest_neg == undefined || curr > largest_neg) {\n\
    \                largest_neg = curr;\n            }\n        }\n    }\n    return\
    \ [largest_neg, smallest_pos];\n}\n", "  // TODO: implement me\n  return [undefined,\
    \ undefined];\n}\n", "    let largestNegative: number | undefined;\n    let smallestPositive:\
    \ number | undefined;\n    for (let i: number = 0; i < lst.length; i++) {\n  \
    \      if (lst[i] < 0) {\n            if (largestNegative === undefined) {\n \
    \               largestNegative = lst[i];\n            } else if (lst[i] > largestNegative)\
    \ {\n                largestNegative = lst[i];\n            }\n        } else\
    \ if (lst[i] > 0) {\n            if (smallestPositive === undefined) {\n     \
    \           smallestPositive = lst[i];\n            } else if (lst[i] < smallestPositive)\
    \ {\n                smallestPositive = lst[i];\n            }\n        }\n  \
    \  }\n    return [largestNegative, smallestPositive];\n}\n\nexport {largest_smallest_integers};",
  "    let negatives: number[] = lst.filter(isNegative);\n    let positives: number[]\
    \ = lst.filter(isPositive);\n    return [negatives.length > 0 ? Math.max(...negatives)\
    \ : undefined, positives.length > 0 ? Math.min(...positives) : undefined];\n}\n",
  "    if (lst.length === 0) {\n        return [undefined, undefined];\n    }\n  \
    \  let largestNegative = 0;\n    let smallestPositive = 0;\n    let count = 0;\n\
    \    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n     \
    \       if (lst[i] > largestNegative) {\n                largestNegative = lst[i];\n\
    \            }\n        } else if (lst[i] > 0) {\n            if (smallestPositive\
    \ === 0) {\n                smallestPositive = lst[i];\n            } else if\
    \ (lst[i] < smallestPositive) {\n                smallestPositive = lst[i];\n\
    \            }\n        } else {\n            count += 1;\n        }\n    }\n\
    \    if (count === lst.length) {\n        return [undefined, undefined];\n   \
    \ }\n    return [largestNegative, smallestPositive];\n}\n\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));\n",
  "    return [1, 2];\n}\n", "    var max: number | undefined;\n    var min: number\
    \ | undefined;\n    for (let num of lst) {\n        if (num < 0) {\n         \
    \   if (max == undefined || num > max) {\n                max = num;\n       \
    \     }\n        } else if (num > 0) {\n            if (min == undefined || num\
    \ < min) {\n                min = num;\n            }\n        }\n    }\n    return\
    \ [max, min];\n}", "    let largest: number | undefined;\n    let smallest: number\
    \ | undefined;\n    for (let i = 0; i < lst.length; i++) {\n        const elem\
    \ = lst[i];\n        if (elem < 0) {\n            if (largest === undefined ||\
    \ elem > largest) {\n                largest = elem;\n            }\n        }\
    \ else if (elem > 0) {\n            if (smallest === undefined || elem < smallest)\
    \ {\n                smallest = elem;\n            }\n        }\n    }\n    return\
    \ [largest, smallest];\n}\n", "    let largest_neg = -Infinity;\n    let smallest_pos\
    \ = Infinity;\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i]\
    \ < 0 && lst[i] > largest_neg) {\n            largest_neg = lst[i];\n        }\n\
    \        if (lst[i] > 0 && lst[i] < smallest_pos) {\n            smallest_pos\
    \ = lst[i];\n        }\n    }\n    if (largest_neg == -Infinity) {\n        largest_neg\
    \ = undefined;\n    }\n    if (smallest_pos == Infinity) {\n        smallest_pos\
    \ = undefined;\n    }\n    return [largest_neg, smallest_pos];\n}\n", "  let largest:\
    \ number | undefined;\n  let smallest: number | undefined;\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (largest === undefined\
    \ || lst[i] > largest) {\n        largest = lst[i];\n      }\n    } else if (lst[i]\
    \ > 0) {\n      if (smallest === undefined || lst[i] < smallest) {\n        smallest\
    \ = lst[i];\n      }\n    }\n  }\n  return [largest, smallest];\n}\n\ndescribe(\"\
    largest_smallest_integers\", () => {\n  it(\"should return the largest negative\
    \ integer and the smallest positive integer\", () => {\n    expect(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])).toEqual([undefined, 1]);\n    expect(largest_smallest_integers([0])).toEqual([undefined,\
    \ undefined]);\n    expect(largest_smallest_integers([])).toEqual([undefined,\
    \ undefined]);\n    expect(largest_smallest_integers([-10, 5, -7, 1, 0, -5, -4,\
    \ -6, -10, -2])).toEqual([-2, 1]);\n  });\n});\n", "  // your code here\n  let\
    \ pos = undefined\n  let neg = undefined\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] > 0) {\n      if (pos == undefined) {\n        pos = lst[i]\n\
    \      } else if (lst[i] < pos) {\n        pos = lst[i]\n      }\n    } else if\
    \ (lst[i] < 0) {\n      if (neg == undefined) {\n        neg = lst[i]\n      }\
    \ else if (lst[i] > neg) {\n        neg = lst[i]\n      }\n    }\n  }\n  return\
    \ [neg, pos]\n}\n", "  let lowest_positive = undefined;\n  let highest_negative\
    \ = undefined;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0)\
    \ {\n      if (lowest_positive === undefined || lst[i] < lowest_positive) {\n\
    \        lowest_positive = lst[i];\n      }\n    } else if (lst[i] < 0) {\n  \
    \    if (highest_negative === undefined || lst[i] > highest_negative) {\n    \
    \    highest_negative = lst[i];\n      }\n    }\n  }\n  return [highest_negative,\
    \ lowest_positive];\n}\n", "    let max: number = -Infinity;\n    let min: number\
    \ = Infinity;\n    lst.forEach(function (i) {\n        if (i < 0 && i > max) {\n\
    \            max = i;\n        }\n        if (i > 0 && i < min) {\n          \
    \  min = i;\n        }\n    });\n    if (max === -Infinity) {\n        max = undefined;\n\
    \    }\n    if (min === Infinity) {\n        min = undefined;\n    }\n    return\
    \ [max, min];\n}\n", "    // Type of elements of the output array.\n    type output_t\
    \ = number | undefined;\n\n    // Create a tuple from two arrays of numbers.\n\
    \    function tuple(a: number[], b: number[]): [output_t, output_t] {\n      \
    \  const max_a = a.length ? Math.max(...a) : undefined;\n        const min_b =\
    \ b.length ? Math.min(...b) : undefined;\n        return [max_a, min_b];\n   \
    \ }\n\n    // Return result.\n    return tuple(lst.filter(x => x < 0), lst.filter(x\
    \ => x > 0));\n}\n\ntest(\"02\", () => {\n    expect(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7])).toEqual([undefined, 1]);\n    expect(largest_smallest_integers([])).toEqual([undefined,\
    \ undefined]);\n    expect(largest_smallest_integers([0])).toEqual([undefined,\
    \ undefined]);\n});\n", "    if (lst.length == 0) {\n        return [undefined,\
    \ undefined];\n    }\n\n    let largestNegative: number | undefined = undefined;\n\
    \    let smallestPositive: number | undefined = undefined;\n\n    for (let num\
    \ of lst) {\n        if (num < 0) {\n            if (largestNegative === undefined\
    \ || num > largestNegative) {\n                largestNegative = num;\n      \
    \      }\n        }\n        else if (num > 0) {\n            if (smallestPositive\
    \ === undefined || num < smallestPositive) {\n                smallestPositive\
    \ = num;\n            }\n        }\n    }\n\n    return [largestNegative, smallestPositive];\n\
    }\n\n", "  if (lst.length === 0) {\n    return [undefined, undefined];\n  }\n\
    \  const positive_lst = lst.filter(value => value > 0);\n  const negative_lst\
    \ = lst.filter(value => value < 0);\n  if (positive_lst.length === 0 || negative_lst.length\
    \ === 0) {\n    return [undefined, undefined];\n  }\n  return [Math.max(...negative_lst),\
    \ Math.min(...positive_lst)];\n}\n", "    let a: number | undefined;\n    let\
    \ b: number | undefined;\n    for (let i = 0; i < lst.length; i++) {\n       \
    \ if (lst[i] < 0) {\n            if (a == undefined) {\n                a = lst[i];\n\
    \            } else if (lst[i] > a) {\n                a = lst[i];\n         \
    \   }\n        } else if (lst[i] > 0) {\n            if (b == undefined) {\n \
    \               b = lst[i];\n            } else if (lst[i] < b) {\n          \
    \      b = lst[i];\n            }\n        }\n    }\n    return [a, b];\n}\n",
  "    // get the maximum of negative integers\n    // get the minimum of positive\
    \ integers\n    let max_negative = undefined;\n    let min_positive = undefined;\n\
    \    for (let i = 0; i < lst.length; i++) {\n        const num = lst[i];\n   \
    \     if (num > 0) {\n            if (min_positive === undefined || num < min_positive)\
    \ {\n                min_positive = num;\n            }\n        } else if (num\
    \ < 0) {\n            if (max_negative === undefined || num > max_negative) {\n\
    \                max_negative = num;\n            }\n        }\n    }\n    return\
    \ [max_negative, min_positive];\n}\n", "  let largestNeg = undefined;\n  let smallestPos\
    \ = undefined;\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] < 0)\
    \ {\n      if (largestNeg === undefined || lst[i] > largestNeg) {\n        largestNeg\
    \ = lst[i];\n      }\n    } else if (lst[i] > 0) {\n      if (smallestPos ===\
    \ undefined || lst[i] < smallestPos) {\n        smallestPos = lst[i];\n      }\n\
    \    }\n  }\n  return [largestNeg, smallestPos];\n}\n", "  let largeNeg: number\
    \ | undefined;\n  let smallPos: number | undefined;\n  for (let num of lst) {\n\
    \    if (num < 0) {\n      if (largeNeg === undefined || num > largeNeg) {\n \
    \       largeNeg = num;\n      }\n    } else if (num > 0) {\n      if (smallPos\
    \ === undefined || num < smallPos) {\n        smallPos = num;\n      }\n    }\n\
    \  }\n  return [largeNeg, smallPos];\n}\n", "  const { largestNegative, smallestPositive\
    \ } = lst.reduce((acc, item) => {\n    if (item > 0 && (acc.smallestPositive ===\
    \ undefined || item < acc.smallestPositive)) {\n      acc.smallestPositive = item;\n\
    \    }\n    if (item < 0 && (acc.largestNegative === undefined || item > acc.largestNegative))\
    \ {\n      acc.largestNegative = item;\n    }\n    return acc;\n  }, { largestNegative:\
    \ undefined, smallestPositive: undefined });\n  return [largestNegative, smallestPositive];\n\
    }\n", "    if (lst.length == 0) {\n        return [undefined, undefined];\n  \
    \  }\n    const negatives = lst.filter(i => i < 0);\n    const positives = lst.filter(i\
    \ => i > 0);\n    let largestNegative = negatives.length > 0 ? Math.max(...negatives)\
    \ : undefined;\n    let smallestPositive = positives.length > 0 ? Math.min(...positives)\
    \ : undefined;\n    return [largestNegative, smallestPositive];\n}", "    // TODO:\
    \ implement this function\n    let negative = lst.filter(i => i < 0);\n    let\
    \ positive = lst.filter(i => i > 0);\n    return [negative.length ? Math.max(...negative)\
    \ : undefined, positive.length ? Math.min(...positive) : undefined];\n}\n", " \
    \   let large = Math.max(...lst);\n    let small = Math.min(...lst);\n    let\
    \ pos: number[] = [];\n    let neg: number[] = [];\n    if (lst.length == 0) {\n\
    \        return [undefined, undefined];\n    }\n    else {\n        lst.forEach(function\
    \ (i) {\n            if (i < 0) {\n                neg.push(i);\n            }\n\
    \            else if (i > 0) {\n                pos.push(i);\n            }\n\
    \        });\n        if (neg.length == 0) {\n            return [undefined, Math.min(...pos)];\n\
    \        }\n        else if (pos.length == 0) {\n            return [Math.max(...neg),\
    \ undefined];\n        }\n        else {\n            return [Math.max(...neg),\
    \ Math.min(...pos)];\n        }\n    }\n}\n", "    // your code here\n    throw\
    \ new Error(\"Method not implemented.\");\n}\n", "    let maxNegative: number\
    \ | undefined = undefined;\n    let minPositive: number | undefined = undefined;\n\
    \    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n     \
    \       if (maxNegative === undefined || lst[i] > maxNegative) {\n           \
    \     maxNegative = lst[i];\n            }\n        } else if (lst[i] > 0) {\n\
    \            if (minPositive === undefined || lst[i] < minPositive) {\n      \
    \          minPositive = lst[i];\n            }\n        }\n    }\n    return\
    \ [maxNegative, minPositive];\n}", "  let largestNegative: number | undefined;\n\
    \  let smallestPositive: number | undefined;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] > 0) {\n      if (smallestPositive === undefined || lst[i]\
    \ < smallestPositive) {\n        smallestPositive = lst[i];\n      }\n    } else\
    \ if (lst[i] < 0) {\n      if (largestNegative === undefined || lst[i] > largestNegative)\
    \ {\n        largestNegative = lst[i];\n      }\n    }\n  }\n  return [largestNegative,\
    \ smallestPositive];\n}\n", "    let positive = undefined;\n    let negative =\
    \ undefined;\n    let positiveFound = false;\n    let negativeFound = false;\n\
    \    for (let i of lst) {\n        if (i > 0) {\n            if (!positiveFound)\
    \ {\n                positive = i;\n                positiveFound = true;\n  \
    \          } else {\n                positive = Math.min(positive, i);\n     \
    \       }\n        } else if (i < 0) {\n            if (!negativeFound) {\n  \
    \              negative = i;\n                negativeFound = true;\n        \
    \    } else {\n                negative = Math.max(negative, i);\n           \
    \ }\n        }\n    }\n    return [negative, positive];\n}\n", "    let posMin:\
    \ number | undefined = undefined;\n    let negMax: number | undefined = undefined;\n\
    \    let curr: number;\n    for (let i = 0; i < lst.length; i++) {\n        curr\
    \ = lst[i];\n        if (curr > 0) {\n            if (posMin === undefined ||\
    \ curr < posMin) {\n                posMin = curr;\n            }\n        } else\
    \ if (curr < 0) {\n            if (negMax === undefined || curr > negMax) {\n\
    \                negMax = curr;\n            }\n        }\n    }\n    return [negMax,\
    \ posMin];\n}\n", "    let smallestPositiveNumber: number | undefined = undefined;\n\
    \    let largestNegativeNumber: number | undefined = undefined;\n    for (let\
    \ num of lst) {\n        if (num > 0) {\n            if (smallestPositiveNumber\
    \ === undefined) {\n                smallestPositiveNumber = num;\n          \
    \  } else if (num < smallestPositiveNumber) {\n                smallestPositiveNumber\
    \ = num;\n            }\n        } else if (num < 0) {\n            if (largestNegativeNumber\
    \ === undefined) {\n                largestNegativeNumber = num;\n           \
    \ } else if (num > largestNegativeNumber) {\n                largestNegativeNumber\
    \ = num;\n            }\n        }\n    }\n    return [largestNegativeNumber,\
    \ smallestPositiveNumber];\n}\n", "    let max_neg = undefined;\n    let min_pos\
    \ = undefined;\n    for (let n of lst) {\n        if (n < 0) {\n            if\
    \ (max_neg === undefined || n > max_neg) {\n                max_neg = n;\n   \
    \         }\n        } else if (n > 0) {\n            if (min_pos === undefined\
    \ || n < min_pos) {\n                min_pos = n;\n            }\n        }\n\
    \    }\n    return [max_neg, min_pos];\n}\n", "  // TODO: implement\n  let pos\
    \ = undefined;\n  let neg = undefined;\n  let fst = true;\n  let snd = true;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > 0 && fst) {\n    \
    \  pos = lst[i];\n      fst = false;\n    }\n    if (lst[i] < 0 && snd) {\n  \
    \    neg = lst[i];\n      snd = false;\n    }\n    if (lst[i] > 0 && lst[i] <\
    \ pos) {\n      pos = lst[i];\n    }\n    if (lst[i] < 0 && lst[i] > neg) {\n\
    \      neg = lst[i];\n    }\n  }\n  return [neg, pos];\n}\n", "  // implement\
    \ function here\n  let max: number = lst[0];\n  let min: number = lst[0];\n  let\
    \ max_neg: number | undefined = undefined;\n  let min_pos: number | undefined\
    \ = undefined;\n  let count: number = 0;\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    if (lst[i] > max) {\n      max = lst[i];\n    }\n    if (lst[i] < min)\
    \ {\n      min = lst[i];\n    }\n    if (lst[i] < 0) {\n      max_neg = lst[i];\n\
    \      count++;\n    }\n    if (lst[i] > 0) {\n      min_pos = lst[i];\n     \
    \ count++;\n    }\n  }\n  if (count == 0) {\n    return [undefined, undefined];\n\
    \  } else if (count == 1) {\n    if (max_neg == undefined) {\n      return [undefined,\
    \ min_pos];\n    } else {\n      return [max_neg, undefined];\n    }\n  } else\
    \ {\n    for (let i = 0; i < lst.length; i++) {\n      if (lst[i] < 0 && lst[i]\
    \ > max_neg) {\n        max_neg = lst[i];\n      }\n      if (lst[i] > 0 && lst[i]\
    \ < min_pos) {\n        min_pos = lst[i];\n      }\n    }\n    return [max_neg,\
    \ min_pos];\n  }\n}\n", "    let min = Number.MAX_VALUE;\n    let max = Number.MIN_VALUE;\n\
    \    let minValue: number | undefined;\n    let maxValue: number | undefined;\n\
    \    lst.forEach(element => {\n        if (element < 0 && element > max) {\n \
    \           max = element;\n            maxValue = element;\n        } else if\
    \ (element > 0 && element < min) {\n            min = element;\n            minValue\
    \ = element;\n        }\n    });\n    return [maxValue, minValue];\n}\n", "  \
    \  let largest = lst[0];\n    let smallest = lst[0];\n    let has_positive = false;\n\
    \    let has_negative = false;\n    for (let i = 0; i < lst.length; i++) {\n \
    \       if (lst[i] > largest) {\n            largest = lst[i];\n        }\n  \
    \      if (lst[i] < smallest) {\n            smallest = lst[i];\n        }\n \
    \       if (lst[i] < 0) {\n            has_negative = true;\n        }\n     \
    \   if (lst[i] > 0) {\n            has_positive = true;\n        }\n    }\n  \
    \  if (has_negative) {\n        return [largest, undefined];\n    }\n    if (has_positive)\
    \ {\n        return [undefined, smallest];\n    }\n    return [undefined, undefined];\n\
    }", "  if (lst.length == 0) {\n    return [undefined, undefined];\n  }\n  let\
    \ smallest = lst[0];\n  let largest = lst[0];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (lst[i] < smallest) {\n      smallest = lst[i];\n    }\n    if\
    \ (lst[i] > largest) {\n      largest = lst[i];\n    }\n  }\n  return [largest,\
    \ smallest];\n}\nconsole.log(largest_smallest_integers([2, 4, 1, 3, 5, 7]));\n",
  "    let is_positive = (x: number) => x > 0\n    let is_negative = (x: number) =>\
    \ x < 0\n    let positives = lst.filter(is_positive)\n    let negatives = lst.filter(is_negative)\n\
    \    let largest_negative = negatives.reduce((x, y) => x > y ? x : y, 0)\n   \
    \ let smallest_positive = positives.reduce((x, y) => x < y ? x : y, 0)\n    if\
    \ (positives.length == 0) {\n        smallest_positive = undefined\n    }\n  \
    \  if (negatives.length == 0) {\n        largest_negative = undefined\n    }\n\
    \    return [largest_negative, smallest_positive]\n}\n", "    let negatives: number[]\
    \ = lst.filter(function (n) { return n < 0; });\n    let negativesSorted: number[]\
    \ = negatives.sort(function (a, b) { return b - a; });\n    let negativesMax:\
    \ number | undefined = negativesSorted[0];\n\n    let positives: number[] = lst.filter(function\
    \ (n) { return n > 0; });\n    let positivesSorted: number[] = positives.sort(function\
    \ (a, b) { return a - b; });\n    let positivesMin: number | undefined = positivesSorted[0];\n\
    \n    return [negativesMax, positivesMin];\n}\n", "    let largest_negative: number\
    \ | undefined = undefined;\n    let smallest_positive: number | undefined = undefined;\n\
    \    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n     \
    \       if (largest_negative === undefined) {\n                largest_negative\
    \ = lst[i];\n            } else if (lst[i] > largest_negative) {\n           \
    \     largest_negative = lst[i];\n            }\n        } else if (lst[i] > 0)\
    \ {\n            if (smallest_positive === undefined) {\n                smallest_positive\
    \ = lst[i];\n            } else if (lst[i] < smallest_positive) {\n          \
    \      smallest_positive = lst[i];\n            }\n        }\n    }\n    return\
    \ [largest_negative, smallest_positive];\n}\n", "    //function largest_smallest_integers(lst:\
    \ number[]): [number, number] {\n    //function largest_smallest_integers(lst:\
    \ number[]): [number?, number?] {\n    let a: number | undefined;\n    let b:\
    \ number | undefined;\n    for (let x of lst) {\n        if (x < 0) {\n      \
    \      if (a === undefined || x > a) {\n                a = x;\n            }\n\
    \        } else if (x > 0) {\n            if (b === undefined || x < b) {\n  \
    \              b = x;\n            }\n        }\n    }\n    return [a, b];\n}\n",
  "  // Your code here\n  return [undefined, undefined];\n}\n", "    return [undefined,\
    \ undefined];\n}\n", "    let largest = undefined;\n    let smallest = undefined;\n\
    \    for (let i = 0; i < lst.length; i++) {\n        if (largest === undefined)\
    \ {\n            if (lst[i] < 0) {\n                largest = lst[i];\n      \
    \      }\n        } else {\n            if (lst[i] < 0 && lst[i] > largest) {\n\
    \                largest = lst[i];\n            }\n        }\n        if (smallest\
    \ === undefined) {\n            if (lst[i] > 0) {\n                smallest =\
    \ lst[i];\n            }\n        } else {\n            if (lst[i] > 0 && lst[i]\
    \ < smallest) {\n                smallest = lst[i];\n            }\n        }\n\
    \    }\n    return [largest, smallest];\n}\n", "    const [sorted_lst, rev_lst]\
    \ = [lst.sort((a, b) => a - b), lst.sort((a, b) => b - a)];\n    const [largest_neg,\
    \ smallest_pos] = [rev_lst[0], sorted_lst[0]];\n    if (largest_neg < 0 && smallest_pos\
    \ > 0) {\n        return [largest_neg, smallest_pos];\n    } else {\n        return\
    \ [undefined, undefined];\n    }\n}\n", "    let largestNegative: number | undefined;\n\
    \    let smallestPositive: number | undefined;\n    for (let item of lst) {\n\
    \        if (item < 0) {\n            if (largestNegative === undefined || item\
    \ > largestNegative) {\n                largestNegative = item;\n            }\n\
    \        } else if (item > 0) {\n            if (smallestPositive === undefined\
    \ || item < smallestPositive) {\n                smallestPositive = item;\n  \
    \          }\n        }\n    }\n    return [largestNegative, smallestPositive];\n\
    }", "  // TODO\n  let lst_max = lst[0];\n  let lst_min = lst[0];\n  for (let i\
    \ = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (lst[i] > lst_max)\
    \ {\n        lst_max = lst[i];\n      }\n    } else {\n      if (lst[i] < lst_min)\
    \ {\n        lst_min = lst[i];\n      }\n    }\n  }\n  if (lst_max < 0) {\n  \
    \  return [lst_max, lst_min];\n  } else {\n    return [undefined, undefined];\n\
    \  }\n}\n", "    let largest = lst[0];\n    let smallest = lst[0];\n    let smallestFound\
    \ = false;\n    let largestFound = false;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        if (lst[i] < 0) {\n            if (lst[i] > largest) {\n   \
    \             largest = lst[i];\n                largestFound = true;\n      \
    \      }\n        } else if (lst[i] > 0) {\n            if (lst[i] < smallest)\
    \ {\n                smallest = lst[i];\n                smallestFound = true;\n\
    \            }\n        }\n    }\n    return [largestFound ? largest : undefined,\
    \ smallestFound ? smallest : undefined];\n}\n", "  const neg = Math.max(...lst.filter(x\
    \ => x < 0));\n  const pos = Math.min(...lst.filter(x => x > 0));\n  return [neg\
    \ || undefined, pos || undefined];\n}\n", "    let pos: number[] = [];\n    let\
    \ neg: number[] = [];\n    for (let i: number = 0; i < lst.length; i++) {\n  \
    \      if (lst[i] > 0) {\n            pos.push(lst[i]);\n        } else if (lst[i]\
    \ < 0) {\n            neg.push(lst[i]);\n        }\n    }\n    if (pos.length\
    \ < 1) {\n        pos.push(undefined);\n    }\n    if (neg.length < 1) {\n   \
    \     neg.push(undefined);\n    }\n    pos.sort(function (a, b) { return a - b\
    \ });\n    neg.sort(function (a, b) { return b - a });\n    let ans: [number |\
    \ undefined, number | undefined] = [neg[0], pos[0]];\n    return ans;\n}", " \
    \   const [neg, pos] = lst.reduce(\n        ([neg, pos], x) => {\n           \
    \ if (x < 0) {\n                if (neg === undefined || x > neg) {\n        \
    \            neg = x;\n                }\n            } else if (x > 0) {\n  \
    \              if (pos === undefined || x < pos) {\n                    pos =\
    \ x;\n                }\n            }\n            return [neg, pos];\n     \
    \   },\n        [undefined, undefined]\n    );\n    return [neg, pos];\n}\n\n\
    test(`largest_smallest_integers([2, 4, 1, 3, 5, 7]) should return [undefined,\
    \ 1]`, () => {\n    expect(largest_smallest_integers([2, 4, 1, 3, 5, 7])).toEqual([undefined,\
    \ 1]);\n});\ntest(`largest_smallest_integers([]) should return [undefined, undefined]`,\
    \ () => {\n    expect(largest_smallest_integers([])).toEqual([undefined, undefined]);\n\
    });\ntest(`largest_smallest_integers([0]) should return [undefined, undefined]`,\
    \ () => {\n    expect(largest_smallest_integers([0])).toEqual([undefined, undefined]);\n\
    });\ntest(`largest_smallest_integers([-1, -2, -3, -4, -5]) should return [-1,\
    \ undefined]`, () => {\n    expect(largest_smallest_integers([-1, -2, -3, -4,\
    \ -5])).toEqual([-1, undefined]);\n});\ntest(`largest_smallest_integers([5, 1,\
    \ -2, 3, 4]) should return [-2, 1]`, () => {\n    expect(largest_smallest_integers([5,\
    \ 1, -2, 3, 4])).toEqual([-2, 1]);\n});\ntest(`largest_smallest_integers([-1,\
    \ -2, -3, -4, -5, -6, -7, -8, -9, -10]) should return [-1, undefined]`, () =>\
    \ {\n    expect(largest_smallest_integers([-", "    if (lst.length === 0) {\n\
    \        return [undefined, undefined];\n    }\n    let maxNeg = undefined;\n\
    \    let minPos = undefined;\n    for (let i = 0; i < lst.length; i++) {\n   \
    \     if (lst[i] < 0) {\n            if (maxNeg === undefined || lst[i] > maxNeg)\
    \ {\n                maxNeg = lst[i];\n            }\n        } else if (lst[i]\
    \ > 0) {\n            if (minPos === undefined || lst[i] < minPos) {\n       \
    \         minPos = lst[i];\n            }\n        }\n    }\n    return [maxNeg,\
    \ minPos];\n}", "    // let smallest_positive: number | undefined = undefined;\n\
    \    // let largest_negative: number | undefined = undefined;\n    // for (let\
    \ i = 0; i < lst.length; i++) {\n    //     if (lst[i] > 0) {\n    //        \
    \ if (smallest_positive === undefined) {\n    //             smallest_positive\
    \ = lst[i];\n    //         } else if (lst[i] < smallest_positive) {\n    // \
    \            smallest_positive = lst[i];\n    //         }\n    //     } else\
    \ if (lst[i] < 0) {\n    //         if (largest_negative === undefined) {\n  \
    \  //             largest_negative = lst[i];\n    //         } else if (lst[i]\
    \ > largest_negative) {\n    //             largest_negative = lst[i];\n    //\
    \         }\n    //     }\n    // }\n    // return [largest_negative, smallest_positive];\n\
    \    let smallest_positive: number | undefined = undefined;\n    let largest_negative:\
    \ number | undefined = undefined;\n    for (let i = 0; i < lst.length; i++) {\n\
    \        if (lst[i] > 0) {\n            if (smallest_positive === undefined) {\n\
    \                smallest_positive = lst[i];\n            } else if (lst[i] <\
    \ smallest_positive) {\n                smallest_positive = lst[i];\n        \
    \    }\n        } else if (lst[i] < 0) {\n            if (largest_negative ===\
    \ undefined) {\n                largest_negative = lst[i];\n            } else\
    \ if (lst[i] > largest_negative) {\n                largest_negative = lst[i];\n\
    \            }\n        }\n    }\n    return [largest_negative, smallest_positive];\n\
    }\n", "    return undefined;\n}\n", "    const s = new Set(lst);\n    if (s.size\
    \ < 1) {\n        return [undefined, undefined];\n    }\n\n    const MIN = Math.min(...s);\n\
    \    const MAX = Math.max(...s);\n\n    if (MIN >= 0) {\n        return [undefined,\
    \ MIN];\n    }\n\n    if (MAX <= 0) {\n        return [MAX, undefined];\n    }\n\
    \n    return [MAX, MIN];\n}\n\nassert(largest_smallest_integers([2, 4, 1, 3, 5,\
    \ 7])[0] === undefined);\nassert(largest_smallest_integers([2, 4, 1, 3, 5, 7])[1]\
    \ === 1);\nassert(largest_smallest_integers([])[0] === undefined);\nassert(largest_smallest_integers([])[1]\
    \ === undefined);\nassert(largest_smallest_integers([0])[0] === undefined);\n\
    assert(largest_smallest_integers([0])[1] === undefined);\nassert(largest_smallest_integers([-3,\
    \ -2, -1])[0] === -1);\nassert(largest_smallest_integers([-3, -2, -1])[1] ===\
    \ undefined);\nassert(largest_smallest_integers([1, 2, 3])[0] === undefined);\n\
    assert(largest_smallest_integers([1, 2, 3])[1] === 1);\n", "    return [undefined,\
    \ undefined];\n}\n", "  const positives = lst.filter(x => x > 0);\n  const negatives\
    \ = lst.filter(x => x < 0);\n  return [negatives.length > 0 ? Math.max(...negatives)\
    \ : undefined, positives.length > 0 ? Math.min(...positives) : undefined];\n}\n",
  "    return [undefined, undefined];\n}\n", "  let largest_negative: number | undefined\
    \ = undefined;\n  let smallest_positive: number | undefined = undefined;\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    const elt = lst[i];\n    if (elt < 0)\
    \ {\n      if (largest_negative === undefined || elt > largest_negative) {\n \
    \       largest_negative = elt;\n      }\n    } else if (elt > 0) {\n      if\
    \ (smallest_positive === undefined || elt < smallest_positive) {\n        smallest_positive\
    \ = elt;\n      }\n    }\n  }\n  return [largest_negative, smallest_positive];\n\
    }\n", "    var ret: [number | undefined, number | undefined] = [undefined, undefined];\n\
    \    for (var i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n     \
    \       if (ret[1] == undefined) {\n                ret[1] = lst[i];\n       \
    \     } else if (lst[i] < ret[1]) {\n                ret[1] = lst[i];\n      \
    \      }\n        } else if (lst[i] < 0) {\n            if (ret[0] == undefined)\
    \ {\n                ret[0] = lst[i];\n            } else if (lst[i] > ret[0])\
    \ {\n                ret[0] = lst[i];\n            }\n        }\n    }\n    return\
    \ ret;\n}\n", "  let smallestPositiveInteger: number | undefined;\n  let largestNegativeInteger:\
    \ number | undefined;\n  lst.forEach(item => {\n    if (item > 0) {\n      if\
    \ (smallestPositiveInteger == undefined) {\n        smallestPositiveInteger =\
    \ item;\n      } else if (item < smallestPositiveInteger) {\n        smallestPositiveInteger\
    \ = item;\n      }\n    } else if (item < 0) {\n      if (largestNegativeInteger\
    \ == undefined) {\n        largestNegativeInteger = item;\n      } else if (item\
    \ > largestNegativeInteger) {\n        largestNegativeInteger = item;\n      }\n\
    \    }\n  });\n  return [largestNegativeInteger, smallestPositiveInteger];\n}\n",
  "  const negatives = lst.filter(n => n < 0).sort((a, b) => b - a);\n  const positives\
    \ = lst.filter(n => n > 0).sort((a, b) => a - b);\n  return [negatives[0], positives[0]];\n\
    }\n", "  // YOUR CODE HERE\n  return [undefined, undefined];\n}\n", "    // TODO:\
    \ implement largest_smallest_integers function\n    let largest = lst[0];\n  \
    \  let smallest = lst[0];\n    let largest_index = 0;\n    let smallest_index\
    \ = 0;\n    let large_neg = 0;\n    let small_pos = 0;\n    for (let i = 0; i\
    \ < lst.length; i++) {\n        if (lst[i] > largest) {\n            largest =\
    \ lst[i];\n            largest_index = i;\n        }\n        if (lst[i] < smallest)\
    \ {\n            smallest = lst[i];\n            smallest_index = i;\n       \
    \ }\n    }\n    if (lst.length === 0) {\n        return [undefined, undefined];\n\
    \    } else if (lst.length === 1) {\n        return [undefined, undefined];\n\
    \    } else if (lst.length === 2) {\n        return [lst[0], lst[1]];\n    } else\
    \ {\n        for (let i = 0; i < lst.length; i++) {\n            if (lst[i] <\
    \ 0) {\n                if (lst[i] > large_neg) {\n                    large_neg\
    \ = lst[i];\n                }\n            }\n            if (lst[i] > 0) {\n\
    \                if (lst[i] < small_pos) {\n                    small_pos = lst[i];\n\
    \                }\n            }\n        }\n        if (large_neg === 0) {\n\
    \            return [undefined, small_pos];\n        } else if (small_pos ===\
    \ 0) {\n            return [large_neg, undefined];\n        } else {\n       \
    \     return [large_neg, small_pos];\n        }\n    }\n}\n", "    const pos =\
    \ lst.filter(x => x > 0);\n    const neg = lst.filter(x => x < 0);\n    const\
    \ b = (neg.length !== 0) ? Math.max(...neg) : undefined;\n    const a = (pos.length\
    \ !== 0) ? Math.min(...pos) : undefined;\n    return [b, a];\n}\n", "    // your\
    \ code goes here\n    if (lst.length === 0) {\n        return [undefined, undefined];\n\
    \    }\n    let min = lst[0];\n    let max = lst[0];\n    for (let i = 0; i <\
    \ lst.length; i++) {\n        if (lst[i] > max) {\n            max = lst[i];\n\
    \        }\n        if (lst[i] < min) {\n            min = lst[i];\n        }\n\
    \    }\n    return [min, max];\n}\n", "    const positives = [];\n    const negatives\
    \ = [];\n    for (const n of lst) {\n        if (n > 0) {\n            positives.push(n);\n\
    \        } else if (n < 0) {\n            negatives.push(n);\n        }\n    }\n\
    \    const smallest_positive = positives.length > 0 ? positives.reduce((a, b)\
    \ => Math.min(a, b)) : undefined;\n    const largest_negative = negatives.length\
    \ > 0 ? negatives.reduce((a, b) => Math.max(a, b)) : undefined;\n    return [largest_negative,\
    \ smallest_positive];\n}\n", "  // Start with undefined. Update as you find larger\
    \ or smaller numbers.\n  let largestNegative: number | undefined = undefined;\n\
    \  let smallestPositive: number | undefined = undefined;\n  for (const n of lst)\
    \ {\n    if (n < 0) {\n      // n is a negative number\n      if (largestNegative\
    \ === undefined || n > largestNegative) {\n        largestNegative = n;\n    \
    \  }\n    } else if (n > 0) {\n      // n is a positive number\n      if (smallestPositive\
    \ === undefined || n < smallestPositive) {\n        smallestPositive = n;\n  \
    \    }\n    }\n  }\n  return [largestNegative, smallestPositive];\n}\n", "   \
    \ // Your Code Here\n    return [undefined, undefined];\n}\n", "  // TODO: write\
    \ me\n  return [undefined, undefined];\n}\n", "    let largestNegative: number\
    \ | undefined;\n    let smallestPositive: number | undefined;\n    lst.forEach(function\
    \ (num) {\n        if (num < 0) {\n            if (largestNegative == undefined)\
    \ {\n                largestNegative = num;\n            } else if (num > largestNegative)\
    \ {\n                largestNegative = num;\n            }\n        } else if\
    \ (num > 0) {\n            if (smallestPositive == undefined) {\n            \
    \    smallestPositive = num;\n            } else if (num < smallestPositive) {\n\
    \                smallestPositive = num;\n            }\n        }\n    });\n\
    \    return [largestNegative, smallestPositive];\n}\n", "    let largest_neg:\
    \ number | undefined;\n    let smallest_pos: number | undefined;\n    for (let\
    \ num of lst) {\n        if (num < 0) {\n            if (largest_neg === undefined\
    \ || num > largest_neg) {\n                largest_neg = num;\n            }\n\
    \        } else if (num > 0) {\n            if (smallest_pos === undefined ||\
    \ num < smallest_pos) {\n                smallest_pos = num;\n            }\n\
    \        }\n    }\n    return [largest_neg, smallest_pos];\n}\n", "  let sorted\
    \ = lst.sort((a, b) => b - a);\n  let [neg, pos] = [[], []];\n  for (let i = 0;\
    \ i < sorted.length; i++) {\n    if (sorted[i] < 0) {\n      neg.push(sorted[i]);\n\
    \    } else if (sorted[i] > 0) {\n      pos.push(sorted[i]);\n    }\n  }\n  return\
    \ [neg[0], pos[0]];\n}\n", "  if (lst.length == 0) {\n    return [undefined, undefined];\n\
    \  }\n  let maxNegative = undefined;\n  let minPositive = undefined;\n  for (let\
    \ i = 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (maxNegative\
    \ === undefined || lst[i] > maxNegative) {\n        maxNegative = lst[i];\n  \
    \    }\n    } else if (lst[i] > 0) {\n      if (minPositive === undefined || lst[i]\
    \ < minPositive) {\n        minPositive = lst[i];\n      }\n    }\n  }\n  return\
    \ [maxNegative, minPositive];\n}\n", "    let smallestPos: number | undefined;\n\
    \    let largestNeg: number | undefined;\n    lst.forEach(ele => {\n        if\
    \ (ele < 0) {\n            if (largestNeg == undefined) {\n                largestNeg\
    \ = ele;\n            } else if (ele > largestNeg) {\n                largestNeg\
    \ = ele;\n            }\n        } else if (ele > 0) {\n            if (smallestPos\
    \ == undefined) {\n                smallestPos = ele;\n            } else if (ele\
    \ < smallestPos) {\n                smallestPos = ele;\n            }\n      \
    \  }\n    });\n    return [largestNeg, smallestPos];\n}\n", "    var pos = [];\n\
    \    var neg = [];\n    for (var i = 0; i < lst.length; i++) {\n        if (lst[i]\
    \ < 0) {\n            neg.push(lst[i]);\n        } else if (lst[i] > 0) {\n  \
    \          pos.push(lst[i]);\n        }\n    }\n    var pos_smallest = pos.length\
    \ > 0 ? Math.min(...pos) : undefined;\n    var neg_largest = neg.length > 0 ?\
    \ Math.max(...neg) : undefined;\n    return [neg_largest, pos_smallest];\n}",
  "    if (lst.length == 0) {\n        return [undefined, undefined];\n    }\n   \
    \ var pos = lst.filter(x => x > 0);\n    var neg = lst.filter(x => x < 0);\n \
    \   if (pos.length == 0) {\n        return [neg.reduce((a, b) => Math.max(a, b)),\
    \ undefined];\n    }\n    if (neg.length == 0) {\n        return [undefined, pos.reduce((a,\
    \ b) => Math.min(a, b))];\n    }\n    return [neg.reduce((a, b) => Math.max(a,\
    \ b)), pos.reduce((a, b) => Math.min(a, b))];\n}\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));\n",
  "  return [undefined, undefined];\n}\n", "    let largest_neg = -1 * Number.MAX_VALUE;\n\
    \    let smallest_pos = Number.MAX_VALUE;\n    for (let num of lst) {\n      \
    \  if (num < 0 && num > largest_neg) {\n            largest_neg = num;\n     \
    \   }\n        if (num > 0 && num < smallest_pos) {\n            smallest_pos\
    \ = num;\n        }\n    }\n    return [largest_neg === -1 * Number.MAX_VALUE\
    \ ? undefined : largest_neg, smallest_pos === Number.MAX_VALUE ? undefined : smallest_pos];\n\
    }\n\nconsole.log(largest_smallest_integers([2, 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\n\
    console.log(largest_smallest_integers([0]));\n", "    let min: number | undefined;\n\
    \    let max: number | undefined;\n    let firstPositive: boolean = true;\n  \
    \  let firstNegative: boolean = true;\n    for (let num of lst) {\n        if\
    \ (num > 0) {\n            if (firstPositive) {\n                min = num;\n\
    \                firstPositive = false;\n            } else {\n              \
    \  min = Math.min(min!, num);\n            }\n        } else if (num < 0) {\n\
    \            if (firstNegative) {\n                max = num;\n              \
    \  firstNegative = false;\n            } else {\n                max = Math.max(max!,\
    \ num);\n            }\n        }\n    }\n    return [max, min];\n}\n", "    if\
    \ (lst.length > 0) {\n        let smallest = lst[0];\n        let largest = lst[0];\n\
    \        for (let i = 0; i < lst.length; i++) {\n            if (lst[i] > 0) {\n\
    \                if (lst[i] < smallest) {\n                    smallest = lst[i];\n\
    \                }\n            } else {\n                if (lst[i] > largest)\
    \ {\n                    largest = lst[i];\n                }\n            }\n\
    \        }\n        return [largest, smallest];\n    } else {\n        return\
    \ [undefined, undefined];\n    }\n}\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));",
  "    let min = undefined;\n    let max = undefined;\n    lst.forEach(function (el)\
    \ {\n        if (el > 0) {\n            if (min == undefined || el < min) {\n\
    \                min = el;\n            }\n        } else if (el < 0) {\n    \
    \        if (max == undefined || el > max) {\n                max = el;\n    \
    \        }\n        }\n    });\n    return [max, min];\n}", "    return [Math.max(...lst.filter(x\
    \ => x < 0)), Math.min(...lst.filter(x => x > 0))];\n}\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));\n",
  "  return [lst.filter(x => x < 0).reduce((x, y) => x > y ? x : y, 0), lst.filter(x\
    \ => x > 0).reduce((x, y) => x < y ? x : y, 0)];\n}\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));\n",
  "    const filtered_list = lst.filter( (x) => x !== 0 )\n\n    let pos_val = filtered_list.filter(\
    \ x => x > 0 ).sort((a, b) => a - b)[0]\n    let neg_val = filtered_list.filter(\
    \ x => x < 0 ).sort((a, b) => b - a)[0]\n\n    return [neg_val, pos_val]\n}\n",
  "    let max_of_neg = 0;\n    let min_of_pos = 0;\n    let found_max_of_neg = false;\n\
    \    let found_min_of_pos = false;\n    for (let i = 0; i < lst.length; i++) {\n\
    \        let el = lst[i];\n        if (el < 0) {\n            if (!found_max_of_neg)\
    \ {\n                max_of_neg = el;\n                found_max_of_neg = true;\n\
    \            } else {\n                if (el > max_of_neg) {\n              \
    \      max_of_neg = el;\n                }\n            }\n        } else if (el\
    \ > 0) {\n            if (!found_min_of_pos) {\n                min_of_pos = el;\n\
    \                found_min_of_pos = true;\n            } else {\n            \
    \    if (el < min_of_pos) {\n                    min_of_pos = el;\n          \
    \      }\n            }\n        }\n    }\n    if (!found_max_of_neg) {\n    \
    \    max_of_neg = undefined;\n    }\n    if (!found_min_of_pos) {\n        min_of_pos\
    \ = undefined;\n    }\n    return [max_of_neg, min_of_pos];\n}\n", "    return\
    \ [lst.reduce((max, curr) => curr < 0 && curr > max ? curr : max, lst[0]),\n \
    \           lst.reduce((min, curr) => curr > 0 && curr < min ? curr : min, lst[0])];\n\
    }\n", "  let smallest: number | undefined;\n  let largest: number | undefined;\n\
    \  let found_positive = false;\n  let found_negative = false;\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    if (lst[i] < 0) {\n      if (found_negative)\
    \ {\n        if (lst[i] > largest!) {\n          largest = lst[i];\n        }\n\
    \      } else {\n        largest = lst[i];\n        found_negative = true;\n \
    \     }\n    } else if (lst[i] > 0) {\n      if (found_positive) {\n        if\
    \ (lst[i] < smallest!) {\n          smallest = lst[i];\n        }\n      } else\
    \ {\n        smallest = lst[i];\n        found_positive = true;\n      }\n   \
    \ }\n  }\n  return [largest, smallest];\n}\n", "    let a: number | undefined;\n\
    \    let b: number | undefined;\n    for (let i of lst) {\n        if (i < 0)\
    \ {\n            if (a === undefined) {\n                a = i;\n            }\
    \ else if (i > a) {\n                a = i;\n            }\n        } else if\
    \ (i > 0) {\n            if (b === undefined) {\n                b = i;\n    \
    \        } else if (i < b) {\n                b = i;\n            }\n        }\n\
    \    }\n    return [a, b];\n}\nconsole.log(largest_smallest_integers([2, 4, 1,\
    \ 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));\n",
  "    // Your Code Here\n    let largest = 0\n    let smallest = 1\n    let a = undefined\n\
    \    let b = undefined\n    for (let i = 0; i < lst.length; i++) {\n        if\
    \ (lst[i] < 0) {\n            if (lst[i] > largest) {\n                largest\
    \ = lst[i]\n            }\n        }\n        if (lst[i] > 0) {\n            if\
    \ (lst[i] < smallest) {\n                smallest = lst[i]\n            }\n  \
    \      }\n    }\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i]\
    \ === largest) {\n            a = largest\n        }\n        if (lst[i] === smallest)\
    \ {\n            b = smallest\n        }\n    }\n    let c = [a, b]\n    return\
    \ c\n}\n", "  return [\n    lst.filter(a => a < 0).reduce((a, b) => Math.max(a,\
    \ b), undefined),\n    lst.filter(a => a > 0).reduce((a, b) => Math.min(a, b),\
    \ undefined)\n  ];\n}"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
