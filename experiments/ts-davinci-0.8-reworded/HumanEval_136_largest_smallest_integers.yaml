name: HumanEval_136_largest_smallest_integers
language: ts
prompt: "//Create a function that returns an array (a, b), where 'a' is\n// the largest\
  \ of negative integers, and 'b' is the smallest\n// of positive integers in an array.\n\
  // If there is no negative or positive integers, return them as undefined.\n// Examples:\n\
  // >>> largest_smallest_integers([2, 4, 1, 3, 5, 7])\n// [undefined, 1]\n// >>>\
  \ largest_smallest_integers([])\n// [undefined, undefined]\n// >>> largest_smallest_integers([0])\n\
  // [undefined, undefined]\nfunction largest_smallest_integers(lst: number[]): [number\
  \ | undefined, number | undefined] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = largest_smallest_integers;\n  assert.deepEqual(candidate([2,\
  \ 4, 1, 3, 5, 7]),[undefined, 1]);\n  assert.deepEqual(candidate([2, 4, 1, 3, 5,\
  \ 7, 0]),[undefined, 1]);\n  assert.deepEqual(candidate([1, 3, 2, 4, 5, 6, -2]),[-2,\
  \ 1]);\n  assert.deepEqual(candidate([4, 5, 3, 6, 2, 7, -7]),[-7, 2]);\n  assert.deepEqual(candidate([7,\
  \ 3, 8, 4, 9, 2, 5, -9]),[-9, 2]);\n  assert.deepEqual(candidate([]),[undefined,\
  \ undefined]);\n  assert.deepEqual(candidate([0]),[undefined, undefined]);\n  assert.deepEqual(candidate([-1,\
  \ -3, -5, -6]),[-1, undefined]);\n  assert.deepEqual(candidate([-1, -3, -5, -6,\
  \ 0]),[-1, undefined]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, 1]),[-3,\
  \ 1]);\n  assert.deepEqual(candidate([-6, -4, -4, -3, -100, 1]),[-3, 1]);\n}\n\n\
  test();"
completions: ["    let a: number | undefined = undefined\n    let b: number | undefined\
    \ = undefined\n    for (let i = 0; i < lst.length; i++) {\n        if (lst[i]\
    \ > 0) {\n            if (b === undefined) {\n                b = lst[i]\n   \
    \         } else if (lst[i] < b) {\n                b = lst[i]\n            }\n\
    \        } else if (lst[i] < 0) {\n            if (a === undefined) {\n      \
    \          a = lst[i]\n            } else if (lst[i] > a) {\n                a\
    \ = lst[i]\n            }\n        }\n    }\n    return [a, b]\n}\n", "    if\
    \ (lst.length === 0) return [undefined, undefined];\n    return [Math.max(...lst.filter(x\
    \ => x < 0)), Math.min(...lst.filter(x => x > 0))];\n}\n", "    // Your code here\n\
    \    let max_neg: number | undefined = undefined;\n    let min_pos: number | undefined\
    \ = undefined;\n    for (let i of lst) {\n        if (i < 0) {\n            if\
    \ (max_neg == undefined) {\n                max_neg = i;\n            } else if\
    \ (i > max_neg) {\n                max_neg = i;\n            }\n        } else\
    \ if (i > 0) {\n            if (min_pos == undefined) {\n                min_pos\
    \ = i;\n            } else if (i < min_pos) {\n                min_pos = i;\n\
    \            }\n        }\n    }\n    return [max_neg, min_pos];\n}\n", "    const\
    \ mapped = lst.map( x => [x > 0, x]);\n    let smallest: number | undefined;\n\
    \    let largest: number | undefined;\n    for (const pair of mapped) {\n    \
    \    if (pair[0]) {\n            if (smallest === undefined || pair[1] < smallest)\
    \ {\n                smallest = pair[1];\n            }\n        } else {\n  \
    \          if (largest === undefined || pair[1] > largest) {\n               \
    \ largest = pair[1];\n            }\n        }\n    }\n    return [largest, smallest];\n\
    }\n", "    var largest_negative: number | undefined;\n    var smallest_positive:\
    \ number | undefined;\n    for (var i = 0; i < lst.length; i++) {\n        if\
    \ (lst[i] < 0) {\n            if (largest_negative === undefined) {\n        \
    \        largest_negative = lst[i];\n            } else if (lst[i] > largest_negative)\
    \ {\n                largest_negative = lst[i];\n            }\n        } else\
    \ if (lst[i] > 0) {\n            if (smallest_positive === undefined) {\n    \
    \            smallest_positive = lst[i];\n            } else if (lst[i] < smallest_positive)\
    \ {\n                smallest_positive = lst[i];\n            }\n        }\n \
    \   }\n    return [largest_negative, smallest_positive];\n}\n\n", "  let max_negative:\
    \ number | undefined = undefined;\n  let min_positive: number | undefined = undefined;\n\
    \  for (let num of lst) {\n    if (num < 0) {\n      if (max_negative == undefined\
    \ || num > max_negative) {\n        max_negative = num;\n      }\n    } else if\
    \ (num > 0) {\n      if (min_positive == undefined || num < min_positive) {\n\
    \        min_positive = num;\n      }\n    }\n  }\n  return [max_negative, min_positive];\n\
    }", "    // create two variables for tracking the highest negative and lowest\
    \ positive\n    let highestNegative = undefined;\n    let lowestPositive = undefined;\n\
    \    // loop through the array, updating the variables as necessary\n    for (let\
    \ i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n            if (highestNegative\
    \ === undefined || lst[i] > highestNegative) {\n                highestNegative\
    \ = lst[i];\n            }\n        } else if (lst[i] > 0) {\n            if (lowestPositive\
    \ === undefined || lst[i] < lowestPositive) {\n                lowestPositive\
    \ = lst[i];\n            }\n        }\n    }\n    // return a tuple (immutable\
    \ ordered list of length 2) containing the variables\n    return [highestNegative,\
    \ lowestPositive];\n}\n", "    const pos = lst.filter(x => x > 0);\n    const\
    \ neg = lst.filter(x => x < 0);\n    return [neg.length > 0 ? Math.max(...neg)\
    \ : undefined, pos.length > 0 ? Math.min(...pos) : undefined];\n}\n\nconsole.log(largest_smallest_integers([2,\
    \ 4, 1, 3, 5, 7]));\nconsole.log(largest_smallest_integers([]));\nconsole.log(largest_smallest_integers([0]));\n",
  "    if (lst.length == 0) {\n        return [undefined, undefined];\n    }\n   \
    \ if (lst.length == 1) {\n        return [undefined, undefined];\n    }\n    if\
    \ (lst.length == 2) {\n        return [undefined, undefined];\n    }\n    let\
    \ neg = -Number.MAX_VALUE;\n    let pos = Number.MAX_VALUE;\n    let flag1 = false;\n\
    \    let flag2 = false;\n    for (let i = 0; i < lst.length; i++) {\n        if\
    \ (lst[i] > 0) {\n            if (lst[i] < pos) {\n                pos = lst[i];\n\
    \                flag2 = true;\n            }\n        }\n        if (lst[i] <\
    \ 0) {\n            if (lst[i] > neg) {\n                neg = lst[i];\n     \
    \           flag1 = true;\n            }\n        }\n    }\n    return [flag1\
    \ ? neg : undefined, flag2 ? pos : undefined];\n}\n", "    let min: number | undefined\
    \ = undefined;\n    let max: number | undefined = undefined;\n    for (let n of\
    \ lst) {\n        if (min === undefined && n > 0) {\n            min = n;\n  \
    \      }\n        if (max === undefined && n < 0) {\n            max = n;\n  \
    \      }\n        if (n > 0 && n < min) {\n            min = n;\n        }\n \
    \       if (n < 0 && n > max) {\n            max = n;\n        }\n    }\n    return\
    \ [max, min];\n}\n", "  let negative: number[] = [];\n  let positive: number[]\
    \ = [];\n  lst.forEach(function (num) {\n    if (num > 0) {\n      positive.push(num);\n\
    \    } else if (num < 0) {\n      negative.push(num);\n    }\n  });\n  negative.sort(function\
    \ (a, b) {\n    return a - b;\n  });\n  positive.sort(function (a, b) {\n    return\
    \ a - b;\n  });\n  if (negative.length > 0 && positive.length > 0) {\n    return\
    \ [negative[0], positive[0]];\n  } else if (negative.length > 0) {\n    return\
    \ [negative[0], undefined];\n  } else if (positive.length > 0) {\n    return [undefined,\
    \ positive[0]];\n  } else {\n    return [undefined, undefined];\n  }\n}\n", " \
    \   //TODO: implement function\n    return [undefined, undefined];\n}\n", "  const\
    \ positive = lst.filter(i => i > 0);\n  const negative = lst.filter(i => i < 0);\n\
    \  return [\n    negative.length == 0 ? undefined : Math.max(...negative),\n \
    \   positive.length == 0 ? undefined : Math.min(...positive)\n  ];\n}", "    if\
    \ (lst.length == 0) {\n        return [undefined, undefined];\n    }\n    let\
    \ highestNegative = Number.MIN_SAFE_INTEGER;\n    let lowestPositive = Number.MAX_SAFE_INTEGER;\n\
    \    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0 && lst[i]\
    \ > highestNegative) {\n            highestNegative = lst[i];\n        }\n   \
    \     if (lst[i] > 0 && lst[i] < lowestPositive) {\n            lowestPositive\
    \ = lst[i];\n        }\n    }\n    if (highestNegative == Number.MIN_SAFE_INTEGER)\
    \ {\n        highestNegative = undefined;\n    }\n    if (lowestPositive == Number.MAX_SAFE_INTEGER)\
    \ {\n        lowestPositive = undefined;\n    }\n    return [highestNegative,\
    \ lowestPositive];\n}\n", "    return [undefined, undefined];\n}\n", "    if (lst.length\
    \ === 0) {\n        return [undefined, undefined];\n    }\n    let high = Math.max(...lst);\n\
    \    let low = Math.min(...lst);\n    let lowCheck = 0;\n    let highCheck = 0;\n\
    \    for (let i = 0; i < lst.length; i++) {\n        if (lst[i] < 0) {\n     \
    \       lowCheck++;\n        }\n        if (lst[i] > 0) {\n            highCheck++;\n\
    \        }\n    }\n    if (lowCheck === 0) {\n        low = undefined;\n    }\n\
    \    if (highCheck === 0) {\n        high = undefined;\n    }\n    return [high,\
    \ low];\n}\n", "    let largestNegativeInteger: number | undefined;\n    let smallestPositiveInteger:\
    \ number | undefined;\n    for (let i = 0; i < lst.length; i++) {\n        if\
    \ (lst[i] < 0) {\n            if (largestNegativeInteger === undefined) {\n  \
    \              largestNegativeInteger = lst[i];\n            } else if (lst[i]\
    \ > largestNegativeInteger) {\n                largestNegativeInteger = lst[i];\n\
    \            }\n        } else if (lst[i] > 0) {\n            if (smallestPositiveInteger\
    \ === undefined) {\n                smallestPositiveInteger = lst[i];\n      \
    \      } else if (lst[i] < smallestPositiveInteger) {\n                smallestPositiveInteger\
    \ = lst[i];\n            }\n        }\n    }\n    return [largestNegativeInteger,\
    \ smallestPositiveInteger];\n}\n", "    return [undefined, undefined];\n}\n",
  "    var small = 0;\n    var big = 0;\n    if (lst.length == 0) {\n        return\
    \ [undefined, undefined];\n    }\n    if (lst.length == 1) {\n        return [undefined,\
    \ undefined];\n    }\n    small = lst[0];\n    big = lst[0];\n    for (var i =\
    \ 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            if (small\
    \ > lst[i]) {\n                small = lst[i];\n            }\n        }\n   \
    \     if (lst[i] < 0) {\n            if (big < lst[i]) {\n                big\
    \ = lst[i];\n            }\n        }\n    }\n    return [big, small];\n}\n",
  "    // CODE GOES HERE\n    if (lst.length === 0) {\n        return [undefined,\
    \ undefined];\n    }\n    if (lst.length === 1) {\n        return [undefined,\
    \ undefined];\n    }\n    if (lst.length === 2) {\n        if (lst[0] < 0 && lst[1]\
    \ > 0) {\n            return [lst[0], lst[1]];\n        }\n        if (lst[0]\
    \ > 0 && lst[1] < 0) {\n            return [lst[1], lst[0]];\n        }\n    \
    \    return [undefined, undefined];\n    }\n    const positives = lst.filter(function\
    \ (x) {\n        return x > 0;\n    });\n    const negatives = lst.filter(function\
    \ (x) {\n        return x < 0;\n    });\n    if (positives.length === 0 || negatives.length\
    \ === 0) {\n        return [undefined, undefined];\n    }\n    return [Math.max(...negatives),\
    \ Math.min(...positives)];\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
