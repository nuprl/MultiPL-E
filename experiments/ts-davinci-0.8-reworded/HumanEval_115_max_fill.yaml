name: HumanEval_115_max_fill
language: ts
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
completions: ["  const weights = grid.reduce((acc, curr) => acc.concat(curr.map((n)\
    \ => n * capacity)), []);\n  const percentages = weights.map((n) => n / capacity);\n\
    \  const weightsWithMedian = percentages.map((n) => Math.floor(n - (1 - 0.5)));\n\
    \  const bucketsNeeded = weightsWithMedian.reduce((acc, curr) => acc + curr, 0);\n\
    \  return bucketsNeeded;\n}\n", "    let result = 0;\n    const rows = grid.length;\n\
    \    const cols = grid[0].length;\n    const well = [];\n    const temp = [];\n\
    \    const bucket = capacity;\n    const counter = [];\n    // filling well\n\
    \    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols;\
    \ col++) {\n            well.push(grid[row][col]);\n        }\n    }\n    for\
    \ (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n   \
    \         if (well[cols * i + j] === 1) {\n                temp.push(bucket);\n\
    \            } else {\n                temp.push(0);\n            }\n        }\n\
    \    }\n    for (let i = 0; i < rows; i++) {\n        counter.push(cols);\n  \
    \  }\n    while (true) {\n        const sum = [...temp].reduce((acc, x) => acc\
    \ + x, 0);\n        if (sum > 0) {\n            for (let row = 0; row < rows;\
    \ row++) {\n                for (let col = 0; col < cols; col++) {\n         \
    \           if (temp[cols * row + col] > 0) {\n                        temp[cols\
    \ * row + col] -= 1;\n                        if (temp[cols * row + col] === 0)\
    \ {\n                            counter[row] -= 1;\n                        }\n\
    \                    }\n                }\n            }\n            result +=\
    \ 1;\n        } else {\n            break;\n        }\n    }\n    // console.log(counter);\n\
    \    if (counter.every(x => x === 0)) {\n        return result;\n    } else {\n\
    \        return -1;\n    }\n}\n\n(function () {\n    console.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\n    console.log(max_fill([[0, 0,\
    \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,", "    let row: number[] = [];\n    let\
    \ min: number = 0;\n    let max: number = 0;\n    let result: number = 0;\n  \
    \  for (let i: number = 0; i < grid.length; i++) {\n        for (let j: number\
    \ = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
    \           row.push(1);\n            } else {\n                row.push(0);\n\
    \            }\n        }\n        min = Math.min(...row);\n        max = Math.max(...row);\n\
    \        result += max * capacity - (max - min) * capacity;\n        row = [];\n\
    \    }\n    return result;\n}", "  let num_buckets = 0;\n  let bucket_capacity\
    \ = capacity;\n  let [rows, cols] = [grid.length, grid[0].length];\n  for (let\
    \ i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j]\
    \ > 0) {\n        num_buckets += 1;\n        bucket_capacity -= grid[i][j];\n\
    \      }\n    }\n    bucket_capacity = capacity;\n  }\n  return num_buckets;\n\
    }\n\n(function main(): void {\n  const a = [\n    [0, 0, 1, 0],\n    [0, 1, 0,\
    \ 0],\n    [1, 1, 1, 1]\n  ];\n  const b = [\n    [0, 0, 1, 1],\n    [0, 0, 0,\
    \ 0],\n    [1, 1, 1, 1],\n    [0, 1, 1, 1]\n  ];\n  const c = [\n    [0, 0, 0],\n\
    \    [0, 0, 0]\n  ];\n  console.log(max_fill(a, 1));\n  console.log(max_fill(b,\
    \ 2));\n  console.log(max_fill(c, 5));\n})();", "  let times = 0;\n  let visit\
    \ = [];\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      visit.push([i, j]);\n      if (grid[i][j] === 1) {\n        grid[i][j]\
    \ = capacity;\n        times += capacity;\n      }\n    }\n  }\n  while (visit.length\
    \ > 0) {\n    let [i, j] = visit.shift();\n    if (grid[i][j] > 0) {\n      for\
    \ (let [i1, j1] of [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]) {\n     \
    \   if (\n          i1 >= 0 &&\n          i1 < grid.length &&\n          j1 >=\
    \ 0 &&\n          j1 < grid[i].length &&\n          grid[i1][j1] < grid[i][j]\n\
    \        ) {\n          visit.push([i1, j1]);\n          grid[i1][j1] += grid[i][j]\
    \ - 1;\n          times += grid[i][j] - 1;\n        }\n      }\n    }\n  }\n \
    \ return times;\n}\n\n(function () {\n  function assertEquals(a, b) {\n    if\
    \ (a === b) {\n      console.log(\"PASS\");\n    } else {\n      console.log(\"\
    FAIL\", a, b);\n    }\n  }\n  assertEquals(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1), 6);\n  assertEquals(\n    max_fill([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),\n    5\n  );\n  assertEquals(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5), 0);\n})();", "  return 0;\n}\n", "    let times = 0;\n\
    \    let test = grid;\n    while (!validateGrid(test)) {\n        times++;\n \
    \       test = add_water(test, capacity);\n    }\n    return times;\n}\n", " \
    \   let all_ones = true;\n    let buckets_needed = 0;\n    for (let x = 0; x <\
    \ grid.length; x++) {\n        for (let y = 0; y < grid[x].length; y++) {\n  \
    \          if (grid[x][y] === 0) {\n                all_ones = false;\n      \
    \      }\n        }\n    }\n    if (all_ones) {\n        return 0;\n    } else\
    \ {\n        while (true) {\n            let bucket_count = 0;\n            for\
    \ (let x = 0; x < grid.length; x++) {\n                for (let y = 0; y < grid[x].length;\
    \ y++) {\n                    if (grid[x][y] === 1) {\n                      \
    \  bucket_count++;\n                    }\n                }\n            }\n\
    \            if (bucket_count < capacity) {\n                buckets_needed++;\n\
    \                for (let x = 0; x < grid.length; x++) {\n                   \
    \ for (let y = 0; y < grid[x].length; y++) {\n                        if (grid[x][y]\
    \ === 1) {\n                            grid[x][y] = 0;\n                    \
    \    }\n                    }\n                }\n            } else {\n     \
    \           return buckets_needed;\n            }\n        }\n    }\n}\n", " \
    \   let times = 0;\n    grid.forEach(row => {\n        let current = 0;\n    \
    \    row.forEach(cell => {\n            if (cell === 1) {\n                current\
    \ += 1;\n            }\n        });\n        times += (current / capacity) + ((current\
    \ % capacity) > 0 ? 1 : 0);\n    });\n    return times;\n}\n", "  let count =\
    \ 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] == 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n", "    let sum = 0;\n    let water = 0;\n  \
    \  let fill = 0;\n    while (true) {\n        if (sum === grid.length) {\n   \
    \         break;\n        }\n        let maxCol = getMaxCol(grid);\n        let\
    \ maxColStart = grid[maxCol].length - 1;\n        for (let i = maxColStart; i\
    \ >= 0; i--) {\n            if (grid[maxCol][i] === 1) {\n                if (water\
    \ < capacity) {\n                    water += 1;\n                    grid[maxCol][i]\
    \ = 0;\n                } else {\n                    water = 0;\n           \
    \         fill += 1;\n                }\n            }\n        }\n        sum\
    \ += 1;\n    }\n    return fill;\n}\n", "    let count = 0;\n    let maxPos =\
    \ { row: 0, pos: 0 };\n    for (let row = 0; row < grid.length; row++) {\n   \
    \     for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col]\
    \ > grid[maxPos.row][maxPos.pos]) {\n                maxPos.row = row;\n     \
    \           maxPos.pos = col;\n            }\n        }\n    }\n    for (let row\
    \ = 0; row < grid.length; row++) {\n        let col = maxPos.pos;\n        while\
    \ (col < grid[row].length) {\n            count += grid[row][col];\n         \
    \   col++;\n        }\n    }\n    return count * capacity;\n}\n\nlet grid: number[][]\
    \ = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]];\nconsole.log(max_fill(grid, 1));\n\
    grid = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]];\nconsole.log(max_fill(grid,\
    \ 2));\ngrid = [[0, 0, 0], [0, 0, 0]];\nconsole.log(max_fill(grid, 5));", "  \
    \  throw new Error(\"Method not implemented.\");\n}\n", "    let drops = 0;\n\
    \    // Store the maximum height of each column\n    let maxHeight: number[] =\
    \ [];\n    for (let col = 0; col < grid[0].length; col++) {\n        maxHeight.push(0);\n\
    \        for (let row = 0; row < grid.length; row++) {\n            if (grid[row][col]\
    \ === 1) {\n                maxHeight[col] = row + 1;\n            }\n       \
    \ }\n    }\n    let currentHeight = 0;\n    while (currentHeight < Math.max(...maxHeight))\
    \ {\n        // Sort the columns by height\n        maxHeight.sort((a, b) => a\
    \ - b);\n        // Iterate through the columns until we find one with enough\
    \ water to fill the bucket\n        for (let col = 0; col < maxHeight.length;\
    \ col++) {\n            if (maxHeight[col] >= currentHeight + capacity) {\n  \
    \              // Once we find one, fill the bucket and lower it\n           \
    \     currentHeight += capacity;\n                drops++;\n                //\
    \ Remove the water from the column\n                maxHeight[col] -= capacity;\n\
    \                break;\n            }\n        }\n    }\n    return drops;\n\
    }\n", "  const rows = grid.length;\n  const cols = grid[0].length;\n  let sum\
    \ = 0;\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++)\
    \ {\n      if (grid[r][c] === 1) {\n        sum += capacity;\n      }\n    }\n\
    \  }\n  return sum;\n}\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "\tlet water = 0;\n\tfor (let i = 0; i < grid.length; i++) {\n\t\tlet row = grid[i];\n\
    \t\tfor (let j = 0; j < row.length; j++) {\n\t\t\tlet bucket = row[j];\n\t\t\t\
    if (bucket) {\n\t\t\t\twater += capacity;\n\t\t\t}\n\t\t}\n\t}\n\treturn water;\n\
    }\n", "\t// init count\n\t// loop through wells\n\t// try to fill till capacity\n\
    \t// if can fill\n\t// increment count\n\tlet count = 0;\n\tfor (let i = 0; i\
    \ < grid.length; i++) {\n\t\tfor (let j = 0; j < grid[i].length; j++) {\n\t\t\t\
    let canFit = capacity;\n\t\t\tlet index = j;\n\t\t\twhile (canFit > 0 && index\
    \ < grid[i].length) {\n\t\t\t\tif (grid[i][index] === 1) {\n\t\t\t\t\tcanFit--;\n\
    \t\t\t\t\tindex++;\n\t\t\t\t} else {\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\
    \t\t\tif (canFit < capacity) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n\nexport { max_fill };", "  let counter = 0;\n  let index = grid[0].length\
    \ - 1;\n  const add = () => {\n    let sum = 0;\n    for (let row of grid) {\n\
    \      sum += row[index];\n    }\n    return sum;\n  };\n  while (index >= 0)\
    \ {\n    let addValue = add();\n    if (addValue >= capacity) {\n      for (let\
    \ row of grid) {\n        row[index] = 0;\n      }\n      counter += capacity;\n\
    \    } else {\n      for (let row of grid) {\n        row[index] = 0;\n      }\n\
    \      counter += addValue;\n    }\n    index--;\n  }\n  return counter;\n}\n",
  "  let count = 0;\n  let min = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
    \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        count++;\n      }\n    }\n    if (i === 0) {\n      min = count;\n  \
    \  } else {\n      min = Math.min(min, count);\n    }\n    count = 0;\n  }\n \
    \ return min * capacity;\n}\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let times = 0;\n    let filledRows = 0;\n    while (filledRows < grid.length)\
    \ {\n        let filledCols = 0;\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            let gridRowCol = [filledRows, j];\n            if (grid[gridRowCol[0]][gridRowCol[1]]\
    \ === 1) {\n                grid = updateGrid(grid, gridRowCol, capacity);\n \
    \               filledCols++;\n            }\n        }\n        filledRows +=\
    \ Math.ceil(filledCols / capacity);\n        times++;\n    }\n    return times;\n\
    }\n", "  let maxFill = 0;\n  let wellsCount = grid.length;\n  let wellsLength\
    \ = grid[0].length;\n  let run = 0;\n  let currentWellIndex = 0;\n  let currentWell\
    \ = grid[currentWellIndex];\n  let skipCurrentWell = false;\n  let fill = 0;\n\
    \  let wellsFilled = 0;\n  for (run; run < capacity; run++) {\n    for (let i\
    \ = 0; i < wellsLength; i++) {\n      if (currentWell[i] === 1) {\n        fill\
    \ += 1;\n        currentWell[i] = 0;\n      }\n    }\n    if (fill === wellsLength)\
    \ {\n      wellsFilled += 1;\n      fill = 0;\n      if (wellsFilled === wellsCount)\
    \ {\n        return maxFill;\n      }\n      currentWellIndex += 1;\n      currentWell\
    \ = grid[currentWellIndex];\n    }\n    maxFill += 1;\n  }\n  return maxFill;\n\
    }\n\nexport { max_fill };", "  let max_fill = 0;\n  for (let row of grid) {\n\
    \    max_fill += Math.floor(row.reduce((accum, current) => accum + current) /\
    \ capacity);\n  }\n  return max_fill;\n}\n\nexport { max_fill };", "    const\
    \ max = [...grid.reduce((acc, row) => [...acc, ...row], [])].reduce((acc, item)\
    \ => item > acc ? item : acc, 0);\n    const min = [...grid.reduce((acc, row)\
    \ => [...acc, ...row], [])].reduce((acc, item) => item < acc ? item : acc, 0);\n\
    \    console.log(min);\n    console.log(max);\n    const result = [min, max].reduce((acc,\
    \ item) => {\n        return acc;\n    }, 0);\n    return result;\n}\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));", "  // Fill grid vertically\n \
    \ for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] == 1) {\n        grid[i][j] = capacity;\n     \
    \ }\n    }\n  }\n\n  // Fill grid horizontally\n  for (let i = 1; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      let gap = 0;\n\
    \      for (let k = i - 1; k >= 0; k--) {\n        if (grid[k][j] == capacity)\
    \ {\n          gap++;\n        } else {\n          break;\n        }\n      }\n\
    \      if (gap > 0) {\n        for (let k = 0; k < gap; k++) {\n          grid[i\
    \ - k][j] = capacity;\n        }\n      }\n    }\n  }\n\n  // Get fill count\n\
    \  let fill_count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] == capacity) {\n   \
    \     fill_count++;\n      }\n    }\n  }\n\n  return fill_count;\n}\n", "    let\
    \ count = 0;\n    let rowLength = grid[0].length;\n    let columnLength = grid.length;\n\
    \    for (let i = 0; i < rowLength; i++) {\n        for (let j = 0; j < columnLength;\
    \ j++) {\n            if (grid[j][i] === 1) {\n                count += 1;\n \
    \           }\n        }\n    }\n    return count * capacity;\n}\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let remainingWater = grid.map(well => well.reduce((acc,\
    \ cur) => acc + cur, 0));\n  let currentRow = 0;\n  let rowCount = grid.length;\n\
    \  let bucketCount = 0;\n  while (currentRow < rowCount) {\n    let currentWell\
    \ = grid[currentRow];\n    let fillCount = capacity;\n    if (currentRow !== 0)\
    \ {\n      let previousWell = grid[currentRow - 1];\n      for (let i = 0; i <\
    \ currentWell.length; i++) {\n        if (currentWell[i] === 0 && previousWell[i]\
    \ === 1) {\n          fillCount = fillCount - 1;\n        }\n      }\n    }\n\
    \    let emptyCount = 0;\n    for (let i = 0; i < currentWell.length; i++) {\n\
    \      if (currentWell[i] === 0) {\n        emptyCount = emptyCount + 1;\n   \
    \   }\n    }\n    bucketCount = bucketCount + fillCount + emptyCount;\n    currentRow\
    \ = currentRow + 1;\n  }\n  return bucketCount;\n}\n\nlet testGrid1 = [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]];\nlet testGrid2 = [[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]];\nlet testGrid3 = [[0, 0, 0], [0, 0, 0]];\n\
    console.log(max_fill(testGrid1, 1));\nconsole.log(max_fill(testGrid2, 2));\nconsole.log(max_fill(testGrid3,\
    \ 5));", "    let rows = grid.length;\n    let columns = grid[0].length;\n   \
    \ let solution = 0;\n    let bucket = capacity;\n    let currentRow = 0;\n   \
    \ let currentColumn = 0;\n    while (currentRow < rows) {\n        while (currentColumn\
    \ < columns) {\n            if (grid[currentRow][currentColumn] == 1) {\n    \
    \            if (bucket != 0) {\n                    bucket -= 1;\n          \
    \          grid[currentRow][currentColumn] = 0;\n                } else {\n  \
    \                  solution += 1;\n                    bucket = capacity;\n  \
    \                  bucket -= 1;\n                    grid[currentRow][currentColumn]\
    \ = 0;\n                }\n            }\n            currentColumn += 1;\n  \
    \      }\n        currentColumn = 0;\n        currentRow += 1;\n    }\n    return\
    \ solution;\n}", "    let total = 0;\n    let num_rows = grid.length;\n    let\
    \ num_cols = grid[0].length;\n    let visited: boolean[][] = new Array(num_rows);\n\
    \    for (let i = 0; i < num_rows; i++) {\n        visited[i] = new Array(num_cols);\n\
    \        for (let j = 0; j < num_cols; j++) {\n            visited[i][j] = false;\n\
    \        }\n    }\n    for (let i = 0; i < num_rows; i++) {\n        for (let\
    \ j = 0; j < num_cols; j++) {\n            if (grid[i][j] == 1 && !visited[i][j])\
    \ {\n                total += max_fill_bucket(grid, capacity, i, j, visited);\n\
    \            }\n        }\n    }\n    return total;\n}\n", "    throw new Error(\"\
    Not implemented\");\n}\n", "  const LENGTH = grid.length;\n  let moves = 0;\n\
    \  let max = -1;\n  let firstIndex = 0;\n  let lastIndex = 0;\n  for (let i =\
    \ 0; i < LENGTH; i++) {\n    let ones = [];\n    let zeros = [];\n    let row\
    \ = grid[i];\n    row.forEach((val, index) => {\n      if (val) {\n        ones.push(index);\n\
    \      } else {\n        zeros.push(index);\n      }\n    });\n    for (let j\
    \ = 0; j < ones.length; j++) {\n      let index = ones[j];\n      if (ones[j +\
    \ 1] && ones[j + 1] - index === 1) {\n        continue;\n      }\n      // now\
    \ we know the ones are broken into two groups\n      // then we need to see if\
    \ there is any place where zero can fit in\n      let current = index;\n     \
    \ let lastPlace = index;\n      while (current < row.length) {\n        let diff\
    \ = current - lastPlace;\n        if (diff === 1) {\n          break;\n      \
    \  }\n        let next = zeros.indexOf(current);\n        if (next < 0) {\n  \
    \        break;\n        }\n        lastPlace = current;\n        current = zeros[next\
    \ + 1];\n      }\n      if (current - lastPlace > max) {\n        max = current\
    \ - lastPlace;\n        firstIndex = lastPlace;\n        lastIndex = current;\n\
    \      }\n    }\n  }\n  for (let i = firstIndex; i < lastIndex; i++) {\n    grid[0][i]\
    \ = 1;\n  }\n  console.log(grid);\n  return moves;\n}\n", "  let count = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    let total = grid[i].reduce((sum,\
    \ num) => sum + num, 0);\n    count += Math.ceil(total / capacity);\n  }\n  return\
    \ count;\n}\n", "  let fill = 0;\n  for (let i = 0; i < grid.length; i++) {\n\
    \    let row = grid[i];\n    for (let j = 0; j < row.length; j++) {\n      if\
    \ (row[j] === 1) {\n        fill++;\n        grid[i] = grid[i].map(n => n - 1);\n\
    \      }\n    }\n  }\n  return fill;\n}\n", "    // Your code here...\n    let\
    \ total = 0;\n    let currentCapacity = capacity;\n    for (let i = 0; i < grid.length;\
    \ i++) {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                currentCapacity--;\n                if (currentCapacity\
    \ === 0) {\n                    total++;\n                    currentCapacity\
    \ = capacity;\n                }\n            }\n        }\n    }\n    return\
    \ total;\n}", "  let move = 0;\n  for (let i = 0; i < grid.length; i++) {\n  \
    \  for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        move += max_fill_helper(i, j, grid, capacity);\n      }\n    }\n  }\n\
    \  return move;\n}\n", "  let max_units = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        max_units++;\n      }\n    }\n  }\n  let result = 0;\n  if\
    \ (max_units > capacity) {\n    result = max_units / capacity;\n    if (max_units\
    \ % capacity !== 0) {\n      result += 1;\n    }\n  }\n  return result;\n}\n\n\
    (function() {\n  console.log(\"Example 1:\")\n  console.log(max_fill([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n  console.log(\"Example 2:\")\n  console.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n  console.log(\"Example\
    \ 3:\")\n  console.log(max_fill([[0, 0, 0], [0, 0, 0]], 5))\n})()", "  return\
    \ 0;\n}\n\nexport { max_fill };", "  const offset = 1;\n  const row_range = [0,\
    \ grid.length - offset];\n  const col_range = [0, grid[0].length - offset];\n\
    \  let operations = 0;\n  let [row, col] = [0, 0];\n  const level = new Array(col_range[1]\
    \ + offset).fill(0);\n  const state = new Array(row_range[1] + offset)\n    .fill(0)\n\
    \    .map(() => new Array(col_range[1] + offset).fill(0));\n  for (let i = 0;\
    \ i < capacity; i++) {\n    for (row = row_range[0]; row <= row_range[1]; row++)\
    \ {\n      for (col = col_range[0]; col <= col_range[1]; col++) {\n        if\
    \ (grid[row][col] === 1) {\n          level[col]++;\n          operations++;\n\
    \        }\n      }\n    }\n    if (i === capacity - offset) {\n      break;\n\
    \    }\n    row = col = 0;\n    while (row <= row_range[1]) {\n      while (col\
    \ <= col_range[1]) {\n        if (level[col] > 0) {\n          state[row][col]\
    \ = 1;\n          operations++;\n          level[col]--;\n        }\n        col++;\n\
    \      }\n      col = 0;\n      row++;\n    }\n    row = col = 0;\n    while (row\
    \ <= row_range[1]) {\n      while (col <= col_range[1]) {\n        if (state[row][col]\
    \ === 1) {\n          grid[row][col] = 0;\n        }\n        col++;\n      }\n\
    \      col = 0;\n      row++;\n    }\n  }\n  return operations;\n}\n", "    const\
    \ not_empty = grid.map(row => row.indexOf(1));\n    const num_buckets = grid[0].length;\n\
    \    let result = 0;\n    for (let i = 0; i < num_buckets; i++) {\n        const\
    \ bucket_depth = capacity - 1;\n        if (not_empty[i] <= bucket_depth) {\n\
    \            const lift_depth = not_empty[i];\n            for (let j = 0; j <\
    \ num_buckets; j++) {\n                if (not_empty[j] !== -1) {\n          \
    \          not_empty[j] -= lift_depth;\n                }\n            }\n   \
    \         result += lift_depth;\n        }\n    }\n    return result;\n}", " \
    \ let count = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j =\
    \ 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        count\
    \ += capacity;\n      }\n    }\n  }\n  return count;\n}\n\nlet wells = [[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]];\nlet capacity = 1;\nconsole.log(max_fill(wells,\
    \ capacity));\n\nwells = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1,\
    \ 1]];\ncapacity = 2;\nconsole.log(max_fill(wells, capacity));\n\nwells = [[0,\
    \ 0, 0], [0, 0, 0]];\ncapacity = 5;\nconsole.log(max_fill(wells, capacity));",
  "    // TODO: implement your solution here\n    throw \"Not Implemented\";\n}",
  "  // console.log(grid, capacity);\n  let ops = 0;\n  const maxRow = grid.length;\n\
    \  const maxCol = grid[0].length;\n  for (let row = 0; row < maxRow; row++) {\n\
    \    for (let col = 0; col < maxCol; col++) {\n      if (grid[row][col] === 1)\
    \ {\n        // console.log(`${row} ${col}`);\n        const rowTo = maxRow -\
    \ 1;\n        let colTo = 0;\n        let max = grid[rowTo][col];\n        for\
    \ (let colT = 0; colT < maxCol; colT++) {\n          if (grid[rowTo][colT] > max)\
    \ {\n            max = grid[rowTo][colT];\n            colTo = colT;\n       \
    \   }\n        }\n        // console.log(`max ${max}`);\n        if (max < capacity)\
    \ {\n          // console.log(`max < capacity ${max} ${capacity}`);\n        \
    \  grid[rowTo][colTo] = capacity;\n          ops++;\n        }\n        for (let\
    \ rowTo = maxRow - 1; rowTo > row; rowTo--) {\n          // console.log(`${rowTo}\
    \ ${colTo}`);\n          let max = grid[rowTo][colTo];\n          let colToT =\
    \ 0;\n          for (let colToT = 0; colToT < maxCol; colToT++) {\n          \
    \  if (grid[rowTo][colToT] > max) {\n              max = grid[rowTo][colToT];\n\
    \              colTo = colToT;\n            }\n          }\n          // console.log(`max\
    \ ${max}`);\n          if (max < capacity) {\n            // console.log(`max\
    \ < capacity ${max} ${capacity}`);\n            grid[rowTo][colTo] = capacity;\n\
    \            ops++;\n          }\n        }\n      }\n    }\n  }\n  // console.log(grid);\n\
    \  return ops;\n}\n\n(function() {\n  const grids = [\n    [[0, 0, 1, 0], [0,\
    \ 1, 0, 0],", "    let height = grid.length;\n    let width = grid[0].length;\n\
    \    let max_fill = 0;\n    let max_val = 0;\n    for (let i = 0; i < height;\
    \ i++) {\n        let count = 0;\n        for (let j = 0; j < width; j++) {\n\
    \            if (grid[i][j] == 1) {\n                count++;\n            }\n\
    \        }\n        if (count > max_val) {\n            max_val = count;\n   \
    \     }\n    }\n    max_fill = max_val * capacity;\n    return max_fill;\n}",
  "    const result = 0;\n    return result;\n}\n", "    let max_fill_calls = 0;\n\
    \    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                max_fill_calls++;\n\
    \                _max_fill(grid, capacity, i, j);\n            }\n        }\n\
    \    }\n    return max_fill_calls;\n}\n", "  if (capacity === 0) {\n    return\
    \ 0;\n  }\n  let count = 0;\n  const maxHeight = grid.reduce((acc, row) => {\n\
    \    if (acc < Math.max(...row)) {\n      acc = Math.max(...row);\n    }\n   \
    \ return acc;\n  }, 0);\n  for (let i = 0; i < maxHeight; i++) {\n    for (let\
    \ j = 0; j < grid.length; j++) {\n      if (grid[j][i] === 1) {\n        if (capacity\
    \ === 1) {\n          count++;\n        } else {\n          grid[j][i] = 0;\n\
    \          count++;\n          capacity--;\n        }\n      }\n    }\n  }\n \
    \ return count;\n}\n\nconst tests: { grid: number[][]; capacity: number; expected:\
    \ number }[] = [\n  {\n    grid: [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\n\
    \    capacity: 1,\n    expected: 6,\n  },\n  {\n    grid: [[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\n    capacity: 2,\n    expected: 5,\n  },\n\
    \  {\n    grid: [[0, 0, 0], [0, 0, 0]],\n    capacity: 5,\n    expected: 0,\n\
    \  },\n  {\n    grid: [[0, 0, 0], [0, 0, 0]],\n    capacity: 0,\n    expected:\
    \ 0,\n  },\n  {\n    grid: [[0, 0, 0], [0, 0, 0]],\n    capacity: 1,\n    expected:\
    \ 0,\n  },\n  {\n    grid: [[0, 0, 0], [0, 0, 0]],\n    capacity: 0,\n    expected:\
    \ 0,\n  },\n  {\n    grid: [[0, 0, 0], [0, 0, 0]],\n    capacity: 0,\n    expected:\
    \ 0,\n  },\n  {\n    grid: [[0,", "  if (grid.length === 0) {\n    return 0;\n\
    \  }\n  let sum = 0;\n  const row = grid.length;\n  const col = grid[0].length;\n\
    \  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n    \
    \  sum += grid[i][j];\n    }\n  }\n  return sum / capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let count = 0;\n  grid.forEach((row) => {\n   \
    \ row.forEach((cell) => {\n      if (cell === 1) {\n        capacity--;\n    \
    \    if (capacity === 0) {\n          capacity = capacity + row.length;\n    \
    \      count++;\n        }\n      }\n    });\n  });\n  if (capacity === grid[0].length)\
    \ {\n    return 0;\n  }\n  return count;\n}\n", "  let need = 0;\n  for (let i\
    \ = 0; i < grid.length; i++) {\n    const well = grid[i];\n    for (let j = 0;\
    \ j < well.length; j++) {\n      if (well[j] > 0) {\n        well[j] = well[j]\
    \ - capacity;\n        need++;\n      }\n    }\n  }\n  return need;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let buckets = 0;\n    let lower = true;\n   \
    \ for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                if (lower) {\n\
    \                    buckets++;\n                    lower = false;\n        \
    \        }\n            } else {\n                lower = true;\n            }\n\
    \        }\n    }\n    return buckets * capacity;\n}\n\nexport function runTests():\
    \ void {\n    const inputs = [\n        [[[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], 1],\n        [[[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2],\n        [[[0, 0, 0], [0, 0, 0]], 5]\n    ];\n\n    inputs.forEach(input\
    \ => {\n        const answer = max_fill(input[0], input[1]);\n        console.log(answer);\n\
    \    });\n}", "  let fillCount = 0;\n  for (let row of grid) {\n    let subCount\
    \ = capacity;\n    for (let cell of row) {\n      if (cell === 1) {\n        fillCount++;\n\
    \        subCount--;\n      }\n      if (subCount === 0) {\n        break;\n \
    \     }\n    }\n  }\n  return fillCount;\n}\n\ntype Friends = string[];\ninterface\
    \ Phonebook {\n  [name: string]: Friends;\n}\ntype Request = [string, string];",
  "    let n = grid.length, m = grid[0].length, count = 0;\n    for (let i = 0; i\
    \ < n; i++) {\n        let len = grid[i].length;\n        let line = grid[i];\n\
    \        while (line.length > 0) {\n            if (line[0] == 1) {\n        \
    \        line.shift();\n                len--;\n                count++;\n   \
    \         } else {\n                if (len <= capacity) {\n                 \
    \   line.shift();\n                    len--;\n                } else {\n    \
    \                for (let j = 0; j < capacity; j++) {\n                      \
    \  line.shift();\n                        len--;\n                    }\n    \
    \                count++;\n                }\n            }\n        }\n    }\n\
    \    return count;\n}\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1,\
    \ 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1],\
    \ [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", " \
    \ return 0;\n}\n", "    // Your code here!\n    return 0;\n}", "    // your code\
    \ here\n}\n", "    let max = 0;\n    let min = 0;\n    let result = 0;\n    let\
    \ length = grid.length;\n    let col = grid[0].length;\n    for (let i = 0; i\
    \ < length; i++) {\n        for (let j = 0; j < col; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                max += capacity;\n            }\n        }\n    }\n\
    \    for (let i = 0; i < length; i++) {\n        for (let j = 0; j < col; j++)\
    \ {\n            if (grid[i][j] === 1) {\n                min += capacity;\n \
    \           }\n        }\n    }\n    while (min < max) {\n        let mid = Math.floor((min\
    \ + max) / 2);\n        let row = 0;\n        let temp = 0;\n        while (row\
    \ < length) {\n            if (temp === 0) {\n                temp = capacity;\n\
    \            }\n            let col = 0;\n            while (col < grid[row].length)\
    \ {\n                if (grid[row][col] === 1) {\n                    temp--;\n\
    \                }\n                if (temp === 0) {\n                    break;\n\
    \                }\n                col++;\n            }\n            if (temp\
    \ === 0) {\n                row++;\n            } else {\n                break;\n\
    \            }\n        }\n        if (row === length) {\n            min = mid\
    \ + 1;\n            result = mid;\n        } else {\n            max = mid;\n\
    \        }\n    }\n    return result;\n}\n", "    let numOfBuckets = 0;\n    let\
    \ numOfWells = grid.length;\n    let wellLength = grid[0].length;\n    let wellIndex\
    \ = 0;\n    let numOfBucketsUsed = 0;\n    while (wellIndex < numOfWells) {\n\
    \        let bucketCapacity = capacity;\n        for (let i = 0; i < wellLength;\
    \ i++) {\n            if (grid[wellIndex][i] == 1) {\n                bucketCapacity--;\n\
    \                grid[wellIndex][i] = 0;\n            }\n            if (bucketCapacity\
    \ == 0) {\n                numOfBucketsUsed++;\n                bucketCapacity\
    \ = capacity;\n            }\n        }\n        wellIndex++;\n    }\n    return\
    \ numOfBucketsUsed;\n}\n", "    let times = 0;\n    const rows = grid.length;\n\
    \    const columns = grid[0].length;\n    for (let i = 0; i < rows; i++) {\n \
    \       for (let j = 0; j < columns; j++) {\n            if (grid[i][j] === 1)\
    \ {\n                const water = Math.min(capacity, i);\n                times\
    \ += water;\n                grid[i - water][j] = 1;\n            }\n        }\n\
    \    }\n    return times;\n}\n", "  const m = grid.length;\n  const n = grid[0].length;\n\
    \  const count = [];\n  let ans = 0;\n  let x = 0;\n  while (x < m) {\n    let\
    \ y = 0;\n    while (y < n) {\n      if (grid[x][y] === 1) {\n        y++;\n \
    \     } else {\n        let cell = Math.min(capacity, m - x, n - y);\n       \
    \ for (let i = 0; i < cell; i++) {\n          grid[x + i][y] = 1;\n        }\n\
    \        ans += cell;\n        count.push(cell);\n        y++;\n      }\n    }\n\
    \    x++;\n  }\n  return ans;\n}\n", "  // your code here\n  return 0;\n}\n\n\
    export { max_fill };", "    let result = 0;\n    for (let row of grid) {\n   \
    \     let filled = 0;\n        for (let well of row) {\n            filled +=\
    \ well;\n            if (filled === capacity) {\n                result++;\n \
    \               filled = 0;\n            }\n        }\n        if (filled > 0)\
    \ {\n            result++;\n        }\n    }\n    return result;\n}\n", "    let\
    \ lowers = 0;\n    let total = 0;\n    const rows = grid.length;\n    const cols\
    \ = grid[0].length;\n    const bucket = new Array(cols).fill(0);\n    while(bucket.filter(x\
    \ => x === capacity).length !== cols) {\n        lowers++;\n        let empty_bucket\
    \ = false;\n        for(let col = 0; col < cols; col++) {\n            if(bucket[col]\
    \ < capacity) {\n                empty_bucket = true;\n                for(let\
    \ row = 0; row < rows; row++) {\n                    if(grid[row][col] && bucket[col]\
    \ < capacity) {\n                        bucket[col] += 1;\n                 \
    \       grid[row][col] = 0;\n                    }\n                }\n      \
    \      }\n        }\n        if(!empty_bucket) {\n            lowers = 0;\n  \
    \          break;\n        }\n    }\n    return lowers;\n}\n", "  let numberOfFillings\
    \ = 0;\n  let stack: number[][] = [];\n  let visited = new Set<string>();\n  let\
    \ gridH = grid.length;\n  let gridW = grid[0].length;\n  let fill = (x: number,\
    \ y: number, grid: number[][]) => {\n    if (grid[x][y] === 1) {\n      numberOfFillings++;\n\
    \      grid[x][y] = 0;\n    }\n  };\n  stack.push([0, 0]);\n  while (stack.length\
    \ > 0) {\n    let [x, y] = stack.pop()!;\n    let key = `${x}${y}`;\n    if (visited.has(key))\
    \ {\n      continue;\n    }\n    for (let i = 0; i < capacity; i++) {\n      let\
    \ u = x - i;\n      let d = x + i;\n      let l = y - i;\n      let r = y + i;\n\
    \      if (\n        u >= 0 &&\n        d < gridH &&\n        l >= 0 &&\n    \
    \    r < gridW &&\n        !visited.has(`${u}${y}`)\n      ) {\n        fill(u,\
    \ y, grid);\n        visited.add(`${u}${y}`);\n        stack.push([u, y]);\n \
    \     }\n      if (\n        u >= 0 &&\n        d < gridH &&\n        l >= 0 &&\n\
    \        r < gridW &&\n        !visited.has(`${x}${l}`)\n      ) {\n        fill(x,\
    \ l, grid);\n        visited.add(`${x}${l}`);\n        stack.push([x, l]);\n \
    \     }\n      if (\n        u >= 0 &&\n        d < gridH &&\n        l >= 0 &&\n\
    \        r < gridW &&\n        !visited.has(`${d}${y}`)\n      ) {\n        fill(d,\
    \ y, grid);\n        visited.add(`${d}${y}`);\n        stack.push([d, y]);\n \
    \     }\n      if (\n        u >= 0 &&", "    // your code goes here\n    var\
    \ sum = 0;\n    var lengthRow = grid.length;\n    var lengthColumn = grid[0].length;\n\
    \    for (var i = 0; i < lengthRow; i++) {\n        var largest = 0;\n       \
    \ for (var j = 0; j < lengthColumn; j++) {\n            if (grid[i][j] > 0) {\n\
    \                grid[i][j] = grid[i][j] - capacity;\n                largest\
    \ = largest + capacity;\n            }\n        }\n        if (largest >= capacity)\
    \ {\n            sum = sum + largest;\n        }\n    }\n    return sum;\n}\n",
  "    let steps = 0;\n    let max = 0;\n    let i = 0;\n    let j = 0;\n    let rowLength\
    \ = grid[0].length;\n    let columnLength = grid.length;\n    for (let j = 0;\
    \ j < rowLength; j++) {\n        steps += grid[0][j];\n    }\n    for (let i =\
    \ 1; i < columnLength; i++) {\n        max = -Infinity;\n        for (let j =\
    \ 0; j < rowLength; j++) {\n            max = Math.max(max, grid[i - 1][j]);\n\
    \        }\n        for (let j = 0; j < rowLength; j++) {\n            steps +=\
    \ Math.max(0, max - grid[i][j]);\n        }\n    }\n    return steps;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  if (grid.length === 0) {\n    return 0;\n  }\n\
    \  let result = 0;\n  let currentCapacity = capacity;\n  let j = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    for (j = 0; j < grid[i].length; j++) {\n\
    \      if (grid[i][j] === 1) {\n        if (currentCapacity <= 0) {\n        \
    \  result++;\n          currentCapacity = capacity;\n        }\n        currentCapacity--;\n\
    \      }\n    }\n  }\n  if (currentCapacity < capacity) {\n    result++;\n  }\n\
    \  return result;\n}\n", "    // let water_level = 0;\n    // let wells_to_fill\
    \ = [];\n    // let wells_filled = [];\n    // let number_of_fills = 0;\n    //\
    \ while(water_level <= capacity) {\n    //     // find next wells to fill\n  \
    \  //     for(let r = 0; r < grid.length; r++) {\n    //         if (wells_filled.includes(r))\
    \ {\n    //             continue;\n    //         }\n    //         let row =\
    \ grid[r];\n    //         let wells_to_add = [];\n    //         for(let c =\
    \ 0; c < row.length; c++) {\n    //             if (row[c] >= water_level) {\n\
    \    //                 wells_to_add.push(c);\n    //             }\n    //  \
    \       }\n    //         if (wells_to_add.length > 0) {\n    //             wells_to_fill.push(wells_to_add);\n\
    \    //             wells_filled.push(r);\n    //         }\n    //     }\n  \
    \  //     if (wells_to_fill.length === 0) {\n    //         break;\n    //   \
    \  }\n    //     number_of_fills++;\n    //     water_level++;\n    //     //\
    \ empty all wells\n    //     wells_to_fill = [];\n    // }\n    // return number_of_fills;\n\
    \    let counter = 0;\n    for(let r = 0; r < grid.length; r++) {\n        let\
    \ row = grid[r];\n        for(let c = 0; c < row.length; c++) {\n            if\
    \ (row[c] === 1) {\n                counter++;\n            }\n        }\n   \
    \ }\n    return counter;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log", "    let total = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        const row = grid[i];\n        for (let\
    \ j = 0; j < row.length; j++) {\n            if (row[j] === 1) {\n           \
    \     total += capacity;\n            }\n        }\n    }\n    return total;\n\
    }\n", "  const rows = grid.length;\n  const cols = grid[0].length;\n  const overflow\
    \ = findOverflow(grid, capacity);\n  return max_fill_recursive(grid, capacity,\
    \ overflow);\n}\n", "    if (grid.length === 0) {\n        return 0;\n    }\n\
    \    if (grid[0].length === 0) {\n        return 0;\n    }\n    if (capacity ===\
    \ 0) {\n        return 0;\n    }\n    const wells: number[] = grid.map(row =>\
    \ row.reduce((a, b) => a + b));\n    let steps = 0;\n    const max_well_capacity\
    \ = wells.reduce((a, b) => Math.max(a, b));\n    while (true) {\n        const\
    \ max_well_value = wells.reduce((a, b) => Math.max(a, b));\n        if (max_well_value\
    \ < capacity) {\n            return steps;\n        }\n        wells.forEach((value,\
    \ index) => {\n            wells[index] = Math.max(0, value - capacity);\n   \
    \     });\n        steps += capacity;\n    }\n}", "    let result = 0;\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n        let\
    \ count = 0;\n        for (let j = 0; j < row.length; j++) {\n            if (row[j]\
    \ === 1) {\n                count++;\n            }\n        }\n        result\
    \ += count;\n    }\n    return result / capacity;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)); //6\nconsole.log(max_fill([[0, 0,\
    \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)); //5\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5)); //0", "    throw new Error(\"Not implemented yet.\"\
    );\n}", "  return 0;\n}\n", "  const maxY = grid.length;\n  const maxX = grid[0].length;\n\
    \  const bucket = 0;\n  let drops = 0;\n  let y = maxY - 1;\n  let x = 0;\n  while\
    \ (y >= 0) {\n    while (grid[y][x] === bucket) {\n      x++;\n      if (x ===\
    \ maxX) {\n        y--;\n        x = 0;\n      }\n    }\n    grid[y][x] = bucket;\n\
    \    drops++;\n    x++;\n    if (x === maxX) {\n      y--;\n      x = 0;\n   \
    \ }\n  }\n  return drops;\n}\n", "    let maxDepth = 0;\n    let numSteps = 0;\n\
    \    let xMax = grid[0].length;\n    let yMax = grid.length;\n    // start at\
    \ bottom left corner and work right\n    for (let y = yMax - 1; y >= 0; y--) {\n\
    \        // set first value\n        if (grid[y][0] === 1) {\n            maxDepth++;\n\
    \        }\n        // fill in remaining depths\n        for (let x = 1; x < xMax;\
    \ x++) {\n            if (grid[y][x] === 1) {\n                maxDepth++;\n \
    \           }\n            // check if we need to dump here\n            if (maxDepth\
    \ >= capacity) {\n                numSteps++;\n                maxDepth = 0;\n\
    \            }\n        }\n    }\n    return numSteps;\n}\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));\n", "  let bucket = 0;\n  let count = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    bucket += grid[i].reduce((p, c) => p + c,\
    \ 0);\n    if (bucket >= capacity) {\n      bucket = 0;\n      count++;\n    }\n\
    \  }\n  return count;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1)); // 6\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], 2)); // 5\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5)); // 0", "    let total = 0;\n    for (let row of grid) {\n     \
    \   let maxGroup = 0;\n        let curGroup = 0;\n        for (let cell of row)\
    \ {\n            if (cell === 1) {\n                curGroup++;\n            }\
    \ else {\n                if (curGroup > maxGroup) {\n                    maxGroup\
    \ = curGroup;\n                }\n                curGroup = 0;\n            }\n\
    \        }\n        if (curGroup > maxGroup) {\n            maxGroup = curGroup;\n\
    \        }\n        total += maxGroup;\n    }\n    return total - capacity;\n\
    }\n", "  let count = 0;\n  const N = grid.length;\n  const M = grid[0].length;\n\
    \  for (let j = 0; j < M; j++) {\n    const col = grid.map(row => row[j]);\n \
    \   for (let i = 0; i < N; i++) {\n      const g = col[i];\n      if (g === 1)\
    \ {\n        const sum = col.slice(0, i + 1).reduce((a, b) => a + b, 0);\n   \
    \     const times = Math.ceil(sum / capacity);\n        count += times;\n    \
    \  }\n    }\n  }\n  return count;\n}\n", "\tif (grid.length === 0) {\n\t\treturn\
    \ 0;\n\t}\n\tif (grid[0].length === 0) {\n\t\treturn 0;\n\t}\n\tif (capacity ===\
    \ 0) {\n\t\treturn 0;\n\t}\n\tif (grid.length > 100) {\n\t\treturn 0;\n\t}\n\t\
    if (grid[0].length > 100) {\n\t\treturn 0;\n\t}\n\tif (capacity > 10) {\n\t\t\
    return 0;\n\t}\n\tlet to_fill: number = 0;\n\tfor (let row of grid) {\n\t\tlet\
    \ row_fill = 0;\n\t\tfor (let index = 0; index < row.length; index++) {\n\t\t\t\
    const element = row[index];\n\t\t\tif (element) {\n\t\t\t\trow_fill++;\n\t\t\t\
    } else {\n\t\t\t\tif (row_fill) {\n\t\t\t\t\tto_fill += row_fill;\n\t\t\t\t\t\
    row_fill = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (row_fill) {\n\t\t\tto_fill +=\
    \ row_fill;\n\t\t}\n\t}\n\treturn to_fill / capacity;\n}\n", "  let count = 0;\n\
    \  const rows = grid.length;\n  const cols = grid[0].length;\n  for (let col =\
    \ 0; col < cols; col++) {\n    const well = [...grid].map(row => row[col]);\n\
    \    count += max_fill_helper(well, capacity);\n  }\n  return count;\n}\n", " \
    \ let numberOfBox = 0;\n  let count = 0;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      let numberOfFill =\
    \ 0;\n      if (grid[i][j] === 1) {\n        if (numberOfBox === capacity) {\n\
    \          numberOfBox = 0;\n          count += 1;\n        }\n        numberOfBox\
    \ += 1;\n        numberOfFill += 1;\n      }\n      if (numberOfFill === grid[i].length)\
    \ {\n        count += 1;\n      }\n    }\n  }\n  return count;\n}\n\ndescribe(\"\
    max_fill\", () => {\n  test(\"#1\", () => {\n    expect(max_fill([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1)).toBe(6);\n  });\n  test(\"#2\", () => {\n \
    \   expect(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2)).toBe(5);\n  });\n  test(\"#3\", () => {\n    expect(max_fill([[0, 0, 0],\
    \ [0, 0, 0]], 5)).toBe(0);\n  });\n});", "  let time: number = 0;\n  const bk:\
    \ number[] = new Array(grid[0].length).fill(0);\n  // put all the water in the\
    \ buckets\n  for (let i = 0; i < grid.length; i++) {\n    // check if the bucket\
    \ needs to be lowered\n    for (let j = 0; j < grid[i].length; j++) {\n      if\
    \ (grid[i][j] === 1) {\n        bk[j]++;\n      }\n    }\n    // lower the bucket\
    \ if needed\n    for (let j = 0; j < grid[i].length; j++) {\n      if (bk[j] ===\
    \ capacity) {\n        bk[j] = 0;\n        time++;\n      }\n    }\n  }\n  return\
    \ time;\n}\n", "    let result = 0;\n    const column_count = grid[0].length;\n\
    \    const row_count = grid.length;\n    const filled_pixels = new Set<number>();\n\
    \    const has_pixel = (row: number, column: number) => grid[row][column] ===\
    \ 1;\n    const fill_pixel = (row: number, column: number) => {\n        if (has_pixel(row,\
    \ column)) {\n            filled_pixels.add(row * column_count + column);\n  \
    \      }\n    };\n    const is_filled = (row: number, column: number) =>\n   \
    \     filled_pixels.has(row * column_count + column);\n    const fill_row = (row:\
    \ number) => {\n        const start = is_filled(row, 0) ? 0 : column_count - 1;\n\
    \        const end = start === 0 ? column_count : -1;\n        const step = start\
    \ === 0 ? 1 : -1;\n        for (let column = start; column !== end; column +=\
    \ step) {\n            if (has_pixel(row, column)) {\n                for (let\
    \ j = 0; j < capacity; j++) {\n                    fill_pixel(row, column + j\
    \ * step);\n                }\n            }\n        }\n    };\n    for (let\
    \ i = 0; i < row_count; i++) {\n        fill_row(i);\n    }\n    return filled_pixels.size;\n\
    }\n\n(function () {\n    console.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\n    console.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\n    console.log(max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5));\n})();", "    let result = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                result += get_bucket_count(grid, i, j, capacity);\n\
    \            }\n        }\n    }\n    return result;\n}\n", "  let rows: number\
    \ = grid.length;\n  let cols: number = grid[0].length;\n  let count: number =\
    \ 0;\n  for (let i: number = 0; i < rows; i++) {\n    for (let j: number = 0;\
    \ j < cols; j++) {\n      if (grid[i][j] === 1) {\n        count += (capacity\
    \ - 1);\n      }\n    }\n  }\n  return count;\n}\n\nexport { max_fill };", " \
    \   return 0;\n}\n", "    // TODO: Your code here\n    return 0;\n}\n", "  const\
    \ rows = grid.length;\n  const cols = grid[0].length;\n  //loop through rows\n\
    \  let count = 0;\n  for (let i = 0; i < rows; i++) {\n    //loop through wells\
    \ in row\n    for (let j = 0; j < cols; j++) {\n      //if well empty then continue\n\
    \      if (grid[i][j] === 0) continue;\n      //if well has water then fill capacity\
    \ until empty\n      for (let k = 0; k < capacity; k++) {\n        if (grid[i][j]\
    \ > 0) {\n          count++;\n          grid[i][j] -= 1;\n        }\n      }\n\
    \    }\n  }\n  return count;\n}\n", "    let ans = 0;\n    while(true) {\n   \
    \     let stop = true;\n        for(let i=0; i<grid.length; i++) {\n         \
    \   let left = 0;\n            let right = 0;\n            let idxl = 0;\n   \
    \         let idxr = grid[i].length - 1;\n            while(left<capacity) {\n\
    \                if(grid[i][idxl] == 1) {\n                    left++;\n     \
    \           }\n                idxl++;\n            }\n            idxl--;\n \
    \           while(right<capacity) {\n                if(grid[i][idxr] == 1) {\n\
    \                    right++;\n                }\n                idxr--;\n  \
    \          }\n            idxr++;\n            if(right == capacity) {\n     \
    \           ans++;\n                for(let j=idxr; j<grid[i].length; j++) {\n\
    \                    grid[i][j] = 0;\n                }\n                stop\
    \ = false;\n            }\n            if(left == capacity) {\n              \
    \  ans++;\n                for(let j=0; j<=idxl; j++) {\n                    grid[i][j]\
    \ = 0;\n                }\n                stop = false;\n            }\n    \
    \    }\n        if(stop) {\n            break;\n        }\n    }\n    return ans;\n\
    }", "  const rows = grid.length;\n  const cols = grid[0].length;\n  let water\
    \ = 0;\n  for (let r = 0; r < rows; r++) {\n    let acc = 0;\n    for (let c =\
    \ 0; c < cols; c++) {\n      if (grid[r][c] == 1) {\n        water += capacity\
    \ - acc;\n        acc = 0;\n      } else {\n        acc++;\n      }\n    }\n \
    \ }\n  return water;\n}\n", "  let times = 0;\n  const rows = grid.length;\n \
    \ const cols = grid[0].length;\n  const wells = new Array(rows);\n  for (let i\
    \ = 0; i < rows; i++) {\n    wells[i] = new Array(cols);\n    for (let j = 0;\
    \ j < cols; j++) {\n      wells[i][j] = grid[i][j] === 1 ? capacity : 0;\n   \
    \ }\n  }\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++)\
    \ {\n      if (wells[i][j] > 0) {\n        for (let k = i; k < rows; k++) {\n\
    \          for (let l = j; l < cols; l++) {\n            if (wells[k][l] > 0)\
    \ {\n              times++;\n              const d = wells[i][j] + wells[k][l]\
    \ - capacity;\n              wells[i][j] = Math.min(wells[i][j], capacity);\n\
    \              wells[k][l] = Math.min(wells[k][l], capacity);\n              if\
    \ (d > 0) {\n                wells[i][j] = wells[i][j] + d;\n              }\n\
    \            }\n          }\n        }\n      }\n    }\n  }\n  return times;\n\
    }\n", "    let res = 0;\n    // Write your code here\n    return res;\n}\n", " \
    \ let total = 0;\n  for (let i = 0; i < grid.length; i++) {\n    const well =\
    \ grid[i];\n    let j = 0;\n    let count = 0;\n    while (j < well.length) {\n\
    \      if (well[j] === 1) {\n        count++;\n      } else {\n        if (count\
    \ > 0) {\n          if (count > capacity) {\n            total += capacity;\n\
    \          } else {\n            total += count;\n          }\n          count\
    \ = 0;\n        }\n      }\n      j++;\n    }\n    if (count > 0) {\n      if\
    \ (count > capacity) {\n        total += capacity;\n      } else {\n        total\
    \ += count;\n      }\n    }\n  }\n  return total;\n}\n", "  // your code here\n\
    \  return -1;\n}\n\nexport { max_fill };", "  if (capacity === 0) {\n    return\
    \ 0;\n  }\n  const result = grid.map(row => row.map(value => value === 1 ? capacity\
    \ : 0));\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        result[i][j] = capacity;\n  \
    \      if (i > 0) {\n          result[i - 1][j] = Math.max(result[i - 1][j], capacity\
    \ - (i + 1));\n        }\n        if (j > 0) {\n          result[i][j - 1] = Math.max(result[i][j\
    \ - 1], capacity - (j + 1));\n        }\n      }\n    }\n  }\n  return result.reduce((acc,\
    \ row) => acc + row.reduce((acc2, value) => acc2 + value, 0), 0);\n}", "    return\
    \ 0;\n}\n\nexport { max_fill }", "  let totalOperations = 0;\n  const checkExtraction\
    \ = (row: number, col: number) => {\n    if (row < 0 || row >= grid.length ||\
    \ col < 0 || col >= grid[0].length) {\n      return;\n    }\n    if (grid[row][col]\
    \ === 1) {\n      grid[row][col] = 0;\n      totalOperations++;\n      checkExtraction(row\
    \ - 1, col);\n      checkExtraction(row + 1, col);\n      checkExtraction(row,\
    \ col - 1);\n      checkExtraction(row, col + 1);\n    }\n  };\n  for (let row\
    \ = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[0].length;\
    \ col++) {\n      if (grid[row][col] === 1) {\n        checkExtraction(row, col);\n\
    \      }\n    }\n  }\n  return totalOperations;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let numberOfLowerings = 0;\n  let numberOfColumns\
    \ = grid[0].length;\n  //iterate over each element in the array\n  for (let i\
    \ = 0; i < grid.length; i++) {\n    // iterate over each element in the array\n\
    \    for (let j = 0; j < numberOfColumns; j++) {\n      // if the current element\
    \ is 1, and we have capacity, lower the bucket\n      if (grid[i][j] === 1 &&\
    \ capacity > 0) {\n        numberOfLowerings++;\n        capacity--;\n      }\n\
    \      // else if we hit the end of the row and there is still capacity\n    \
    \  else if (j === numberOfColumns - 1 && capacity > 0) {\n        numberOfLowerings++;\n\
    \        capacity--;\n      }\n    }\n  }\n  return numberOfLowerings;\n}\n",
  "    let count = 0;\n    let array = [];\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        array.push(grid[i].join(\"\"));\n    }\n    for (let i = 0; i < array.length;\
    \ i++) {\n        let bucket = array[i].split(\"1\").join(\"0\");\n        bucket\
    \ = bucket.split(\"\");\n        let fill = bucket.length;\n        let c = 0;\n\
    \        while (fill > 0) {\n            let fill = bucket.length;\n         \
    \   for (let j = 0; j < bucket.length; j++) {\n                if (bucket[j] ==\
    \ \"0\") {\n                    bucket[j] = \"1\";\n                    fill--;\n\
    \                }\n            }\n            count += c;\n            c++;\n\
    \        }\n    }\n    return count;\n}\n", "    let visited: boolean[][] = [];\n\
    \    let n: number = grid.length;\n    let m: number = grid[0].length;\n    let\
    \ result: number = 0;\n    for (let i: number = 0; i < n; i++) {\n        visited[i]\
    \ = [];\n        for (let j: number = 0; j < m; j++) {\n            visited[i][j]\
    \ = false;\n        }\n    }\n    for (let i: number = 0; i < n; i++) {\n    \
    \    for (let j: number = 0; j < m; j++) {\n            if (grid[i][j] === 1 &&\
    \ !visited[i][j]) {\n                result += getMaxWater(grid, visited, i, j,\
    \ capacity);\n            }\n        }\n    }\n    return result;\n}\n", "  let\
    \ result = 0;\n  const len = grid.length;\n  const max = grid[0].length;\n  const\
    \ total = len * max;\n  let counter = 0;\n  while (counter < total) {\n    for\
    \ (let i = 0; i < len; i++) {\n      for (let j = 0; j < max; j++) {\n       \
    \ if (grid[i][j] > 0) {\n          counter++;\n          grid[i][j] = 0;\n   \
    \       result++;\n        }\n      }\n    }\n    for (let i = 0; i < len; i++)\
    \ {\n      for (let j = 0; j < max; j++) {\n        if (j - capacity >= 0) {\n\
    \          grid[i][j - capacity] = grid[i][j - capacity] + 1;\n        }\n   \
    \     if (j + capacity < max) {\n          grid[i][j + capacity] = grid[i][j +\
    \ capacity] + 1;\n        }\n      }\n    }\n  }\n  return result;\n}\n", "  \
    \  // your code here\n    return 0;\n}\n", "  const depths = grid.map(x => x.reduce((a,\
    \ b) => a + b, 0));\n  const height = Math.max(...depths);\n  let res = 0;\n \
    \ for (let i = 0; i < height; i++) {\n    const max = Math.max(...depths);\n \
    \   depths.forEach((x, idx) => {\n      if (x === max) {\n        depths[idx]\
    \ -= capacity;\n        res++;\n      }\n    });\n  }\n  return res;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let movements = 0;\n  let wellIndex = 0;\n  let\
    \ waterInBucket = 0;\n  while (wellIndex < grid.length) {\n    // Loop through\
    \ wells\n    const wells = grid[wellIndex];\n    const indexOfWellWithWater =\
    \ wells.indexOf(1);\n    if (indexOfWellWithWater !== -1) {\n      // Found water\
    \ in well\n      // Increase counter\n      movements++;\n      // Put water from\
    \ well into bucket\n      waterInBucket += indexOfWellWithWater + 1;\n      //\
    \ If bucket is full, dump it\n      if (waterInBucket >= capacity) {\n       \
    \ waterInBucket = 0;\n      }\n    }\n    wellIndex++;\n  }\n  return movements;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  return Math.max(\n    // number of times we visit\
    \ each empty cell\n    ...grid.map((row, i) => {\n      return row.map((col, j)\
    \ => {\n        if (col === 0) {\n          // get all not visited cells\n   \
    \       return Array.from(\n            Array(grid.length)\n              .fill(true)\n\
    \              .map((_, k) => {\n                return row.map((_, l) => {\n\
    \                  return k !== i && l !== j;\n                });\n         \
    \     })\n              .flat()\n          ).filter(Boolean).length;\n       \
    \ }\n        return 0;\n      });\n    })\n  );\n}\n", "  let water = 0;\n  let\
    \ fill = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j\
    \ < grid[i].length; j++) {\n      water += grid[i][j];\n    }\n    fill += Math.ceil(water\
    \ / capacity);\n    water = 0;\n  }\n  return fill;\n}\n", "    let sum = 0;\n\
    \    let count = 0;\n    let max = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n        for (let j = 0; j < grid[i].length; j++) {\n            sum += grid[i][j];\n\
    \        }\n        count += sum;\n        if (sum > max) {\n            max =\
    \ sum;\n        }\n        sum = 0;\n    }\n    return max * count;\n}\n\n(function\
    \ () {\n    console.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\n\
    \    console.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1,\
    \ 1]], 2));\n    console.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));\n})();", " \
    \ let deep = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        grid[i][j]\
    \ = 0;\n        deep += capacity;\n      }\n    }\n  }\n  return deep;\n}\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let max_fill = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j]\
    \ > 0) {\n        max_fill += capacity;\n      }\n    }\n  }\n  return max_fill;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "    let total_level = 0;\n    const height = grid.length;\n\
    \    const width = grid[0].length;\n    for (let level = 0; level < height; level++)\
    \ {\n        for (let index = 0; index < width; index++) {\n            if (grid[level][index]\
    \ === 1) {\n                total_level += capacity;\n            }\n        }\n\
    \    }\n    return total_level;\n}\n\n(function () {\n    console.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\n    console.log(max_fill([[0, 0,\
    \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\n    console.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));\n})();", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    let currentCount = 0;\n    for (let j = 0; j < grid[i].length; j++)\
    \ {\n      if (grid[i][j] === 1) {\n        currentCount++;\n      }\n    }\n\
    \    if (currentCount > 0) {\n      count += currentCount / capacity;\n      if\
    \ (currentCount % capacity > 0) {\n        count++;\n      }\n    }\n  }\n  return\
    \ count;\n}\n\nexport { max_fill };", "    let num_lowered = 0;\n    for (let\
    \ i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] == 1) {\n                num_lowered++;\n\
    \                let k = i;\n                while (grid[k][j] == 1 && k < grid.length)\
    \ {\n                    grid[k][j] = capacity;\n                    k++;\n  \
    \              }\n            }\n        }\n    }\n    return num_lowered;\n}\n\
    \nexport default max_fill;", "  let totalWater = 0;\n  let totalBuckets = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        totalWater++;\n      }\n    }\n\
    \  }\n  while (totalWater > 0) {\n    totalBuckets++;\n    totalWater -= capacity;\n\
    \  }\n  return totalBuckets;\n}\n", "  let count = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    const row = grid[i];\n    const last = row.length - 1;\n    const\
    \ lastBucket = row[last];\n    if (lastBucket === 1) {\n      const x = i + 1;\n\
    \      if (x < grid.length) {\n        const nextRow = grid[x];\n        if (nextRow[last]\
    \ === 1) {\n          nextRow[last] = 0;\n          count++;\n        }\n    \
    \  }\n      row[last] = 0;\n      count++;\n    }\n    let j = last - 1;\n   \
    \ while (j >= 0) {\n      const v = row[j];\n      if (v === 1) {\n        row[j]\
    \ = 0;\n        count++;\n      }\n      j--;\n    }\n  }\n  return count;\n}\n\
    \nconst input = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]];\nconst bucket = 1;\n\
    console.log(max_fill(input, bucket));", "    if (grid.length === 0) return 0;\n\
    \    let totalOperations = 0;\n    const targetWells: number[] = [];\n    for\
    \ (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] === 1) {\n                targetWells.push(j);\n\
    \            }\n        }\n    }\n    for (let target of targetWells) {\n    \
    \    let lowerX = 0;\n        let upperX = grid.length - 1;\n        let lowerY\
    \ = target;\n        let upperY = target;\n        while (lowerX < upperX) {\n\
    \            while (lowerY >= 0 && grid[lowerX][lowerY] === 1) {\n           \
    \     grid[lowerX][lowerY] = 0;\n                lowerY--;\n            }\n  \
    \          while (upperY < grid[upperX].length && grid[upperX][upperY] === 1)\
    \ {\n                grid[upperX][upperY] = 0;\n                upperY++;\n  \
    \          }\n            if (lowerY < 0) {\n                lowerY = target;\n\
    \            }\n            if (upperY >= grid[upperX].length) {\n           \
    \     upperY = target;\n            }\n            lowerX++;\n            upperX--;\n\
    \            totalOperations++;\n        }\n    }\n    return totalOperations;\n\
    }\n", "  let rowLength = grid[0].length;\n  let rows = grid.length;\n  let buckets\
    \ = 0;\n  for (let row of grid) {\n    let index = 0;\n    let l = 0;\n    while\
    \ (index < rowLength) {\n      l = 0;\n      if (row[index] === 1) {\n       \
    \ while (l < capacity && index < rowLength) {\n          l += row[index];\n  \
    \        index++;\n        }\n        buckets++;\n      } else {\n        index++;\n\
    \      }\n    }\n  }\n  return buckets;\n}\n\nexport { max_fill };", "    // need\
    \ to find how many times the capacity will fill a 1 \n    // in the grid.\n  \
    \  // the first thing i need to do is make sure that each 1 \n    // is at the\
    \ max at the same time.\n    // so, we need to count 1s in all rows up to current\
    \ row\n    // and then count 1s in this row up to current col\n    // take the\
    \ max of those two, and that is the number of \n    // water units in the current\
    \ well\n    // the number of times that capacity will fill the current well\n\
    \    // is the number of water units / capacity\n    // return the sum of this\
    \ value for each 1 in the grid\n    let timeToFill = 0;\n    for (let row = 0;\
    \ row < grid.length; row++) {\n        for (let col = 0; col < grid[row].length;\
    \ col++) {\n            if (grid[row][col] === 1) {\n                const rowWater\
    \ = countRowWater(grid, row);\n                const colWater = countColWater(grid,\
    \ row, col);\n                const water = Math.max(rowWater, colWater);\n  \
    \              timeToFill += water / capacity;\n            }\n        }\n   \
    \ }\n    return Math.ceil(timeToFill);\n}\n", "    // your code here\n}", "\t\
    let count: number = 0;\n\tlet column: number = 0;\n\tlet water_needed: number\
    \ = 0;\n\twhile (column < grid[0].length) {\n\t\tlet water_collected: number =\
    \ 0;\n\t\tfor (let row: number = 0; row < grid.length; row++) {\n\t\t\tif (grid[row][column]\
    \ === 1) {\n\t\t\t\tif (water_collected < capacity) {\n\t\t\t\t\twater_collected\
    \ += 1;\n\t\t\t\t\tcount += 1;\n\t\t\t\t} else {\n\t\t\t\t\tcount += 2;\n\t\t\t\
    \t\twater_collected = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcolumn += 1;\n\t}\n\t\
    return count;\n}", "    let sum = 0;\n    for (let row of grid) {\n        for\
    \ (let cell of row) {\n            sum += cell;\n        }\n    }\n    return\
    \ sum;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "\tlet rows\
    \ = grid.length;\n\tlet cols = grid[0].length;\n\tlet bucket_count = 0;\n\tlet\
    \ current_max = -1;\n\tlet current_min = 11;\n\tfor (let r = 0; r < rows; r++)\
    \ {\n\t\tfor (let c = 0; c < cols; c++) {\n\t\t\tif (grid[r][c] === 1) {\n\t\t\
    \t\tif (current_max === -1) {\n\t\t\t\t\tcurrent_max = c;\n\t\t\t\t}\n\t\t\t\t\
    current_min = Math.min(current_min, c);\n\t\t\t}\n\t\t}\n\t\tif (current_max !==\
    \ -1) {\n\t\t\tbucket_count += current_max - current_min + 1;\n\t\t\tcurrent_max\
    \ = -1;\n\t\t\tcurrent_min = 11;\n\t\t}\n\t}\n\treturn bucket_count;\n}\n\nlet\
    \ tests: [number[][], number, number][] = [\n\t[[[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1, 6],\n\t[[[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
    \ 2, 5],\n\t[[[0, 0, 0], [0, 0, 0]], 5, 0],\n];\n\ntests.forEach((v) => {\n\t\
    let [grid, capacity, res] = v;\n\tlet out = max_fill(grid, capacity);\n\tconsole.assert(out\
    \ === res);\n});", "  let count = 0;\n  let empty = true;\n  while (empty) {\n\
    \    empty = false;\n    for (let i = 0; i < grid.length; i++) {\n      for (let\
    \ j = 0; j < grid[i].length; j++) {\n        if (grid[i][j] !== 0) {\n       \
    \   grid[i][j] -= capacity;\n          if (grid[i][j] < 0) {\n            grid[i][j]\
    \ = 0;\n          }\n          count++;\n          empty = true;\n        }\n\
    \      }\n    }\n  }\n  return count;\n}\n\nexport function max_fillTests(): void\
    \ {\n  Test.expect(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1) ===\
    \ 6);\n  Test.expect(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2) === 5);\n  Test.expect(max_fill([[0, 0, 0], [0, 0, 0]], 5) === 0);\n\
    }", "  let steps = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      let to_fill = capacity - grid[i][j];\n\
    \      if (to_fill > 0) {\n        steps += to_fill;\n      }\n    }\n  }\n  return\
    \ steps;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "  // your\
    \ code here\n  return 0;\n}\n\nexport { max_fill };", "  const width = grid[0].length;\n\
    \  let time = 0;\n  while (!isEmpty(grid)) {\n    time += 1;\n    let x = 0;\n\
    \    while (x < width) {\n      if (grid[0][x] === 1) {\n        fill(grid, capacity,\
    \ x);\n      }\n      x += 1;\n    }\n  }\n  return time;\n}\n", "    const R\
    \ = grid.length;\n    const C = grid[0].length;\n    let [maxRow, maxCol] = [0,\
    \ 0];\n    let [r, c] = [0, 0];\n    let moves = 0;\n    while (r < R) {\n   \
    \     while (c < C) {\n            [maxRow, maxCol] = maxInRowCol(grid, r, c);\n\
    \            if (maxRow > maxCol) {\n                // go left\n            \
    \    if (c > 0) {\n                    c--;\n                    moves++;\n  \
    \              }\n            } else {\n                // go down\n         \
    \       if (r < R - 1) {\n                    r++;\n                    moves++;\n\
    \                }\n            }\n        }\n        r++;\n        c = 0;\n \
    \   }\n    return moves;\n}", "    let sum = 0;\n    let numOfTimes = 0;\n   \
    \ for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j < grid[i].length;\
    \ j++) {\n            if (grid[i][j] == 1) {\n                if (sum < capacity)\
    \ {\n                    sum++;\n                } else {\n                  \
    \  sum = 1;\n                    numOfTimes++;\n                }\n          \
    \  }\n        }\n    }\n    return numOfTimes;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  let max = 0;\n  let maxW = 0;\n  let filled = false;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    let w = 0;\n    for (let j = 0;\
    \ j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        w++;\n  \
    \    }\n    }\n    if (w > maxW) {\n      maxW = w;\n      filled = true;\n  \
    \  }\n    if (w > 0) {\n      max++;\n    }\n  }\n  return filled ? (max - 1)\
    \ * capacity + maxW : 0;\n}\n\nexport default max_fill;", "    let count = 0;\n\
    \    while (true) {\n        let max = 0;\n        let rowIndex = 0;\n       \
    \ for (let i = 0; i < grid.length; i++) {\n            let row = grid[i];\n  \
    \          let sum = 0;\n            for (let j = 0; j < row.length; j++) {\n\
    \                sum += row[j];\n            }\n            if (sum > max) {\n\
    \                max = sum;\n                rowIndex = i;\n            }\n  \
    \      }\n        if (max === 0) break;\n        for (let i = 0; i < grid[rowIndex].length;\
    \ i++) {\n            grid[rowIndex][i] = Math.max(grid[rowIndex][i] - capacity,\
    \ 0);\n        }\n        count++;\n    }\n    return count;\n}\n", "  //1. Create\
    \ a copy of the grid and fill it up with zeros to work with.\n  //2. Check each\
    \ row for a 1.\n  //3. If a 1 is found, delete it and increment the times the\
    \ bucket was lowered.\n  //4. Repeat steps 2 & 3 until no 1s are left.\n  //5.\
    \ Return the bucket lowers.\n  var working_grid = grid.map(function(x){return\
    \ x.slice()});\n  var buckets_lowered = 0;\n  while(true){\n    let has_1s = false;\n\
    \    for(let i=0; i<working_grid.length; i++){\n      let row = working_grid[i];\n\
    \      for(let j=0; j<row.length; j++){\n        if(row[j] === 1){\n         \
    \ has_1s = true;\n          buckets_lowered += 1;\n          row[j] = 0;\n   \
    \     }\n      }\n    }\n    if(!has_1s){\n      break;\n    }\n  }\n  return\
    \ buckets_lowered;\n}\n\nexport function test_max_fill(){\n  try{\n    let example_1\
    \ = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]];\n    let example_2 = [[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]];\n    let example_3 = [[0, 0,\
    \ 0], [0, 0, 0]];\n    let example_4 = [[0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0", "  let fillTimes = 0;\n  for (let row of grid) {\n    for (let well of\
    \ row) {\n      if (well === 1) {\n        fillTimes += 1;\n      }\n    }\n \
    \ }\n  const emptyWells = grid.reduce((acc, row) => {\n    for (let i = 0; i <\
    \ row.length; i++) {\n      if (row[i] === 0) {\n        acc.push(i);\n      }\n\
    \    }\n    return acc;\n  }, []);\n  if (emptyWells.length) {\n    fillTimes\
    \ += emptyWells.reduce((acc, curr) => {\n      return Math.abs(acc - curr);\n\
    \    });\n  }\n  return fillTimes * capacity;\n}\nconsole.log(max_fill([[0, 0,\
    \ 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0,\
    \ 0], [0, 0, 0]], 5));", "  let steps = 0;\n  // TODO: Implement\n  return steps;\n\
    }\n", "  let drops = 0;\n  const gridLength = grid.length;\n  const wells = grid[0].length;\n\
    \  const tank = capacity;\n  let i = 0;\n  let tankVolume = 0;\n  let fullWells\
    \ = 0;\n  for (i; i < gridLength; i++) {\n    const row = grid[i];\n    let j\
    \ = 0;\n    for (j; j < wells; j++) {\n      if (row[j] === 1) {\n        tankVolume++;\n\
    \        if (tankVolume === tank) {\n          tankVolume = 0;\n          drops++;\n\
    \        }\n      }\n    }\n    if (tankVolume) {\n      drops++;\n      tankVolume\
    \ = 0;\n    }\n  }\n  return drops;\n}\n\nexport { max_fill };", "  // TODO:\n\
    \  return 0;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,\
    \ 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "    let\
    \ max_fill = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            let fill = 0;\n            for\
    \ (let k = i; k < grid.length; k++) {\n                if (grid[k][j] !== 1) {\n\
    \                    fill += capacity;\n                } else {\n           \
    \         break;\n                }\n            }\n            if (fill > max_fill)\
    \ {\n                max_fill = fill;\n            }\n        }\n    }\n    return\
    \ max_fill;\n}\n", "  // TODO\n  return 0;\n}\n\nexport { max_fill };", "  return\
    \ 0;\n}\n\nexport default max_fill;", "  let count = 0;\n  let isBucketFull =\
    \ false;\n  let isBucketEmpty = false;\n  for (let i = 0; i < grid.length; i++)\
    \ {\n    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] ===\
    \ 1) {\n        count++;\n        if (i !== grid.length - 1) {\n          count++;\n\
    \        }\n      }\n    }\n  }\n  return count;\n}\n", "  let fillCount = 0;\n\
    \  let currentCapacity = capacity;\n  for (let i = 0; i < grid.length; i++) {\n\
    \    for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        fillCount++;\n        if (currentCapacity === 0) {\n          currentCapacity\
    \ = capacity;\n        }\n        currentCapacity--;\n      }\n    }\n  }\n  return\
    \ fillCount;\n}\n\nexport { max_fill };", "  let count = 0;\n  let wells = 0;\n\
    \  for (let x = 0; x < grid.length; x++) {\n    for (let y = 0; y < grid[x].length;\
    \ y++) {\n      if (grid[x][y] == 1) {\n        wells++;\n      }\n    }\n  }\n\
    \  while (wells > 0) {\n    for (let x = 0; x < grid.length; x++) {\n      for\
    \ (let y = 0; y < grid[x].length; y++) {\n        if (grid[x][y] == 1) {\n   \
    \       if (capacity > 0) {\n            capacity--;\n            grid[x][y] =\
    \ 0;\n            wells--;\n          }\n        }\n      }\n    }\n    count++;\n\
    \    capacity = 2;\n  }\n  return count;\n}\n", "    let r = grid.length;\n  \
    \  let c = grid[0].length;\n    let res = 0;\n    let left = 0;\n    let right\
    \ = c - 1;\n    while (left <= right) {\n        while (left < c && grid[r - 1][left]\
    \ === 0) {\n            left++;\n        }\n        while (right >= 0 && grid[r\
    \ - 1][right] === 0) {\n            right--;\n        }\n        if (left <= right)\
    \ {\n            let r_i = r - 1;\n            let c_i = left;\n            while\
    \ (r_i >= 0 && grid[r_i][c_i] === 0) {\n                res += capacity;\n   \
    \             r_i--;\n            }\n            c_i = right;\n            r_i\
    \ = r - 1;\n            while (r_i >= 0 && grid[r_i][c_i] === 0) {\n         \
    \       res += capacity;\n                r_i--;\n            }\n            left++;\n\
    \            right--;\n        }\n    }\n    return res;\n}\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "\t// assume you can only fill the well from the left\n\
    \tlet moves = 0;\n\tgrid.forEach(row => {\n\t\tconst firstIndex = row.indexOf(1);\n\
    \t\tif (firstIndex !== -1) {\n\t\t\tlet numBuckets = 0;\n\t\t\tfor (let i = 0;\
    \ i < firstIndex; i++) {\n\t\t\t\tif (row[i] === 1) {\n\t\t\t\t\tnumBuckets++;\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\tmoves += Math.ceil(numBuckets / capacity);\n\t\t}\n\t\
    });\n\treturn moves;\n}\n\nconst test1 = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1,\
    \ 1]];\nconsole.log(max_fill(test1, 1));", "  // Write your code here\n  return\
    \ 0;\n}\n", "  let numberOfFills = 0;\n  let v = grid.length;\n  let h = grid[0].length;\n\
    \  const copyGrid = JSON.parse(JSON.stringify(grid));\n  while (max_fillHelper(copyGrid,\
    \ capacity)) {\n    numberOfFills++;\n  }\n  return numberOfFills;\n}\n", "  \
    \  // find tallest column\n    // repeat until done\n    // count used buckets\n\
    \    const columnHeights = new Array(grid[0].length).fill(0);\n    let maxCol\
    \ = 0;\n    let totalMax = 0;\n    grid.forEach(row => {\n        row.forEach((cell,\
    \ col) => {\n            if (cell > 0) {\n                columnHeights[col]++;\n\
    \                totalMax++;\n            }\n        });\n    });\n    maxCol\
    \ = Math.max(...columnHeights);\n    let usedBuckets = 0;\n    for (let i = maxCol;\
    \ i > 0; i--) {\n        const toFill = columnHeights.filter(height => height\
    \ >= i).length;\n        const bucketCount = Math.ceil(toFill / capacity);\n \
    \       usedBuckets += bucketCount;\n    }\n    return usedBuckets;\n}\n\nexport\
    \ { max_fill };", "  const bucket = new Bucket(capacity);\n  let fillCount = 0;\n\
    \  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        bucket.addWater();\n        fillCount++;\n\
    \      }\n    }\n    bucket.empty();\n  }\n  return fillCount;\n}\n", "    let\
    \ total = 0;\n    let rowNum = grid.length;\n    let colNum = grid[0].length;\n\
    \    let x = 0;\n    let y = 0;\n    while (x < rowNum && y < colNum) {\n    \
    \    // start filling\n        while (y < colNum && grid[x][y] === 0) {\n    \
    \        y++;\n        }\n        if (y === colNum) {\n            break;\n  \
    \      }\n        // start dropping\n        total += capacity;\n        for (let\
    \ i = 0; i < x; i++) {\n            for (let j = 0; j < colNum; j++) {\n     \
    \           if (grid[i][j] === 1) {\n                    grid[i][j] = 0;\n   \
    \             }\n            }\n        }\n        for (let j = 0; j < y; j++)\
    \ {\n            if (grid[x][j] === 1) {\n                grid[x][j] = 0;\n  \
    \          }\n        }\n        // move on\n        y++;\n        if (y === colNum)\
    \ {\n            x++;\n            y = 0;\n        }\n    }\n    return total;\n\
    }", "  let res = 0;\n  let prev = new Array(grid[0].length).fill(0);\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++)\
    \ {\n      if (grid[i][j] > 0) {\n        if (capacity - grid[i][j] >= 0) {\n\
    \          grid[i][j] = 0;\n          capacity -= grid[i][j];\n        } else\
    \ {\n          grid[i][j] -= capacity;\n          capacity = 0;\n        }\n \
    \     }\n      if (capacity === 0) {\n        res++;\n        if (i > 0) {\n \
    \         grid[i][j] += prev[j];\n          if (grid[i][j] > 0) {\n          \
    \  capacity = capacity + grid[i][j] > capacity ? capacity : capacity + grid[i][j];\n\
    \            grid[i][j] = 0;\n          }\n        }\n      }\n    }\n    prev\
    \ = grid[i];\n  }\n  return res;\n}\n", "    let all_zeros = true;\n    let max_fill\
    \ = 0;\n    for (let i = 0; i < grid.length; i++) {\n        let row = grid[i];\n\
    \        let fill = 0;\n        for (let j = 0; j < row.length; j++) {\n     \
    \       let cell = row[j];\n            if (cell == 1) {\n                all_zeros\
    \ = false;\n                fill += cell;\n            }\n        }\n        max_fill\
    \ = Math.max(max_fill, fill);\n    }\n    if (all_zeros) {\n        return 0;\n\
    \    }\n    return Math.ceil(max_fill / capacity);\n}\n\nexport { max_fill }",
  "    // your code here\n    return 0;\n}\n\nexport { max_fill }", "  let position\
    \ = 0;\n  const rowLength = grid[0].length;\n  let count = 0;\n  while (position\
    \ < rowLength) {\n    const water = grid.map(row => row[position]);\n    const\
    \ filled = water.filter(w => w === 1).length;\n    if (filled > capacity) {\n\
    \      count += (filled - capacity);\n    }\n    position++;\n  }\n  return count;\n\
    }\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));\nconsole.log(max_fill([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0,", "    let count = 0;\n    const rows = grid.length;\n    const cols\
    \ = grid[0].length;\n    let rowNum = 0;\n    let row = grid[rowNum];\n    while\
    \ (rowNum < rows) {\n        while (row.some(x => x === 1)) {\n            //\
    \ count++;\n            if (row.length > 0) {\n                row.splice(0, capacity);\n\
    \            }\n        }\n        count++;\n        rowNum++;\n        row =\
    \ grid[rowNum];\n    }\n    return count;\n}\n\nconsole.log(max_fill([[0, 0, 1,\
    \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0,\
    \ 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0],\
    \ [0, 0, 0]], 5));\n", "    let total: number = 0;\n    // let count: number =\
    \ 0;\n    let next: number[][] = [];\n    let to_visit: number[][] = [];\n   \
    \ let visited: number[][] = [];\n    let i = 0;\n    let j = 0;\n    let k = 0;\n\
    \    let l = 0;\n    for (i = 0; i < grid.length; i += 1) {\n        for (j =\
    \ 0; j < grid[i].length; j += 1) {\n            total += grid[i][j];\n       \
    \ }\n    }\n    for (i = 0; i < grid.length; i += 1) {\n        for (j = 0; j\
    \ < grid[i].length; j += 1) {\n            next = [];\n            if (grid[i][j]\
    \ === 1) {\n                next.push([i, j]);\n                to_visit.push([i,\
    \ j]);\n                while (to_visit.length > 0) {\n                    for\
    \ (k = 0; k < to_visit.length; k += 1) {\n                        let elem = to_visit[k];\n\
    \                        grid[elem[0]][elem[1]] = 0;\n                       \
    \ if (elem[0] > 0 && grid[elem[0] - 1][elem[1]] === 1) {\n                   \
    \         next.push([elem[0] - 1, elem[1]]);\n                        }\n    \
    \                    if (elem[0] < grid.length - 1 && grid[elem[0] + 1][elem[1]]\
    \ === 1) {\n                            next.push([elem[0] + 1, elem[1]]);\n \
    \                       }\n                        if (elem[1] > 0 && grid[elem[0]][elem[1]\
    \ - 1] === 1) {\n                            next.push([elem[0], elem[1] - 1]);\n\
    \                        }\n                        if (elem[1] < grid[elem[0]].length\
    \ - 1 && grid[elem[0]][elem[1] + 1] === 1) {\n                            next.push([elem[0],\
    \ ele", "    let prev_fill: number[] = grid[0];\n    let fill_counter: number\
    \ = 0;\n    grid.forEach((row: number[], i: number) => {\n        if (i != 0)\
    \ {\n            prev_fill = fill(row, prev_fill, capacity);\n            fill_counter\
    \ += count_fill(row, prev_fill);\n        }\n    });\n    return fill_counter;\n\
    }\n", "    let counter = 0;\n    for (let i = 0; i < grid.length; i++) {\n   \
    \     for (let j = 0; j < grid[i].length; j++) {\n            let tmp = capacity;\n\
    \            for (let k = i; k < grid.length; k++) {\n                for (let\
    \ l = j; l < grid[k].length; l++) {\n                    if (grid[k][l] === 1)\
    \ {\n                        if (tmp >= 1) {\n                            grid[k][l]\
    \ = 0;\n                            tmp -= 1;\n                        } else\
    \ {\n                            break;\n                        }\n         \
    \           }\n                }\n            }\n            if (tmp < capacity)\
    \ {\n                counter += 1;\n            }\n        }\n    }\n    return\
    \ counter;\n}\n", "  // TODO: Implement the function here\n  // * 1 <= grid.length\
    \ <= 10^2\n  // * 1 <= grid[:,1].length <= 10^2\n  // * grid[i][j] -> 0 | 1\n\
    \  // * 1 <= capacity <= 10\n  if (capacity == 0) {\n    return 0;\n  }\n  const\
    \ m = grid.length;\n  const n = grid[0].length;\n  let count = 0;\n  for (let\
    \ i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j]\
    \ == 1) {\n        grid[i][j] = 0;\n        count++;\n        if (i - 1 >= 0 &&\
    \ grid[i - 1][j] == 1) {\n          grid[i - 1][j] = 0;\n          count++;\n\
    \        }\n        if (i + 1 < m && grid[i + 1][j] == 1) {\n          grid[i\
    \ + 1][j] = 0;\n          count++;\n        }\n        if (j - 1 >= 0 && grid[i][j\
    \ - 1] == 1) {\n          grid[i][j - 1] = 0;\n          count++;\n        }\n\
    \        if (j + 1 < n && grid[i][j + 1] == 1) {\n          grid[i][j + 1] = 0;\n\
    \          count++;\n        }\n      }\n    }\n  }\n  return count;\n}\n", " \
    \ let moves = 0;\n  while (true) {\n    if (grid.map(row => row.reduce((a, b)\
    \ => a + b, 0)).reduce((a, b) => a + b, 0) === 0) {\n      return moves;\n   \
    \ }\n    for (let i = 0; i < grid.length; i++) {\n      for (let j = 0; j < grid[i].length;\
    \ j++) {\n        if (grid[i][j] > 0) {\n          grid[i][j] = 0;\n         \
    \ moves++;\n          for (let k = i + 1; k < grid.length; k++) {\n          \
    \  if (grid[k][j] > 0) {\n              if (grid[k][j] - capacity >= 0) {\n  \
    \              grid[k][j] -= capacity;\n              } else {\n             \
    \   grid[k][j] = 0;\n              }\n            }\n          }\n        }\n\
    \      }\n    }\n  }\n}\n", "  let times = 0;\n  const wells = grid.map(well =>\
    \ well.reduce((sum, el) => sum + el, 0));\n  const wellsCopy = wells.map(well\
    \ => well);\n  let min = Math.min(...wellsCopy);\n  let max = Math.max(...wellsCopy);\n\
    \  let idxMax = wellsCopy.indexOf(max);\n  while (min < max) {\n    wellsCopy[idxMax]\
    \ -= capacity;\n    if (wellsCopy[idxMax] < min) {\n      min = wellsCopy[idxMax];\n\
    \    }\n    if (wellsCopy[idxMax] > max) {\n      max = wellsCopy[idxMax];\n \
    \   }\n    idxMax = wellsCopy.indexOf(max);\n    times++;\n  }\n  return times;\n\
    }\n", "  let filled = 0;\n  const wells = grid.map(r => r.join(''));\n  let max\
    \ = wells.reduce((max, well) => Math.max(max, well.length), 0);\n  while (max\
    \ > 0) {\n    let count = 0;\n    for (let i = 0; i < wells.length; i++) {\n \
    \     const well = wells[i];\n      if (well.length < max && well.includes('1'))\
    \ {\n        count++;\n        wells[i] = [...well.slice(0, well.indexOf('1')),\
    \ ...well.slice(well.indexOf('1') + 1)].join('');\n      }\n    }\n    filled\
    \ += Math.ceil(count / capacity);\n    max--;\n  }\n  return filled;\n}\nexport\
    \ default max_fill;", "  let lowerCounter = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n      let currentCell\
    \ = grid[i][j];\n      if (currentCell !== 0) {\n        currentCell -= capacity;\n\
    \        if (currentCell < 0) {\n          lowerCounter += currentCell * -1;\n\
    \        }\n      }\n    }\n  }\n  return lowerCounter;\n}\n", "\tif (grid.length\
    \ === 0) {\n\t\treturn 0;\n\t}\n\tif (grid[0].length === 0) {\n\t\treturn 0;\n\
    \t}\n\tif (capacity === 0) {\n\t\treturn 0;\n\t}\n\tif (grid.length === 1 && grid[0].length\
    \ === 1) {\n\t\tif (grid[0][0] === 1) {\n\t\t\treturn capacity;\n\t\t} else {\n\
    \t\t\treturn 0;\n\t\t}\n\t}\n\tlet filledColumns = [];\n\tfor (let i = 0; i <\
    \ grid[0].length; i++) {\n\t\tfilledColumns.push(false);\n\t}\n\tlet count = 0;\n\
    \tfor (let i = 0; i < grid.length; i++) {\n\t\tfor (let j = 0; j < grid[i].length;\
    \ j++) {\n\t\t\tif (grid[i][j] === 1 && !filledColumns[j]) {\n\t\t\t\tfilledColumns[j]\
    \ = true;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn count * capacity;\n\
    }\n", "  let ans = 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let\
    \ j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n        ans\
    \ += capacity;\n        for (let k = 0; k < capacity; k++) {\n          if (i\
    \ > 0 && grid[i - 1][j] === 1) {\n            ans--;\n          }\n          if\
    \ (j > 0 && grid[i][j - 1] === 1) {\n            ans--;\n          }\n       \
    \ }\n      }\n    }\n  }\n  return ans;\n}\nconsole.log(max_fill([[0, 0, 1, 0],\
    \ [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0,\
    \ 0, 0]], 5));", "    // Fill me in!\n    return 0;\n}\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\nconsole.log(max_fill([[0, 0, 1,\
    \ 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5))", "  //   let ans = 0;\n  //   let wells = 0;\n  // \
    \  let water = 0;\n  //   let i = 0;\n  //   let j = 0;\n  //   const max = grid.length;\n\
    \  //   while (i < max) {\n  //     while (j < max) {\n  //       if (grid[i][j]\
    \ === 1) {\n  //         water += 1;\n  //       }\n  //       if (water === capacity)\
    \ {\n  //         water = 0;\n  //         wells += 1;\n  //       }\n  //   \
    \    if (wells === max) {\n  //         ans += 1;\n  //         wells = 0;\n \
    \ //       }\n  //       j += 1;\n  //     }\n  //     j = 0;\n  //     i += 1;\n\
    \  //   }\n  //   return ans;\n  return 0;\n}\n", "  let result = 0;\n  const\
    \ rowLength = grid[0].length;\n  const columnLength = grid.length;\n  for (let\
    \ i = 0; i < rowLength; i++) {\n    let checker = true;\n    for (let j = 0; j\
    \ < columnLength; j++) {\n      if (grid[j][i] === 1) {\n        checker = false;\n\
    \        break;\n      }\n    }\n    if (checker) {\n      result += capacity;\n\
    \    }\n  }\n  return result;\n}\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], 1)); // 6\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0,\
    \ 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2)); // 5\nconsole.log(max_fill([[0, 0, 0],\
    \ [0, 0, 0]], 5)); // 0", "  let bucket: number = 0;\n  let maxBucket: number\
    \ = 0;\n  for (let i = 0; i < grid.length; i++) {\n    let row: number[] = grid[i];\n\
    \    for (let j = 0; j < row.length; j++) {\n      if (row[j] === 1) {\n     \
    \   bucket++;\n      }\n    }\n    maxBucket = Math.max(maxBucket, bucket);\n\
    \    bucket = 0;\n  }\n  return maxBucket === 0 ? 0 : maxBucket - capacity;\n\
    }\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5));", "  // TODO: insert code here.\n  return -1;\n}\n\n\
    import {\n  assertEquals,\n} from \"https://deno.land/std@0.60.0/testing/asserts.ts\"\
    ;\nDeno.test({\n  name: \"max_fill\",\n  fn(): void {\n    assertEquals(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1), 6);\n    assertEquals(max_fill([[0,\
    \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2), 5);\n    assertEquals(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5), 0);\n  },\n});", "    let number_of_moves = 0;\n    let\
    \ current_position: number[];\n    const height = grid.length;\n    const width\
    \ = grid[0].length;\n    const empty_rows = findEmptyRows(grid);\n    for (let\
    \ well_col = 0; well_col < width; well_col++) {\n        let is_filled = false;\n\
    \        for (let well_row = 0; well_row < height; well_row++) {\n           \
    \ if (grid[well_row][well_col] === 1) {\n                is_filled = true;\n \
    \               if (well_row + 1 < height && grid[well_row + 1][well_col] ===\
    \ 0) {\n                    number_of_moves++;\n                    current_position\
    \ = [well_row + 1, well_col];\n                    fill(current_position, grid,\
    \ capacity);\n                }\n            }\n        }\n        if (!is_filled)\
    \ {\n            number_of_moves += (height - empty_rows[well_col]);\n       \
    \ }\n    }\n    return number_of_moves;\n}\n", "    if (grid.length === 0) {\n\
    \        return 0;\n    }\n    let left_most = 0;\n    let right_most = grid[0].length\
    \ - 1;\n    let max_fill = 0;\n    while (left_most <= right_most) {\n       \
    \ let max_fill_left = 0;\n        let max_fill_right = 0;\n        for (let i\
    \ = 0; i < grid.length; i++) {\n            if (grid[i][left_most] === 1) {\n\
    \                max_fill_left += 1;\n            }\n            if (grid[i][right_most]\
    \ === 1) {\n                max_fill_right += 1;\n            }\n        }\n \
    \       if (max_fill_left >= max_fill_right) {\n            max_fill += Math.min(max_fill_left,\
    \ capacity);\n            left_most += 1;\n        } else {\n            max_fill\
    \ += Math.min(max_fill_right, capacity);\n            right_most -= 1;\n     \
    \   }\n    }\n    return max_fill;\n}\n", "    let timesLowered = 0;\n    for\
    \ (let y = 0; y < grid.length; y++) {\n        if (grid[y].indexOf(1) !== -1)\
    \ {\n            for (let x = 0; x < grid[y].length; x++) {\n                if\
    \ (grid[y][x] === 1) {\n                    timesLowered += capacity;\n      \
    \              let tempRow = grid[y];\n                    grid[y] = tempRow.map(value\
    \ => 0);\n                }\n            }\n        }\n    }\n    return timesLowered;\n\
    }", "    let numCycles = 0;\n    // console.log(\"1\");\n    if (grid.length <=\
    \ capacity) {\n        numCycles += 1;\n    }\n    // console.log(\"2\");\n  \
    \  if (grid[0].length <= capacity) {\n        numCycles += 1;\n    }\n    // console.log(\"\
    3\");\n    for (let i = 0; i < grid.length; i++) {\n        for (let j = 0; j\
    \ < grid[i].length; j++) {\n            // console.log(\"4\");\n            if\
    \ (grid[i][j] === 1) {\n                numCycles += 1;\n            }\n     \
    \   }\n    }\n    // console.log(\"5\");\n    return numCycles;\n}\n\n(function\
    \ () {\n    console.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\n\
    \    console.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1,\
    \ 1]], 2));\n    console.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));\n})();", " \
    \ // TODO: implement this!\n  return 0;\n}\n", "  // your code goes here\n  return\
    \ -1;\n}\n\nexport { max_fill };", "  let min = 0;\n  let max = 0;\n  let count\
    \ = 0;\n  let rowLength = grid[0].length;\n  let columnLength = grid.length;\n\
    \  let lowWater = false;\n  while (true) {\n    let water = capacity;\n    for\
    \ (let i = 0; i < columnLength; i++) {\n      for (let j = 0; j < rowLength; j++)\
    \ {\n        if (grid[i][j] === 1) {\n          water--;\n          grid[i][j]\
    \ = 0;\n          if (water === 0) {\n            break;\n          }\n      \
    \  }\n      }\n      if (water === 0) {\n        count++;\n        lowWater =\
    \ false;\n        break;\n      }\n    }\n    if (water > 0) {\n      for (let\
    \ i = 0; i < columnLength; i++) {\n        for (let j = 0; j < rowLength; j++)\
    \ {\n          if (grid[i][j] === 0) {\n            grid[i][j] = 1;\n        \
    \    water--;\n            if (water === 0) {\n              break;\n        \
    \    }\n          }\n        }\n        if (water === 0) {\n          count++;\n\
    \          lowWater = true;\n          break;\n        }\n      }\n    }\n   \
    \ if (lowWater) {\n      for (let i = 0; i < columnLength; i++) {\n        for\
    \ (let j = 0; j < rowLength; j++) {\n          if (grid[i][j] === 1) {\n     \
    \       lowWater = false;\n            break;\n          }\n        }\n      \
    \  if (!lowWater) {\n          break;\n        }\n      }\n    }\n    if (lowWater)\
    \ {\n      break;\n    }\n  }\n  return count;\n}\n", "    // your code here\n\
    \    let result: number = 0;\n    for (let i = 0; i < grid.length; i++) {\n  \
    \      for (let j = 0; j < grid[i].length; j++) {\n            if (grid[i][j]\
    \ === 1) {\n                result += (capacity - 1);\n            }\n       \
    \ }\n    }\n    return result;\n}", "  // TODO\n  // var wells = [];\n  // var\
    \ row = grid.length;\n  // var col = grid[0].length;\n  // var b = 0;\n  // var\
    \ i = 0;\n  // var j = 0;\n  // var k = 0;\n  // var m = 0;\n  // var n = 0;\n\
    \  // var filled = 0;\n  // var left = 0;\n  // for (i = 0; i < row; i++) {\n\
    \  //   wells[i] = [];\n  //   for (j = 0; j < col; j++) {\n  //     wells[i][j]\
    \ = grid[i][j];\n  //   }\n  // }\n  // filled = row;\n  // while (filled !==\
    \ 0) {\n  //   if (capacity > 0) {\n  //     b++;\n  //     capacity--;\n  //\
    \   }\n  //   filled = 0;\n  //   left = capacity;\n  //   for (i = 0; i < row;\
    \ i++) {\n  //     for (j = 0; j < col; j++) {\n  //       if (wells[i][j] ===\
    \ 1) {\n  //         filled++;\n  //         wells[i][j] = 0;\n  //         left--;\n\
    \  //         if (left < 0) {\n  //           break;\n  //         }\n  //   \
    \    }\n  //     }\n  //     if (left < 0) {\n  //       break;\n  //     }\n\
    \  //   }\n  //   if (left < 0) {\n  //     left = 0;\n  //   }\n  //   capacity\
    \ = left;\n  // }\n  // return b;\n  return 0;\n}\n", "  const wells = grid.length;\n\
    \  const units = grid[0].length;\n  const stack: { well: number; units: number\
    \ }[] = [];\n  let moves = 0;\n  let well = 0;\n  let unit = 0;\n  for (let i\
    \ = 0; i < wells; i++) {\n    for (let j = 0; j < units; j++) {\n      if (grid[i][j]\
    \ === 1) {\n        stack.push({ well: i, units: j });\n      }\n    }\n  }\n\
    \  while (stack.length > 0) {\n    well = stack[0].well;\n    unit = stack[0].units;\n\
    \    while (well > 0 && unit < units) {\n      if (grid[well - 1][unit] === 1)\
    \ {\n        stack.push({ well: well - 1, units: unit });\n        well--;\n \
    \     } else {\n        unit++;\n      }\n    }\n    for (let j = 0; j < unit;\
    \ j++) {\n      moves++;\n      grid[well][j] = 0;\n    }\n    stack.shift();\n\
    \  }\n  return moves;\n}\n", "  let result = 0;\n  for (let i = 0; i < grid.length;\
    \ i++) {\n    result += max_fill_row(grid[i], capacity);\n  }\n  return result;\n\
    }\n", "    let times = 0;\n    const maxRow = grid.length;\n    const maxCol =\
    \ grid[0].length;\n    for (let i = 0; i < maxRow; i++) {\n        for (let j\
    \ = 0; j < maxCol; j++) {\n            if (grid[i][j] === 1) {\n             \
    \   for (let n = 1; n <= capacity; n++) {\n                    const row = i +\
    \ n;\n                    if (row >= maxRow) {\n                        break;\n\
    \                    }\n                    if (grid[row][j] === 1) {\n      \
    \                  grid[row][j] = 0;\n                        times++;\n     \
    \               }\n                }\n            }\n        }\n    }\n    return\
    \ times;\n}\n\nexport function runTests(): void {\n    const inputs = [\n    \
    \    [[[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1],\n        [[[0, 0, 1, 1],\
    \ [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2],\n        [[[0, 0, 0], [0, 0,\
    \ 0]], 5],\n    ];\n    const expected = [6, 5, 0];\n    for (let i = 0; i < inputs.length;\
    \ i++) {\n        const result = max_fill(inputs[i][0], inputs[i][1]);\n     \
    \   if (result !== expected[i]) {\n            throw new Error(`Test failed for\
    \ ${inputs[i]}, expected ${expected[i]}, got ${result}`);\n        }\n    }\n\
    \    console.log('All tests passed!');\n}", "  let cnt = 0;\n  for (let i = 0;\
    \ i < grid.length; i++) {\n    let row = grid[i];\n    let sum = row.reduce((acc,\
    \ cur) => acc + cur, 0);\n    let step = Math.ceil(sum / capacity);\n    cnt +=\
    \ step;\n  }\n  return cnt;\n}\n\nlet res = max_fill([[0, 0, 1, 0], [0, 1, 0,\
    \ 0], [1, 1, 1, 1]], 1);\nconsole.log(res);", "  const wells: number[][] = grid.map(row\
    \ => [...row]);\n  let fillCount = 0;\n  while (true) {\n    const emptyRowIndex\
    \ = wells.findIndex(row => row.includes(1));\n    if (emptyRowIndex < 0) {\n \
    \     break;\n    }\n    for (let i = 0; i < wells[emptyRowIndex].length; i++)\
    \ {\n      if (wells[emptyRowIndex][i] === 1) {\n        wells[emptyRowIndex][i]\
    \ = 0;\n        fillCount++;\n      }\n    }\n    for (let i = emptyRowIndex +\
    \ 1; i < wells.length; i++) {\n      wells[i] = wells[i].map(value => value ===\
    \ 1 ? 0 : value);\n    }\n  }\n  return fillCount;\n}\n\ninterface ISolution {\n\
    \  fillCount: number;\n  grid: number[][];\n  capacity: number;\n}\n", "    let\
    \ result = 0;\n    for (let row of grid) {\n        let currentRow = 0;\n    \
    \    for (let i = 0; i < row.length; i++) {\n            currentRow += row[i];\n\
    \            if (currentRow > capacity) {\n                result += currentRow\
    \ - capacity;\n                currentRow = capacity;\n            }\n       \
    \ }\n    }\n    return result;\n}\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1,\
    \ 0, 0], [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0],\
    \ [1, 1, 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]],\
    \ 5));", "  const min = Math.min(...grid.map(l => Math.min(...l)));\n  const max\
    \ = Math.max(...grid.map(l => Math.max(...l)));\n  if (min === max) {\n    return\
    \ 0;\n  }\n  if (capacity === 1) {\n    return grid.length * grid[0].length;\n\
    \  }\n  const height = grid.length;\n  const width = grid[0].length;\n  let min_depth\
    \ = min;\n  let total_depth = 0;\n  while (true) {\n    if (total_depth + min_depth\
    \ >= max) {\n      break;\n    }\n    let depth = 0;\n    let volume = 0;\n  \
    \  for (let i = 0; i < height; i++) {\n      for (let j = 0; j < width; j++) {\n\
    \        if (grid[i][j] > depth) {\n          depth = grid[i][j];\n          volume\
    \ = 1;\n        } else if (grid[i][j] === depth) {\n          volume++;\n    \
    \    }\n      }\n    }\n    if (total_depth + depth >= max) {\n      break;\n\
    \    }\n    total_depth += depth;\n    if (volume > capacity) {\n      min_depth\
    \ = depth;\n    }\n    if (volume <= capacity) {\n      break;\n    }\n    for\
    \ (let i = 0; i < height; i++) {\n      for (let j = 0; j < width; j++) {\n  \
    \      if (grid[i][j] === depth) {\n          grid[i][j] = 0;\n        }\n   \
    \   }\n    }\n  }\n  return total_depth;\n}", "  let cnt: number = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++)\
    \ {\n      if (grid[i][j] == 1) {\n        grid[i][j] = 0;\n        cnt++;\n \
    \       while (capacity > 0) {\n          capacity--;\n          if (i == 0 &&\
    \ j == 0) {\n            if (grid[i][j + 1] == 1) {\n              grid[i][j +\
    \ 1] = 0;\n              capacity++;\n            }\n            if (grid[i +\
    \ 1][j] == 1) {\n              grid[i + 1][j] = 0;\n              capacity++;\n\
    \            }\n          } else if (i == 0 && j == grid[i].length - 1) {\n  \
    \          if (grid[i][j - 1] == 1) {\n              grid[i][j - 1] = 0;\n   \
    \           capacity++;\n            }\n            if (grid[i + 1][j] == 1) {\n\
    \              grid[i + 1][j] = 0;\n              capacity++;\n            }\n\
    \          } else if (i == grid.length - 1 && j == 0) {\n            if (grid[i][j\
    \ + 1] == 1) {\n              grid[i][j + 1] = 0;\n              capacity++;\n\
    \            }\n            if (grid[i - 1][j] == 1) {\n              grid[i -\
    \ 1][j] = 0;\n              capacity++;\n            }\n          } else if (i\
    \ == grid.length - 1 && j == grid[i].length - 1) {\n            if (grid[i][j\
    \ - 1] == 1) {\n              grid[i][j - 1] = 0;\n              capacity++;\n\
    \            }\n            if (grid[i - 1][j] == 1) {\n              grid[i -\
    \ 1][j] = 0;\n              capacity++;\n            }\n          } else if (i\
    \ == 0) {\n            if (grid[i][j - 1] == 1) {\n              grid[i][j - 1]\
    \ = 0;\n              capacity++;\n            }\n            if (grid[i", " \
    \   let sum = 0;\n    for (let i = 0; i < grid.length; i++) {\n        for (let\
    \ j = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n   \
    \             sum += capacity;\n            }\n        }\n    }\n    return sum;\n\
    }", "  return 0;\n}\n", "    let count = 0;\n    while (true) {\n        let has_fill\
    \ = false;\n        for (let row = 0; row < grid.length; row++) {\n          \
    \  let sum = 0;\n            for (let col = 0; col < grid[row].length; col++)\
    \ {\n                if (grid[row][col] === 1) {\n                    sum++;\n\
    \                }\n            }\n            if (sum === capacity) {\n     \
    \           for (let col = 0; col < grid[row].length; col++) {\n             \
    \       grid[row][col] = 0;\n                }\n                has_fill = true;\n\
    \            }\n        }\n        if (!has_fill) {\n            break;\n    \
    \    }\n        count++;\n    }\n    return count;\n}\n", "    // your code goes\
    \ here\n    let row = grid.length;\n    let col = grid[0].length;\n    let total\
    \ = 0;\n    for (let i = 0; i < row; i++) {\n        let j = 0;\n        let cur\
    \ = 0;\n        while (j < col) {\n            if (grid[i][j] === 1) {\n     \
    \           if (cur < capacity) {\n                    cur = capacity;\n     \
    \               total++;\n                }\n            } else {\n          \
    \      cur--;\n            }\n            j++;\n        }\n    }\n    return total;\n\
    }\n", "  return -1;\n}\n", "    let drops = 0;\n    let wells = grid.length;\n\
    \    let len = grid[0].length;\n    let buckets = new Array(wells).fill(0);\n\
    \    let buckets_empty = true;\n    let hole_empty = false;\n    let hole = false;\n\
    \    while (true) {\n        buckets_empty = true;\n        hole_empty = false;\n\
    \        hole = false;\n        for (let i = 0; i < wells; i++) {\n          \
    \  if (buckets[i] < capacity) {\n                buckets_empty = false;\n    \
    \        }\n            if (buckets[i] < capacity && grid[i][0] === 1) {\n   \
    \             if (i === 0 || buckets[i - 1] >= capacity) {\n                 \
    \   buckets[i] += 1;\n                    drops += 1;\n                    grid[i].shift();\n\
    \                    hole = true;\n                }\n            }\n        }\n\
    \        if (buckets_empty && !hole) {\n            break;\n        }\n      \
    \  for (let i = 0; i < wells; i++) {\n            if (buckets[i] < capacity) {\n\
    \                buckets_empty = false;\n            }\n            if (buckets[i]\
    \ < capacity && grid[i][len - 1] === 1) {\n                if (i === wells - 1\
    \ || buckets[i + 1] >= capacity) {\n                    buckets[i] += 1;\n   \
    \                 drops += 1;\n                    grid[i].pop();\n          \
    \          hole = true;\n                }\n            }\n        }\n       \
    \ if (buckets_empty && !hole) {\n            break;\n        }\n    }\n    return\
    \ drops;\n}\n\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]],\
    \ 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1,\
    \ 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));", "  let sum\
    \ = 0;\n  let min = grid[0][0];\n  let max = grid[0][0];\n  for (let i = 0; i\
    \ < grid.length; i++) {\n    let count = 0;\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n  \
    \  sum += count;\n    if (count < min) {\n      min = count;\n    }\n    if (count\
    \ > max) {\n      max = count;\n    }\n  }\n  let count = 0;\n  for (let i = 0;\
    \ i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++) {\n  \
    \    if (grid[i][j] === 1) {\n        count++;\n      }\n    }\n  }\n  if (count\
    \ === 0) {\n    return 0;\n  }\n  let rounds = 0;\n  let times = Math.floor(max\
    \ / capacity);\n  if (times === 0) {\n    rounds += 1;\n  } else {\n    rounds\
    \ += times;\n  }\n  rounds += Math.floor(min / capacity);\n  return rounds * capacity;\n\
    }\n", "  // your code here\n  return 0;\n}", "  // TODO\n  return 0;\n}\n\nconsole.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));", "  let max_fill = 0;\n  for (let\
    \ i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length; j++)\
    \ {\n      if (grid[i][j] === 1) {\n        max_fill++;\n      }\n    }\n  }\n\
    \  return max_fill * capacity;\n}\n", "  let isFilled = (i: number, j: number)\
    \ => {\n    return i >= 0 && j >= 0 && i < grid.length && j < grid[0].length;\n\
    \  };\n  let fill = (i: number, j: number) => {\n    if (isFilled(i, j) && grid[i][j]\
    \ > 0) {\n      grid[i][j] -= 1;\n      return 1;\n    }\n    return 0;\n  };\n\
    \  let fillNeighbors = (i: number, j: number) => {\n    return fill(i - 1, j)\
    \ + fill(i + 1, j) + fill(i, j - 1) + fill(i, j + 1);\n  };\n  let count = 0;\n\
    \  while (true) {\n    let fillUp = 0;\n    for (let i = 0; i < grid.length; i++)\
    \ {\n      for (let j = 0; j < grid[0].length; j++) {\n        if (grid[i][j]\
    \ > 0) {\n          fillUp += Math.min(grid[i][j], capacity);\n          let filledNeighbors\
    \ = fillNeighbors(i, j);\n          grid[i][j] = Math.max(0, grid[i][j] - filledNeighbors);\n\
    \        }\n      }\n    }\n    if (fillUp === 0) {\n      break;\n    }\n   \
    \ count += 1;\n  }\n  return count;\n}\n", "  let drops = 0;\n  const rows: number\
    \ = grid.length;\n  const cols: number = grid[0].length;\n  for (let c = 0; c\
    \ < cols; c++) {\n    drops = fill_column(grid, capacity, c, rows, drops);\n \
    \ }\n  return drops;\n}\n", "    let moves = 0;\n    let wells = grid[0].length;\n\
    \    let rows = grid.length;\n    for (let i = 0; i < rows; i++) {\n        for\
    \ (let j = 0; j < wells; j++) {\n            if (grid[i][j] === 1) {\n       \
    \         moves++;\n                grid[i][j] = 0;\n                let currentCapacity\
    \ = capacity;\n                while (currentCapacity > 0) {\n               \
    \     if (i > 0 && grid[i - 1][j] === 1) {\n                        grid[i - 1][j]\
    \ = 0;\n                        currentCapacity--;\n                    }\n  \
    \                  if (i < rows - 1 && grid[i + 1][j] === 1) {\n             \
    \           grid[i + 1][j] = 0;\n                        currentCapacity--;\n\
    \                    }\n                    if (j > 0 && grid[i][j - 1] === 1)\
    \ {\n                        grid[i][j - 1] = 0;\n                        currentCapacity--;\n\
    \                    }\n                    if (j < wells - 1 && grid[i][j + 1]\
    \ === 1) {\n                        grid[i][j + 1] = 0;\n                    \
    \    currentCapacity--;\n                    }\n                    if (i ===\
    \ 0 && j === 0) {\n                        break;\n                    }\n   \
    \             }\n            }\n        }\n    }\n    return moves;\n}", "  const\
    \ m = grid.length;\n  const n = grid[0].length;\n  let count = 0;\n  for (let\
    \ j = 0; j < n; j++) {\n    let isUsed = false;\n    for (let i = 0; i < m; i++)\
    \ {\n      if (grid[i][j] === 1) {\n        if (isUsed) {\n          count++;\n\
    \        } else {\n          isUsed = true;\n        }\n      } else {\n     \
    \   isUsed = false;\n      }\n    }\n  }\n  return count * capacity;\n}\n", " \
    \   //find total number of wells, and total number of 0's,\n    //use total number\
    \ of wells - total number of 0's to find number of wells to fill\n    //divide\
    \ by the bucket capacity to find number of times to lower bucket\n    let totalWells\
    \ = 0;\n    let totalZeros = 0;\n    let totalOnes = 0;\n    for (let row = 0;\
    \ row < grid.length; row++) {\n        for (let col = 0; col < grid[row].length;\
    \ col++) {\n            if (grid[row][col] === 0) {\n                totalZeros++;\n\
    \            } else {\n                totalOnes++;\n            }\n        }\n\
    \        totalWells += grid[row].length;\n    }\n    let fillWells = totalWells\
    \ - totalZeros;\n    return Math.ceil(fillWells / capacity);\n}\n", "  const numberOfWells\
    \ = grid.length;\n  const wells = grid.map(x => x.map(y => y));\n  let fill: number\
    \ = 0;\n  while (true) {\n    const wellToFill = wells.findIndex(x => x.some(y\
    \ => y === 1));\n    if (wellToFill === -1) {\n      break;\n    }\n\n    const\
    \ unitsToFill = wells[wellToFill].filter(x => x === 1).length;\n    fill += Math.ceil(unitsToFill\
    \ / capacity);\n    wells[wellToFill] = wells[wellToFill].map(x => 0);\n  }\n\
    \  return fill;\n}\n", "  // make a range of wells, with the height of each well\n\
    \  const wells = grid.map(row => {\n    return row.filter(col => col).length;\n\
    \  });\n  // console.log('wells', wells);\n  // sort the wells in descending order\n\
    \  const sortedWells = wells.sort((a, b) => b - a);\n  // console.log('sortedWells',\
    \ sortedWells);\n  // run max_fill for each well\n  let count = 0;\n  sortedWells.forEach(well\
    \ => {\n    count += max_fill_for_well(well, capacity);\n  });\n  return count;\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
