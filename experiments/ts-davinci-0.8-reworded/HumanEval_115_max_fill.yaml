name: HumanEval_115_max_fill
language: ts
prompt: "//You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n// and each 1 in a row represents a single unit of water.\n// Each well\
  \ has a corresponding bucket that can be used to extract water from it, \n// and\
  \ all buckets have the same capacity.\n// Your task is to use the buckets to empty\
  \ the wells.\n// Output the number of times you need to lower the buckets.\n// Example\
  \ 1:\n// >>> max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1)\n// 6\n// Example\
  \ 2:\n// >>> max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]],\
  \ 2)\n// 5\n// Example 3:\n// >>> max_fill([[0, 0, 0], [0, 0, 0]], 5)\n// 0\n//\
  \ Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n\
  // * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity\
  \ <= 10\nfunction max_fill(grid: number[][], capacity: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = max_fill;\n  assert.deepEqual(candidate([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6);\n  assert.deepEqual(candidate([[0, 0,\
  \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5);\n  assert.deepEqual(candidate([[0,\
  \ 0, 0], [0, 0, 0]], 5),0);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1,\
  \ 1, 1]], 2),4);\n  assert.deepEqual(candidate([[1, 1, 1, 1], [1, 1, 1, 1]], 9),2);\n\
  }\n\ntest();"
completions: ["  const weights = grid.reduce((acc, curr) => acc.concat(curr.map((n)\
    \ => n * capacity)), []);\n  const percentages = weights.map((n) => n / capacity);\n\
    \  const weightsWithMedian = percentages.map((n) => Math.floor(n - (1 - 0.5)));\n\
    \  const bucketsNeeded = weightsWithMedian.reduce((acc, curr) => acc + curr, 0);\n\
    \  return bucketsNeeded;\n}\n", "    let result = 0;\n    const rows = grid.length;\n\
    \    const cols = grid[0].length;\n    const well = [];\n    const temp = [];\n\
    \    const bucket = capacity;\n    const counter = [];\n    // filling well\n\
    \    for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols;\
    \ col++) {\n            well.push(grid[row][col]);\n        }\n    }\n    for\
    \ (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n   \
    \         if (well[cols * i + j] === 1) {\n                temp.push(bucket);\n\
    \            } else {\n                temp.push(0);\n            }\n        }\n\
    \    }\n    for (let i = 0; i < rows; i++) {\n        counter.push(cols);\n  \
    \  }\n    while (true) {\n        const sum = [...temp].reduce((acc, x) => acc\
    \ + x, 0);\n        if (sum > 0) {\n            for (let row = 0; row < rows;\
    \ row++) {\n                for (let col = 0; col < cols; col++) {\n         \
    \           if (temp[cols * row + col] > 0) {\n                        temp[cols\
    \ * row + col] -= 1;\n                        if (temp[cols * row + col] === 0)\
    \ {\n                            counter[row] -= 1;\n                        }\n\
    \                    }\n                }\n            }\n            result +=\
    \ 1;\n        } else {\n            break;\n        }\n    }\n    // console.log(counter);\n\
    \    if (counter.every(x => x === 0)) {\n        return result;\n    } else {\n\
    \        return -1;\n    }\n}\n\n(function () {\n    console.log(max_fill([[0,\
    \ 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1));\n    console.log(max_fill([[0, 0,\
    \ 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0,", "    let row: number[] = [];\n    let\
    \ min: number = 0;\n    let max: number = 0;\n    let result: number = 0;\n  \
    \  for (let i: number = 0; i < grid.length; i++) {\n        for (let j: number\
    \ = 0; j < grid[i].length; j++) {\n            if (grid[i][j] === 1) {\n     \
    \           row.push(1);\n            } else {\n                row.push(0);\n\
    \            }\n        }\n        min = Math.min(...row);\n        max = Math.max(...row);\n\
    \        result += max * capacity - (max - min) * capacity;\n        row = [];\n\
    \    }\n    return result;\n}", "  let num_buckets = 0;\n  let bucket_capacity\
    \ = capacity;\n  let [rows, cols] = [grid.length, grid[0].length];\n  for (let\
    \ i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (grid[i][j]\
    \ > 0) {\n        num_buckets += 1;\n        bucket_capacity -= grid[i][j];\n\
    \      }\n    }\n    bucket_capacity = capacity;\n  }\n  return num_buckets;\n\
    }\n\n(function main(): void {\n  const a = [\n    [0, 0, 1, 0],\n    [0, 1, 0,\
    \ 0],\n    [1, 1, 1, 1]\n  ];\n  const b = [\n    [0, 0, 1, 1],\n    [0, 0, 0,\
    \ 0],\n    [1, 1, 1, 1],\n    [0, 1, 1, 1]\n  ];\n  const c = [\n    [0, 0, 0],\n\
    \    [0, 0, 0]\n  ];\n  console.log(max_fill(a, 1));\n  console.log(max_fill(b,\
    \ 2));\n  console.log(max_fill(c, 5));\n})();", "  let times = 0;\n  let visit\
    \ = [];\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      visit.push([i, j]);\n      if (grid[i][j] === 1) {\n        grid[i][j]\
    \ = capacity;\n        times += capacity;\n      }\n    }\n  }\n  while (visit.length\
    \ > 0) {\n    let [i, j] = visit.shift();\n    if (grid[i][j] > 0) {\n      for\
    \ (let [i1, j1] of [[i - 1, j], [i + 1, j], [i, j - 1], [i, j + 1]]) {\n     \
    \   if (\n          i1 >= 0 &&\n          i1 < grid.length &&\n          j1 >=\
    \ 0 &&\n          j1 < grid[i].length &&\n          grid[i1][j1] < grid[i][j]\n\
    \        ) {\n          visit.push([i1, j1]);\n          grid[i1][j1] += grid[i][j]\
    \ - 1;\n          times += grid[i][j] - 1;\n        }\n      }\n    }\n  }\n \
    \ return times;\n}\n\n(function () {\n  function assertEquals(a, b) {\n    if\
    \ (a === b) {\n      console.log(\"PASS\");\n    } else {\n      console.log(\"\
    FAIL\", a, b);\n    }\n  }\n  assertEquals(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1), 6);\n  assertEquals(\n    max_fill([[0, 0, 1, 1], [0, 0,\
    \ 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),\n    5\n  );\n  assertEquals(max_fill([[0,\
    \ 0, 0], [0, 0, 0]], 5), 0);\n})();", "  return 0;\n}\n", "    let times = 0;\n\
    \    let test = grid;\n    while (!validateGrid(test)) {\n        times++;\n \
    \       test = add_water(test, capacity);\n    }\n    return times;\n}\n", " \
    \   let all_ones = true;\n    let buckets_needed = 0;\n    for (let x = 0; x <\
    \ grid.length; x++) {\n        for (let y = 0; y < grid[x].length; y++) {\n  \
    \          if (grid[x][y] === 0) {\n                all_ones = false;\n      \
    \      }\n        }\n    }\n    if (all_ones) {\n        return 0;\n    } else\
    \ {\n        while (true) {\n            let bucket_count = 0;\n            for\
    \ (let x = 0; x < grid.length; x++) {\n                for (let y = 0; y < grid[x].length;\
    \ y++) {\n                    if (grid[x][y] === 1) {\n                      \
    \  bucket_count++;\n                    }\n                }\n            }\n\
    \            if (bucket_count < capacity) {\n                buckets_needed++;\n\
    \                for (let x = 0; x < grid.length; x++) {\n                   \
    \ for (let y = 0; y < grid[x].length; y++) {\n                        if (grid[x][y]\
    \ === 1) {\n                            grid[x][y] = 0;\n                    \
    \    }\n                    }\n                }\n            } else {\n     \
    \           return buckets_needed;\n            }\n        }\n    }\n}\n", " \
    \   let times = 0;\n    grid.forEach(row => {\n        let current = 0;\n    \
    \    row.forEach(cell => {\n            if (cell === 1) {\n                current\
    \ += 1;\n            }\n        });\n        times += (current / capacity) + ((current\
    \ % capacity) > 0 ? 1 : 0);\n    });\n    return times;\n}\n", "  let count =\
    \ 0;\n  for (let i = 0; i < grid.length; i++) {\n    for (let j = 0; j < grid[i].length;\
    \ j++) {\n      if (grid[i][j] == 1) {\n        count += capacity;\n      }\n\
    \    }\n  }\n  return count;\n}\n", "    let sum = 0;\n    let water = 0;\n  \
    \  let fill = 0;\n    while (true) {\n        if (sum === grid.length) {\n   \
    \         break;\n        }\n        let maxCol = getMaxCol(grid);\n        let\
    \ maxColStart = grid[maxCol].length - 1;\n        for (let i = maxColStart; i\
    \ >= 0; i--) {\n            if (grid[maxCol][i] === 1) {\n                if (water\
    \ < capacity) {\n                    water += 1;\n                    grid[maxCol][i]\
    \ = 0;\n                } else {\n                    water = 0;\n           \
    \         fill += 1;\n                }\n            }\n        }\n        sum\
    \ += 1;\n    }\n    return fill;\n}\n", "    let count = 0;\n    let maxPos =\
    \ { row: 0, pos: 0 };\n    for (let row = 0; row < grid.length; row++) {\n   \
    \     for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col]\
    \ > grid[maxPos.row][maxPos.pos]) {\n                maxPos.row = row;\n     \
    \           maxPos.pos = col;\n            }\n        }\n    }\n    for (let row\
    \ = 0; row < grid.length; row++) {\n        let col = maxPos.pos;\n        while\
    \ (col < grid[row].length) {\n            count += grid[row][col];\n         \
    \   col++;\n        }\n    }\n    return count * capacity;\n}\n\nlet grid: number[][]\
    \ = [[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]];\nconsole.log(max_fill(grid, 1));\n\
    grid = [[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]];\nconsole.log(max_fill(grid,\
    \ 2));\ngrid = [[0, 0, 0], [0, 0, 0]];\nconsole.log(max_fill(grid, 5));", "  \
    \  throw new Error(\"Method not implemented.\");\n}\n", "    let drops = 0;\n\
    \    // Store the maximum height of each column\n    let maxHeight: number[] =\
    \ [];\n    for (let col = 0; col < grid[0].length; col++) {\n        maxHeight.push(0);\n\
    \        for (let row = 0; row < grid.length; row++) {\n            if (grid[row][col]\
    \ === 1) {\n                maxHeight[col] = row + 1;\n            }\n       \
    \ }\n    }\n    let currentHeight = 0;\n    while (currentHeight < Math.max(...maxHeight))\
    \ {\n        // Sort the columns by height\n        maxHeight.sort((a, b) => a\
    \ - b);\n        // Iterate through the columns until we find one with enough\
    \ water to fill the bucket\n        for (let col = 0; col < maxHeight.length;\
    \ col++) {\n            if (maxHeight[col] >= currentHeight + capacity) {\n  \
    \              // Once we find one, fill the bucket and lower it\n           \
    \     currentHeight += capacity;\n                drops++;\n                //\
    \ Remove the water from the column\n                maxHeight[col] -= capacity;\n\
    \                break;\n            }\n        }\n    }\n    return drops;\n\
    }\n", "  const rows = grid.length;\n  const cols = grid[0].length;\n  let sum\
    \ = 0;\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++)\
    \ {\n      if (grid[r][c] === 1) {\n        sum += capacity;\n      }\n    }\n\
    \  }\n  return sum;\n}\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0], [1,\
    \ 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1, 1,\
    \ 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "\tlet water = 0;\n\tfor (let i = 0; i < grid.length; i++) {\n\t\tlet row = grid[i];\n\
    \t\tfor (let j = 0; j < row.length; j++) {\n\t\t\tlet bucket = row[j];\n\t\t\t\
    if (bucket) {\n\t\t\t\twater += capacity;\n\t\t\t}\n\t\t}\n\t}\n\treturn water;\n\
    }\n", "\t// init count\n\t// loop through wells\n\t// try to fill till capacity\n\
    \t// if can fill\n\t// increment count\n\tlet count = 0;\n\tfor (let i = 0; i\
    \ < grid.length; i++) {\n\t\tfor (let j = 0; j < grid[i].length; j++) {\n\t\t\t\
    let canFit = capacity;\n\t\t\tlet index = j;\n\t\t\twhile (canFit > 0 && index\
    \ < grid[i].length) {\n\t\t\t\tif (grid[i][index] === 1) {\n\t\t\t\t\tcanFit--;\n\
    \t\t\t\t\tindex++;\n\t\t\t\t} else {\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\
    \t\t\tif (canFit < capacity) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t}\n\treturn\
    \ count;\n}\n\nexport { max_fill };", "  let counter = 0;\n  let index = grid[0].length\
    \ - 1;\n  const add = () => {\n    let sum = 0;\n    for (let row of grid) {\n\
    \      sum += row[index];\n    }\n    return sum;\n  };\n  while (index >= 0)\
    \ {\n    let addValue = add();\n    if (addValue >= capacity) {\n      for (let\
    \ row of grid) {\n        row[index] = 0;\n      }\n      counter += capacity;\n\
    \    } else {\n      for (let row of grid) {\n        row[index] = 0;\n      }\n\
    \      counter += addValue;\n    }\n    index--;\n  }\n  return counter;\n}\n",
  "  let count = 0;\n  let min = 0;\n  for (let i = 0; i < grid.length; i++) {\n \
    \   for (let j = 0; j < grid[i].length; j++) {\n      if (grid[i][j] === 1) {\n\
    \        count++;\n      }\n    }\n    if (i === 0) {\n      min = count;\n  \
    \  } else {\n      min = Math.min(min, count);\n    }\n    count = 0;\n  }\n \
    \ return min * capacity;\n}\nconsole.log(max_fill([[0, 0, 1, 0], [0, 1, 0, 0],\
    \ [1, 1, 1, 1]], 1));\nconsole.log(max_fill([[0, 0, 1, 1], [0, 0, 0, 0], [1, 1,\
    \ 1, 1], [0, 1, 1, 1]], 2));\nconsole.log(max_fill([[0, 0, 0], [0, 0, 0]], 5));",
  "    let times = 0;\n    let filledRows = 0;\n    while (filledRows < grid.length)\
    \ {\n        let filledCols = 0;\n        for (let j = 0; j < grid[0].length;\
    \ j++) {\n            let gridRowCol = [filledRows, j];\n            if (grid[gridRowCol[0]][gridRowCol[1]]\
    \ === 1) {\n                grid = updateGrid(grid, gridRowCol, capacity);\n \
    \               filledCols++;\n            }\n        }\n        filledRows +=\
    \ Math.ceil(filledCols / capacity);\n        times++;\n    }\n    return times;\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
