name: HumanEval_69_search
language: ts
prompt: "//You are given a non-empty array of positive integers. Return the greatest\
  \ integer that is greater than \n// zero, and has a frequency greater than or equal\
  \ to the value of the integer itself. \n// The frequency of an integer is the number\
  \ of times it appears in the array.\n// If no such a value exist, return -1.\n//\
  \ Examples:\n// >>> search([4, 1, 2, 2, 3, 1])\n// 2\n// >>> search([1, 2, 2, 3,\
  \ 3, 3, 4, 4, 4])\n// 3\n// >>> search([5, 5, 4, 4, 4])\n// -1\nfunction search(lst:\
  \ number[]): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = search;\n  assert.deepEqual(candidate([5, 5, 5, 5,\
  \ 1]),1);\n  assert.deepEqual(candidate([4, 1, 4, 1, 4, 4]),4);\n  assert.deepEqual(candidate([3,\
  \ 3]),-1);\n  assert.deepEqual(candidate([8, 8, 8, 8, 8, 8, 8, 8]),8);\n  assert.deepEqual(candidate([2,\
  \ 3, 3, 2, 2]),2);\n  assert.deepEqual(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6,\
  \ 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]),1);\n  assert.deepEqual(candidate([3, 2,\
  \ 8, 2]),2);\n  assert.deepEqual(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]),1);\n\
  \  assert.deepEqual(candidate([8, 8, 3, 6, 5, 6, 4]),-1);\n  assert.deepEqual(candidate([6,\
  \ 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]),1);\n\
  \  assert.deepEqual(candidate([1, 9, 10, 1, 3]),1);\n  assert.deepEqual(candidate([6,\
  \ 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]),5);\n\
  \  assert.deepEqual(candidate([1]),1);\n  assert.deepEqual(candidate([8, 8, 10,\
  \ 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]),4);\n  assert.deepEqual(candidate([2,\
  \ 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]),2);\n  assert.deepEqual(candidate([1,\
  \ 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]),1);\n  assert.deepEqual(candidate([9, 2, 4,\
  \ 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10,\
  \ 9, 4]),4);\n  assert.deepEqual(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6,\
  \ 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]),4);\n  assert.deepEqual(candidate([9, 8, 6,\
  \ 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]),2);\n  assert.deepEqual(candidate([5,\
  \ 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]),-1);\n  assert.deepEqual(candidate([10]),-1);\n\
  \  assert.deepEqual(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),2);\n  assert.deepEqual(candidate([5,\
  \ 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]),1);\n  assert.deepEqual(candidate([7, 9, 9, 9,\
  \ 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]),1);\n  assert.deepEqual(candidate([3,\
  \ 10, 10, 9, 2]),-1);\n}\n\ntest();"
completions: ["\tlet pos: number[] = [];\n\tfor (let i = 0; i < lst.length; i++) {\n\
    \t\tpos.push(lst[i]);\n\t}\n\tpos.sort(function (a, b) { return a - b });\n\t\
    let last = -1;\n\tlet freq = 0;\n\tfor (let i = 0; i < pos.length; i++) {\n\t\t\
    if (pos[i] === last) {\n\t\t\tfreq += 1;\n\t\t} else {\n\t\t\tlast = pos[i];\n\
    \t\t\tfreq = 1;\n\t\t}\n\t\tif (last >= freq) {\n\t\t\treturn last;\n\t\t}\n\t\
    }\n\treturn -1;\n}", "    let newArr = [];\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        if (lst[i] > 0) {\n            newArr.push(lst[i]);\n      \
    \  }\n    }\n    if (newArr.length < 1) {\n        return -1;\n    }\n    let\
    \ obj: { [key: number]: number } = {};\n    for (let n of newArr) {\n        if\
    \ (obj[n]) {\n            obj[n] += 1;\n        } else {\n            obj[n] =\
    \ 1;\n        }\n    }\n    let max = 0;\n    for (let key in obj) {\n       \
    \ if (obj[key] >= Number(key) && Number(key) > max) {\n            max = Number(key);\n\
    \        }\n    }\n    if (max === 0) {\n        return -1;\n    }\n    return\
    \ max;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2,\
    \ 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\nconsole.log(search([]));\n\
    console.log(search([3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3", "    const numFrequency = new Map<number, number>();\n  \
    \  for (let i = 0; i < lst.length; i++) {\n        const num = lst[i];\n     \
    \   if (numFrequency.has(num)) {\n            const count = numFrequency.get(num);\n\
    \            numFrequency.set(num, count + 1);\n        } else {\n           \
    \ numFrequency.set(num, 1);\n        }\n    }\n    let max = 0;\n    numFrequency.forEach((value,\
    \ key) => {\n        if (key > value && key > max) {\n            max = key;\n\
    \        }\n    });\n    return max || -1;\n}\n", "    let freq = {};\n    for\
    \ (let i = 0; i < lst.length; i++) {\n        let key = lst[i];\n        if (key\
    \ > 0) {\n            if (freq[key]) {\n                freq[key] += 1;\n    \
    \        } else {\n                freq[key] = 1;\n            }\n        }\n\
    \    }\n    let res = -1;\n    for (let key in freq) {\n        if (freq[key]\
    \ >= key) {\n            res = Math.max(key, res);\n        }\n    }\n    return\
    \ res;\n}\n", "    const myMap = new Map<number, number>();\n    for (let i =\
    \ 0; i < lst.length; i++) {\n        const key = lst[i];\n        if (myMap.has(key))\
    \ {\n            myMap.set(key, myMap.get(key) + 1);\n        } else {\n     \
    \       myMap.set(key, 1);\n        }\n    }\n    const sortedKeys = Array.from(myMap.keys()).sort((a,\
    \ b) => {\n        if (myMap.get(a) > myMap.get(b)) {\n            return -1;\n\
    \        } else if (myMap.get(a) < myMap.get(b)) {\n            return 1;\n  \
    \      } else {\n            return a - b;\n        }\n    });\n    const largestKey\
    \ = sortedKeys[0];\n    if (myMap.get(largestKey) >= largestKey) {\n        return\
    \ largestKey;\n    } else {\n        return -1;\n    }\n}\n", "    let max: number\
    \ = -1;\n    let frequency: number = 0;\n    for (let i = 0; i < lst.length; i++)\
    \ {\n        for (let j = 0; j < lst.length; j++) {\n            if (lst[i] ===\
    \ lst[j]) {\n                frequency++;\n            }\n        }\n        if\
    \ (lst[i] > max && frequency >= lst[i]) {\n            max = lst[i];\n       \
    \ }\n        frequency = 0;\n    }\n    return max;\n}\n", "    let table: object\
    \ = {};\n    let result: number = -1;\n    for (let num of lst) {\n        if\
    \ (table[num]) {\n            table[num] += 1;\n        } else {\n           \
    \ table[num] = 1;\n        }\n    }\n    for (let key in table) {\n        if\
    \ (table[key] >= key && table[key] > result) {\n            result = table[key];\n\
    \        }\n    }\n    return result;\n}\n\nconsole.log(search([4, 1, 2, 2, 3,\
    \ 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));\n", "    var result: number = -1;\n    var maxFreq: number =\
    \ 0;\n    var freq: number = 0;\n    lst.sort();\n    for (var i: number = 0;\
    \ i < lst.length; i++) {\n        freq++;\n        if (lst[i] > maxFreq && lst[i]\
    \ >= freq) {\n            maxFreq = freq;\n            result = lst[i];\n    \
    \    }\n        if (lst[i] != lst[i + 1]) {\n            freq = 0;\n        }\n\
    \    }\n    return result;\n}", "    // Write your code here\n    return 0;\n\
    }\n", "  // your code here\n  return -1;\n}\n\n", "    const f: { [key: number]:\
    \ number } = {}\n    for (const k of lst) {\n        if (k in f) f[k] += 1\n \
    \       else f[k] = 1\n    }\n    for (const k of lst) {\n        if (k > 0 &&\
    \ f[k] >= k) return k\n    }\n    return -1\n}\nconsole.log(search([4, 1, 2, 2,\
    \ 3, 1]))\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]))\nconsole.log(search([5,\
    \ 5, 4, 4, 4]))\n", "  if (lst.length === 0) return -1;\n  let uniqueNum = [...new\
    \ Set(lst)];\n  let freq = uniqueNum.map(x => lst.filter(y => y === x).length);\n\
    \  let maxFreq = Math.max(...freq);\n  let out = uniqueNum.filter((x, i) => x\
    \ >= maxFreq && x === freq[i]);\n  return out.length > 0 ? out[0] : -1;\n}\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "  let frequencyMap = new Map();\n  for (let n of lst) {\n\
    \    if (frequencyMap.has(n)) {\n      frequencyMap.set(n, frequencyMap.get(n)\
    \ + 1);\n    } else {\n      frequencyMap.set(n, 1);\n    }\n  }\n  let sorted\
    \ = [...frequencyMap.entries()].sort((a, b) => {\n    return a[0] > b[0] ? 1 :\
    \ -1;\n  });\n  for (let i = sorted.length - 1; i >= 0; i--) {\n    let key =\
    \ sorted[i][0];\n    let value = sorted[i][1];\n    if (key <= value) {\n    \
    \  return key;\n    }\n  }\n  return -1;\n}\n", "  let hash = {};\n  let maxNum\
    \ = -1;\n  for (let n of lst) {\n    if (hash[n]) {\n      hash[n] += 1;\n   \
    \ } else {\n      hash[n] = 1;\n    }\n  }\n  let keys = Object.keys(hash);\n\
    \  for (let i = 0; i < keys.length; i++) {\n    if (hash[keys[i]] >= Number(keys[i])\
    \ && Number(keys[i]) > maxNum) {\n      maxNum = Number(keys[i]);\n    }\n  }\n\
    \  return maxNum;\n}\n", "  let dict: { [key: number]: number } = {};\n  for (let\
    \ i = 0; i < lst.length; i++) {\n    if (dict[lst[i]] === undefined) {\n     \
    \ dict[lst[i]] = 1;\n    } else {\n      dict[lst[i]]++;\n    }\n  }\n  let res:\
    \ number = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (dict[i] !==\
    \ undefined && dict[i] >= i) {\n      res = i;\n    }\n  }\n  return res;\n}\n\
    \nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3,\
    \ 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));", "    let dict: object\
    \ = {};\n    for (let i: number = 0; i < lst.length; i++) {\n        if (dict[lst[i]])\
    \ {\n            dict[lst[i]] += 1;\n        } else {\n            dict[lst[i]]\
    \ = 1;\n        }\n    }\n    let index: number = 1;\n    while (index < lst.length)\
    \ {\n        if (dict[index] >= index) {\n            return index;\n        }\n\
    \        index++;\n    }\n    return -1;\n}\nconsole.log(search([4, 1, 2, 2, 3,\
    \ 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "    // write your code here\n}\n", "    // TODO: Implement\
    \ this function\n    return -1;\n}\n", "    let res: number[] = lst.filter(v =>\
    \ v >= lst.filter(i => i === v).length);\n    return res.length > 0 ? Math.max(...res)\
    \ : -1;\n}\n", "    let sorted = lst.sort((a, b) => a - b);\n    let unique =\
    \ [...new Set(sorted)];\n    let result = 0;\n    let count = 0;\n    for (let\
    \ i = 0; i < unique.length; i++) {\n        if (unique[i] > count) {\n       \
    \     result = unique[i];\n            count = sorted.filter(n => n === unique[i]).length;\n\
    \        }\n    }\n    return result >= count ? result : -1;\n}\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "    let a = [...new Set(lst)];\n    a.sort((a, b) => a - b);\n\
    \    let longest = -1;\n    for (let i = a.length - 1; i >= 0; i--) {\n      \
    \  if (lst.filter(e => e == a[i]).length >= a[i]) {\n            longest = a[i];\n\
    \            break;\n        }\n    }\n    return longest;\n}\n", "  const dic\
    \ = lst.reduce((acc, num) => {\n    acc[num] = (acc[num] || 0) + 1;\n    return\
    \ acc;\n  }, {} as { [key: number]: number });\n  const frequencies = Object.keys(dic).map(num\
    \ => dic[num]);\n  let maxFreq = Math.max(...frequencies);\n  let maxNum = maxFreq;\n\
    \  while (maxNum) {\n    if (maxNum <= maxFreq) {\n      return maxNum;\n    }\n\
    \    maxNum--;\n  }\n  return -1;\n}\n\nexport default search;", "    let freq\
    \ = lst.reduce((acc, val) => {\n        acc[val] = (acc[val] || 0) + 1;\n    \
    \    return acc;\n    }, {});\n    let x = Object.keys(freq).sort((a, b) => a\
    \ - b).find(x => {\n        return parseInt(x) <= freq[x];\n    });\n    return\
    \ x ? parseInt(x) : -1;\n}\n", "    const arr = lst.sort();\n    const numMap\
    \ = new Map<number, number>();\n    let answer = -1;\n    for (let i = 0; i <\
    \ arr.length; i++) {\n        const el = arr[i];\n        if (el >= arr.length)\
    \ return answer;\n        if (numMap.has(el)) {\n            numMap.set(el, numMap.get(el)\
    \ + 1);\n        } else {\n            numMap.set(el, 1);\n        }\n    }\n\
    \    for (let [key, value] of numMap) {\n        if (key <= value) {\n       \
    \     answer = key;\n        }\n    }\n    return answer;\n}\n", "  if (lst.length\
    \ < 1) {\n    return -1;\n  }\n  var count = 1;\n  lst.sort((a, b) => a - b);\n\
    \  for (var i = 1; i < lst.length; i++) {\n    if (lst[i] == lst[i - 1]) {\n \
    \     count++;\n    } else {\n      if (count >= lst[i - 1]) {\n        return\
    \ lst[i - 1];\n      }\n      count = 1;\n    }\n  }\n  return -1;\n}\n", "  let\
    \ countHash: object = {};\n  lst.forEach(n => {\n    if (countHash[n]) {\n   \
    \   countHash[n] += 1;\n    } else {\n      countHash[n] = 1;\n    }\n  });\n\
    \  let keys = Object.keys(countHash);\n  let max = -1;\n  for (let i = 0; i <\
    \ keys.length; i++) {\n    let freq = countHash[keys[i]];\n    if (Number(keys[i])\
    \ <= freq && Number(keys[i]) > max) {\n      max = Number(keys[i]);\n    }\n \
    \ }\n  return max;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\n", "    //\
    \ Create an array to store the frequency of each number\n    let numbers = new\
    \ Array(lst.length);\n    // set each element in the array to 0, then add one\
    \ every time that number appears\n    for (let i = 0; i < lst.length; i++) {\n\
    \        numbers[i] = 0;\n        for (let j = 0; j < lst.length; j++) {\n   \
    \         if (lst[i] == lst[j]) {\n                numbers[i]++;\n           \
    \ }\n        }\n    }\n    // sort the list of numbers\n    let sorted = lst.sort((a,\
    \ b) => a - b);\n    // iterate through the sorted list, looking for the first\
    \ number with a frequency greater than or equal to its value\n    // return that\
    \ number\n    for (let i = 0; i < sorted.length; i++) {\n        if (numbers[i]\
    \ >= sorted[i]) {\n            return sorted[i];\n        }\n    }\n    // if\
    \ there is no such number, return -1\n    return -1;\n}", "    if (lst.length\
    \ === 0) return -1;\n    const counter: number[] = Array(lst.length + 1).fill(0);\n\
    \    lst.forEach(num => counter[num] += 1);\n    for (let i = counter.length -\
    \ 1; i >= 0; i--) {\n        if (counter[i] >= i) return i;\n    }\n    return\
    \ -1;\n}\n", "    let d: { [k: number]: number } = {};\n    let max = -1;\n  \
    \  for (let n of lst) {\n        if (d[n] === undefined) {\n            d[n] =\
    \ 1;\n        } else {\n            d[n] += 1;\n        }\n        if (d[n] >=\
    \ n && n > max) {\n            max = n;\n        }\n    }\n    return max;\n}\n",
  "    const counts = {};\n    lst.forEach(num => {\n        if (counts[num]) counts[num]\
    \ += 1;\n        else counts[num] = 1;\n    });\n    return Object.keys(counts).filter(num\
    \ => parseInt(num) <= counts[num]).sort((a, b) => parseInt(b) - parseInt(a))[0]\
    \ || -1;\n}\n", "    const occurences = {};\n    let max = -1;\n    lst.forEach(num\
    \ => {\n        occurences[num] = occurences[num] ? occurences[num] + 1 : 1;\n\
    \        if (occurences[num] >= num && num > max) {\n            max = num;\n\
    \        }\n    });\n    return max;\n}\n\nconsole.log(search([4, 1, 2, 2, 3,\
    \ 1])); // 2\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4])); // 3\nconsole.log(search([5,\
    \ 5, 4, 4, 4])); // -1", "    let freq: number[] = [], value: number = -1;\n \
    \   lst.sort((a, b) => a - b);\n    for (let i: number = 0; i < lst.length; i++)\
    \ {\n        freq[lst[i]] = (freq[lst[i]] || 0) + 1;\n    }\n    for (let i: number\
    \ = lst.length - 1; i >= 0; i--) {\n        if (freq[lst[i]] >= lst[i]) {\n  \
    \          value = lst[i];\n            break;\n        }\n    }\n    return value;\n\
    }\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3,\
    \ 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\n", "    var str = lst.toString().split(',');\n\
    \    var d = {};\n    for (var i = 0; i < str.length; i++) {\n        if (d[str[i]])\
    \ {\n            d[str[i]]++;\n        } else {\n            d[str[i]] = 1;\n\
    \        }\n    }\n    var max = Math.max.apply(null, str);\n    if (d[max] <\
    \ max) {\n        return -1;\n    }\n    for (var i = max; i > 0; i--) {\n   \
    \     if (d[i] >= i) {\n            return i;\n        }\n    }\n}\n", "  let\
    \ counts: { [s: number]: number } = {};\n  for (let i of lst) {\n    if (counts[i])\
    \ {\n      counts[i]++;\n    } else {\n      counts[i] = 1;\n    }\n  }\n  let\
    \ items = Object.keys(counts);\n  for (let i of items) {\n    if (counts[i] >=\
    \ Number(i)) {\n      return Number(i);\n    }\n  }\n  return -1;\n}\n", "   \
    \ return -1;\n}\n", "    let maxVal = Math.max(...lst);\n    for (let i = maxVal;\
    \ i > 0; i--) {\n        if (lst.filter(val => val === i).length >= i) {\n   \
    \         return i;\n        }\n    }\n    return -1;\n}\n", "  // Your code here...\n\
    \  const freqCount = {};\n  let result;\n  lst.forEach(num => {\n    if (freqCount[num])\
    \ {\n      freqCount[num] += 1;\n    } else {\n      freqCount[num] = 1;\n   \
    \ }\n  });\n  for (let i = lst.length; i > 0; i--) {\n    if (freqCount[i] >=\
    \ i) {\n      result = i;\n      break;\n    }\n  }\n  return result || -1;\n\
    }\nconsole.log(search([5, 5, 4, 4, 4]));\n", "\tlet obj = lst.reduce((o, v) =>\
    \ {\n\t\tif (o[v]) {\n\t\t\to[v]++;\n\t\t} else {\n\t\t\to[v] = 1;\n\t\t}\n\t\t\
    return o;\n\t}, {});\n\tlet arr = Object.keys(obj);\n\tlet max = arr.reduce((a,\
    \ v) => {\n\t\tif (obj[v] >= +v && +v > a) {\n\t\t\treturn +v;\n\t\t} else {\n\
    \t\t\treturn a;\n\t\t}\n\t}, 0);\n\treturn max ? max : -1;\n}\n\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "    const grtrThanZero: number[] = lst.filter(x => x > 0);\n\
    \    const ordered: number[] = grtrThanZero.sort((a, b) => a - b);\n    const\
    \ freq: number[] = ordered.map(x => {\n        return {\n            val: x,\n\
    \            count: ordered.filter(y => y === x).length\n        }\n    }).filter(x\
    \ => x.count >= x.val);\n    if (freq.length > 0) {\n        return freq.sort((a,\
    \ b) => b.count - a.count)[0].val;\n    }\n    return -1;\n}", "\tlet greatest:\
    \ number = -1;\n\tconst counted: { [index: number]: number } = {};\n\tfor (let\
    \ i: number = 0; i < lst.length; i++) {\n\t\tif (lst[i] > greatest) {\n\t\t\t\
    if (counted[lst[i]]) {\n\t\t\t\tcounted[lst[i]]++;\n\t\t\t} else {\n\t\t\t\tcounted[lst[i]]\
    \ = 1;\n\t\t\t}\n\t\t\tif (counted[lst[i]] >= lst[i]) {\n\t\t\t\tgreatest = lst[i];\n\
    \t\t\t}\n\t\t}\n\t}\n\treturn greatest;\n}\n", "\tlet found = new Set<number>();\n\
    \tfor (let x of lst) {\n\t\tif (x > 0) {\n\t\t\tfound.add(x);\n\t\t}\n\t}\n\t\
    let dups = new Set<number>();\n\tfor (let x of lst) {\n\t\tif (found.has(x)) {\n\
    \t\t\tfound.delete(x);\n\t\t\tdups.add(x);\n\t\t}\n\t}\n\tfor (let dup of dups)\
    \ {\n\t\tif (dups.has(dup) && dups.has(dup - 1)) {\n\t\t\tdups.delete(dup);\n\t\
    \t}\n\t}\n\tlet result = -1;\n\tfor (let dup of dups) {\n\t\tif (dup > result)\
    \ {\n\t\t\tresult = dup;\n\t\t}\n\t}\n\treturn result;\n}", "  // YOUR CODE GOES\
    \ HERE\n  let counts = lst.reduce((acc, val) => {\n    if (acc[val]) {\n     \
    \ acc[val] = acc[val] + 1;\n    } else {\n      acc[val] = 1;\n    }\n    return\
    \ acc;\n  }, {});\n  let max: number = 0;\n  for (let i = 1; i < lst.length; i++)\
    \ {\n    if (counts[i] && counts[i] >= i) {\n      max = i;\n    }\n  }\n  return\
    \ max;\n}", "    const freqMap = new Map<number, number>();\n    for (const val\
    \ of lst) {\n        if (freqMap.has(val)) {\n            freqMap.set(val, freqMap.get(val)\
    \ + 1);\n        } else {\n            freqMap.set(val, 1);\n        }\n    }\n\
    \    let res = -1;\n    for (const entry of freqMap.entries()) {\n        if (entry[0]\
    \ <= entry[1] && entry[0] > res) {\n            res = entry[0];\n        }\n \
    \   }\n    return res;\n}\n", "  const numObj = lst.reduce((a, v) => {\n    if\
    \ (a[v]) {\n      a[v] += 1;\n    } else {\n      a[v] = 1;\n    }\n    return\
    \ a;\n  }, {});\n  return Object.keys(numObj).reduce((a, v) => {\n    if (parseInt(v)\
    \ <= numObj[v] && parseInt(v) > a) {\n      return parseInt(v);\n    }\n    return\
    \ a;\n  }, -1);\n}\n\nconsole.log(search([4, 1, 2, 2, 3, 1])); // 2\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4])); // 3\nconsole.log(search([5, 5, 4, 4, 4])); // -1",
  "    let myMap = new Map<number, number>();\n    let output: number[] = [];\n  \
    \  for (let i = 0; i < lst.length; i++) {\n        if (myMap.has(lst[i])) {\n\
    \            myMap.set(lst[i], myMap.get(lst[i]) + 1);\n        } else {\n   \
    \         myMap.set(lst[i], 1);\n        }\n    }\n    for (let n of myMap.keys())\
    \ {\n        if (n <= myMap.get(n)) {\n            output.push(n);\n        }\n\
    \    }\n    if (output.length == 0) {\n        return -1;\n    } else {\n    \
    \    output.sort(function (a, b) { return b - a });\n        return output[0];\n\
    \    }\n}\n", "    const counts = new Map<number, number>();\n    for (const num\
    \ of lst) {\n        if (counts.has(num)) {\n            counts.set(num, counts.get(num)\
    \ + 1);\n        } else {\n            counts.set(num, 1);\n        }\n    }\n\
    \    let max: number = -1;\n    for (const [k, v] of counts) {\n        if (v\
    \ >= k && k > max) {\n            max = k;\n        }\n    }\n    return max;\n\
    }\n", "  let map = new Map();\n  for (let num of lst) {\n    map.set(num, map.has(num)\
    \ ? map.get(num) + 1 : 1);\n  }\n  for (let entry of map) {\n    if (entry[0]\
    \ <= entry[1]) {\n      return entry[0];\n    }\n  }\n  return -1;\n}\n", "  \
    \  // your code here\n    return -1;\n}\n", "    const s: number[] = lst.sort((a,\
    \ b) => a - b);\n    const result: number[] = [];\n    for (let i = 0; i < s.length;\
    \ i++) {\n        if (s[i] === s[i + 1]) {\n            let counter: number =\
    \ 1;\n            for (let j = i + 1; j < s.length; j++) {\n                if\
    \ (s[i] === s[j]) {\n                    counter++;\n                }\n     \
    \       }\n            if (counter >= s[i]) {\n                result.push(s[i]);\n\
    \            }\n        }\n    }\n    if (result.length === 0) {\n        return\
    \ -1;\n    }\n    return Math.max(...result);\n}\n\nconsole.log(search([4, 1,\
    \ 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "    let freq: number[] = [];\n    let max = 0;\n    let max_idx\
    \ = -1;\n    for (let i = 0; i < lst.length; i++) {\n        let e = lst[i];\n\
    \        if (freq[e] === undefined) {\n            freq[e] = 1;\n        } else\
    \ {\n            freq[e]++;\n        }\n        if (freq[e] >= e && e > max) {\n\
    \            max = e;\n            max_idx = i;\n        }\n    }\n    return\
    \ max;\n}\n\n", "  const indexToNum: number[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (indexToNum[lst[i]] === undefined) {\n      indexToNum[lst[i]]\
    \ = 1;\n    } else {\n      indexToNum[lst[i]]++;\n    }\n  }\n  let max = -1;\n\
    \  for (let i = 1; i < indexToNum.length; i++) {\n    if (indexToNum[i] >= i &&\
    \ i > max) {\n      max = i;\n    }\n  }\n  return max;\n}\n\ndescribe(\"search\"\
    , () => {\n  it(\"should work\", () => {\n    expect(search([4, 1, 2, 2, 3, 1])).toBe(2);\n\
    \    expect(search([1, 2, 2, 3, 3, 3, 4, 4, 4])).toBe(3);\n    expect(search([5,\
    \ 5, 4, 4, 4])).toBe(-1);\n  });\n});", "  const freq = {};\n  lst.forEach(x =>\
    \ {\n    if (freq[x]) {\n      freq[x] += 1;\n    } else {\n      freq[x] = 1;\n\
    \    }\n  });\n  return lst.find(x => freq[x] >= x) || -1;\n}\n", "    let freq:\
    \ number[] = new Array(lst.length).fill(0);\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        freq[lst[i]] += 1;\n    }\n    for (let i = lst.length; i >\
    \ 0; i--) {\n        if (freq[i] >= i) {\n            return i;\n        }\n \
    \   }\n    return -1;\n}\n", "  const frequencies = lst.reduce((acc, num) => {\n\
    \    if (!acc[num]) {\n      acc[num] = 1;\n    } else {\n      acc[num]++;\n\
    \    }\n    return acc;\n  }, {});\n  let greatestInt = -1;\n  for (let key in\
    \ frequencies) {\n    if (frequencies[key] >= Number(key) && Number(key) > greatestInt)\
    \ {\n      greatestInt = Number(key);\n    }\n  }\n  return greatestInt;\n}\n",
  "    // Write your code here\n    return -1;\n}", "    return 0;\n}\n", "    let\
    \ frequency = {};\n    let max = 0;\n    for (let i = 0; i < lst.length; i++)\
    \ {\n        let num = lst[i];\n        if (frequency[num] === undefined) {\n\
    \            frequency[num] = 1;\n        } else {\n            frequency[num]++;\n\
    \        }\n        if (frequency[num] >= num && max < num) {\n            max\
    \ = num;\n        }\n    }\n    return max === 0 ? -1 : max;\n}\n\nexport { search\
    \ };", "    return -1;\n}\n\nexport { search }", "    let most_freq = -1;\n  \
    \  let most_freq_ctr = -1;\n    let current_ctr = 0;\n    let current_freq = 0;\n\
    \    lst.sort();\n    console.log(lst);\n    for (let i = 0; i < lst.length; i++)\
    \ {\n        console.log(\"1 current_freq: \" + current_freq + \" | current_ctr:\
    \ \" + current_ctr + \" | most_freq: \" + most_freq + \" | most_freq_ctr: \" +\
    \ most_freq_ctr);\n        if (current_freq == 0) {\n            current_freq\
    \ = lst[i];\n            current_ctr = 1;\n        } else if (current_freq ==\
    \ lst[i]) {\n            current_ctr++;\n        } else {\n            if (current_freq\
    \ >= current_ctr && current_ctr > most_freq_ctr) {\n                most_freq\
    \ = current_freq;\n                most_freq_ctr = current_ctr;\n            }\n\
    \            current_freq = lst[i];\n            current_ctr = 1;\n        }\n\
    \        console.log(\"2 current_freq: \" + current_freq + \" | current_ctr: \"\
    \ + current_ctr + \" | most_freq: \" + most_freq + \" | most_freq_ctr: \" + most_freq_ctr);\n\
    \    }\n    if (current_freq >= current_ctr && current_ctr > most_freq_ctr) {\n\
    \        most_freq = current_freq;\n        most_freq_ctr = current_ctr;\n   \
    \ }\n    return most_freq;\n}\n", "    let numArr: number[] = [];\n    for (let\
    \ i = 0; i < lst.length; i++) {\n        if (lst[i] > 0) {\n            numArr.push(lst[i]);\n\
    \        }\n    }\n    let numObj: { [id: number]: number } = {};\n    numArr.forEach(num\
    \ => {\n        if (numObj[num]) {\n            numObj[num]++;\n        } else\
    \ {\n            numObj[num] = 1;\n        }\n    });\n    let maxFreqKey = 0;\n\
    \    for (let key in numObj) {\n        let value = numObj[key];\n        if (value\
    \ >= +key && value >= numObj[maxFreqKey]) {\n            maxFreqKey = +key;\n\
    \        }\n    }\n    return numObj[maxFreqKey] >= maxFreqKey ? maxFreqKey :\
    \ -1;\n}\n\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2,\
    \ 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));", "  const count\
    \ = lst.reduce((acc, c) => {\n    acc[c] = (acc[c] || 0) + 1;\n    return acc;\n\
    \  }, {} as any);\n  return Object.keys(count)\n    .map(Number)\n    .sort((a,\
    \ b) => a - b)\n    .find(k => k <= count[k]) || -1;\n}\n", "    const numFreq:\
    \ any = {};\n    lst.forEach(num => {\n        if (!numFreq[num]) {\n        \
    \    numFreq[num] = 1;\n        } else {\n            numFreq[num]++;\n      \
    \  }\n    });\n    let res: number[] = [];\n    for (let k in numFreq) {\n   \
    \     if (numFreq[k] >= parseInt(k)) {\n            res.push(parseInt(k));\n \
    \       }\n    }\n    return Math.max(...res) === -Infinity ? -1 : Math.max(...res);\n\
    }", "    let lst_set = new Set(lst);\n    let lst_set_array = Array.from(lst_set);\n\
    \    let lst_set_array_len = lst_set_array.length;\n    let lst_len = lst.length;\n\
    \    let max_value = 0;\n    let max_count = 0;\n    for (let i = 0; i < lst_set_array_len;\
    \ i++) {\n        let count = 0;\n        for (let j = 0; j < lst_len; j++) {\n\
    \            if (lst_set_array[i] === lst[j]) {\n                count++;\n  \
    \          }\n        }\n        if (count >= lst_set_array[i] && count > max_count)\
    \ {\n            max_value = lst_set_array[i];\n            max_count = count;\n\
    \        }\n    }\n    if (max_value === 0) {\n        return -1;\n    }\n   \
    \ return max_value;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));", "  const\
    \ dict = {};\n  for (let num of lst) {\n    if (dict[num]) {\n      dict[num]++;\n\
    \    } else {\n      dict[num] = 1;\n    }\n  }\n  let maxFreq = -1;\n  let maxFreqNum\
    \ = -1;\n  for (let key in dict) {\n    let keyInt = parseInt(key);\n    if (dict[key]\
    \ >= keyInt && dict[key] > maxFreq) {\n      maxFreq = dict[key];\n      maxFreqNum\
    \ = keyInt;\n    }\n  }\n  return maxFreqNum;\n}\n", "  const freq = new Map<number,\
    \ number>();\n  lst.forEach(x => {\n    if (freq.has(x)) {\n      freq.set(x,\
    \ freq.get(x) + 1);\n    } else {\n      freq.set(x, 1);\n    }\n  });\n  const\
    \ freqArray = Array.from(freq.entries()).sort((a, b) => a[0] - b[0]);\n  for (let\
    \ i = 0; i < freqArray.length; i++) {\n    const [key, value] = freqArray[i];\n\
    \    if (key <= value) {\n      return key;\n    }\n  }\n  return -1;\n}\n", " \
    \ if (!lst.length) return -1;\n  const freqMap = lst.reduce((acc, i) => {\n  \
    \  if (acc[i]) {\n      acc[i]++;\n    } else {\n      acc[i] = 1;\n    }\n  \
    \  return acc;\n  }, {});\n  const candidates = Object.keys(freqMap).filter(i\
    \ => i > 0 && i <= freqMap[i]);\n  if (!candidates.length) return -1;\n  return\
    \ Math.max(...candidates);\n}\n", "    let f: FrequencyMap = {};\n    let m: number\
    \ = -1;\n    lst.forEach(x => {\n        if (f[x] === undefined) {\n         \
    \   f[x] = 1;\n        } else {\n            f[x]++;\n        }\n    });\n   \
    \ for (let k in f) {\n        let v: number = Number(k);\n        if (v > m &&\
    \ f[k] >= v) {\n            m = v;\n        }\n    }\n    return m;\n}\n\ntype\
    \ FrequencyMap = { [k: string]: number };", "    let result = {};\n    for (let\
    \ i = 0; i < lst.length; i++) {\n        let key = lst[i];\n        if (result[key])\
    \ {\n            result[key] += 1;\n        } else {\n            result[key]\
    \ = 1;\n        }\n    }\n    for (let key in result) {\n        if (result[key]\
    \ >= key) {\n            return key;\n        }\n    }\n    return -1;\n}\n",
  "  const numMap = {};\n  for (let i = 0; i < lst.length; i++) {\n    const num =\
    \ lst[i];\n    if (numMap[num]) {\n      numMap[num] += 1;\n    } else {\n   \
    \   numMap[num] = 1;\n    }\n  }\n  let result = -1;\n  const keys = Object.keys(numMap);\n\
    \  for (let i = 0; i < keys.length; i++) {\n    const num = keys[i];\n    if (numMap[num]\
    \ >= Number(num)) {\n      result = Number(num);\n    }\n  }\n  return result;\n\
    }\n", "    let search: number = -1;\n    let dict: Map<number, number> = new Map<number,\
    \ number>();\n    lst.forEach(el => {\n        if (dict.has(el)) {\n         \
    \   dict.set(el, dict.get(el) + 1);\n        } else {\n            dict.set(el,\
    \ 1);\n        }\n    });\n    dict.forEach((val, key) => {\n        if (val >=\
    \ key && key > search) {\n            search = key;\n        }\n    });\n    return\
    \ search;\n}", "    var result = -1;\n    var map: { [k: number]: number } = {};\n\
    \    for (var i = 0; i < lst.length; i++) {\n        if (map[lst[i]] === undefined)\
    \ {\n            map[lst[i]] = 1;\n        } else {\n            map[lst[i]] +=\
    \ 1;\n        }\n    }\n    for (var k in map) {\n        var key: number = parseInt(k);\n\
    \        if (key <= map[k] && key > result) {\n            result = key;\n   \
    \     }\n    }\n    return result;\n}\n", "    let dict: { [key: number]: number\
    \ } = {};\n    for (let i of lst) {\n        if (dict[i]) {\n            dict[i]\
    \ += 1;\n        } else {\n            dict[i] = 1;\n        }\n    }\n    let\
    \ max = -1;\n    for (let key in dict) {\n        if (dict[key] >= parseInt(key)\
    \ && max < parseInt(key)) {\n            max = parseInt(key);\n        }\n   \
    \ }\n    return max;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\n", "  let\
    \ count = 1;\n  let max = 0;\n  lst.sort((a, b) => a - b);\n  console.log(lst);\n\
    \  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] === lst[i + 1]) {\n\
    \      count++;\n    } else {\n      if (count >= lst[i]) {\n        if (lst[i]\
    \ > max) {\n          max = lst[i];\n        }\n      }\n      count = 1;\n  \
    \  }\n  }\n  if (max === 0) {\n    return -1;\n  }\n  return max;\n}\n", "   \
    \ return -1;\n}", "    let maxInt = -1;\n    let lst2 = lst.slice();\n    for\
    \ (let i = 0; i < lst.length; i++) {\n        let elem = lst[i];\n        let\
    \ count = 0;\n        for (let j = 0; j < lst2.length; j++) {\n            if\
    \ (lst2[j] === elem) {\n                count++;\n                lst2.splice(j,\
    \ 1);\n                j--;\n            }\n        }\n        if (count >= elem\
    \ && elem > maxInt) {\n            maxInt = elem;\n        }\n    }\n    return\
    \ maxInt;\n}\n\n\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));", "    let\
    \ counts: number[] = [];\n    let max = -1;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        if (counts[lst[i]] === undefined) {\n            counts[lst[i]]\
    \ = 1;\n        } else {\n            counts[lst[i]] += 1;\n        }\n      \
    \  if (lst[i] > max) {\n            max = lst[i];\n        }\n    }\n    let result\
    \ = -1;\n    for (let i = 0; i < max; i++) {\n        if (counts[i] === undefined)\
    \ {\n            continue;\n        }\n        if (counts[i] >= i) {\n       \
    \     result = i;\n        }\n    }\n    return result;\n}\n", "    var dic: {\
    \ [key: number]: number } = {};\n    var highestFreq: number = 0;\n    var highestNum:\
    \ number = 0;\n    for (var i = 0; i < lst.length; i++) {\n        var value =\
    \ lst[i];\n        if (dic[value] != null) {\n            dic[value]++;\n    \
    \    } else {\n            dic[value] = 1;\n        }\n        if (dic[value]\
    \ >= value && dic[value] > highestFreq) {\n            highestFreq = dic[value];\n\
    \            highestNum = value;\n        }\n    }\n    return highestNum;\n}",
  "    let max = Math.max(...lst);\n    if (max == 0) {\n        return -1;\n    }\n\
    \    for (let i = max; i > 0; i--) {\n        let count = 0;\n        for (let\
    \ j = 0; j < lst.length; j++) {\n            if (lst[j] == i) {\n            \
    \    count++;\n            }\n        }\n        if (count >= i) {\n         \
    \   return i;\n        }\n    }\n    return -1;\n}", "  // Write your code here.\n\
    }\n", "    var numbers = {};\n    for (var i = 0; i < lst.length; i++) {\n   \
    \     var number = lst[i];\n        if (numbers[number]) {\n            numbers[number]\
    \ += 1;\n        } else {\n            numbers[number] = 1;\n        }\n    }\n\
    \    var numbersList = Object.keys(numbers).map(k => parseInt(k));\n    var max\
    \ = Math.max(...numbersList);\n    if (numbers[max] < max) {\n        return -1;\n\
    \    }\n    return max;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\n", "    let\
    \ max = Math.max(...lst);\n    let counts = new Array(max + 1).fill(0);\n    for\
    \ (let n of lst) {\n        counts[n]++;\n    }\n    for (let i = max; i > 0;\
    \ i--) {\n        if (counts[i] >= i) return i;\n    }\n    return -1;\n}\n",
  "  const elemFrequency = new Map<number, number>();\n  lst.forEach(x => {\n    const\
    \ freq = elemFrequency.get(x) || 0;\n    elemFrequency.set(x, freq + 1);\n  });\n\
    \  return lst.filter(x => elemFrequency.get(x) >= x).sort((a, b) => b - a)[0]\
    \ || -1;\n}\n", "    let nums: Map<number, number> = new Map();\n    for (let\
    \ num of lst) {\n        if (nums.has(num)) {\n            nums.set(num, nums.get(num)\
    \ + 1);\n        } else {\n            nums.set(num, 1);\n        }\n    }\n \
    \   let result: number = -1;\n    for (let [num, freq] of nums) {\n        if\
    \ (num >= freq && num > result) {\n            result = num;\n        }\n    }\n\
    \    return result;\n}\n", "  // your code here\n  return 0;\n}\n\ntest(\"test\"\
    , () => {\n  expect(search([4, 1, 2, 2, 3, 1])).toBe(2);\n  expect(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4])).toBe(3);\n  expect(search([5, 5, 4, 4, 4])).toBe(-1);\n\
    });", "  // your code here\n  return -1;\n}\n\nconsole.log(search([4, 1, 2, 2,\
    \ 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "    let frequencyMap: Map<number, number> = new Map<number,\
    \ number>();\n    let frequencies: number[] = [];\n    let greatestInt: number\
    \ = -1;\n    lst.forEach(integer => {\n        let frequency: number = frequencyMap.get(integer)\
    \ || 0;\n        frequencyMap.set(integer, frequency + 1);\n        frequencies[integer]\
    \ = frequency + 1;\n    });\n    for (let integer of lst) {\n        if (integer\
    \ === frequencies[integer] && integer > greatestInt) {\n            greatestInt\
    \ = integer;\n        }\n    }\n    return greatestInt;\n}\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));\n", "  let maxNumber = 0;\n  let maxFreq = 0;\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    let freq = 0;\n    for (let j = 0; j < lst.length;\
    \ j++) {\n      if (lst[i] === lst[j]) {\n        freq++;\n      }\n    }\n  \
    \  if (freq >= lst[i] && freq >= maxFreq) {\n      maxNumber = lst[i];\n     \
    \ maxFreq = freq;\n    }\n  }\n  if (maxNumber === 0) {\n    return -1;\n  }\n\
    \  return maxNumber;\n}\n\nconsole.log(search([4, 1, 2, 2, 3, 1])); //2\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4])); //3\nconsole.log(search([5, 5, 4, 4, 4])); //-1\n",
  "  let counter: number[] = new Array(lst.length + 1).fill(0);\n  for (let i = 0;\
    \ i < lst.length; i++) {\n    counter[lst[i]] += 1;\n  }\n  for (let i = lst.length;\
    \ i > 0; i--) {\n    if (counter[i] >= i) {\n      return i;\n    }\n  }\n  return\
    \ -1;\n}", "    const uniqueItems = lst.reduce((acc, val) => {\n        if (val\
    \ in acc) {\n            acc[val] += 1;\n        } else {\n            acc[val]\
    \ = 1;\n        }\n        return acc;\n    }, {});\n    let maxInt = -1;\n  \
    \  Object.keys(uniqueItems).forEach(value => {\n        const intValue = parseInt(value);\n\
    \        if (intValue > maxInt && uniqueItems[value] >= intValue) {\n        \
    \    maxInt = intValue;\n        }\n    });\n    return maxInt;\n}", "    let\
    \ counts: { [key: number]: number } = {};\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        let item = lst[i];\n        if (counts[item] == undefined) counts[item]\
    \ = 0;\n        counts[item]++;\n    }\n    let maxFreq = 0;\n    let maxInt =\
    \ -1;\n    for (let item in counts) {\n        let freq = counts[item];\n    \
    \    let int = parseInt(item);\n        if (freq >= int && freq > maxFreq) {\n\
    \            maxFreq = freq;\n            maxInt = int;\n        }\n    }\n  \
    \  return maxInt;\n}\n", "  let max_num = -1\n  let value = -1\n  let count =\
    \ 0\n\n  for (let i = 0; i < lst.length; i++) {\n    if (lst[i] > max_num) {\n\
    \      max_num = lst[i]\n    }\n  }\n\n  let array_count = new Array(max_num)\n\
    \  array_count.fill(0)\n\n  for (let i = 0; i < lst.length; i++) {\n    array_count[lst[i]\
    \ - 1] += 1\n  }\n\n  for (let i = 0; i < array_count.length; i++) {\n    if (array_count[i]\
    \ >= i + 1) {\n      if (count < array_count[i]) {\n        count = array_count[i]\n\
    \        value = i + 1\n      }\n    }\n  }\n\n  return value\n}", "  let freq\
    \ = {};\n  for (let i of lst) {\n    if (freq[i]) {\n      freq[i] += 1;\n   \
    \ } else {\n      freq[i] = 1;\n    }\n  }\n  let result = -1;\n  for (let i in\
    \ freq) {\n    if (parseInt(i) < freq[i] && parseInt(i) > result) {\n      result\
    \ = parseInt(i);\n    }\n  }\n  return result;\n}\n\nconsole.log(search([4, 1,\
    \ 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));\n", "  let count: object = {};\n  for (let num of lst) {\n  \
    \  if (count[num]) {\n      count[num]++;\n    } else {\n      count[num] = 1;\n\
    \    }\n  }\n  let newArr: number[] = [];\n  for (let key in count) {\n    newArr.push(count[key]);\n\
    \  }\n  newArr.sort((a, b) => b - a);\n  let result: number[] = [];\n  for (let\
    \ key in count) {\n    if (count[key] >= Number(key)) {\n      result.push(Number(key));\n\
    \    }\n  }\n  result.sort((a, b) => b - a);\n  if (result.length < 1) {\n   \
    \ return -1;\n  } else {\n    return result[0];\n  }\n}", "    let ht = {};\n\
    \    let ans: number = -1;\n    for (let x of lst) {\n        if (ht[x]) {\n \
    \           ht[x] += 1;\n        } else {\n            ht[x] = 1;\n        }\n\
    \    }\n    for (let key in ht) {\n        if (parseInt(key) <= ht[key]) {\n \
    \           ans = Math.max(ans, parseInt(key));\n        }\n    }\n    return\
    \ ans;\n}\n", "    if (lst.length === 0) {\n        return -1;\n    }\n    let\
    \ maxValue = -1;\n    let currentFreq = 1;\n    let nextFreq = 1;\n    let count\
    \ = 0;\n    let result = 0;\n    lst.sort((a, b) => a - b);\n    for (let i =\
    \ 0; i < lst.length; i++) {\n        if (lst[i] > maxValue) {\n            maxValue\
    \ = lst[i];\n        }\n        if (lst[i] === lst[i + 1]) {\n            currentFreq\
    \ = nextFreq;\n            nextFreq = currentFreq + 1;\n        } else {\n   \
    \         if (nextFreq >= lst[i]) {\n                count++;\n              \
    \  result = lst[i];\n            }\n            nextFreq = 1;\n        }\n   \
    \ }\n    if (count > 1) {\n        return -1;\n    }\n    if (lst[lst.length -\
    \ 1] > maxValue) {\n        if (nextFreq >= lst[lst.length - 1]) {\n         \
    \   return lst[lst.length - 1];\n        }\n    }\n    return result;\n}\n", " \
    \   let result = -1;\n    for (let i = 1; i <= lst.length; i++) {\n        let\
    \ frequency = lst.filter(x => x === i).length;\n        if (frequency >= i) {\n\
    \            result = i;\n        }\n    }\n    return result;\n}", "  let frequencies:\
    \ Map<number, number> = new Map();\n  lst.forEach(element => {\n    if (frequencies.has(element))\
    \ {\n      frequencies.set(element, frequencies.get(element) + 1);\n    } else\
    \ {\n      frequencies.set(element, 1);\n    }\n  });\n  let frequencySet: Set<number>\
    \ = new Set();\n  frequencies.forEach((value, key) => {\n    if (key <= value)\
    \ {\n      frequencySet.add(key);\n    }\n  });\n  let sortedFrequencyArray: number[]\
    \ = Array.from(frequencySet).sort((a, b) => {\n    return b - a;\n  });\n  if\
    \ (sortedFrequencyArray.length) {\n    return sortedFrequencyArray[0];\n  } else\
    \ {\n    return -1;\n  }\n}\n\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));", "\tlet result\
    \ = -1;\n\tlet freq: [number, number][] = [];\n\tfor (let i = 0; i < lst.length;\
    \ i++) {\n\t\tfreq.push([lst[i], 1]);\n\t\tfor (let j = 0; j < freq.length - 1;\
    \ j++) {\n\t\t\tif (lst[i] === freq[j][0]) {\n\t\t\t\tfreq[j][1]++;\n\t\t\t\t\
    freq.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (let i = 0; i < freq.length;\
    \ i++) {\n\t\tif (freq[i][0] <= freq[i][1]) {\n\t\t\tresult = freq[i][0];\n\t\t\
    }\n\t}\n\treturn result;\n}\n", "  if (lst.length === 0) return -1;\n  // Create\
    \ a map\n  let m = new Map<number, number>();\n  // Iterate through the array\n\
    \  for (let i = 0; i < lst.length; i++) {\n    // If the map contains the element\n\
    \    if (m.has(lst[i])) {\n      // Add 1 to the value\n      m.set(lst[i], m.get(lst[i])\
    \ + 1);\n    } else {\n      // Set the value to 1\n      m.set(lst[i], 1);\n\
    \    }\n  }\n  // Sort the array\n  lst.sort((a, b) => b - a);\n  // Iterate through\
    \ the array\n  for (let i = 0; i < lst.length; i++) {\n    // If the number is\
    \ greater than 0 and the frequency is equal to the value\n    if (lst[i] > 0 &&\
    \ m.get(lst[i]) >= lst[i]) {\n      // Return the number\n      return lst[i];\n\
    \    }\n  }\n  // Otherwise return -1\n  return -1;\n}\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1])); // 2\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4])); //\
    \ 3\nconsole.log(search([5, 5, 4, 4, 4])); // -1\n", "  let counter = 0;\n  let\
    \ obj: any = {};\n  let arr = [];\n  for (let i = 0; i < lst.length; i++) {\n\
    \    if (obj[lst[i]]) {\n      obj[lst[i]]++;\n    } else {\n      obj[lst[i]]\
    \ = 1;\n    }\n  }\n  let objArr = Object.entries(obj);\n  for (let i = 0; i <\
    \ objArr.length; i++) {\n    if (objArr[i][0] <= objArr[i][1]) {\n      arr.push(objArr[i][0]);\n\
    \    }\n  }\n  arr.sort((a, b) => b - a);\n  return arr[0] || -1;\n}\n", "  let\
    \ counts: number[] = new Array(Math.max(...lst) + 1).fill(0);\n  lst.forEach(el\
    \ => counts[el]++);\n  for (let i = counts.length - 1; i >= 0; i--) {\n    if\
    \ (counts[i] >= i) {\n      return i;\n    }\n  }\n  return -1;\n}\n", "    const\
    \ freq = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    let i = 9;\n    while (i > 0) {\n\
    \        if (freq[i] >= i) {\n            return i;\n        }\n        i--;\n\
    \    }\n    return -1;\n}", "    const count = new Map<number, number>();\n  \
    \  let result = -1;\n    for (const num of lst) {\n        if (count.has(num))\
    \ {\n            count.set(num, count.get(num) + 1);\n        } else {\n     \
    \       count.set(num, 1);\n        }\n    }\n    for (const [key, value] of count)\
    \ {\n        if (key <= value && key > result) {\n            result = key;\n\
    \        }\n    }\n    return result;\n}", "    let sortLst = lst.sort((a, b)\
    \ => a - b);\n    console.log(sortLst);\n    let repeat: number[] = [];\n    let\
    \ lstIndex: number[] = [];\n    for (let i = 0; i < sortLst.length; i++) {\n \
    \       let count = 0;\n        for (let j = 0; j < sortLst.length; j++) {\n \
    \           if (sortLst[i] == sortLst[j]) {\n                count++;\n      \
    \      }\n        }\n        if (count == sortLst[i]) {\n            return sortLst[i];\n\
    \        }\n    }\n    return -1;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\n\
    console.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4,\
    \ 4, 4]));\n", "  let index = -1;\n  let max = 0;\n  let counter: number[] = [];\n\
    \  for (let i = 0; i < lst.length; i++) {\n    let num = lst[i];\n    if (num\
    \ >= max) {\n      max = num;\n    }\n    if (counter[num] === undefined) {\n\
    \      counter[num] = 1;\n    } else {\n      counter[num]++;\n    }\n  }\n  for\
    \ (let i = 1; i <= max; i++) {\n    if (counter[i] >= i) {\n      index = i;\n\
    \    }\n  }\n  return index;\n}\n\nconsole.log(search([4, 1, 2, 2, 3, 1])); //\
    \ 2\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4])); // 3\nconsole.log(search([5,\
    \ 5, 4, 4, 4])); // -1", "    let hashTable: Object = {}\n    let output: number\
    \ = -1\n    let max: number = 0\n    for (let i: number = 0; i < lst.length; i++)\
    \ {\n        if (hashTable[lst[i]] == undefined) {\n            hashTable[lst[i]]\
    \ = 1\n        } else {\n            hashTable[lst[i]]++\n        }\n    }\n \
    \   for (let key in hashTable) {\n        if (hashTable[key] >= key && hashTable[key]\
    \ > max) {\n            max = hashTable[key]\n            output = key\n     \
    \   }\n    }\n    return output\n}\n", "    let dict: { [key: number]: number\
    \ } = {};\n    for (let i = 0; i < lst.length; i++) {\n        if (dict[lst[i]])\
    \ {\n            dict[lst[i]] += 1;\n        } else {\n            dict[lst[i]]\
    \ = 1;\n        }\n    }\n    for (let i = 1; i < Object.keys(dict).length; i++)\
    \ {\n        if (dict[i] >= i) {\n            return i;\n        }\n    }\n  \
    \  return -1;\n}\n", "    // check for empty list\n    if (lst.length == 0) return\
    \ -1;\n    // sort list\n    lst.sort();\n    // create dictionary mapping number\
    \ to frequency\n    let numberDict: { [number: number]: number } = {};\n    lst.forEach(number\
    \ => {\n        if (numberDict[number]) {\n            numberDict[number]++;\n\
    \        } else {\n            numberDict[number] = 1;\n        }\n    });\n \
    \   // create list of numbers and their frequencies\n    let numberFreqList: Array<number[]>\
    \ = [];\n    for (let key in numberDict) {\n        numberFreqList.push([parseInt(key),\
    \ numberDict[key]]);\n    }\n    // sort list of numbers and their frequencies\n\
    \    numberFreqList.sort((a, b) => {\n        if (a[0] > b[0]) return 1;\n   \
    \     if (a[0] < b[0]) return -1;\n        return 0;\n    });\n    // find frequency\
    \ which is at least as large as its number\n    for (let i = 0; i < numberFreqList.length;\
    \ i++) {\n        if (numberFreqList[i][1] >= numberFreqList[i][0]) {\n      \
    \      return numberFreqList[i][0];\n        }\n    }\n    // return -1 if no\
    \ such number exists\n    return -1;\n}\n", "    let dic = new Map<number, number>();\n\
    \    for (let i = 0; i < lst.length; i++) {\n        let freq = dic.get(lst[i]);\n\
    \        if (freq === undefined) {\n            dic.set(lst[i], 1);\n        }\
    \ else {\n            dic.set(lst[i], freq + 1);\n        }\n    }\n    let keys\
    \ = Array.from(dic.keys());\n    let maxNum = -1;\n    for (let i = 0; i < keys.length;\
    \ i++) {\n        if (keys[i] > maxNum && keys[i] <= dic.get(keys[i])) {\n   \
    \         maxNum = keys[i];\n        }\n    }\n    return maxNum;\n}\n", "  let\
    \ map = new Map();\n  let newList = [];\n  for (let value of lst) {\n    if (map.has(value))\
    \ {\n      map.set(value, map.get(value) + 1);\n    } else {\n      map.set(value,\
    \ 1);\n    }\n  }\n  let sortedMap = new Map([...map.entries()].sort((a, b) =>\
    \ a[0] - b[0]));\n  for (let [key, value] of sortedMap) {\n    if (key === value)\
    \ {\n      return key;\n    }\n  }\n  return -1;\n}\n", "    let freq: number[]\
    \ = [];\n    let max = 0;\n    let min = 0;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        if (lst[i] > max) max = lst[i];\n        if (lst[i] < min) min\
    \ = lst[i];\n    }\n    for (let i = 0; i < max - min + 1; i++) {\n        freq[i]\
    \ = 0;\n    }\n    for (let i = 0; i < lst.length; i++) {\n        freq[lst[i]\
    \ - min]++;\n    }\n    for (let i = 0; i < max - min + 1; i++) {\n        if\
    \ (freq[i] >= i + min) return i + min;\n    }\n    return -1;\n}\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "    let freqCount: number[] = new Array(lst.length + 1).fill(0);\n\
    \n    for (let i = 0; i < lst.length; i++) {\n        let element = lst[i];\n\
    \        freqCount[element]++;\n    }\n\n    let maxFreq = Math.max(...freqCount);\n\
    \    let maxFreqIndex = freqCount.indexOf(maxFreq);\n\n    if (maxFreqIndex >=\
    \ 1 && maxFreq >= maxFreqIndex)\n        return maxFreqIndex;\n    else\n    \
    \    return -1;\n}\n\n", "  let freq: number[] = [];\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (freq[lst[i]] === undefined) {\n      freq[lst[i]] = 1;\n   \
    \ } else {\n      freq[lst[i]]++;\n    }\n  }\n  for (let i = lst.length - 1;\
    \ i > 0; i--) {\n    if (freq[i] >= i) {\n      return i;\n    }\n  }\n  return\
    \ -1;\n}\n", "    let result: number = -1;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        let number = lst[i];\n        let count = lst.filter(x => x\
    \ === number).length;\n        if (count >= number && number > result) {\n   \
    \         result = number;\n        }\n    }\n    return result;\n}\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));\n", "    let counter = new Map();\n    lst.forEach(val => {\n\
    \        if (!counter.has(val)) {\n            counter.set(val, 1);\n        }\
    \ else {\n            counter.set(val, counter.get(val) + 1);\n        }\n   \
    \ });\n    const keys = Array.from(counter.keys());\n    keys.sort((a, b) => b\
    \ - a);\n    let result = -1;\n    for (let i = 0; i < keys.length; i++) {\n \
    \       const key = keys[i];\n        if (counter.get(key) >= key) {\n       \
    \     result = key;\n            break;\n        }\n    }\n    return result;\n\
    }\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3,\
    \ 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\n", "    let freqDict:\
    \ { [k: number]: number } = {};\n    let res: number = -1;\n    lst.forEach(a\
    \ => {\n        if (freqDict[a]) {\n            freqDict[a]++;\n        } else\
    \ {\n            freqDict[a] = 1;\n        }\n    });\n    for (let key in freqDict)\
    \ {\n        let value = freqDict[key];\n        if (value >= Number(key) && Number(key)\
    \ > res) {\n            res = Number(key);\n        }\n    }\n    return res;\n\
    }\n", "    let map: Map<number, number> = new Map();\n    for (let i = 0; i <\
    \ lst.length; i++) {\n        if (map.has(lst[i])) {\n            map.set(lst[i],\
    \ map.get(lst[i]) + 1);\n        } else {\n            map.set(lst[i], 1);\n \
    \       }\n    }\n    let max = 0;\n    for (let [key, value] of map) {\n    \
    \    if (key <= value && key > max) {\n            max = key;\n        }\n   \
    \ }\n    return max === 0 ? -1 : max;\n}\n", "    let dict: { [key: number]: number\
    \ } = {};\n    for (let num of lst) {\n        if (dict[num]) {\n            dict[num]++;\n\
    \        } else {\n            dict[num] = 1;\n        }\n    }\n    let best:\
    \ number = 0;\n    for (let key in dict) {\n        if (dict[key] >= Number(key)\
    \ && key > best) {\n            best = Number(key);\n        }\n    }\n    return\
    \ best > 0 ? best : -1;\n}\n", "    let max = -1\n    let len = lst.length\n \
    \   let max_count = 0\n    for (let i = 0; i < len; i++) {\n        let count\
    \ = 0\n        for (let j = 0; j < len; j++) {\n            if (lst[i] == lst[j])\
    \ count += 1\n        }\n        if (lst[i] > max_count && count >= lst[i]) {\n\
    \            max = lst[i]\n            max_count = count\n        }\n    }\n \
    \   return max\n}\n", "    const freq = lst.reduce((a, b) => {\n        a[b] =\
    \ (a[b] || 0) + 1;\n        return a;\n    }, {});\n    let res = -1;\n    for\
    \ (let num in freq) {\n        num = parseInt(num);\n        if (num <= freq[num]\
    \ && num > res) {\n            res = num;\n        }\n    }\n    return res;\n\
    }", "    let a = new Set(lst);\n    let b = [...a];\n    let c = b.map(x => [x,\
    \ lst.filter(y => y == x).length])\n    console.log(c);\n    let d = c.filter(x\
    \ => x[0] <= x[1])\n    console.log(d);\n    return d.length == 0 ? -1 : d.sort((a,\
    \ b) => a[1] - b[1])[d.length - 1][0];\n}\n", "    // Your code here\n}\n", " \
    \   // Write your code here\n    return -1;\n}\n\n", "    let max = Math.max(...lst);\n\
    \    let freq = new Array(max + 1).fill(0);\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        freq[lst[i]] += 1;\n    }\n    for (let i = max; i > 0; i--)\
    \ {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n  \
    \  return -1;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));", "    return\
    \ 0;\n}\n", "    const freq = {};\n    let max_freq = 0;\n    for (let i = 0;\
    \ i < lst.length; i++) {\n        if (freq[lst[i]]) {\n            freq[lst[i]]++;\n\
    \        } else {\n            freq[lst[i]] = 1;\n        }\n        if (max_freq\
    \ < freq[lst[i]]) {\n            max_freq = freq[lst[i]];\n        }\n    }\n\
    \    for (let i = max_freq; i > 0; i--) {\n        for (let j = 0; j < lst.length;\
    \ j++) {\n            if (freq[lst[j]] === i && i >= lst[j]) {\n             \
    \   return lst[j];\n            }\n        }\n    }\n    return -1;\n}", "   \
    \ //throw new Error(\"Method not implemented.\");\n    let max = -1;\n    for\
    \ (let i = 0; i < lst.length; i++) {\n        let counter = 0;\n        for (let\
    \ j = 0; j < lst.length; j++) {\n            if (lst[i] == lst[j]) {\n       \
    \         counter++;\n            }\n        }\n        if (counter >= lst[i]\
    \ && max < lst[i]) {\n            max = lst[i];\n        }\n    }\n    return\
    \ max;\n}", "    let freq = {};\n    let max = 0;\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        let current = lst[i];\n        if (freq[current]) {\n      \
    \      freq[current] += 1;\n        } else {\n            freq[current] = 1;\n\
    \        }\n        if (current >= freq[current] && current > max) {\n       \
    \     max = current;\n        }\n    }\n    return max;\n}\n\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "    let obj = {};\n    let highestFrequency = -1;\n    let\
    \ result = -1;\n    for (let i = 0; i < lst.length; i++) {\n        if (obj[lst[i]]\
    \ === undefined) {\n            obj[lst[i]] = 1;\n        } else {\n         \
    \   obj[lst[i]] += 1;\n        }\n    }\n    for (let key in obj) {\n        if\
    \ (obj[key] >= parseInt(key) && obj[key] > highestFrequency) {\n            highestFrequency\
    \ = obj[key];\n            result = parseInt(key);\n        }\n    }\n    return\
    \ result;\n}\n\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\nconsole.log(search([]));",
  "    const freqObj = {};\n    lst.forEach(l => {\n        if (freqObj[l]) {\n  \
    \          freqObj[l]++;\n        } else {\n            freqObj[l] = 1;\n    \
    \    }\n    });\n    const freqLst = Object.keys(freqObj).map(key => {\n     \
    \   return {\n            num: parseInt(key),\n            freq: freqObj[key]\n\
    \        }\n    });\n    const maxFreq = Math.max(...freqLst.map(f => f.freq));\n\
    \    const validValues = freqLst.filter(f => f.freq >= f.num);\n    if (validValues.length\
    \ === 0) {\n        return -1;\n    }\n    const result = validValues.reduce((acc,\
    \ curr) => {\n        if (curr.freq > acc.freq) {\n            return curr;\n\
    \        } else if (curr.freq === acc.freq) {\n            return curr.num > acc.num\
    \ ? curr : acc;\n        } else {\n            return acc;\n        }\n    });\n\
    \    return result.num;\n}\n", "    let maxValue = 0;\n    let maxCount = 0;\n\
    \    let maxNum = 0;\n    for (let i = 0; i < lst.length; i++) {\n        let\
    \ count = 0;\n        for (let j = 0; j < lst.length; j++) {\n            if (lst[i]\
    \ === lst[j]) {\n                count++;\n            }\n        }\n        if\
    \ (count >= lst[i] && count > maxCount) {\n            maxValue = lst[i];\n  \
    \          maxCount = count;\n            maxNum = maxValue;\n        }\n    }\n\
    \    if (maxValue === 0) {\n        return -1;\n    }\n    return maxNum;\n}\n\
    console.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3,\
    \ 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\n", "  let count: number\
    \ = 0;\n  let maxNum: number = 0;\n  let freq: number = 0;\n  for (let i: number\
    \ = 0; i < lst.length; i++) {\n    for (let j: number = 0; j < lst.length; j++)\
    \ {\n      if (lst[i] === lst[j]) {\n        count += 1;\n      }\n    }\n   \
    \ if (count >= lst[i] && lst[i] > maxNum) {\n      maxNum = lst[i];\n      freq\
    \ = count;\n    }\n    count = 0;\n  }\n  if (freq === 0) {\n    return -1;\n\
    \  }\n  return maxNum;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\n", "    const\
    \ dict = {};\n    lst.forEach(val => {\n        if (dict[val]) {\n           \
    \ dict[val] += 1;\n        } else {\n            dict[val] = 1;\n        }\n \
    \   });\n    const max_count = Math.max(...Object.values(dict));\n    const max_count_nums\
    \ = Object.keys(dict).filter(key => dict[key] === max_count);\n    return max_count_nums.some(el\
    \ => el >= max_count) ? parseInt(max_count_nums.join(\"\")) : -1;\n}\n", "   \
    \ const dict = {};\n    let max = 0;\n    let highestKey = -1;\n    for (let i\
    \ = 0; i < lst.length; i++) {\n        if (dict[lst[i]] === undefined) {\n   \
    \         dict[lst[i]] = 1;\n        } else {\n            dict[lst[i]] += 1;\n\
    \        }\n        if (dict[lst[i]] >= lst[i] && lst[i] > max) {\n          \
    \  max = lst[i];\n            highestKey = lst[i];\n        }\n    }\n    return\
    \ highestKey;\n}\n", "    let frequencies: { [key: number]: number } = {};\n \
    \   for (let i = 0; i < lst.length; i++) {\n        if (lst[i] in frequencies)\
    \ {\n            frequencies[lst[i]]++;\n        } else {\n            frequencies[lst[i]]\
    \ = 1;\n        }\n    }\n    let frequencyValues: number[] = Object.values(frequencies);\n\
    \    let frequencyKeys: number[] = Object.keys(frequencies);\n    for (let i =\
    \ frequencyValues.length - 1; i >= 0; i--) {\n        if (frequencyValues[i] >=\
    \ Number(frequencyKeys[i])) {\n            return Number(frequencyKeys[i]);\n\
    \        }\n    }\n    return -1;\n}\n", "  return -1;\n}\n", "\t// Your code\
    \ goes here\n}\n", "    // TODO: Your solution goes here\n    return 0;\n}\n",
  "  let hash: { [key: number]: number } = {};\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (hash[lst[i]]) {\n      hash[lst[i]] += 1;\n    } else {\n  \
    \    hash[lst[i]] = 1;\n    }\n  }\n  let keys = Object.keys(hash);\n  let greatest\
    \ = -1;\n  for (let j = 0; j < keys.length; j++) {\n    if (hash[keys[j]] >= parseInt(keys[j]))\
    \ {\n      if (parseInt(keys[j]) > greatest) {\n        greatest = parseInt(keys[j]);\n\
    \      }\n    }\n  }\n  return greatest;\n}\n", "    if (lst.length === 0) return\
    \ -1;\n    let frequencyDict: { [key: number]: number } = {};\n    for (let item\
    \ of lst) {\n        if (frequencyDict[item]) {\n            frequencyDict[item]++;\n\
    \        } else {\n            frequencyDict[item] = 1;\n        }\n    }\n  \
    \  let answer: number = -1;\n    for (let key in frequencyDict) {\n        if\
    \ (frequencyDict[key] >= parseInt(key) && answer < parseInt(key)) {\n        \
    \    answer = parseInt(key);\n        }\n    }\n    return answer;\n}\n", "  let\
    \ highestVal;\n  let highestValCount = 0;\n  let dictionary = new Map();\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    let count = 0;\n    if (dictionary.has(lst[i]))\
    \ {\n      count = dictionary.get(lst[i]);\n    }\n    dictionary.set(lst[i],\
    \ count + 1);\n    if (count + 1 >= lst[i] && count + 1 > highestValCount) {\n\
    \      highestVal = lst[i];\n      highestValCount = count + 1;\n    }\n  }\n\
    \  return highestVal ? highestVal : -1;\n}\n", "  var pos = lst.indexOf(1)\n \
    \ if (pos === -1) return -1\n  return lst.reduce((a, v, i) => {\n    if (i > pos\
    \ && v > 1 && v >= lst.filter(x => x === v).length) return v\n    return a\n \
    \ }, -1)\n}\n", "    let frequencies: number[] = [];\n    lst.forEach(e => {\n\
    \        if (!frequencies[e]) {\n            frequencies[e] = 1;\n        } else\
    \ {\n            frequencies[e]++;\n        }\n    });\n    for (let i = frequencies.length\
    \ - 1; i > 0; i--) {\n        if (frequencies[i] && frequencies[i] >= i) {\n \
    \           return i;\n        }\n    }\n    return -1;\n}\n", "    const freq\
    \ = new Map<number, number>();\n    for (const i of lst) {\n        freq.set(i,\
    \ (freq.get(i) || 0) + 1);\n    }\n    const a = [...freq.entries()].sort(([i,\
    \ _f], [j, _g]) => j - i);\n    for (const [i, f] of a) {\n        if (i > f)\
    \ {\n            return -1;\n        }\n        if (i === f) {\n            return\
    \ i;\n        }\n    }\n    return -1;\n}\nconsole.log(search([4, 1, 2, 2, 3,\
    \ 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));\n", "    const freq = lst.reduce((a, b) => {\n        a[b] =\
    \ (a[b] || 0) + 1;\n        return a;\n    }, {});\n    const filtered = Object.keys(freq).filter(x\
    \ => {\n        return x <= freq[x];\n    });\n    if (filtered.length > 0) {\n\
    \        return Math.max(...filtered);\n    }\n    return -1;\n}\n", "  const\
    \ counter = new Map<number, number>();\n  let maxNum = -1;\n  for (const num of\
    \ lst) {\n    counter.set(num, (counter.get(num) || 0) + 1);\n    if (counter.get(num)\
    \ >= num && num > maxNum) {\n      maxNum = num;\n    }\n  }\n  return maxNum;\n\
    }\n", "  let frequencyMap = new Map<number, number>();\n  let maxValue = 0;\n\
    \  let maxFrequency = 0;\n  for (let i = 0; i < lst.length; i++) {\n    const\
    \ currentValue = lst[i];\n    if (currentValue > maxValue) {\n      maxValue =\
    \ currentValue;\n    }\n    if (frequencyMap.has(currentValue)) {\n      frequencyMap.set(currentValue,\
    \ frequencyMap.get(currentValue) + 1);\n    } else {\n      frequencyMap.set(currentValue,\
    \ 1);\n    }\n    if (frequencyMap.get(currentValue) > maxFrequency) {\n     \
    \ maxFrequency = frequencyMap.get(currentValue);\n    }\n  }\n  for (let i = maxValue;\
    \ i > 0; i--) {\n    if (frequencyMap.has(i) && frequencyMap.get(i) >= i) {\n\
    \      return i;\n    }\n  }\n  return -1;\n}\n", "    let x = {};\n    for (let\
    \ i of lst) {\n        if (x[i]) {\n            x[i]++;\n        } else {\n  \
    \          x[i] = 1;\n        }\n    }\n    for (let i in x) {\n        if (x[i]\
    \ >= i) {\n            return i;\n        }\n    }\n    return -1;\n}\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));\n", "    let d: { [key: number]: number } = {};\n    for (let\
    \ i of lst) {\n        if (d[i]) {\n            d[i]++;\n        } else {\n  \
    \          d[i] = 1;\n        }\n    }\n    for (let i of lst) {\n        if (d[i]\
    \ >= i) {\n            return i;\n        }\n    }\n    return -1;\n}\n", "  \
    \  let highestFrequency = 0;\n    let highestNumber = 0;\n    const freq = {};\n\
    \    lst.forEach(num => {\n        if (freq[num]) {\n            freq[num]++;\n\
    \        } else {\n            freq[num] = 1;\n        }\n    });\n    const keys\
    \ = Object.keys(freq);\n    for (let i = 0; i < keys.length; i++) {\n        if\
    \ (freq[keys[i]] >= parseInt(keys[i]) && highestFrequency < freq[keys[i]]) {\n\
    \            highestFrequency = freq[keys[i]];\n            highestNumber = parseInt(keys[i]);\n\
    \        }\n    }\n    return highestNumber === 0 ? -1 : highestNumber;\n}\n",
  "  // your code here\n  let s = new Set();\n  let freq = {};\n  let result = -1;\n\
    \  for (let i = 0; i < lst.length; i++) {\n    s.add(lst[i]);\n    if (freq[lst[i]])\
    \ {\n      freq[lst[i]] += 1;\n    } else {\n      freq[lst[i]] = 1;\n    }\n\
    \  }\n  console.log(freq);\n  console.log(s);\n  for (let k of s) {\n    if (freq[k]\
    \ >= k) {\n      if (k > result) {\n        result = k;\n      }\n    }\n  }\n\
    \  return result;\n}", "    let counts: Map<number, number> = new Map();\n   \
    \ for (let i = 0; i < lst.length; i++) {\n        let num = lst[i];\n        let\
    \ count = counts.get(num);\n        if (count === undefined)\n            count\
    \ = 0;\n        counts.set(num, count + 1);\n    }\n    let max: number = -1;\n\
    \    for (let [key, value] of counts) {\n        if (key <= value && key > max)\n\
    \            max = key;\n    }\n    return max;\n}\n", "    // Write your code\
    \ here\n    const count = new Map<number, number>();\n    for (const num of lst)\
    \ {\n        const c = count.get(num) || 0;\n        count.set(num, c + 1);\n\
    \    }\n    let res = -1;\n    for (const [num, c] of count) {\n        if (num\
    \ <= c && num > res) {\n            res = num;\n        }\n    }\n    return res;\n\
    }\n\nexport default search;", "    let result: number = -1;\n    let freqDict:\
    \ { [key: number]: number } = {};\n    for (let item of lst) {\n        if (freqDict[item])\
    \ {\n            freqDict[item]++;\n        } else {\n            freqDict[item]\
    \ = 1;\n        }\n    }\n    for (let key in freqDict) {\n        let value:\
    \ number = Number(key);\n        if (value < freqDict[key] && value > result)\
    \ {\n            result = value;\n        }\n    }\n    return result;\n}\n",
  "  const freq = lst.reduce((m, x) => {\n    if (m[x]) {\n      m[x] += 1;\n    }\
    \ else {\n      m[x] = 1;\n    }\n    return m;\n  }, {});\n  let max = -1;\n\
    \  for (const key in freq) {\n    if (freq[key] >= Number(key) && Number(key)\
    \ > max) {\n      max = Number(key);\n    }\n  }\n  return max;\n}\n", "  const\
    \ obj = {}\n  let highest = 0\n  let greatest = -1\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    if (obj[lst[i]]) {\n      obj[lst[i]]++\n    } else {\n      obj[lst[i]]\
    \ = 1\n    }\n  }\n  for (let j = 0; j < lst.length; j++) {\n    if (obj[lst[j]]\
    \ >= lst[j] && obj[lst[j]] > highest) {\n      highest = obj[lst[j]]\n      greatest\
    \ = lst[j]\n    }\n  }\n  return greatest\n}\n", "    // your code here\n    let\
    \ d: { [key: number]: number } = {};\n    for (let x of lst) {\n        if (d[x])\
    \ {\n            d[x]++;\n        } else {\n            d[x] = 1;\n        }\n\
    \    }\n    let r = -1;\n    let c = -1;\n    for (let key in d) {\n        if\
    \ (d[key] >= parseInt(key) && parseInt(key) > r) {\n            r = parseInt(key);\n\
    \            c = d[key];\n        }\n    }\n    return r;\n}\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));\n", "    let cnt: number[] = [];\n    let n: number = lst.length;\n\
    \    let mx: number = lst[0];\n    for (let i: number = 0; i < n; i++) {\n   \
    \     if (cnt[lst[i]] === undefined) {\n            cnt[lst[i]] = 1;\n       \
    \ } else {\n            cnt[lst[i]] += 1;\n        }\n        if (mx < lst[i])\
    \ {\n            mx = lst[i];\n        }\n    }\n    for (let i: number = mx;\
    \ i >= 1; i--) {\n        if (cnt[i] !== undefined && cnt[i] >= i) {\n       \
    \     return i;\n        }\n    }\n    return -1;\n}", "    let frequencyMap:\
    \ Map<number, number> = new Map();\n    for (let num of lst) {\n        if (frequencyMap.has(num))\
    \ {\n            frequencyMap.set(num, frequencyMap.get(num) + 1);\n        }\
    \ else {\n            frequencyMap.set(num, 1);\n        }\n    }\n    let maxFreq\
    \ = -1;\n    let maxKey = -1;\n    for (let num of lst) {\n        if (frequencyMap.get(num)\
    \ >= num && num > maxFreq) {\n            maxFreq = frequencyMap.get(num);\n \
    \           maxKey = num;\n        }\n    }\n    return maxKey;\n}\n", "    let\
    \ count = 0;\n    let obj = {};\n    let newArr = [];\n    for (let i = 0; i <\
    \ lst.length; i++) {\n        if (obj[lst[i]]) {\n            obj[lst[i]] += 1;\n\
    \        } else {\n            obj[lst[i]] = 1;\n        }\n    }\n    console.log(obj);\n\
    \    for (let key in obj) {\n        newArr.push(obj[key]);\n    }\n    newArr.sort((a,\
    \ b) => b - a);\n    console.log(newArr);\n    count = newArr[0];\n    for (let\
    \ i = 0; i < newArr.length; i++) {\n        if (count === newArr[i]) {\n     \
    \       for (let key in obj) {\n                if (obj[key] === count) {\n  \
    \                  return parseInt(key);\n                }\n            }\n \
    \       }\n    }\n    return -1;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\n\
    console.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4,\
    \ 4, 4]));", "  let max = -1;\n  let count = 0;\n  const dict = {};\n  for (let\
    \ i = 0; i < lst.length; i++) {\n    const num = lst[i];\n    if (dict[num]) {\n\
    \      dict[num] += 1;\n    } else {\n      dict[num] = 1;\n    }\n  }\n  for\
    \ (let key in dict) {\n    if (dict[key] >= key) {\n      if (Number(key) > max)\
    \ {\n        max = Number(key);\n      }\n    }\n  }\n  return max;\n}\n", " \
    \   let numDict: Record<number, number> = {};\n    lst.forEach(element => {\n\
    \        if (numDict[element]) {\n            numDict[element] += 1;\n       \
    \ } else {\n            numDict[element] = 1;\n        }\n    });\n    let max\
    \ = -1;\n    for (const element in numDict) {\n        if (numDict[element] >=\
    \ element && element > max) {\n            max = element;\n        }\n    }\n\
    \    return max;\n}\n", "    let res = -1;\n    let max = lst.length;\n    let\
    \ counts = {};\n    for (let el of lst) {\n        if (el in counts) {\n     \
    \       counts[el]++;\n        } else {\n            counts[el] = 1;\n       \
    \ }\n    }\n    for (let el in counts) {\n        if (parseInt(el) >= counts[el]\
    \ && parseInt(el) < max) {\n            res = parseInt(el);\n            max =\
    \ parseInt(el);\n        }\n    }\n    return res;\n}\n", "  let counts: number[]\
    \ = []\n  let count: number = 0\n  lst.sort(function(a, b){return a - b})\n  for\
    \ (let i = 0; i < lst.length; i++) {\n    if (lst[i] == lst[i - 1]) {\n      count++\n\
    \    } else {\n      counts.push(count)\n      count = 1\n    }\n  }\n  console.log(counts)\n\
    \  for (let i = counts.length - 1; i >= 0; i--) {\n    if (counts[i] >= lst[i])\
    \ {\n      return lst[i]\n    }\n  }\n  return -1\n}\n", "  let r: number = -1;\n\
    \  let occurrences: { [key: number]: number; } = {};\n  lst.forEach(l => occurrences[l]\
    \ = (occurrences[l] || 0) + 1);\n  for (let k in occurrences) {\n    if (+k >=\
    \ occurrences[k] && +k > r) {\n      r = +k;\n    }\n  }\n  return r;\n}\n", " \
    \   const frequency: Map<number, number> = new Map();\n    for (let i = 0; i <\
    \ lst.length; i++) {\n        const curFrequency = (frequency.get(lst[i]) || 0)\
    \ + 1;\n        frequency.set(lst[i], curFrequency);\n    }\n    let result =\
    \ -1;\n    const keys = Array.from(frequency.keys());\n    keys.sort();\n    for\
    \ (let i = keys.length - 1; i >= 0; i--) {\n        if (keys[i] <= frequency.get(keys[i]))\
    \ {\n            result = keys[i];\n            break;\n        }\n    }\n   \
    \ return result;\n}\n", "    const countMap = new Map<number, number>();\n   \
    \ lst.forEach(val => {\n        if (!countMap.has(val)) countMap.set(val, 0);\n\
    \        countMap.set(val, countMap.get(val) + 1);\n    });\n    for (let i =\
    \ lst.length; i > 0; i--) {\n        if (countMap.has(i) && countMap.get(i) >=\
    \ i) {\n            return i;\n        }\n    }\n    return -1;\n}\n", "    const\
    \ counts = {};\n    let max = -1;\n    for (let i = 0; i < lst.length; i++) {\n\
    \        const val = lst[i];\n        if (counts[val]) {\n            counts[val]++;\n\
    \        } else {\n            counts[val] = 1;\n        }\n        if (counts[val]\
    \ >= val && val > max) {\n            max = val;\n        }\n    }\n    return\
    \ max;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2,\
    \ 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));", "    // your\
    \ code here\n}\n", "    let cur = -1;\n    for (let x of lst) {\n        if (lst.filter(y\
    \ => y === x).length >= x) {\n            cur = x;\n        }\n    }\n    return\
    \ cur;\n}\n", "    let max = Math.max(...lst);\n    if (max == -Infinity) return\
    \ -1;\n    let freq = {};\n    lst.forEach(function (i) { freq[i] = (freq[i] ||\
    \ 0) + 1; });\n    if (freq[max] >= max) return max;\n    else return -1;\n}",
  "  const rst: any = {};\n  let max = 0;\n  let maxInt = -1;\n  for (let i = 0; i\
    \ < lst.length; i++) {\n    const temp = lst[i];\n    if (rst[temp]) {\n     \
    \ rst[temp] += 1;\n    } else {\n      rst[temp] = 1;\n    }\n    if (rst[temp]\
    \ >= temp && temp > max) {\n      max = temp;\n      maxInt = temp;\n    }\n \
    \ }\n  return maxInt;\n}\n", "  let lst2 = lst.sort((a, b) => b - a);\n  let dict\
    \ = new Map();\n  for (let i = 0; i < lst2.length; i++) {\n    if (dict.has(lst2[i]))\
    \ {\n      dict.set(lst2[i], dict.get(lst2[i]) + 1);\n    } else {\n      dict.set(lst2[i],\
    \ 1);\n    }\n  }\n  let max = -1;\n  for (let j = 0; j < lst2.length; j++) {\n\
    \    if (lst2[j] > 0 && dict.get(lst2[j]) >= lst2[j]) {\n      max = lst2[j];\n\
    \      break;\n    }\n  }\n  return max;\n}", "    let max: number = lst[0];\n\
    \    for (let i: number = 1; i < lst.length; i++) {\n        if (lst[i] > max)\
    \ {\n            max = lst[i];\n        }\n    }\n    let temp: number[] = new\
    \ Array(max + 1).fill(0);\n    for (let i: number = 0; i < lst.length; i++) {\n\
    \        temp[lst[i]] += 1;\n    }\n    for (let i: number = 1; i < temp.length;\
    \ i++) {\n        if (temp[i] >= i) {\n            return i;\n        }\n    }\n\
    \    return -1;\n}\n", "    if (lst.length == 0) {\n        return -1;\n    }\n\
    \    let max: number = Math.max(...lst);\n    let i: number = 1;\n    while (i\
    \ <= max) {\n        if (lst.filter(l => l == i).length >= i) {\n            return\
    \ i;\n        }\n        i++;\n    }\n    return -1;\n}\n", "  // handle error\
    \ cases\n  if (lst.length < 1) return -1;\n  // initialize map variable to hold\
    \ counts of numbers\n  let counts: Map<number, number> = new Map();\n  // loop\
    \ through the list\n  for (let i = 0; i < lst.length; i++) {\n    let count =\
    \ counts.get(lst[i]);\n    if (count === undefined) {\n      counts.set(lst[i],\
    \ 1);\n    } else {\n      counts.set(lst[i], count + 1);\n    }\n  }\n  // sort\
    \ the map keys\n  let sortedKeys = Array.from(counts.keys()).sort((a, b) => b\
    \ - a);\n  // loop through the map keys\n  for (let i = 0; i < sortedKeys.length;\
    \ i++) {\n    // get the count of the current key\n    let count = counts.get(sortedKeys[i]);\n\
    \    // if the current key is less than the current count, then we have the result\n\
    \    if (sortedKeys[i] <= count) {\n      return sortedKeys[i];\n    }\n  }\n\
    \  // otherwise return -1\n  return -1;\n}\n", "  let counter = {};\n  for (let\
    \ num of lst) {\n    if (counter[num]) {\n      counter[num]++;\n    } else {\n\
    \      counter[num] = 1;\n    }\n  }\n  let result = -1;\n  for (let key in counter)\
    \ {\n    if (parseInt(key) <= counter[key] && result < parseInt(key)) {\n    \
    \  result = parseInt(key);\n    }\n  }\n  return result;\n}\n\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "  let result = -1;\n  const counter = {};\n  for (let i =\
    \ 0; i < lst.length; i++) {\n    if (counter[lst[i]]) {\n      counter[lst[i]]++;\n\
    \    } else {\n      counter[lst[i]] = 1;\n    }\n  }\n  const uniqueNumLst =\
    \ Object.keys(counter);\n  let max = 0;\n  for (let i = 0; i < uniqueNumLst.length;\
    \ i++) {\n    if (Number(uniqueNumLst[i]) > max && counter[uniqueNumLst[i]] >=\
    \ Number(uniqueNumLst[i])) {\n      max = Number(uniqueNumLst[i]);\n      result\
    \ = max;\n    }\n  }\n  return result;\n}\n", "    let dict: any = {};\n    for\
    \ (let i = 0; i < lst.length; i++) {\n        if (dict[lst[i]]) dict[lst[i]]++;\n\
    \        else dict[lst[i]] = 1;\n    }\n    for (let x in dict) {\n        if\
    \ (dict[x] >= x) return parseInt(x);\n    }\n    return -1;\n}\n\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));\n", "  const freqMap = new Map<number, number>();\n  for (const\
    \ num of lst) {\n    const count = freqMap.get(num) || 0;\n    freqMap.set(num,\
    \ count + 1);\n  }\n  let best = 0;\n  let bestVal = -1;\n  for (const [key, val]\
    \ of freqMap) {\n    if (key > val) {\n      continue;\n    }\n    if (key > bestVal)\
    \ {\n      best = val;\n      bestVal = key;\n    }\n  }\n  return bestVal;\n\
    }\n", "  return Math.max(...Object.keys(lst.reduce((acc, cur) => {\n    acc[cur]\
    \ = acc[cur] ? acc[cur] + 1 : 1;\n    return acc;\n  }, {})).filter(k => lst.filter(i\
    \ => i === +k).length >= +k));\n}\n", "  const integers = new Map<number, number>();\n\
    \  for (const el of lst) {\n    const val = integers.get(el);\n    if (val) {\n\
    \      integers.set(el, val + 1);\n    } else {\n      integers.set(el, 1);\n\
    \    }\n  }\n  const max = Math.max(...integers.keys());\n  for (let i = max;\
    \ i > 0; i--) {\n    const val = integers.get(i);\n    if (val && val >= i) {\n\
    \      return i;\n    }\n  }\n  return -1;\n}\n", "  let freq: number[] = [0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0];\n  for (let i: number = 0; i < lst.length; i++)\
    \ {\n    freq[lst[i]]++;\n  }\n  for (let i: number = freq.length - 1; i >= 0;\
    \ i--) {\n    if (freq[i] >= i) {\n      return i;\n    }\n  }\n  return -1;\n\
    }\n", "  let counter: number = 0;\n  let lst2: number[] = [];\n  let result: number\
    \ = -1;\n  lst.sort();\n  for (let i: number = 0; i < lst.length; i++) {\n   \
    \ for (let j: number = 0; j < lst.length; j++) {\n      if (lst[i] === lst[j])\
    \ {\n        counter++;\n      }\n    }\n    if (counter >= lst[i]) {\n      lst2.push(lst[i]);\n\
    \    }\n    counter = 0;\n  }\n  if (lst2.length > 0) {\n    result = lst2[lst2.length\
    \ - 1];\n  }\n  return result;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\n\
    console.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4,\
    \ 4, 4]));\n", "  const freqHash = {}\n  for (let i = 0; i < lst.length; i++)\
    \ {\n    const item = lst[i]\n    if (freqHash[item]) {\n      freqHash[item]++\n\
    \    } else {\n      freqHash[item] = 1\n    }\n  }\n  let max = 0\n  for (let\
    \ item in freqHash) {\n    if (freqHash[item] >= item && item > max) {\n     \
    \ max = item\n    }\n  }\n  return max > 0 ? max : -1\n}\n", "    let freq = {};\n\
    \    let maxFreq = 0;\n    let maxFreqNumber = -1;\n    for (let num of lst) {\n\
    \        if (freq[num] === undefined) {\n            freq[num] = 1;\n        }\
    \ else {\n            freq[num]++;\n        }\n        if (freq[num] >= num &&\
    \ num > maxFreq) {\n            maxFreq = freq[num];\n            maxFreqNumber\
    \ = num;\n        }\n    }\n    return maxFreqNumber;\n}\n", "  let max = -1;\n\
    \  for (let num of lst) {\n    if (num > max && lst.filter(x => x === num).length\
    \ >= num) {\n      max = num;\n    }\n  }\n  return max;\n}", "    const dict\
    \ = {};\n    let res = -1;\n    for (let i = 0; i < lst.length; i++) {\n     \
    \   if (dict[lst[i]]) {\n            dict[lst[i]] += 1;\n        } else {\n  \
    \          dict[lst[i]] = 1;\n        }\n    }\n    for (let key in dict) {\n\
    \        if (parseInt(key) > 0 && dict[key] >= parseInt(key)) {\n            res\
    \ = parseInt(key);\n        }\n    }\n    return res;\n}\n\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "    let counts: number[] = [];\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        counts[lst[i]] = counts[lst[i]] + 1 || 1;\n    }\n    let max\
    \ = -1;\n    for (let i = 1; i < counts.length; i++) {\n        if (counts[i]\
    \ >= i && counts[i] > counts[max]) {\n            max = i;\n        }\n    }\n\
    \    return max;\n}\n", "  let result: number = -1;\n  for (let i = 0; i < lst.length;\
    \ i++) {\n    let count: number = 0;\n    for (let j = 0; j < lst.length; j++)\
    \ {\n      if (lst[i] === lst[j]) {\n        count++;\n      }\n    }\n    if\
    \ (count >= lst[i] && lst[i] > result) {\n      result = lst[i];\n    }\n  }\n\
    \  return result;\n}\n\nconst array: number[] = [5, 5, 4, 4, 4];\nconsole.log(search(array));",
  "    return Math.max(...lst.filter(num => num < lst.length && lst.filter(v => v\
    \ === num).length >= num));\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1,\
    \ 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\n", "    //\
    \ your code goes here\n    var result = null;\n    var dict = new Map();\n   \
    \ var max = null;\n    var maxFreq = 0;\n    for (var i = 0; i < lst.length; i++)\
    \ {\n        var el = lst[i];\n        if (dict.has(el)) {\n            dict.set(el,\
    \ dict.get(el) + 1);\n        } else {\n            dict.set(el, 1);\n       \
    \ }\n        if (el > max) {\n            max = el;\n        }\n    }\n    for\
    \ (var i = max; i > 0; i--) {\n        if (dict.has(i) && dict.get(i) >= i) {\n\
    \            return i;\n        }\n    }\n    return -1;\n}\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));\n", "    if (lst.length === 0) {\n        return -1;\n    }\n\
    \    lst.sort((a, b) => a - b);\n    let index: number = 0;\n    let count: number\
    \ = 1;\n    let max: number = 1;\n    let maxIndex: number = 0;\n    while (index\
    \ < lst.length - 1) {\n        if (lst[index] === lst[index + 1]) {\n        \
    \    count++;\n        } else {\n            if (count > max) {\n            \
    \    max = count;\n                maxIndex = index;\n            }\n        \
    \    count = 1;\n        }\n        index++;\n    }\n    if (count > max) {\n\
    \        max = count;\n        maxIndex = index;\n    }\n    if (max >= lst[maxIndex])\
    \ {\n        return lst[maxIndex];\n    } else {\n        return -1;\n    }\n\
    }\n", "    // your code here\n    let obj = lst.reduce((a,c)=>(a[c]=(a[c]||0)+1,a),{});\n\
    \    //console.log(obj);\n    let max = -1;\n    for(let key in obj){\n      \
    \  if(obj[key]>=key && key>max){\n            max = key;\n        }\n    }\n \
    \   return max;\n}\n", "    let cnt = lst.reduce((x, y) => (x[y] = ++x[y] || 1,\
    \ x), {} as any)\n    return Object.keys(cnt).filter(k => cnt[k] >= k).sort((a,\
    \ b) => b - a)[0] || -1\n}\n", "    return -1;\n}", "    let m = new Map();\n\
    \    let max = 0;\n    for (let i = 0; i < lst.length; i++) {\n        let e =\
    \ lst[i];\n        if (m.has(e)) {\n            m.set(e, m.get(e) + 1);\n    \
    \    } else {\n            m.set(e, 1);\n        }\n        if (e > max) {\n \
    \           max = e;\n        }\n    }\n    if (m.get(max) >= max) {\n       \
    \ return max;\n    }\n    return -1;\n}", "    let numMap = {};\n    for (let\
    \ i = 0; i < lst.length; i++) {\n        if (lst[i] in numMap) {\n           \
    \ numMap[lst[i]]++;\n        } else {\n            numMap[lst[i]] = 1;\n     \
    \   }\n    }\n    let results = [];\n    for (let key in numMap) {\n        let\
    \ num = parseInt(key);\n        if (num > 0 && numMap[key] >= num) {\n       \
    \     results.push(num);\n        }\n    }\n    if (results.length > 0) {\n  \
    \      return Math.max(...results);\n    } else {\n        return -1;\n    }\n\
    }\nconsole.log(search([5, 5, 4, 4, 4]));", "  const lst1 = lst.slice().sort((a,\
    \ b) => a - b);\n  const len = lst1.length;\n  let count = 1;\n  let last = lst1[0];\n\
    \  for (let i = 1; i < len; i++) {\n    if (lst1[i] === last) {\n      count++;\n\
    \    } else {\n      if (count >= last) {\n        return last;\n      }\n   \
    \   last = lst1[i];\n      count = 1;\n    }\n  }\n  return count >= last ? last\
    \ : -1;\n}\n\ndescribe(\"search\", () => {\n  it(\"should work with example 1\"\
    , () => {\n    assert.equal(search([4, 1, 2, 2, 3, 1]), 2);\n  });\n  it(\"should\
    \ work with example 2\", () => {\n    assert.equal(search([1, 2, 2, 3, 3, 3, 4,\
    \ 4, 4]), 3);\n  });\n  it(\"should work with example 3\", () => {\n    assert.equal(search([5,\
    \ 5, 4, 4, 4]), -1);\n  });\n});", "    const freqCount: number[] = Array(lst.length\
    \ + 1).fill(0);\n    for (let i = 0; i < lst.length; i++) {\n        const element\
    \ = lst[i];\n        freqCount[element]++;\n    }\n    for (let i = freqCount.length\
    \ - 1; i >= 0; i--) {\n        if (freqCount[i] >= i) {\n            return i;\n\
    \        }\n    }\n    return -1;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\n\
    console.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4,\
    \ 4, 4]));"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
