name: HumanEval_69_search
language: ts
prompt: "//You are given a non-empty array of positive integers. Return the greatest\
  \ integer that is greater than \n// zero, and has a frequency greater than or equal\
  \ to the value of the integer itself. \n// The frequency of an integer is the number\
  \ of times it appears in the array.\n// If no such a value exist, return -1.\n//\
  \ Examples:\n// >>> search([4, 1, 2, 2, 3, 1])\n// 2\n// >>> search([1, 2, 2, 3,\
  \ 3, 3, 4, 4, 4])\n// 3\n// >>> search([5, 5, 4, 4, 4])\n// -1\nfunction search(lst:\
  \ number[]): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = search;\n  assert.deepEqual(candidate([5, 5, 5, 5,\
  \ 1]),1);\n  assert.deepEqual(candidate([4, 1, 4, 1, 4, 4]),4);\n  assert.deepEqual(candidate([3,\
  \ 3]),-1);\n  assert.deepEqual(candidate([8, 8, 8, 8, 8, 8, 8, 8]),8);\n  assert.deepEqual(candidate([2,\
  \ 3, 3, 2, 2]),2);\n  assert.deepEqual(candidate([2, 7, 8, 8, 4, 8, 7, 3, 9, 6,\
  \ 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1]),1);\n  assert.deepEqual(candidate([3, 2,\
  \ 8, 2]),2);\n  assert.deepEqual(candidate([6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10]),1);\n\
  \  assert.deepEqual(candidate([8, 8, 3, 6, 5, 6, 4]),-1);\n  assert.deepEqual(candidate([6,\
  \ 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9]),1);\n\
  \  assert.deepEqual(candidate([1, 9, 10, 1, 3]),1);\n  assert.deepEqual(candidate([6,\
  \ 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10]),5);\n\
  \  assert.deepEqual(candidate([1]),1);\n  assert.deepEqual(candidate([8, 8, 10,\
  \ 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5]),4);\n  assert.deepEqual(candidate([2,\
  \ 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10]),2);\n  assert.deepEqual(candidate([1,\
  \ 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3]),1);\n  assert.deepEqual(candidate([9, 2, 4,\
  \ 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10,\
  \ 9, 4]),4);\n  assert.deepEqual(candidate([2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6,\
  \ 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7]),4);\n  assert.deepEqual(candidate([9, 8, 6,\
  \ 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1]),2);\n  assert.deepEqual(candidate([5,\
  \ 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8]),-1);\n  assert.deepEqual(candidate([10]),-1);\n\
  \  assert.deepEqual(candidate([9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2]),2);\n  assert.deepEqual(candidate([5,\
  \ 4, 10, 2, 1, 1, 10, 3, 6, 1, 8]),1);\n  assert.deepEqual(candidate([7, 9, 9, 9,\
  \ 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6]),1);\n  assert.deepEqual(candidate([3,\
  \ 10, 10, 9, 2]),-1);\n}\n\ntest();"
completions: ["\tlet pos: number[] = [];\n\tfor (let i = 0; i < lst.length; i++) {\n\
    \t\tpos.push(lst[i]);\n\t}\n\tpos.sort(function (a, b) { return a - b });\n\t\
    let last = -1;\n\tlet freq = 0;\n\tfor (let i = 0; i < pos.length; i++) {\n\t\t\
    if (pos[i] === last) {\n\t\t\tfreq += 1;\n\t\t} else {\n\t\t\tlast = pos[i];\n\
    \t\t\tfreq = 1;\n\t\t}\n\t\tif (last >= freq) {\n\t\t\treturn last;\n\t\t}\n\t\
    }\n\treturn -1;\n}", "    let newArr = [];\n    for (let i = 0; i < lst.length;\
    \ i++) {\n        if (lst[i] > 0) {\n            newArr.push(lst[i]);\n      \
    \  }\n    }\n    if (newArr.length < 1) {\n        return -1;\n    }\n    let\
    \ obj: { [key: number]: number } = {};\n    for (let n of newArr) {\n        if\
    \ (obj[n]) {\n            obj[n] += 1;\n        } else {\n            obj[n] =\
    \ 1;\n        }\n    }\n    let max = 0;\n    for (let key in obj) {\n       \
    \ if (obj[key] >= Number(key) && Number(key) > max) {\n            max = Number(key);\n\
    \        }\n    }\n    if (max === 0) {\n        return -1;\n    }\n    return\
    \ max;\n}\nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2,\
    \ 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));\nconsole.log(search([]));\n\
    console.log(search([3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3, 3, 3", "    const numFrequency = new Map<number, number>();\n  \
    \  for (let i = 0; i < lst.length; i++) {\n        const num = lst[i];\n     \
    \   if (numFrequency.has(num)) {\n            const count = numFrequency.get(num);\n\
    \            numFrequency.set(num, count + 1);\n        } else {\n           \
    \ numFrequency.set(num, 1);\n        }\n    }\n    let max = 0;\n    numFrequency.forEach((value,\
    \ key) => {\n        if (key > value && key > max) {\n            max = key;\n\
    \        }\n    });\n    return max || -1;\n}\n", "    let freq = {};\n    for\
    \ (let i = 0; i < lst.length; i++) {\n        let key = lst[i];\n        if (key\
    \ > 0) {\n            if (freq[key]) {\n                freq[key] += 1;\n    \
    \        } else {\n                freq[key] = 1;\n            }\n        }\n\
    \    }\n    let res = -1;\n    for (let key in freq) {\n        if (freq[key]\
    \ >= key) {\n            res = Math.max(key, res);\n        }\n    }\n    return\
    \ res;\n}\n", "    const myMap = new Map<number, number>();\n    for (let i =\
    \ 0; i < lst.length; i++) {\n        const key = lst[i];\n        if (myMap.has(key))\
    \ {\n            myMap.set(key, myMap.get(key) + 1);\n        } else {\n     \
    \       myMap.set(key, 1);\n        }\n    }\n    const sortedKeys = Array.from(myMap.keys()).sort((a,\
    \ b) => {\n        if (myMap.get(a) > myMap.get(b)) {\n            return -1;\n\
    \        } else if (myMap.get(a) < myMap.get(b)) {\n            return 1;\n  \
    \      } else {\n            return a - b;\n        }\n    });\n    const largestKey\
    \ = sortedKeys[0];\n    if (myMap.get(largestKey) >= largestKey) {\n        return\
    \ largestKey;\n    } else {\n        return -1;\n    }\n}\n", "    let max: number\
    \ = -1;\n    let frequency: number = 0;\n    for (let i = 0; i < lst.length; i++)\
    \ {\n        for (let j = 0; j < lst.length; j++) {\n            if (lst[i] ===\
    \ lst[j]) {\n                frequency++;\n            }\n        }\n        if\
    \ (lst[i] > max && frequency >= lst[i]) {\n            max = lst[i];\n       \
    \ }\n        frequency = 0;\n    }\n    return max;\n}\n", "    let table: object\
    \ = {};\n    let result: number = -1;\n    for (let num of lst) {\n        if\
    \ (table[num]) {\n            table[num] += 1;\n        } else {\n           \
    \ table[num] = 1;\n        }\n    }\n    for (let key in table) {\n        if\
    \ (table[key] >= key && table[key] > result) {\n            result = table[key];\n\
    \        }\n    }\n    return result;\n}\n\nconsole.log(search([4, 1, 2, 2, 3,\
    \ 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));\n", "    var result: number = -1;\n    var maxFreq: number =\
    \ 0;\n    var freq: number = 0;\n    lst.sort();\n    for (var i: number = 0;\
    \ i < lst.length; i++) {\n        freq++;\n        if (lst[i] > maxFreq && lst[i]\
    \ >= freq) {\n            maxFreq = freq;\n            result = lst[i];\n    \
    \    }\n        if (lst[i] != lst[i + 1]) {\n            freq = 0;\n        }\n\
    \    }\n    return result;\n}", "    // Write your code here\n    return 0;\n\
    }\n", "  // your code here\n  return -1;\n}\n\n", "    const f: { [key: number]:\
    \ number } = {}\n    for (const k of lst) {\n        if (k in f) f[k] += 1\n \
    \       else f[k] = 1\n    }\n    for (const k of lst) {\n        if (k > 0 &&\
    \ f[k] >= k) return k\n    }\n    return -1\n}\nconsole.log(search([4, 1, 2, 2,\
    \ 3, 1]))\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]))\nconsole.log(search([5,\
    \ 5, 4, 4, 4]))\n", "  if (lst.length === 0) return -1;\n  let uniqueNum = [...new\
    \ Set(lst)];\n  let freq = uniqueNum.map(x => lst.filter(y => y === x).length);\n\
    \  let maxFreq = Math.max(...freq);\n  let out = uniqueNum.filter((x, i) => x\
    \ >= maxFreq && x === freq[i]);\n  return out.length > 0 ? out[0] : -1;\n}\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "  let frequencyMap = new Map();\n  for (let n of lst) {\n\
    \    if (frequencyMap.has(n)) {\n      frequencyMap.set(n, frequencyMap.get(n)\
    \ + 1);\n    } else {\n      frequencyMap.set(n, 1);\n    }\n  }\n  let sorted\
    \ = [...frequencyMap.entries()].sort((a, b) => {\n    return a[0] > b[0] ? 1 :\
    \ -1;\n  });\n  for (let i = sorted.length - 1; i >= 0; i--) {\n    let key =\
    \ sorted[i][0];\n    let value = sorted[i][1];\n    if (key <= value) {\n    \
    \  return key;\n    }\n  }\n  return -1;\n}\n", "  let hash = {};\n  let maxNum\
    \ = -1;\n  for (let n of lst) {\n    if (hash[n]) {\n      hash[n] += 1;\n   \
    \ } else {\n      hash[n] = 1;\n    }\n  }\n  let keys = Object.keys(hash);\n\
    \  for (let i = 0; i < keys.length; i++) {\n    if (hash[keys[i]] >= Number(keys[i])\
    \ && Number(keys[i]) > maxNum) {\n      maxNum = Number(keys[i]);\n    }\n  }\n\
    \  return maxNum;\n}\n", "  let dict: { [key: number]: number } = {};\n  for (let\
    \ i = 0; i < lst.length; i++) {\n    if (dict[lst[i]] === undefined) {\n     \
    \ dict[lst[i]] = 1;\n    } else {\n      dict[lst[i]]++;\n    }\n  }\n  let res:\
    \ number = -1;\n  for (let i = 1; i < lst.length; i++) {\n    if (dict[i] !==\
    \ undefined && dict[i] >= i) {\n      res = i;\n    }\n  }\n  return res;\n}\n\
    \nconsole.log(search([4, 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3,\
    \ 3, 4, 4, 4]));\nconsole.log(search([5, 5, 4, 4, 4]));", "    let dict: object\
    \ = {};\n    for (let i: number = 0; i < lst.length; i++) {\n        if (dict[lst[i]])\
    \ {\n            dict[lst[i]] += 1;\n        } else {\n            dict[lst[i]]\
    \ = 1;\n        }\n    }\n    let index: number = 1;\n    while (index < lst.length)\
    \ {\n        if (dict[index] >= index) {\n            return index;\n        }\n\
    \        index++;\n    }\n    return -1;\n}\nconsole.log(search([4, 1, 2, 2, 3,\
    \ 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));", "    // write your code here\n}\n", "    // TODO: Implement\
    \ this function\n    return -1;\n}\n", "    let res: number[] = lst.filter(v =>\
    \ v >= lst.filter(i => i === v).length);\n    return res.length > 0 ? Math.max(...res)\
    \ : -1;\n}\n", "    let sorted = lst.sort((a, b) => a - b);\n    let unique =\
    \ [...new Set(sorted)];\n    let result = 0;\n    let count = 0;\n    for (let\
    \ i = 0; i < unique.length; i++) {\n        if (unique[i] > count) {\n       \
    \     result = unique[i];\n            count = sorted.filter(n => n === unique[i]).length;\n\
    \        }\n    }\n    return result >= count ? result : -1;\n}\nconsole.log(search([4,\
    \ 1, 2, 2, 3, 1]));\nconsole.log(search([1, 2, 2, 3, 3, 3, 4, 4, 4]));\nconsole.log(search([5,\
    \ 5, 4, 4, 4]));"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
