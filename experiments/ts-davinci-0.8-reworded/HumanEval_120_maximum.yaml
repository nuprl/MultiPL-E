name: HumanEval_120_maximum
language: ts
prompt: "//Given an array arr of integers and a positive integer k, return a sorted\
  \ array \n// of length k with the maximum k numbers in arr.\n// Example 1:\n// >>>\
  \ maximum([-3, -4, 5], 3)\n// [-4, -3, 5]\n// Example 2:\n// >>> maximum([4, -4,\
  \ 4], 2)\n// [4, 4]\n// Example 3:\n// >>> maximum([-3, 2, 1, 2, -1, -2, 1], 1)\n\
  // [2]\n// Note:\n// 1. The length of the array will be in the range of [1, 1000].\n\
  // 2. The elements in the array will be in the range of [-1000, 1000].\n// 3. 0\
  \ <= k <= len(arr)\nfunction maximum(arr: number[], k: number): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = maximum;\n  assert.deepEqual(candidate([-3, -4, 5],\
  \ 3),[-4, -3, 5]);\n  assert.deepEqual(candidate([4, -4, 4], 2),[4, 4]);\n  assert.deepEqual(candidate([-3,\
  \ 2, 1, 2, -1, -2, 1], 1),[2]);\n  assert.deepEqual(candidate([123, -123, 20, 0,\
  \ 1, 2, -3], 3),[2, 20, 123]);\n  assert.deepEqual(candidate([-123, 20, 0, 1, 2,\
  \ -3], 4),[0, 1, 2, 20]);\n  assert.deepEqual(candidate([5, 15, 0, 3, -13, -8, 0],\
  \ 7),[-13, -8, 0, 0, 3, 5, 15]);\n  assert.deepEqual(candidate([-1, 0, 2, 5, 3,\
  \ -10], 2),[3, 5]);\n  assert.deepEqual(candidate([1, 0, 5, -7], 1),[5]);\n  assert.deepEqual(candidate([4,\
  \ -4], 2),[-4, 4]);\n  assert.deepEqual(candidate([-10, 10], 2),[-10, 10]);\n  assert.deepEqual(candidate([1,\
  \ 2, 3, -23, 243, -400, 0], 0),[]);\n}\n\ntest();"
completions: ["  let result: number[] = arr.sort((a, b) => b - a);\n  return result.slice(0,\
    \ k);\n}\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4,\
    \ 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "    let result:\
    \ number[] = [];\n    while (k > 0) {\n        k--;\n        let max = arr[0];\n\
    \        let maxIndex = 0;\n        for (let i = 1; i < arr.length; i++) {\n \
    \           if (arr[i] > max) {\n                max = arr[i];\n             \
    \   maxIndex = i;\n            }\n        }\n        result.push(max);\n     \
    \   arr.splice(maxIndex, 1);\n    }\n    return result;\n}\n", "  return [...new\
    \ Set(arr.sort((a, b) => b - a).slice(0, k))];\n}\n", "  let maxHeap = new MaxHeap();\n\
    \  for (let i = 0; i < arr.length; i++) {\n    maxHeap.insert(arr[i]);\n  }\n\
    \  let maxArr = [];\n  for (let i = 0; i < k; i++) {\n    maxArr.push(maxHeap.remove());\n\
    \  }\n  return maxArr;\n}\n\nexport default maximum;", "    return [];\n}\n\n\
    export { maximum };", "    let filtered = arr.filter(num => num > 0);\n    let\
    \ sorted = filtered.sort((a, b) => a - b);\n    return sorted.slice(sorted.length\
    \ - k);\n}\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4,\
    \ 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  // Your code\
    \ here\n}\n", "  // const sorted = arr.sort((a, b) => b - a)\n  // return sorted.slice(0,\
    \ k)\n  const arr_length = arr.length\n  if (arr_length < k) {\n    return arr\n\
    \  }\n  let p1 = 0\n  let p2 = k\n  while (p2 < arr_length) {\n    if (arr[p1]\
    \ <= arr[p2]) {\n      p1 += 1\n      p2 += 1\n    } else {\n      arr.splice(p1,\
    \ 1)\n      p2 += 1\n    }\n  }\n  return arr\n}\n\nexport default maximum", " \
    \   if (k === 0) {\n        return [];\n    }\n    if (k >= arr.length) {\n  \
    \      return arr.sort((a, b) => b - a);\n    }\n    return arr.sort((a, b) =>\
    \ b - a).slice(0, k);\n}\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4,\
    \ -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  // Write\
    \ your code here\n  if (k === arr.length) {\n    return arr;\n  }\n\n  const result:\
    \ number[] = [];\n  const map: { [key: number]: number } = {};\n\n  for (let i\
    \ = 0; i < arr.length; i++) {\n    map[arr[i]] = (map[arr[i]] || 0) + 1;\n  }\n\
    \n  const sorted = Object.keys(map).sort((a, b) => Number(b) - Number(a));\n\n\
    \  for (let i = 0; i < k; i++) {\n    const count = map[sorted[i]];\n    for (let\
    \ j = 0; j < count; j++) {\n      result.push(Number(sorted[i]));\n    }\n  }\n\
    \n  return result;\n}\n\nexport { maximum };", "    if (k === 0) {\n        return\
    \ [];\n    }\n    if (k === arr.length) {\n        return arr;\n    }\n    return\
    \ arr.sort((a, b) => b - a).slice(0, k);\n}\n", "  if (k === 0) return [];\n \
    \ if (k >= arr.length) return arr.sort((a, b) => b - a);\n  return arr.sort((a,\
    \ b) => b - a).slice(0, k);\n}\n", "  const length = arr.length;\n  if (k ===\
    \ length) {\n    return arr;\n  }\n  const result = [];\n  const max = length\
    \ - k;\n  for (let i = 0; i < length; i++) {\n    const val = arr[i];\n    if\
    \ (result.length < k) {\n      const idx = findFirstLarger(result, val);\n   \
    \   if (idx !== -1) {\n        result.splice(idx, 0, val);\n      } else {\n \
    \       result.push(val);\n      }\n    } else {\n      if (result[max] < val)\
    \ {\n        const idx = findFirstLarger(result, val);\n        if (idx !== -1)\
    \ {\n          result.splice(idx, 0, val);\n          result.pop();\n        }\n\
    \      }\n    }\n  }\n  return result;\n}\n", "  if (k <= 0) return [];\n  let\
    \ heap = new MaxHeap();\n  arr.forEach(element => {\n    heap.insert(element);\n\
    \  });\n  let result = [];\n  while (k > 0) {\n    let remove = heap.remove();\n\
    \    result.push(remove);\n    k--;\n  }\n  return result;\n}\n", "    // so we\
    \ want to sort the array and pull out the first k elements\n\n    // Return the\
    \ sorted array of length k\n    return arr.sort((a, b) => a - b).slice(0, k);\n\
    }\n", "  let result: number[] = [];\n  let temp: number[] = [];\n  for (let i:\
    \ number = 0; i < arr.length; i++) {\n    if (result.length < k) {\n      result.push(arr[i]);\n\
    \    } else {\n      result.sort(function (a, b) {\n        return a - b;\n  \
    \    });\n      if (arr[i] > result[0]) {\n        result.shift();\n        result.push(arr[i]);\n\
    \      }\n    }\n  }\n  result.sort(function (a, b) {\n    return a - b;\n  });\n\
    \  return result;\n}\n\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));\nconsole.log(maximum([-3, -4, 5], 3));", "  return\
    \ arr.sort((a, b) => b - a).slice(0, k);\n}\n\ndescribe(\"Test maximum array\"\
    , () => {\n  it(\"Test: [-3, -4, 5], 3\", () => {\n    expect(maximum([-3, -4,\
    \ 5], 3)).toStrictEqual([-4, -3, 5]);\n  });\n  it(\"Test: [4, -4, 4], 2\", ()\
    \ => {\n    expect(maximum([4, -4, 4], 2)).toStrictEqual([4, 4]);\n  });\n  it(\"\
    Test: [-3, 2, 1, 2, -1, -2, 1], 1\", () => {\n    expect(maximum([-3, 2, 1, 2,\
    \ -1, -2, 1], 1)).toStrictEqual([2]);\n  });\n});", "  // Fast path: if k is greater\
    \ than length of arr, just return arr sorted\n  if (k >= arr.length) {\n    return\
    \ arr.sort((a, b) => a - b);\n  }\n\n  // Slower path, for the case where k is\
    \ less than the length of arr\n  // Create a max heap using Heap.js from this\
    \ repo\n  const heap = new Heap<number>((a, b) => b - a);\n\n  // Insert the first\
    \ k elements\n  for (let i = 0; i < k; i++) {\n    heap.push(arr[i]);\n  }\n\n\
    \  // Iterate over the rest of the array, comparing each element to the smallest\n\
    \  // value of the heap\n  for (let i = k; i < arr.length; i++) {\n    if (arr[i]\
    \ > heap.peek()) {\n      heap.pop();\n      heap.push(arr[i]);\n    }\n  }\n\n\
    \  // Return the heap as an array\n  return heap.toArray();\n}\n", "    if (k\
    \ === 0) {\n        return [];\n    }\n\n    if (k === arr.length) {\n       \
    \ return arr;\n    }\n\n    return arr.sort((a, b) => a - b).slice(arr.length\
    \ - k);\n}\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4,\
    \ 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  const maxNumber\
    \ = arr.splice(arr.indexOf(Math.max(...arr)), 1);\n  const minNumber = arr.splice(arr.indexOf(Math.min(...arr)),\
    \ 1);\n  return maxNumber.concat(minNumber);\n}\n\nconsole.log(maximum([-3, -4,\
    \ 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3, 2,\
    \ 1, 2, -1, -2, 1], 1));", "  let num = 0;\n  let ans = [];\n  for (let i = 0;\
    \ i < arr.length; i++) {\n    if (arr[i] > num) {\n      num = arr[i];\n     \
    \ console.log(num);\n      ans.push(num);\n    }\n  }\n  ans.sort();\n  return\
    \ ans.slice(ans.length - k);\n}\n", "    if (k > arr.length) {\n        throw\
    \ new Error('k cannot be greater than the array length');\n    }\n    const result:\
    \ number[] = arr.sort((a, b) => b - a).slice(0, k);\n    return result;\n}\n",
  "    if (k > arr.length) {\n        throw new Error('The length of array can not\
    \ be smaller than k');\n    }\n\n    return [...arr].sort((a, b) => b - a).slice(0,\
    \ k);\n}\n\n(function() {\n    const result = maximum([4, -4, 4], 2);\n    console.log(result);\n\
    })();", "  if (k === 0) return [];\n  if (k >= arr.length) return arr.sort((a,\
    \ b) => b - a);\n  let max = [];\n  for (let i = 0; i < k; i++) {\n    let maxNum\
    \ = Math.max(...arr);\n    max.push(maxNum);\n    arr.splice(arr.indexOf(maxNum),\
    \ 1);\n  }\n  return max;\n}\n", "    // YOUR CODE GOES HERE\n    arr.sort((a,\
    \ b) => b - a);\n    return arr.slice(0, k);\n}\n", "    let res: number[] = [];\n\
    \    // let first = 0;\n    // let last = arr.length - 1;\n    // while (first\
    \ < last) {\n    //     let temp = arr[first];\n    //     arr[first] = arr[last];\n\
    \    //     arr[last] = temp;\n    //     first++;\n    //     last--;\n    //\
    \ }\n    for (let i = 0; i < k; i++) {\n        let idx = 0;\n        for (let\
    \ j = 0; j < arr.length; j++) {\n            if (arr[j] > arr[idx]) {\n      \
    \          idx = j;\n            }\n        }\n        res.push(arr[idx]);\n \
    \       arr.splice(idx, 1);\n    }\n    return res;\n}\n", "  const result: number[]\
    \ = [];\n  const quickSort = (start: number, end: number) => {\n    if (start\
    \ >= end) return;\n    let pivot = start;\n    let left = start + 1;\n    let\
    \ right = end;\n    while (left <= right) {\n      while (left <= end && arr[left]\
    \ >= arr[pivot]) left++;\n      while (right > start && arr[right] <= arr[pivot])\
    \ right--;\n      if (left > right) {\n        [arr[pivot], arr[right]] = [arr[right],\
    \ arr[pivot]];\n        pivot = right;\n      } else {\n        [arr[left], arr[right]]\
    \ = [arr[right], arr[left]];\n      }\n    }\n    if (pivot === k) return;\n \
    \   quickSort(start, pivot - 1);\n    quickSort(pivot + 1, end);\n  };\n  quickSort(0,\
    \ arr.length - 1);\n  for (let i = 0; i < k; i++) {\n    result.push(arr[i]);\n\
    \  }\n  return result;\n}\nconsole.log(maximum([1, 4, 3, 2], 4));\nconsole.log(maximum([4,\
    \ 3, 2, 1], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));", "  if (k === arr.length) return arr;\n  arr.sort((a,\
    \ b) => a - b);\n  const result = [];\n  for (let i = arr.length - 1; i >= arr.length\
    \ - k; i--) {\n    result.push(arr[i]);\n  }\n  return result;\n}\n", "    if\
    \ (k > arr.length) {\n        return arr;\n    }\n    const q = new PriorityQueue({\
    \ comparator: (a, b) => a > b ? 1 : -1 });\n    for (let num of arr) {\n     \
    \   q.offer(num);\n        if (q.size() > k) {\n            q.poll();\n      \
    \  }\n    }\n    return Array.from(q);\n}", "    if (k <= 0) return [];\n    if\
    \ (k === arr.length) return arr.sort((a, b) => a - b);\n    let newArr = arr.slice();\n\
    \    let result = [];\n    while (result.length < k) {\n        let max = Math.max(...newArr);\n\
    \        result.push(max);\n        newArr.splice(newArr.indexOf(max), 1);\n \
    \   }\n    return result;\n}\n", "    if (k === 0) {\n        return [];\n   \
    \ }\n    if (k === arr.length) {\n        return arr;\n    }\n    let result:\
    \ number[] = [];\n    let min = Math.min(...arr);\n    let index = arr.indexOf(min);\n\
    \    let max = Math.max(...arr);\n    arr.splice(index, 1);\n    result.push(min);\n\
    \    for (let i = 0; i < k - 1; i++) {\n        let index = arr.indexOf(max);\n\
    \        arr.splice(index, 1);\n        result.push(max);\n        max = Math.max(...arr);\n\
    \    }\n    return result;\n}\n", "  return arr.sort((a, b) => a - b).slice(-k);\n\
    }\n", "  return arr.sort((a, b) => a - b).slice(-k);\n}\n", "  const res: number[]\
    \ = [];\n  for (let i = 0; i < arr.length; i++) {\n    let index = res.length\
    \ - 1;\n    while (index >= 0 && arr[i] > res[index]) {\n      index--;\n    }\n\
    \    res.splice(index + 1, 0, arr[i]);\n    res.length = Math.min(res.length,\
    \ k);\n  }\n  return res;\n}\n\nexport default maximum;", "    if (k >= arr.length)\
    \ {\n        return arr.sort((a, b) => b - a);\n    }\n    const sortedArr = mergeSort(arr);\n\
    \    return sortedArr.slice(0, k);\n}\n", "  return arr.sort((a, b) => a - b).slice(-k);\n\
    }\n", "  return sort(arr).slice(arr.length - k);\n}\n", "    const maxHeap = new\
    \ MaxHeap();\n    arr.forEach(num => maxHeap.insert(num));\n    const result =\
    \ [];\n    while (k--) {\n        result.push(maxHeap.remove());\n    }\n    return\
    \ result;\n}\n", "  const list = [];\n  for (let i = 0; i < arr.length; i++) {\n\
    \    const item = arr[i];\n    if (i < k) {\n      list.push(item);\n    } else\
    \ {\n      for (let j = k - 1; j >= 0; j--) {\n        if (item > list[j]) {\n\
    \          list.splice(j, 0, item);\n          list.pop();\n          break;\n\
    \        }\n      }\n    }\n  }\n  return list;\n}\n\nexport { maximum };", " \
    \ return arr.sort((a, b) => a - b).slice(-k);\n}\n\nconsole.log(maximum([-3, -4,\
    \ 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3, 2,\
    \ 1, 2, -1, -2, 1], 1));", "    let count = 0;\n    let result: number[] = [];\n\
    \    let i = 0;\n    while (count < k) {\n        result.push(arr[i]);\n     \
    \   count++;\n        i++;\n    }\n    // TODO: return a sorted array with maximum\
    \ k numbers\n    return result;\n}\n", "  return arr.sort((a, b) => b - a).slice(0,\
    \ k);\n}\n", "  return arr.sort((a, b) => a - b).slice(-k);\n}\n\ntest('test maximum\
    \ array', () => {\n  expect(maximum([-3, -4, 5], 3)).toEqual([-4, -3, 5]);\n \
    \ expect(maximum([4, -4, 4], 2)).toEqual([4, 4]);\n  expect(maximum([-3, 2, 1,\
    \ 2, -1, -2, 1], 1)).toEqual([2]);\n});", "  return arr.sort((a, b) => b - a).slice(0,\
    \ k);\n}\n", "    let result: number[] = []\n    let heap = new MinHeap([], k)\n\
    \    for (let i = 0; i < arr.length; i++) {\n        heap.add(arr[i])\n    }\n\
    \    while (heap.size() > 0) {\n        result.push(heap.remove())\n    }\n  \
    \  return result\n}\n", "  // TODO\n}\n", "  return arr.sort((a, b) => b - a).slice(0,\
    \ k);\n}\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4,\
    \ 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "    const sorted\
    \ = arr.sort((a, b) => a - b)\n    const arrOfK = sorted.slice(arr.length - k,\
    \ arr.length)\n    return arrOfK\n}", "  // return arr.sort((a, b) => b - a).slice(0,\
    \ k);\n  return arr.sort((a, b) => a - b).slice(arr.length - k);\n}\n", "    //\
    \ @ts-ignore\n    return [...arr].sort((a, b) => b - a).slice(0, k);\n}\n", " \
    \   return arr.sort((a, b) => b - a).slice(0, k);\n}\n", "  return arr.sort((a,\
    \ b) => b - a).slice(0, k);\n}\n", "  let result: number[] = [];\n  if (k ===\
    \ 0) {\n    return result;\n  }\n  arr.sort((a, b) => b - a);\n  result = arr.slice(0,\
    \ k);\n  return result;\n}\nconsole.log(maximum([4, -4, 4], 2));", "  const ans:\
    \ number[] = [];\n  let len = arr.length;\n  while (k--) {\n    let max = arr[0];\n\
    \    let idx = 0;\n    for (let i = 1; i < len; i++) {\n      if (arr[i] > max)\
    \ {\n        max = arr[i];\n        idx = i;\n      }\n    }\n    ans.push(max);\n\
    \    arr.splice(idx, 1);\n    len--;\n  }\n  return ans;\n}\n\nconst ans = maximum([-3,\
    \ -4, 5], 3);\nconsole.log(ans);", "  const set = new Set();\n  for (let i = 0;\
    \ i < arr.length; i++) {\n    if (set.size < k) {\n      set.add(arr[i]);\n  \
    \  } else {\n      let minimum = Number.MAX_SAFE_INTEGER;\n      let minValue\
    \ = -1;\n      for (let item of set) {\n        if (item < minimum) {\n      \
    \    minimum = item;\n          minValue = item;\n        }\n      }\n      if\
    \ (arr[i] > minimum) {\n        set.delete(minValue);\n        set.add(arr[i]);\n\
    \      }\n    }\n  }\n  return Array.from(set).sort((a, b) => a - b);\n}\n\ndescribe(\"\
    maximum\", () => {\n  test(\"#1\", () => {\n    expect(maximum([-3, -4, 5], 3)).toEqual([-4,\
    \ -3, 5]);\n  });\n  test(\"#2\", () => {\n    expect(maximum([4, -4, 4], 2)).toEqual([4,\
    \ 4]);\n  });\n  test(\"#3\", () => {\n    expect(maximum([-3, 2, 1, 2, -1, -2,\
    \ 1], 1)).toEqual([2]);\n  });\n});", "    let result: number[] = [];\n    const\
    \ n = arr.length;\n    const lo = arr[0];\n    const hi = arr[n - 1];\n    let\
    \ left = lo;\n    let right = hi;\n    for (let i = 0; i < k; i++) {\n       \
    \ result.push(hi);\n    }\n    while (left <= right) {\n        const mid = Math.floor((left\
    \ + right) / 2);\n        let count = 0;\n        let j = 0;\n        for (let\
    \ i = 0; i < n; i++) {\n            while (j < n && arr[j] - mid <= 0) {\n   \
    \             j++;\n            }\n            count += j - i;\n        }\n  \
    \      if (count === k) {\n            left = mid + 1;\n        } else if (count\
    \ < k) {\n            right = mid - 1;\n        } else {\n            left = mid\
    \ + 1;\n            result = [];\n            j = 0;\n            for (let i =\
    \ 0; i < n; i++) {\n                while (j < n && arr[j] - mid <= 0) {\n   \
    \                 j++;\n                }\n                for (let z = i; z <\
    \ j; z++) {\n                    if (result.length < k) {\n                  \
    \      result.push(arr[z]);\n                    }\n                }\n      \
    \      }\n        }\n    }\n    return result;\n}", "  let start = 0;\n  let end\
    \ = arr.length - 1;\n  let pivot = partition(arr, start, end);\n  while (pivot\
    \ !== k - 1) {\n    if (pivot > k - 1) {\n      end = pivot - 1;\n      pivot\
    \ = partition(arr, start, end);\n    } else {\n      start = pivot + 1;\n    \
    \  pivot = partition(arr, start, end);\n    }\n  }\n  return arr.slice(0, k);\n\
    }\n", "    let results: number[] = [];\n    for (let i = 0; i < k; i++) {\n  \
    \      let max = Math.max(...arr);\n        results.push(max);\n        arr.splice(arr.indexOf(max),\
    \ 1);\n    }\n    return results;\n}\n\nexport function maxArray() {\n    let\
    \ newArr: number[] = [];\n    let k: number = 6;\n    for (let i = 0; i < 20;\
    \ i++) {\n        newArr.push(Math.floor(Math.random() * 1000));\n    }\n    console.log(newArr);\n\
    \    console.log(maximum(newArr, k));\n}", "  const answer: number[] = [];\n \
    \ while (k) {\n    answer.push(Math.max(...arr));\n    arr.splice(arr.indexOf(Math.max(...arr)),\
    \ 1);\n    k--;\n  }\n  return answer;\n}\n", "    let max: number[] = [];\n \
    \   for (let i = 0; i < k; i++) {\n        let max_index = 0;\n        for (let\
    \ j = 0; j < arr.length; j++) {\n            if (arr[j] > arr[max_index]) {\n\
    \                max_index = j;\n            }\n        }\n        max.push(arr[max_index]);\n\
    \        arr.splice(max_index, 1);\n    }\n    return max;\n}\n", "  let arrSorted:\
    \ number[] = [];\n  if (k >= arr.length) {\n    arrSorted = arr.sort((a, b) =>\
    \ a - b);\n  } else {\n    let sortArr: number[] = arr.sort((a, b) => a - b);\n\
    \    arrSorted = sortArr.slice(sortArr.length - k);\n  }\n  return arrSorted;\n\
    }\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\n\
    console.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "    let max: number[] =\
    \ [];\n    for (let i = 0; i < k; i++) {\n        let max_num = arr[i];\n    \
    \    let max_index = i;\n        for (let j = i + 1; j < arr.length; j++) {\n\
    \            if (arr[j] > max_num) {\n                max_num = arr[j];\n    \
    \            max_index = j;\n            }\n        }\n        arr[max_index]\
    \ = arr[i];\n        arr[i] = max_num;\n        max.push(max_num);\n    }\n  \
    \  return max;\n}", "    if (k >= arr.length) {\n        return arr.sort((a, b)\
    \ => a - b);\n    }\n\n    const queue = new PriorityQueue<number>();\n    const\
    \ result = [];\n\n    for (let i = 0; i < arr.length; i++) {\n        queue.insert(arr[i]);\n\
    \    }\n\n    for (let i = 0; i < k; i++) {\n        result.push(queue.extractMax());\n\
    \    }\n\n    return result;\n}", "    arr.sort((a, b) => a - b);\n    const result\
    \ = [];\n    let i = arr.length - 1;\n    while (i >= 0 && k > 0) {\n        result.push(arr[i]);\n\
    \        i--;\n        k--;\n    }\n    return result;\n}\n", "  // Use Min Heap\n\
    \  // In JS, we can't use priority queue, so let's use an Array and sort it.\n\
    \  const maxHeap = [];\n  // Generate a max heap using the first k elements of\
    \ the array.\n  for (let i = 0; i < k; i++) {\n    maxHeap.push(arr[i]);\n  }\n\
    \  // Swap the first element in the max heap with the ith element in the array\n\
    \  // if the ith element is greater than the first element in the max heap\n \
    \ // and heapify the heap.\n  for (let i = k; i < arr.length; i++) {\n    if (arr[i]\
    \ > maxHeap[0]) {\n      maxHeap[0] = arr[i];\n      maxHeap.sort((a, b) => b\
    \ - a);\n    }\n  }\n  return maxHeap;\n}\n\nmodule.exports = { maximum };", " \
    \   let res: number[] = [];\n    if (arr.length === 0) {\n        return res;\n\
    \    }\n    let max, index;\n    for (let i = 0; i < k; i++) {\n        max =\
    \ -Infinity;\n        index = -1;\n        for (let j = 0; j < arr.length; j++)\
    \ {\n            if (arr[j] > max) {\n                max = arr[j];\n        \
    \        index = j;\n            }\n        }\n        res.push(max);\n      \
    \  arr.splice(index, 1);\n    }\n    return res;\n}\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));", "    const max: number[] = []\n    arr.sort((a,\
    \ b) => b - a).forEach((el, index) => {\n        if (index < k) {\n          \
    \  max.push(el)\n        }\n    })\n    return max\n}", "    let max: number[]\
    \ = [];\n    let pivot: number;\n    let less: number[] = [];\n    let more: number[]\
    \ = [];\n    if (arr.length === k) {\n        return arr;\n    }\n    pivot =\
    \ arr[0];\n    arr.forEach((v, i) => {\n        if (i === 0) {\n            return;\n\
    \        }\n        if (v > pivot) {\n            more.push(v);\n        } else\
    \ {\n            less.push(v);\n        }\n    });\n    if (more.length >= k)\
    \ {\n        return maximum(more, k);\n    } else {\n        max = more;\n   \
    \     max.push(pivot);\n        return max.concat(maximum(less, k - more.length\
    \ - 1));\n    }\n}\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4,\
    \ -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  if (k\
    \ === 0) return [];\n  let left = 0;\n  let right = arr.length - 1;\n  let pivotIndex;\n\
    \  while (true) {\n    pivotIndex = partition(arr, left, right);\n    if (pivotIndex\
    \ === k - 1) break;\n    if (pivotIndex > k - 1) {\n      right = pivotIndex -\
    \ 1;\n    } else {\n      left = pivotIndex + 1;\n    }\n  }\n  return arr.slice(0,\
    \ k);\n}\n", "  const result: number[] = [];\n  if (k > arr.length) {\n    return\
    \ result;\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(Math.max(...arr));\n\
    \    arr.splice(arr.indexOf(Math.max(...arr)), 1);\n  }\n  return result;\n}\n\
    \nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\n\
    console.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  let result: number[] =\
    \ [];\n  let max: number = 0;\n  let position: number = 0;\n  let index: number\
    \ = 0;\n  while (index < k) {\n    result.push(arr[index]);\n    index++;\n  }\n\
    \  while (index < arr.length) {\n    let current: number = arr[index];\n    if\
    \ (current > result[0]) {\n      result[0] = current;\n      position = 0;\n \
    \     for (let i = 1; i < k; i++) {\n        if (result[i] > result[position])\
    \ {\n          position = i;\n        }\n      }\n      max = result[position];\n\
    \      for (let i = position; i > 0; i--) {\n        result[i] = result[i - 1];\n\
    \      }\n      result[0] = max;\n    }\n    index++;\n  }\n  return result;\n\
    }\n", "    if (k === 0) {\n        return [];\n    }\n    return arr.sort((a,\
    \ b) => b - a).slice(0, k);\n}\n", "    const maxHeap = new MaxHeap();\n    for\
    \ (let i = 0; i < arr.length; i++) {\n        maxHeap.insert(arr[i]);\n    }\n\
    \    const result = [];\n    for (let i = 0; i < k; i++) {\n        result.push(maxHeap.extractMax());\n\
    \    }\n    return result;\n}\n\nconst heap = new MaxHeap();\nheap.insert(3);\n\
    heap.insert(5);\nheap.insert(10);\nheap.insert(2);\nheap.insert(7);\nheap.insert(8);\n\
    console.log(heap.extractMax());\nconsole.log(heap.extractMax());\nconsole.log(heap.extractMax());\n\
    console.log(heap.extractMax());\nconsole.log(heap.extractMax());\nconsole.log(heap.extractMax());\n\
    console.log(heap.extractMax());\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4,\
    \ -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  const\
    \ sortedArr = arr.sort((a, b) => b - a);\n  const res = [];\n  for (let i = 0;\
    \ i < k; i++) {\n    res.push(sortedArr[i]);\n  }\n  return res;\n}\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));", "  // create a min heap of size k\n  const minHeap\
    \ = new Heap<number>(arr.slice(0, k), (a, b) => a - b);\n  // loop through the\
    \ rest of the array\n  for (let i = k; i < arr.length; i++) {\n    // if the current\
    \ element is larger than the root of the min heap\n    if (arr[i] > minHeap.getRoot())\
    \ {\n      // extract the root\n      minHeap.extractRoot();\n      // insert\
    \ the current element\n      minHeap.insert(arr[i]);\n    }\n  }\n  // return\
    \ the arr of the heap elements\n  return minHeap.toArray();\n}\n", "  if (!arr\
    \ || !arr.length) return [];\n  if (k >= arr.length) return arr.sort((a, b) =>\
    \ b - a);\n  const rtn = [];\n  // max heap\n  arr.forEach(e => {\n    rtn.push(e);\n\
    \    let cur = rtn.length - 1;\n    while (cur >= 0) {\n      const parent = Math.floor((cur\
    \ - 1) / 2);\n      if (parent >= 0 && rtn[parent] < rtn[cur]) {\n        const\
    \ tmp = rtn[parent];\n        rtn[parent] = rtn[cur];\n        rtn[cur] = tmp;\n\
    \        cur = parent;\n      } else {\n        break;\n      }\n    }\n    if\
    \ (rtn.length > k) {\n      rtn[0] = rtn[rtn.length - 1];\n      rtn.length--;\n\
    \      cur = 0;\n      while (cur < rtn.length) {\n        const left = cur *\
    \ 2 + 1;\n        const right = cur * 2 + 2;\n        let swap = cur;\n      \
    \  if (left < rtn.length && rtn[swap] < rtn[left]) {\n          swap = left;\n\
    \        }\n        if (right < rtn.length && rtn[swap] < rtn[right]) {\n    \
    \      swap = right;\n        }\n        if (swap !== cur) {\n          const\
    \ tmp = rtn[swap];\n          rtn[swap] = rtn[cur];\n          rtn[cur] = tmp;\n\
    \          cur = swap;\n        } else {\n          break;\n        }\n      }\n\
    \    }\n  });\n  return rtn;\n}\n\ndescribe(\"maximum\", () => {\n  it(\"#1\"\
    , () => {\n    assert.deepEqual(maximum([-3, -4, 5], 3), [-4, -3, 5]);\n  });\n\
    \  it(\"#2\", () => {\n    assert.deepEqual(maximum([4, -4, 4], 2), [4, 4]);\n\
    \  });\n  it(\"#3\", () => {\n    assert", "  const n = arr.length;\n  for (let\
    \ i = 0; i < n; i++) {\n    let max = i;\n    for (let j = i + 1; j < n; j++)\
    \ {\n      if (arr[j] > arr[max]) {\n        max = j;\n      }\n    }\n    [arr[i],\
    \ arr[max]] = [arr[max], arr[i]];\n  }\n  return arr.slice(0, k);\n}", "    let\
    \ sortedArr = Array.from(arr);\n    sortedArr.sort((a, b) => a - b);\n    return\
    \ sortedArr.slice(sortedArr.length - k);\n}\n", "  if (!arr || arr.length ===\
    \ 0) return null;\n  if (k === 0) return [];\n  let maxHeap = new MaxHeap();\n\
    \  for (let i = 0; i < arr.length; i++) {\n    if (maxHeap.size() < k) {\n   \
    \   maxHeap.insert(arr[i]);\n    } else {\n      if (arr[i] > maxHeap.peek())\
    \ {\n        maxHeap.pop();\n        maxHeap.insert(arr[i]);\n      }\n    }\n\
    \  }\n  return maxHeap.toArray();\n}\n\nconsole.log(maximum([-3, -4, 5], 3));\
    \ // [-4, -3, 5]\nconsole.log(maximum([4, -4, 4], 2)); // [4, 4]\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1)); // [2]", "    if(k === arr.length) return arr.sort((a,\
    \ b) => a - b);\n    let newArr = arr.sort((a, b) => a - b);\n    return newArr.slice(newArr.length\
    \ - k);\n}\n", "    // O(n log k)\n    // const result = [];\n    // let sorted\
    \ = [...arr].sort((a, b) => b - a);\n    // while (k > 0) {\n    //     result.push(sorted.shift());\n\
    \    //     k--;\n    // }\n    // return result;\n\n    // O(n log k)\n    const\
    \ result = [...arr].sort((a, b) => b - a).slice(0, k);\n    return result;\n}\n",
  "    let heap = [arr[0]];\n    for (let i = 1; i < arr.length; i++) {\n        if\
    \ (heap.length < k) {\n            heap.push(arr[i]);\n            swim(heap,\
    \ heap.length - 1);\n        } else if (arr[i] > heap[0]) {\n            heap[0]\
    \ = arr[i];\n            sink(heap, 0);\n        }\n    }\n    return heap;\n\
    }\n", "    if (k === arr.length) {\n        return arr.sort((a, b) => a - b);\n\
    \    }\n    return arr.sort((a, b) => b - a).slice(0, k);\n}\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));\n", "  const minHeap = new MaxHeap();\n  arr.forEach(num\
    \ => minHeap.insert(num));\n  const res = [];\n  for (let i = 0; i < k; i++) {\n\
    \    res.push(minHeap.extractMax());\n  }\n  return res;\n}\n\nconst arr = [-3,\
    \ -4, 5];\nconst k = 3;\nconsole.log(maximum(arr, k));\n\nconst arr2 = [4, -4,\
    \ 4];\nconst k2 = 2;\nconsole.log(maximum(arr2, k2));\n\nconst arr3 = [-3, 2,\
    \ 1, 2, -1, -2, 1];\nconst k3 = 1;\nconsole.log(maximum(arr3, k3));", "    let\
    \ result: number[] = []\n    for (let i = 0; i < k; i++) {\n        let max: number\
    \ = arr[0]\n        let maxIndex: number = 0\n        for (let j = 0; j < arr.length;\
    \ j++) {\n            if (arr[j] > max) {\n                max = arr[j]\n    \
    \            maxIndex = j\n            }\n        }\n        result.push(max)\n\
    \        arr.splice(maxIndex, 1)\n    }\n    return result\n}\n", "  const heap\
    \ = new MaxHeap(k);\n  for (let i = 0; i < arr.length; i++) {\n    heap.insert(arr[i]);\n\
    \  }\n  return heap.list;\n}", "    let aux: number[] = [];\n    for (let i =\
    \ 0; i < k; i++) {\n        aux.push(arr[i]);\n    }\n    aux.sort((a, b) => a\
    \ - b);\n    for (let i = k; i < arr.length; i++) {\n        if (arr[i] > aux[0])\
    \ {\n            aux[0] = arr[i];\n            let j = 0;\n            while (j\
    \ < k - 1 && aux[j] > aux[j + 1]) {\n                [aux[j], aux[j + 1]] = [aux[j\
    \ + 1], aux[j]];\n                j++;\n            }\n        }\n    }\n    return\
    \ aux;\n}\n", "    if (k > arr.length) {\n        return null;\n    }\n    let\
    \ result: number[] = [];\n    let resultIndex = 0;\n    let ptr = 0;\n    for\
    \ (let i = 0; i < arr.length; i++) {\n        if (arr[i] > arr[ptr]) {\n     \
    \       ptr = i;\n        }\n        if (i % (arr.length / k) === 0) {\n     \
    \       result[resultIndex] = arr[ptr];\n            resultIndex++;\n        \
    \    ptr = i;\n        }\n    }\n    return result;\n}\n\nexport function getMaxNumbers(arr:\
    \ number[], k: number): number[] {\n    return maximum(arr, k);\n}", "  return\
    \ arr.sort((a, b) => a - b).slice(-k);\n}\n\nexport { maximum };", "  if (k ===\
    \ 0) return [];\n  let l = arr.length;\n  let first = Math.floor((l - 1) / 2);\n\
    \  let last = first + 1;\n  let count = 1;\n  const result = [arr[first]];\n \
    \ while (count < k) {\n    if (first >= 0 && last < l) {\n      result.push(arr[first--],\
    \ arr[last++]);\n      count += 2;\n    } else if (first >= 0) {\n      result.push(arr[first--]);\n\
    \      count++;\n    } else if (last < l) {\n      result.push(arr[last++]);\n\
    \      count++;\n    }\n  }\n  return result;\n}\n\nconst max = maximum([-3, -4,\
    \ 5], 3);\nconsole.log(max);", "  // Your code here.\n  return [];\n}\n", "  \
    \  let result: number[] = [];\n    for (let i = 0; i < k; i++) {\n        let\
    \ index = -1;\n        let maxValue = -Infinity;\n        for (let j = 0; j <\
    \ arr.length; j++) {\n            if (maxValue < arr[j]) {\n                maxValue\
    \ = arr[j];\n                index = j;\n            }\n        }\n        result.push(maxValue);\n\
    \        arr.splice(index, 1);\n    }\n    return result;\n}\n", "  if (k > arr.length)\
    \ throw new Error('k must be <= arr.length')\n  return quicksort(arr, 0, arr.length\
    \ - 1).slice(0, k)\n}\n", "  const res: number[] = [];\n  const sortedArr = arr.sort((a,\
    \ b) => a - b);\n  for (let i = arr.length - 1; i >= arr.length - k; i--) {\n\
    \    res.push(sortedArr[i]);\n  }\n  return res;\n}\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));", "    if (k <= 0) {\n        return [];\n    }\n\n\
    \    if (k >= arr.length) {\n        return arr.sort((a, b) => a - b);\n    }\n\
    \n    const max = Math.max(...arr);\n    const min = Math.min(...arr);\n    const\
    \ res: number[] = [...arr.slice(0, k)];\n    res.sort((a, b) => a - b);\n\n  \
    \  for (let i = k; i < arr.length; i++) {\n        let j = 0;\n        for (;\
    \ j < k; j++) {\n            if (arr[i] > res[j]) {\n                res.splice(j,\
    \ 0, arr[i]);\n                res.pop();\n                break;\n          \
    \  }\n        }\n    }\n\n    return res;\n}\n\nconsole.log(maximum([-3, -4, 5],\
    \ 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2,\
    \ -1, -2, 1], 1));", "  const result: number[] = [];\n  for (let i = 0; i < k;\
    \ i++) {\n    for (let j = 0; j < arr.length; j++) {\n      if (arr[j] > arr[j\
    \ + 1]) {\n        arr[j] = arr[j] + arr[j + 1];\n        arr[j + 1] = arr[j]\
    \ - arr[j + 1];\n        arr[j] = arr[j] - arr[j + 1];\n      }\n    }\n    result.push(arr[arr.length\
    \ - 1 - i]);\n  }\n  return result;\n}\n", "    const result: number[] = [];\n\
    \    let i = 0;\n    while (i < k) {\n        const maxIndex = getMaxIndex(arr);\n\
    \        result.push(arr[maxIndex]);\n        arr.splice(maxIndex, 1);\n     \
    \   i++;\n    }\n    return result;\n}\n", "  let n = arr.length;\n  if (k > n)\
    \ {\n    throw new Error(\"k must be less than or equal to the length of arr\"\
    );\n  }\n  let max: number[] = [];\n  for (let i = 0; i < k; i++) {\n    let index\
    \ = i;\n    let min = arr[i];\n    for (let j = i + 1; j < n; j++) {\n      if\
    \ (arr[j] > min) {\n        min = arr[j];\n        index = j;\n      }\n    }\n\
    \    [arr[i], arr[index]] = [arr[index], arr[i]];\n    max.push(arr[i]);\n  }\n\
    \  return max;\n}\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4,\
    \ -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  let max:\
    \ number[] = [];\n  for (let i = 0; i < k; i++) {\n    let maxIdx = 0;\n    for\
    \ (let j = 0; j < arr.length; j++) {\n      if (arr[j] > arr[maxIdx]) {\n    \
    \    maxIdx = j;\n      }\n    }\n    max.push(arr[maxIdx]);\n    arr.splice(maxIdx,\
    \ 1);\n  }\n  return max;\n}\n", "  return arr.sort((a, b) => b - a).slice(0,\
    \ k);\n}\n", "    if (k === 0) {\n        return [];\n    }\n\n    const result:\
    \ number[] = [];\n    if (k === arr.length) {\n        return arr.sort((a, b)\
    \ => a - b);\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n        if\
    \ (result.length === k) {\n            break;\n        }\n        let counter\
    \ = 0;\n        for (let j = 0; j < result.length; j++) {\n            if (arr[i]\
    \ > result[j]) {\n                counter++;\n            }\n        }\n     \
    \   if (counter === result.length) {\n            result.push(arr[i]);\n     \
    \   }\n    }\n    for (let i = 0; i < arr.length; i++) {\n        if (result.length\
    \ === k) {\n            break;\n        }\n        if (result.indexOf(arr[i])\
    \ === -1) {\n            result.push(arr[i]);\n        }\n    }\n    return result.sort((a,\
    \ b) => a - b);\n}\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4,\
    \ -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  return\
    \ arr.sort((a, b) => b - a).slice(0, k);\n}\n\nconsole.log(maximum([-3, -4, 5],\
    \ 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2,\
    \ -1, -2, 1], 1));", "  let kthSmallest = -Infinity;\n  let counter = 0;\n  let\
    \ maxHeap = new Heap();\n  let res = [];\n  maxHeap.buildMaxHeap(arr);\n  for\
    \ (let i = 0; i < k; i++) {\n    let max = maxHeap.extractMax();\n    res.push(max);\n\
    \  }\n  return res;\n}\n\nexport class Heap {\n  heap: number[];\n  constructor()\
    \ {\n    this.heap = [];\n  }\n  buildMaxHeap(arr: number[]): void {\n    for\
    \ (let i = 0; i < arr.length; i++) {\n      this.insert(arr[i]);\n    }\n  }\n\
    \  max(): number {\n    return this.heap[0];\n  }\n  heapSize(): number {\n  \
    \  return this.heap.length;\n  }\n  left(i: number): number {\n    return 2 *\
    \ i + 1;\n  }\n  right(i: number): number {\n    return 2 * i + 2;\n  }\n  parent(i:\
    \ number): number {\n    return Math.floor((i - 1) / 2);\n  }\n  insert(value:\
    \ number): void {\n    this.heap.push(value);\n    let i = this.heapSize() - 1;\n\
    \    while (i > 0 && this.heap[this.parent(i)] < this.heap[i]) {\n      [this.heap[this.parent(i)],\
    \ this.heap[i]] = [\n        this.heap[i],\n        this.heap[this.parent(i)],\n\
    \      ];\n      i = this.parent(i);\n    }\n  }\n  extractMax(): number {\n \
    \   let max = this.heap[0];\n    this.heap[0] = this.heap[this.heapSize() - 1];\n\
    \    this.heap.pop();\n    this.maxHeapify(0);\n    return max;\n  }\n  maxHeapify(i:\
    \ number): void {\n    let left = this.left(i);\n    let right", "  return arr.sort((a,\
    \ b) => b - a).slice(0, k);\n}\n", "  return arr.sort((a, b) => b - a).slice(0,\
    \ k);\n}\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4, 4],\
    \ 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "    if (k === 0)\
    \ {\n        return [];\n    }\n    let nums = [];\n    let max = [];\n    for\
    \ (let i = 0; i < arr.length; i++) {\n        nums.push(arr[i]);\n        if (nums.length\
    \ > k) {\n            nums.sort((a, b) => a - b);\n            nums.pop();\n \
    \       }\n    }\n    return nums.sort((a, b) => a - b);\n}\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));\n\nexport { }", "    if (k === 0) {\n        return\
    \ [];\n    }\n    let minHeap = new MinHeap();\n    for (let i = 0; i < arr.length;\
    \ i++) {\n        if (minHeap.size() < k) {\n            minHeap.insert(arr[i]);\n\
    \        } else {\n            if (arr[i] > minHeap.min()) {\n               \
    \ minHeap.delMin();\n                minHeap.insert(arr[i]);\n            }\n\
    \        }\n    }\n    return minHeap.heap;\n}", "    // TODO: Implement me\n\
    \    throw new Error(\"Method not implemented.\");\n}", "    arr.sort( (a, b)\
    \ => a - b );\n    arr.splice(0, arr.length - k);\n    return arr;\n}", "    arr.sort((a,\
    \ b) => a - b);\n    let i = 0;\n    let j = arr.length - 1;\n    while (i < j)\
    \ {\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n        i++;\n        j--;\n\
    \    }\n    return arr.slice(0, k);\n}\n", "    // O(nlogn)\n    // return arr.sort((a,\
    \ b) => b - a).slice(0, k);\n    // O(nlogk)\n    // return arr.sort((a, b) =>\
    \ b - a).slice(0, k).sort((a, b) => a - b);\n    // O(nlogk)\n    // return [...new\
    \ Set(arr)].sort((a, b) => b - a).slice(0, k);\n    // O(nk)\n    // const result\
    \ = [];\n    // for (let i = 0; i < k; i++) {\n    //     let max = Number.MIN_SAFE_INTEGER;\n\
    \    //     let idx = 0;\n    //     for (let j = 0; j < arr.length; j++) {\n\
    \    //         if (arr[j] > max) {\n    //             max = arr[j];\n    //\
    \             idx = j;\n    //         }\n    //     }\n    //     result.push(max);\n\
    \    //     arr.splice(idx, 1);\n    // }\n    // return result;\n    // O(nk)\n\
    \    const result = [];\n    for (let i = 0; i < k; i++) {\n        let min =\
    \ Number.MAX_SAFE_INTEGER;\n        let idx = 0;\n        for (let j = 0; j <\
    \ arr.length; j++) {\n            if (arr[j] < min) {\n                min = arr[j];\n\
    \                idx = j;\n            }\n        }\n        result.push(min);\n\
    \        arr.splice(idx, 1);\n    }\n    return result;\n}\n\nexport default {\n\
    \    maximum\n};", "  arr.sort((a, b) => a - b);\n  return arr.slice(arr.length\
    \ - k);\n}\n", "  let length = arr.length;\n  let hashed: Record<number, number>\
    \ = {};\n  let heap: Record<number, number> = {};\n  let heapLength = 0;\n  for\
    \ (let i = 0; i < length; i++) {\n    if (hashed[arr[i]]) {\n      hashed[arr[i]]++;\n\
    \    } else {\n      hashed[arr[i]] = 1;\n    }\n  }\n  let result: number[] =\
    \ [];\n  Object.keys(hashed).forEach((key) => {\n    insert(Number(key), hashed[key]);\n\
    \  });\n  for (let i = 0; i < k; i++) {\n    let top = pop();\n    result.push(top.value);\n\
    \    if (top.num !== 1) {\n      insert(top.value, top.num - 1);\n    }\n  }\n\
    \  return result;\n\n  function insert(value: number, num: number) {\n    heap[heapLength]\
    \ = value;\n    heap[heapLength + 1] = num;\n    heapLength += 2;\n    shiftUp(heapLength\
    \ - 2);\n  }\n\n  function pop() {\n    let top = {\n      value: heap[0],\n \
    \     num: heap[1],\n    };\n    swap(0, heapLength - 2);\n    swap(1, heapLength\
    \ - 1);\n    heapLength -= 2;\n    shiftDown(0);\n    return top;\n  }\n\n  function\
    \ shiftUp(idx: number) {\n    let parentIdx = Math.floor((idx - 2) / 2);\n   \
    \ if (parentIdx < 0) {\n      return;\n    }\n    if (heap[idx] > heap[parentIdx])\
    \ {\n      swap(idx, parentIdx);\n      shiftUp(parentIdx);\n    }\n  }\n\n  function\
    \ shiftDown(idx: number) {\n    let childIdx = idx * 2 + 2;\n    if (childIdx\
    \ >= heapLength) {\n      return;\n    }\n    if (heap[childIdx] > heap[childIdx\
    \ - 2]) {", "  const result: number[] = [];\n  for (let i = 0; i < k; i++) {\n\
    \    const max = Math.max(...arr);\n    result.push(max);\n    arr.splice(arr.indexOf(max),\
    \ 1);\n  }\n  return result;\n}\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4,\
    \ -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  const\
    \ result: number[] = [];\n  arr.sort((a, b) => b - a);\n  for (let i = 0; i <\
    \ k; i++) {\n    result.push(arr[i]);\n  }\n  return result;\n}\n\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));", "  return arr.sort((a, b) => b - a).slice(0, k);\n\
    }\n", "  arr.sort((a, b) => a - b);\n  return arr.slice(arr.length - k);\n}\n",
  "  arr.sort((a, b) => b - a);\n  return arr.slice(0, k);\n}\n\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));", "    // if (arr.length < k) return arr;\n    let\
    \ head: number = 0;\n    let tail: number = arr.length - 1;\n    let headNum:\
    \ number = 0;\n    let tailNum: number = 0;\n    while (head < tail) {\n     \
    \   if (arr[head] > arr[tail]) {\n            arr[tail - 1] = [arr[tail], arr[tail]\
    \ = arr[tail - 1]][0];\n            --tail;\n            ++tailNum;\n        }\
    \ else {\n            arr[head + 1] = [arr[head], arr[head] = arr[head + 1]][0];\n\
    \            ++head;\n            ++headNum;\n        }\n        if (headNum ===\
    \ k) break;\n        if (tailNum === k) break;\n    }\n    if (headNum === k)\
    \ {\n        return arr.slice(head - k + 1, head + 1);\n    } else {\n       \
    \ return arr.slice(0, tail + 1).reverse();\n    }\n}\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));\n", "    let result: number[] = [];\n    for (let\
    \ i = 0; i < k; i++) {\n        let max = arr[0];\n        let index = 0;\n  \
    \      for (let j = 0; j < arr.length; j++) {\n            if (arr[j] > max) {\n\
    \                max = arr[j];\n                index = j;\n            }\n  \
    \      }\n        result.push(max);\n        arr.splice(index, 1);\n    }\n  \
    \  return result;\n}", "  if (k <= 0) return [];\n  if (k >= arr.length) return\
    \ arr.sort((a, b) => b - a);\n  const stack: number[] = [];\n  for (let i = 0;\
    \ i < arr.length; i++) {\n    while (stack.length > 0 && stack[stack.length -\
    \ 1] < arr[i] && stack.length - 1 + arr.length - i >= k) {\n      stack.pop();\n\
    \    }\n    if (stack.length < k) {\n      stack.push(arr[i]);\n    }\n  }\n \
    \ return stack;\n}\n", "  if (!arr.length) return [];\n  if (k === 0) return [];\n\
    \  return arr.sort((a, b) => b - a).slice(0, k);\n}\n\ndescribe(\"sort max of\
    \ array\", () => {\n  it(\"max 1\", () => {\n    const expected = [-4, -3, 5];\n\
    \    const actual = maximum([-3, -4, 5], 3);\n    expect(actual).toEqual(expected);\n\
    \  });\n  it(\"max 2\", () => {\n    const expected = [4, 4];\n    const actual\
    \ = maximum([4, -4, 4], 2);\n    expect(actual).toEqual(expected);\n  });\n  it(\"\
    max 3\", () => {\n    const expected = [2];\n    const actual = maximum([-3, 2,\
    \ 1, 2, -1, -2, 1], 1);\n    expect(actual).toEqual(expected);\n  });\n});", " \
    \ const sorted = arr.sort((a, b) => b - a);\n  return sorted.slice(0, k);\n}\n",
  "  const heap = new Heap<number>();\n  arr.forEach(x => heap.insert(x));\n  const\
    \ maxs = [];\n  for (let i = 0; i < k; i++) {\n    maxs.push(heap.extractMax());\n\
    \  }\n  return maxs;\n}\n", "  const maxHeap = new MaxHeap(arr);\n  const kHeap\
    \ = new MaxHeap();\n  for (let i = 0; i < k; i++) {\n    kHeap.add(maxHeap.poll());\n\
    \  }\n  return kHeap.heap;\n}\n", "    let result: number[] = [];\n    let sortedArr:\
    \ number[] = arr.sort((a, b) => a - b);\n    for (let i = 0; i < k; i++) {\n \
    \       result.push(sortedArr[sortedArr.length - 1 - i]);\n    }\n    return result;\n\
    }\n", "    return arr.sort((a, b) => b - a).slice(0, k);\n}\n\nexport { maximum\
    \ };", "  let start = 0;\n  let end = arr.length - 1;\n  let target = arr.length\
    \ - k;\n  let index = partition(arr, start, end);\n  while (index !== target)\
    \ {\n    if (index < target) {\n      start = index + 1;\n    } else {\n     \
    \ end = index - 1;\n    }\n    index = partition(arr, start, end);\n  }\n  return\
    \ arr.slice(index);\n}\n", "  // TODO: Implement solution\n  const maxHeap = new\
    \ MaxHeap();\n  maxHeap.buildHeap(arr);\n  return maxHeap.sort(k);\n}\n", "  \
    \  if (k === 0) {\n        return [];\n    }\n    if (k === arr.length) {\n  \
    \      return arr;\n    }\n    arr.sort((a, b) => a - b);\n    return arr.slice(arr.length\
    \ - k);\n}", "  if (k === 0) return [];\n  arr.sort((a, b) => a - b);\n  return\
    \ arr.slice(arr.length - k);\n}\n\ntest('maximum', () => {\n  expect(maximum([-3,\
    \ -4, 5], 3)).toEqual([-4, -3, 5]);\n  expect(maximum([4, -4, 4], 2)).toEqual([4,\
    \ 4]);\n  expect(maximum([-3, 2, 1, 2, -1, -2, 1], 1)).toEqual([2]);\n});", " \
    \ let nums: number[] = [];\n  arr.sort((a, b) => b - a);\n  let i = 0;\n  while\
    \ (nums.length < k) {\n    nums.push(arr[i]);\n    i++;\n  }\n  return nums;\n\
    }\n", "  // we can use sort if the data is small\n  // sort method will return\
    \ a sorted copy of the array\n  const sortedArr = arr.sort((a, b) => a - b);\n\
    \  // console.log(sortedArr);\n  // return a slice of k elements from the end\
    \ of the array\n  return sortedArr.slice(sortedArr.length - k);\n}\n", "  let\
    \ smallestIndex = 0;\n  let sortedArray = [];\n  for (let i = 0; i < k; i++) {\n\
    \    // look for smallest number and add it to sorted array\n    let smallestNumber\
    \ = arr[smallestIndex];\n    for (let j = smallestIndex; j < arr.length; j++)\
    \ {\n      let number = arr[j];\n      if (number < smallestNumber) {\n      \
    \  smallestNumber = number;\n        smallestIndex = j;\n      }\n    }\n    sortedArray.push(smallestNumber);\n\
    \    smallestIndex++;\n  }\n  return sortedArray;\n}\n", "  const maxHeap = createMaxHeap(arr,\
    \ k);\n  let index = k;\n  for (; index < arr.length; index++) {\n    if (arr[index]\
    \ > maxHeap[0]) {\n      maxHeap[0] = arr[index];\n      sink(maxHeap, 0);\n \
    \   }\n  }\n  return maxHeap;\n}\n", "    let result: number[] = [];\n    let\
    \ temp: number[] = arr.sort((a, b) => b - a);\n    if (k === 0) {\n        return\
    \ result;\n    }\n    for (let i = 0; i < k; i++) {\n        result.push(temp[i]);\n\
    \    }\n    return result;\n}", "  return arr.sort((a, b) => b - a).slice(0, k);\n\
    }\n", "    if (k === 0) {\n        return [];\n    }\n\n    return [...arr].sort((a,\
    \ b) => a - b).slice(-k);\n}", "  return arr.sort((a, b) => b - a).slice(0, k);\n\
    }\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\n\
    console.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  const n = arr.length;\n\
    \  const kth = n - k;\n  const result = [];\n  for (let i = 0; i < n; i++) {\n\
    \    const next = arr[i];\n    // if the array is already sorted, then we just\
    \ pop the\n    // head of the array\n    if (result.length === kth) {\n      if\
    \ (result[0] <= next) {\n        result.shift();\n        result.push(next);\n\
    \      }\n    } else {\n      // there are still empty spaces in the array,\n\
    \      // then we do binary search to find the index for insertion.\n      //\
    \ the reason for binary search is that we want to maintain\n      // the sorted\
    \ order.\n      const index = binarySearch(result, next);\n      result.splice(index,\
    \ 0, next);\n    }\n  }\n  return result;\n}\n", "  const sorted = arr.sort((a,\
    \ b) => a - b);\n  return sorted.slice(arr.length - k);\n}\n\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));", "    let result: number[] = [];\n    for (let i\
    \ = 0; i < k; i++) {\n        result.push(arr[i]);\n    }\n    result.sort((a,\
    \ b) => a - b);\n    let min: number = result[0];\n    for (let i = k; i < arr.length;\
    \ i++) {\n        if (arr[i] > min) {\n            result.shift();\n         \
    \   result.push(arr[i]);\n            result.sort((a, b) => a - b);\n        \
    \    min = result[0];\n        }\n    }\n    return result;\n}\n", "  if (!arr.length)\
    \ return [];\n  const pq = new PriorityQueue<number>((a, b) => b - a);\n  for\
    \ (let n of arr) {\n    pq.add(n);\n    if (pq.size() > k) pq.poll();\n  }\n \
    \ return pq.toArray();\n}\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4,\
    \ -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  let max\
    \ = Math.max(...arr);\n  let result = new Array(k).fill(max);\n  let c = 0;\n\
    \  let r = 0;\n  while (c < k) {\n    if (r === arr.length) break;\n    if (arr[r]\
    \ < result[c]) {\n      result[c] = arr[r];\n      c++;\n    }\n    r++;\n  }\n\
    \  while (c < k) {\n    result[c] = max;\n    c++;\n  }\n  return result;\n}\n\
    console.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\n\
    console.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  // const heap = new MaxHeap();\n\
    \  // heap.buildHeap(arr);\n  // const result = [];\n  // while (k--) {\n  //\
    \   result.push(heap.remove());\n  // }\n  // return result;\n  return arr.sort((a,\
    \ b) => b - a).slice(0, k);\n}\n", "  if (!arr || !arr.length) return [];\n  const\
    \ maxHeap = new MaxHeap();\n  maxHeap.add(arr);\n  return maxHeap.retrieveKMax(k);\n\
    }\n", "    const result: number[] = [];\n    for (let i = 0; i < k; i++) {\n \
    \       const max = Math.max(...arr);\n        result.push(max);\n        arr.splice(arr.indexOf(max),\
    \ 1);\n    }\n    return result;\n}\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4,\
    \ -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  return\
    \ arr.sort((a, b) => a - b).slice(-k);\n}\n\nconsole.log(maximum([-3, -4, 5],\
    \ 3)); // [-4, -3, 5]\nconsole.log(maximum([4, -4, 4], 2)); // [4, 4]\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1)); // [2]", "  if (k > arr.length) return [];\n  const\
    \ result = [];\n  arr.sort((a, b) => a - b);\n  for (let i = 0; i < k; i++) {\n\
    \    result.push(arr[arr.length - 1 - i]);\n  }\n  return result;\n}\n", "  //\
    \ length check\n  if (arr.length < k) {\n    return [];\n  }\n  // sort descending\n\
    \  arr.sort((a, b) => b - a);\n  // return first k elements\n  return arr.slice(0,\
    \ k);\n}\n", "  let result: number[] = [];\n  for (let i = 0; i < k; i++) {\n\
    \    result.push(arr[i]);\n  }\n  for (let i = k; i < arr.length; i++) {\n   \
    \ if (arr[i] > result[0]) {\n      result.shift();\n      result.push(arr[i]);\n\
    \    }\n  }\n  return result;\n}\n", "    let result: number[] = [];\n    for\
    \ (let i = 0; i < k; i++) {\n        let indexOfMax = 0;\n        for (let j =\
    \ 0; j < arr.length; j++) {\n            if (arr[j] > arr[indexOfMax]) {\n   \
    \             indexOfMax = j;\n            }\n        }\n        result.push(arr[indexOfMax]);\n\
    \        arr.splice(indexOfMax, 1);\n    }\n    return result;\n}\n", "    let\
    \ sortedArr = arr.sort((a, b) => b - a);\n    return sortedArr.slice(0, k);\n\
    }\n", "  // https://www.geeksforgeeks.org/k-largestor-smallest-elements-in-an-array/\n\
    \  let result: number[] = []\n  let maxHeap = new MaxHeap()\n  for (let i = 0;\
    \ i < arr.length; i++) {\n    maxHeap.add(arr[i])\n  }\n  for (let i = 0; i <\
    \ k; i++) {\n    result.push(maxHeap.extractMax())\n  }\n  return result\n}\n",
  "    if (k === 0) {\n        return [];\n    }\n\n    const result: number[] = [arr[0]];\n\
    \    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] > result[0]) {\n\
    \            result.unshift(arr[i]);\n        } else if (arr[i] > result[result.length\
    \ - 1]) {\n            result.push(arr[i]);\n        } else {\n            //\
    \ if arr[i] > result[0] then result.length + 1 > k, not meet the requirement.\n\
    \            // So when we get here, result.length <= k.\n            // We only\
    \ need to insert arr[i] in between result[0] and result[result.length - 1].\n\
    \            let left = 0;\n            let right = result.length - 1;\n     \
    \       while (left < right) {\n                const mid = Math.floor((left +\
    \ right) / 2);\n                if (result[mid] > arr[i]) {\n                \
    \    left = mid + 1;\n                } else {\n                    right = mid;\n\
    \                }\n            }\n            result.splice(left, 0, arr[i]);\n\
    \        }\n        if (result.length > k) {\n            result.pop();\n    \
    \    }\n    }\n    return result;\n}\n\ndescribe(\"maximum\", () => {\n    it(\"\
    0\", () => {\n        assert.deepEqual(maximum([-3, -4, 5], 3), [-4, -3, 5]);\n\
    \    });\n    it(\"1\", () => {\n        assert.deepEqual(maximum([4, -4, 4],\
    \ 2), [4, 4]);\n    });\n    it(\"2\", () => {\n        assert.deepEqual(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1), [2]);\n    });\n});", "    let sortedArr = [...arr].sort((a,\
    \ b) => a - b);\n    return sortedArr.slice(sortedArr.length - k);\n}", "  if\
    \ (k === arr.length) return arr.sort((a, b) => b - a);\n  if (k === 1) return\
    \ [Math.max(...arr)];\n  let result: number[] = [];\n  for (let i = 0; i < k;\
    \ i++) {\n    let max = Math.max(...arr);\n    result.push(max);\n    arr.splice(arr.indexOf(max),\
    \ 1);\n  }\n  return result;\n}\n", "  let result: number[] = [];\n  let sortedArr\
    \ = arr.sort((a, b) => a - b);\n  for (let i = sortedArr.length - 1; i >= sortedArr.length\
    \ - k; i--) {\n    result.push(sortedArr[i]);\n  }\n  return result;\n}\n\nexport\
    \ {maximum};", "    let max = arr.slice(0, k).sort((a, b) => a - b);\n    arr.slice(k).forEach(v\
    \ => {\n        let i = k - 1;\n        while (i >= 0 && v > max[i]) i--;\n  \
    \      if (i < k - 1) max[i + 1] = v;\n    });\n    return max;\n}", "    let\
    \ result: number[] = [];\n    const len = arr.length;\n    if (k > len) {\n  \
    \      throw Error(\"k is larger than arr's length.\");\n    }\n    if (k ===\
    \ len) {\n        return arr.sort((a, b) => a - b);\n    }\n    const tempMax:\
    \ number[] = arr.slice(0, k);\n    const sortedTempMax = tempMax.sort((a, b) =>\
    \ a - b);\n    for (let i = k; i < len; i++) {\n        const num = arr[i];\n\
    \        for (let j = 0; j < k; j++) {\n            if (num > sortedTempMax[j])\
    \ {\n                sortedTempMax[j] = num;\n                break;\n       \
    \     }\n        }\n    }\n    return sortedTempMax;\n}\n\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));", "  const result: number[] = [];\n  for (let i =\
    \ 0; i < k; i++) {\n    let maxNumber = arr[i];\n    let maxIndex = i;\n    for\
    \ (let j = i + 1; j < arr.length; j++) {\n      if (arr[j] > maxNumber) {\n  \
    \      maxNumber = arr[j];\n        maxIndex = j;\n      }\n    }\n    result.push(maxNumber);\n\
    \    const temp = arr[i];\n    arr[i] = arr[maxIndex];\n    arr[maxIndex] = temp;\n\
    \  }\n  return result;\n}\n", "  const stack: number[] = [];\n  for (let i = 0;\
    \ i < arr.length; i++) {\n    let target = arr[i];\n    while (stack.length >\
    \ 0 && stack[stack.length - 1] < target && k > 0) {\n      stack.pop();\n    \
    \  k--;\n    }\n    stack.push(target);\n  }\n  return stack.slice(0, k);\n}\n\
    \ndescribe(\"test maximum k numbers\", () => {\n  it(\"test 1\", () => {\n   \
    \ expect(maximum([-3, -4, 5], 3)).toEqual([-4, -3, 5]);\n  });\n  it(\"test 2\"\
    , () => {\n    expect(maximum([4, -4, 4], 2)).toEqual([4, 4]);\n  });\n  it(\"\
    test 3\", () => {\n    expect(maximum([-3, 2, 1, 2, -1, -2, 1], 1)).toEqual([2]);\n\
    \  });\n});", "    let numberToFind = k;\n    let foundNumbers: number[] = [];\n\
    \    while (numberToFind > 0) {\n        let maximumNumber = arr[0];\n       \
    \ let maximumNumberIndex = 0;\n        for (let i = 0; i < arr.length; i++) {\n\
    \            if (arr[i] > maximumNumber) {\n                maximumNumber = arr[i];\n\
    \                maximumNumberIndex = i;\n            }\n        }\n        arr.splice(maximumNumberIndex,\
    \ 1);\n        foundNumbers.push(maximumNumber);\n        numberToFind--;\n  \
    \  }\n    return foundNumbers;\n}\n", "  let answer: number[] = [];\n  if (k >\
    \ arr.length) return arr;\n  while (answer.length < k) {\n    let max: number\
    \ = -Infinity;\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] >\
    \ max) {\n        max = arr[i];\n      }\n    }\n    arr.splice(arr.indexOf(max),\
    \ 1);\n    answer.push(max);\n  }\n  return answer;\n}\n\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));", "  let result: number[] = [];\n  let max: number\
    \ = Number.MIN_SAFE_INTEGER;\n  let idx: number = 0;\n  let start: number = 0;\n\
    \  let end: number = arr.length - 1;\n  while (k > 0) {\n    max = Number.MIN_SAFE_INTEGER;\n\
    \    for (let i = start; i <= end; i++) {\n      if (arr[i] > max) {\n       \
    \ max = arr[i];\n        idx = i;\n      }\n    }\n    result.push(max);\n   \
    \ if (max > arr[start]) {\n      start = idx;\n    } else {\n      end = idx;\n\
    \    }\n    k--;\n  }\n  return result;\n}\n", "    if (k === 0) {\n        return\
    \ [];\n    }\n    let largest: number[] = [arr[0]];\n    for (let i = 1; i < arr.length;\
    \ i++) {\n        if (arr[i] > largest[0]) {\n            largest.unshift(arr[i]);\n\
    \        } else {\n            largest.push(arr[i]);\n        }\n        if (largest.length\
    \ > k) {\n            largest.pop();\n        }\n    }\n    return largest;\n\
    }\n", "  let sorted = [];\n  for (let i = 0; i < arr.length; i++) {\n    let cur\
    \ = arr[i];\n    for (let j = 0; j < sorted.length; j++) {\n      if (sorted[j]\
    \ < cur) {\n        sorted.splice(j, 0, cur);\n        break;\n      }\n    }\n\
    \    if (sorted.length < k) {\n      sorted.push(cur);\n    }\n  }\n  return sorted.slice(0,\
    \ k);\n}\n", "  arr.sort((a, b) => a - b);\n  return arr.slice(arr.length - k);\n\
    }\n\nconsole.log(maximum([-3, -4, 5], 3)); // [-4, -3, 5]\nconsole.log(maximum([4,\
    \ -4, 4], 2)); // [4, 4]\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1)); //\
    \ [2]", "  let r: number[] = [];\n  let c: number[] = arr.slice();\n  while (k\
    \ > 0) {\n    const max = Math.max(...c);\n    r.push(max);\n    c.splice(c.indexOf(max),\
    \ 1);\n    k--;\n  }\n  return r;\n}\n", "  let sorted: number[] = arr.sort((a,\
    \ b) => b - a);\n  return sorted.slice(0, k);\n}\nconsole.log(maximum([-3, -4,\
    \ 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3, 2,\
    \ 1, 2, -1, -2, 1], 1));", "  let result: number[] = [];\n  let sortedArr = sortArray(arr);\n\
    \  console.log(sortedArr);\n  for (let i = 0; i < k; i++) {\n    result.push(sortedArr[i]);\n\
    \  }\n  return result;\n}\n", "  let a = arr.sort((a, b) => b - a).slice(0, k);\n\
    \  return a;\n}\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4,\
    \ -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  let res:\
    \ number[] = [];\n  let heap: Heap<number> = new Heap<number>(arr, true);\n  for\
    \ (let i = 0; i < k; i++) {\n    res.push(heap.remove());\n  }\n  return res;\n\
    }\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\n\
    console.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "  if (!arr || !arr.length)\
    \ return [];\n  let results: number[] = [];\n  while (k) {\n    let largest =\
    \ Number.MIN_SAFE_INTEGER;\n    let i = 0;\n    while (i < arr.length) {\n   \
    \   if (arr[i] > largest) {\n        largest = arr[i];\n      }\n      i++;\n\
    \    }\n    results.push(largest);\n    arr.splice(arr.indexOf(largest), 1);\n\
    \    k--;\n  }\n  return results;\n}\n", "  if (k > arr.length) throw new Error(\"\
    k is greater than the length of the array\")\n  if (k == arr.length) return arr.sort((a,\
    \ b) => a - b)\n  if (k == 1) return [Math.max(...arr)]\n  let sort = false\n\
    \  let sorted = 0\n  let firstUnsorted = 1\n  let largest = 0\n  let checkIndex\
    \ = 0\n  while (!sort) {\n    if (sorted >= k) {\n      sort = true\n    } else\
    \ {\n      checkIndex = firstUnsorted\n      if (arr[checkIndex] > arr[largest])\
    \ {\n        largest = checkIndex\n      }\n      sorted++\n      firstUnsorted++\n\
    \    }\n  }\n  return arr.slice(largest, largest + k)\n}\n\nconsole.log(maximum([-3,\
    \ -4, 5], 3))\nconsole.log(maximum([4, -4, 4], 2))\nconsole.log(maximum([-3, 2,\
    \ 1, 2, -1, -2, 1], 1))", "  let result: number[] = [];\n  if (k > arr.length)\
    \ return arr;\n  let start = 0;\n  let end = arr.length - 1;\n  while (start <\
    \ end) {\n    if (end < start + k) return result;\n    let temp = partition(arr,\
    \ start, end);\n    if (temp === k - 1) return arr.slice(0, k);\n    if (temp\
    \ < k - 1) {\n      start = temp + 1;\n    } else {\n      end = temp - 1;\n \
    \   }\n  }\n  return result;\n}\n", "  if (k === 0) return [];\n  if (k >= arr.length)\
    \ return arr.sort((a, b) => b - a);\n  return arr.sort((a, b) => b - a).slice(0,\
    \ k);\n}\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4,\
    \ 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "    const max\
    \ = arr.slice(0, k).sort((a, b) => b - a);\n    for (let i = k; i < arr.length;\
    \ i++) {\n        const maxLast: number = max[k - 1];\n        if (arr[i] > maxLast)\
    \ {\n            max.splice(k - 1, 1);\n            for (let j = 0; j < k; j++)\
    \ {\n                if (arr[i] > max[j]) {\n                    max.splice(j,\
    \ 0, arr[i]);\n                    break;\n                }\n            }\n\
    \        }\n    }\n    return max;\n}\nconsole.log(maximum([-3, -4, 5], 3));\n\
    console.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2,\
    \ 1], 1));", "  arr.sort((a, b) => b - a);\n  return arr.slice(0, k);\n}\n", " \
    \   // initialize new array with length k\n    let maxArray: number[] = new Array(k);\n\
    \    // fill with -infinity\n    for (let i = 0; i < k; i++) {\n        maxArray[i]\
    \ = -Infinity;\n    }\n    // go through arr checking if el is greater than min\
    \ of current maxArray\n    for (let el of arr) {\n        if (el > Math.min(...maxArray))\
    \ {\n            // if so, replace min el with new el\n            maxArray[maxArray.indexOf(Math.min(...maxArray))]\
    \ = el;\n        }\n    }\n    // sort maxArray and return\n    return maxArray.sort((a,\
    \ b) => a - b);\n}\n", "    let kArr: number[] = [];\n    let lastMax: number\
    \ = 0;\n    for (let i = 0; i < k; i++) {\n        let max: number = Math.max(...arr);\n\
    \        kArr.push(max);\n        arr.splice(arr.indexOf(max), 1);\n        lastMax\
    \ = max;\n    }\n    return kArr;\n}\n", "  const heap = new Heap<number>([],\
    \ (a, b) => a - b);\n  for (let i = 0; i < arr.length; i++) {\n    heap.add(arr[i]);\n\
    \    if (heap.size() > k) {\n      heap.poll();\n    }\n  }\n  return heap.toArray();\n\
    }\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\n\
    console.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "    return arr.sort((a,\
    \ b) => a - b).slice(-k);\n}\n\nexport { maximum };", "  // your code goes here\n\
    \  let res: number[] = [];\n  for (let i = 0; i < k; i++) {\n    let max = Number.MIN_SAFE_INTEGER;\n\
    \    let index = -1;\n    for (let j = 0; j < arr.length; j++) {\n      if (arr[j]\
    \ > max) {\n        max = arr[j];\n        index = j;\n      }\n    }\n    res.push(max);\n\
    \    arr.splice(index, 1);\n  }\n  return res;\n}\n", "  if (k === 0) return [];\n\
    \  arr.sort((a, b) => b - a);\n  return arr.slice(0, k);\n}\n", "  if (!arr.length)\
    \ return [];\n  const results: number[] = [];\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    while (\n      results.length &&\n      arr[i] > results[results.length\
    \ - 1] &&\n      results.length + arr.length - i > k\n    ) {\n      results.pop();\n\
    \    }\n    if (results.length < k) {\n      results.push(arr[i]);\n    }\n  }\n\
    \  return results;\n}\n\ndescribe(\"maximum\", () => {\n  it(\"Example test cases\"\
    , () => {\n    expect(maximum([-3, -4, 5], 3)).toEqual([-4, -3, 5]);\n    expect(maximum([4,\
    \ -4, 4], 2)).toEqual([4, 4]);\n    expect(maximum([-3, 2, 1, 2, -1, -2, 1], 1)).toEqual([2]);\n\
    \  });\n});", "  if (k >= arr.length) return arr.sort((a, b) => b - a);\n  if\
    \ (k === 1) return [Math.max(...arr)];\n  let temp = arr.slice(0, k);\n  let result\
    \ = [...temp];\n  let min = Math.min(...temp);\n  let minIdx = temp.indexOf(min);\n\
    \  temp.splice(minIdx, 1);\n  for (let i = k; i < arr.length; i++) {\n    if (arr[i]\
    \ > min) {\n      result.splice(minIdx, 1, arr[i]);\n      temp.push(arr[i]);\n\
    \      min = Math.min(...temp);\n      minIdx = temp.indexOf(min);\n      temp.splice(minIdx,\
    \ 1);\n    }\n  }\n  return result;\n}\n", "  const max: number[] = [];\n  let\
    \ count = k;\n  for (let i = 0; i < arr.length; i++) {\n    if (count === 0) break;\n\
    \    const curr = arr[i];\n    if (max.length < k) {\n      max.push(curr);\n\
    \      count--;\n    } else {\n      let inserted = false;\n      for (let j =\
    \ 0; j < max.length; j++) {\n        if (curr > max[j]) {\n          inserted\
    \ = true;\n          max.splice(j, 0, curr);\n          max.pop();\n         \
    \ break;\n        }\n      }\n      if (!inserted) {\n        max.pop();\n   \
    \     max.push(curr);\n      }\n    }\n  }\n  return max;\n}\n", "    // your\
    \ code here\n    let output = []\n    let result = []\n    for (let i = 0; i <\
    \ arr.length; i++) {\n        if (arr[i] > 0) {\n            output.push(arr[i])\n\
    \        }\n    }\n    let sorted = output.sort((a, b) => b - a)\n    let sliced\
    \ = sorted.slice(0, k)\n    for (let i = 0; i < arr.length; i++) {\n        if\
    \ (arr[i] < 0) {\n            result.push(arr[i])\n        }\n    }\n    let reversed\
    \ = result.sort((a, b) => a - b)\n    return [...reversed, ...sliced]\n}\nconsole.log(maximum([-3,\
    \ -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3,\
    \ 2, 1, 2, -1, -2, 1], 1));\n", "  if (k < 1) return []\n  let output: number[]\
    \ = arr.slice(0, k).sort((a, b) => a - b)\n  for (let i = k; i < arr.length; i++)\
    \ {\n    if (arr[i] > output[0]) {\n      output.unshift(arr[i])\n      output.pop()\n\
    \    }\n  }\n  return output\n}\n", "  return arr.sort((a, b) => b - a).slice(0,\
    \ k);\n}\n", "  let results: number[] = [];\n  let index = 0;\n  while (index\
    \ < k) {\n    let maxNum = arr[0];\n    let maxIndex = 0;\n    for (let i = 0;\
    \ i < arr.length; i++) {\n      if (arr[i] > maxNum) {\n        maxNum = arr[i];\n\
    \        maxIndex = i;\n      }\n    }\n    results.push(maxNum);\n    arr.splice(maxIndex,\
    \ 1);\n    index++;\n  }\n  return results;\n}\n\nconsole.log(maximum([-3, -4,\
    \ 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3, 2,\
    \ 1, 2, -1, -2, 1], 1));", "  const length = arr.length;\n  if (k === length)\
    \ {\n    return arr;\n  }\n  return arr.sort((a, b) => a - b).slice(length - k);\n\
    }\n\nconst testArr1 = [-3, -4, 5];\nconst testArr2 = [4, -4, 4];\nconst testArr3\
    \ = [-3, 2, 1, 2, -1, -2, 1];\n\nconsole.log(maximum(testArr1, 3));\nconsole.log(maximum(testArr2,\
    \ 2));\nconsole.log(maximum(testArr3, 1));", "  let result: number[] = [];\n \
    \ let sorted: number[] = arr.sort((a, b) => a - b);\n  for (let i = 0; i < k;\
    \ i++) {\n    result.push(sorted[sorted.length - 1 - i]);\n  }\n  return result;\n\
    }\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4, -4, 4], 2));\n\
    console.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));", "    let result: number[]\
    \ = [];\n    let count: number = 0;\n    while (count < k) {\n        let max:\
    \ number = arr[0];\n        let currentIndex: number = 0;\n        for (let i:\
    \ number = 0; i < arr.length; i++) {\n            if (arr[i] > max) {\n      \
    \          max = arr[i];\n                currentIndex = i;\n            }\n \
    \       }\n        result.push(max);\n        arr.splice(currentIndex, 1);\n \
    \       count++;\n    }\n    return result;\n}\nconsole.log(maximum([-3, -4, 5],\
    \ 3));\nconsole.log(maximum([4, -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2,\
    \ -1, -2, 1], 1));", "  if (k <= 0) return [];\n  if (k >= arr.length) return\
    \ arr.sort((a, b) => b - a);\n  let left = 0;\n  let right = arr.length - 1;\n\
    \  while (left <= right) {\n    const pIdx = partition(arr, left, right);\n  \
    \  if (pIdx === k - 1) {\n      return arr.slice(0, k).sort((a, b) => b - a);\n\
    \    } else if (pIdx < k - 1) {\n      left = pIdx + 1;\n    } else {\n      right\
    \ = pIdx - 1;\n    }\n  }\n  return [];\n}\n", "  if (k === 0) return [];\n  let\
    \ maxHeap = new Heap([], null, ((a, b) => b - a));\n  for (let i = 0; i < arr.length;\
    \ i++) {\n    if (maxHeap.size() < k) {\n      maxHeap.push(arr[i]);\n    } else\
    \ {\n      if (arr[i] > maxHeap.peek()) {\n        maxHeap.pop();\n        maxHeap.push(arr[i]);\n\
    \      }\n    }\n  }\n  return maxHeap.toArray();\n}\n", "  // If a number is\
    \ greater than another number, it's bigger in the heap\n  // Create a heap of\
    \ size k\n  // For each item in the array, if the heap has space, push it on to\
    \ the heap\n  // If the heap is full, then only push the item if it's bigger than\
    \ the smallest item in the heap\n  // Sort the heap\n  // Return the first k items\
    \ of the heap\n  const heap = new MinHeap();\n  const output = [];\n  for (let\
    \ i = 0; i < arr.length; i++) {\n    if (heap.length < k) {\n      heap.push(arr[i]);\n\
    \    } else if (heap.length === k && arr[i] > heap.peak()) {\n      heap.pop();\n\
    \      heap.push(arr[i]);\n    }\n  }\n  heap.sort();\n  for (let i = 0; i < k;\
    \ i++) {\n    output.push(heap.pop());\n  }\n  return output;\n}", "  let heap\
    \ = new Heap();\n  let result = [];\n  for (let i = 0; i < arr.length; i++) {\n\
    \    heap.insert(arr[i]);\n  }\n  for (let i = 0; i < k; i++) {\n    result.push(heap.popMax());\n\
    \  }\n  return result;\n}\n", "  if (k === 0) return [];\n  const result: number[]\
    \ = [];\n  while (k--) {\n    let max = arr[0];\n    let maxIdx = 0;\n    for\
    \ (let i = 1; i < arr.length; i++) {\n      if (arr[i] > max) {\n        max =\
    \ arr[i];\n        maxIdx = i;\n      }\n    }\n    result.push(max);\n    arr.splice(maxIdx,\
    \ 1);\n  }\n  return result;\n}\n\nconsole.log(maximum([-3, -4, 5], 3));\nconsole.log(maximum([4,\
    \ -4, 4], 2));\nconsole.log(maximum([-3, 2, 1, 2, -1, -2, 1], 1));"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
