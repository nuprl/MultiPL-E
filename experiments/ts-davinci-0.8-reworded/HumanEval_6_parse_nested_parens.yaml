name: HumanEval_6_parse_nested_parens
language: ts
prompt: "//Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n// For each of the group, output the deepest\
  \ level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting\
  \ while ((())) has three.\n// >>> parse_nested_parens(\"(()()) ((())) () ((())()())\"\
  )\n// [2, 3, 1, 3]\nfunction parse_nested_parens(paren_string: string): number[]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = parse_nested_parens;\n  assert.deepEqual(candidate(\"\
  (()()) ((())) () ((())()())\"),[2, 3, 1, 3]);\n  assert.deepEqual(candidate(\"()\
  \ (()) ((())) (((())))\"),[1, 2, 3, 4]);\n  assert.deepEqual(candidate(\"(()(())((())))\"\
  ),[4]);\n}\n\ntest();"
completions: ["  //Task 6: Complete this function\n  const parenStack: string[] =\
    \ [];\n  const result: number[] = [];\n  let groupMax: number = 0;\n  let groupTotal:\
    \ number = 0;\n  for (let char of paren_string) {\n    if (char == '(') {\n  \
    \    parenStack.push(char);\n      groupTotal++;\n      if (groupTotal > groupMax)\
    \ {\n        groupMax = groupTotal;\n      }\n    } else if (char == ')') {\n\
    \      parenStack.pop();\n      groupTotal--;\n    } else if (char == ' ') {\n\
    \      result.push(groupMax);\n      groupMax = 0;\n      groupTotal = 0;\n  \
    \  }\n  }\n  result.push(groupMax);\n  return result;\n}\n", "    const parens\
    \ = paren_string.split(\" \");\n    let results: number[] = [];\n    for (let\
    \ i = 0; i < parens.length; i++) {\n        let curr_paren: string = parens[i];\n\
    \        let length: number = curr_paren.length;\n        let count: number =\
    \ 0;\n        for (let j = 0; j < length; j++) {\n            if (curr_paren[j]\
    \ === \"(\") {\n                count++;\n            } else if (curr_paren[j]\
    \ === \")\") {\n                count--;\n            }\n        }\n        results.push(count);\n\
    \    }\n    return results;\n}\n", "    return paren_string.split(' ').map(str\
    \ => {\n        let level = 0;\n        let max_level = 0;\n        for (let c\
    \ of str) {\n            if (c === '(') {\n                level++;\n        \
    \        max_level = Math.max(max_level, level);\n            } else if (c ===\
    \ ')') {\n                level--;\n            }\n        }\n        return max_level;\n\
    \    });\n}\n\nexport {\n    parse_nested_parens\n}", "    const result: number[]\
    \ = [];\n    const paren_groups = paren_string.split(\" \");\n    for (const group\
    \ of paren_groups) {\n        result.push(find_paren_depth(group));\n    }\n \
    \   return result;\n}\n", "  let levels = [];\n  let currentLevel = 0;\n  for\
    \ (let i = 0; i < paren_string.length; i++) {\n    let char = paren_string[i];\n\
    \    if (char === \"(\") {\n      currentLevel++;\n    } else if (char === \"\
    )\") {\n      levels.push(currentLevel);\n      currentLevel--;\n    }\n  }\n\
    \  return levels;\n}\n", "  return paren_string.split(\" \").map(str => get_nested_parens(str));\n\
    }\n\nconsole.log(parse_nested_parens(\"(()()) ((())) () ((())()())\"));\n", " \
    \ const groups = paren_string.split(\" \");\n  const paren_counts = [];\n  for\
    \ (const group of groups) {\n    if (group !== \"\") {\n      let max_count =\
    \ 0;\n      let curr_count = 0;\n      for (const paren of group) {\n        if\
    \ (paren === \"(\") {\n          curr_count++;\n          if (curr_count > max_count)\
    \ {\n            max_count = curr_count;\n          }\n        } else if (paren\
    \ === \")\") {\n          curr_count--;\n        }\n      }\n      paren_counts.push(max_count);\n\
    \    }\n  }\n  return paren_counts;\n}\n\nif (require.main === module) {\n  const\
    \ assert = require(\"assert\");\n  assert.deepEqual(parse_nested_parens(\"(()())\
    \ ((())) () ((())()())\"), [\n    2,\n    3,\n    1,\n    3\n  ]);\n  assert.deepEqual(parse_nested_parens(\"\
    (()) ()()\"), [2, 2]);\n  assert.deepEqual(parse_nested_parens(\"()\"), [1]);\n\
    \  assert.deepEqual(parse_nested_parens(\"(()(()())()((()))()((()))()(()))\"),\
    \ [\n    8\n  ]);\n  assert.deepEqual(parse_nested_parens(\"(()(()())()((()))()((()))()(()))\"\
    ), [\n    8\n  ]);\n  assert.deepEqual(parse_nested_parens(\"(()(()())()((()))()((()))()(()))\"\
    ), [\n    8\n  ]);\n  assert.deepEqual(parse_nested_parens(\"(()(()())()((()))()((()))()(()))\"\
    ), [\n    8\n  ]);\n  assert.deepEqual(parse_nested_parens(\"(()(()())()((()))()((()))()(()))\"\
    ), [\n    8\n  ]);\n  assert.deepEqual(parse_nested", "  const out: number[] =\
    \ [];\n  const split_strings = paren_string.split(\" \");\n  let depth: number;\n\
    \  for (let s of split_strings) {\n    depth = 0;\n    for (let i = 0; i < s.length;\
    \ i++) {\n      if (s[i] === \"(\") {\n        depth++;\n      } else if (s[i]\
    \ === \")\") {\n        depth--;\n      }\n    }\n    out.push(depth);\n  }\n\
    \  return out;\n}\n", "    let res: number[] = [];\n    let cur_max = 0;\n   \
    \ for (let c of paren_string) {\n        if (c === '(') {\n            cur_max++;\n\
    \        } else if (c === ')') {\n            res.push(cur_max);\n           \
    \ cur_max--;\n        }\n    }\n    return res;\n}\n", "  // \n  let res: number[]\
    \ = [];\n  // \n  if (paren_string) {\n    let arr: string[] = paren_string.split(\"\
    \ \");\n    // \n    for (let item of arr) {\n      let num: number = 0;\n   \
    \   // \n      for (let i: number = 0; i < item.length; i++) {\n        if (item[i]\
    \ === \"(\") {\n          num++;\n        } else if (item[i] === \")\") {\n  \
    \        num--;\n        }\n      }\n      // \n      res.push(num);\n    }\n\
    \  }\n  // \n  return res;\n}", "  const paren_groups = paren_string.split(\"\
    \ \");\n  const depths = [];\n  for (let i = 0; i < paren_groups.length; i++)\
    \ {\n    depths.push(get_max_nesting_level(paren_groups[i]));\n  }\n  return depths;\n\
    }\n\nconsole.log(parse_nested_parens(\"(()()) ((())) () ((())()())\"));\n", " \
    \ const spaces = paren_string.split(' ');\n  const list = [];\n  for (let i =\
    \ 0; i < spaces.length; i++) {\n    const st = spaces[i];\n    let max = 0;\n\
    \    let counter = 0;\n    for (let j = 0; j < st.length; j++) {\n      if (st[j]\
    \ === '(') {\n        counter++;\n        if (counter > max) {\n          max\
    \ = counter;\n        }\n      } else if (st[j] === ')') {\n        counter--;\n\
    \      }\n    }\n    list.push(max);\n  }\n  return list;\n}\n", "  const paren_groups\
    \ = paren_string.split(\" \");\n  return paren_groups.map(function(paren_group)\
    \ {\n    const paren_stack = [];\n    let current_depth = 0;\n    let deepest_depth\
    \ = 0;\n    for (let i = 0; i < paren_group.length; i++) {\n      if (paren_group[i]\
    \ === \"(\") {\n        paren_stack.push(paren_group[i]);\n        current_depth\
    \ += 1;\n        if (current_depth > deepest_depth) {\n          deepest_depth\
    \ = current_depth;\n        }\n      } else if (paren_group[i] === \")\") {\n\
    \        if (paren_stack.length === 0) {\n          throw new Error(\"There are\
    \ more right parentheses than left parentheses in this group\");\n        }\n\
    \        paren_stack.pop();\n        current_depth -= 1;\n      }\n    }\n   \
    \ if (paren_stack.length > 0) {\n      throw new Error(\"There are more left parentheses\
    \ than right parentheses in this group\");\n    }\n    return deepest_depth;\n\
    \  });\n}\n", "  if (paren_string.length === 0) {\n    return [];\n  }\n\n  let\
    \ countStack: number[] = [];\n  let maxCount: number = 0;\n  for (let i = 0; i\
    \ < paren_string.length; i++) {\n    if (paren_string[i] === \"(\") {\n      countStack.push(1);\n\
    \    } else if (paren_string[i] === \")\") {\n      let currCount = countStack.pop();\n\
    \      if (currCount === undefined) {\n        // console.log(paren_string[i]);\n\
    \        countStack.push(0);\n      } else {\n        countStack.push(++currCount);\n\
    \        maxCount = Math.max(maxCount, currCount);\n      }\n    }\n  }\n\n  return\
    \ countStack.filter((item) => item === maxCount);\n}\n", "    let paren_groups\
    \ = paren_string.split(\" \");\n    let paren_count = paren_groups.map(group =>\
    \ {\n        let depth = 0;\n        let max_depth = 0;\n        for (let index\
    \ = 0; index < group.length; index++) {\n            if (group[index] === \"(\"\
    ) {\n                depth++;\n            } else if (group[index] === \")\")\
    \ {\n                depth--;\n            }\n            if (depth > max_depth)\
    \ {\n                max_depth = depth;\n            }\n        }\n        return\
    \ max_depth;\n    });\n    return paren_count;\n}", "    const paren_groups =\
    \ paren_string.split(\" \");\n    const result: number[] = [];\n    for (const\
    \ paren_group of paren_groups) {\n        const paren_stack: string[] = [];\n\
    \        let max = 0;\n        for (const paren of paren_group) {\n          \
    \  if (paren === \"(\") {\n                paren_stack.push(paren);\n        \
    \        max = paren_stack.length > max ? paren_stack.length : max;\n        \
    \    } else if (paren === \")\") {\n                paren_stack.pop();\n     \
    \       }\n        }\n        result.push(max);\n    }\n    return result;\n}\n\
    console.log(parse_nested_parens(\"(()()) ((())) () ((())()())\"));", "  const\
    \ result: number[] = [];\n  paren_string.split(\" \").forEach((paren_group: string)\
    \ => {\n    const stack: string[] = [];\n    let count: number = 0;\n    paren_group.split(\"\
    \").forEach((paren: string) => {\n      if (paren === \"(\") {\n        stack.push(paren);\n\
    \        count = count + 1;\n      } else if (paren === \")\") {\n        stack.pop();\n\
    \        count = count - 1;\n      }\n    });\n    result.push(count);\n  });\n\
    \  return result;\n}\n\nconsole.log(parse_nested_parens(\"(()()) ((())) () ((())()())\"\
    ));\n", "  const res: number[] = [];\n  const list: string[] = paren_string.split(\"\
    \ \");\n  for (let i = 0; i < list.length; i++) {\n    let max_depth = 0;\n  \
    \  let cur_depth = 0;\n    for (let j = 0; j < list[i].length; j++) {\n      if\
    \ (list[i][j] === \"(\") {\n        cur_depth++;\n        max_depth = Math.max(max_depth,\
    \ cur_depth);\n      } else if (list[i][j] === \")\") {\n        cur_depth--;\n\
    \      }\n    }\n    res.push(max_depth);\n  }\n  return res;\n}\n\nconsole.log(parse_nested_parens(\"\
    (()()) ((())) () ((())()())\"));\nconsole.log(parse_nested_parens(\"(((((((\"\
    ));\nconsole.log(parse_nested_parens(\"((()))))()\"));\nconsole.log(parse_nested_parens(\"\
    ())(\"));\nconsole.log(parse_nested_parens(\"()\"));\nconsole.log(parse_nested_parens(\"\
    \"));\n", "  return paren_string.split(' ').map(str => {\n    let level = 0;\n\
    \    let max_level = 0;\n    for (let i = 0; i < str.length; i++) {\n      if\
    \ (str[i] === '(') {\n        level++;\n        max_level = Math.max(max_level,\
    \ level);\n      } else if (str[i] === ')') {\n        level--;\n      }\n   \
    \ }\n    return max_level;\n  });\n}\n", "  return paren_string.split(\" \").map(x\
    \ => {\n    var current_depth = 0;\n    var max_depth = 0;\n    x.split(\"\").forEach(y\
    \ => {\n      if (y === \"(\") {\n        current_depth += 1;\n        max_depth\
    \ = Math.max(max_depth, current_depth);\n      } else if (y === \")\") {\n   \
    \     current_depth -= 1;\n      }\n    });\n    return max_depth;\n  });\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
