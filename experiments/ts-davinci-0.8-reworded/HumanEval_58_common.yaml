name: HumanEval_58_common
language: ts
prompt: "//Return sorted unique common elements for two arrays.\n// >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5,\
  \ 3, 2, 8], [3, 2])\n// [2, 3]\nfunction common(l1: number[], l2: number[]): number[]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = common;\n  assert.deepEqual(candidate([1, 4, 3, 34,\
  \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);\n  assert.deepEqual(candidate([5,\
  \ 3, 2, 8], [3, 2]),[2, 3]);\n  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2,\
  \ 4]),[2, 3, 4]);\n  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);\n}\n\ntest();"
completions: ["    //Your code here\n    return l1.filter(value => l2.includes(value));\n\
    }\n", "    return unique(l1.concat(l2)).sort((a, b) => a - b);\n}\n\nexport default\
    \ common;", "    //TODO\n    return [];\n}\n", "  //  var l1_set = new Set(l1)\n\
    \  //  var l2_set = new Set(l2)\n  //  return [...l1_set].filter(x => l2_set.has(x))\n\
    \  return Array.from(new Set(l1.filter(x => l2.includes(x))));\n}\n", "    let\
    \ outList: number[] = [];\n    for (let i of l1) {\n        if (l2.includes(i)\
    \ && !outList.includes(i)) {\n            outList.push(i);\n        }\n    }\n\
    \    return outList.sort((a, b) => a - b);\n}\n", "    //\n    // Check if two\
    \ arrays have common elements, if there isn't any return empty array.\n    if\
    \ (Array.isArray(l1) && Array.isArray(l2) && l1.length != 0 && l2.length != 0)\
    \ {\n        let arr1: number[] = l1.sort(sortFunc);\n        let arr2: number[]\
    \ = l2.sort(sortFunc);\n        let newArr: number[] = [];\n        let i: number\
    \ = 0;\n        let j: number = 0;\n        let arr1Size: number = arr1.length;\n\
    \        let arr2Size: number = arr2.length;\n        // Two loop to find common\
    \ elements for two arrays and add them to newArr.\n        while (i < arr1Size\
    \ && j < arr2Size) {\n            if (arr1[i] < arr2[j]) {\n                i\
    \ += 1;\n            } else if (arr1[i] > arr2[j]) {\n                j += 1;\n\
    \            } else {\n                newArr.push(arr1[i]);\n               \
    \ i += 1;\n                j += 1;\n            }\n        }\n        return newArr;\n\
    \    } else {\n        return [];\n    }\n}\n\n", "  return [...new Set(l1.filter(i\
    \ => l2.includes(i)))].sort((a, b) => a - b);\n}\n", "    return l1.filter(i =>\
    \ l2.includes(i)).sort().filter((num, pos, arr) => arr.indexOf(num) === pos);\n\
    }\nconsole.log(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]));\n\
    console.log(common([5, 3, 2, 8], [3, 2]));\n", "    return l1.filter(x => l2.includes(x)).sort((a,\
    \ b) => a - b).filter((e, i, a) => i === a.indexOf(e));\n}\n", "    const list1:\
    \ Set<number> = new Set(l1);\n    const list2: Set<number> = new Set(l2);\n  \
    \  const intersection: Set<number> = new Set([...list1].filter(x => list2.has(x)));\n\
    \    return [...intersection].sort();\n}\n", "    return l1.filter(function (item:\
    \ number) {\n        return l2.indexOf(item) !== -1;\n    });\n}\n", "  return\
    \ Array.from(new Set(l1.filter(item => l2.includes(item))));\n}\n", "    return\
    \ [...new Set(l1.filter(x => l2.includes(x)))].sort((a, b) => a - b);\n}\n", " \
    \ return [...new Set(l1.filter(n => l2.includes(n)))].sort((a, b) => a - b);\n\
    }\n", "    let set1 = new Set(l1);\n    let set2 = new Set(l2);\n    let common\
    \ = [...set1].filter(x => set2.has(x));\n    return common.sort();\n}\n", "  const\
    \ uniqueNumbers = new Set([...l1, ...l2]);\n  return [...uniqueNumbers].sort((a,\
    \ b) => a - b);\n}\n", "  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n\
    \  const commonSet = [...set1].filter(e => set2.has(e));\n  return commonSet.sort((a,\
    \ b) => a - b);\n}\n", "    let set1 = new Set(l1);\n    let set2 = new Set(l2);\n\
    \    return Array.from(set1).filter(x => set2.has(x));\n}\n\ntest(common, [[1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]], [1, 5, 653]);\ntest(common,\
    \ [[5, 3, 2, 8], [3, 2]], [2, 3]);\n", "  const longerList = l1.length >= l2.length\
    \ ? l1 : l2;\n  const shorterList = l1.length < l2.length ? l1 : l2;\n  const\
    \ hashMap = {};\n  for (let i = 0; i < longerList.length; i++) {\n    if (shorterList.includes(longerList[i]))\
    \ {\n      hashMap[longerList[i]] = 0;\n    }\n  }\n  return Object.keys(hashMap).map(item\
    \ => Number(item));\n}", "    let result: number[] = [];\n    for (let index =\
    \ 0; index < l1.length; index++) {\n        if (l2.includes(l1[index])) {\n  \
    \          result.push(l1[index]);\n        }\n    }\n    return result.sort().filter((item,\
    \ pos, ary) => {\n        return !pos || item != ary[pos - 1];\n    });\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
