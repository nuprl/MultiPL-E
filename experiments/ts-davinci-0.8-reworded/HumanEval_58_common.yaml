name: HumanEval_58_common
language: ts
prompt: "//Return sorted unique common elements for two arrays.\n// >>> common([1,\
  \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5,\
  \ 3, 2, 8], [3, 2])\n// [2, 3]\nfunction common(l1: number[], l2: number[]): number[]\
  \ {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = common;\n  assert.deepEqual(candidate([1, 4, 3, 34,\
  \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),[1, 5, 653]);\n  assert.deepEqual(candidate([5,\
  \ 3, 2, 8], [3, 2]),[2, 3]);\n  assert.deepEqual(candidate([4, 3, 2, 8], [3, 2,\
  \ 4]),[2, 3, 4]);\n  assert.deepEqual(candidate([4, 3, 2, 8], []),[]);\n}\n\ntest();"
completions: ["    //Your code here\n    return l1.filter(value => l2.includes(value));\n\
    }\n", "    return unique(l1.concat(l2)).sort((a, b) => a - b);\n}\n\nexport default\
    \ common;", "    //TODO\n    return [];\n}\n", "  //  var l1_set = new Set(l1)\n\
    \  //  var l2_set = new Set(l2)\n  //  return [...l1_set].filter(x => l2_set.has(x))\n\
    \  return Array.from(new Set(l1.filter(x => l2.includes(x))));\n}\n", "    let\
    \ outList: number[] = [];\n    for (let i of l1) {\n        if (l2.includes(i)\
    \ && !outList.includes(i)) {\n            outList.push(i);\n        }\n    }\n\
    \    return outList.sort((a, b) => a - b);\n}\n", "    //\n    // Check if two\
    \ arrays have common elements, if there isn't any return empty array.\n    if\
    \ (Array.isArray(l1) && Array.isArray(l2) && l1.length != 0 && l2.length != 0)\
    \ {\n        let arr1: number[] = l1.sort(sortFunc);\n        let arr2: number[]\
    \ = l2.sort(sortFunc);\n        let newArr: number[] = [];\n        let i: number\
    \ = 0;\n        let j: number = 0;\n        let arr1Size: number = arr1.length;\n\
    \        let arr2Size: number = arr2.length;\n        // Two loop to find common\
    \ elements for two arrays and add them to newArr.\n        while (i < arr1Size\
    \ && j < arr2Size) {\n            if (arr1[i] < arr2[j]) {\n                i\
    \ += 1;\n            } else if (arr1[i] > arr2[j]) {\n                j += 1;\n\
    \            } else {\n                newArr.push(arr1[i]);\n               \
    \ i += 1;\n                j += 1;\n            }\n        }\n        return newArr;\n\
    \    } else {\n        return [];\n    }\n}\n\n", "  return [...new Set(l1.filter(i\
    \ => l2.includes(i)))].sort((a, b) => a - b);\n}\n", "    return l1.filter(i =>\
    \ l2.includes(i)).sort().filter((num, pos, arr) => arr.indexOf(num) === pos);\n\
    }\nconsole.log(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]));\n\
    console.log(common([5, 3, 2, 8], [3, 2]));\n", "    return l1.filter(x => l2.includes(x)).sort((a,\
    \ b) => a - b).filter((e, i, a) => i === a.indexOf(e));\n}\n", "    const list1:\
    \ Set<number> = new Set(l1);\n    const list2: Set<number> = new Set(l2);\n  \
    \  const intersection: Set<number> = new Set([...list1].filter(x => list2.has(x)));\n\
    \    return [...intersection].sort();\n}\n", "    return l1.filter(function (item:\
    \ number) {\n        return l2.indexOf(item) !== -1;\n    });\n}\n", "  return\
    \ Array.from(new Set(l1.filter(item => l2.includes(item))));\n}\n", "    return\
    \ [...new Set(l1.filter(x => l2.includes(x)))].sort((a, b) => a - b);\n}\n", " \
    \ return [...new Set(l1.filter(n => l2.includes(n)))].sort((a, b) => a - b);\n\
    }\n", "    let set1 = new Set(l1);\n    let set2 = new Set(l2);\n    let common\
    \ = [...set1].filter(x => set2.has(x));\n    return common.sort();\n}\n", "  const\
    \ uniqueNumbers = new Set([...l1, ...l2]);\n  return [...uniqueNumbers].sort((a,\
    \ b) => a - b);\n}\n", "  const set1 = new Set(l1);\n  const set2 = new Set(l2);\n\
    \  const commonSet = [...set1].filter(e => set2.has(e));\n  return commonSet.sort((a,\
    \ b) => a - b);\n}\n", "    let set1 = new Set(l1);\n    let set2 = new Set(l2);\n\
    \    return Array.from(set1).filter(x => set2.has(x));\n}\n\ntest(common, [[1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]], [1, 5, 653]);\ntest(common,\
    \ [[5, 3, 2, 8], [3, 2]], [2, 3]);\n", "  const longerList = l1.length >= l2.length\
    \ ? l1 : l2;\n  const shorterList = l1.length < l2.length ? l1 : l2;\n  const\
    \ hashMap = {};\n  for (let i = 0; i < longerList.length; i++) {\n    if (shorterList.includes(longerList[i]))\
    \ {\n      hashMap[longerList[i]] = 0;\n    }\n  }\n  return Object.keys(hashMap).map(item\
    \ => Number(item));\n}", "    let result: number[] = [];\n    for (let index =\
    \ 0; index < l1.length; index++) {\n        if (l2.includes(l1[index])) {\n  \
    \          result.push(l1[index]);\n        }\n    }\n    return result.sort().filter((item,\
    \ pos, ary) => {\n        return !pos || item != ary[pos - 1];\n    });\n}\n",
  "    return l1.filter(e1 => l2.includes(e1)).sort().reduce((l, e) => {\n       \
    \ if (!l.includes(e)) {\n            l.push(e);\n        }\n        return l;\n\
    \    }, []);\n}\n", "  return l1.filter(a => l2.includes(a)).sort((a, b) => a\
    \ - b);\n}\n", "    return (l1.filter(x => l2.includes(x))).sort().filter((value,\
    \ index, self) => self.indexOf(value) === index);\n}\n", "  return Array.from(new\
    \ Set(l1)).filter(x => l2.includes(x));\n}\n", "    return l1.concat(l2).sort().filter((value,\
    \ index, array) => {\n        return value === array[index + 1] && value !== array[index\
    \ - 1];\n    });\n}\n", "    const result: number[] = [];\n    let i: number =\
    \ 0;\n    let j: number = 0;\n    while (i < l1.length && j < l2.length) {\n \
    \       if (l1[i] === l2[j]) {\n            if (result.length === 0 || result[result.length\
    \ - 1] !== l1[i]) {\n                result.push(l1[i]);\n            }\n    \
    \        i++;\n            j++;\n        } else if (l1[i] < l2[j]) {\n       \
    \     i++;\n        } else {\n            j++;\n        }\n    }\n    return result;\n\
    }\n", "    return [...new Set(l1.filter(i => l2.includes(i)).sort((a, b) => a\
    \ - b))];\n}\n", "  return [];\n}\n", "  return Array.from(new Set(l1.filter(x\
    \ => l2.includes(x))));\n}\n", "  return l1.filter(a => l2.includes(a)).sort();\n\
    }\n", "    // TODO:\n    return [];\n}\n", "    return l1.filter(n => l2.includes(n)).sort((a,\
    \ b) => a - b);\n}\n", "  var l3 = [];\n  for (var j = 0; j < l1.length; j++)\
    \ {\n    for (var i = 0; i < l2.length; i++) {\n      if (l1[j] === l2[i]) {\n\
    \        l3.push(l1[j]);\n      }\n    }\n  }\n  return l3;\n}\n", "    return\
    \ unique(l1.filter(element => l2.includes(element)));\n}\n", "    return [...new\
    \ Set(l1.filter(e => l2.includes(e)))].sort((a, b) => a - b);\n}\n\n", "    let\
    \ result = [];\n    l1.forEach(el => {\n        if (l2.includes(el) && !result.includes(el))\
    \ {\n            result.push(el);\n        }\n    });\n    return result.sort((a,\
    \ b) => a - b);\n}\n", "    return new Set([...l1, ...l2]).values();\n}\n", " \
    \ const set1 = new Set(l1);\n  const set2 = new Set(l2);\n  const commonElems\
    \ = new Set();\n  set1.forEach(n => {\n    if (set2.has(n)) {\n      commonElems.add(n);\n\
    \    }\n  });\n  return Array.from(commonElems);\n}\n", "  return [...new Set(l1.filter(x\
    \ => l2.includes(x)).sort())];\n}\n", "    return []\n}\n", "    let result: number[]\
    \ = [];\n    l1.sort();\n    l2.sort();\n    if (l1.length > l2.length) {\n  \
    \      for (let i = 0; i < l1.length; i++) {\n            if (l2.includes(l1[i]))\
    \ {\n                result.push(l1[i]);\n            }\n        }\n    } else\
    \ {\n        for (let i = 0; i < l2.length; i++) {\n            if (l1.includes(l2[i]))\
    \ {\n                result.push(l2[i]);\n            }\n        }\n    }\n  \
    \  return result;\n}\n", "    const s = new Set();\n    for (const e of l1) {\n\
    \        if (l2.includes(e)) {\n            s.add(e);\n        }\n    }\n    return\
    \ Array.from(s);\n}\n", "    return [...new Set(l1.filter(value => l2.includes(value)))].sort((a,\
    \ b) => a - b);\n}\n", "    return unique(l1.filter(e => l2.includes(e)));\n}\n",
  "  const [l1u, l2u] = [...l1, ...l2].sort().reduce(([l1u, l2u], val) => {\n    if\
    \ (l1.includes(val) && !l1u.includes(val)) l1u.push(val);\n    if (l2.includes(val)\
    \ && !l2u.includes(val)) l2u.push(val);\n    return [l1u, l2u];\n  }, [[], []]);\n\
    \  return l1u.filter(val => l2u.includes(val));\n}\n", "  return [...new Set(l1.filter(x\
    \ => l2.includes(x)))].sort((a, b) => a - b);\n}\n", "    let result = []\n  \
    \  let uniq = new Set(l1.concat(l2))\n    for (let value of uniq) {\n        if\
    \ (l1.includes(value) && l2.includes(value)) {\n            result.push(value)\n\
    \        }\n    }\n    return result\n}\n\ntest(common([1, 4, 3, 34, 653, 2, 5],\
    \ [5, 7, 1, 5, 9, 653, 121]), [1, 5, 653])\ntest(common([5, 3, 2, 8], [3, 2]),\
    \ [2, 3])\n", "    return [...new Set(l1.filter(n => l2.includes(n)))].sort((a,\
    \ b) => a - b);\n}\n", "  return [...l1, ...l2].sort().filter((value, index, array)\
    \ => array.indexOf(value) === index && array.lastIndexOf(value) !== index);\n\
    }\n", "  const l3 = [];\n  for (let i of l1) {\n    for (let j of l2) {\n    \
    \  if (i === j) {\n        l3.push(i);\n      }\n    }\n  }\n  return l3.sort().filter((item,\
    \ index) => l3.indexOf(item) === index);\n}\nconsole.log(common([1, 4, 3, 34,\
    \ 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]));\nconsole.log(common([5, 3, 2, 8], [3,\
    \ 2]));\n", "    return [...new Set(l1.filter(e => l2.includes(e)))].sort((a,\
    \ b) => a - b);\n}\n", "  let l3 = [];\n  for (let i = 0; i < l1.length; i++)\
    \ {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i] === l2[j]) {\n\
    \        l3.push(l1[i]);\n      }\n    }\n  }\n  return l3;\n}\n", "    let unique:\
    \ number[] = l1.filter(element => {\n        return l2.includes(element);\n  \
    \  })\n    return Array.from(new Set(unique));\n}\n", "    let m = new Map<number,\
    \ number>();\n    for (let i of l1) {\n        if (m.has(i)) {\n            m.set(i,\
    \ m.get(i) + 1);\n        } else {\n            m.set(i, 1);\n        }\n    }\n\
    \    let res: number[] = [];\n    for (let i of l2) {\n        if (m.has(i)) {\n\
    \            res.push(i);\n            if (m.get(i) === 1) {\n               \
    \ m.delete(i);\n            } else {\n                m.set(i, m.get(i) - 1);\n\
    \            }\n        }\n    }\n    return res;\n}\n", "    return l1.concat(l2).filter((item,\
    \ idx, self) => self.indexOf(item) === idx).sort((a, b) => a - b);\n}\n\ntest(common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]), [1, 5, 653]);\ntest(common([5,\
    \ 3, 2, 8], [3, 2]), [2, 3]);\n", "  const unique = (elem: number, index: number,\
    \ array: number[]) => array.indexOf(elem) === index;\n  const common = (elem:\
    \ number, index: number, array: number[]) => l2.indexOf(elem) !== -1;\n  return\
    \ l1.filter(unique).filter(common).sort((a, b) => a - b);\n}\n", "    return Array.from(new\
    \ Set(l1)).filter(n => l2.includes(n)).sort((a, b) => a - b);\n}\n", "  var list1\
    \ = l1.sort();\n  var list2 = l2.sort();\n  var result = [];\n  for (var i = 0;\
    \ i < list1.length; i++) {\n    if (list2.indexOf(list1[i]) !== -1) {\n      result.push(list1[i]);\n\
    \    }\n  }\n  return result;\n}\n", "    return [...new Set(l1.filter(x => l2.includes(x)))].sort();\n\
    }\nconsole.log(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]));\n\
    \n", "  return l1.filter(l => l2.includes(l)).sort((a, b) => a - b);\n}\n", " \
    \   const res = l1.filter(item => l2.includes(item));\n    return [...new Set(res)].sort((a,\
    \ b) => a - b);\n}\n", "    return unique(l1.filter(v => l2.includes(v)));\n}\n",
  "  const u1 = sort(unique(l1));\n  const u2 = sort(unique(l2));\n  let i1 = 0;\n\
    \  let i2 = 0;\n  const len1 = u1.length;\n  const len2 = u2.length;\n  const\
    \ res: number[] = [];\n  while (i1 < len1 && i2 < len2) {\n    if (u1[i1] < u2[i2])\
    \ {\n      i1++;\n    } else if (u1[i1] > u2[i2]) {\n      i2++;\n    } else {\n\
    \      res.push(u1[i1]);\n      i1++;\n      i2++;\n    }\n  }\n  return res;\n\
    }\n", "    return [...new Set(l1.filter(num => l2.includes(num)))].sort((a, b)\
    \ => a - b);\n}\n", "    let hash = {};\n    for (let i = 0; i < l1.length; i++)\
    \ {\n        if (hash[l1[i]]) {\n            hash[l1[i]] += 1;\n        } else\
    \ {\n            hash[l1[i]] = 1;\n        }\n    }\n    let result = [];\n  \
    \  for (let i = 0; i < l2.length; i++) {\n        if (hash[l2[i]]) {\n       \
    \     result.push(l2[i]);\n        }\n    }\n    return result;\n}\n", "    return\
    \ new Set([...l1, ...l2]).values();\n}\n", "    return [...new Set(l1.filter(i\
    \ => l2.includes(i)))].sort((a, b) => a - b);\n}\n\n", "    var c1 = l1.filter(item\
    \ => l2.includes(item)).sort((a, b) => a - b);\n    var s = [];\n    for (var\
    \ v of c1) {\n        if (!s.includes(v)) {\n            s.push(v);\n        }\n\
    \    }\n    return s;\n}\n", "    const list1 = l1.slice().sort((a, b) => a -\
    \ b);\n    const list2 = l2.slice().sort((a, b) => a - b);\n    let i = 0;\n \
    \   let j = 0;\n    const arr: number[] = [];\n    while (i < list1.length &&\
    \ j < list2.length) {\n        if (list1[i] === list2[j]) {\n            arr.push(list1[i]);\n\
    \            i++;\n            j++;\n        } else if (list1[i] < list2[j]) {\n\
    \            i++;\n        } else {\n            j++;\n        }\n    }\n    return\
    \ arr;\n}\n", "    return Array.from(new Set(l1.filter(e => l2.includes(e))))\n\
    }\n", "    return [...new Set(l1.filter(x => l2.includes(x)))].sort((a, b) =>\
    \ a - b);\n}\n", "  var s1 = new Set(l1)\n  var s2 = new Set(l2)\n  return [...new\
    \ Set([...s1].filter(x => s2.has(x)))]\n}\n\n", "    let m = new Map<number, number>();\n\
    \    for (let i = 0; i < l1.length; i++) {\n        m.set(l1[i], 0);\n    }\n\
    \    for (let i = 0; i < l2.length; i++) {\n        if (m.has(l2[i])) {\n    \
    \        m.set(l2[i], m.get(l2[i]) + 1);\n        }\n    }\n    let res: number[]\
    \ = [];\n    m.forEach((value, key) => {\n        if (value > 0) {\n         \
    \   res.push(key);\n        }\n    });\n    return res;\n}\n", "  return []\n\
    }\n", "    return Array.from(new Set(l1.filter(e => l2.includes(e))))\n}\nconsole.log(common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]))\nconsole.log(common([5, 3,\
    \ 2, 8], [3, 2]))\n", "    let uniq = new Set([...l1, ...l2]);\n    return [...uniq].sort((a,\
    \ b) => a - b);\n}\n", "  return [...new Set(l1.filter(v => l2.includes(v)))].sort((a,\
    \ b) => a - b);\n}\n", "    return [...new Set(l1.filter(n => l2.includes(n)))].sort((a,\
    \ b) => a - b);\n}\n", "  let result: number[] = [];\n  let set1 = new Set(l1);\n\
    \  let set2 = new Set(l2);\n  for (let i of set1) {\n    if (set2.has(i)) {\n\
    \      result.push(i);\n    }\n  }\n  return result;\n}\n", "    const set1 =\
    \ new Set(l1);\n    const set2 = new Set(l2);\n    const res = new Set([]);\n\
    \    set1.forEach(i => {\n        if (set2.has(i)) {\n            res.add(i);\n\
    \        }\n    });\n    return [...res];\n}\n", "  return [...new Set(l1.filter(el\
    \ => l2.includes(el)))].sort();\n}\n", "    let result: number[] = [];\n    let\
    \ s1: number[] = l1.sort((a, b) => a - b);\n    let s2: number[] = l2.sort((a,\
    \ b) => a - b);\n    let i = 0;\n    let j = 0;\n    while (i < s1.length && j\
    \ < s2.length) {\n        if (s1[i] < s2[j]) i++;\n        else if (s1[i] > s2[j])\
    \ j++;\n        else if (s1[i] === s2[j]) {\n            result.push(s1[i]);\n\
    \            i++;\n            j++;\n        }\n    }\n    return result;\n}\n\
    \ntest('common', () => {\n    expect(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])).toEqual([1, 5, 653]);\n    expect(common([5, 3, 2, 8], [3,\
    \ 2])).toEqual([2, 3]);\n});\n", "  // your code here\n  return [];\n}\n", " \
    \   return [...new Set(l1.filter(i => l2.includes(i)))].sort((a, b) => a - b);\n\
    }\n", "    return [...new Set(l1.filter(x => l2.includes(x)))].sort((a, b) =>\
    \ a - b);\n}\n", "  const longList = l1.length > l2.length ? l1 : l2;\n  const\
    \ shortList = l1.length > l2.length ? l2 : l1;\n  const shortListSet = new Set(shortList);\n\
    \  const shortListLen = shortList.length;\n  const resList: number[] = [];\n \
    \ let cnt = 0;\n  let idx = 0;\n  while (cnt < shortListLen) {\n    if (shortListSet.has(longList[idx]))\
    \ {\n      resList.push(longList[idx]);\n      cnt++;\n    }\n    idx++;\n  }\n\
    \  return resList;\n}\n", "    const result = [];\n    l1.forEach(el => {\n  \
    \      if (l2.includes(el) && !result.includes(el)) {\n            result.push(el);\n\
    \        }\n    });\n    return result.sort((a, b) => a - b);\n}\n", "    let\
    \ output: number[] = [];\n    for (let i = 0; i < l1.length; i++) {\n        for\
    \ (let j = 0; j < l2.length; j++) {\n            if (l1[i] === l2[j]) {\n    \
    \            output.push(l1[i]);\n            }\n        }\n    }\n    return\
    \ output.sort();\n}\n", "    const l1Unique = l1.filter((i, pos) => l1.indexOf(i)\
    \ === pos)\n    const l2Unique = l2.filter((i, pos) => l2.indexOf(i) === pos)\n\
    \    const merge = [...l1Unique, ...l2Unique]\n    return merge.filter((i, pos)\
    \ => merge.indexOf(i) === pos)\n}\n", "    return [...new Set(l1.filter(e => l2.includes(e)).sort((a,\
    \ b) => a - b))];\n}\n", "    return Array.from(new Set(l1.filter(item => l2.includes(item))));\n\
    }\n", "  return l1.filter(e => l2.includes(e)).sort((a, b) => a - b);\n}\n", " \
    \ return [...new Set(l1.filter(x => l2.includes(x)))].sort((a, b) => a - b);\n\
    }\n", "  let d = [];\n  return l1.filter(function(n) {\n    return d.indexOf(n)\
    \ === -1 && d.push(n) && l2.indexOf(n) !== -1;\n  });\n}\n", "    return _.intersection(l1,\
    \ l2);\n}\n", "  return l1.filter(function(n) {\n    return l2.indexOf(n) !==\
    \ -1;\n  }).sort();\n}", "  return Array.from(new Set(l1.filter(n => l2.includes(n))));\n\
    }\n\nexport function common_v2(l1: number[], l2: number[]): number[] {\n  return\
    \ l1.filter(n => l2.includes(n)).sort((a, b) => a - b);\n}\n\nexport function\
    \ common_v3(l1: number[], l2: number[]): number[] {\n  return [...new Set(l1.filter(n\
    \ => l2.includes(n)))];\n}\n", "  //create a new array that is made up of common\
    \ elements\n  let commonElements: number[] = [];\n  //for loop over l1 array\n\
    \  for (let l1 of l1) {\n    //for loop over l2 array\n    for (let l2 of l2)\
    \ {\n      //if l1 element === l2 element\n      if (l1 === l2) {\n        //add\
    \ to the commonElements array\n        commonElements.push(l1);\n      }\n   \
    \ }\n  }\n  //return the sorted commonElements array\n  return commonElements.sort();\n\
    }\n\nconsole.log(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]));\n",
  "  const shorter = l1.length < l2.length ? l1 : l2;\n  const longer = l1.length\
    \ < l2.length ? l2 : l1;\n  return shorter.filter(val => longer.includes(val)).sort((a,\
    \ b) => a - b);\n}\n", "    const l3 = [];\n    const l4 = [];\n    const l5 =\
    \ [];\n    for (let i = 0; i < l1.length; i++) {\n        if (l2.includes(l1[i]))\
    \ {\n            l3.push(l1[i]);\n        }\n    }\n    for (let i = 0; i < l2.length;\
    \ i++) {\n        if (l1.includes(l2[i])) {\n            l4.push(l2[i]);\n   \
    \     }\n    }\n    for (let i = 0; i < l3.length; i++) {\n        if (l4.includes(l3[i]))\
    \ {\n            l5.push(l3[i]);\n        }\n    }\n    return [...new Set(l5)].sort((a,\
    \ b) => a - b);\n}", "    // commonItems.sort();\n    let commonItems = [],\n\
    \        map = new Map();\n    for (let item of l1) {\n        map.set(item, true);\n\
    \    }\n    for (let item of l2) {\n        if (map.get(item)) {\n           \
    \ commonItems.push(item);\n        }\n    }\n    return commonItems;\n}\n", " \
    \ return [...new Set(l1.filter(x => l2.includes(x)))].sort((a, b) => a - b);\n\
    }\n", "  return l1.filter(e => l2.includes(e));\n}\n", "    return Array.from(new\
    \ Set(l1.filter(x => l2.includes(x)).sort()));\n}\n", "    return Array.from(new\
    \ Set(l1.filter(e => l2.includes(e)).sort((a, b) => a - b)));\n}\n", "    let\
    \ result = [];\n    for (let i = 0; i < l1.length; i++) {\n        if (l2.includes(l1[i]))\
    \ {\n            result.push(l1[i]);\n        }\n    }\n    return result.sort((a,\
    \ b) => a - b);\n}\n", "    //Your code here\n    return [];\n}\n\n", "  return\
    \ [...new Set(l1.filter(val => l2.includes(val)))].sort((a, b) => a - b);\n}\n",
  "    let res: number[] = [];\n    let i = 0;\n    let j = 0;\n    l1.sort((a, b)\
    \ => a - b);\n    l2.sort((a, b) => a - b);\n    while (i < l1.length && j < l2.length)\
    \ {\n        if (l1[i] === l2[j]) {\n            res.push(l1[i]);\n          \
    \  i++;\n            j++;\n        } else if (l1[i] < l2[j]) {\n            i++;\n\
    \        } else {\n            j++;\n        }\n    }\n    return res;\n}\n\n\
    export { common };", "    return l1.filter(function (e) {\n        return l2.indexOf(e)\
    \ !== -1;\n    }).sort().filter(function (e, i, l) {\n        return i === 0 ||\
    \ e !== l[i - 1];\n    });\n}\n\ntest(\"16. Find the common elements for two arrays.\"\
    , function () {\n    deepEqual(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9,\
    \ 653, 121]), [1, 5, 653]);\n    deepEqual(common([5, 3, 2, 8], [3, 2]), [2, 3]);\n\
    });\n", "    return [...new Set(l1.filter(x => l2.includes(x)))].sort((a, b) =>\
    \ a - b);\n}\n", "    const list1 = l1.sort();\n    const list2 = l2.sort();\n\
    \    const [short, long] = list1.length > list2.length ? [list2, list1] : [list1,\
    \ list2];\n    const result: number[] = [];\n    let iter = 0;\n    for (let i\
    \ = 0; i < short.length; i++) {\n        while (iter < long.length && long[iter]\
    \ < short[i]) {\n            iter++;\n        }\n        if (iter < long.length\
    \ && long[iter] === short[i]) {\n            result.push(short[i]);\n        }\n\
    \    }\n    return result;\n}\n", "    const map = new Map<number, number>();\n\
    \    l1.forEach(i => {\n        if (map.has(i)) map.set(i, map.get(i) + 1);\n\
    \        else map.set(i, 1);\n    });\n    return l2.filter(e => {\n        if\
    \ (map.has(e)) {\n            const count = map.get(e);\n            if (count\
    \ > 1) map.set(e, count - 1);\n            else map.delete(e);\n            return\
    \ true;\n        }\n        return false;\n    });\n}\n", "  return [...new Set(l1.filter(x\
    \ => l2.includes(x)))].sort((a, b) => a - b);\n}", "  return [...new Set(l1.filter(v\
    \ => l2.includes(v)))].sort();\n}", "    let l3 = []\n    for (let i of l1) {\n\
    \        if (l2.includes(i)) {\n            l3.push(i)\n        }\n    }\n   \
    \ l3.sort((a, b) => a - b)\n    return l3\n}", "  let res: number[] = []\n  for\
    \ (let num of l1) {\n    if (l2.includes(num) && !res.includes(num)) {\n     \
    \ res.push(num)\n    }\n  }\n  return res.sort((a, b) => a - b)\n}\n", "  var\
    \ result: number[] = [];\n  l1.forEach(function(a){\n    l2.forEach(function(b){\n\
    \      if (a === b && result.indexOf(a) === -1) {\n        result.push(a);\n \
    \     }\n    });\n  });\n  return result.sort(function(a, b){\n    return a -\
    \ b;\n  });\n}\n", "    let result: number[] = []\n    let i = 0\n    let j =\
    \ 0\n    while (i < l1.length && j < l2.length) {\n        if (l1[i] === l2[j])\
    \ {\n            if (result.indexOf(l1[i]) === -1) result.push(l1[i])\n      \
    \      i++\n            j++\n        } else if (l1[i] < l2[j]) {\n           \
    \ i++\n        } else {\n            j++\n        }\n    }\n    return result\n\
    }\n", "    let uniqs = new Set();\n    for (let i = 0; i < l1.length; i++) {\n\
    \        if (l2.includes(l1[i])) {\n            uniqs.add(l1[i]);\n        }\n\
    \    }\n    return Array.from(uniqs).sort();\n}\n", "    return [...new Set(l1.filter(v\
    \ => l2.includes(v)))].sort((a, b) => a - b);\n}\n", "    return [...new Set(l1.filter(x\
    \ => l2.includes(x)))].sort((a, b) => a - b);\n}\n", "  return Array.from(new\
    \ Set(l1)).filter(num => l2.includes(num));\n}\n", "    return l1.filter(n =>\
    \ l2.includes(n));\n}\n", "  const result: number[] = [];\n  for (let i = 0; i\
    \ < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n      if (l1[i]\
    \ === l2[j]) {\n        result.push(l1[i]);\n      }\n    }\n  }\n  return [...new\
    \ Set(result)];\n}\n", "    return [...new Set(l1.filter(x => l2.includes(x)))].sort((a,\
    \ b) => a - b);\n}\n", "    return [...new Set(l1.filter(v => l2.includes(v)))].sort();\n\
    }\n", "  let newArr: number[] = [];\n  let set1 = new Set(l1);\n  let set2 = new\
    \ Set(l2);\n  for (let i of set1) {\n    if (set2.has(i)) {\n      newArr.push(i);\n\
    \    }\n  }\n  return newArr.sort((a, b) => a - b);\n}\nconsole.log(common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]));\nconsole.log(common([5, 3,\
    \ 2, 8], [3, 2]));\n", "    return _.intersection(l1, l2).sort((a, b) => a - b);\n\
    }\n\n\n", "  const copy: number[] = [...l1];\n  const copy2: number[] = [...l2];\n\
    \  const unique: number[] = [];\n  const unique2: number[] = [];\n  const newArray:\
    \ number[] = [];\n  for (let i = 0; i < copy.length; i++) {\n    if (copy.indexOf(copy[i])\
    \ === i) {\n      unique.push(copy[i]);\n    }\n  }\n  for (let i = 0; i < copy2.length;\
    \ i++) {\n    if (copy2.indexOf(copy2[i]) === i) {\n      unique2.push(copy2[i]);\n\
    \    }\n  }\n  for (let i = 0; i < unique.length; i++) {\n    if (unique2.indexOf(unique[i])\
    \ !== -1) {\n      newArray.push(unique[i]);\n    }\n  }\n  return newArray;\n\
    }\n", "    let common: number[] = [];\n    for (let i = 0; i < l1.length; i++)\
    \ {\n        if (l2.indexOf(l1[i]) > -1) {\n            common.push(l1[i]);\n\
    \        }\n    }\n    return common.sort();\n}", "    return [...new Set(l1.filter(x\
    \ => l2.includes(x)))].sort((a, b) => a - b);\n}\n\n", "  return l1.filter(x =>\
    \ l2.includes(x)).sort((a, b) => a - b).filter((el, i, arr) => i === arr.indexOf(el));\n\
    }\n\nexport default common;", "  return [...new Set(l1.filter(x => l2.includes(x)))].sort();\n\
    }\n", "  return [...new Set(l1.filter(x => l2.includes(x)))].sort();\n}\n", " \
    \ const unique = l1.filter(i => !l2.includes(i))\n  return unique\n}\n", "   \
    \ return [...new Set(l1.filter(x => l2.includes(x)))].sort((a, b) => a - b);\n\
    }\n", "  // Your code here\n  let hash = {};\n  let common_array = [];\n  for\
    \ (let i = 0; i < l1.length; i++) {\n    if (hash[l1[i]]) {\n      hash[l1[i]]++;\n\
    \    } else {\n      hash[l1[i]] = 1;\n    }\n  }\n  for (let i = 0; i < l2.length;\
    \ i++) {\n    if (hash[l2[i]] > 0) {\n      common_array.push(l2[i]);\n      hash[l2[i]]--;\n\
    \    }\n  }\n  return common_array;\n}\n", "  return l1.filter(e => l2.includes(e)).sort((a,\
    \ b) => a - b);\n}\n", "  return _.intersection(l1, l2);\n}\n", "    return l1.filter(x\
    \ => l2.includes(x));\n}\n", "    return [...new Set(l1.filter(item => l2.includes(item)).sort((a,\
    \ b) => a - b))];\n}\nconsole.log(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]));\nconsole.log(common([5, 3, 2, 8], [3, 2]));\n", "  return Array.from(new\
    \ Set(l1.filter(x => l2.includes(x))));\n}\n", "    return l1.filter(x => l2.includes(x)).sort();\n\
    }\n", "    const set = new Set(l1);\n    return l2.filter(x => set.has(x)).sort((a,\
    \ b) => a - b);\n}\n", "    return [...l1, ...l2].filter((e, i, a) => a.indexOf(e)\
    \ === i && i !== a.lastIndexOf(e))\n}\n", "    let res: number[] = [];\n    for\
    \ (let v of l1) {\n        if (l2.indexOf(v) > -1) {\n            res.push(v);\n\
    \        }\n    }\n    return res.sort((a, b) => a - b);\n}\n", "    let common\
    \ = Array.from(new Set(l1.filter(x => l2.includes(x))));\n    common.sort();\n\
    \    return common;\n}\n", "  return l1.filter(e => l2.includes(e));\n}\n\nexport\
    \ { common };", "    let result: number[] = [];\n    // return l1.filter(value\
    \ => l2.includes(value)).filter((value, index, self) => self.indexOf(value) ===\
    \ index).sort((a, b) => a - b);\n    //solution 2\n    l1.sort((a, b) => a - b);\n\
    \    l2.sort((a, b) => a - b);\n    let p1 = 0;\n    let p2 = 0;\n    while (p1\
    \ < l1.length && p2 < l2.length) {\n        if (l1[p1] == l2[p2]) {\n        \
    \    result.push(l1[p1]);\n            p1++;\n            p2++;\n        } else\
    \ if (l1[p1] < l2[p2]) {\n            p1++;\n        } else {\n            p2++;\n\
    \        }\n    }\n    return result;\n}\n", "  return [...new Set(l1.filter(e\
    \ => l2.includes(e)))].sort((a, b) => a - b);\n}\n", "    return l1.filter(n =>\
    \ l2.includes(n)).sort((a, b) => a - b).filter((val, index, arr) => arr.indexOf(val)\
    \ === index);\n}\n", "    return l1.filter(v => l2.includes(v)).sort().filter((v,\
    \ i, arr) => i === 0 || v !== arr[i - 1]);\n}\n", "    let list: number[] = [];\n\
    \    for (let i = 0; i < l1.length; i++) {\n        for (let j = 0; j < l2.length;\
    \ j++) {\n            if (l1[i] === l2[j]) {\n                list.push(l1[i]);\n\
    \            }\n        }\n    }\n    list.sort((a, b) => a - b);\n    for (let\
    \ i = 0; i < list.length; i++) {\n        for (let j = i + 1; j < list.length;\
    \ j++) {\n            if (list[i] === list[j]) {\n                list.splice(j,\
    \ 1);\n                j--;\n            }\n        }\n    }\n    return list;\n\
    }\n", "    return [...new Set(l1.filter(e => l2.includes(e)))].sort((a, b) =>\
    \ a - b);\n}\n", "  // Get the common elements out of the two lists\n  let common\
    \ = l1.filter(x => l2.includes(x));\n  // Now sort it and remove any duplicate\
    \ entries.\n  let sorted = common.sort((a, b) => a - b);\n  let unique = sorted.filter((x,\
    \ i) => sorted.indexOf(x) === i);\n  return unique;\n}\n", "    return l1.filter(i\
    \ => l2.includes(i)).sort((a, b) => a - b);\n}\n", "  let set = new Set();\n \
    \ l1.forEach(e => {\n    l2.forEach(ee => {\n      if (e === ee) {\n        set.add(e);\n\
    \      }\n    });\n  });\n  return [...set];\n}\n", "  const result = []\n  const\
    \ seen = {}\n  l1.concat(l2).forEach(e => {\n    if (!seen[e]) {\n      seen[e]\
    \ = true\n      result.push(e)\n    }\n  })\n  return result\n}\n", "    return\
    \ [...new Set(l1.filter(x => l2.includes(x)))].sort((a, b) => a - b);\n}\n", " \
    \   return Array.from(new Set(l1.filter(e => l2.includes(e))));\n}\n", "  return\
    \ null;\n}\n", "    let res: number[] = [];\n    for (let i of l1) {\n       \
    \ if (l2.includes(i) && !res.includes(i)) {\n            res.push(i);\n      \
    \  }\n    }\n    return res.sort((a, b) => a - b);\n}\n", "    let ret: number[]\
    \ = [];\n    for (let i = 0; i < l1.length; i++) {\n        for (let j = 0; j\
    \ < l2.length; j++) {\n            if (l1[i] === l2[j]) {\n                ret.push(l1[i]);\n\
    \            }\n        }\n    }\n    return ret.sort((x, y) => x - y);\n}\n",
  "  let result: number[] = [];\n  for (let i of l1) {\n    if (l2.includes(i) &&\
    \ !result.includes(i)) {\n      result.push(i);\n    }\n  }\n  return result.sort((a,\
    \ b) => a - b);\n}\n", "    return l1.filter(e => l2.includes(e)).sort().filter((e,\
    \ i, a) => i === a.indexOf(e));\n}\n", "  let common: number[] = [];\n  for (let\
    \ i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++) {\n  \
    \    if (l1[i] === l2[j]) {\n        common.push(l1[i]);\n      }\n    }\n  }\n\
    \  return common.sort((a, b) => a - b);\n}\nconsole.log(common([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121]));\nconsole.log(common([5, 3, 2, 8], [3, 2]));\n",
  "    return unique(sort(l1.concat(l2))).filter(item => l1.includes(item) && l2.includes(item));\n\
    }\n", "  return [...new Set(l1.filter(item => l2.includes(item)))].sort(\n   \
    \ (a, b) => a - b\n  );\n}\n\nexport { common };", "  let result: number[] = [];\n\
    \  for (let a of l1) {\n    for (let b of l2) {\n      if (a === b) {\n      \
    \  result.push(a);\n      }\n    }\n  }\n  return result.sort().filter((element,\
    \ index, arr) => arr.indexOf(element) === index);\n}\n", "    return new Set([...l1,\
    \ ...l2]).values();\n}\n\n", "    const res: number[] = [];\n    const set: Set<number>\
    \ = new Set(l1);\n    for (const n of l2) {\n        if (set.has(n)) {\n     \
    \       res.push(n);\n        }\n    }\n    return Array.from(new Set(res)).sort((a,\
    \ b) => a - b);\n}\n", "    const set = new Set(l1);\n    return l2.filter(e =>\
    \ set.has(e)).sort((a, b) => a - b);\n}\n", "    let result = [];\n    for (let\
    \ i = 0; i < l1.length; i++) {\n        for (let j = 0; j < l2.length; j++) {\n\
    \            if (l1[i] === l2[j]) {\n                result.push(l1[i]);\n   \
    \         }\n        }\n    }\n    return result.sort().filter((i, p, arr) =>\
    \ arr.indexOf(i) === p);\n}\n", "    return uniq([...l1].filter(x => l2.includes(x)));\n\
    }\n", "    const result: number[] = [];\n    l1.forEach(x => {\n        if (l2.includes(x)\
    \ && !result.includes(x)) {\n            result.push(x);\n        }\n    });\n\
    \    return result.sort((a, b) => a - b);\n}\n", "    return l1.filter(n => l2.includes(n)).sort((a,\
    \ b) => a - b);\n}\n\n", "    return [];\n}\n\nexport { common };", "    const\
    \ set1 = new Set(l1);\n    const set2 = new Set(l2);\n    const common = new Set([...set1].filter(x\
    \ => set2.has(x)));\n    return [...common];\n}\n", "  const l3 = l1.filter(e\
    \ => l2.includes(e));\n  return l3.filter((v, i) => l3.indexOf(v) === i);\n}\n",
  "  let res = l1.filter(n => l2.includes(n));\n  return res.sort((a, b) => a - b);\n\
    }\n\nconsole.log(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]));\n\
    console.log(common([5, 3, 2, 8], [3, 2]));\n", "  let result: number[] = [];\n\
    \  for (let i = 0; i < l1.length; i++) {\n    for (let j = 0; j < l2.length; j++)\
    \ {\n      if (l1[i] === l2[j]) {\n        result.push(l1[i]);\n      }\n    }\n\
    \  }\n  return uniq(result);\n}\n", "    return l1.filter(x => l2.includes(x)).sort((a,\
    \ b) => a - b).filter((x, i, l) => l.indexOf(x) === i);\n}\n", "  return [...new\
    \ Set(l1.filter(el => l2.includes(el)))].sort((a, b) => a - b);\n}\n", "    //\
    \ Your code here\n    return [];\n}\n", "  return l1.filter(function(n) {\n  \
    \  return l2.indexOf(n) != -1;\n  });\n}\nconsole.log(\"common:\", common([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]));\n", "  const s1 = new Set(l1);\n\
    \  const s2 = new Set(l2);\n  return Array.from(new Set([...s1].filter(x => s2.has(x))));\n\
    }\n", "    return _.union(_.intersection(l1, l2));\n}\n", "    let result: number[]\
    \ = [];\n    let l1_map: { [_: string]: boolean } = {};\n    let l2_map: { [_:\
    \ string]: boolean } = {};\n    l1.forEach(num => l1_map[num] = true);\n    l2.forEach(num\
    \ => l2_map[num] = true);\n    l1.forEach(num => {\n        if (l2_map[num]) {\n\
    \            result.push(num);\n        }\n    });\n    return result;\n}\n",
  "    const result = new Set<number>();\n    const set1 = new Set(l1);\n    const\
    \ set2 = new Set(l2);\n    const smallSet = set1.size < set2.size ? set1 : set2;\n\
    \    const bigSet = set1.size >= set2.size ? set1 : set2;\n    for (const i of\
    \ smallSet) {\n        if (bigSet.has(i)) {\n            result.add(i);\n    \
    \    }\n    }\n    return [...result].sort((a, b) => a - b);\n}\n", "  return\
    \ [...new Set(l1.filter(x => l2.includes(x)))].sort((a, b) => a - b);\n}\n", " \
    \   let set1 = new Set(l1);\n    let set2 = new Set(l2);\n    let common = new\
    \ Set([...set1].filter(x => set2.has(x)));\n    return Array.from(common).sort((a,\
    \ b) => a - b);\n}\n\nconsole.log(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5,\
    \ 9, 653, 121]));\nconsole.log(common([5, 3, 2, 8], [3, 2]));", "  const set1\
    \ = new Set(l1);\n  const set2 = new Set(l2);\n  const res = [...set1].filter(x\
    \ => set2.has(x));\n  return res.sort((a, b) => a - b);\n}\n", "    return Array.from(new\
    \ Set(l1.filter(a => l2.includes(a))));\n}", "  const set = new Set(l1);\n  const\
    \ common: number[] = [];\n  for (const e of l2) {\n    if (set.has(e)) {\n   \
    \   common.push(e);\n    }\n  }\n  return [...new Set(common)].sort((a, b) =>\
    \ a - b);\n}\n", "  return Array.from(new Set(l1.filter(x => l2.includes(x))));\n\
    }\n", "  return Array.from(new Set(l1.filter(el => l2.includes(el))));\n}\n",
  "  return _.intersection(l1, l2);\n}\n", "  const list: number[] = []\n  l1.forEach(e\
    \ => {\n    if (l2.includes(e) && !list.includes(e)) {\n      list.push(e)\n \
    \   }\n  })\n  return list.sort((a, b) => a - b)\n}\n", "  return [...new Set(l1.filter(item\
    \ => l2.includes(item)))].sort((a, b) => a - b);\n}\n\nexport { common };"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
