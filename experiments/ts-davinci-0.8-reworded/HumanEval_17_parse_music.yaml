name: HumanEval_17_parse_music
language: ts
prompt: "//Input to this function is a string representing musical notes in a special\
  \ ASCII format.\n// Your task is to parse this string and return array of integers\
  \ corresponding to how many beats does each\n// not last.\n// Here is a legend:\n\
  // 'o' - whole note, lasts four beats\n// 'o|' - half note, lasts two beats\n//\
  \ '.|' - quater note, lasts one beat\n// >>> parse_music(\"o o| .| o| o| .| .| .|\
  \ .| o o\")\n// [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\nfunction parse_music(music_string:\
  \ string): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = parse_music;\n  assert.deepEqual(candidate(\"\"),[]);\n\
  \  assert.deepEqual(candidate(\"o o o o\"),[4, 4, 4, 4]);\n  assert.deepEqual(candidate(\"\
  .| .| .| .|\"),[1, 1, 1, 1]);\n  assert.deepEqual(candidate(\"o| o| .| .| o o o\
  \ o\"),[2, 2, 1, 1, 4, 4, 4, 4]);\n  assert.deepEqual(candidate(\"o| .| o| .| o\
  \ o| o o|\"),[2, 1, 2, 1, 4, 2, 4, 2]);\n}\n\ntest();"
completions: ["    const beatSequence: number[] = [];\n    const beatsPerMeasure:\
    \ number = 4;\n    const beat = {\n        o: beatsPerMeasure,\n        oBar:\
    \ beatsPerMeasure / 2,\n        dotBar: beatsPerMeasure / 4\n    };\n    const\
    \ noteTypes = Object.keys(beat);\n    const notes: string[] = music_string.split(\"\
    \ \");\n    for (let note of notes) {\n        for (let type of noteTypes) {\n\
    \            if (note.indexOf(type) === 0) {\n                let repeat: number\
    \ = Number(note.charAt(type.length));\n                if (isNaN(repeat)) {\n\
    \                    repeat = 1;\n                }\n                for (let\
    \ i = 0; i < repeat; i++) {\n                    beatSequence.push(beat[type]);\n\
    \                }\n            }\n        }\n    }\n    return beatSequence;\n\
    }\n", "  let parse_music = music_string.split(' ');\n  let note_duration: number[]\
    \ = [];\n  for (let i = 0; i < parse_music.length; i++) {\n    let notes = parse_music[i];\n\
    \    if (notes === 'o') {\n      note_duration.push(4);\n    } else if (notes\
    \ === 'o|') {\n      note_duration.push(2);\n    } else if (notes === '.|') {\n\
    \      note_duration.push(1);\n    }\n  }\n  return note_duration;\n}\n", "  \
    \  return music_string.split(' ').map(char => {\n        switch (char) {\n   \
    \         case 'o':\n                return 4;\n            case 'o|':\n     \
    \           return 2;\n            case '.|':\n                return 1;\n   \
    \         default:\n                return 0;\n        }\n    });\n}\n\nconsole.log(parse_music(\"\
    o o| .| o| o| .| .| .| .| o o\"));\n", "  const notes = music_string.split(\"\
    \ \");\n  const beats = [];\n  for (let i = 0; i < notes.length; i++) {\n    const\
    \ currentNote = notes[i];\n    switch (currentNote) {\n      case \"o\":\n   \
    \     beats.push(4);\n        break;\n      case \"o|\":\n        beats.push(2);\n\
    \        break;\n      case \".|\":\n        beats.push(1);\n        break;\n\
    \    }\n  }\n  return beats;\n}\n", "    return music_string.split(\" \").map(note\
    \ => {\n        switch (note) {\n            case \"o\":\n                return\
    \ 4;\n            case \"o|\":\n                return 2;\n            case \"\
    .|\":\n                return 1;\n            default:\n                return\
    \ 0;\n        }\n    });\n}\n", "  return music_string.split(' ').map(s => {\n\
    \    switch (s) {\n      case 'o':\n        return 4;\n      case 'o|':\n    \
    \    return 2;\n      case '.|':\n        return 1;\n      default:\n        return\
    \ 0;\n    }\n  });\n}\n", "  // TODO: Your code here!\n  return [];\n}\n", " \
    \   let result: number[] = []\n    const notes = music_string.split(\" \")\n \
    \   for (let note of notes) {\n        switch (note) {\n            case \"o\"\
    :\n                result.push(4)\n                break\n            case \"\
    o|\":\n                result.push(2)\n                break\n            case\
    \ \".|\":\n                result.push(1)\n                break\n        }\n\
    \    }\n    return result\n}\n", "  const beats = ['o|', '.|', 'o'];\n  const\
    \ beats_num = [2, 1, 4];\n  let result = music_string.split(' ');\n  return result.map(x\
    \ => beats_num[beats.indexOf(x)]);\n}\n\ntest('test parse_music', () => {\n  expect(parse_music(\"\
    o o| .| o| o| .| .| .| .| o o\")).toEqual([4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]);\n\
    });", "    return music_string.split(' ').map(note => {\n        if (note == 'o')\
    \ return 4;\n        if (note == 'o|') return 2;\n        if (note == '.|') return\
    \ 1;\n    });\n}\n", "    const notes: string[] = music_string.split(' ');\n \
    \   return notes.map(note => {\n        switch (note) {\n            case 'o':\n\
    \                return 4;\n            case 'o|':\n                return 2;\n\
    \            case '.|':\n                return 1;\n            default:\n   \
    \             throw new Error('Unrecognized note: ' + note);\n        }\n    });\n\
    }\n", "  const music = music_string.split(\" \");\n  const music_values = [];\n\
    \  music.forEach(m => {\n    if (m === \"o\") {\n      music_values.push(4);\n\
    \    } else if (m === \"o|\") {\n      music_values.push(2);\n    } else if (m\
    \ === \".|\") {\n      music_values.push(1);\n    }\n  });\n  return music_values;\n\
    }\n\ndescribe(\"parse_music\", () => {\n  it(\"should parse music\", () => {\n\
    \    const notes = [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4];\n    expect(parse_music(\"\
    o o| .| o| o| .| .| .| .| o o\")).toEqual(notes);\n  });\n});\n", "    let result\
    \ = [];\n    let beats = 0;\n    for (let i = 0; i < music_string.length; i++)\
    \ {\n        if (music_string[i] === 'o') {\n            beats += 4;\n       \
    \ } else if (music_string[i] === 'o' && music_string[i + 1] === '|') {\n     \
    \       beats += 2;\n            i++;\n        } else if (music_string[i] ===\
    \ '.' && music_string[i + 1] === '|') {\n            beats += 1;\n           \
    \ i++;\n        } else if (music_string[i] === ' ') {\n            result.push(beats);\n\
    \            beats = 0;\n        }\n    }\n    result.push(beats);\n    return\
    \ result;\n}\n\ndescribe('music', () => {\n    it('should parse music', () =>\
    \ {\n        expect(parse_music(\"o o| .| o| o| .| .| .| .| o o\")).to.deep.equal([4,\
    \ 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]);\n    });\n});", "  return music_string.split('\
    \ ').map(e => e[0] === 'o' ?\n  e.length > 1 ? 2 : 4 : 1);\n}", "  return music_string.split(\"\
    \ \").map(single => {\n    if (single === \"o\") {\n      return 4;\n    } else\
    \ if (single === \"o|\") {\n      return 2;\n    } else if (single === \".|\"\
    ) {\n      return 1;\n    }\n  });\n}\n", "    let sp = music_string.split(\"\
    \ \");\n    let res = [];\n    for (let x of sp) {\n        if (x == \"o\") {\n\
    \            res.push(4);\n        } else if (x == \"o|\") {\n            res.push(2);\n\
    \        } else if (x == \".|\") {\n            res.push(1);\n        }\n    }\n\
    \    return res;\n}\n", "    const beats: number[] = [];\n    for (let note of\
    \ music_string.split(' ')) {\n        switch (note) {\n            case 'o':\n\
    \                beats.push(4);\n                break;\n            case 'o|':\n\
    \                beats.push(2);\n                break;\n            case '.|':\n\
    \                beats.push(1);\n                break;\n        }\n    }\n  \
    \  return beats;\n}", "    let notes = music_string.split(' ');\n    return notes.map(function\
    \ (note) {\n        if (note === 'o') {\n            return 4;\n        } else\
    \ if (note === 'o|') {\n            return 2;\n        } else if (note === '.|')\
    \ {\n            return 1;\n        }\n    });\n}\n\nconsole.log(parse_music(\"\
    o o| .| o| o| .| .| .| .| o o\"));\n", "    let notes: string[] = music_string.trim().split(\"\
    \ \");\n    let note_values: number[] = [];\n    let whole_note_value: number\
    \ = 4;\n    let half_note_value: number = 2;\n    let quarter_note_value: number\
    \ = 1;\n    let note_value: number = 0;\n\n    for (let note of notes) {\n   \
    \     if (note === \"o\") {\n            note_value = whole_note_value;\n    \
    \    } else if (note === \"o|\") {\n            note_value = half_note_value;\n\
    \        } else if (note === \".|\") {\n            note_value = quarter_note_value;\n\
    \        } else {\n            throw new Error(\"Invalid note format\");\n   \
    \     }\n        note_values.push(note_value);\n    }\n    return note_values;\n\
    }\n", "    const result: number[] = [];\n    const notes = music_string.split('\
    \ ');\n    for (const note of notes) {\n        if (note === 'o') {\n        \
    \    result.push(4);\n        } else if (note === 'o|') {\n            result.push(2);\n\
    \        } else if (note === '.|') {\n            result.push(1);\n        }\n\
    \    }\n    return result;\n}"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
