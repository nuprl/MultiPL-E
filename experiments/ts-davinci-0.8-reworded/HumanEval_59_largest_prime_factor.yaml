name: HumanEval_59_largest_prime_factor
language: ts
prompt: "//Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  // >>> largest_prime_factor(13195)\n// 29\n// >>> largest_prime_factor(2048)\n//\
  \ 2\nfunction largest_prime_factor(n: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = largest_prime_factor;\n  assert.deepEqual(candidate(15),5);\n\
  \  assert.deepEqual(candidate(27),3);\n  assert.deepEqual(candidate(63),7);\n  assert.deepEqual(candidate(330),11);\n\
  \  assert.deepEqual(candidate(13195),29);\n}\n\ntest();"
completions: ["  let i = 2;\n  while (i * i <= n) {\n    if (n % i === 0) {\n    \
    \  while (n % i === 0) {\n        n /= i;\n      }\n    }\n    i++;\n  }\n  return\
    \ n;\n}\n\nexport function main() {\n  console.log(largest_prime_factor(13195));\n\
    \  console.log(largest_prime_factor(2048));\n}", "    var result = 0;\n    //\
    \ start with 2 (all numbers are divisible by 1)\n    var test = 2;\n    while\
    \ (n > 1) {\n        if (n % test === 0) {\n            result = test;\n     \
    \       n = n / test;\n        } else {\n            test++;\n        }\n    }\n\
    \    return result;\n}\n", "    if (n < 2) {\n        return undefined;\n    }\n\
    \n    if (n === 2) {\n        return 2;\n    }\n\n    if (n % 2 === 0) {\n   \
    \     return largest_prime_factor(n / 2);\n    }\n\n    for (let i = 3; i < n;\
    \ i += 2) {\n        if (n % i === 0) {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n\n    return n;\n}\n\nexport {\n    largest_prime_factor\n\
    };", "    let largest = 1;\n    let current = 2;\n    while (current <= n) {\n\
    \        if (n % current === 0) {\n            largest = current;\n          \
    \  n = n / current;\n        } else {\n            current++;\n        }\n   \
    \ }\n    return largest;\n}\n", "    let factor: number = 2;\n    let largest_factor:\
    \ number = 1;\n    while (n > 1) {\n        if (n % factor == 0) {\n         \
    \   largest_factor = factor;\n            n /= factor;\n            while (n %\
    \ factor == 0) {\n                n /= factor;\n            }\n        }\n   \
    \     factor += 1;\n    }\n    return largest_factor;\n}\n\nconsole.log(largest_prime_factor(13195));\n\
    console.log(largest_prime_factor(2048));", "  let num = n\n  let factor = 2\n\
    \  while (factor <= num) {\n    if (num % factor !== 0) {\n      factor += 1\n\
    \    } else {\n      num /= factor\n    }\n  }\n  return factor\n}\n", "    let\
    \ max: number = 0;\n    let i: number = 2;\n    while (i * i <= n) {\n       \
    \ if (n % i === 0) {\n            while (n % i === 0) {\n                n = n\
    \ / i;\n            }\n            max = i;\n        }\n        i += 1;\n    }\n\
    \    if (n > 1) {\n        max = n;\n    }\n    return max;\n}\n", "    let i\
    \ = 2;\n    let largest_prime = 2;\n    while (i <= n) {\n        if (n % i ===\
    \ 0) {\n            largest_prime = i;\n            n = n / i;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    return largest_prime;\n}\n", " \
    \ let prime = 2;\n  while (n > prime) {\n    if (n % prime === 0) {\n      n /=\
    \ prime;\n    } else {\n      prime++;\n    }\n  }\n  return prime;\n}\n", " \
    \   for (let i = n - 1; i > 1; i--) {\n        if (n % i === 0 && is_prime(i))\
    \ {\n            return i;\n        }\n    }\n    return -1;\n}\n", "    if (n\
    \ < 1) {\n        throw \"n must be greater than 1\";\n    }\n    if (is_prime(n))\
    \ {\n        return n;\n    }\n    const smallest_factor = smallest_factor(n);\n\
    \    const largest_prime_factor_of_smallest_factor = largest_prime_factor(smallest_factor);\n\
    \    const largest_prime_factor_of_remainder = largest_prime_factor(n / smallest_factor);\n\
    \    if (largest_prime_factor_of_smallest_factor > largest_prime_factor_of_remainder)\
    \ {\n        return largest_prime_factor_of_smallest_factor;\n    } else {\n \
    \       return largest_prime_factor_of_remainder;\n    }\n}\n", "  var i: number;\n\
    \  var result: number;\n  for (i = 2; i < n; i++) {\n    if (n % i === 0) {\n\
    \      result = i;\n      n = n / i;\n      i = 1;\n    }\n  }\n  return result;\n\
    }\n", "    // n must be greater than 1 and not a prime\n    if(n <= 1 || is_prime(n))\
    \ return n;\n    // variables\n    let candidate = n - 1; // candidate factors\n\
    \    let quotient = n; // quotient of division\n    // search for first factor\n\
    \    while(quotient % candidate !== 0) candidate--;\n    // recursive call to\
    \ iterate through the other factors\n    return largest_prime_factor(quotient\
    \ / candidate);\n}\n", "    for (let i = Math.ceil(Math.sqrt(n)); i > 0; i--)\
    \ {\n        if (n % i === 0 && is_prime(i)) {\n            return i;\n      \
    \  }\n    }\n    return undefined;\n}\n", "  let primes: number[] = [];\n  for\
    \ (let factor = 2; factor <= n; factor++) {\n    if (is_prime(factor)) {\n   \
    \   primes.push(factor);\n    }\n  }\n  return primes[primes.length - 1];\n}\n",
  "    let factors = primes_factors(n);\n    return factors[factors.length - 1];\n\
    }\n", "    if (n < 2) { return 1; }\n    for (let i = 2; i < n; i++) {\n     \
    \   if (n % i === 0) {\n            return largest_prime_factor(n / i);\n    \
    \    }\n    }\n    return n;\n}\n", "    let i = 2;\n    while (i * i <= n) {\n\
    \        if (n % i === 0) {\n            n = n / i;\n        } else {\n      \
    \      i++;\n        }\n    }\n    return n;\n}\n", "    for (let i = 2; i < n;\
    \ i++) {\n        if (n % i === 0) {\n            return largest_prime_factor(n\
    \ / i);\n        }\n    }\n    return n;\n}\n\n", "    let highest: number = 0;\n\
    \    let current: number = 2;\n    while (n > current) {\n        if (n % current\
    \ === 0) {\n            let temp = n / current;\n            if (is_prime(temp))\
    \ {\n                return temp;\n            }\n            n = temp;\n    \
    \    }\n        current++;\n    }\n    return highest;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
