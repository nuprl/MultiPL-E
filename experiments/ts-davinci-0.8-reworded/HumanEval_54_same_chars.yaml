name: HumanEval_54_same_chars
language: ts
prompt: "//Check if two words have the same characters.\n// >>> same_chars(\"eabcdzzzz\"\
  , \"dddzzzzzzzddeddabc\")\n// true\n// >>> same_chars(\"abcd\", \"dddddddabc\")\n\
  // true\n// >>> same_chars(\"dddddddabc\", \"abcd\")\n// true\n// >>> same_chars(\"\
  eabcd\", \"dddddddabc\")\n// false\n// >>> same_chars(\"abcd\", \"dddddddabce\"\
  )\n// false\n// >>> same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")\n// false\n\
  function same_chars(s0: string, s1: string): boolean {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = same_chars;\n  assert.deepEqual(candidate(\"eabcdzzzz\"\
  , \"dddzzzzzzzddeddabc\"),true);\n  assert.deepEqual(candidate(\"abcd\", \"dddddddabc\"\
  ),true);\n  assert.deepEqual(candidate(\"dddddddabc\", \"abcd\"),true);\n  assert.deepEqual(candidate(\"\
  eabcd\", \"dddddddabc\"),false);\n  assert.deepEqual(candidate(\"abcd\", \"dddddddabcf\"\
  ),false);\n  assert.deepEqual(candidate(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"),false);\n\
  \  assert.deepEqual(candidate(\"aabb\", \"aaccc\"),false);\n}\n\ntest();"
completions: ["    // Your code here\n    let store = 0;\n    for (let i = 0; i <\
    \ s0.length; i++) {\n        let c = s0.charCodeAt(i);\n        store |= 1 <<\
    \ c;\n    }\n    for (let i = 0; i < s1.length; i++) {\n        let c = s1.charCodeAt(i);\n\
    \        if ((store & (1 << c)) === 0) {\n            return false;\n        }\n\
    \    }\n    return true;\n}\n", "    let count = 0;\n    let used: boolean[] =\
    \ new Array(s0.length);\n    for (let i = 0; i < s0.length; i++) {\n        let\
    \ c = s0.charAt(i);\n        if (s1.indexOf(c) !== -1) {\n            used[i]\
    \ = true;\n            count++;\n        }\n    }\n    return count === s0.length;\n\
    }\n", "    return JSON.stringify(s0.split(\"\").sort()) === JSON.stringify(s1.split(\"\
    \").sort());\n}\n", "    let m0 = new Map<string, number>();\n    let m1 = new\
    \ Map<string, number>();\n    for (let c of s0) {\n        if (m0.has(c)) {\n\
    \            m0.set(c, m0.get(c) + 1);\n        } else {\n            m0.set(c,\
    \ 1);\n        }\n    }\n    for (let c of s1) {\n        if (m1.has(c)) {\n \
    \           m1.set(c, m1.get(c) + 1);\n        } else {\n            m1.set(c,\
    \ 1);\n        }\n    }\n    for (let c of s0) {\n        if (!m1.has(c) || m1.get(c)\
    \ < m0.get(c)) {\n            return false;\n        }\n    }\n    for (let c\
    \ of s1) {\n        if (!m0.has(c) || m0.get(c) < m1.get(c)) {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n", "  if (s0.length !== s1.length)\
    \ {\n    return false;\n  }\n  let chars: { [index: string]: number } = {};\n\
    \  for (let c of s0) {\n    if (chars[c]) {\n      chars[c]++;\n    } else {\n\
    \      chars[c] = 1;\n    }\n  }\n  for (let c of s1) {\n    if (chars[c]) {\n\
    \      chars[c]--;\n    } else {\n      return false;\n    }\n  }\n  for (let\
    \ v of Object.values(chars)) {\n    if (v !== 0) {\n      return false;\n    }\n\
    \  }\n  return true;\n}\n", "    const a0 = s0.split(\"\").sort();\n    const\
    \ a1 = s1.split(\"\").sort();\n    if (a0.length !== a1.length) {\n        return\
    \ false;\n    }\n    for (let i = 0; i < a0.length; i++) {\n        if (a0[i]\
    \ !== a1[i]) {\n            return false;\n        }\n    }\n    return true;\n\
    }\n\ntest(\"same_chars\", () => {\n    expect(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\"\
    )).toBe(true);\n    expect(same_chars(\"abcd\", \"dddddddabc\")).toBe(true);\n\
    \    expect(same_chars(\"dddddddabc\", \"abcd\")).toBe(true);\n    expect(same_chars(\"\
    eabcd\", \"dddddddabc\")).toBe(false);\n    expect(same_chars(\"abcd\", \"dddddddabce\"\
    )).toBe(false);\n    expect(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\")).toBe(false);\n\
    });\n", "    let d0 = char_counts(s0);\n    let d1 = char_counts(s1);\n    if\
    \ (d0.size !== d1.size) return false;\n    for (let [c, n] of d0) {\n        if\
    \ (n !== d1.get(c)) return false;\n    }\n    return true;\n}\n", "    let m0\
    \ = to_charmap(s0);\n    let m1 = to_charmap(s1);\n    return _.isEqual(m0, m1);\n\
    }\n", "    let check_arr: boolean[] = new Array(s0.length).fill(false);\n    for\
    \ (let i = 0; i < s0.length; i++) {\n        for (let j = 0; j < s1.length; j++)\
    \ {\n            if (s0[i] === s1[j] && !check_arr[j]) {\n                check_arr[j]\
    \ = true;\n                break;\n            }\n        }\n    }\n    return\
    \ check_arr.every(e => e);\n}", "    if (s0.length !== s1.length) {\n        return\
    \ false;\n    }\n\n    let charIndex: number = -1;\n    let word: string = \"\"\
    ;\n    while (++charIndex < s0.length) {\n        word = s0.substr(charIndex)\
    \ + s0.substr(0, charIndex);\n        if (word === s1) {\n            return true;\n\
    \        }\n    }\n\n    return false;\n}\n\nconsole.log(same_chars(\"eabcdzzzz\"\
    , \"dddzzzzzzzddeddabc\"));\nconsole.log(same_chars(\"abcd\", \"dddddddabc\"));\n\
    console.log(same_chars(\"dddddddabc\", \"abcd\"));\nconsole.log(same_chars(\"\
    eabcd\", \"dddddddabc\"));\nconsole.log(same_chars(\"abcd\", \"dddddddabce\"));\n\
    console.log(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));\n", "    let m0\
    \ = new Map<string, number>();\n    let m1 = new Map<string, number>();\n    for\
    \ (let c of s0) {\n        if (m0.has(c)) {\n            m0.set(c, m0.get(c)!\
    \ + 1);\n        } else {\n            m0.set(c, 1);\n        }\n    }\n    for\
    \ (let c of s1) {\n        if (m1.has(c)) {\n            m1.set(c, m1.get(c)!\
    \ + 1);\n        } else {\n            m1.set(c, 1);\n        }\n    }\n    for\
    \ (let [k, v] of m0) {\n        if (!m1.has(k) || m1.get(k)! < v) {\n        \
    \    return false;\n        }\n    }\n    for (let [k, v] of m1) {\n        if\
    \ (!m0.has(k) || m0.get(k)! < v) {\n            return false;\n        }\n   \
    \ }\n    return true;\n}\n", "    // YOUR CODE HERE\n    return false;\n}\n",
  "  if (s0.length !== s1.length) {\n    return false;\n  }\n  let set0 = new Set(s0);\n\
    \  let set1 = new Set(s1);\n  if (set0.size !== set1.size) {\n    return false;\n\
    \  }\n  let checker = (set0: Set<string>, set1: Set<string>): boolean => {\n \
    \   for (let item of set0) {\n      if (!set1.has(item)) {\n        return false;\n\
    \      }\n    }\n    return true;\n  };\n  return checker(set0, set1) && checker(set1,\
    \ set0);\n}\n", "    return s0.split(\"\").sort().join(\"\") === s1.split(\"\"\
    ).sort().join(\"\");\n}\n", "  let s0_counter = count_chars(s0);\n  let s1_counter\
    \ = count_chars(s1);\n  let same_length = s0.length === s1.length;\n  for (let\
    \ key in s0_counter) {\n    if (s0_counter[key] !== s1_counter[key]) {\n     \
    \ return false;\n    }\n  }\n  return same_length;\n}\n", "    if (s0.length !=\
    \ s1.length) {\n        return false;\n    }\n    for (let i = 0; i < s0.length;\
    \ i++) {\n        if (s0.indexOf(s1[i]) < 0) {\n            return false;\n  \
    \      }\n    }\n    return true;\n}\n", "    if (s0.length != s1.length) {\n\
    \        return false;\n    }\n    let count = {};\n    for (let c of s0) {\n\
    \        if (count[c]) {\n            count[c]++;\n        } else {\n        \
    \    count[c] = 1;\n        }\n    }\n    for (let c of s1) {\n        if (count[c])\
    \ {\n            count[c]--;\n        } else {\n            return false;\n  \
    \      }\n    }\n    for (let c in count) {\n        if (count[c] != 0) {\n  \
    \          return false;\n        }\n    }\n    return true;\n}\nconsole.log(same_chars(\"\
    eabcdzzzz\", \"dddzzzzzzzddeddabc\"));\nconsole.log(same_chars(\"abcd\", \"dddddddabc\"\
    ));\nconsole.log(same_chars(\"dddddddabc\", \"abcd\"));\nconsole.log(same_chars(\"\
    eabcd\", \"dddddddabc\"));\nconsole.log(same_chars(\"abcd\", \"dddddddabce\"));\n\
    console.log(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));", "  for (let i\
    \ = 0; i < s0.length; i++) {\n    let c0 = s0.charAt(i);\n    if (s1.indexOf(c0)\
    \ === -1) {\n      return false;\n    }\n  }\n  for (let i = 0; i < s1.length;\
    \ i++) {\n    let c1 = s1.charAt(i);\n    if (s0.indexOf(c1) === -1) {\n     \
    \ return false;\n    }\n  }\n  return true;\n}\n", "    let s0_sorted = s0.split(\"\
    \").sort().join(\"\");\n    let s1_sorted = s1.split(\"\").sort().join(\"\");\n\
    \    return s0_sorted === s1_sorted;\n}\n\nconsole.log(same_chars(\"eabcdzzzz\"\
    , \"dddzzzzzzzddeddabc\"));\nconsole.log(same_chars(\"abcd\", \"dddddddabc\"));\n\
    console.log(same_chars(\"dddddddabc\", \"abcd\"));\nconsole.log(same_chars(\"\
    eabcd\", \"dddddddabc\"));\nconsole.log(same_chars(\"abcd\", \"dddddddabce\"));\n\
    console.log(same_chars(\"eabcdzzzz\", \"dddzzzzzzzddddabc\"));", "    if (s0.length\
    \ !== s1.length) {\n        return false;\n    }\n\n    let match = 0;\n    const\
    \ charCount = {};\n    for (let i = 0; i < s0.length; i++) {\n        const char\
    \ = s0[i];\n        charCount[char] = charCount[char] || 0;\n        charCount[char]++;\n\
    \    }\n\n    for (let i = 0; i < s1.length; i++) {\n        const char = s1[i];\n\
    \        if (charCount[char]) {\n            charCount[char]--;\n            match++;\n\
    \        }\n    }\n\n    return match === s0.length;\n}\n\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
