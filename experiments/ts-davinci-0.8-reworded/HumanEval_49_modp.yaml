name: HumanEval_49_modp
language: ts
prompt: "//Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n\
  // >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n//\
  \ 8\n// >>> modp(100, 101)\n// 1\nfunction modp(n: number, p: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = modp;\n  assert.deepEqual(candidate(3, 5),3);\n  assert.deepEqual(candidate(1101,\
  \ 101),2);\n  assert.deepEqual(candidate(0, 101),1);\n  assert.deepEqual(candidate(3,\
  \ 11),8);\n  assert.deepEqual(candidate(100, 101),1);\n  assert.deepEqual(candidate(30,\
  \ 5),4);\n  assert.deepEqual(candidate(31, 5),3);\n}\n\ntest();"
completions: ["    if (n === 0) {\n        return 1;\n    }\n    if (n % 2 === 0)\
    \ {\n        const x = modp(n / 2, p);\n        return mulmod(x, x, p);\n    }\n\
    \    return mulmod(modp(n - 1, p), n, p);\n}\n", "    if (n === 0) {\n       \
    \ return 1;\n    }\n    if (n % 2 === 0) {\n        return modp(n / 2, p) ** 2\
    \ % p;\n    }\n    return modp(n - 1, p) * n % p;\n}\n", "  if (n === 0) {\n \
    \   return 1;\n  }\n  let res = 1;\n  while (n) {\n    if (n & 1) {\n      res\
    \ = (res * n) % p;\n    }\n    n = n >> 1;\n    n = (n * n) % p;\n  }\n  return\
    \ res;\n}\n", "    var a = Math.pow(2, n) % p;\n    return a;\n}\n", "    let\
    \ i: number;\n    let j: number;\n    let pow2: number;\n    let result: number;\n\
    \n    if(n === 0) {\n        return 1;\n    }\n\n    pow2 = 1;\n    result = 1;\n\
    \    while(pow2 <= n) {\n        pow2 *= 2;\n    }\n    pow2 /= 2;\n\n    while(pow2\
    \ > 0) {\n        result = (result * result) % p;\n        if(n >= pow2) {\n \
    \           result = (result * 2) % p;\n            n -= pow2;\n        }\n  \
    \      pow2 /= 2;\n    }\n\n    return result;\n}\n", "    const digits = [];\n\
    \    let i = 1;\n    while (i <= n) {\n        if (n & i) {\n            digits.push(i);\n\
    \        }\n        i = i << 1;\n    }\n    let value = 1;\n    for (const digit\
    \ of digits) {\n        if (digit === 1) {\n            value = (value * 2) %\
    \ p;\n        } else {\n            value = (value * 4) % p;\n        }\n    }\n\
    \    return value;\n}\n", "    if (n === 0) {\n        return 1;\n    } else if\
    \ (n % 2 === 0) {\n        let r = modp(n / 2, p);\n        return (r * r) % p;\n\
    \    } else {\n        return (modp(n - 1, p) * 2) % p;\n    }\n}\n", "  if (n\
    \ === 0) {\n    return 1;\n  }\n  let half = modp(Math.floor(n / 2), p);\n  let\
    \ result = half * half % p;\n  if (n % 2 === 1) {\n    result = result * 2 % p;\n\
    \  }\n  return result;\n}\n", "    if (n === 0) {\n        return 1;\n    }\n\
    \    if (n % 2 == 0) {\n        let sqrt = modp(n / 2, p);\n        return (sqrt\
    \ * sqrt) % p;\n    }\n    return (modp(n - 1, p) * n) % p;\n}\n", "  let s =\
    \ 1;\n  for (let i = 0; i < n; i++) {\n    s = (s * 2) % p;\n  }\n  return s;\n\
    }\n", "    return n % p;\n}\n", "  let result = 1;\n  let base = n;\n  while (p\
    \ !== 0) {\n    if (p & 1) {\n      result = (result * base) % 101;\n    }\n \
    \   p >>= 1;\n    base = (base * base) % 101;\n  }\n  return result;\n}\n\nexport\
    \ function reduce(text: string, size: number): number {\n  let result = 0;\n \
    \ for (let i = 0; i < text.length; i++) {\n    result = (result + modp(text.charCodeAt(i),\
    \ size)) % 101;\n  }\n  return result;\n}\n\nexport function isValid(text: string,\
    \ checksum: number): boolean {\n  return reduce(text, checksum) === 0;\n}", " \
    \   if (n === 0) {\n        return 1;\n    }\n    if (n % 2 === 0) {\n       \
    \ const x = modp(n / 2, p);\n        return (x * x) % p;\n    }\n    return (modp(n\
    \ - 1, p) * n) % p;\n}\n", "    var m = 1;\n    for (var i = 0; i < n; i++) {\n\
    \        m = (m * 2) % p;\n    }\n    return m;\n}\n", "    if (n % p === 0) return\
    \ 0;\n    if (n < 0) return (n % p) + p;\n    return n % p;\n}\n", "  if (n ==\
    \ 0) return 1;\n  else if (n % 2 == 0) {\n    var x = modp(n / 2, p);\n    return\
    \ (x * x) % p;\n  } else {\n    return ((modp(n - 1, p) * modp(n, p)) % p);\n\
    \  }\n}\n", "    if (n === 0) {\n        return 1;\n    }\n    else if (n % 2\
    \ === 0) {\n        let c = modp(n / 2, p);\n        return (c * c) % p;\n   \
    \ }\n    else {\n        return (2 * modp(n - 1, p)) % p;\n    }\n}\n", "  if\
    \ (n === 0) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return modp(n / 2,\
    \ p) ** 2 % p;\n  }\n  return (modp(n - 1, p) * modp(n + 1, p)) % p;\n}\n", " \
    \   // Using the modulo operator % is not allowed.\n    var base = 2;\n    var\
    \ res = 1;\n    var mod = p;\n    var tmp = n;\n    while (tmp > 0) {\n      \
    \  if (tmp % 2 != 0) {\n            res = (res * base) % mod;\n        }\n   \
    \     base = (base * base) % mod;\n        tmp = Math.floor(tmp / 2);\n    }\n\
    \    return res;\n}\n", "  if (n <= 1) {\n    return n;\n  }\n  const res = (modp(n\
    \ >> 1, p) * modp(n >> 1, p)) % p;\n  if (n & 1) {\n    return (res * 2) % p;\n\
    \  }\n  return res;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
