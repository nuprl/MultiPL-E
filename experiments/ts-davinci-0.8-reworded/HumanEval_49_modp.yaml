name: HumanEval_49_modp
language: ts
prompt: "//Return 2^n modulo p (be aware of numerics).\n// >>> modp(3, 5)\n// 3\n\
  // >>> modp(1101, 101)\n// 2\n// >>> modp(0, 101)\n// 1\n// >>> modp(3, 11)\n//\
  \ 8\n// >>> modp(100, 101)\n// 1\nfunction modp(n: number, p: number): number {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = modp;\n  assert.deepEqual(candidate(3, 5),3);\n  assert.deepEqual(candidate(1101,\
  \ 101),2);\n  assert.deepEqual(candidate(0, 101),1);\n  assert.deepEqual(candidate(3,\
  \ 11),8);\n  assert.deepEqual(candidate(100, 101),1);\n  assert.deepEqual(candidate(30,\
  \ 5),4);\n  assert.deepEqual(candidate(31, 5),3);\n}\n\ntest();"
completions: ["    if (n === 0) {\n        return 1;\n    }\n    if (n % 2 === 0)\
    \ {\n        const x = modp(n / 2, p);\n        return mulmod(x, x, p);\n    }\n\
    \    return mulmod(modp(n - 1, p), n, p);\n}\n", "    if (n === 0) {\n       \
    \ return 1;\n    }\n    if (n % 2 === 0) {\n        return modp(n / 2, p) ** 2\
    \ % p;\n    }\n    return modp(n - 1, p) * n % p;\n}\n", "  if (n === 0) {\n \
    \   return 1;\n  }\n  let res = 1;\n  while (n) {\n    if (n & 1) {\n      res\
    \ = (res * n) % p;\n    }\n    n = n >> 1;\n    n = (n * n) % p;\n  }\n  return\
    \ res;\n}\n", "    var a = Math.pow(2, n) % p;\n    return a;\n}\n", "    let\
    \ i: number;\n    let j: number;\n    let pow2: number;\n    let result: number;\n\
    \n    if(n === 0) {\n        return 1;\n    }\n\n    pow2 = 1;\n    result = 1;\n\
    \    while(pow2 <= n) {\n        pow2 *= 2;\n    }\n    pow2 /= 2;\n\n    while(pow2\
    \ > 0) {\n        result = (result * result) % p;\n        if(n >= pow2) {\n \
    \           result = (result * 2) % p;\n            n -= pow2;\n        }\n  \
    \      pow2 /= 2;\n    }\n\n    return result;\n}\n", "    const digits = [];\n\
    \    let i = 1;\n    while (i <= n) {\n        if (n & i) {\n            digits.push(i);\n\
    \        }\n        i = i << 1;\n    }\n    let value = 1;\n    for (const digit\
    \ of digits) {\n        if (digit === 1) {\n            value = (value * 2) %\
    \ p;\n        } else {\n            value = (value * 4) % p;\n        }\n    }\n\
    \    return value;\n}\n", "    if (n === 0) {\n        return 1;\n    } else if\
    \ (n % 2 === 0) {\n        let r = modp(n / 2, p);\n        return (r * r) % p;\n\
    \    } else {\n        return (modp(n - 1, p) * 2) % p;\n    }\n}\n", "  if (n\
    \ === 0) {\n    return 1;\n  }\n  let half = modp(Math.floor(n / 2), p);\n  let\
    \ result = half * half % p;\n  if (n % 2 === 1) {\n    result = result * 2 % p;\n\
    \  }\n  return result;\n}\n", "    if (n === 0) {\n        return 1;\n    }\n\
    \    if (n % 2 == 0) {\n        let sqrt = modp(n / 2, p);\n        return (sqrt\
    \ * sqrt) % p;\n    }\n    return (modp(n - 1, p) * n) % p;\n}\n", "  let s =\
    \ 1;\n  for (let i = 0; i < n; i++) {\n    s = (s * 2) % p;\n  }\n  return s;\n\
    }\n", "    return n % p;\n}\n", "  let result = 1;\n  let base = n;\n  while (p\
    \ !== 0) {\n    if (p & 1) {\n      result = (result * base) % 101;\n    }\n \
    \   p >>= 1;\n    base = (base * base) % 101;\n  }\n  return result;\n}\n\nexport\
    \ function reduce(text: string, size: number): number {\n  let result = 0;\n \
    \ for (let i = 0; i < text.length; i++) {\n    result = (result + modp(text.charCodeAt(i),\
    \ size)) % 101;\n  }\n  return result;\n}\n\nexport function isValid(text: string,\
    \ checksum: number): boolean {\n  return reduce(text, checksum) === 0;\n}", " \
    \   if (n === 0) {\n        return 1;\n    }\n    if (n % 2 === 0) {\n       \
    \ const x = modp(n / 2, p);\n        return (x * x) % p;\n    }\n    return (modp(n\
    \ - 1, p) * n) % p;\n}\n", "    var m = 1;\n    for (var i = 0; i < n; i++) {\n\
    \        m = (m * 2) % p;\n    }\n    return m;\n}\n", "    if (n % p === 0) return\
    \ 0;\n    if (n < 0) return (n % p) + p;\n    return n % p;\n}\n", "  if (n ==\
    \ 0) return 1;\n  else if (n % 2 == 0) {\n    var x = modp(n / 2, p);\n    return\
    \ (x * x) % p;\n  } else {\n    return ((modp(n - 1, p) * modp(n, p)) % p);\n\
    \  }\n}\n", "    if (n === 0) {\n        return 1;\n    }\n    else if (n % 2\
    \ === 0) {\n        let c = modp(n / 2, p);\n        return (c * c) % p;\n   \
    \ }\n    else {\n        return (2 * modp(n - 1, p)) % p;\n    }\n}\n", "  if\
    \ (n === 0) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return modp(n / 2,\
    \ p) ** 2 % p;\n  }\n  return (modp(n - 1, p) * modp(n + 1, p)) % p;\n}\n", " \
    \   // Using the modulo operator % is not allowed.\n    var base = 2;\n    var\
    \ res = 1;\n    var mod = p;\n    var tmp = n;\n    while (tmp > 0) {\n      \
    \  if (tmp % 2 != 0) {\n            res = (res * base) % mod;\n        }\n   \
    \     base = (base * base) % mod;\n        tmp = Math.floor(tmp / 2);\n    }\n\
    \    return res;\n}\n", "  if (n <= 1) {\n    return n;\n  }\n  const res = (modp(n\
    \ >> 1, p) * modp(n >> 1, p)) % p;\n  if (n & 1) {\n    return (res * 2) % p;\n\
    \  }\n  return res;\n}\n", "  if (n < 0) {\n    throw new Error('Only non-negative\
    \ integers are allowed.');\n  }\n  if (p <= 0) {\n    throw new Error('Only positive\
    \ integers are allowed.');\n  }\n  if (n < p) {\n    return n;\n  }\n  return\
    \ modp(n % p, p);\n}\n", "    //let n = parseInt(n, 2);\n    if (n === 0) {\n\
    \        return 1;\n    }\n    else if (n % 2 === 0) {\n        return modp(n\
    \ / 2, p) ** 2 % p;\n    }\n    else {\n        return modp(n - 1, p) * 2 % p;\n\
    \    }\n}\n", "  if (n === 0) {\n    return 1;\n  } else if (n % 2 === 0) {\n\
    \    return square(modp(n / 2, p)) % p;\n  } else {\n    return (n * modp(n -\
    \ 1, p)) % p;\n  }\n}\n", "  let r = 1;\n  let b = n;\n  while (b > 0) {\n   \
    \ if (b & 1) {\n      r = r * n % p;\n    }\n    b = b >> 1;\n    n = n * n %\
    \ p;\n  }\n  return r;\n}\n", "    if (n == 0) return 1;\n    return (n%2 == 0)\
    \ ? modp(n/2, p)**2%p : n*modp(n-1, p)%p;\n}\n", "  let res = 1;\n  for (let i\
    \ = 0; i < n; i++) {\n    res = (res * 2) % p;\n  }\n  return res;\n}\n", "  let\
    \ res = 1n;\n  while (n > 0) {\n    res = BigInt(p) * res + BigInt(n % 2);\n \
    \   n = Math.floor(n / 2);\n  }\n  return parseInt(res.toString());\n}\n", " \
    \ const m = 1 << n;\n  const sum = m % p;\n  return sum;\n}\n", "  let out = 1;\n\
    \  while (n > 0) {\n    if (n % 2) {\n      out = (out * 2) % p;\n    }\n    n\
    \ = Math.floor(n / 2);\n  }\n  return out;\n}\n", "    let x = 1;\n    let c =\
    \ 0;\n    let i = 0;\n    let m = n;\n    while (m > 0) {\n        if (m % 2 ==\
    \ 1) {\n            c = c + x;\n        }\n        i = i + 1;\n        x = x *\
    \ 2;\n        m = Math.floor(m / 2);\n    }\n    return c % p;\n}\n", "  if (n\
    \ === 0) {\n    return 1;\n  } else if (n % 2 === 0) {\n    const k = modp(n /\
    \ 2, p);\n    return k * k % p;\n  } else {\n    return n * modp(n - 1, p) % p;\n\
    \  }\n}\n", "  if (n === 0) {\n    return 1;\n  }\n  const p1 = modp(n / 2, p);\n\
    \  const p2 = (p1 * p1) % p;\n  return (n % 2 === 0) ? p2 : (p2 * 2) % p;\n}\n",
  "  return Math.pow(2, n) % p;\n}\n", "    if (n === 0) return 1;\n    const p2 =\
    \ p * p;\n    const t = modp(Math.floor(n / 2), p);\n    const r = (n % 2) ? t\
    \ * t * p : t * t;\n    return r > p2 ? r % p2 : r;\n}\n", "  return p > 1 ? n\
    \ % p : 0;\n}\n", "  let tn = n;\n  let answer = 1;\n  for (let i = 0; i < tn;\
    \ i++) {\n    answer = (answer * 2) % p;\n  }\n  return answer;\n}\n", "    let\
    \ result = 1;\n    for (let i = 1; i <= n; i++) {\n        result = (result *\
    \ 2) % p;\n    }\n    return result;\n}\n\n", "  if (n === 0) {\n    return 1;\n\
    \  } else if (n % 2 === 0) {\n    const b = modp(n / 2, p);\n    return (b * b)\
    \ % p;\n  } else {\n    return (2 * modp(n - 1, p)) % p;\n  }\n}\n", "  if (n\
    \ === 0) {\n    return 1;\n  }\n  let res = 1;\n  let b = n;\n  while (p) {\n\
    \    if (p & 1) {\n      res = (res * b) % p;\n    }\n    p >>= 1;\n    b = (b\
    \ * b) % p;\n  }\n  return res;\n}\n", "  var res = 1;\n  for (let i = 0; i <\
    \ n; i++) {\n    res = (res * 2) % p;\n  }\n  return res;\n}\n", "    if (n ===\
    \ 0) return 1;\n    if (n % 2 === 0) {\n        const x = modp(n / 2, p);\n  \
    \      return (x * x) % p;\n    } else {\n        return (modp(n - 1, p) * n)\
    \ % p;\n    }\n}\n", "    if (n === 0) {\n        return 1;\n    }\n    if (n\
    \ % 2 === 0) {\n        return Math.pow(modp(n / 2, p), 2) % p;\n    }\n    return\
    \ (modp(n - 1, p) * 2) % p;\n}\n", "  return Math.pow(2, n) % p;\n}\n", "  if\
    \ (n < 0) n = n % p + p;\n  return n % p;\n}\n", "    if (n === 0) {\n       \
    \ return 1;\n    }\n    if (n % 2 === 0) {\n        return Math.pow(modp(n / 2,\
    \ p), 2) % p;\n    }\n    return (n % p) * modp(n - 1, p) % p;\n}\n", "    if\
    \ (n === 0) {\n        return 1;\n    }\n    if (n % 2 === 0) {\n        const\
    \ m = modp(n / 2, p);\n        return (m * m) % p;\n    }\n    return (modp(n\
    \ - 1, p) * n) % p;\n}\n", "    if (n === 0) {\n        return 1;\n    } else\
    \ if (n % 2 === 0) {\n        const temp = modp(n / 2, p);\n        return (temp\
    \ * temp) % p;\n    } else {\n        return ((2 * modp(n - 1, p)) % p);\n   \
    \ }\n}\n", "  if (n < 0) {\n    throw new Error('Negative exponents are not allowed\
    \ in modp');\n  }\n  if (n === 0) {\n    return 1;\n  }\n  if (n === 1) {\n  \
    \  return n % p;\n  }\n  let result = modp(n >> 1, p);\n  result = (result * result)\
    \ % p;\n  if (n % 2 === 1) {\n    result = (result * n) % p;\n  }\n  return result;\n\
    }\n", "    let result = 1;\n    let base = n;\n    while (p > 0) {\n        if\
    \ (p % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n   \
    \     p = Math.floor(p / 2);\n        base = (base * base) % MOD;\n    }\n   \
    \ return result;\n}\n", "    let res = 1;\n    n = n % p;\n    while (n > 0) {\n\
    \        if (n & 1)\n            res = (res * 2) % p;\n        n = n >> 1;\n \
    \   }\n    return res;\n}\n", "    if (n === 0) return 1;\n    if (n % 2 === 0)\
    \ {\n        return modp(n / 2, p) ** 2 % p;\n    } else {\n        return modp(n\
    \ - 1, p) * n % p;\n    }\n}\n", "    if (n <= 1) {\n        return n;\n    }\n\
    \    if (n % 2 === 0) {\n        const m = modp(n / 2, p);\n        return (m\
    \ * m) % p;\n    }\n    const m = modp((n - 1) / 2, p);\n    return (((m * m)\
    \ % p) * n) % p;\n}\n", "    if (n < 0) {\n        return modp(-n, p);\n    }\n\
    \    let result = 1;\n    for (let i = 0; i < n; i++) {\n        result = (result\
    \ * 2) % p;\n    }\n    return result;\n}\n\n", "    if (n === 0) {\n        return\
    \ 1;\n    }\n    if (n % 2 === 0) {\n        const m = modp(n / 2, p);\n     \
    \   return (m * m) % p;\n    }\n    return (2 * modp(n - 1, p)) % p;\n}\n", " \
    \   let r = 1;\n    let b = n;\n    while (b > 0) {\n        if (b & 1) {\n  \
    \          r = (r * n) % p;\n        }\n        b = b >> 1;\n        n = (n *\
    \ n) % p;\n    }\n    return r;\n}\n", "  if (n < 0) return modp(-n, p);\n  if\
    \ (n == 0) return 1;\n  if (n == 1) return 0;\n  if (n % 2 == 0) return (modp(n\
    \ / 2, p) ** 2) % p;\n  return (modp(n - 1, p) * 2) % p;\n}\n", "    if (n ===\
    \ 0) {\n        return 1;\n    }\n    return modp(Math.floor(n / 2), p) ** 2 *\
    \ modp(n % 2, p) % p;\n}\n", "    return n % p;\n}\n", "    let result = 1;\n\
    \    let t = n;\n    while (t > 0) {\n        result = result * (t % 2 === 1 ?\
    \ n : 1) % p;\n        t = Math.floor(t / 2);\n        n = n * n % p;\n    }\n\
    \    return result;\n}\n", "  const res = (1 << n) % p;\n  return res === 0 ?\
    \ 1 : res;\n}\n\nexport { modp };", "    if (n == 0) return 1;\n    if (n == 1)\
    \ return n % p;\n    if (n % 2 == 0) {\n        let r = modp(n/2, p);\n      \
    \  return (r * r) % p;\n    } else {\n        return (modp(n-1, p) * n) % p;\n\
    \    }\n}\n\n", "  if (n === 0) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n\
    \    return square(modp(n / 2, p)) % p;\n  }\n  return (modp(n - 1, p) * n) %\
    \ p;\n}\n", "  if (n === 0) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return\
    \ modp(n / 2, p) ** 2 % p;\n  }\n  return modp(n - 1, p) * n % p;\n}\n", "  if\
    \ (n === 0) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return modp(n / 2,\
    \ p) ** 2 % p;\n  }\n  return modp(n - 1, p) * modp(n, p) % p;\n}\n", "    //TODO\n\
    \    let bin = dec2bin(n);\n    let binLength = bin.length;\n    let num = p;\n\
    \    let result = 1;\n    while (binLength > 0) {\n        if (bin[binLength -\
    \ 1] == 1) {\n            result = result * num % p;\n        }\n        num =\
    \ num * num % p;\n        binLength--;\n    }\n    return result;\n}\n", "   \
    \ if (n === 0) {\n        return 1;\n    }\n    const pp = Math.floor(p / 2);\n\
    \    const t = modp(n, pp);\n    let r = t * t;\n    if (p % 2 === 1) {\n    \
    \    r = r * n;\n    }\n    r = r % p;\n    return r;\n}\n", "    let result =\
    \ 1;\n    while (n !== 0) {\n        if (n % 2 === 1) {\n            result =\
    \ (result * p) % mod;\n        }\n        n = Math.floor(n / 2);\n        p =\
    \ (p * p) % mod;\n    }\n    return result;\n}\n", "  //return (bigInt(2).pow(n).mod(p));\n\
    \  return Math.pow(2, n) % p;\n}\n", "    if (n === 0) {\n        return 1;\n\
    \    }\n    if (n % 2 === 0) {\n        let r = modp(n / 2, p);\n        return\
    \ (r * r) % p;\n    }\n    return (modp(n - 1, p) * n) % p;\n}\n", "  if (n ===\
    \ 0) {\n    return 1;\n  } else if (n % 2 === 0) {\n    let half = modp(n / 2,\
    \ p);\n    return half * half % p;\n  } else {\n    return 2 * modp(n - 1, p)\
    \ % p;\n  }\n}\n", "  if (n < 0) return 0;\n  if (n < p) return n;\n  return modp(n\
    \ - p, p);\n}\n", "  if (n < 0) {\n    return p - modp(-n, p);\n  }\n  if (n ===\
    \ 0) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return modp(n / 2, p) **\
    \ 2 % p;\n  }\n  return (modp(n - 1, p) * modp(n + 1, p)) % p;\n}\n", "    //\
    \ To do:\n    return 0;\n}\n", "  if (n === 0) {\n    return 1;\n  }\n  if (n\
    \ === 1) {\n    return n;\n  }\n  if (n % 2 === 0) {\n    return modp(modp(n /\
    \ 2, p) * modp(n / 2, p), p);\n  }\n  return (modp(n - 1, p) * modp(n, p)) % p;\n\
    }\n", "  if (n < 0) {\n    return NaN;\n  }\n  if (n === 0) {\n    return 1;\n\
    \  }\n  if (n % 2 === 0) {\n    const x = modp(n / 2, p);\n    return (x * x)\
    \ % p;\n  }\n  return (modp(n - 1, p) * n) % p;\n}\n\nexport function getLegendreSymbol(a:\
    \ number, p: number): number {\n  if (modp(a, p) === 0) {\n    return 0;\n  }\n\
    \  if (a > p) {\n    return getLegendreSymbol(a % p, p);\n  }\n  const q = (p\
    \ - 1) / 2;\n  if (q % 2 === 0) {\n    const z = modp(a, p);\n    return z ===\
    \ p - 1 ? -1 : 1;\n  }\n  const x = modp(a, p);\n  return modp(x, 2) === 0 ? -1\
    \ : 1;\n}\n\nexport function getQuadraticResidue(n: number, p: number): number\
    \ {\n  if (getLegendreSymbol(n, p) !== 1) {\n    return NaN;\n  }\n  if (n ===\
    \ 0) {\n    return 0;\n  }\n  if (p === 2) {\n    return 1;\n  }\n  if (p % 4\
    \ === 3) {\n    return modp(n, p);\n  }\n  if (p === 5) {\n    return modp(n,\
    \ p);\n  }\n  if (p % 8 === 5) {\n    const c = modp(n, p);\n    return modp(2\
    \ * c, p);\n  }\n  const c = modp(n, p);\n  return modp(2 * c, p);\n}\n\nexport\
    \ function getDiscreteLog(a: number, b: number, p: number): number {\n  if (b\
    \ === 0) {\n    return 0;\n  }\n  if (b === 1) {\n    return 1;\n  }\n  if (a\
    \ === 0) {\n   ", "    let result = 1;\n    let x = n % p;\n    while (n > 0)\
    \ {\n        if (n % 2 == 1) {\n            result = (result * x) % p;\n     \
    \   }\n        n = Math.floor(n / 2);\n        x = (x * x) % p;\n    }\n    return\
    \ result;\n}\n", "    if (n >= p) {\n        n = n % p;\n    }\n    var result\
    \ = 1;\n    var base = n;\n    while (true) {\n        if (base === 0) {\n   \
    \         break;\n        }\n        if (base % 2 !== 0) {\n            result\
    \ = (result * n) % p;\n        }\n        base = base >> 1;\n        n = (n *\
    \ n) % p;\n    }\n    return result;\n}\n", "    return modp_rec(n, p, 1)\n}\n",
  "  let ret = 1;\n  for (let i = 0; i < n; i++) {\n    ret = (ret * 2) % p;\n  }\n\
    \  return ret;\n}\n", "  if (n === 0) {\n    return 1;\n  } else if (n === 1)\
    \ {\n    return n;\n  } else {\n    let half = modp(n >> 1, p);\n    let result\
    \ = (half * half) % p;\n    if (n % 2 === 1) {\n      result = (result * n) %\
    \ p;\n    }\n    return result;\n  }\n}\n", "    return BigInt(2) ** BigInt(n)\
    \ % BigInt(p);\n}\n", "  if (n === 0) {\n    return 1;\n  } else if (n % 2 ===\
    \ 0) {\n    return Math.pow(modp(n / 2, p), 2) % p;\n  } else {\n    return Math.pow(modp((n\
    \ - 1) / 2, p), 2) * 2 % p;\n  }\n}\n", "  if (n == 0) return 1;\n  if (n % 2\
    \ == 0) {\n    let a = modp(n/2, p);\n    return (a * a) % p;\n  } else {\n  \
    \  return (modp(n-1, p) * n) % p;\n  }\n}\n", "  if (n < 0) return p - modp(-n,\
    \ p);\n  if (n < p) return n;\n  if (n % p === 0) return 0;\n  return (n % p)\
    \ * Math.pow(2, log2(n / p)) % p;\n}\n\nexport function mod(a: number, b: number):\
    \ number {\n  return ((a % b) + b) % b;\n}\n", "  let mask = 1;\n  let result\
    \ = 1;\n  while (mask < n) {\n    if (n & mask) {\n      result = (result * p)\
    \ % mod;\n    }\n    p = (p * p) % mod;\n    mask <<= 1;\n  }\n  return result;\n\
    }\n", "    let power: number = 1;\n    while (n > 0) {\n        if (n % 2 ===\
    \ 1) {\n            power = (power * 2) % p;\n        }\n        n = Math.floor(n\
    \ / 2);\n    }\n    return power;\n}\n", "    if (n === 0) {\n        return 1;\n\
    \    }\n    // Split n by even and odd\n    const i = Math.floor(n / 2);\n   \
    \ const j = n - i * 2;\n    // Recursive call\n    const c = modp(i, p);\n   \
    \ // Flatten recursive call\n    const d = (c * c) % p;\n    // Return the result\n\
    \    return j === 0 ? d : (d * p) % p;\n}\n", "    let r = 1;\n    let x = n %\
    \ p;\n    while (n > 0) {\n        if (n % 2 == 1) r = (r * x) % p;\n        x\
    \ = (x * x) % p;\n        n = Math.floor(n / 2);\n    }\n    return r;\n}\n",
  "  let r = 1;\n  for (let i = 1; i <= n; i++) {\n    r = r * 2 % p;\n  }\n  return\
    \ r;\n}\n", "  if (n < 0) {\n    return -modp(-n, p);\n  } else if (n < p) {\n\
    \    return n;\n  } else {\n    //Should be: return modp(n % p, p);\n    //But,\
    \ for some reason, this numerically unstable\n    //implementation is necessary.\n\
    \    return modp(n - p, p);\n  }\n}\n", "    if (n == 0) return 1;\n    let result\
    \ = n;\n    while (n > 1) {\n        n--;\n        result = (result * n) % p;\n\
    \    }\n    return result;\n}\n", "    if (n == 0) return 1;\n    if (n == 1)\
    \ return 2;\n    const m = Math.floor(n / 2);\n    const t = modp(m, p);\n   \
    \ const r = modp(n - m, p);\n    if (n % 2 == 0) return (t * t) % p;\n    else\
    \ return (t * t * r) % p;\n}\n", "  if (n < 0) {\n    return 0;\n  }\n  if (n\
    \ === 0) {\n    return 1;\n  }\n  const m = n % (p - 1);\n  return Math.pow(2,\
    \ m) % p;\n}\n", "    let res = 1;\n    while (n > 0) {\n        if (n & 1) {\n\
    \            res = (res * p) % 101;\n        }\n        p = (p * p) % 101;\n \
    \       n >>= 1;\n    }\n    return res;\n}\n", "    if (n <= 1) {\n        return\
    \ n;\n    }\n    return (modp(n - 1, p) * 2) % p;\n}\n", "  // n = n mod p\n \
    \ n = n % p;\n  // m = 2^n mod p\n  var m = 1;\n  // Accumulate the answer.\n\
    \  for (let i = 0; i < n; i++) {\n    m = (m * 2) % p;\n  }\n  return m;\n}\n",
  "  var res = 1;\n  for (var i = 0; i < n; i++) {\n    res = (res * 2) % p;\n  }\n\
    \  return res;\n}\n", "    var ans = 1;\n    n = n % p;\n    while (n > 0) {\n\
    \        if (n % 2 != 0) {\n            ans = (ans * 2) % p;\n        }\n    \
    \    n = Math.floor(n / 2);\n        if (n > 0) {\n            ans = (ans * 2)\
    \ % p;\n        }\n    }\n    return ans;\n}\n", "  return (2 ** n) % p;\n}\n",
  "    if (n < 0) {\n        return modp(n + p, p);\n    }\n    if (n === 0) {\n \
    \       return 1;\n    }\n    if (n === 1) {\n        return n;\n    }\n    if\
    \ (n % 2 === 0) {\n        return modp(n / 2, p) ** 2 % p;\n    }\n    return\
    \ modp(n - 1, p) * n % p;\n}\n", "    let result = 1;\n    let pow2 = 2;\n   \
    \ while (n !== 0) {\n        if (n % 2 === 1) {\n            result = (result\
    \ * pow2) % p;\n        }\n        pow2 = (pow2 * pow2) % p;\n        n = Math.floor(n\
    \ / 2);\n    }\n    return result;\n}\n", "  let result = 1;\n  for (let i = 0;\
    \ i < n; i++) {\n    result = (result * 2) % p;\n  }\n  return result;\n}\n\n\
    export function solve(input: string): number {\n  const [, a, b] = /Generator\
    \ (\\w) starts with (\\d+)/.exec(input);\n  const aFactor = a === \"A\" ? 16807\
    \ : 48271;\n  const bFactor = b === \"B\" ? 48271 : 16807;\n  let aValue = +a;\n\
    \  let bValue = +b;\n  let count = 0;\n  for (let i = 0; i < 40000000; i++) {\n\
    \    aValue = (aValue * aFactor) % 2147483647;\n    bValue = (bValue * bFactor)\
    \ % 2147483647;\n    if ((aValue & 0xffff) === (bValue & 0xffff)) {\n      count++;\n\
    \    }\n  }\n  return count;\n}\n\nexport function solve2(input: string): number\
    \ {\n  const [, a, b] = /Generator (\\w) starts with (\\d+)/.exec(input);\n  const\
    \ aFactor = a === \"A\" ? 16807 : 48271;\n  const bFactor = b === \"B\" ? 48271\
    \ : 16807;\n  let aValue = +a;\n  let bValue = +b;\n  let count = 0;\n  for (let\
    \ i = 0; i < 5000000; i++) {\n    do {\n      aValue = (aValue * aFactor) % 2147483647;\n\
    \    } while (aValue % 4 !== 0);\n    do {\n      bValue = (bValue * bFactor)\
    \ % 2147483647;\n    } while (bValue % 8 !== 0);\n    if ((aValue & 0xffff) ===\
    \ (bValue & 0xffff)) {\n      count++;\n    }\n  }\n  return count;\n}", "   \
    \ return Math.pow(2, n) % p;\n}\n", "  const res = mod(n, p);\n  if (res < 0)\
    \ {\n    return p + res;\n  }\n  return res;\n}\n", "    let result = 1;\n   \
    \ for (let i = 0; i < n; i++) {\n        result = (result * 2) % p;\n    }\n \
    \   return result;\n}\n", "    if (n < p) {\n        return n;\n    }\n    else\
    \ {\n        let i = 0;\n        while (n >= p) {\n            n = n / 2;\n  \
    \          i++;\n        }\n        return modp(n, p) * Math.pow(2, i) % p;\n\
    \    }\n}\n", "    let res = 1;\n    for (let i = 0; i < n; i++) {\n        res\
    \ = (res * 2) % p;\n    }\n    return res;\n}\n", "  if (n === 0) {\n    return\
    \ 1;\n  }\n  if (n === 1) {\n    return 0;\n  }\n  if (n % 2 === 0) {\n    return\
    \ (modp(n / 2, p) * (1 + p)) % p;\n  }\n  return (modp(n - 1, p) + p) % p;\n}\n",
  "    let sum = 1;\n    for (let i = 1; i <= n; i++) {\n        sum = (sum * 2) %\
    \ p;\n    }\n    return sum;\n}\n", "    return Math.pow(2, n) % p;\n}\n", " \
    \ if (n == 0) {\n    return 1;\n  } else if (n % 2 == 0) {\n    //n even\n   \
    \ let x = modp(n / 2, p);\n    return (x * x) % p;\n  } else {\n    //n odd\n\
    \    return ((modp(n - 1, p) % p) * (modp(n, p) % p)) % p;\n  }\n}\n", "  if (n\
    \ === 0) {\n    return 1;\n  } else if (n % 2 === 0) {\n    return square(modp(n\
    \ / 2, p)) % p;\n  } else {\n    return (modp(n - 1, p) * n) % p;\n  }\n}\n",
  "    if (n === 0) {\n        return 1;\n    } else if (n % 2 === 0) {\n        let\
    \ r = modp(n / 2, p);\n        return (r * r) % p;\n    } else {\n        return\
    \ (2 * modp(n - 1, p)) % p;\n    }\n}\n", "  var nbDigits = Math.floor(Math.log(n)\
    \ / Math.log(2));\n  var result = 1;\n  var accumulator = 2;\n  while (nbDigits\
    \ > 0) {\n    if (n >= Math.pow(2, nbDigits)) {\n      result = (result * accumulator)\
    \ % p;\n      n -= Math.pow(2, nbDigits);\n    }\n    accumulator = (accumulator\
    \ * accumulator) % p;\n    nbDigits--;\n  }\n  return result;\n}\n", "    if (n\
    \ === 0) {\n        return 1;\n    }\n    else if (n % 2 === 0) {\n        return\
    \ modp(n/2, p) * modp(n/2, p) % p;\n    }\n    else {\n        return 2 * modp(n-1,\
    \ p) % p;\n    }\n}\n", "  const n2: number = mod(n, p);\n  const n1: number =\
    \ ((p - 1) / 2) % 2 ? n2 : 1;\n  const res: number = mul(n1, n2);\n  return mod(res,\
    \ p);\n}\n", "  var res = 1;\n  while (n > 0) {\n    if (n & 1) {\n      res =\
    \ (res * 2) % p;\n    }\n    n >>= 1;\n    res = res % p;\n  }\n  return res;\n\
    }\n", "  // 2^n = (1 + 1)^n = C(n, 0) + C(n, 1) + ... + C(n, n)\n  // 2^n mod\
    \ p = sum of (C(n, i) mod p) for i in [0, n]\n  // C(n, i) mod p = (n! / i!(n\
    \ - i)!) mod p\n  let nModP = n % p;\n  let mod: number = 1;\n  for (let i = 1;\
    \ i <= nModP; i++) {\n    mod *= i;\n    mod %= p;\n  }\n  let factorialNModP\
    \ = mod;\n  let factorialIModP = 1;\n  mod = 1;\n  for (let i = 1; i <= nModP;\
    \ i++) {\n    mod *= (nModP - i + 1);\n    mod %= p;\n    factorialIModP *= i;\n\
    \    factorialIModP %= p;\n    let result = mod * modInverse(factorialIModP, p);\n\
    \    if (result < 0) {\n      result += p;\n    }\n    console.log(`(n=${nModP},\
    \ i=${i}) = ${result}`);\n  }\n  return mod;\n}\n", "  if (n < 0) {\n    return\
    \ 0;\n  }\n  let res = 1;\n  let cn = n;\n  let cp = p;\n  while (cn > 0) {\n\
    \    if (cn & 1) {\n      res = (res * cn) % cp;\n    }\n    cn = cn >> 1;\n \
    \   cp = (cp * cp) % p;\n  }\n  return res;\n}\n", "  // If n is even, there is\
    \ no need to keep track of the list of\n  // even powers of 2, since they are\
    \ all divisible by 2, which means\n  // they don't contribute to the final result.\n\
    \  if (n % 2 == 0) {\n    return Math.pow(2, n/2) % p;\n  }\n  // If p is odd,\
    \ then it can be written as 2k+1. This means that\n  // 2^n = 2^k * (2^k)^2, and\
    \ so\n  // (2^n mod p) = (2^k mod p) * (2^k mod p)^2 mod p\n  //             =\
    \ (2^k mod p) * (2^k mod p) mod p\n  //             = (2^k mod p)^2 mod p\n  //\
    \             = (2^2k mod p) mod p\n  if (p % 2 == 1) {\n    return Math.pow(2,\
    \ 2*(n/2)) % p;\n  }\n  // If n is odd and p is even, then the result is\n  //\
    \ (2^n mod p) = (2^(n-1) mod p) * 2\n  return (2 * modp(n-1, p)) % p;\n}\n", " \
    \ if (n === 0) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    const r = modp(n\
    \ / 2, p);\n    return (r * r) % p;\n  }\n  return (modp(n - 1, p) * n) % p;\n\
    }\n", "    if (n === 0) {\n        return 1;\n    }\n    const value = modp(n\
    \ >> 1, p);\n    return ((n & 1) === 0) ? ((value * value) % p) : ((value * value\
    \ * 2) % p);\n}\n", "    return Math.pow(2, n) % p;\n}\n", "    return Math.pow(2,\
    \ n) % p;\n}\n", "    let res = 1;\n    while (n > 0) {\n        if (n & 1) {\n\
    \            res = (res * n) % p;\n        }\n        n = n >> 1;\n        n =\
    \ (n * n) % p;\n    }\n    return res;\n}\n", "    if (n === 0) return 1;\n  \
    \  if (n % 2 === 0) {\n        return modp(n / 2, p) ** 2 % p;\n    } else {\n\
    \        return n * modp(n - 1, p) % p;\n    }\n}", "    let res = 1;\n    n =\
    \ n % p;\n    while (n > 0) {\n        if (n & 1)\n            res = (res * 2)\
    \ % p;\n        n = n >> 1;\n    }\n    return res;\n}\n", "    //let a = Math.pow(2,\
    \ Math.floor(Math.log2(n)));\n    //let b = n - a;\n    let a = 2 ** Math.floor(Math.log2(n));\n\
    \    let b = n - a;\n    return (b == 0) ? a % p : (2 * a * modp(b, p)) % p;\n\
    }\n", "    let res = 1;\n    while (n > 0) {\n        if (n & 1) {\n         \
    \   res = (res * n) % p;\n        }\n        n = n >> 1;\n        n = (n * n)\
    \ % p;\n    }\n    return res;\n}\n", "  let res = 1;\n  for (let i = 0; i < n;\
    \ i++) {\n    res = (res * 2) % p;\n  }\n  return res;\n}\n", "  var result =\
    \ 1;\n  while (n > 0) {\n    if (n % 2) {\n      result = (result * p) % 10;\n\
    \    }\n    n = Math.floor(n / 2);\n    p = (p * p) % 10;\n  }\n  return result;\n\
    }\n", "    let bin = n.toString(2);\n    let res = 1;\n    for (let i = 0; i <\
    \ bin.length; i++) {\n        if (bin[i] === '1') {\n            res = (res *\
    \ 2) % p;\n        }\n        res = (res * res) % p;\n    }\n    return res;\n\
    }\n", "    if (n < 0) {\n        //we work in the positive domain\n        return\
    \ modp(-n, p);\n    }\n    if (n < p) {\n        //base case\n        return n;\n\
    \    }\n    //recursive step\n    let x = modp(Math.floor(n / p), p);\n    //shift\
    \ and add\n    return (x << 1) + (n % 2);\n}\n", "  var res = 1;\n  while (n >\
    \ 0) {\n    res = (res * (n & 1 ? p : 1)) % P;\n    n >>= 1;\n    p = (p * p)\
    \ % P;\n  }\n  return res;\n}\n", "    if (n === 0) {\n        return 1;\n   \
    \ }\n    let ans = 1;\n    let x = n;\n    while (p > 0) {\n        if (p % 2\
    \ !== 0) {\n            ans = (ans * x) % MOD;\n        }\n        x = (x * x)\
    \ % MOD;\n        p = p / 2;\n    }\n    return ans;\n}\n", "    let result =\
    \ 1;\n    let powN = n;\n    let powP = p;\n    while (powN > 0) {\n        if\
    \ (powN % 2 == 1) {\n            result = (result * powP) % p;\n        }\n  \
    \      powN = Math.floor(powN / 2);\n        powP = (powP * powP) % p;\n    }\n\
    \    return result;\n}\n", "    if (n === 0) return 1;\n    if (n === 1) return\
    \ n;\n    let temp = modp(n / 2, p);\n    return ((temp % p) * (temp % p) * (n\
    \ % 2 === 0 ? 1 : n)) % p;\n}\n", "  //Modular Exponentiation\n  let r = 1;\n\
    \  for (let i = 0; i < n; i++) {\n    r = (r * 2) % p;\n  }\n  return r;\n}\n",
  "    // TODO: implement me\n    return 0;\n}\n", "  let res = 1;\n  while (n !==\
    \ 0) {\n    if (n & 1) {\n      res = (res * 2) % p;\n    }\n    n >>= 1;\n  }\n\
    \  return res;\n}\n", "    let result = 1;\n    for (let i = 0; i < n; i++) {\n\
    \        result = (result * 2) % p;\n    }\n    return result;\n}\n", "  if (n\
    \ == 0) {\n    return 1;\n  } else if (n % 2 == 0) {\n    return modp(n / 2, p)\
    \ ** 2 % p;\n  } else {\n    return (modp(n - 1, p) * modp(n, p)) % p;\n  }\n\
    }\n", "    return Math.pow(2, n) % p;\n}\n", "    // We are using the built-in\
    \ JavaScript % operator for convenience.\n    // Normally you would not compute\
    \ the modulo with a simple % operation.\n    return n % p;\n}\n", "    //TODO:\
    \ Implement modp.\n    return 0;\n}\n", "  if (n === 0) {\n    return 1;\n  }\n\
    \  if (n % 2 === 0) {\n    let r = modp(n / 2, p);\n    return r * r % p;\n  }\n\
    \  return modp(n - 1, p) * n % p;\n}\n", "  if (n < 0) {\n    return p - modp(-n,\
    \ p);\n  }\n  if (n === 0) {\n    return 1;\n  }\n  if (n === 1) {\n    return\
    \ 0;\n  }\n  if (n % 2 === 0) {\n    return (2 * modp(n / 2, p)) % p;\n  }\n \
    \ if (n % 2 === 1) {\n    return (2 * modp((n - 1) / 2, p) + 2) % p;\n  }\n  throw\
    \ Error(\"modp: unreachable code\");\n}\n", "  let power = 1;\n  for (let i =\
    \ 0; i < n; i++) {\n    power = power * 2 % p;\n  }\n  return power;\n}\n", " \
    \ if (n === 0) {\n    return 1;\n  }\n  let ret = 1;\n  for (let i = 0; i < n;\
    \ i++) {\n    ret = (ret * 2) % p;\n  }\n  return ret;\n}\n", "  // Fill in your\
    \ code here\n  const i = ~~(Math.log(n) / Math.log(2));\n  const twoi = Math.pow(2,\
    \ i);\n  if (twoi === n) {\n    return n % p;\n  } else {\n    return (modp(twoi,\
    \ p) * modp(n - twoi, p)) % p;\n  }\n}\n", "  // make sure n is a number, see:\
    \ https://stackoverflow.com/a/1830844/673991\n  if (isNaN(n)) {\n    throw new\
    \ Error('modp(): n is not a number');\n  }\n  // note that n % p is a mathematically\
    \ correct result but not what we want here\n  // because that result can be negative,\
    \ e.g.\n  // >>> -3 % 7\n  // -3\n  if (n % p === 0) {\n    return 0;\n  }\n \
    \ // however, for our purposes, we need a positive result that can be used as\
    \ an\n  // array index, e.g.\n  // >>> -3 % 7\n  // 4\n  let m = n % p;\n  if\
    \ (m < 0) {\n    m += p;\n  }\n  return m;\n}\n", "  if (n === 0) {\n    return\
    \ 1;\n  }\n  if (n % 2 === 0) {\n    return modp(n / 2, p) ** 2 % p;\n  }\n  return\
    \ (modp(n - 1, p) * 2) % p;\n}\n", "  if (n === 0) {\n    return 1;\n  }\n  if\
    \ (n % 2 === 0) {\n    return (modp(n / 2, p) ** 2) % p;\n  }\n  return (2 * modp(n\
    \ - 1, p)) % p;\n}\n", "    if (n === 0) {\n        return 1;\n    } else if (n\
    \ % 2 === 0) {\n        const x = modp(n / 2, p);\n        return modmult(x, x,\
    \ p);\n    } else {\n        const x = modp(n - 1, p);\n        return modmult(n,\
    \ x, p);\n    }\n}\n", "    if (n == 0) {\n        return 1;\n    } else if (n\
    \ % 2 == 0) {\n        return Math.pow(modp(n / 2, p), 2) % p;\n    } else {\n\
    \        return Math.pow(modp((n - 1) / 2, p), 2) * n % p;\n    }\n}\n", "  if\
    \ (n === 0) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    return modp(n / 2,\
    \ p) ** 2 % p;\n  }\n  if (n % 2 === 1) {\n    return modp(n - 1, p) * 2 % p;\n\
    \  }\n}\n\ndescribe(\"TEST MODP\", () => {\n  test(\"#1\", () => {\n    expect(modp(3,\
    \ 5)).toBe(3);\n  });\n  test(\"#2\", () => {\n    expect(modp(1101, 101)).toBe(2);\n\
    \  });\n  test(\"#3\", () => {\n    expect(modp(0, 101)).toBe(1);\n  });\n  test(\"\
    #4\", () => {\n    expect(modp(3, 11)).toBe(8);\n  });\n  test(\"#5\", () => {\n\
    \    expect(modp(100, 101)).toBe(1);\n  });\n});", "  if (n < 0) {\n    let result\
    \ = modp(-n, p);\n    if (result === 0) {\n      return 0;\n    } else {\n   \
    \   return p - result;\n    }\n  }\n  if (n === 0) {\n    return 1;\n  }\n  if\
    \ (n % 2 === 0) {\n    return square(modp(n / 2, p)) % p;\n  } else {\n    return\
    \ modp(n - 1, p) * n % p;\n  }\n}\n", "  if (n === 0) {\n    return 1;\n  } else\
    \ if (n % 2 === 0) {\n    return modp(n / 2, p) ** 2 % p;\n  } else {\n    return\
    \ n * modp(n - 1, p) % p;\n  }\n}\n", "    let x = 1;\n    let y = n;\n    while\
    \ (p > 0) {\n        if (p % 2 == 1) {\n            x = (x * y) % 101;\n     \
    \   }\n        y = (y * y) % 101;\n        p = Math.floor(p / 2);\n    }\n   \
    \ return x % 101;\n}\n", "    if (n < 0) {\n        return p - modp(-n, p);\n\
    \    }\n    if (n === 0) {\n        return 1;\n    }\n    if (n === 1) {\n   \
    \     return n;\n    }\n    if (n % 2) {\n        return (modp(n - 1, p) * 2)\
    \ % p;\n    }\n    return modp(n / 2, p) ** 2 % p;\n}\n", "  return Math.pow(2,\
    \ n) % p;\n}\n", "  if (n === 0) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n\
    \    let a = modp(n / 2, p);\n    return (a * a) % p;\n  } else {\n    return\
    \ (modp(n - 1, p) * n) % p;\n  }\n}\n", "    if (n === 0) {\n        return 1;\n\
    \    }\n    else if (n % 2 === 0) {\n        return modp(n / 2, p) ** 2 % p;\n\
    \    }\n    else {\n        return modp(n - 1, p) * n % p;\n    }\n}\n", "  return\
    \ intToInt(mod(BigInt(n), BigInt(p)));\n}\n", "    if (n == 0) return 1;\n   \
    \ if (n % 2 == 0) {\n        const m = modp(n / 2, p);\n        return (m * m)\
    \ % p;\n    } else {\n        return (modp(n - 1, p) * n) % p;\n    }\n}\n", " \
    \ var r = 1;\n  var base = n % p;\n  while (n > 0) {\n    if (n % 2 === 1) {\n\
    \      r = (r * base) % p;\n    }\n    n = Math.floor(n / 2);\n    base = (base\
    \ * base) % p;\n  }\n  return r;\n}\n", "    //Q2: Implement modp(n, p) here\n\
    \    return 0;\n}\n", "    if (n < 0) {\n        throw 'modp of negative number';\n\
    \    }\n    return powmod(2, n, p);\n}\n", "  if (n === 0) {\n    return 1;\n\
    \  }\n  if (n % 2 === 0) {\n    const x = modp(n / 2, p);\n    return (x * x)\
    \ % p;\n  }\n  return (modp(n - 1, p) * n) % p;\n}\n", "  if (n === 0) {\n   \
    \ return 1;\n  } else if (n % 2 === 0) {\n    let b = modp(n / 2, p);\n    return\
    \ (b * b) % p;\n  } else {\n    return (n * modp(n - 1, p)) % p;\n  }\n}\n", " \
    \ // TODO\n  //@ts-ignore\n  let res = Math.pow(2, n) % p;\n  return res;\n}\n",
  "    if (n == 0) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        return\
    \ modp(n / 2, p) ** 2 % p;\n    }\n    else {\n        return (2 * modp(n - 1,\
    \ p)) % p;\n    }\n}\n", "    let r = 1;\n    while (n) {\n        n & 1 && (r\
    \ = r * 2 % p);\n        n >>= 1;\n        2 * r % p === 0 && (r = 0);\n    }\n\
    \    return r;\n}\n", "    let result = 1;\n    const nbits = Math.round(Math.log2(n));\n\
    \    for (let i = nbits; i >= 0; i--) {\n        result = result * result % p;\n\
    \        if (n % (1 << i) === 1) {\n            result = result * 2 % p;\n   \
    \     }\n    }\n    return result;\n}\n\nexport function compute(points: number[]):\
    \ number {\n    const n = points.length;\n    const min = Math.min(...points);\n\
    \    const max = Math.max(...points);\n    const range = max - min;\n    const\
    \ nParts = Math.ceil(range / n);\n    const parts = [];\n    for (let i = 0; i\
    \ < nParts; i++) {\n        parts.push(new Array(n).fill(0));\n    }\n    for\
    \ (let i = 0; i < n; i++) {\n        const target = Math.floor((points[i] - min)\
    \ / nParts);\n        parts[target][i] = 1;\n    }\n    let sum = 0;\n    for\
    \ (let i = 0; i < nParts; i++) {\n        sum += modp(parts[i].reduce((sum, val)\
    \ => sum + val, 0), 1000000007);\n    }\n    return sum;\n}", "    return (n %\
    \ p + p) % p;\n}\n", "  if (n === 0) {\n    return 1;\n  }\n  let x = 1;\n  let\
    \ y = 2;\n  for (let i = n; i > 0; i >>= 1) {\n    if (i & 1) {\n      x = (x\
    \ * y) % p;\n    }\n    y = (y * y) % p;\n  }\n  return x;\n}\n", "  if (n % p\
    \ == 0) return 0;\n  let res = 1;\n  for (let i = 0; i < n; i++) {\n    res =\
    \ (res * 2) % p;\n  }\n  return res;\n}\n", "    if (n === 0) {\n        return\
    \ 1;\n    } else if (n % 2 === 0) {\n        return modp(n / 2, p) ** 2 % p;\n\
    \    } else {\n        return modp(n - 1, p) * 2 % p;\n    }\n}\n", "  if (n ==\
    \ 0) return 1;\n  let x = modp(Math.floor(n / 2), p);\n  let y = (x * x) % p;\n\
    \  if (n % 2 == 0) return y;\n  else return (y * 2) % p;\n}\n", "  let res = 1;\n\
    \  const b = n % p;\n  if (b === 0) {\n    return 0;\n  }\n  for (let i = 0; i\
    \ < n; i++) {\n    res = (res * b) % p;\n  }\n  return res;\n}\n", "    let res\
    \ = 1;\n    for (let i = 0; i < n; i++) {\n        res = (res * 2) % p;\n    }\n\
    \    return res;\n}\n", "  let res = 1;\n  while (n > 0) {\n    if (n & 1) {\n\
    \      res = (res * n) % p;\n    }\n    n = n >> 1;\n    n = (n * n) % p;\n  }\n\
    \  return res;\n}\n", "  // TODO\n  let result = 1;\n  for (let i = 0; i < n;\
    \ i++) {\n    result = (result * 2) % p;\n  }\n  return result;\n}\n", "    var\
    \ res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res = (res\
    \ * n) % p;\n        }\n        n = n >> 1;\n        n = (n * n) % p;\n    }\n\
    \    return res;\n}\n", "  return Math.pow(2, n) % p;\n}\n", "    if (n === 0)\
    \ {\n        return 1;\n    }\n    let m = n;\n    let res = 1;\n    let x = 2;\n\
    \    while (m > 0) {\n        if (m % 2 !== 0) {\n            res = (res * x)\
    \ % p;\n        }\n        x = (x * x) % p;\n        m = m >> 1;\n    }\n    return\
    \ res;\n}\n", "  // TODO: Implement your solution here\n  let res = 1;\n  while\
    \ (n > 0) {\n    if (n % 2 === 1) {\n      res = (res * 2) % p;\n    }\n    n\
    \ = Math.floor(n / 2);\n  }\n  return res;\n}\n", "  var c: number;\n  if (n ===\
    \ 0) {\n    return 1;\n  } else if (n % 2 === 0) {\n    c = modp(n / 2, p);\n\
    \    return (c * c) % p;\n  } else {\n    c = modp((n - 1) / 2, p);\n    return\
    \ (2 * c * c) % p;\n  }\n}\n", "    if (n === 0) {\n        return 1;\n    } else\
    \ if (n % 2 === 0) {\n        return modp(n/2, p) * modp(n/2, p) % p;\n    } else\
    \ {\n        return modp(n-1, p) * modp(n+1, p) % p;\n    }\n}\n\n", "  let result\
    \ = 1;\n  let x = n % p;\n  while (n > 0) {\n    if (n % 2 === 1) {\n      result\
    \ = (result * x) % p;\n    }\n    n = Math.floor(n / 2);\n    x = (x * x) % p;\n\
    \  }\n  return result;\n}\n", "    var result = 1;\n    for (var i = 1; i <= n;\
    \ i++) {\n        result = (result * 2) % p;\n    }\n    return result;\n}\n",
  "  if (n === 0) {\n    return 1;\n  } else if (n % 2 == 0) {\n    return modp(n\
    \ / 2, p) ** 2 % p;\n  } else {\n    return n * modp(n - 1, p) % p;\n  }\n}\n",
  "  const two_pow_n = Math.pow(2, n);\n  return two_pow_n % p;\n}\n", "  var res\
    \ = 1;\n  for (var i = 0; i < n; i++) {\n    res = (res * 2) % p;\n  }\n  return\
    \ res;\n}\n\ndescribe('helpers', () => {\n  describe('lcm', () => {\n    it('works',\
    \ () => {\n      expect(lcm(1, 7)).toBe(7);\n      expect(lcm(4, 7)).toBe(28);\n\
    \      expect(lcm(4, 7, 11)).toBe(244);\n    });\n  });\n\n  describe('isPalindrome',\
    \ () => {\n    it('works', () => {\n      expect(isPalindrome('')).toBe(true);\n\
    \      expect(isPalindrome('0')).toBe(true);\n      expect(isPalindrome('1')).toBe(true);\n\
    \      expect(isPalindrome('2')).toBe(true);\n      expect(isPalindrome('3')).toBe(true);\n\
    \      expect(isPalindrome('9')).toBe(true);\n      expect(isPalindrome('11')).toBe(true);\n\
    \      expect(isPalindrome('22')).toBe(true);\n      expect(isPalindrome('33')).toBe(true);\n\
    \      expect(isPalindrome('99')).toBe(true);\n      expect(isPalindrome('909')).toBe(true);\n\
    \      expect(isPalindrome('919')).toBe(true);\n      expect(isPalindrome('909890')).toBe(true);\n\
    \      expect(isPalindrome('9098090')).toBe(true);\n      expect(isPalindrome('908809')).toBe(true);\n\
    \      expect(isPalindrome('908710')).toBe(false);\n      expect(isPalindrome('9087109')).toBe(false);\n\
    \      expect(isPalindrome('898798')).toBe(true);\n      expect(isPalindrome('8987981')).toBe(false);\n\
    \      expect(isPalindrome('9087109')).toBe(false);\n", "  let factor = 2;\n \
    \ let result = 1;\n  while (n > 0) {\n    if (n % 2 == 1) {\n      result = (result\
    \ * factor) % p;\n    }\n    factor = (factor * factor) % p;\n    n = n >> 1;\n\
    \  }\n  return result;\n}\n", "  let ans = 1;\n  let mult = n;\n  let nn = n;\n\
    \  while (nn > 0) {\n    if (nn % 2) {\n      ans = (ans * mult) % p;\n    }\n\
    \    mult = (mult * mult) % p;\n    nn = Math.floor(nn / 2);\n  }\n  return ans;\n\
    }\n", "  if (n === 0) {\n    return 1;\n  }\n  if (n % 2 === 0) {\n    const t\
    \ = modp(n / 2, p);\n    return (t * t) % p;\n  }\n  const t = modp((n - 1) /\
    \ 2, p);\n  return (t * t * n) % p;\n}\n", "  if (n == 0) return 1;\n  const t\
    \ = modp(n >> 1, p);\n  if (n & 1) {\n    return (t * t * n) % p;\n  } else {\n\
    \    return (t * t) % p;\n  }\n}\n", "    if (n === 0) return 1;\n    if (n ===\
    \ 1) return n;\n    if (n % 2 === 0) return modp(n / 2, p) ** 2 % p;\n    return\
    \ modp(n - 1, p) * modp(n, p) % p;\n}\n", "    if (n == 0) {\n        return 1;\n\
    \    }\n    if (n % 2 == 0) {\n        let m = modp(n / 2, p);\n        return\
    \ (m * m) % p;\n    }\n    else {\n        return ((modp(n - 1, p) * n) % p);\n\
    \    }\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
