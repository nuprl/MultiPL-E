name: HumanEval_132_is_nested
language: ts
prompt: "//Create a function that takes a string as input which contains only square\
  \ brackets.\n// The function should return true if and only if there is a valid\
  \ subsequence of brackets \n// where at least one bracket in the subsequence is\
  \ nested.\n// >>> is_nested(\"[[]]\")\n// true\n// >>> is_nested(\"[]]]]]]][[[[[]\"\
  )\n// false\n// >>> is_nested(\"[][]\")\n// false\n// >>> is_nested(\"[]\")\n//\
  \ false\n// >>> is_nested(\"[[][]]\")\n// true\n// >>> is_nested(\"[[]][[\")\n//\
  \ true\nfunction is_nested(string: string): boolean {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = is_nested;\n  assert.deepEqual(candidate(\"[[]]\"\
  ),true);\n  assert.deepEqual(candidate(\"[]]]]]]][[[[[]\"),false);\n  assert.deepEqual(candidate(\"\
  [][]\"),false);\n  assert.deepEqual(candidate(\"[]\"),false);\n  assert.deepEqual(candidate(\"\
  [[[[]]]]\"),true);\n  assert.deepEqual(candidate(\"[]]]]]]]]]]\"),false);\n  assert.deepEqual(candidate(\"\
  [][][[]]\"),true);\n  assert.deepEqual(candidate(\"[[]\"),false);\n  assert.deepEqual(candidate(\"\
  []]\"),false);\n  assert.deepEqual(candidate(\"[[]][[\"),true);\n  assert.deepEqual(candidate(\"\
  [[][]]\"),true);\n  assert.deepEqual(candidate(\"\"),false);\n  assert.deepEqual(candidate(\"\
  [[[[[[[[\"),false);\n  assert.deepEqual(candidate(\"]]]]]]]]\"),false);\n}\n\ntest();"
completions: ["    var count: number = 0;\n    for (var i: number = 0; i < string.length;\
    \ i++) {\n        if (string[i] == '[') {\n            count += 1;\n        }\
    \ else if (string[i] == ']') {\n            count -= 1;\n        }\n        if\
    \ (count < 0) {\n            return false;\n        }\n    }\n    return count\
    \ == 0;\n}", "    var stack: any[] = []\n    var map: any = {\n        \"(\":\
    \ \")\",\n        \"[\": \"]\",\n        \"{\": \"}\"\n    }\n    var set: any\
    \ = new Set([\"(\", \"[\", \"{\"])\n    var valid: boolean = false\n    for (var\
    \ i: number = 0; i < string.length; i++) {\n        if (set.has(string[i])) {\n\
    \            stack.push(string[i])\n        } else {\n            var last: any\
    \ = stack.pop()\n            if (string[i] !== map[last]) {\n                return\
    \ false\n            } else {\n                valid = true\n            }\n \
    \       }\n    }\n    return valid\n}\nconsole.log(is_nested(\"[[]][[\"));", " \
    \   const braces = {\n        '(': ')',\n        '[': ']',\n        '{': '}'\n\
    \    };\n    let queue: string[] = [];\n    for (let char of string) {\n     \
    \   if (char in braces) {\n            queue.push(char);\n        } else {\n \
    \           if (braces[queue.pop()] !== char) {\n                return false;\n\
    \            }\n        }\n    }\n    return queue.length === 0;\n}\n", "    if\
    \ (string.length === 0) {\n        return false;\n    }\n    let currentNesting\
    \ = 0;\n    let hasNested: boolean = false;\n    for (let char of string) {\n\
    \        if (char === '[') {\n            currentNesting += 1;\n        } else\
    \ if (char === ']') {\n            currentNesting -= 1;\n        }\n        if\
    \ (currentNesting < 0) {\n            return false;\n        }\n        if (currentNesting\
    \ > 0) {\n            hasNested = true;\n        }\n    }\n    return hasNested;\n\
    }\n", "    let opener: string = '[';\n    let closer: string = ']';\n    let stack:\
    \ string[] = [];\n    for (let i: number = 0; i < string.length; i++) {\n    \
    \    if (string[i] === opener) {\n            stack.push(string[i]);\n       \
    \ } else if (string[i] === closer) {\n            if (stack.length === 0) {\n\
    \                return false;\n            } else {\n                stack.pop();\n\
    \            }\n        }\n    }\n    return (stack.length === 0) ? true : false;\n\
    }\n", "    let stack: string[] = [];\n    for (let i = 0; i < string.length; i++)\
    \ {\n        if (string[i] === '[') {\n            stack.push(string[i]);\n  \
    \      } else if (string[i] === ']') {\n            if (stack.length > 0) {\n\
    \                stack.pop();\n            } else {\n                return false;\n\
    \            }\n        }\n    }\n    return stack.length > 0 ? false : true;\n\
    }\n", "    let list: string[] = [];\n    let nested: boolean = false;\n    for\
    \ (let char of string) {\n        if (char === \"[\") {\n            list.push(char);\n\
    \        } else if (char === \"]\") {\n            if (list.length > 0) {\n  \
    \              list.pop();\n                nested = true;\n            } else\
    \ {\n                return false;\n            }\n        }\n    }\n    return\
    \ nested;\n}\n", "    if (string.length <= 1) return false;\n    let stack: string[]\
    \ = [];\n    for (let i: number = 0; i < string.length; i++) {\n        const\
    \ elem: string = string[i];\n        if (elem === '[') {\n            stack.push(elem);\n\
    \        } else if (elem === ']') {\n            if (stack.length === 0) return\
    \ false;\n            stack.pop();\n        }\n    }\n    return stack.length\
    \ === 0;\n}\n", "  if (string.length < 2) {\n    return false;\n  }\n  let currentLetter\
    \ = 0;\n  let currentCount = 0;\n  let nextCount = 0;\n  let maxCount = 0;\n \
    \ for (let i = 0; i < string.length; i++) {\n    if (string[i] === \"[\") {\n\
    \      currentCount++;\n    } else {\n      currentCount--;\n    }\n    if (currentCount\
    \ < 0) {\n      return false;\n    }\n    if (currentCount > nextCount) {\n  \
    \    nextCount = currentCount;\n    }\n    if (currentCount === 0) {\n      currentLetter\
    \ = i;\n      maxCount = Math.max(maxCount, nextCount);\n      nextCount = 0;\n\
    \    }\n  }\n  if (currentCount === 0) {\n    return maxCount > 1;\n  }\n  return\
    \ false;\n}\n", "    let counter = 0;\n    let flag = false;\n    let hasOpenBracket\
    \ = false;\n    for (let i = 0; i < string.length; i++) {\n        const char\
    \ = string[i];\n        if (char === '[') {\n            hasOpenBracket = true;\n\
    \            counter++;\n        } else if (char === ']') {\n            counter--;\n\
    \        }\n        if (counter < 0) {\n            return false;\n        }\n\
    \        if (counter === 0 && hasOpenBracket) {\n            flag = true;\n  \
    \      }\n    }\n    return flag;\n}\nconsole.log(is_nested(\"[[]]\"));\nconsole.log(is_nested(\"\
    []]]]]]][[[[[]\"));\nconsole.log(is_nested(\"[][]\"));\nconsole.log(is_nested(\"\
    []\"));\nconsole.log(is_nested(\"[[][]]\"));\nconsole.log(is_nested(\"[[]][[\"\
    ));\n", "    let stack = [];\n    for (let i = 0; i < string.length; i++) {\n\
    \        if (string[i] === '[') {\n            stack.push(string[i]);\n      \
    \  } else if (string[i] === ']') {\n            if (stack.length > 0) {\n    \
    \            stack.pop();\n            } else {\n                return false;\n\
    \            }\n        }\n    }\n    return stack.length === 0;\n}\n\n", "  \
    \  const stack: string[] = [];\n    const bracket_map: { [index: string]: string\
    \ } = {\n        \"{\": \"}\",\n        \"[\": \"]\",\n        \"(\": \")\"\n\
    \    };\n    const open_brackets: string[] = Object.keys(bracket_map);\n    const\
    \ closing_brackets: string[] = Object.values(bracket_map);\n    for (let bracket\
    \ of string) {\n        if (open_brackets.includes(bracket)) {\n            stack.push(bracket);\n\
    \        } else if (closing_brackets.includes(bracket)) {\n            if (stack.length\
    \ === 0) {\n                return false;\n            }\n            const top_item\
    \ = stack.pop();\n            if (bracket_map[top_item] !== bracket) {\n     \
    \           return false;\n            }\n        }\n    }\n    return stack.length\
    \ === 0;\n}\n", "    let stack: string[] = [];\n    let is_nested: boolean = false;\n\
    \    for (let i = 0; i < string.length; i++) {\n        if (string[i] === '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] === ']')\
    \ {\n            stack.pop();\n            if (stack.length === 0) {\n       \
    \         is_nested = true;\n            }\n        }\n    }\n    return is_nested;\n\
    }", "    let openBrackets = 0;\n    let closeBrackets = 0;\n    for (let i = 0;\
    \ i < string.length; i++) {\n        if (string[i] === \"[\") {\n            openBrackets\
    \ += 1;\n        } else if (string[i] === \"]\") {\n            closeBrackets\
    \ += 1;\n        }\n        if (closeBrackets > openBrackets) {\n            return\
    \ false;\n        }\n    }\n    return openBrackets === closeBrackets;\n}", " \
    \   let bracketStack: string[] = [];\n    for (let i = 0; i < string.length; i++)\
    \ {\n        if (string[i] === '[') {\n            bracketStack.push(string[i]);\n\
    \        } else if (string[i] === ']') {\n            if (bracketStack.length\
    \ === 0) {\n                return false;\n            } else {\n            \
    \    bracketStack.pop();\n            }\n        }\n    }\n    return (bracketStack.length\
    \ === 0);\n}\n\ndescribe('is_nested', () => {\n    test('no string', () => {\n\
    \        expect(is_nested('')).toBe(false);\n    });\n    test('[[]]', () => {\n\
    \        expect(is_nested('[[]]')).toBe(true);\n    });\n    test('[][]', () =>\
    \ {\n        expect(is_nested('[][]')).toBe(false);\n    });\n    test('[]', ()\
    \ => {\n        expect(is_nested('[]')).toBe(false);\n    });\n    test('[[][]]',\
    \ () => {\n        expect(is_nested('[[][]]')).toBe(true);\n    });\n    test('[[]][[',\
    \ () => {\n        expect(is_nested('[[]][[')).toBe(true);\n    });\n    test('[]]]]]]][[[[[]',\
    \ () => {\n        expect(is_nested('[]]]]]]][[[[[]')).toBe(false);\n    });\n\
    });", "    let bracketList: string[] = string.split('');\n    let isNested: boolean\
    \ = false;\n    let keepGoing: boolean = true;\n    let j: number = 0;\n    for\
    \ (let i: number = 0; i < bracketList.length && keepGoing; i++) {\n        if\
    \ (bracketList[i] === '[') {\n            for (j = i + 1; j < bracketList.length;\
    \ j++) {\n                if (bracketList[j] === ']') {\n                    isNested\
    \ = true;\n                    break;\n                }\n            }\n    \
    \        keepGoing = false;\n        }\n    }\n    if (j < bracketList.length)\
    \ {\n        let bracketString: string = '';\n        for (let k: number = j +\
    \ 1; k < bracketList.length; k++) {\n            bracketString += bracketList[k];\n\
    \        }\n        isNested = is_nested(bracketString);\n    }\n    return isNested;\n\
    }\n", "    let squared = string.split('');\n    let balanced = 0;\n    for (let\
    \ i = 0; i < squared.length; i++) {\n        if (squared[i] === '[') {\n     \
    \       balanced += 1;\n        } else if (squared[i] === ']') {\n           \
    \ balanced -= 1;\n        }\n        if (balanced < 0) {\n            return false;\n\
    \        }\n    }\n    return balanced === 0;\n}\n", "    var found: boolean =\
    \ false;\n    var s = string.replace(/\\[\\]/g, \"\")\n    if (s.length == 0)\
    \ {\n        found = true;\n    }\n    return found;\n}\nconsole.log(is_nested(\"\
    [[]]\")); //true\nconsole.log(is_nested(\"[]]]]]]][[[[[]\")); //false\nconsole.log(is_nested(\"\
    [][]\")); //false\nconsole.log(is_nested(\"[]\")); //false\nconsole.log(is_nested(\"\
    [[][]]\")); //true\nconsole.log(is_nested(\"[[]][[\")); //true\n", "    //return\
    \ false;\n    let stringArr = string.split('');\n    let openBrackets = ['[',\
    \ '{', '('];\n    let closeBrackets = [']', '}', ')'];\n    let bracketTracker\
    \ = [];\n    let isNested = false;\n    stringArr.forEach(element => {\n     \
    \   if (openBrackets.includes(element)) {\n            bracketTracker.push(element);\n\
    \        }\n        if (closeBrackets.includes(element)) {\n            // if\
    \ at any point the last element in bracketTracker is an open bracket\n       \
    \     // and element is the first close bracket in closeBrackets for that bracketTracker\n\
    \            // set isNested to true\n            if (bracketTracker.length >\
    \ 0) {\n                if (openBrackets.indexOf(bracketTracker[bracketTracker.length\
    \ - 1]) === closeBrackets.indexOf(element)) {\n                    isNested =\
    \ true;\n                }\n            }\n        }\n    });\n    return isNested;\n\
    }\n", "    let stack = [];\n    for (let i = 0; i < string.length; i++) {\n  \
    \      if (string[i] === '[') {\n            stack.push(string[i]);\n        }\
    \ else if (string[i] === ']') {\n            if (stack.length > 0) {\n       \
    \         stack.pop();\n            } else {\n                return false;\n\
    \            }\n        }\n    }\n    return true;\n}\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
