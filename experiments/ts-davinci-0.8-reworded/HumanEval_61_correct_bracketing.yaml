name: HumanEval_61_correct_bracketing
language: ts
prompt: "//brackets is a string of \"(\" and \")\".\n// return true if every opening\
  \ bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\"\
  )\n// false\n// >>> correct_bracketing(\"()\")\n// true\n// >>> correct_bracketing(\"\
  (()())\")\n// true\n// >>> correct_bracketing(\")(()\")\n// false\nfunction correct_bracketing(brackets:\
  \ string): boolean {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = correct_bracketing;\n  assert.deepEqual(candidate(\"\
  ()\"),true);\n  assert.deepEqual(candidate(\"(()())\"),true);\n  assert.deepEqual(candidate(\"\
  ()()(()())()\"),true);\n  assert.deepEqual(candidate(\"()()((()()())())(()()(()))\"\
  ),true);\n  assert.deepEqual(candidate(\"((()())))\"),false);\n  assert.deepEqual(candidate(\"\
  )(()\"),false);\n  assert.deepEqual(candidate(\"(\"),false);\n  assert.deepEqual(candidate(\"\
  ((((\"),false);\n  assert.deepEqual(candidate(\")\"),false);\n  assert.deepEqual(candidate(\"\
  (()\"),false);\n  assert.deepEqual(candidate(\"()()(()())())(()\"),false);\n  assert.deepEqual(candidate(\"\
  ()()(()())()))()\"),false);\n}\n\ntest();"
completions: ["    let leftBracketCounter = 0;\n    let rightBracketCounter = 0;\n\
    \    for (let index = 0; index < brackets.length; index++) {\n        if (brackets[index]\
    \ === \"(\") {\n            leftBracketCounter++;\n        } else if (brackets[index]\
    \ === \")\") {\n            rightBracketCounter++;\n        }\n    }\n    return\
    \ leftBracketCounter === rightBracketCounter;\n}\n", "    return brackets.split(\"\
    \").reduce((a, c) => a + (c === \"(\" ? 1 : -1), 0) === 0;\n}\n", "  let count\
    \ = 0;\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] ===\
    \ \"(\") {\n      count++;\n    } else if (brackets[i] === \")\") {\n      count--;\n\
    \    }\n    if (count < 0) {\n      return false;\n    }\n  }\n  return count\
    \ === 0;\n}\n", "  // INSERT YOUR CODE HERE\n  return false;\n}\n\n", "    var\
    \ stack: string[] = [];\n    for (var i = 0; i < brackets.length; i++) {\n   \
    \     if (brackets[i] == \"(\") {\n            stack.push(brackets[i]);\n    \
    \    } else if (brackets[i] == \")\") {\n            if (stack.length == 0) {\n\
    \                return false;\n            } else {\n                stack.pop();\n\
    \            }\n        }\n    }\n    return stack.length == 0;\n}\n", "    //\
    \ placeholder\n    return false;\n}\n\n", "  let sum = 0;\n  for (let i = 0; i\
    \ < brackets.length; i++) {\n    if (brackets[i] === \"(\") {\n      sum += 1;\n\
    \    } else {\n      sum -= 1;\n    }\n    if (sum < 0) {\n      return false;\n\
    \    }\n  }\n  return sum === 0;\n}\n", "    let bracketStack: string[] = [];\n\
    \    for (let i: number = 0; i < brackets.length; i++) {\n        if (brackets[i]\
    \ === '(') {\n            bracketStack.push('(');\n        } else if (brackets[i]\
    \ === ')') {\n            bracketStack.pop();\n        }\n    }\n    return bracketStack.length\
    \ === 0;\n}\n", "    // console.log(brackets);\n    let newBrackets = brackets.split(\"\
    \");\n    // console.log(newBrackets);\n    let leftBrackets = 0;\n    for (let\
    \ bracket of newBrackets) {\n        if (bracket === \"(\") {\n            leftBrackets\
    \ += 1;\n        } else if (bracket === \")\") {\n            leftBrackets -=\
    \ 1;\n        }\n        if (leftBrackets < 0) {\n            return false;\n\
    \        }\n    }\n    if (leftBrackets === 0) {\n        return true;\n    }\
    \ else {\n        return false;\n    }\n}\n", "  let openCounter = 0;\n  let closeCounter\
    \ = 0;\n  for (let bracket of brackets) {\n    if (bracket === '(') {\n      openCounter\
    \ += 1;\n    } else if (bracket === ')') {\n      closeCounter += 1;\n    }\n\
    \  }\n  return openCounter === closeCounter;\n}\n", "    let num_open = 0;\n \
    \   for (let i = 0; i < brackets.length; i++) {\n        if (brackets[i] === \"\
    (\") {\n            num_open++;\n        } else if (brackets[i] === \")\") {\n\
    \            num_open--;\n        }\n        if (num_open < 0) {\n           \
    \ return false;\n        }\n    }\n    return num_open === 0;\n}\n", "  const\
    \ arr = [];\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i]\
    \ === \"(\") {\n      arr.push(brackets[i]);\n    } else if (brackets[i] === \"\
    )\") {\n      arr.pop();\n    }\n  }\n  return arr.length === 0;\n}\n", "  const\
    \ stack: string[] = [];\n  for (const bracket of brackets) {\n    if (bracket\
    \ === \"(\") {\n      stack.push(bracket);\n    } else if (bracket === \")\")\
    \ {\n      if (stack.length === 0) {\n        return false;\n      }\n      stack.pop();\n\
    \    }\n  }\n  return stack.length === 0;\n}\n", "    const openingBrackets =\
    \ new Stack();\n    for (let i = 0; i < brackets.length; i++) {\n        if (brackets[i]\
    \ === \"(\") {\n            openingBrackets.push(brackets[i]);\n        } else\
    \ if (brackets[i] === \")\") {\n            if (openingBrackets.isEmpty()) {\n\
    \                return false;\n            }\n            openingBrackets.pop();\n\
    \        }\n    }\n    return openingBrackets.isEmpty();\n}\n", "  let num_open\
    \ = 0;\n  for (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] ===\
    \ \"(\") {\n      num_open++;\n    } else if (brackets[i] === \")\") {\n     \
    \ num_open--;\n    }\n    if (num_open < 0) {\n      return false;\n    }\n  }\n\
    \  return num_open === 0;\n}\n", "  if (brackets === \"\") {\n    return true;\n\
    \  }\n  const stack: string[] = [];\n  for (const bracket of brackets) {\n   \
    \ if (bracket === \"(\") {\n      stack.push(bracket);\n    } else if (bracket\
    \ === \")\") {\n      if (stack.length === 0) {\n        return false;\n     \
    \ }\n      stack.pop();\n    }\n  }\n  return stack.length === 0;\n}\n\ndescribe(\"\
    correct_bracketing\", () => {\n  it(\"returns true when given empty string\",\
    \ () => {\n    expect(correct_bracketing(\"\")).toBe(true);\n  });\n  it(\"returns\
    \ false when given single open bracket\", () => {\n    expect(correct_bracketing(\"\
    (\")).toBe(false);\n  });\n  it(\"returns true when given valid bracket pair\"\
    , () => {\n    expect(correct_bracketing(\"()\")).toBe(true);\n  });\n  it(\"\
    returns true when given valid bracket expression\", () => {\n    expect(correct_bracketing(\"\
    (()())\")).toBe(true);\n  });\n  it(\"returns false when given invalid bracket\
    \ expression\", () => {\n    expect(correct_bracketing(\")(()\")).toBe(false);\n\
    \  });\n});", "  // Find the number of opening brackets\n  let open = 0;\n  for\
    \ (let i = 0; i < brackets.length; i++) {\n    if (brackets[i] === \"(\") {\n\
    \      open++;\n    }\n  }\n  // If the number of closing brackets does not match\
    \ the number of opening\n  // brackets, then the bracketing is incorrect.\n  return\
    \ (brackets.length - open) === open;\n}\n", "  let count = 0;\n  for (let i =\
    \ 0; i < brackets.length; i++) {\n    if (brackets[i] === \"(\") {\n      count++;\n\
    \    } else if (brackets[i] === \")\") {\n      count--;\n    }\n    if (count\
    \ < 0) {\n      return false;\n    }\n  }\n  return count === 0;\n}\n", "    return\
    \ !!brackets.match(/^\\(?[^\\(\\)]*\\)*$/);\n}\n\n", "    let count = 0;\n   \
    \ for (let i = 0; i < brackets.length; i++) {\n        if (brackets[i] === '(')\
    \ {\n            count++;\n        } else if (brackets[i] === ')') {\n       \
    \     count--;\n        }\n        if (count < 0) {\n            return false;\n\
    \        }\n    }\n    return count === 0;\n}\n\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
