name: HumanEval_10_make_palindrome
language: ts
prompt: "//Find the shortest palindrome that begins with a supplied string.\n// Algorithm\
  \ idea is simple:\n// - Find the longest postfix of supplied string that is a palindrome.\n\
  // - Append to the end of the string reverse of a string prefix that comes before\
  \ the palindromic suffix.\n// >>> make_palindrome(\"\")\n// \"\"\n// >>> make_palindrome(\"\
  cat\")\n// \"catac\"\n// >>> make_palindrome(\"cata\")\n// \"catac\"\nfunction make_palindrome(string:\
  \ string): string {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = make_palindrome;\n  assert.deepEqual(candidate(\"\"\
  ),\"\");\n  assert.deepEqual(candidate(\"x\"),\"x\");\n  assert.deepEqual(candidate(\"\
  xyz\"),\"xyzyx\");\n  assert.deepEqual(candidate(\"xyx\"),\"xyx\");\n  assert.deepEqual(candidate(\"\
  jerry\"),\"jerryrrej\");\n}\n\ntest();"
completions: ["  // first we need to find the longest palindromic suffix\n  let index\
    \ = find_longest_palindromic_suffix(string)\n\n  // if string is a palindrome,\
    \ we just return it\n  if (index === 0) {\n    return string\n  }\n\n  // now\
    \ we have the longest palindromic suffix\n  // we need to append to the end of\
    \ the string reverse of prefix\n  let prefix = string.slice(0, index)\n  return\
    \ prefix + string.slice(index).split('').reverse().join('')\n}\n", "    let reverse\
    \ = string.split(\"\").reverse().join(\"\");\n    let i = string.length;\n   \
    \ while (i >= 0) {\n        if (string.substring(0, i) === reverse.substring(reverse.length\
    \ - i)) {\n            break;\n        }\n        i--;\n    }\n    return string\
    \ + reverse.substring(reverse.length - i);\n}\n", "    let longest_palindrome\
    \ = \"\";\n    for (let i = string.length; i >= 0; i--) {\n        const candidate\
    \ = string.substring(i);\n        if (candidate.length > longest_palindrome.length\
    \ && candidate === candidate.split(\"\").reverse().join(\"\")) {\n           \
    \ longest_palindrome = candidate;\n        }\n    }\n    return string + longest_palindrome.split(\"\
    \").reverse().join(\"\").substring(string.length);\n}\n\nexport {make_palindrome};",
  "    const suffix = find_longest_palindromic_suffix(string);\n    return string\
    \ + reverse(string.slice(0, string.length - suffix.length));\n}\n", "    if (string.length\
    \ === 0) {\n        return \"\";\n    }\n    let lps = longest_palindromic_suffix(string);\n\
    \    return string + string.substring(0, string.length - lps).split(\"\").reverse().join(\"\
    \");\n}\n", "  const mirror = string\n    .split(\"\")\n    .reverse()\n    .join(\"\
    \");\n  return (\n    string +\n    mirror.substring(mirror.length - string.length\
    \ + longest_palindrome_length(string))\n  );\n}\n", "    const palindrome_length\
    \ = palindrome_lengths(string);\n    const i = max_index(palindrome_length);\n\
    \    if (i === string.length) {\n        return string;\n    }\n    return string\
    \ + string.slice(0, string.length - i - 1).split(\"\").reverse().join(\"\");\n\
    }\n", "    let longest_postfix_palindrome = make_postfix_palindrome(string);\n\
    \    let prefix = string.substring(0, string.length - longest_postfix_palindrome.length);\n\
    \    let prefix_reversed = reverse(prefix);\n    return prefix_reversed + string;\n\
    }\n", "    var i = 0;\n    var j = string.length - 1;\n    var is_palindrome =\
    \ function(i: number, j: number): boolean {\n        for (var k = i; k <= i +\
    \ (j - i) / 2; k++) {\n            if (string[k] != string[j - k + i]) {\n   \
    \             return false;\n            }\n        }\n        return true;\n\
    \    };\n    while (i < j && !is_palindrome(i, j)) {\n        j--;\n    }\n  \
    \  return string + reverse(string.substring(0, i));\n}\n", "  if (!string) {\n\
    \    return \"\";\n  }\n  for (let i = string.length; i >= 0; i--) {\n    if (string[i]\
    \ === string[i - 1]) {\n      continue;\n    }\n    if (is_palindrome(string.slice(i)))\
    \ {\n      return string + string.slice(0, i).split(\"\").reverse().join(\"\"\
    );\n    }\n  }\n  return string + string.slice(1).split(\"\").reverse().join(\"\
    \");\n}\n", "    if (string === \"\") {\n        return string;\n    }\n    let\
    \ i = string.length;\n    while (i > 0) {\n        if (string.substring(0, i)\
    \ === string.substring(i).split(\"\").reverse().join(\"\")) {\n            return\
    \ string + string.substring(0, string.length - i).split(\"\").reverse().join(\"\
    \");\n        }\n        i--;\n    }\n    return string + string.substring(0,\
    \ string.length - 1).split(\"\").reverse().join(\"\");\n}\n", "  let pal_string\
    \ =\n    string.slice(0, -1 * longest_palindrome_suffix(string).length) +\n  \
    \  string\n      .slice(0, -1 * longest_palindrome_suffix(string).length)\n  \
    \    .split(\"\")\n      .reverse()\n      .join(\"\");\n  return pal_string;\n\
    }\n", "  // Base case.\n  if (string.length === 0) {\n    return string;\n  }\n\
    \n  // Find the longest postfix of supplied string that is a palindrome.\n  let\
    \ suffix: string = \"\";\n  for (let i = string.length - 1; i >= 0; i--) {\n \
    \   // if string[i:end] is a palindrome\n    if (is_palindrome(string.substring(i)))\
    \ {\n      suffix = string.substring(i);\n      break;\n    }\n  }\n\n  // Append\
    \ reverse of string[0:end-suffix.length] to the end of string.\n  return string\
    \ + string.substring(0, string.length - suffix.length).split(\"\").reverse().join(\"\
    \");\n}\n", "    if (string.length === 0) {\n        return string;\n    }\n \
    \   const longest_palindrome_suffix = find_longest_palindrome_suffix(string);\n\
    \    return string + reverse(string.substring(0, string.length - longest_palindrome_suffix.length));\n\
    }\n", "  // Find a longest palindromic suffix of a string\n  function longest_palindromic_suffix(string:\
    \ string): string {\n    for (let i = string.length; i >= 0; i--) {\n      let\
    \ postfix = string.substring(i, string.length);\n      if (is_palindrome(postfix))\
    \ {\n        return postfix;\n      }\n    }\n    return \"\";\n  }\n\n  // find\
    \ the longest palindromic suffix\n  let suffix = longest_palindromic_suffix(string);\n\
    \  if (suffix.length === string.length) {\n    // string is already a palindrome\n\
    \    return string;\n  }\n  // prepend to the end of the string reverse of a prefix\
    \ that comes before the suffix\n  return string + reverse(string.substring(0,\
    \ string.length - suffix.length));\n}\n", "    //Finds the longest postfix that\
    \ is a palindrome\n    function is_palindrome(postfix: string): boolean {\n  \
    \      //If the postfix is just one character, it is a palindrome.\n        if\
    \ (postfix.length === 1) {\n            return true;\n        }\n        //The\
    \ string is a palindrome if first and last characters are equal\n        // and\
    \ the rest of the string is a palindrome.\n        return postfix[0] === postfix[postfix.length\
    \ - 1] && is_palindrome(postfix.slice(1, postfix.length - 1));\n    }\n\n    //Finds\
    \ the longest postfix that is a palindrome.\n    function longest_palindrome_postfix(string:\
    \ string): string {\n        for (let i = string.length; i > 0; i--) {\n     \
    \       if (is_palindrome(string.slice(string.length - i))) {\n              \
    \  return string.slice(string.length - i);\n            }\n        }\n       \
    \ return string;\n    }\n\n    //Finds the longest prefix that is not a palindrome.\n\
    \    function longest_prefix(string: string): string {\n        for (let i = 0;\
    \ i < string.length; i++) {\n            if (is_palindrome(string.slice(0, i)))\
    \ {\n                return string.slice(0, i);\n            }\n        }\n  \
    \      return string;\n    }\n\n    return string + string.slice(0, string.length\
    \ - longest_palindrome_postfix(string).length).split(\"\").reverse().join(\"\"\
    );\n}\n", "    if (string === \"\") return \"\";\n    //Longest palindromic suffix.\n\
    \    let pal_suffix: string;\n    if (string.length % 2 === 0) {\n        pal_suffix\
    \ = find_palindrome(string, string.length / 2 - 1, string.length / 2);\n    }\
    \ else {\n        pal_suffix = find_palindrome(string, Math.floor(string.length\
    \ / 2), Math.floor(string.length / 2));\n    }\n    let result: string = string.substring(0,\
    \ string.length - pal_suffix.length);\n    result = result.split(\"\").reverse().join(\"\
    \");\n    return string + result;\n}\n", "    const palindromeSuffix = longest_palindrome_suffix(string);\n\
    \    const palindromePrefix = string.substring(0, string.length - palindromeSuffix.length);\n\
    \    return string + reverse(palindromePrefix);\n}\n", "  let suffix = largest_palindrome_suffix(string);\n\
    \  return string + reverse(string.slice(0, string.length - suffix.length));\n\
    }\n", "    //Find longest palindromic suffix in string\n    function palindromic_suffix(string:\
    \ string): string {\n        //End of the string is empty so string has no palindromic\
    \ suffix\n        if (string.length <= 1) {\n            return \"\";\n      \
    \  }\n\n        //Palindromic suffix is the same as whole string\n        if (is_palindrome(string))\
    \ {\n            return string;\n        }\n\n        //Recursively find palindromic\
    \ suffix of a substring that starts at index 1\n        return palindromic_suffix(string.substring(1));\n\
    \    }\n\n    //Find longest palindromic prefix in string\n    function palindromic_prefix(string:\
    \ string): string {\n        //End of the string is empty so string has no palindromic\
    \ prefix\n        if (string.length <= 1) {\n            return \"\";\n      \
    \  }\n\n        //Palindromic prefix is the same as whole string\n        if (is_palindrome(string))\
    \ {\n            return string;\n        }\n\n        //Recursively find palindromic\
    \ prefix of a substring that ends before last character\n        return palindromic_prefix(string.substring(0,\
    \ string.length - 1));\n    }\n\n    //Return string plus reverse of the longest\
    \ palindromic prefix\n    return string + reverse(palindromic_prefix(string));\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
