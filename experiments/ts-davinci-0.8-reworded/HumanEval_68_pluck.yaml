name: HumanEval_68_pluck
language: ts
prompt: "//\"Given an array representing a branch of a tree that has non-negative\
  \ integer nodes\n// your task is to pluck one of the nodes and return it.\n// The\
  \ plucked node should be the node with the smallest even value.\n// If multiple\
  \ nodes with the same smallest even value are found return the node that has smallest\
  \ index.\n// The plucked node should be returned in an array, [ smalest_value, its\
  \ index ],\n// If there are no even values or the given array is empty, return [].\n\
  // Example 1:\n// >>> pluck([4, 2, 3])\n// [2, 1]\n// Explanation: 2 has the smallest\
  \ even value, and 2 has the smallest index.\n// Example 2:\n// >>> pluck([1, 2,\
  \ 3])\n// [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest\
  \ index.\n// Example 3:\n// >>> pluck([])\n// []\n// Example 4:\n// >>> pluck([5,\
  \ 0, 3, 0, 4, 2])\n// [0, 1]\n// Explanation: 0 is the smallest value, but  there\
  \ are two zeros,\n// so we will choose the first zero, which has the smallest index.\n\
  // Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunction\
  \ pluck(arr: number[]): number[] {\n"
tests: "declare var require: any;\nconst assert = require('node:assert');\n\n\nfunction\
  \ test() {\n  let candidate = pluck;\n  assert.deepEqual(candidate([4, 2, 3]),[2,\
  \ 1]);\n  assert.deepEqual(candidate([1, 2, 3]),[2, 1]);\n  assert.deepEqual(candidate([]),[]);\n\
  \  assert.deepEqual(candidate([5, 0, 3, 0, 4, 2]),[0, 1]);\n  assert.deepEqual(candidate([1,\
  \ 2, 3, 0, 5, 3]),[0, 3]);\n  assert.deepEqual(candidate([5, 4, 8, 4, 8]),[4, 1]);\n\
  \  assert.deepEqual(candidate([7, 6, 7, 1]),[6, 1]);\n  assert.deepEqual(candidate([7,\
  \ 9, 7, 1]),[]);\n}\n\ntest();"
completions: ["    const evens = arr.filter(x => x % 2 === 0);\n    return evens.length\
    \ ? [Math.min(...evens), arr.indexOf(Math.min(...evens))] : [];\n}\nconsole.log(pluck([4,\
    \ 2, 3]));\nconsole.log(pluck([1, 2, 3]));\nconsole.log(pluck([]));\nconsole.log(pluck([5,\
    \ 0, 3, 0, 4, 2]));", "  let min = null;\n  let index = null;\n  for (let i =\
    \ 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      if (min === null)\
    \ {\n        min = arr[i];\n        index = i;\n      } else if (arr[i] < min)\
    \ {\n        min = arr[i];\n        index = i;\n      }\n    }\n  }\n  if (min\
    \ !== null) {\n    return [min, index];\n  } else {\n    return [];\n  }\n}",
  "  let smallestEvenValue = 10001;\n  let smallestEvenValueIndex = -1;\n  for (let\
    \ i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0 && arr[i] < smallestEvenValue)\
    \ {\n      smallestEvenValue = arr[i];\n      smallestEvenValueIndex = i;\n  \
    \  }\n  }\n  if (smallestEvenValueIndex === -1) {\n    return [];\n  }\n  return\
    \ [smallestEvenValue, smallestEvenValueIndex];\n}\n", "  let min = null;\n  let\
    \ minIndex = null;\n  for (let i = 0; i < arr.length; i++) {\n    const element\
    \ = arr[i];\n    if (element % 2 === 0) {\n      if (min === null || element <\
    \ min) {\n        min = element;\n        minIndex = i;\n      }\n    }\n  }\n\
    \  return min === null ? [] : [min, minIndex];\n}\n", "  if (arr.length === 0)\
    \ {\n    return [];\n  }\n  let evenArr: number[] = [];\n  let evenArrInd: number[]\
    \ = [];\n  let finalArr: number[] = [];\n  let evenVal: number = 0;\n  let firstVal:\
    \ number = 0;\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 ===\
    \ 0) {\n      evenArr.push(arr[i]);\n      evenArrInd.push(i);\n    }\n  }\n \
    \ if (evenArr.length === 0) {\n    return [];\n  }\n  evenVal = Math.min(...evenArr);\n\
    \  for (let j = 0; j < evenArr.length; j++) {\n    if (evenArr[j] === evenVal)\
    \ {\n      firstVal = evenArrInd[j];\n      break;\n    }\n  }\n  finalArr.push(evenVal,\
    \ firstVal);\n  return finalArr;\n}", "  if (arr.length === 0) {\n    return [];\n\
    \  }\n  let evens = arr.filter(n => n % 2 === 0);\n  if (evens.length === 0) {\n\
    \    return [];\n  }\n  let min = Math.min(...evens);\n  let index = arr.indexOf(min);\n\
    \  return [min, index];\n}\n", "    let minEven: number = Number.MAX_SAFE_INTEGER;\n\
    \    let minIndex: number = Number.MAX_SAFE_INTEGER;\n    for (let i = 0; i <\
    \ arr.length; i++) {\n        if (arr[i] !== 0 && arr[i] % 2 === 0 && arr[i] <\
    \ minEven) {\n            minEven = arr[i];\n            minIndex = i;\n     \
    \   }\n    }\n    return minEven === Number.MAX_SAFE_INTEGER ? [] : [minEven,\
    \ minIndex];\n}\n", "  if (arr.length === 0) {\n    return [];\n  }\n  const evens\
    \ = arr.filter(i => i % 2 === 0);\n  const min = Math.min(...evens);\n  return\
    \ [min, arr.indexOf(min)];\n}\n", "    if (arr.length < 1) {\n        return [];\n\
    \    }\n    const result = arr.map((val, idx) => [val, idx]).filter(val => val[0]\
    \ % 2 === 0).sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n    return result.length\
    \ > 0 ? result[0] : [];\n}\n", "  const even: number[] = [];\n  const index: number[]\
    \ = [];\n  arr.forEach((num, i) => {\n    if (num % 2 === 0) {\n      even.push(num);\n\
    \      index.push(i);\n    }\n  });\n  const min: number = Math.min(...even);\n\
    \  const res: number[] = [];\n  for (let i = 0; i < even.length; i++) {\n    if\
    \ (even[i] === min) {\n      res.push(even[i]);\n      res.push(index[i]);\n \
    \     break;\n    }\n  }\n  return res;\n}\n", "  const array = arr\n    .filter((item)\
    \ => {\n      return item % 2 === 0;\n    })\n    .sort((a, b) => {\n      return\
    \ a - b;\n    });\n  return array.length > 0 ? [array[0], arr.indexOf(array[0])]\
    \ : [];\n}\n\nexport { pluck };", "  const smallest: number[] = [];\n  for (let\
    \ i = 0; i < arr.length; i++) {\n    if (arr[i] % 2 === 0) {\n      smallest.push(arr[i]);\n\
    \    }\n  }\n  smallest.sort((a, b) => a - b);\n  return smallest.length === 0\
    \ ? [] : [smallest[0], arr.indexOf(smallest[0])];\n}\n", "  // your code\n}\n\n\
    export { pluck };", "  // find the smallest even element, if there are multiple,\
    \ return the index of the first one\n  // if there are no even elements, return\
    \ []\n  // if the array is empty, return []\n  // if the array is null, throw\
    \ error?\n  // maybe use a heap to solve this\n  if (arr === null) {\n    throw\
    \ new Error('Invalid input: null array');\n  }\n  if (arr.length === 0) {\n  \
    \  return [];\n  }\n  let smallestEvenVal: number = Number.MAX_SAFE_INTEGER;\n\
    \  let smallestEvenValIndex: number = Number.MAX_SAFE_INTEGER;\n  for (let i =\
    \ 0; i < arr.length; i++) {\n    const curVal = arr[i];\n    if (curVal < smallestEvenVal\
    \ && curVal % 2 === 0) {\n      smallestEvenVal = curVal;\n      smallestEvenValIndex\
    \ = i;\n    }\n  }\n  if (smallestEvenVal === Number.MAX_SAFE_INTEGER) {\n   \
    \ return [];\n  }\n  return [smallestEvenVal, smallestEvenValIndex];\n}\n\nexport\
    \ default pluck;", "    if (!arr.length) {\n        return [];\n    }\n    //\
    \ let smallest = Math.min(...arr.filter(x => x % 2 === 0));\n    let smallest\
    \ = arr.filter(x => x % 2 === 0).reduce((x, y) => Math.min(x, y));\n    let smallestIdx\
    \ = arr.indexOf(smallest);\n    return [smallest, smallestIdx];\n}\n", "  let\
    \ result: number[] = [];\n  if (arr.length === 0) {\n    return result;\n  }\n\
    \n  const evenArr = arr.filter((num) => num % 2 === 0);\n  if (evenArr.length\
    \ === 0) {\n    return result;\n  }\n\n  const smallestValue = Math.min(...evenArr);\n\
    \  const smallestIndex = arr.indexOf(smallestValue);\n  result.push(smallestValue,\
    \ smallestIndex);\n  return result;\n}\n", "    const evens = arr.filter(v =>\
    \ v % 2 === 0);\n    const minEven = Math.min(...evens);\n    const index = arr.indexOf(minEven);\n\
    \    return [minEven, index];\n}\n\nconsole.log(pluck([4, 2, 3]));\nconsole.log(pluck([1,\
    \ 2, 3]));\nconsole.log(pluck([]));\nconsole.log(pluck([5, 0, 3, 0, 4, 2]));",
  "  const evenValues: number[] = arr.filter((value) => {\n    return value % 2 ===\
    \ 0;\n  });\n  if (evenValues.length === 0) {\n    return [];\n  }\n  const smallestEvenValue:\
    \ number = Math.min(...evenValues);\n  const index: number = arr.indexOf(smallestEvenValue);\n\
    \  return [smallestEvenValue, index];\n}\nconsole.log(pluck([1, 2, 3]));\nconsole.log(pluck([4,\
    \ 2, 3]));\nconsole.log(pluck([5, 0, 3, 0, 4, 2]));\nconsole.log(pluck([]));",
  "    const evens = arr.filter(value => value % 2 === 0).sort();\n    if (!evens.length)\
    \ {\n        return [];\n    }\n    const smallestEven = evens[0];\n    const\
    \ smallestEvenIndex = arr.indexOf(smallestEven);\n    return [smallestEven, smallestEvenIndex];\n\
    }\n", "  let target = Number.MAX_SAFE_INTEGER;\n  let index = 0;\n  let isEven\
    \ = false;\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i];\n\
    \    if (el % 2 === 0 && el < target) {\n      target = el;\n      index = i;\n\
    \      isEven = true;\n    }\n  }\n  return isEven ? [target, index] : [];\n}\n\
    \ndescribe(\"Tree Plucking\", () => {\n  it(\"should return the smallest even\
    \ value with smallest index\", () => {\n    expect(pluck([4, 2, 3])).to.deep.equal([2,\
    \ 1]);\n    expect(pluck([1, 2, 3])).to.deep.equal([2, 1]);\n    expect(pluck([5,\
    \ 0, 3, 0, 4, 2])).to.deep.equal([0, 1]);\n  });\n  it(\"should return [] when\
    \ the array is empty\", () => {\n    expect(pluck([])).to.deep.equal([]);\n  });\n\
    });"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nclass"
