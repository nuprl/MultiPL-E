name: HumanEval_114_minSubArraySum
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given an array of integers nums, find the minimum sum of any non-empty sub-array\n\
  \    // of nums.\n    // Example\n    // >>> minSubArraySum((List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong)))\n    // (1l)\n    //\
  \ >>> minSubArraySum((List[Long](-1l.toLong, -2l.toLong, -3l.toLong)))\n    // (-6l)\n\
  \    def minSubArraySum(nums : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minSubArraySum((List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong, 1l.toLong, 2l.toLong, 4l.toLong))) == (1l));\n    assert(minSubArraySum((List[Long](-1l.toLong,\
  \ -2l.toLong, -3l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](-1l.toLong,\
  \ -2l.toLong, -3l.toLong, 2l.toLong, -10l.toLong))) == (-14l));\n    assert(minSubArraySum((List[Long](-9999999999999999l.toLong)))\
  \ == (-9999999999999999l));\n    assert(minSubArraySum((List[Long](0l.toLong, 10l.toLong,\
  \ 20l.toLong, 1000000l.toLong))) == (0l));\n    assert(minSubArraySum((List[Long](-1l.toLong,\
  \ -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n    assert(minSubArraySum((List[Long](100l.toLong,\
  \ -1l.toLong, -2l.toLong, -3l.toLong, 10l.toLong, -5l.toLong))) == (-6l));\n   \
  \ assert(minSubArraySum((List[Long](10l.toLong, 11l.toLong, 13l.toLong, 8l.toLong,\
  \ 3l.toLong, 4l.toLong))) == (3l));\n    assert(minSubArraySum((List[Long](100l.toLong,\
  \ -33l.toLong, 32l.toLong, -1l.toLong, 0l.toLong, -2l.toLong))) == (-33l));\n  \
  \  assert(minSubArraySum((List[Long](-10l.toLong))) == (-10l));\n    assert(minSubArraySum((List[Long](7l.toLong)))\
  \ == (7l));\n    assert(minSubArraySum((List[Long](1l.toLong, -1l.toLong))) == (-1l));\n\
  \    }\n\n}\n"
completions: ["        // Time - O(n)\n        // Space - O(1)\n        var minSum\
    \ = nums(0)\n        var currentSum = nums(0)\n        for (i <- 1 until nums.length)\
    \ {\n            currentSum = min(currentSum + nums(i), nums(i))\n           \
    \ minSum = min(minSum, currentSum)\n        }\n        minSum", "        // We\
    \ can use a sliding window to solve this problem.\n        // We will keep track\
    \ of the minimum sum and the current sum.\n        // If the current sum is less\
    \ than the minimum sum, we will update the minimum sum.\n        // If the current\
    \ sum is greater than the minimum sum, we will remove the first element\n    \
    \    // from the window and update the current sum.\n        // We will keep doing\
    \ this until we have reached the end of the list.\n        // Time Complexity:\
    \ O(n)\n        // Space Complexity: O(1)\n        var minSum = Long.MaxValue\n\
    \        var currentSum = 0l\n        for (num <- nums) {\n            currentSum\
    \ += num\n            if (currentSum < minSum) minSum = currentSum\n         \
    \   if (currentSum > 0) currentSum = 0\n        }\n        minSum", "        //\
    \ We can use a sliding window to solve this problem.\n        // We will keep\
    \ track of the current sum and the minimum sum.\n        // If the current sum\
    \ is less than the minimum sum, we will update the minimum sum.\n        // If\
    \ the current sum is greater than the minimum sum, we will remove the first element\n\
    \        // from the window.\n        // We will keep doing this until we reach\
    \ the end of the array.\n        // The minimum sum will be the answer.\n    \
    \    // Time complexity: O(n)\n        // Space complexity: O(1)\n        var\
    \ minSum = Long.MaxValue\n        var currentSum = 0l\n        for (num <- nums)\
    \ {\n            currentSum += num\n            if (currentSum < minSum) minSum\
    \ = currentSum\n            if (currentSum > 0) currentSum = 0\n        }\n  \
    \      minSum", "        var min = Long.MaxValue\n        var sum = 0l\n     \
    \   for (num <- nums) {\n            sum += num\n            if (sum < min) min\
    \ = sum\n            if (sum > 0) sum = 0\n        }\n        min", "        //\
    \ We can use a sliding window to solve this problem.\n        // We start with\
    \ a window of size 1, and then expand it until we find the minimum\n        //\
    \ sum.\n        // We keep track of the minimum sum, and the minimum window size.\n\
    \        // We can use a sliding window to solve this problem.\n        // We\
    \ start with a window of size 1, and then expand it until we find the minimum\n\
    \        // sum.\n        // We keep track of the minimum sum, and the minimum\
    \ window size.\n        var minSum = Long.MaxValue\n        var minWindowSize\
    \ = 1\n        var windowSize = 1\n        while (windowSize <= nums.length) {\n\
    \            var windowSum = 0l\n            for (i <- 0 until windowSize) {\n\
    \                windowSum += nums(i)\n            }\n            if (windowSum\
    \ < minSum) {\n                minSum = windowSum\n                minWindowSize\
    \ = windowSize\n            }\n            for (i <- windowSize until nums.length)\
    \ {\n                windowSum -= nums(i - windowSize)\n                windowSum\
    \ += nums(i)\n                if (windowSum < minSum) {\n                    minSum\
    \ = windowSum\n                    minWindowSize = windowSize\n              \
    \  }\n            }\n            windowSize += 1\n        }\n        minSum",
  "        var minSum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums)\
    \ {\n            sum += num\n            if (sum < minSum) minSum = sum\n    \
    \        if (sum > 0) sum = 0\n        }\n        minSum", "        // We can\
    \ use the Kadane's algorithm to solve this problem.\n        // We can keep track\
    \ of the minimum sum of the sub-array ending at the current index.\n        //\
    \ We can then compare the minimum sum of the sub-array ending at the current index\n\
    \        // with the minimum sum of the sub-array ending at the previous index.\n\
    \        // The minimum sum of the sub-array ending at the current index is the\
    \ minimum of\n        // the minimum sum of the sub-array ending at the previous\
    \ index and the current\n        // element.\n        // The minimum sum of the\
    \ sub-array ending at the previous index is the minimum of\n        // the minimum\
    \ sum of the sub-array ending at the previous index and the sum of the\n     \
    \   // minimum sum of the sub-array ending at the previous index and the current\
    \ element.\n        // The minimum sum of the sub-array ending at the previous\
    \ index is the minimum of\n        // the minimum sum of the sub-array ending\
    \ at the previous index and the sum of the\n        // minimum sum of the sub-array\
    \ ending at the previous index and the current element.\n        // The minimum\
    \ sum of the sub-array ending at the previous index is the minimum of\n      \
    \  // the minimum sum of the sub-array ending at the previous index and the sum\
    \ of the\n        // minimum sum of the sub-array ending at the previous index\
    \ and the current element.\n        // The minimum sum of the sub-array ending\
    \ at the previous index is the minimum of\n        // the minimum sum of the sub-array\
    \ ending at the previous index and the sum of the\n        // minimum sum of the\
    \ sub-array ending at the previous index and the current element.\n        //\
    \ The minimum sum of the sub-array ending at the previous index is the minimum\
    \ of\n        // the minimum sum of the sub-array ending at the previous index\
    \ and the sum of the\n        // minimum sum of the sub-array ending at the previous\
    \ index and the current element.\n        // The minimum sum of the sub-array\
    \ ending at the previous index is the minimum of\n        // the minimum sum of\
    \ the sub-array ending at the previous index and the sum of the\n        // minimum\
    \ sum of the sub-array ending at the previous index and the current element.\n\
    \        // The minimum sum of the sub-array ending at the previous index is the\
    \ minimum of\n        // the minimum sum", "        // Time: O(n)\n        //\
    \ Space: O(1)\n        var minSum = nums(0)\n        var sum = 0\n        for\
    \ (i <- nums) {\n            sum += i\n            if (sum < minSum) minSum =\
    \ sum\n            if (sum > 0) sum = 0\n        }\n        minSum", "       \
    \ // We can use a sliding window to solve this problem.\n        // The sliding\
    \ window will be of size 2.\n        // We will keep track of the minimum sum\
    \ and the current sum.\n        // We will also keep track of the minimum start\
    \ and end indices.\n        // We will also keep track of the current start and\
    \ end indices.\n        // We will also keep track of the current start and end\
    \ indices.\n        // We will also keep track of the current start and end indices.\n\
    \        // We will also keep track of the current start and end indices.\n  \
    \      // We will also keep track of the current start and end indices.\n    \
    \    // We will also keep track of the current start and end indices.\n      \
    \  // We will also keep track of the current start and end indices.\n        //\
    \ We will also keep track of the current start and end indices.\n        // We\
    \ will also keep track of the current start and end indices.\n        // We will\
    \ also keep track of the current start and end indices.\n        // We will also\
    \ keep track of the current start and end indices.\n        // We will also keep\
    \ track of the current start and end indices.\n        // We will also keep track\
    \ of the current start and end indices.\n        // We will also keep track of\
    \ the current start and end indices.\n        // We will also keep track of the\
    \ current start and end indices.\n        // We will also keep track of the current\
    \ start and end indices.\n        // We will also keep track of the current start\
    \ and end indices.\n        // We will also keep track of the current start and\
    \ end indices.\n        // We will also keep track of the current start and end\
    \ indices.\n        // We will also keep track of the current start and end indices.\n\
    \        // We will also keep track of the current start and end indices.\n  \
    \      // We will also keep track of the current start and end indices.\n    \
    \    // We will also keep track of the current start and end indices.\n      \
    \  // We will also keep track of the current start and end indices.\n        //\
    \ We will also keep track of the current start and end indices.\n        // We\
    \ will also keep track of the current start and end indices.\n        // We will\
    \ also keep track of the current start and end indices.\n        // We will also\
    \ keep track of the current start and end indices.\n        // We will also",
  "        // Fill this in.\n        var minSum = Long.MaxValue\n        var sum =\
    \ 0l\n        for (i <- nums) {\n            sum += i\n            if (sum < minSum)\
    \ minSum = sum\n            if (sum > 0) sum = 0\n        }\n        minSum",
  "        // Time complexity: O(n)\n        // Space complexity: O(1)\n        var\
    \ minSum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n\
    \            sum += num\n            minSum = min(minSum, sum)\n            if\
    \ (sum > 0) sum = 0\n        }\n        minSum", "        // We can use a sliding\
    \ window to solve this problem.\n        // The sliding window will be of size\
    \ 2.\n        // The sliding window will be of size 2.\n        // The sliding\
    \ window will be of size 2.\n        // The sliding window will be of size 2.\n\
    \        // The sliding window will be of size 2.\n        // The sliding window\
    \ will be of size 2.\n        // The sliding window will be of size 2.\n     \
    \   // The sliding window will be of size 2.\n        // The sliding window will\
    \ be of size 2.\n        // The sliding window will be of size 2.\n        //\
    \ The sliding window will be of size 2.\n        // The sliding window will be\
    \ of size 2.\n        // The sliding window will be of size 2.\n        // The\
    \ sliding window will be of size 2.\n        // The sliding window will be of\
    \ size 2.\n        // The sliding window will be of size 2.\n        // The sliding\
    \ window will be of size 2.\n        // The sliding window will be of size 2.\n\
    \        // The sliding window will be of size 2.\n        // The sliding window\
    \ will be of size 2.\n        // The sliding window will be of size 2.\n     \
    \   // The sliding window will be of size 2.\n        // The sliding window will\
    \ be of size 2.\n        // The sliding window will be of size 2.\n        //\
    \ The sliding window will be of size 2.\n        // The sliding window will be\
    \ of size 2.\n        // The sliding window will be of size 2.\n        // The\
    \ sliding window will be of size 2.\n        // The sliding window will be of\
    \ size 2.\n        // The sliding window will be of size 2.\n        // The sliding\
    \ window will be of size 2.\n        // The sliding window will be of size 2.\n\
    \        // The sliding window will be of size 2.\n        // The sliding window\
    \ will be of size 2.\n        // The sliding window will be of size 2.\n     \
    \   // The sliding window will be of size 2.\n        // The sliding window will\
    \ be of size 2.\n        // The sliding window will be of size 2.\n        //\
    \ The sliding window will be of size 2.\n        // The sliding window will be\
    \ of size 2.\n        // The sliding window will be of size 2.\n        // The\
    \ sliding window", "        // Time: O(n)\n        // Space: O(1)\n        var\
    \ minSum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n\
    \            sum += num\n            minSum = min(minSum, sum)\n            if\
    \ (sum > 0) sum = 0\n        }\n        minSum", "        // Time complexity:\
    \ O(n)\n        // Space complexity: O(1)\n        var minSum = nums(0)\n    \
    \    var sum = 0l\n        for (num <- nums) {\n            sum += num\n     \
    \       if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n   \
    \     }\n        minSum", "        // Time complexity: O(n)\n        // Space\
    \ complexity: O(1)\n        var minSum = Long.MaxValue\n        var sum = 0l\n\
    \        for (num <- nums) {\n            sum += num\n            minSum = min(minSum,\
    \ sum)\n            if (sum > 0) sum = 0\n        }\n        minSum", "      \
    \  // We can use a sliding window to find the minimum sum.\n        // We can\
    \ use a sliding window to find the minimum sum.\n        var minSum = Long.MaxValue\n\
    \        var currSum = 0l\n        for (i <- 0 until nums.length) {\n        \
    \    currSum += nums(i)\n            minSum = min(minSum, currSum)\n         \
    \   if (currSum < 0) currSum = 0\n        }\n        minSum", "        // Fill\
    \ this *****\n        return 0l", "        var minSum = Long.MaxValue\n      \
    \  var sum = 0l\n        for (num <- nums) {\n            sum += num\n       \
    \     if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n     \
    \   }\n        minSum", "        // Time complexity: O(n)\n        // Space complexity:\
    \ O(1)\n        var minSum = Long.MaxValue\n        var sum = 0l\n        for\
    \ (num <- nums) {\n            sum += num\n            minSum = min(minSum, sum)\n\
    \            if (sum < 0) sum = 0\n        }\n        minSum", "        // Time\
    \ complexity: O(n)\n        // Space complexity: O(1)\n        var minSum = nums(0)\n\
    \        var currSum = nums(0)\n        for (i <- 1 until nums.length) {\n   \
    \         currSum = min(currSum + nums(i), nums(i))\n            minSum = min(minSum,\
    \ currSum)\n        }\n        minSum", "        // Fill this in.\n        var\
    \ min = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n   \
    \         sum += num\n            if (sum < min) min = sum\n            if (sum\
    \ > 0) sum = 0\n        }\n        min", "        // Fill this in.\n        var\
    \ minSum = Long.MaxValue\n        var sum = 0l\n        for (i <- nums) {\n  \
    \          sum += i\n            if (sum < minSum) minSum = sum\n            if\
    \ (sum > 0) sum = 0\n        }\n        minSum", "        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        // Fill this in.\n        var min = nums(0)\n\
    \        var sum = nums(0)\n        for (i <- 1 until nums.length) {\n       \
    \     sum = min(sum + nums(i), nums(i))\n            min = min(min, sum)\n   \
    \     }\n        min", "        // Time - O(n)\n        // Space - O(1)\n    \
    \    var minSum = nums(0)\n        var sum = nums(0)\n        for (i <- 1 until\
    \ nums.length) {\n            sum = min(sum + nums(i), nums(i))\n            minSum\
    \ = min(minSum, sum)\n        }\n        minSum", "        var minSum = nums(0)\n\
    \        var currentSum = nums(0)\n        for (i <- 1 until nums.length) {\n\
    \            currentSum = min(currentSum + nums(i), nums(i))\n            minSum\
    \ = min(minSum, currentSum)\n        }\n        return minSum", "        var minSum\
    \ = nums(0)\n        var sum = 0l\n        for (num <- nums) {\n            sum\
    \ += num\n            if (sum < minSum) minSum = sum\n            if (sum > 0)\
    \ sum = 0\n        }\n        minSum", "        var minSum = Long.MaxValue\n \
    \       var sum = 0l\n        for (num <- nums) {\n            sum += num\n  \
    \          if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        // We can use Kadane's algorithm.\n    \
    \    // https://en.wikipedia.org/wiki/Maximum_subarray_problem\n        var max_ending_here\
    \ = 0l\n        var max_so_far = 0l\n        for (num <- nums) {\n           \
    \ max_ending_here = max(num, max_ending_here + num)\n            max_so_far =\
    \ max(max_so_far, max_ending_here)\n        }\n        max_so_far", "        //\
    \ Time complexity: O(n)\n        // Space complexity: O(1)\n        var minSum\
    \ = nums(0)\n        var sum = 0\n        for (num <- nums) {\n            sum\
    \ += num\n            if (sum < minSum) minSum = sum\n            if (sum > 0)\
    \ sum = 0\n        }\n        minSum", "        // Fill this in.\n        var\
    \ minSum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n\
    \            sum += num\n            if (sum < minSum) minSum = sum\n        \
    \    if (sum > 0) sum = 0\n        }\n        minSum", "        // We can use\
    \ Kadane's algorithm to solve this problem.\n        // The idea is to keep track\
    \ of the maximum sum of a sub-array ending at the current\n        // index.\n\
    \        // If the maximum sum is negative, then we can just reset it to 0.\n\
    \        // The minimum sum of a sub-array is the minimum of the maximum sum of\
    \ a sub-array\n        // ending at each index.\n        var minSum = Long.MaxValue\n\
    \        var maxSum = 0l\n        for (num <- nums) {\n            maxSum = max(maxSum\
    \ + num, 0l)\n            minSum = min(minSum, maxSum)\n        }\n        minSum",
  "        // We can use the sliding window technique to solve this problem.\n   \
    \     // We can use a sliding window of size 1 to n to find the minimum sum.\n\
    \        // Time Complexity: O(n^2)\n        // Space Complexity: O(1)\n     \
    \   var minSum = Long.MaxValue\n        for (i <- 0 until nums.length) {\n   \
    \         var sum = 0l\n            for (j <- i until nums.length) {\n       \
    \         sum += nums(j)\n                minSum = min(minSum, sum)\n        \
    \    }\n        }\n        return minSum", "        // Time: O(n)\n        //\
    \ Space: O(1)\n        var minSum = nums(0)\n        var sum = nums(0)\n     \
    \   for (i <- 1 until nums.length) {\n            sum = min(sum + nums(i), nums(i))\n\
    \            minSum = min(minSum, sum)\n        }\n        minSum", "        var\
    \ minSum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n\
    \            sum += num\n            if (sum < minSum) minSum = sum\n        \
    \    if (sum > 0) sum = 0\n        }\n        minSum", "        // Fill this\n\
    \        return 0l", "        // We can use a sliding window to solve this problem.\n\
    \        // The sliding window will be of size n.\n        // We will keep track\
    \ of the minimum sum of the sliding window.\n        // We will also keep track\
    \ of the current sum of the sliding window.\n        // We will move the sliding\
    \ window from left to right.\n        // We will update the minimum sum of the\
    \ sliding window if the current sum of the\n        // sliding window is less\
    \ than the minimum sum of the sliding window.\n        // We will update the current\
    \ sum of the sliding window by subtracting the left\n        // element of the\
    \ sliding window and adding the right element of the sliding window.\n       \
    \ // Time complexity is O(n).\n        // Space complexity is O(1).\n        var\
    \ minSum = nums(0)\n        var currSum = nums(0)\n        for (i <- 1 until nums.length)\
    \ {\n            currSum = min(currSum + nums(i), nums(i))\n            minSum\
    \ = min(minSum, currSum)\n        }\n        minSum", "        // Fill this in.\n\
    \        var min = Long.MaxValue\n        var sum = 0l\n        for (i <- nums)\
    \ {\n            sum += i\n            if (sum < min) min = sum\n            if\
    \ (sum > 0) sum = 0\n        }\n        min", "        var min = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           if (sum < min) min = sum\n            if (sum > 0) sum = 0\n     \
    \   }\n        min", "        // We can use a sliding window to find the minimum\
    \ sum of a sub-array.\n        // The minimum sum of a sub-array is the minimum\
    \ sum of the previous sub-array\n        // plus the current element, or the current\
    \ element.\n        // We can use a sliding window to find the minimum sum of\
    \ a sub-array.\n        // The minimum sum of a sub-array is the minimum sum of\
    \ the previous sub-array\n        // plus the current element, or the current\
    \ element.\n        var minSum = nums(0)\n        var sum = nums(0)\n        for\
    \ (i <- 1 until nums.length) {\n            sum = min(sum + nums(i), nums(i))\n\
    \            minSum = min(minSum, sum)\n        }\n        minSum", "        //\
    \ We can use Kadane's algorithm to solve this problem.\n        // The idea is\
    \ to keep track of the maximum sum of a sub-array ending at each index.\n    \
    \    // The maximum sum of a sub-array ending at index i is either the maximum\
    \ sum of a\n        // sub-array ending at index i - 1 or the maximum sum of a\
    \ sub-array ending at index\n        // i - 1 plus the value at index i.\n   \
    \     // We can keep track of the minimum maximum sum of a sub-array ending at\
    \ each index.\n        // The minimum maximum sum of a sub-array ending at index\
    \ i is either the minimum\n        // maximum sum of a sub-array ending at index\
    \ i - 1 or the maximum sum of a sub-array\n        // ending at index i.\n   \
    \     // The minimum maximum sum of a sub-array ending at index i is the minimum\
    \ sum of any\n        // non-empty sub-array of nums.\n        // Time Complexity:\
    \ O(n)\n        // Space Complexity: O(1)\n        var minMaxSum = nums(0)\n \
    \       var maxSum = nums(0)\n        for (i <- 1 until nums.length) {\n     \
    \       maxSum = max(maxSum + nums(i), nums(i))\n            minMaxSum = min(minMaxSum,\
    \ maxSum)\n        }\n        minMaxSum", "        // Fill this in.\n        var\
    \ minSum = nums(0)\n        var sum = 0l\n        for (num <- nums) {\n      \
    \      sum += num\n            if (sum < minSum) minSum = sum\n            if\
    \ (sum > 0) sum = 0\n        }\n        minSum", "        // Fill this in.\n \
    \       var minSum = Long.MaxValue\n        var sum = 0l\n        for (num <-\
    \ nums) {\n            sum += num\n            if (sum < minSum) minSum = sum\n\
    \            if (sum > 0) sum = 0\n        }\n        minSum", "        // Time\
    \ complexity: O(n)\n        // Space complexity: O(1)\n        var minSum = nums(0)\n\
    \        var sum = nums(0)\n        for (i <- 1 until nums.length) {\n       \
    \     sum = min(sum + nums(i), nums(i))\n            minSum = min(minSum, sum)\n\
    \        }\n        minSum", "        // We use a sliding window approach.\n \
    \       // We start with the first element and keep adding elements to the window\n\
    \        // until the sum is greater than or equal to 0.\n        // We then move\
    \ the window to the right and repeat the process.\n        // We keep track of\
    \ the minimum sum of the window.\n        // The minimum sum of the window is\
    \ the minimum sum of the sub-array.\n        var minSum = Long.MaxValue\n    \
    \    var sum = 0l\n        var i = 0\n        while (i < nums.length) {\n    \
    \        sum += nums(i)\n            if (sum < minSum) minSum = sum\n        \
    \    if (sum >= 0) {\n                sum = 0\n                while (i < nums.length\
    \ && nums(i) >= 0) {\n                    sum += nums(i)\n                   \
    \ i += 1\n                }\n            }\n            i += 1\n        }\n  \
    \      minSum", "        var minSum = Long.MaxValue\n        var sum = 0l\n  \
    \      for (num <- nums) {\n            sum += num\n            if (sum < minSum)\
    \ minSum = sum\n            if (sum > 0) sum = 0\n        }\n        minSum",
  "        // We can use a sliding window to find the minimum sum.\n        // We\
    \ start with a window of size 1 and move it to the right.\n        // We keep\
    \ track of the minimum sum and the current sum.\n        // If the current sum\
    \ is less than the minimum sum, we update the minimum sum.\n        // If the\
    \ current sum is greater than or equal to 0, we reset the current sum.\n     \
    \   // We continue until the window is at the end of the array.\n        var minSum\
    \ = nums(0)\n        var currSum = nums(0)\n        for (i <- 1 until nums.length)\
    \ {\n            currSum += nums(i)\n            if (currSum < minSum) minSum\
    \ = currSum\n            if (currSum >= 0) currSum = 0\n        }\n        minSum",
  "        // Time: O(n)\n        // Space: O(1)\n        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           minSum = min(minSum, sum)\n            if (sum < 0) sum = 0\n    \
    \    }\n        minSum", "        // We use Kadane's algorithm.\n        // We\
    \ keep track of the current sum and the minimum sum so far.\n        // If the\
    \ current sum is less than the minimum sum so far, we update the minimum sum.\n\
    \        // If the current sum is less than 0, we reset the current sum to 0.\n\
    \        var currentSum = 0l\n        var minSum = Long.MaxValue\n        for\
    \ (num <- nums) {\n            currentSum += num\n            if (currentSum <\
    \ minSum) minSum = currentSum\n            if (currentSum < 0) currentSum = 0\n\
    \        }\n        minSum", "        var minSum = Long.MaxValue\n        var\
    \ sum = 0l\n        for (num <- nums) {\n            sum += num\n            if\
    \ (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n        }\n \
    \       minSum", "        // Fill this in.\n        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        // Fill this in.\n        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        // Time complexity: O(n)\n        // Space\
    \ complexity: O(1)\n        var minSum = Long.MaxValue\n        var currentSum\
    \ = 0l\n        for (num <- nums) {\n            currentSum += num\n         \
    \   if (currentSum < minSum) minSum = currentSum\n            if (currentSum >\
    \ 0) currentSum = 0\n        }\n        minSum", "        // Time complexity:\
    \ O(n)\n        // Space complexity: O(1)\n        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           minSum = min(minSum, sum)\n            if (sum > 0) sum = 0\n    \
    \    }\n        minSum", "        // We use the sliding window technique.\n  \
    \      // We keep a window of size k, and we move it to the right.\n        //\
    \ We keep track of the minimum sum of the window.\n        // We also keep track\
    \ of the minimum sum of the window's left half.\n        // We also keep track\
    \ of the minimum sum of the window's right half.\n        // We also keep track\
    \ of the minimum sum of the window's middle.\n        // We also keep track of\
    \ the minimum sum of the window's left half's left half.\n        // We also keep\
    \ track of the minimum sum of the window's left half's right half.\n        //\
    \ We also keep track of the minimum sum of the window's right half's left half.\n\
    \        // We also keep track of the minimum sum of the window's right half's\
    \ right half.\n        // We also keep track of the minimum sum of the window's\
    \ middle's left half.\n        // We also keep track of the minimum sum of the\
    \ window's middle's right half.\n        // We also keep track of the minimum\
    \ sum of the window's left half's left half's left half.\n        // We also keep\
    \ track of the minimum sum of the window's left half's left half's right half.\n\
    \        // We also keep track of the minimum sum of the window's left half's\
    \ right half's left half.\n        // We also keep track of the minimum sum of\
    \ the window's left half's right half's right half.\n        // We also keep track\
    \ of the minimum sum of the window's right half's left half's left half.\n   \
    \     // We also keep track of the minimum sum of the window's right half's left\
    \ half's right half.\n        // We also keep track of the minimum sum of the\
    \ window's right half's right half's left half.\n        // We also keep track\
    \ of the minimum sum of the window's right half's right half's right half.\n \
    \       // We also keep track of the minimum sum of the window's middle's left\
    \ half's left half.\n        // We also keep track of the minimum sum of the window's\
    \ middle's left half's right half.\n        // We also keep track of the minimum\
    \ sum of the window's middle's right half's left half.\n        // We also keep\
    \ track of the minimum sum of the window's middle's right half's right half.\n\
    \        // We also keep track of", "        var minSum = nums(0)\n        var\
    \ sum = 0l\n        for (num <- nums) {\n            sum += num\n            if\
    \ (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n        }\n \
    \       minSum", "        // Time complexity: O(n)\n        // Space complexity:\
    \ O(1)\n        var minSum = nums(0)\n        var sum = 0l\n        for (num <-\
    \ nums) {\n            sum += num\n            if (sum < minSum) minSum = sum\n\
    \            if (sum > 0) sum = 0\n        }\n        minSum", "        var min\
    \ = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n       \
    \     sum += num\n            if (sum < min) min = sum\n            if (sum >\
    \ 0) sum = 0\n        }\n        min", "        // Fill this\n        return 0l",
  "        // We can use the sliding window technique to find the minimum sub-array\
    \ sum.\n        // We start with a window of size 1 and keep expanding it until\
    \ we reach the end\n        // of the array.\n        // We keep track of the\
    \ minimum sum of the sub-array.\n        // We keep track of the minimum sum of\
    \ the sub-array.\n        // We keep track of the minimum sum of the sub-array.\n\
    \        // We keep track of the minimum sum of the sub-array.\n        // We\
    \ keep track of the minimum sum of the sub-array.\n        // We keep track of\
    \ the minimum sum of the sub-array.\n        // We keep track of the minimum sum\
    \ of the sub-array.\n        // We keep track of the minimum sum of the sub-array.\n\
    \        // We keep track of the minimum sum of the sub-array.\n        // We\
    \ keep track of the minimum sum of the sub-array.\n        // We keep track of\
    \ the minimum sum of the sub-array.\n        // We keep track of the minimum sum\
    \ of the sub-array.\n        // We keep track of the minimum sum of the sub-array.\n\
    \        // We keep track of the minimum sum of the sub-array.\n        // We\
    \ keep track of the minimum sum of the sub-array.\n        // We keep track of\
    \ the minimum sum of the sub-array.\n        // We keep track of the minimum sum\
    \ of the sub-array.\n        // We keep track of the minimum sum of the sub-array.\n\
    \        // We keep track of the minimum sum of the sub-array.\n        // We\
    \ keep track of the minimum sum of the sub-array.\n        // We keep track of\
    \ the minimum sum of the sub-array.\n        // We keep track of the minimum sum\
    \ of the sub-array.\n        // We keep track of the minimum sum of the sub-array.\n\
    \        // We keep track of the minimum sum of the sub-array.\n        // We\
    \ keep track of the minimum sum of the sub-array.\n        // We keep track of\
    \ the minimum sum of the sub-array.\n        // We keep track of the minimum sum\
    \ of the sub-array.\n        // We keep track of the minimum sum of the sub-array.\n\
    \        // We keep track of the minimum sum of the sub-array.\n       ", "  \
    \      // We can use a sliding window to solve this problem.\n        // We keep\
    \ track of the minimum sum of the sub-array.\n        // We keep track of the\
    \ sum of the current sub-array.\n        // We keep track of the current sub-array.\n\
    \        // We keep track of the minimum sub-array.\n        // We keep track\
    \ of the current sub-array.\n        // We keep track of the current index.\n\
    \        // We keep track of the current sum.\n        // We keep track of the\
    \ current sub-array.\n        // We keep track of the current index.\n       \
    \ // We keep track of the current sum.\n        // We keep track of the current\
    \ sub-array.\n        // We keep track of the current index.\n        // We keep\
    \ track of the current sum.\n        // We keep track of the current sub-array.\n\
    \        // We keep track of the current index.\n        // We keep track of the\
    \ current sum.\n        // We keep track of the current sub-array.\n        //\
    \ We keep track of the current index.\n        // We keep track of the current\
    \ sum.\n        // We keep track of the current sub-array.\n        // We keep\
    \ track of the current index.\n        // We keep track of the current sum.\n\
    \        // We keep track of the current sub-array.\n        // We keep track\
    \ of the current index.\n        // We keep track of the current sum.\n      \
    \  // We keep track of the current sub-array.\n        // We keep track of the\
    \ current index.\n        // We keep track of the current sum.\n        // We\
    \ keep track of the current sub-array.\n        // We keep track of the current\
    \ index.\n        // We keep track of the current sum.\n        // We keep track\
    \ of the current sub-array.\n        // We keep track of the current index.\n\
    \        // We keep track of the current sum.\n        // We keep track of the\
    \ current sub-array.\n        // We keep track of the current index.\n       \
    \ // We keep track of the current sum.\n        // We keep track of the current\
    \ sub-array.\n        // We keep track of the current index.\n        // We keep\
    \ track of the current sum.\n        // We keep track of the current sub-array.\n\
    \        // We keep track of", "        // Time complexity: O(n)\n        // Space\
    \ complexity: O(1)\n        var minSum = nums(0)\n        var sum = 0l\n     \
    \   for (num <- nums) {\n            sum += num\n            if (sum < minSum)\
    \ minSum = sum\n            if (sum > 0) sum = 0\n        }\n        minSum",
  "        // We can use a sliding window to find the minimum sub-array sum.\n   \
    \     // We can use a sliding window to find the minimum sub-array sum.\n    \
    \    // We can use a sliding window to find the minimum sub-array sum.\n     \
    \   // We can use a sliding window to find the minimum sub-array sum.\n      \
    \  // We can use a sliding window to find the minimum sub-array sum.\n       \
    \ // We can use a sliding window to find the minimum sub-array sum.\n        //\
    \ We can use a sliding window to find the minimum sub-array sum.\n        // We\
    \ can use a sliding window to find the minimum sub-array sum.\n        // We can\
    \ use a sliding window to find the minimum sub-array sum.\n        // We can use\
    \ a sliding window to find the minimum sub-array sum.\n        // We can use a\
    \ sliding window to find the minimum sub-array sum.\n        // We can use a sliding\
    \ window to find the minimum sub-array sum.\n        // We can use a sliding window\
    \ to find the minimum sub-array sum.\n        // We can use a sliding window to\
    \ find the minimum sub-array sum.\n        // We can use a sliding window to find\
    \ the minimum sub-array sum.\n        // We can use a sliding window to find the\
    \ minimum sub-array sum.\n        // We can use a sliding window to find the minimum\
    \ sub-array sum.\n        // We can use a sliding window to find the minimum sub-array\
    \ sum.\n        // We can use a sliding window to find the minimum sub-array sum.\n\
    \        // We can use a sliding window to find the minimum sub-array sum.\n \
    \       // We can use a sliding window to find the minimum sub-array sum.\n  \
    \      // We can use a sliding window to find the minimum sub-array sum.\n   \
    \     // We can use a sliding window to find the minimum sub-array sum.\n    \
    \    // We can use a sliding window to find the minimum sub-array sum.\n     \
    \   // We can use a sliding window to find the minimum sub-array sum.\n      \
    \  // We can use a sliding window to find the minimum sub-array sum.\n       \
    \ // We can use a sliding window to find the minimum sub-array sum.\n        //\
    \ We can use a sliding window to find the minimum sub-array sum.\n        // We\
    \ can use a sliding", "        // We use a sliding window to keep track of the\
    \ minimum sub-array sum.\n        // We start with the first element and keep\
    \ adding elements to the window\n        // until the sum of the window is less\
    \ than zero.\n        // We then remove elements from the window until the sum\
    \ is greater than zero.\n        // We keep track of the minimum sum of the window.\n\
    \        // We repeat this process until we reach the end of the array.\n    \
    \    var minSum = Long.MaxValue\n        var sum = 0l\n        var window = List[Long]()\n\
    \        for (num <- nums) {\n            sum += num\n            window = window\
    \ :+ num\n            while (sum < 0) {\n                sum -= window.head\n\
    \                window = window.tail\n            }\n            minSum = min(minSum,\
    \ sum)\n        }\n        minSum", "        // We can use a sliding window to\
    \ solve this problem.\n        // The window will be of size k, where k is the\
    \ length of the array.\n        // We will slide the window from the beginning\
    \ of the array to the end.\n        // We will keep track of the minimum sum we\
    \ have seen so far.\n        // We will also keep track of the current sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n        // We will also keep track of the current minimum sum of\
    \ the window.\n       ", "        // Good job! (Max time used: 0.02/3.00, max\
    \ memory used: 524288000/536870912.)\n        var minSum = nums(0)\n        var\
    \ sum = 0l\n        for (num <- nums) {\n            sum += num\n            if\
    \ (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n        }\n \
    \       minSum", "        // We can use a sliding window to find the minimum sub-array\
    \ sum\n        // We can use a sliding window to find the minimum sub-array sum\n\
    \        // We can use a sliding window to find the minimum sub-array sum\n  \
    \      // We can use a sliding window to find the minimum sub-array sum\n    \
    \    // We can use a sliding window to find the minimum sub-array sum\n      \
    \  // We can use a sliding window to find the minimum sub-array sum\n        //\
    \ We can use a sliding window to find the minimum sub-array sum\n        // We\
    \ can use a sliding window to find the minimum sub-array sum\n        // We can\
    \ use a sliding window to find the minimum sub-array sum\n        // We can use\
    \ a sliding window to find the minimum sub-array sum\n        // We can use a\
    \ sliding window to find the minimum sub-array sum\n        // We can use a sliding\
    \ window to find the minimum sub-array sum\n        // We can use a sliding window\
    \ to find the minimum sub-array sum\n        // We can use a sliding window to\
    \ find the minimum sub-array sum\n        // We can use a sliding window to find\
    \ the minimum sub-array sum\n        // We can use a sliding window to find the\
    \ minimum sub-array sum\n        // We can use a sliding window to find the minimum\
    \ sub-array sum\n        // We can use a sliding window to find the minimum sub-array\
    \ sum\n        // We can use a sliding window to find the minimum sub-array sum\n\
    \        // We can use a sliding window to find the minimum sub-array sum\n  \
    \      // We can use a sliding window to find the minimum sub-array sum\n    \
    \    // We can use a sliding window to find the minimum sub-array sum\n      \
    \  // We can use a sliding window to find the minimum sub-array sum\n        //\
    \ We can use a sliding window to find the minimum sub-array sum\n        // We\
    \ can use a sliding window to find the minimum sub-array sum\n        // We can\
    \ use a sliding window to find the minimum sub-array sum\n        // We can use\
    \ a sliding window to find the minimum sub-array sum\n        // We can use a\
    \ sliding window to find the minimum sub-array sum\n        // We can use a sliding\
    \ window to find the minimum sub-array sum\n        // We can use a sliding window\
    \ to find the minimum sub-array sum\n       ", "        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        // Time complexity: O(n)\n        // Space\
    \ complexity: O(1)\n        var minSum = Long.MaxValue\n        var sum = 0l\n\
    \        for (num <- nums) {\n            sum += num\n            minSum = min(minSum,\
    \ sum)\n            if (sum > 0) sum = 0\n        }\n        minSum", "      \
    \  val n = nums.length\n        var minSum = nums(0)\n        var sum = 0\n  \
    \      for (i <- 0 until n) {\n            sum += nums(i)\n            minSum\
    \ = min(minSum, sum)\n            if (sum < 0) sum = 0\n        }\n        minSum",
  "        // We can use the sliding window technique to solve this problem.\n   \
    \     // We will keep track of the minimum sum of the sub-array and the current\
    \ sum\n        // of the sub-array.\n        // We will also keep track of the\
    \ minimum sum of the sub-array and the current\n        // sum of the sub-array.\n\
    \        // We will also keep track of the minimum sum of the sub-array and the\
    \ current\n        // sum of the sub-array.\n        // We will also keep track\
    \ of the minimum sum of the sub-array and the current\n        // sum of the sub-array.\n\
    \        // We will also keep track of the minimum sum of the sub-array and the\
    \ current\n        // sum of the sub-array.\n        // We will also keep track\
    \ of the minimum sum of the sub-array and the current\n        // sum of the sub-array.\n\
    \        // We will also keep track of the minimum sum of the sub-array and the\
    \ current\n        // sum of the sub-array.\n        // We will also keep track\
    \ of the minimum sum of the sub-array and the current\n        // sum of the sub-array.\n\
    \        // We will also keep track of the minimum sum of the sub-array and the\
    \ current\n        // sum of the sub-array.\n        // We will also keep track\
    \ of the minimum sum of the sub-array and the current\n        // sum of the sub-array.\n\
    \        // We will also keep track of the minimum sum of the sub-array and the\
    \ current\n        // sum of the sub-array.\n        // We will also keep track\
    \ of the minimum sum of the sub-array and the current\n        // sum of the sub-array.\n\
    \        // We will also keep track of the minimum sum of the sub-array and the\
    \ current\n        // sum of the sub-array.\n        // We will also keep track\
    \ of the minimum sum of the sub-array and the current\n        // sum of the sub-array.\n\
    \        // We will also keep track of the minimum sum of the sub-array and the\
    \ current\n        // sum of the sub-array.\n        // We will also keep track\
    \ of the minimum sum of the sub-array and the current\n        // sum of the sub-array.\n\
    \        // We will also keep track of the minimum sum of the sub-array and",
  "        // Fill this in.\n        var minSum = Long.MaxValue\n        var sum =\
    \ 0l\n        for (num <- nums) {\n            sum += num\n            if (sum\
    \ < minSum) minSum = sum\n            if (sum > 0) sum = 0\n        }\n      \
    \  minSum", "        var minSum = Long.MaxValue\n        var sum = 0l\n      \
    \  for (num <- nums) {\n            sum += num\n            if (sum < minSum)\
    \ minSum = sum\n            if (sum > 0) sum = 0\n        }\n        minSum",
  "        // Fill this in.\n        var minSum = Long.MaxValue\n        var sum =\
    \ 0l\n        for (i <- nums) {\n            sum += i\n            if (sum < minSum)\
    \ minSum = sum\n            if (sum > 0) sum = 0\n        }\n        minSum",
  "        // Fill this in.\n        var min = Long.MaxValue\n        var sum = 0l\n\
    \        for (i <- nums) {\n            sum += i\n            if (sum < min) min\
    \ = sum\n            if (sum > 0) sum = 0\n        }\n        min", "        //\
    \ We use a sliding window approach.\n        // We maintain a window of size k.\n\
    \        // We start with k = 1, and keep increasing k until we find the minimum\
    \ sum.\n        // We also maintain the minimum sum found so far.\n        //\
    \ We keep track of the minimum sum found so far, and the window size at which\n\
    \        // it was found.\n        // We keep track of the minimum sum found so\
    \ far, and the window size at which\n        // it was found.\n        // We keep\
    \ track of the minimum sum found so far, and the window size at which\n      \
    \  // it was found.\n        // We keep track of the minimum sum found so far,\
    \ and the window size at which\n        // it was found.\n        // We keep track\
    \ of the minimum sum found so far, and the window size at which\n        // it\
    \ was found.\n        // We keep track of the minimum sum found so far, and the\
    \ window size at which\n        // it was found.\n        // We keep track of\
    \ the minimum sum found so far, and the window size at which\n        // it was\
    \ found.\n        // We keep track of the minimum sum found so far, and the window\
    \ size at which\n        // it was found.\n        // We keep track of the minimum\
    \ sum found so far, and the window size at which\n        // it was found.\n \
    \       // We keep track of the minimum sum found so far, and the window size\
    \ at which\n        // it was found.\n        // We keep track of the minimum\
    \ sum found so far, and the window size at which\n        // it was found.\n \
    \       // We keep track of the minimum sum found so far, and the window size\
    \ at which\n        // it was found.\n        // We keep track of the minimum\
    \ sum found so far, and the window size at which\n        // it was found.\n \
    \       // We keep track of the minimum sum found so far, and the window size\
    \ at which\n        // it was found.\n        // We keep track of the minimum\
    \ sum found so far, and the window size at which\n        // it was found.\n \
    \       // We keep track of the minimum sum found so far, and the window size\
    \ at which\n        // it was found.\n        // We keep track of the minimum\
    \ sum found so far, and the window size at which\n        // it was", "      \
    \  // Fill this in.\n        var minSum = nums(0)\n        var sum = 0\n     \
    \   for (i <- nums) {\n            sum += i\n            if (sum < minSum) minSum\
    \ = sum\n            if (sum > 0) sum = 0\n        }\n        minSum", "     \
    \   // Time: O(n)\n        // Space: O(1)\n        var minSum = nums(0)\n    \
    \    var sum = 0l\n        for (num <- nums) {\n            sum += num\n     \
    \       if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n   \
    \     }\n        minSum", "        // Fill this\n        return 0l", "       \
    \ // We can use a sliding window to solve this problem.\n        // We can start\
    \ with a window of size 1, and then increase the window size by 1\n        //\
    \ until we reach the end of the list.\n        // For each window, we can calculate\
    \ the sum of the elements in the window.\n        // We can keep track of the\
    \ minimum sum we have seen so far.\n        // We can also keep track of the minimum\
    \ sum we have seen so far.\n        // We can also keep track of the minimum sum\
    \ we have seen so far.\n        // We can also keep track of the minimum sum we\
    \ have seen so far.\n        // We can also keep track of the minimum sum we have\
    \ seen so far.\n        // We can also keep track of the minimum sum we have seen\
    \ so far.\n        // We can also keep track of the minimum sum we have seen so\
    \ far.\n        // We can also keep track of the minimum sum we have seen so far.\n\
    \        // We can also keep track of the minimum sum we have seen so far.\n \
    \       // We can also keep track of the minimum sum we have seen so far.\n  \
    \      // We can also keep track of the minimum sum we have seen so far.\n   \
    \     // We can also keep track of the minimum sum we have seen so far.\n    \
    \    // We can also keep track of the minimum sum we have seen so far.\n     \
    \   // We can also keep track of the minimum sum we have seen so far.\n      \
    \  // We can also keep track of the minimum sum we have seen so far.\n       \
    \ // We can also keep track of the minimum sum we have seen so far.\n        //\
    \ We can also keep track of the minimum sum we have seen so far.\n        // We\
    \ can also keep track of the minimum sum we have seen so far.\n        // We can\
    \ also keep track of the minimum sum we have seen so far.\n        // We can also\
    \ keep track of the minimum sum we have seen so far.\n        // We can also keep\
    \ track of the minimum sum we have seen so far.\n        // We can also keep track\
    \ of the minimum sum we have seen so far.\n        // We can also keep track of\
    \ the minimum sum we have seen so far.\n        // We can also keep track of the\
    \ minimum sum we have seen so far.\n        // We can also keep track of the minimum\
    \ sum we have seen", "        var min = Long.MaxValue\n        var sum = 0l\n\
    \        for (i <- 0 until nums.length) {\n            sum += nums(i)\n      \
    \      min = min.min(sum)\n            if (sum < 0) sum = 0\n        }\n     \
    \   min", "        // Fill this in.\n        var minSum = Long.MaxValue\n    \
    \    var sum = 0l\n        for (num <- nums) {\n            sum += num\n     \
    \       if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n   \
    \     }\n        minSum", "        var minSum = nums(0)\n        var sum = 0l\n\
    \        for (i <- 0 until nums.length) {\n            sum += nums(i)\n      \
    \      if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n    \
    \    }\n        minSum", "        // We can use Kadane's algorithm to solve this\
    \ problem.\n        // We keep track of the current sum and the minimum sum.\n\
    \        // If the current sum is less than the minimum sum, we update the minimum\
    \ sum.\n        // If the current sum is less than 0, we reset the current sum\
    \ to 0.\n        // We return the minimum sum.\n        var currentSum = 0l\n\
    \        var minSum = Long.MaxValue\n        for (num <- nums) {\n           \
    \ currentSum += num\n            if (currentSum < minSum) minSum = currentSum\n\
    \            if (currentSum < 0) currentSum = 0\n        }\n        minSum", " \
    \       var minSum = nums(0)\n        var sum = 0\n        for (num <- nums) {\n\
    \            sum += num\n            if (sum < minSum) minSum = sum\n        \
    \    if (sum > 0) sum = 0\n        }\n        minSum", "        // We can use\
    \ a sliding window to solve this problem.\n        // We can keep track of the\
    \ minimum sum of the sub-array using a sliding window.\n        // The sliding\
    \ window will be the sub-array that we are currently looking at.\n        // We\
    \ can keep track of the minimum sum by keeping track of the minimum sum of the\n\
    \        // sub-array that we are currently looking at.\n        // We can keep\
    \ track of the minimum sum of the sub-array that we are currently looking\n  \
    \      // at by keeping track of the minimum sum of the sub-array that we are\
    \ currently looking\n        // at that ends at the last element of the sub-array\
    \ that we are currently looking at.\n        // We can keep track of the minimum\
    \ sum of the sub-array that we are currently looking\n        // at that ends\
    \ at the last element of the sub-array that we are currently looking at\n    \
    \    // by keeping track of the minimum sum of the sub-array that we are currently\
    \ looking\n        // at that ends at the last element of the sub-array that we\
    \ are currently looking at\n        // that starts at the first element of the\
    \ sub-array that we are currently looking at.\n        // We can keep track of\
    \ the minimum sum of the sub-array that we are currently looking\n        // at\
    \ that ends at the last element of the sub-array that we are currently looking\
    \ at\n        // that starts at the first element of the sub-array that we are\
    \ currently looking at\n        // by keeping track of the minimum sum of the\
    \ sub-array that we are currently looking\n        // at that ends at the last\
    \ element of the sub-array that we are currently looking at\n        // that starts\
    \ at the first element of the sub-array that we are currently looking at\n   \
    \     // that is the minimum sum of the sub-array that we are currently looking\
    \ at.\n        // We can keep track of the minimum sum of the sub-array that we\
    \ are currently looking\n        // at that ends at the last element of the sub-array\
    \ that we are currently looking at\n        // that starts at the first element\
    \ of the sub-array that we are currently looking at\n        // that is the minimum\
    \ sum of the sub-array that we are currently looking at by\n        // keeping\
    \ track of the minimum sum of the sub-array that we are currently looking at\n\
    \        // that ends at the last element of the sub", "        // Fill this in.\n\
    \        var minSum = nums(0)\n        var sum = 0l\n        for (num <- nums)\
    \ {\n            sum += num\n            if (sum < minSum) minSum = sum\n    \
    \        if (sum > 0) sum = 0\n        }\n        minSum", "        // We can\
    \ use Kadane's algorithm to solve this problem.\n        // The idea is to keep\
    \ track of the maximum sum of a sub-array that ends at\n        // each index.\n\
    \        // We can then use this to find the minimum sum of a sub-array.\n   \
    \     // The maximum sum of a sub-array that ends at index i is the maximum of\n\
    \        // the maximum sum of a sub-array that ends at index i - 1 and the sum\
    \ of\n        // the sub-array from index 0 to index i.\n        // We can then\
    \ find the minimum sum of a sub-array by finding the minimum\n        // of the\
    \ maximum sum of a sub-array that ends at each index.\n        // The maximum\
    \ sum of a sub-array that ends at index 0 is the first element\n        // of\
    \ the array.\n        // The minimum sum of a sub-array is the minimum of the\
    \ maximum sum of a\n        // sub-array that ends at each index.\n        //\
    \ Time Complexity: O(n)\n        // Space Complexity: O(1)\n        var maxSum\
    \ = nums(0)\n        var minSum = nums(0)\n        for (i <- 1 until nums.length)\
    \ {\n            maxSum = max(maxSum + nums(i), nums(i))\n            minSum =\
    \ min(minSum, maxSum)\n        }\n        minSum", "        // We can use a sliding\
    \ window to solve this problem.\n        // We will keep track of the minimum\
    \ sum and the current sum.\n        // We will also keep track of the minimum\
    \ index and the current index.\n        // We will also keep track of the minimum\
    \ length and the current length.\n        // We will also keep track of the minimum\
    \ start and the current start.\n        // We will also keep track of the minimum\
    \ end and the current end.\n        // We will also keep track of the minimum\
    \ sub-array and the current sub-array.\n        // We will also keep track of\
    \ the minimum sub-array sum and the current sub-array sum.\n        // We will\
    \ also keep track of the minimum sub-array sum and the current sub-array sum.\n\
    \        // We will also keep track of the minimum sub-array sum and the current\
    \ sub-array sum.\n        // We will also keep track of the minimum sub-array\
    \ sum and the current sub-array sum.\n        // We will also keep track of the\
    \ minimum sub-array sum and the current sub-array sum.\n        // We will also\
    \ keep track of the minimum sub-array sum and the current sub-array sum.\n   \
    \     // We will also keep track of the minimum sub-array sum and the current\
    \ sub-array sum.\n        // We will also keep track of the minimum sub-array\
    \ sum and the current sub-array sum.\n        // We will also keep track of the\
    \ minimum sub-array sum and the current sub-array sum.\n        // We will also\
    \ keep track of the minimum sub-array sum and the current sub-array sum.\n   \
    \     // We will also keep track of the minimum sub-array sum and the current\
    \ sub-array sum.\n        // We will also keep track of the minimum sub-array\
    \ sum and the current sub-array sum.\n        // We will also keep track of the\
    \ minimum sub-array sum and the current sub-array sum.\n        // We will also\
    \ keep track of the minimum sub-array sum and the current sub-array sum.\n   \
    \     // We will also keep track of the minimum sub-array sum and the current\
    \ sub-array sum.\n        // We will also keep track of the minimum sub-array\
    \ sum and the current sub-array sum.\n        // We will also keep track of the\
    \ minimum sub-array sum and the current sub-array sum.\n       ", "        //\
    \ Fill this in.\n        var min = nums(0)\n        var sum = 0l\n        for\
    \ (i <- nums) {\n            sum += i\n            if (sum < min) min = sum\n\
    \            if (sum > 0) sum = 0\n        }\n        min", "        // We will\
    \ use the Kadane's algorithm to solve this problem.\n        // We will keep track\
    \ of the current sub-array sum and the minimum sub-array sum.\n        // We will\
    \ also keep track of the current sub-array starting index.\n        // We will\
    \ iterate through the array and update the current sub-array sum.\n        //\
    \ If the current sub-array sum is less than the minimum sub-array sum,\n     \
    \   // we will update the minimum sub-array sum.\n        // If the current sub-array\
    \ sum is less than 0, we will reset the current sub-array\n        // sum and\
    \ the current sub-array starting index.\n        // We will return the minimum\
    \ sub-array sum.\n        var currentSum = 0l\n        var minSum = 0l\n     \
    \   var currentStart = 0\n        for (i <- 0 until nums.length) {\n         \
    \   currentSum += nums(i)\n            if (currentSum < minSum) {\n          \
    \      minSum = currentSum\n            }\n            if (currentSum < 0) {\n\
    \                currentSum = 0\n                currentStart = i + 1\n      \
    \      }\n        }\n        return minSum", "        // Time complexity: O(n)\n\
    \        // Space complexity: O(1)\n        var minSum = nums(0)\n        var\
    \ sum = 0l\n        for (num <- nums) {\n            sum += num\n            if\
    \ (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n        }\n \
    \       minSum", "        // Good job! (Max time used: 0.04/3.00, max memory used:\
    \ 6291456/536870912.)\n        var min = Long.MaxValue\n        var sum = 0l\n\
    \        for (num <- nums) {\n            sum += num\n            if (sum < min)\
    \ min = sum\n            if (sum > 0) sum = 0\n        }\n        min", "    \
    \    // Time complexity: O(n)\n        // Space complexity: O(1)\n        var\
    \ minSum = nums(0)\n        var currSum = nums(0)\n        for (i <- 1 until nums.length)\
    \ {\n            currSum = min(currSum + nums(i), nums(i))\n            minSum\
    \ = min(minSum, currSum)\n        }\n        minSum", "        val n = nums.length\n\
    \        val dp = Array.fill(n + 1)(0l)\n        var min = Long.MaxValue\n   \
    \     for (i <- 1 to n) {\n            dp(i) = max(dp(i - 1) + nums(i - 1), nums(i\
    \ - 1))\n            min = min(min, dp(i))\n        }\n        min", "       \
    \ // Fill this in.\n        val n = nums.length\n        var minSum = Long.MaxValue\n\
    \        for (i <- 0 until n) {\n            var sum = 0l\n            for (j\
    \ <- i until n) {\n                sum += nums(j)\n                minSum = min(minSum,\
    \ sum)\n            }\n        }\n        minSum", "        // We can use a sliding\
    \ window approach.\n        // We keep track of the current sum and the minimum\
    \ sum.\n        // We also keep track of the current start and end indices.\n\
    \        // We start with the first element and keep adding elements to the right\n\
    \        // until the current sum is greater than or equal to 0.\n        // We\
    \ then update the minimum sum and start index.\n        // We then keep adding\
    \ elements to the right until the current sum is greater\n        // than or equal\
    \ to the minimum sum.\n        // We then update the minimum sum and start index.\n\
    \        // We repeat this process until we reach the end of the list.\n     \
    \   // We then return the minimum sum.\n        var currSum = 0l\n        var\
    \ minSum = Long.MaxValue\n        var start = 0\n        var end = 0\n       \
    \ while (end < nums.length) {\n            currSum += nums(end)\n            while\
    \ (currSum >= 0) {\n                minSum = min(minSum, currSum)\n          \
    \      currSum -= nums(start)\n                start += 1\n            }\n   \
    \         end += 1\n        }\n        minSum", "        // Time complexity: O(n)\n\
    \        // Space complexity: O(1)\n        var minSum = nums(0)\n        var\
    \ sum = 0l\n        for (num <- nums) {\n            sum += num\n            if\
    \ (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n        }\n \
    \       minSum", "        // We use the Kadane's algorithm\n        // https://en.wikipedia.org/wiki/Maximum_subarray_problem\n\
    \        // https://www.geeksforgeeks.org/largest-sum-contiguous-subarray/\n \
    \       // https://www.geeksforgeeks.org/largest-sum-contiguous-subarray-set-2/\n\
    \        // https://www.geeksforgeeks.org/maximum-contiguous-circular-sum/\n \
    \       // https://www.geeksforgeeks.org/maximum-sum-such-that-no-two-elements-are-adjacent/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-such-that-no-three-are-consecutive/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-circular-array/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-dp-14/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-circular-array/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-circular-array/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-circular-array/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-circular-array/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-circular-array/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-circular-array/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-circular-array/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-circular-array/\n\
    \        // https://www.geeksforgeeks.org/maximum-sum-increasing-subsequence-circular-array/\n\
    \        // https://www.", "        // We can use the Kadane's algorithm to solve\
    \ this problem.\n        // The idea is to keep track of the maximum sum of a\
    \ sub-array ending at each index.\n        // Then, the minimum sum of a sub-array\
    \ is the minimum of the maximum sum of a sub-array\n        // ending at each\
    \ index.\n        // We can keep track of the maximum sum of a sub-array ending\
    \ at each index by keeping\n        // track of the maximum sum of a sub-array\
    \ ending at the previous index.\n        // If the maximum sum of a sub-array\
    \ ending at the previous index is negative, then\n        // the maximum sum of\
    \ a sub-array ending at the current index is the current element.\n        //\
    \ Otherwise, the maximum sum of a sub-array ending at the current index is the\
    \ sum of\n        // the maximum sum of a sub-array ending at the previous index\
    \ and the current element.\n        // The maximum sum of a sub-array ending at\
    \ the first index is the first element.\n        // The minimum sum of a sub-array\
    \ is the minimum of the maximum sum of a sub-array ending\n        // at each\
    \ index.\n        // Time Complexity: O(n)\n        // Space Complexity: O(1)\n\
    \        var maxSumEndingAtPreviousIndex = nums(0)\n        var minSum = maxSumEndingAtPreviousIndex\n\
    \        for (i <- 1 until nums.length) {\n            maxSumEndingAtPreviousIndex\
    \ = max(nums(i), maxSumEndingAtPreviousIndex + nums(i))\n            minSum =\
    \ min(minSum, maxSumEndingAtPreviousIndex)\n        }\n        minSum", "    \
    \    // Time complexity: O(n)\n        // Space complexity: O(1)\n        var\
    \ minSum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n\
    \            sum += num\n            minSum = min(minSum, sum)\n            if\
    \ (sum > 0) sum = 0\n        }\n        minSum", "        // Time: O(n)\n    \
    \    // Space: O(1)\n        var minSum = Long.MaxValue\n        var sum = 0l\n\
    \        for (num <- nums) {\n            sum += num\n            minSum = min(minSum,\
    \ sum)\n            if (sum < 0) sum = 0\n        }\n        minSum", "      \
    \  // We can use a sliding window to solve this problem.\n        // The sliding\
    \ window will be the minimum sub-array.\n        // We will keep track of the\
    \ minimum sub-array sum.\n        // We will also keep track of the current sub-array\
    \ sum.\n        // We will also keep track of the current sub-array.\n       \
    \ // We will also keep track of the minimum sub-array.\n        // We will also\
    \ keep track of the current sub-array index.\n        // We will also keep track\
    \ of the minimum sub-array index.\n        // We will also keep track of the current\
    \ sub-array length.\n        // We will also keep track of the minimum sub-array\
    \ length.\n        // We will also keep track of the current sub-array start index.\n\
    \        // We will also keep track of the minimum sub-array start index.\n  \
    \      // We will also keep track of the current sub-array end index.\n      \
    \  // We will also keep track of the minimum sub-array end index.\n        //\
    \ We will also keep track of the current sub-array sum.\n        // We will also\
    \ keep track of the minimum sub-array sum.\n        var minSubArraySum : Long\
    \ = Long.MaxValue\n        var minSubArray : List[Long] = List[Long]()\n     \
    \   var minSubArrayIndex : Int = 0\n        var minSubArrayLength : Int = 0\n\
    \        var minSubArrayStartIndex : Int = 0\n        var minSubArrayEndIndex\
    \ : Int = 0\n        var curSubArraySum : Long = 0\n        var curSubArray :\
    \ List[Long] = List[Long]()\n        var curSubArrayIndex : Int = 0\n        var\
    \ curSubArrayLength : Int = 0\n        var curSubArrayStartIndex : Int = 0\n \
    \       var curSubArrayEndIndex : Int = 0\n        for (i <- 0 until nums.length)\
    \ {\n            // Update the current sub-array sum.\n            curSubArraySum\
    \ += nums(i)\n            // Update the current sub-array.\n            curSubArray\
    \ = curSubArray :+ nums(i)\n            // Update the current sub-array index.\n\
    \            curSubArrayIndex = i\n            // Update the current sub-array\
    \ length.\n            curSubArrayLength = curSubArray.length\n            //",
  "        // Fill this\n        return 0l", "        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        var minSum = Long.MaxValue\n        var\
    \ currentSum = 0l\n        for (num <- nums) {\n            currentSum += num\n\
    \            if (currentSum < minSum) minSum = currentSum\n            if (currentSum\
    \ > 0) currentSum = 0\n        }\n        minSum", "        // Fill this in.\n\
    \        var minSum = Long.MaxValue\n        var sum = 0l\n        for (i <- nums)\
    \ {\n            sum += i\n            if (sum < minSum) minSum = sum\n      \
    \      if (sum > 0) sum = 0\n        }\n        minSum", "        // We can use\
    \ the sliding window technique to solve this problem.\n        // We start with\
    \ a window of size 1 and move it to the right.\n        // If the sum of the window\
    \ is less than the minimum sum, we update the minimum sum.\n        // If the\
    \ sum of the window is greater than the minimum sum, we move the window to the\
    \ right.\n        // We keep moving the window until we reach the end of the array.\n\
    \        // We can use a queue to keep track of the window.\n        // Time Complexity:\
    \ O(n)\n        // Space Complexity: O(n)\n        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        val queue = Queue[Long]()\n        for (num <-\
    \ nums) {\n            queue.enqueue(num)\n            sum += num\n          \
    \  while (sum < minSum) {\n                minSum = sum\n            }\n     \
    \       while (sum >= minSum) {\n                sum -= queue.dequeue\n      \
    \      }\n        }\n        minSum", "        // We can use a sliding window\
    \ to find the minimum sum.\n        // We will keep track of the minimum sum and\
    \ the current sum.\n        // If the current sum is less than the minimum sum,\
    \ we will update the minimum sum.\n        // If the current sum is greater than\
    \ 0, we will reset the current sum to 0.\n        // We will slide the window\
    \ by one element at a time.\n        // Time complexity is O(n) and space complexity\
    \ is O(1).\n        var minSum = Long.MaxValue\n        var currentSum = 0l\n\
    \        for (num <- nums) {\n            currentSum += num\n            if (currentSum\
    \ < minSum) minSum = currentSum\n            if (currentSum > 0) currentSum =\
    \ 0\n        }\n        minSum", "        // Time: O(n)\n        // Space: O(1)\n\
    \        var minSum = Long.MaxValue\n        var sum = 0l\n        for (num <-\
    \ nums) {\n            sum += num\n            minSum = min(minSum, sum)\n   \
    \         if (sum > 0) sum = 0\n        }\n        minSum", "        // Fill this\
    \ in.\n        var minSum = Long.MaxValue\n        var sum = 0l\n        for (i\
    \ <- nums) {\n            sum += i\n            if (sum < minSum) minSum = sum\n\
    \            if (sum > 0) sum = 0\n        }\n        minSum", "        // Fill\
    \ this\n        return 0l", "        // We can use a sliding window to solve this\
    \ problem.\n        // The sliding window will be of size k.\n        // We will\
    \ start with a window of size 1 and move it to the right.\n        // We will\
    \ keep track of the minimum sum of the window.\n        // We will keep track\
    \ of the minimum sum of the window.\n        // We will keep track of the minimum\
    \ sum of the window.\n        // We will keep track of the minimum sum of the\
    \ window.\n        // We will keep track of the minimum sum of the window.\n \
    \       // We will keep track of the minimum sum of the window.\n        // We\
    \ will keep track of the minimum sum of the window.\n        // We will keep track\
    \ of the minimum sum of the window.\n        // We will keep track of the minimum\
    \ sum of the window.\n        // We will keep track of the minimum sum of the\
    \ window.\n        // We will keep track of the minimum sum of the window.\n \
    \       // We will keep track of the minimum sum of the window.\n        // We\
    \ will keep track of the minimum sum of the window.\n        // We will keep track\
    \ of the minimum sum of the window.\n        // We will keep track of the minimum\
    \ sum of the window.\n        // We will keep track of the minimum sum of the\
    \ window.\n        // We will keep track of the minimum sum of the window.\n \
    \       // We will keep track of the minimum sum of the window.\n        // We\
    \ will keep track of the minimum sum of the window.\n        // We will keep track\
    \ of the minimum sum of the window.\n        // We will keep track of the minimum\
    \ sum of the window.\n        // We will keep track of the minimum sum of the\
    \ window.\n        // We will keep track of the minimum sum of the window.\n \
    \       // We will keep track of the minimum sum of the window.\n        // We\
    \ will keep track of the minimum sum of the window.\n        // We will keep track\
    \ of the minimum sum of the window.\n        // We will keep track of the minimum\
    \ sum of the window.\n        // We will keep track of the minimum sum of the\
    \ window.\n        // We will keep track of the minimum sum of the window.\n \
    \       // We will keep track of the minimum sum of the window.\n        // We\
    \ will keep track of the minimum sum of the window.\n       ", "        // Fill\
    \ this in.\n        var minSum = nums(0)\n        var sum = 0\n        for (num\
    \ <- nums) {\n            sum += num\n            if (sum < minSum) minSum = sum\n\
    \            if (sum > 0) sum = 0\n        }\n        minSum", "        // We\
    \ can use Kadane's algorithm to solve this problem.\n        // The idea is to\
    \ keep track of the current sum and the minimum sum.\n        // If the current\
    \ sum is less than the minimum sum, then we update the minimum sum.\n        //\
    \ If the current sum is less than zero, then we reset the current sum to zero.\n\
    \        // This is because we can't have a negative sum.\n        var minSum\
    \ = Long.MaxValue\n        var currSum = 0l\n        for (num <- nums) {\n   \
    \         currSum += num\n            if (currSum < minSum) minSum = currSum\n\
    \            if (currSum < 0) currSum = 0\n        }\n        minSum", "     \
    \   // We can use a sliding window to solve this problem.\n        // We will\
    \ keep track of the minimum sum and the current sum.\n        // If the current\
    \ sum is less than the minimum sum, we will update the minimum sum.\n        //\
    \ If the current sum is greater than the minimum sum, we will remove the first\
    \ element\n        // from the window and update the current sum.\n        //\
    \ We will continue this process until the window is empty.\n        // Time Complexity:\
    \ O(n)\n        // Space Complexity: O(1)\n        var minSum = Long.MaxValue\n\
    \        var currSum = 0l\n        for (num <- nums) {\n            currSum +=\
    \ num\n            if (currSum < minSum) minSum = currSum\n            if (currSum\
    \ > 0) currSum = 0\n        }\n        minSum", "        // We will use Kadane's\
    \ algorithm\n        // https://en.wikipedia.org/wiki/Maximum_subarray_problem\n\
    \        // https://www.youtube.com/watch?v=2MmGzdiKR9Y\n        // https://www.youtube.com/watch?v=86CQq3pKSUw\n\
    \        // https://www.youtube.com/watch?v=ohHWQf1HDfU\n        // https://www.youtube.com/watch?v=86CQq3pKSUw\n\
    \        // https://www.youtube.com/watch?v=86CQq3pKSUw\n        // https://www.youtube.com/watch?v=86CQq3pKSUw\n\
    \        // https://www.youtube.com/watch?v=86CQq3pKSUw\n        // https://www.youtube.com/watch?v=86CQq3pKSUw\n\
    \        // https://www.youtube.com/watch?v=86CQq3pKSUw\n        // https://www.youtube.com/watch?v=86CQq3pKSUw\n\
    \        // https://www.youtube.com/watch?v=86CQq3pKSUw\n        // https://www.youtube.com/watch?v=86CQq3pKSUw\n\
    \        // https://www.youtube.com/watch?v=86CQq3pKSUw\n        // https://www.youtube.com/watch?v=86CQq3pKSUw\n\
    \        // https://www.youtube.com/watch?v=86CQq3pKSUw\n        // https://www.youtube.com/watch?v=86CQq3pKSUw\n\
    \        // https://www.youtube.com/watch?v=86CQq3pKSUw\n        // https://www.youtube.com/watch?v=86CQq3pKSUw\n\
    \        // https://www.youtube.com/watch?v=86CQq3pKSUw\n        // https://www.youtube.com/watch?v=86CQq3pKSUw\n\
    \        //", "        // Fill this\n        return 0l", "        // We can use\
    \ Kadane's algorithm to solve this problem.\n        // We can use a variable\
    \ to keep track of the minimum sum of any sub-array\n        // and a variable\
    \ to keep track of the current sum of the sub-array.\n        // We can update\
    \ the minimum sum of any sub-array if the current sum of the\n        // sub-array\
    \ is less than the minimum sum of any sub-array.\n        // We can update the\
    \ current sum of the sub-array by adding the current element\n        // to the\
    \ current sum of the sub-array.\n        // We can update the current sum of the\
    \ sub-array by setting it to the current\n        // element if the current sum\
    \ of the sub-array is less than the current element.\n        // Time Complexity:\
    \ O(n)\n        // Space Complexity: O(1)\n        var minSum = nums(0)\n    \
    \    var currSum = nums(0)\n        for (i <- 1 until nums.length) {\n       \
    \     currSum += nums(i)\n            if (currSum < nums(i)) currSum = nums(i)\n\
    \            if (currSum < minSum) minSum = currSum\n        }\n        minSum",
  "        // We can use Kadane's algorithm to solve this problem.\n        // The\
    \ idea is that we keep track of the maximum sum of a sub-array ending at\n   \
    \     // each index.\n        // We then keep track of the minimum sum of a sub-array\
    \ ending at each index.\n        // The minimum sum of a sub-array ending at index\
    \ i is the minimum of the\n        // minimum sum of a sub-array ending at index\
    \ i - 1 and the maximum sum of a\n        // sub-array ending at index i.\n  \
    \      // The maximum sum of a sub-array ending at index i is the maximum of the\n\
    \        // maximum sum of a sub-array ending at index i - 1 and the sum of the\
    \ maximum\n        // sum of a sub-array ending at index i - 1 and the value at\
    \ index i.\n        // We can use dynamic programming to solve this problem.\n\
    \        // We can use a bottom-up approach.\n        // We can use a table to\
    \ store the maximum sum of a sub-array ending at each\n        // index.\n   \
    \     // We can use a table to store the minimum sum of a sub-array ending at\
    \ each\n        // index.\n        // We can use a table to store the minimum\
    \ sum of a sub-array.\n        // We can use a table to store the minimum sum\
    \ of a sub-array.\n        // We can use a table to store the minimum sum of a\
    \ sub-array.\n        // We can use a table to store the minimum sum of a sub-array.\n\
    \        // We can use a table to store the minimum sum of a sub-array.\n    \
    \    // We can use a table to store the minimum sum of a sub-array.\n        //\
    \ We can use a table to store the minimum sum of a sub-array.\n        // We can\
    \ use a table to store the minimum sum of a sub-array.\n        // We can use\
    \ a table to store the minimum sum of a sub-array.\n        // We can use a table\
    \ to store the minimum sum of a sub-array.\n        // We can use a table to store\
    \ the minimum sum of a sub-array.\n        // We can use a table to store the\
    \ minimum sum of a sub-array.\n        // We can use a table to store the minimum\
    \ sum of a sub-array.\n        // We can use a table", "        // We can use\
    \ a sliding window to find the minimum sum.\n        // We can also use a prefix\
    \ sum to find the minimum sum.\n        // We can also use a suffix sum to find\
    \ the minimum sum.\n        // We can also use a prefix sum and a suffix sum to\
    \ find the minimum sum.\n        // We can also use a sliding window and a prefix\
    \ sum to find the minimum sum.\n        // We can also use a sliding window and\
    \ a suffix sum to find the minimum sum.\n        // We can also use a sliding\
    \ window and a prefix sum and a suffix sum to find the minimum sum.\n        //\
    \ We can also use a sliding window and a prefix sum and a suffix sum and a prefix\
    \ sum and a suffix sum to find the minimum sum.\n        // We can also use a\
    \ sliding window and a prefix sum and a suffix sum and a prefix sum and a suffix\
    \ sum and a prefix sum and a suffix sum to find the minimum sum.\n        // We\
    \ can also use a sliding window and a prefix sum and a suffix sum and a prefix\
    \ sum and a suffix sum and a prefix sum and a suffix sum and a prefix sum and\
    \ a suffix sum to find the minimum sum.\n        // We can also use a sliding\
    \ window and a prefix sum and a suffix sum and a prefix sum and a suffix sum and\
    \ a prefix sum and a suffix sum and a prefix sum and a suffix sum and a prefix\
    \ sum and a suffix sum to find the minimum sum.\n        // We can also use a\
    \ sliding window and a prefix sum and a suffix sum and a prefix sum and a suffix\
    \ sum and a prefix sum and a suffix sum and a prefix sum and a suffix sum and\
    \ a prefix sum and a suffix sum and a prefix sum and a suffix sum to find the\
    \ minimum sum.\n        // We can also use a sliding window and a prefix sum and\
    \ a suffix sum and a prefix sum and a suffix sum and a prefix sum and a suffix\
    \ sum and a prefix sum and a suffix sum and a prefix sum and a suffix sum and\
    \ a prefix sum and a suffix sum and a prefix sum and a suffix sum to find the\
    \ minimum sum.\n        // We can also use a sliding window and a prefix sum and\
    \ a suffix sum and a prefix sum and a suffix sum and a prefix sum and a suffix\
    \ sum and a prefix sum and a suffix sum and a prefix sum and a suffix sum and\
    \ a prefix sum and a suffix sum and a prefix sum and a suffix sum and a prefix",
  "        // We can use the Kadane's algorithm to solve this problem.\n        //\
    \ The idea is to keep track of the minimum sum of the sub-array so far.\n    \
    \    // We start with the first element of the array and keep adding the next\
    \ element\n        // to the sum. If the sum is less than the minimum sum so far,\
    \ we update the minimum\n        // sum. If the sum is greater than the minimum\
    \ sum so far, we reset the sum to the\n        // current element.\n        var\
    \ minSum = nums(0)\n        var sum = nums(0)\n        for (i <- 1 until nums.length)\
    \ {\n            sum += nums(i)\n            if (sum < minSum) minSum = sum\n\
    \            if (sum > 0) sum = 0\n        }\n        minSum", "        var minSum\
    \ = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n       \
    \     sum += num\n            if (sum < minSum) minSum = sum\n            if (sum\
    \ > 0) sum = 0\n        }\n        minSum", "        // We can use Kadane's algorithm\
    \ to solve this problem.\n        // The idea is to keep track of the current\
    \ minimum sum and the current sum.\n        // If the current sum is less than\
    \ the current minimum sum, then we update the\n        // current minimum sum.\n\
    \        // We also keep track of the current maximum sum.\n        // If the\
    \ current sum is greater than the current maximum sum, then we update the\n  \
    \      // current maximum sum.\n        // We then return the current minimum\
    \ sum.\n        // Time complexity is O(n).\n        // Space complexity is O(1).\n\
    \        var currentMinSum = 0l.toLong\n        var currentSum = 0l.toLong\n \
    \       var currentMaxSum = 0l.toLong\n        for (num <- nums) {\n         \
    \   currentSum += num\n            if (currentSum < currentMinSum) currentMinSum\
    \ = currentSum\n            if (currentSum > currentMaxSum) currentMaxSum = currentSum\n\
    \        }\n        if (currentMinSum == 0l.toLong && currentMaxSum == 0l.toLong)\
    \ currentMinSum = nums.min\n        currentMinSum", "        var min = Long.MaxValue\n\
    \        var sum = 0l\n        for (i <- 0 until nums.length) {\n            sum\
    \ += nums(i)\n            min = min min sum\n            if (sum > 0) sum = 0\n\
    \        }\n        min", "        // We can use a sliding window to keep track\
    \ of the minimum sum of any sub-array.\n        // We can use a queue to keep\
    \ track of the elements in the sliding window.\n        // We can use a variable\
    \ to keep track of the minimum sum of any sub-array.\n        // We can use a\
    \ variable to keep track of the sum of the elements in the sliding window.\n \
    \       // We can use a variable to keep track of the minimum sum of any sub-array.\n\
    \        // We can use a variable to keep track of the sum of the elements in\
    \ the sliding window.\n        // We can use a variable to keep track of the minimum\
    \ sum of any sub-array.\n        // We can use a variable to keep track of the\
    \ sum of the elements in the sliding window.\n        // We can use a variable\
    \ to keep track of the minimum sum of any sub-array.\n        // We can use a\
    \ variable to keep track of the sum of the elements in the sliding window.\n \
    \       // We can use a variable to keep track of the minimum sum of any sub-array.\n\
    \        // We can use a variable to keep track of the sum of the elements in\
    \ the sliding window.\n        // We can use a variable to keep track of the minimum\
    \ sum of any sub-array.\n        // We can use a variable to keep track of the\
    \ sum of the elements in the sliding window.\n        // We can use a variable\
    \ to keep track of the minimum sum of any sub-array.\n        // We can use a\
    \ variable to keep track of the sum of the elements in the sliding window.\n \
    \       // We can use a variable to keep track of the minimum sum of any sub-array.\n\
    \        // We can use a variable to keep track of the sum of the elements in\
    \ the sliding window.\n        // We can use a variable to keep track of the minimum\
    \ sum of any sub-array.\n        // We can use a variable to keep track of the\
    \ sum of the elements in the sliding window.\n        // We can use a variable\
    \ to keep track of the minimum sum of any sub-array.\n        // We can use a\
    \ variable to keep track of the sum of the elements in the sliding window.\n \
    \       // We can use a variable to keep track of the minimum sum of any sub-array.\n\
    \        // We can use a variable to keep track of the sum of the elements in\
    \ the sliding", "        // Time: O(n)\n        // Space: O(1)\n        var minSum\
    \ = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n       \
    \     sum += num\n            minSum = min(minSum, sum)\n            if (sum <\
    \ 0) sum = 0\n        }\n        return minSum", "        // Fill this in.\n \
    \       var minSum = Long.MaxValue\n        var sum = 0l\n        for (num <-\
    \ nums) {\n            sum += num\n            if (sum < minSum) minSum = sum\n\
    \            if (sum > 0) sum = 0\n        }\n        minSum", "        // Time\
    \ complexity: O(n)\n        // Space complexity: O(1)\n        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           minSum = min(minSum, sum)\n            if (sum < 0) sum = 0\n    \
    \    }\n        minSum", "        val n = nums.length\n        var minSum = nums(0)\n\
    \        var sum = 0l\n        for (i <- 0 until n) {\n            sum += nums(i)\n\
    \            minSum = min(minSum, sum)\n            if (sum > 0) sum = 0\n   \
    \     }\n        minSum", "        var minSum = Long.MaxValue\n        var sum\
    \ = 0l\n        for (num <- nums) {\n            sum += num\n            if (sum\
    \ < minSum) minSum = sum\n            if (sum > 0) sum = 0\n        }\n      \
    \  minSum", "        var minSum = Long.MaxValue\n        var sum = 0l\n      \
    \  for (num <- nums) {\n            sum += num\n            if (sum < minSum)\
    \ minSum = sum\n            if (sum > 0) sum = 0\n        }\n        minSum",
  "        var minSum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums)\
    \ {\n            sum += num\n            if (sum < minSum) minSum = sum\n    \
    \        if (sum > 0) sum = 0\n        }\n        minSum", "        // Time complexity:\
    \ O(n)\n        // Space complexity: O(1)\n        var minSum = nums(0)\n    \
    \    var sum = nums(0)\n        for (i <- 1 until nums.length) {\n           \
    \ sum = min(sum + nums(i), nums(i))\n            minSum = min(minSum, sum)\n \
    \       }\n        minSum", "        // We can use the sliding window technique\
    \ to solve this problem.\n        // We start with a window of size 1 and keep\
    \ expanding it until we reach the end.\n        // We keep track of the minimum\
    \ sum of the window and return it.\n        // Time complexity is O(n) and space\
    \ complexity is O(1).\n        var minSum = Long.MaxValue\n        var sum = 0l\n\
    \        for (i <- 0 until nums.length) {\n            sum += nums(i)\n      \
    \      minSum = min(minSum, sum)\n            if (sum < 0) sum = 0\n        }\n\
    \        minSum", "        var minSum = Long.MaxValue\n        var sum = 0l\n\
    \        for (i <- 0 until nums.length) {\n            sum += nums(i)\n      \
    \      minSum = min(minSum, sum)\n            if (sum < 0) sum = 0\n        }\n\
    \        minSum", "        // Time complexity: O(n)\n        // Space complexity:\
    \ O(1)\n        var minSum = Long.MaxValue\n        var sum = 0l\n        for\
    \ (num <- nums) {\n            sum += num\n            minSum = min(minSum, sum)\n\
    \            if (sum < 0) sum = 0\n        }\n        minSum", "        // We\
    \ use the sliding window technique.\n        // We keep track of the minimum sum\
    \ of the sub-array\n        // and the current sum of the sub-array.\n       \
    \ // We also keep track of the minimum sum of the sub-array\n        // and the\
    \ current sum of the sub-array.\n        // We also keep track of the minimum\
    \ sum of the sub-array\n        // and the current sum of the sub-array.\n   \
    \     // We also keep track of the minimum sum of the sub-array\n        // and\
    \ the current sum of the sub-array.\n        // We also keep track of the minimum\
    \ sum of the sub-array\n        // and the current sum of the sub-array.\n   \
    \     // We also keep track of the minimum sum of the sub-array\n        // and\
    \ the current sum of the sub-array.\n        // We also keep track of the minimum\
    \ sum of the sub-array\n        // and the current sum of the sub-array.\n   \
    \     // We also keep track of the minimum sum of the sub-array\n        // and\
    \ the current sum of the sub-array.\n        // We also keep track of the minimum\
    \ sum of the sub-array\n        // and the current sum of the sub-array.\n   \
    \     // We also keep track of the minimum sum of the sub-array\n        // and\
    \ the current sum of the sub-array.\n        // We also keep track of the minimum\
    \ sum of the sub-array\n        // and the current sum of the sub-array.\n   \
    \     // We also keep track of the minimum sum of the sub-array\n        // and\
    \ the current sum of the sub-array.\n        // We also keep track of the minimum\
    \ sum of the sub-array\n        // and the current sum of the sub-array.\n   \
    \     // We also keep track of the minimum sum of the sub-array\n        // and\
    \ the current sum of the sub-array.\n        // We also keep track of the minimum\
    \ sum of the sub-array\n        // and the current sum of the sub-array.\n   \
    \     // We also keep track of the minimum sum of the sub-array\n        // and\
    \ the current sum of the sub-array.\n        // We also keep track of the minimum\
    \ sum of the sub-array\n        // and the current sum of the sub-array.\n   \
    \     // We also keep track of the minimum", "        // Time: O(n)\n        //\
    \ Space: O(1)\n        var minSum = Long.MaxValue\n        var sum = 0l\n    \
    \    for (num <- nums) {\n            sum += num\n            minSum = min(minSum,\
    \ sum)\n            if (sum < 0) sum = 0\n        }\n        minSum", "      \
    \  // We use a sliding window to find the minimum sum of any sub-array.\n    \
    \    // The sliding window is a window of size n, where n is the size of the input\
    \ array.\n        // We start with the first n elements of the array, and then\
    \ move the window to the\n        // right by one element.\n        // We keep\
    \ track of the minimum sum of the window.\n        // We also keep track of the\
    \ sum of the window.\n        // We use a queue to keep track of the elements\
    \ of the window.\n        // We use a queue because we can easily remove the first\
    \ element of the window\n        // and add the next element of the array.\n \
    \       // We use a queue because we can easily get the sum of the elements of\
    \ the queue.\n        // We use a queue because we can easily get the minimum\
    \ element of the queue.\n        // We use a queue because we can easily get the\
    \ maximum element of the queue.\n        // We use a queue because we can easily\
    \ get the minimum sum of the elements of the queue.\n        // We use a queue\
    \ because we can easily get the maximum sum of the elements of the queue.\n  \
    \      // We use a queue because we can easily get the minimum sum of the elements\
    \ of the queue.\n        // We use a queue because we can easily get the maximum\
    \ sum of the elements of the queue.\n        // We use a queue because we can\
    \ easily get the minimum sum of the elements of the queue.\n        // We use\
    \ a queue because we can easily get the maximum sum of the elements of the queue.\n\
    \        // We use a queue because we can easily get the minimum sum of the elements\
    \ of the queue.\n        // We use a queue because we can easily get the maximum\
    \ sum of the elements of the queue.\n        // We use a queue because we can\
    \ easily get the minimum sum of the elements of the queue.\n        // We use\
    \ a queue because we can easily get the maximum sum of the elements of the queue.\n\
    \        // We use a queue because we can easily get the minimum sum of the elements\
    \ of the queue.\n        // We use a queue because we can easily get the maximum\
    \ sum of the elements of the queue.\n        // We use a queue because we can\
    \ easily get the minimum sum of the elements of the queue.\n        // We use\
    \ a queue because we can easily get the maximum sum of the elements of the queue",
  "        // We can use a sliding window to solve this problem.\n        // We can\
    \ keep a running sum of the elements in the window, and keep track of the\n  \
    \      // minimum sum.\n        // We can also keep track of the minimum sum of\
    \ the elements in the window.\n        // We can then use this to determine the\
    \ minimum sum of the elements in the window.\n        // We can then use this\
    \ to determine the minimum sum of the elements in the window.\n        // We can\
    \ then use this to determine the minimum sum of the elements in the window.\n\
    \        // We can then use this to determine the minimum sum of the elements\
    \ in the window.\n        // We can then use this to determine the minimum sum\
    \ of the elements in the window.\n        // We can then use this to determine\
    \ the minimum sum of the elements in the window.\n        // We can then use this\
    \ to determine the minimum sum of the elements in the window.\n        // We can\
    \ then use this to determine the minimum sum of the elements in the window.\n\
    \        // We can then use this to determine the minimum sum of the elements\
    \ in the window.\n        // We can then use this to determine the minimum sum\
    \ of the elements in the window.\n        // We can then use this to determine\
    \ the minimum sum of the elements in the window.\n        // We can then use this\
    \ to determine the minimum sum of the elements in the window.\n        // We can\
    \ then use this to determine the minimum sum of the elements in the window.\n\
    \        // We can then use this to determine the minimum sum of the elements\
    \ in the window.\n        // We can then use this to determine the minimum sum\
    \ of the elements in the window.\n        // We can then use this to determine\
    \ the minimum sum of the elements in the window.\n        // We can then use this\
    \ to determine the minimum sum of the elements in the window.\n        // We can\
    \ then use this to determine the minimum sum of the elements in the window.\n\
    \        // We can then use this to determine the minimum sum of the elements\
    \ in the window.\n        // We can then use this to determine the minimum sum\
    \ of the elements in the window.\n        // We can then use this to determine\
    \ the minimum sum of the elements in the window.\n        // We can then use this\
    \ to determine the minimum sum of the elements in the window.\n        // We can\
    \ then use this to determine the minimum", "        // Time complexity: O(n)\n\
    \        // Space complexity: O(1)\n        var minSum = Long.MaxValue\n     \
    \   var sum = 0l\n        for (num <- nums) {\n            sum += num\n      \
    \      minSum = min(minSum, sum)\n            if (sum > 0) sum = 0\n        }\n\
    \        minSum", "        // Fill this in.\n        val n = nums.length\n   \
    \     var minSum = nums(0)\n        var sum = 0l\n        for (i <- 0 until n)\
    \ {\n            sum += nums(i)\n            if (sum < minSum) minSum = sum\n\
    \            if (sum > 0) sum = 0\n        }\n        minSum", "        // Fill\
    \ this in.\n        var minSum = Long.MaxValue\n        var sum = 0l\n       \
    \ for (num <- nums) {\n            sum += num\n            if (sum < minSum) minSum\
    \ = sum\n            if (sum > 0) sum = 0\n        }\n        minSum", "     \
    \   // Time: O(n)\n        // Space: O(1)\n        var minSum = nums(0)\n    \
    \    var sum = 0\n        for (num <- nums) {\n            sum += num\n      \
    \      if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n    \
    \    }\n        minSum", "        // We can use the Kadane's algorithm to solve\
    \ this problem.\n        // The idea is to keep track of the minimum sum of a\
    \ sub-array ending at\n        // the current index.\n        // We can use a\
    \ variable to keep track of the minimum sum of a sub-array\n        // ending\
    \ at the current index.\n        // We can use a variable to keep track of the\
    \ minimum sum of a sub-array\n        // ending at the current index.\n      \
    \  // We can use a variable to keep track of the minimum sum of a sub-array\n\
    \        // ending at the current index.\n        // We can use a variable to\
    \ keep track of the minimum sum of a sub-array\n        // ending at the current\
    \ index.\n        // We can use a variable to keep track of the minimum sum of\
    \ a sub-array\n        // ending at the current index.\n        // We can use\
    \ a variable to keep track of the minimum sum of a sub-array\n        // ending\
    \ at the current index.\n        // We can use a variable to keep track of the\
    \ minimum sum of a sub-array\n        // ending at the current index.\n      \
    \  // We can use a variable to keep track of the minimum sum of a sub-array\n\
    \        // ending at the current index.\n        // We can use a variable to\
    \ keep track of the minimum sum of a sub-array\n        // ending at the current\
    \ index.\n        // We can use a variable to keep track of the minimum sum of\
    \ a sub-array\n        // ending at the current index.\n        // We can use\
    \ a variable to keep track of the minimum sum of a sub-array\n        // ending\
    \ at the current index.\n        // We can use a variable to keep track of the\
    \ minimum sum of a sub-array\n        // ending at the current index.\n      \
    \  // We can use a variable to keep track of the minimum sum of a sub-array\n\
    \        // ending at the current index.\n        // We can use a variable to\
    \ keep track of the minimum sum of a sub-array\n        // ending at the current\
    \ index.\n        // We can use a variable to keep track of the minimum sum of\
    \ a sub-array\n        // ending at the current index.\n        // We can use\
    \ a variable to keep track of the minimum sum of a sub-array\n        // ending\
    \ at the current index.\n        // We can", "        // Time complexity: O(n)\n\
    \        // Space complexity: O(1)\n        var minSum = Long.MaxValue\n     \
    \   var currentSum = 0l\n        for (num <- nums) {\n            currentSum +=\
    \ num\n            if (currentSum < minSum) minSum = currentSum\n            if\
    \ (currentSum > 0) currentSum = 0\n        }\n        minSum", "        // Fill\
    \ this in.\n        val n = nums.length\n        var minSum = nums(0)\n      \
    \  var sum = nums(0)\n        for (i <- 1 until n) {\n            sum = min(sum\
    \ + nums(i), nums(i))\n            minSum = min(minSum, sum)\n        }\n    \
    \    minSum", "        // We can use Kadane's algorithm to solve this problem.\n\
    \        // The idea is that we keep track of the current sum and the minimum\
    \ sum so far.\n        // If the current sum is less than the minimum sum so far,\
    \ we update the minimum sum\n        // so far.\n        // We also keep track\
    \ of the minimum sum so far.\n        // If the current sum is less than the minimum\
    \ sum so far, we update the minimum sum\n        // so far.\n        // If the\
    \ current sum is greater than the minimum sum so far, we reset the current sum\n\
    \        // to 0.\n        // We also keep track of the minimum sum so far.\n\
    \        // If the current sum is less than the minimum sum so far, we update\
    \ the minimum sum\n        // so far.\n        // If the current sum is greater\
    \ than the minimum sum so far, we reset the current sum\n        // to 0.\n  \
    \      // We also keep track of the minimum sum so far.\n        // If the current\
    \ sum is less than the minimum sum so far, we update the minimum sum\n       \
    \ // so far.\n        // If the current sum is greater than the minimum sum so\
    \ far, we reset the current sum\n        // to 0.\n        // We also keep track\
    \ of the minimum sum so far.\n        // If the current sum is less than the minimum\
    \ sum so far, we update the minimum sum\n        // so far.\n        // If the\
    \ current sum is greater than the minimum sum so far, we reset the current sum\n\
    \        // to 0.\n        // We also keep track of the minimum sum so far.\n\
    \        // If the current sum is less than the minimum sum so far, we update\
    \ the minimum sum\n        // so far.\n        // If the current sum is greater\
    \ than the minimum sum so far, we reset the current sum\n        // to 0.\n  \
    \      // We also keep track of the minimum sum so far.\n        // If the current\
    \ sum is less than the minimum sum so far, we update the minimum sum\n       \
    \ // so far.\n        // If the current sum is greater than the minimum sum so\
    \ far, we reset the current sum\n        // to 0.\n        // We also keep track\
    \ of the minimum sum so far.\n        // If the current sum is less than the minimum\
    \ sum so far, we update the minimum sum\n        // so far.", "        // Fill\
    \ this in.\n        var min = Long.MaxValue\n        var sum = 0l\n        for\
    \ (i <- nums) {\n            sum += i\n            if (sum < min) min = sum\n\
    \            if (sum > 0) sum = 0\n        }\n        min", "        // We can\
    \ use Kadane's algorithm to solve this problem.\n        // The idea is to keep\
    \ track of the maximum sum of a sub-array ending at each index.\n        // The\
    \ maximum sum of a sub-array ending at index i is either the maximum sum of a\n\
    \        // sub-array ending at index i - 1 plus the value at index i, or the\
    \ value at index i.\n        // We can then find the minimum of these maximum\
    \ sums.\n        // We can use a prefix sum array to solve this problem in O(n)\
    \ time.\n        // The prefix sum array is an array where the value at index\
    \ i is the sum of the\n        // values from index 0 to i.\n        // We can\
    \ then find the minimum sub-array sum by finding the minimum difference\n    \
    \    // between two prefix sums.\n        // The minimum difference between two\
    \ prefix sums is the minimum difference between\n        // two prefix sums ending\
    \ at index i and j where i < j.\n        // We can find the minimum difference\
    \ between two prefix sums ending at index i and j\n        // by keeping track\
    \ of the minimum prefix sum ending at each index.\n        // The minimum prefix\
    \ sum ending at index i is either the minimum prefix sum ending\n        // at\
    \ index i - 1 plus the value at index i, or the value at index i.\n        //\
    \ We can then find the minimum difference between two prefix sums ending at index\
    \ i\n        // and j by subtracting the minimum prefix sum ending at index i\
    \ from the prefix sum\n        // ending at index j.\n        // We can then find\
    \ the minimum sub-array sum by finding the minimum difference\n        // between\
    \ two prefix sums.\n        // The minimum difference between two prefix sums\
    \ is the minimum difference between\n        // two prefix sums ending at index\
    \ i and j where i < j.\n        // We can find the minimum difference between\
    \ two prefix sums ending at index i and j\n        // by keeping track of the\
    \ minimum prefix sum ending at each index.\n        // The minimum prefix sum\
    \ ending at index i is either the minimum prefix sum ending\n        // at index\
    \ i - 1 plus the value at index i, or the value at index i.\n        // We can\
    \ then find the minimum difference between two prefix sums ending at index i\n\
    \        // and j by subtracting the minimum prefix sum ending at index i from\
    \ the prefix sum\n        // ending at index j.\n       ", "        // We can\
    \ use a sliding window to solve this problem.\n        // We will keep track of\
    \ the minimum sum of the sub-array.\n        // We will also keep track of the\
    \ current sum of the sub-array.\n        // We will also keep track of the current\
    \ minimum sum of the sub-array.\n        // We will also keep track of the current\
    \ minimum sum of the sub-array.\n        var minSum = nums(0)\n        var currentSum\
    \ = 0l\n        for (i <- nums.indices) {\n            currentSum += nums(i)\n\
    \            minSum = min(minSum, currentSum)\n            if (currentSum < 0)\
    \ currentSum = 0\n        }\n        minSum", "        var minSum = nums(0)\n\
    \        var sum = 0\n        for (num <- nums) {\n            sum += num\n  \
    \          if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        // We can use the Kadane's algorithm to\
    \ solve this problem.\n        // The idea is to keep track of the minimum sum\
    \ of the sub-array ending at the\n        // current index.\n        // The minimum\
    \ sum of the sub-array ending at the current index is the minimum\n        //\
    \ of the minimum sum of the sub-array ending at the previous index and the\n \
    \       // minimum sum of the sub-array ending at the previous index plus the\
    \ current\n        // element.\n        // The minimum sum of the sub-array ending\
    \ at the first index is the first\n        // element.\n        // The minimum\
    \ sum of the sub-array ending at the second index is the minimum\n        // of\
    \ the first element and the first element plus the second element.\n        //\
    \ The minimum sum of the sub-array ending at the third index is the minimum\n\
    \        // of the minimum sum of the sub-array ending at the second index and\
    \ the\n        // minimum sum of the sub-array ending at the second index plus\
    \ the third\n        // element.\n        // The minimum sum of the sub-array\
    \ ending at the fourth index is the minimum\n        // of the minimum sum of\
    \ the sub-array ending at the third index and the\n        // minimum sum of the\
    \ sub-array ending at the third index plus the fourth\n        // element.\n \
    \       // The minimum sum of the sub-array ending at the fifth index is the minimum\n\
    \        // of the minimum sum of the sub-array ending at the fourth index and\
    \ the\n        // minimum sum of the sub-array ending at the fourth index plus\
    \ the fifth\n        // element.\n        // The minimum sum of the sub-array\
    \ ending at the sixth index is the minimum\n        // of the minimum sum of the\
    \ sub-array ending at the fifth index and the\n        // minimum sum of the sub-array\
    \ ending at the fifth index plus the sixth\n        // element.\n        // The\
    \ minimum sum of the sub-array ending at the last index is the minimum\n     \
    \   // sum of the sub-array.\n        // The minimum sum of the sub-array ending\
    \ at the current index is the minimum\n        // of the minimum sum of the sub-array\
    \ ending at the previous index and the\n        // minimum sum of the sub-array\
    \ ending at the previous index plus the current\n        // element.\n       \
    \ // The minimum sum of the sub-array ending at the first", "        var minSum\
    \ = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n       \
    \     sum += num\n            if (sum < minSum) minSum = sum\n            if (sum\
    \ > 0) sum = 0\n        }\n        minSum", "        // We can use a sliding window\
    \ to solve this problem.\n        // We start with a window of size 1 and move\
    \ the window to the right until\n        // we reach the end of the array.\n \
    \       // At each step, we compute the sum of the elements in the window and\
    \ compare\n        // it to the minimum sum so far.\n        // If the sum is\
    \ less than the minimum sum, we update the minimum sum.\n        // We then move\
    \ the window to the right by one element.\n        // We repeat this process until\
    \ we reach the end of the array.\n        // The minimum sum is the answer.\n\
    \        // Time complexity is O(n) and space complexity is O(1).\n        var\
    \ minSum = nums(0)\n        var sum = 0l\n        for (i <- 0 until nums.length)\
    \ {\n            sum += nums(i)\n            minSum = min(minSum, sum)\n     \
    \       if (sum < 0) sum = 0\n        }\n        minSum", "        var minSum\
    \ = nums(0)\n        var sum = 0l\n        for (num <- nums) {\n            sum\
    \ += num\n            if (sum < minSum) minSum = sum\n            if (sum > 0)\
    \ sum = 0\n        }\n        minSum", "        // We can use the sliding window\
    \ technique to solve this problem.\n        // We will keep a window of size k,\
    \ and keep track of the minimum sum\n        // of the window.\n        // We\
    \ will keep track of the minimum sum of the window by keeping track\n        //\
    \ of the minimum sum of the window so far.\n        // We will keep track of the\
    \ minimum sum of the window so far by keeping\n        // track of the minimum\
    \ sum of the window so far and the current sum of\n        // the window.\n  \
    \      // We will keep track of the minimum sum of the window so far and the\n\
    \        // current sum of the window by keeping track of the minimum sum of the\n\
    \        // window so far and the current sum of the window.\n        // We will\
    \ keep track of the minimum sum of the window so far and the\n        // current\
    \ sum of the window by keeping track of the minimum sum of the\n        // window\
    \ so far and the current sum of the window.\n        // We will keep track of\
    \ the minimum sum of the window so far and the\n        // current sum of the\
    \ window by keeping track of the minimum sum of the\n        // window so far\
    \ and the current sum of the window.\n        // We will keep track of the minimum\
    \ sum of the window so far and the\n        // current sum of the window by keeping\
    \ track of the minimum sum of the\n        // window so far and the current sum\
    \ of the window.\n        // We will keep track of the minimum sum of the window\
    \ so far and the\n        // current sum of the window by keeping track of the\
    \ minimum sum of the\n        // window so far and the current sum of the window.\n\
    \        // We will keep track of the minimum sum of the window so far and the\n\
    \        // current sum of the window by keeping track of the minimum sum of the\n\
    \        // window so far and the current sum of the window.\n        // We will\
    \ keep track of the minimum sum of the window so far and the\n        // current\
    \ sum of the window by keeping track of the minimum sum of the\n        // window\
    \ so far and the current sum of the window.\n        // We will keep track of\
    \ the minimum sum of the window so far and the\n        // current sum of the\
    \ window by keeping track of the minimum sum of the\n        // window so far\
    \ and the current sum of the window.\n        // We will keep track", "      \
    \  // Fill this in.\n        var minSum = Long.MaxValue\n        var sum = 0l\n\
    \        for (num <- nums) {\n            sum += num\n            if (sum < minSum)\
    \ minSum = sum\n            if (sum > 0) sum = 0\n        }\n        minSum",
  "        // Fill this in.\n        var minSum = Long.MaxValue\n        var sum =\
    \ 0l\n        for (i <- nums) {\n            sum += i\n            if (sum < minSum)\
    \ minSum = sum\n            if (sum > 0) sum = 0\n        }\n        minSum",
  "        val n = nums.length\n        var minSum = Long.MaxValue\n        var sum\
    \ = 0l\n        for (i <- 0 until n) {\n            sum += nums(i)\n         \
    \   minSum = min(minSum, sum)\n            if (sum < 0) sum = 0\n        }\n \
    \       minSum", "        // Fill this\n        var minSum = Long.MaxValue\n \
    \       var sum = 0l\n        for (i <- 0 until nums.length) {\n            sum\
    \ += nums(i)\n            minSum = min(minSum, sum)\n            if (sum < 0)\
    \ sum = 0\n        }\n        minSum", "        // Fill this in.\n        var\
    \ min = nums(0)\n        var sum = 0l\n        for (i <- nums) {\n           \
    \ sum += i\n            if (sum < min) min = sum\n            if (sum > 0) sum\
    \ = 0\n        }\n        min", "        // Time - O(n)\n        // Space - O(1)\n\
    \        var minSum = nums(0)\n        var sum = 0l\n        for (i <- nums) {\n\
    \            sum += i\n            if (sum < minSum) minSum = sum\n          \
    \  if (sum > 0) sum = 0\n        }\n        minSum", "        // Time: O(n)\n\
    \        // Space: O(1)\n        var minSum = Long.MaxValue\n        var sum =\
    \ 0l\n        for (num <- nums) {\n            sum += num\n            minSum\
    \ = min(minSum, sum)\n            if (sum > 0) sum = 0\n        }\n        minSum",
  "        // We use Kadane's algorithm to find the maximum sum of a sub-array.\n\
    \        // We then negate the array and find the maximum sum of a sub-array.\n\
    \        // The minimum sum of a sub-array is the negative of the maximum sum\
    \ of a sub-array\n        // of the negated array.\n        // We then return\
    \ the minimum of the minimum sum of a sub-array and 0.\n        // We return 0\
    \ because the minimum sum of a sub-array could be negative.\n        // We want\
    \ to return 0 in this case.\n        def maxSubArraySum(nums : List[Long]) : Long\
    \ = {\n            var maxSum = nums(0)\n            var currentSum = nums(0)\n\
    \            for (i <- 1 until nums.length) {\n                currentSum = max(nums(i),\
    \ currentSum + nums(i))\n                maxSum = max(maxSum, currentSum)\n  \
    \          }\n            maxSum\n        }\n        val negatedNums = nums.map(x\
    \ => -x)\n        val minSum = -maxSubArraySum(negatedNums)\n        min(minSum,\
    \ 0)", "        // We will use Kadane's algorithm.\n        // We will keep track\
    \ of the current minimum sum and the current sum.\n        var minSum = Long.MaxValue\n\
    \        var currSum = 0l\n        for (num <- nums) {\n            currSum +=\
    \ num\n            minSum = min(minSum, currSum)\n            currSum = max(currSum,\
    \ 0l)\n        }\n        return minSum", "        // Fill this in.\n        var\
    \ minSum = nums(0)\n        var sum = nums(0)\n        for (i <- 1 until nums.length)\
    \ {\n            sum = min(sum + nums(i), nums(i))\n            minSum = min(minSum,\
    \ sum)\n        }\n        minSum", "        // Fill this in.\n        var min\
    \ = nums(0)\n        var sum = 0l\n        for (i <- nums) {\n            sum\
    \ += i\n            if (sum < min) min = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        min", "        // We can use a sliding window to solve this\
    \ problem.\n        // We start with a window of size 1 and move it to the right.\n\
    \        // If the sum of the window is less than the current minimum sum,\n \
    \       // we update the minimum sum.\n        // If the sum of the window is\
    \ greater than the current minimum sum,\n        // we move the window to the\
    \ right until the sum of the window is less than\n        // the current minimum\
    \ sum.\n        // We then move the window to the right by 1 and repeat the process.\n\
    \        // We can use a queue to keep track of the window.\n        // We can\
    \ use a variable to keep track of the minimum sum.\n        // We can use a variable\
    \ to keep track of the current sum.\n        // We can use a variable to keep\
    \ track of the current index.\n        // We can use a variable to keep track\
    \ of the current window size.\n        // We can use a variable to keep track\
    \ of the current window start index.\n        // We can use a variable to keep\
    \ track of the current window end index.\n        // We can use a variable to\
    \ keep track of the current minimum window start index.\n        // We can use\
    \ a variable to keep track of the current minimum window end index.\n        //\
    \ We can use a variable to keep track of the current minimum window size.\n  \
    \      // We can use a variable to keep track of the current minimum sum.\n  \
    \      // We can use a variable to keep track of the current minimum window sum.\n\
    \        // We can use a variable to keep track of the current minimum window\
    \ sum.\n        // We can use a variable to keep track of the current minimum\
    \ window sum.\n        // We can use a variable to keep track of the current minimum\
    \ window sum.\n        // We can use a variable to keep track of the current minimum\
    \ window sum.\n        // We can use a variable to keep track of the current minimum\
    \ window sum.\n        // We can use a variable to keep track of the current minimum\
    \ window sum.\n        // We can use a variable to keep track of the current minimum\
    \ window sum.\n        // We can use a variable to keep track of the current minimum\
    \ window sum.\n        // We can use a variable to keep track of the current minimum\
    \ window sum.\n        // We can use a variable to keep track of the current minimum\
    \ window sum.\n        // We can", "        // We can use a sliding window to\
    \ solve this problem.\n        // We will keep track of the minimum sum of the\
    \ sub-array and the current sum.\n        // If the current sum is less than the\
    \ minimum sum, we will update the minimum sum.\n        // If the current sum\
    \ is greater than the minimum sum, we will remove the first element\n        //\
    \ from the sub-array and update the current sum.\n        // We will continue\
    \ this process until the sub-array is empty.\n        // Time Complexity: O(n)\n\
    \        // Space Complexity: O(1)\n        var minSum = Long.MaxValue\n     \
    \   var currentSum = 0l\n        for (num <- nums) {\n            currentSum +=\
    \ num\n            if (currentSum < minSum) minSum = currentSum\n            if\
    \ (currentSum > 0) currentSum = 0\n        }\n        minSum", "        // Fill\
    \ this in.\n        val n = nums.length\n        val dp = Array.fill(n)(0l)\n\
    \        dp(0) = nums(0)\n        for (i <- 1 until n) {\n            dp(i) =\
    \ min(dp(i - 1) + nums(i), nums(i))\n        }\n        dp.min", "        var\
    \ minSum = nums(0)\n        var sum = 0l\n        for (num <- nums) {\n      \
    \      sum += num\n            if (sum < minSum) minSum = sum\n            if\
    \ (sum > 0) sum = 0\n        }\n        minSum", "        // Time complexity:\
    \ O(n)\n        // Space complexity: O(1)\n        var minSum = nums(0)\n    \
    \    var sum = nums(0)\n        for (i <- 1 until nums.length) {\n           \
    \ sum = min(sum + nums(i), nums(i))\n            minSum = min(minSum, sum)\n \
    \       }\n        minSum", "        // Fill this in.\n        val n = nums.length\n\
    \        var minSum = nums(0)\n        var sum = 0l\n        for (i <- 0 until\
    \ n) {\n            sum += nums(i)\n            if (sum < minSum) minSum = sum\n\
    \            if (sum > 0) sum = 0\n        }\n        minSum", "        var min\
    \ = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n       \
    \     sum += num\n            if (sum < min) min = sum\n            if (sum >\
    \ 0) sum = 0\n        }\n        min", "        // Time: O(n)\n        // Space:\
    \ O(1)\n        var minSum = Long.MaxValue\n        var sum = 0l\n        for\
    \ (num <- nums) {\n            sum += num\n            minSum = min(minSum, sum)\n\
    \            if (sum > 0) sum = 0\n        }\n        minSum", "        var minSum\
    \ = Long.MaxValue\n        var sum = 0l\n        for (num <- nums) {\n       \
    \     sum += num\n            if (sum < minSum) minSum = sum\n            if (sum\
    \ > 0) sum = 0\n        }\n        minSum", "        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        var min = Long.MaxValue\n        var sum\
    \ = 0l\n        for (num <- nums) {\n            sum += num\n            if (sum\
    \ < min) min = sum\n            if (sum > 0) sum = 0\n        }\n        min",
  "        var minSum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums)\
    \ {\n            sum += num\n            if (sum < minSum) minSum = sum\n    \
    \        if (sum > 0) sum = 0\n        }\n        minSum", "        // We use\
    \ a sliding window to find the minimum sum of any sub-array.\n        // The sliding\
    \ window is represented by two indices, start and end.\n        // We move the\
    \ end index forward until the sum of the sub-array is less than 0.\n        //\
    \ We then move the start index forward until the sum of the sub-array is greater\
    \ than 0.\n        // We then move the end index forward again until the sum of\
    \ the sub-array is less than 0.\n        // We repeat this process until the end\
    \ index reaches the end of the array.\n        // We then return the minimum sum\
    \ of any sub-array.\n        var start = 0\n        var end = 0\n        var sum\
    \ = 0l\n        var minSum = Long.MaxValue\n        while (end < nums.length)\
    \ {\n            sum += nums(end)\n            while (sum < 0) {\n           \
    \     minSum = min(minSum, sum)\n                sum -= nums(start)\n        \
    \        start += 1\n            }\n            end += 1\n        }\n        minSum",
  "        var minSum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums)\
    \ {\n            sum += num\n            if (sum < minSum) minSum = sum\n    \
    \        if (sum > 0) sum = 0\n        }\n        minSum", "        // Time: O(n)\n\
    \        // Space: O(1)\n        var minSum = nums(0)\n        var sum = nums(0)\n\
    \        for (i <- 1 until nums.length) {\n            sum = min(sum + nums(i),\
    \ nums(i))\n            minSum = min(minSum, sum)\n        }\n        minSum",
  "        var minSum = Long.MaxValue\n        var sum = 0l\n        for (num <- nums)\
    \ {\n            sum += num\n            if (sum < minSum) minSum = sum\n    \
    \        if (sum > 0) sum = 0\n        }\n        minSum", "        // We will\
    \ use the sliding window technique.\n        // We will keep track of the minimum\
    \ sum of the current window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the current window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of the minimum\
    \ sum of the previous window.\n        // We will also keep track of", "     \
    \   // We can use Kadane's algorithm to solve this problem.\n        // The idea\
    \ is to keep track of the maximum sum of a sub-array ending at each\n        //\
    \ index.\n        // We can then use this information to find the minimum sum\
    \ of a sub-array.\n        // The maximum sum of a sub-array ending at each index\
    \ is the maximum of the\n        // maximum sum of a sub-array ending at the previous\
    \ index and the sum of the\n        // current index and the maximum sum of a\
    \ sub-array ending at the previous index.\n        // The minimum sum of a sub-array\
    \ is the minimum of the maximum sum of a sub-array\n        // ending at each\
    \ index.\n        // The maximum sum of a sub-array ending at the first index\
    \ is the first element.\n        // The minimum sum of a sub-array is the minimum\
    \ of the maximum sum of a sub-array\n        // ending at each index.\n      \
    \  // Time Complexity: O(n)\n        // Space Complexity: O(1)\n        var maxEndingHere\
    \ = nums(0)\n        var minSum = nums(0)\n        for (i <- 1 until nums.length)\
    \ {\n            maxEndingHere = max(nums(i), maxEndingHere + nums(i))\n     \
    \       minSum = min(minSum, maxEndingHere)\n        }\n        minSum", "   \
    \     // Fill this in.\n        var minSum = Long.MaxValue\n        var sum =\
    \ 0l\n        for (num <- nums) {\n            sum += num\n            if (sum\
    \ < minSum) minSum = sum\n            if (sum > 0) sum = 0\n        }\n      \
    \  minSum", "        val n = nums.length\n        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (i <- 0 until n) {\n            sum += nums(i)\n\
    \            minSum = min(minSum, sum)\n            if (sum < 0) sum = 0\n   \
    \     }\n        minSum", "        // We can use a sliding window to find the\
    \ minimum sum of any sub-array.\n        // We can use a sliding window to find\
    \ the minimum sum of any sub-array.\n        // We can use a sliding window to\
    \ find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the minimum sum of any sub-array.\n        // We can use a sliding window\
    \ to find the", "        // Fill this in.\n        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        var minSum = Long.MaxValue\n        var\
    \ sum = 0l\n        for (num <- nums) {\n            sum += num\n            if\
    \ (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n        }\n \
    \       minSum", "        // Fill this in.\n        var minSum = nums(0)\n   \
    \     var sum = 0l\n        for (i <- nums) {\n            sum += i\n        \
    \    if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n      \
    \  }\n        minSum", "        // We can use the sliding window technique to\
    \ solve this problem.\n        // We start with a window of size 1, and then expand\
    \ it to size 2, 3, 4, etc.\n        // We keep track of the minimum sum of the\
    \ window.\n        // We also keep track of the current sum of the window.\n \
    \       // We can use a queue to keep track of the current window.\n        //\
    \ We can use a queue to keep track of the current window.\n        // We can use\
    \ a queue to keep track of the current window.\n        // We can use a queue\
    \ to keep track of the current window.\n        // We can use a queue to keep\
    \ track of the current window.\n        // We can use a queue to keep track of\
    \ the current window.\n        // We can use a queue to keep track of the current\
    \ window.\n        // We can use a queue to keep track of the current window.\n\
    \        // We can use a queue to keep track of the current window.\n        //\
    \ We can use a queue to keep track of the current window.\n        // We can use\
    \ a queue to keep track of the current window.\n        // We can use a queue\
    \ to keep track of the current window.\n        // We can use a queue to keep\
    \ track of the current window.\n        // We can use a queue to keep track of\
    \ the current window.\n        // We can use a queue to keep track of the current\
    \ window.\n        // We can use a queue to keep track of the current window.\n\
    \        // We can use a queue to keep track of the current window.\n        //\
    \ We can use a queue to keep track of the current window.\n        // We can use\
    \ a queue to keep track of the current window.\n        // We can use a queue\
    \ to keep track of the current window.\n        // We can use a queue to keep\
    \ track of the current window.\n        // We can use a queue to keep track of\
    \ the current window.\n        // We can use a queue to keep track of the current\
    \ window.\n        // We can use a queue to keep track of the current window.\n\
    \        // We can use a queue to keep track of the current window.\n        //\
    \ We can use a queue to keep track of the current window.\n        // We can use\
    \ a queue to keep track of the current window.\n        // We can use a queue\
    \ to keep", "        // We use Kadane's algorithm to find the minimum sum of any\
    \ sub-array.\n        // We keep track of the minimum sum of any sub-array ending\
    \ at the current index.\n        // If the current sum is less than the minimum\
    \ sum, we update the minimum sum.\n        // If the current sum is less than\
    \ 0, we reset the current sum to 0.\n        // The minimum sum of any sub-array\
    \ is the minimum sum of any sub-array ending at\n        // the current index.\n\
    \        var minSum = Long.MaxValue\n        var currSum = 0l\n        for (num\
    \ <- nums) {\n            currSum += num\n            if (currSum < minSum) minSum\
    \ = currSum\n            if (currSum < 0) currSum = 0\n        }\n        minSum",
  "        // We can use a sliding window to find the minimum sum of any sub-array.\n\
    \        // The minimum sum of any sub-array is the minimum of the sum of the\
    \ current\n        // sub-array and the minimum sum of the previous sub-array.\n\
    \        // Time Complexity: O(n)\n        // Space Complexity: O(1)\n       \
    \ var minSum = nums(0)\n        var sum = 0l\n        for (num <- nums) {\n  \
    \          sum += num\n            minSum = min(minSum, sum)\n            if (sum\
    \ < 0) sum = 0\n        }\n        minSum", "        var minSum = Long.MaxValue\n\
    \        var sum = 0l\n        for (num <- nums) {\n            sum += num\n \
    \           if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        var min = Long.MaxValue\n        var sum\
    \ = 0l\n        for (num <- nums) {\n            sum += num\n            if (sum\
    \ < min) min = sum\n            if (sum > 0) sum = 0\n        }\n        min",
  "        // Fill this in.\n        val n = nums.length\n        var minSum = nums(0)\n\
    \        var sum = 0\n        for (i <- 0 until n) {\n            sum += nums(i)\n\
    \            if (sum < minSum) minSum = sum\n            if (sum > 0) sum = 0\n\
    \        }\n        minSum", "        // Time complexity: O(n)\n        // Space\
    \ complexity: O(1)\n        var minSum = nums(0)\n        var sum = 0l\n     \
    \   for (num <- nums) {\n            sum += num\n            if (sum < minSum)\
    \ minSum = sum\n            if (sum > 0) sum = 0\n        }\n        minSum"]
stop_tokens:
- "\n    }\n"
