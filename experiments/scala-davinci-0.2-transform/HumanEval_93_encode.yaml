name: HumanEval_93_encode
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that takes a message, and encodes in such a \n    // way\
  \ that it swaps case of all letters, replaces all vowels in \n    // the message\
  \ with the letter that appears 2 places ahead of that \n    // vowel in the english\
  \ alphabet. \n    // Assume only letters. \n    // Examples:\n    // >>> encode((\"\
  test\"))\n    // (\"TGST\")\n    // >>> encode((\"This is a message\"))\n    //\
  \ (\"tHKS KS C MGSSCGG\")\n    def encode(message : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
  )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n\
  \    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"This is\
  \ a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw\
  \ WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
completions: ["        var encoded = \"\"\n        for (c <- message) {\n        \
    \    if (c.isUpper) encoded += c.toLower\n            else if (c.isLower) encoded\
    \ += c.toUpper\n            else encoded += c\n        }\n        encoded", " \
    \       val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val result = new StringBuilder\n      \
    \  for (c <- message) {\n            if (vowels.contains(c.toLower)) {\n     \
    \           val index = vowelsMap(c.toLower)\n                val newIndex = (index\
    \ + 2) % vowels.length\n                result.append(vowels(newIndex).toUpper)\n\
    \            } else {\n                val index = alphabetMap(c.toLower)\n  \
    \              val newIndex = (index + 2) % alphabet.length\n                result.append(alphabet(newIndex).toUpper)\n\
    \            }\n        }\n        result.toString", "        var result = \"\"\
    \n        for (c <- message) {\n            if (c.isUpper) result += c.toLower\n\
    \            else if (c.isLower) result += c.toUpper\n            else result\
    \ += c\n        }\n        result = result.replaceAll(\"a\", \"c\")\n        result\
    \ = result.replaceAll(\"e\", \"g\")\n        result = result.replaceAll(\"i\"\
    , \"k\")\n        result = result.replaceAll(\"o\", \"q\")\n        result = result.replaceAll(\"\
    u\", \"w\")\n        result", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map(x", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val result = new StringBuilder\n        for (c <- message) {\n       \
    \     if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                val newChar =\
    \ vowelsMap2(newIndex)\n                result.append(newChar)\n            }\
    \ else if (alphabet.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % 26\n                val newChar\
    \ = alphabetMap2(newIndex)\n                result.append(newChar)\n         \
    \   } else {\n                result.append(c)\n            }\n        }\n   \
    \     result.toString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n \
    \       val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        message.map(c =>\
    \ if (vowels.contains(c.toLower)) alphabet((alphabet.indexOf(c.toLower) + 2) %\
    \ 26) else c).map(c => if (c.isUpper) c.toLower else c.toUpper)", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encoded =\
    \ message.map(c => {\n            if (c.isUpper) {\n                if (vowels.contains(c.toLower))\
    \ {\n                    val index = alphabetMap(c.toLower)\n                \
    \    alphabet((index + 2) % alphabet.length).toUpper\n                } else {\n\
    \                    c.toLower\n                }\n            } else {\n    \
    \            if (vowels.contains(c)) {\n                    val index = alphabetMap(c)\n\
    \                    alphabet((index + 2) % alphabet.length)\n               \
    \ } else {\n                    c.toUpper\n                }\n            }\n\
    \        })\n        encoded", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (c.isUpper) {\n                if (vowelsMap.contains(c.toLower))\
    \ {\n                    val index = vowelsMap(c.toLower)\n                  \
    \  val nextIndex = (index + 2) % vowels.length\n                    vowels(nextIndex).toUpper\n\
    \                } else {\n                    c.toLower\n                }\n\
    \            } else {\n                if (vowelsMap.contains(c)) {\n        \
    \            val index = vowelsMap(c)\n                    val nextIndex = (index\
    \ + 2) % vowels.length\n                    vowels(nextIndex)\n              \
    \  } else {\n                    c.toUpper\n                }\n            }\n\
    \        })\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabetMap2((index\
    \ + 2) % alphabet.length)\n            } else if (c.isUpper) {\n             \
    \   c.toLower\n            } else {\n                c.toUpper\n            }\n\
    \        }\n        message.map(encodeChar)", "        val vowels = Set('a', 'e',\
    \ 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encodeMap = alphabet.zip(alphabet.drop(2)\
    \ ++ alphabet.take(2)).toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ encodeMap(c.toLower) else c)", "        val vowels = List('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x =>\
    \ if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) % 26) else x)\n      \
    \  val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n        message.map(x\
    \ => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper else encodedAlphabetMap(x))",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabet2 = alphabet + alphabet\n \
    \       val result = new StringBuilder\n        for (c <- message) {\n       \
    \     if (vowels.contains(c.toLower)) {\n                result += alphabet2(alphabetMap(c.toLower)\
    \ + 2)\n            } else {\n                result += c.toLower match {\n  \
    \                  case 'a' => 'A'\n                    case 'b' => 'B'\n    \
    \                case 'c' => 'C'\n                    case 'd' => 'D'\n      \
    \              case 'e' => 'E'\n                    case 'f' => 'F'\n        \
    \            case 'g' => 'G'\n                    case 'h' => 'H'\n          \
    \          case 'i' => 'I'\n                    case 'j' => 'J'\n            \
    \        case 'k' => 'K'\n                    case 'l' => 'L'\n              \
    \      case 'm' => 'M'\n                    case 'n' => 'N'\n                \
    \    case 'o' => 'O'\n                    case 'p' => 'P'\n                  \
    \  case 'q' => 'Q'\n                    case 'r' => 'R'\n                    case\
    \ 's' => 'S'\n                    case 't' => 'T'\n                    case 'u'\
    \ => 'U'\n                    case 'v' => 'V'\n                    case 'w' =>\
    \ 'W'\n                    case 'x' => 'X'\n                    case 'y' => 'Y'\n\
    \                    case 'z' => 'Z'\n                }\n            }\n     \
    \   }\n        result.toString", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toUpper\n            } else {\n            \
    \    if (c.isUpper) {\n                    alphabet(alphabetMap(c.toLower)).toUpper\n\
    \                } else {\n                    alphabet(alphabetMap(c)).toLower\n\
    \                }\n            }\n        })\n        encoded", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetSize\
    \ = alphabet.size\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels.contains(c)) {\n                val index = alphabetMap(c)\n       \
    \         val newIndex = (index + 2) % alphabetSize\n                alphabet(newIndex)\n\
    \            } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar).mkString", "   \
    \     val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val messageArray = message.toLowerCase.toCharArray\n\
    \        for (i <- 0 until messageArray.length) {\n            if (vowels.contains(messageArray(i)))\
    \ {\n                messageArray(i) = vowelsMap2((vowelsMap(messageArray(i))\
    \ + 2) % 5)\n            }\n            else if (alphabet.contains(messageArray(i)))\
    \ {\n                messageArray(i) = alphabetMap2((alphabetMap(messageArray(i))\
    \ + 2) % 26)\n            }\n        }\n        messageArray.mkString", "    \
    \    val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val encodedAlphabet = alphabet.map(x => {\n            val index = alphabetMap(x)\n\
    \            if (vowels.contains(x)) {\n                val newIndex = (index\
    \ + 2) % alphabet.length\n                alphabet(newIndex)\n            } else\
    \ {\n                x\n            }\n        })\n        val encodedAlphabetMap\
    \ = encodedAlphabet.zipWithIndex.toMap\n        message.map(x => {\n         \
    \   val index = alphabetMap(x.toLower)\n            val encodedChar = encodedAlphabet(index)\n\
    \            if (x.isUpper) {\n                encodedChar.toUpper\n         \
    \   } else {\n                encodedChar\n            }\n        })", "     \
    \   val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        val lower = c.toLower\n            if (vowels.contains(lower)) {\n  \
    \              val index = vowelsMap(lower)\n                val newIndex = (index\
    \ + 2) % vowels.length\n                vowels(newIndex)\n            } else if\
    \ (alphabet.contains(lower)) {\n                val index = alphabetMap(lower)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex)\n            } else {\n                c\n            }\n\
    \        })\n        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ vowels(nextIndex).toUpper\n            } else {\n                if (c.isUpper)\
    \ alphabet(alphabetMap(c.toLower) + 1).toUpper\n                else alphabet(alphabetMap(c)\
    \ + 1)\n            }\n        })\n        encoded", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetSize = alphabet.size\n\
    \        message.map(c => {\n            if (vowels.contains(c.toLower)) {\n \
    \               val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabetSize\n                alphabet(newIndex)\n         \
    \   } else {\n                c\n            }\n        }).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        var result = \"\"\n        for\
    \ (c <- message) {\n            if (c.isUpper) {\n                result += c.toLower\n\
    \            } else if (c.isLower) {\n                result += c.toUpper\n  \
    \          } else {\n                result += c\n            }\n        }\n \
    \       result"]
stop_tokens:
- "\n    }\n"
