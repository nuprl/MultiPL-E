name: HumanEval_93_encode
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Write a function that takes a message, and encodes in such a \n    // way\
  \ that it swaps case of all letters, replaces all vowels in \n    // the message\
  \ with the letter that appears 2 places ahead of that \n    // vowel in the english\
  \ alphabet. \n    // Assume only letters. \n    // Examples:\n    // >>> encode((\"\
  test\"))\n    // (\"TGST\")\n    // >>> encode((\"This is a message\"))\n    //\
  \ (\"tHKS KS C MGSSCGG\")\n    def encode(message : String) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
  )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n\
  \    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"This is\
  \ a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw\
  \ WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
completions: ["        var encoded = \"\"\n        for (c <- message) {\n        \
    \    if (c.isUpper) encoded += c.toLower\n            else if (c.isLower) encoded\
    \ += c.toUpper\n            else encoded += c\n        }\n        encoded", " \
    \       val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val result = new StringBuilder\n      \
    \  for (c <- message) {\n            if (vowels.contains(c.toLower)) {\n     \
    \           val index = vowelsMap(c.toLower)\n                val newIndex = (index\
    \ + 2) % vowels.length\n                result.append(vowels(newIndex).toUpper)\n\
    \            } else {\n                val index = alphabetMap(c.toLower)\n  \
    \              val newIndex = (index + 2) % alphabet.length\n                result.append(alphabet(newIndex).toUpper)\n\
    \            }\n        }\n        result.toString", "        var result = \"\"\
    \n        for (c <- message) {\n            if (c.isUpper) result += c.toLower\n\
    \            else if (c.isLower) result += c.toUpper\n            else result\
    \ += c\n        }\n        result = result.replaceAll(\"a\", \"c\")\n        result\
    \ = result.replaceAll(\"e\", \"g\")\n        result = result.replaceAll(\"i\"\
    , \"k\")\n        result = result.replaceAll(\"o\", \"q\")\n        result = result.replaceAll(\"\
    u\", \"w\")\n        result", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map(x", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val result = new StringBuilder\n        for (c <- message) {\n       \
    \     if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                val newChar =\
    \ vowelsMap2(newIndex)\n                result.append(newChar)\n            }\
    \ else if (alphabet.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % 26\n                val newChar\
    \ = alphabetMap2(newIndex)\n                result.append(newChar)\n         \
    \   } else {\n                result.append(c)\n            }\n        }\n   \
    \     result.toString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n \
    \       val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        message.map(c =>\
    \ if (vowels.contains(c.toLower)) alphabet((alphabet.indexOf(c.toLower) + 2) %\
    \ 26) else c).map(c => if (c.isUpper) c.toLower else c.toUpper)", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encoded =\
    \ message.map(c => {\n            if (c.isUpper) {\n                if (vowels.contains(c.toLower))\
    \ {\n                    val index = alphabetMap(c.toLower)\n                \
    \    alphabet((index + 2) % alphabet.length).toUpper\n                } else {\n\
    \                    c.toLower\n                }\n            } else {\n    \
    \            if (vowels.contains(c)) {\n                    val index = alphabetMap(c)\n\
    \                    alphabet((index + 2) % alphabet.length)\n               \
    \ } else {\n                    c.toUpper\n                }\n            }\n\
    \        })\n        encoded", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (c.isUpper) {\n                if (vowelsMap.contains(c.toLower))\
    \ {\n                    val index = vowelsMap(c.toLower)\n                  \
    \  val nextIndex = (index + 2) % vowels.length\n                    vowels(nextIndex).toUpper\n\
    \                } else {\n                    c.toLower\n                }\n\
    \            } else {\n                if (vowelsMap.contains(c)) {\n        \
    \            val index = vowelsMap(c)\n                    val nextIndex = (index\
    \ + 2) % vowels.length\n                    vowels(nextIndex)\n              \
    \  } else {\n                    c.toUpper\n                }\n            }\n\
    \        })\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabetMap2((index\
    \ + 2) % alphabet.length)\n            } else if (c.isUpper) {\n             \
    \   c.toLower\n            } else {\n                c.toUpper\n            }\n\
    \        }\n        message.map(encodeChar)", "        val vowels = Set('a', 'e',\
    \ 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encodeMap = alphabet.zip(alphabet.drop(2)\
    \ ++ alphabet.take(2)).toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ encodeMap(c.toLower) else c)", "        val vowels = List('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x =>\
    \ if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) % 26) else x)\n      \
    \  val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n        message.map(x\
    \ => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper else encodedAlphabetMap(x))",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabet2 = alphabet + alphabet\n \
    \       val result = new StringBuilder\n        for (c <- message) {\n       \
    \     if (vowels.contains(c.toLower)) {\n                result += alphabet2(alphabetMap(c.toLower)\
    \ + 2)\n            } else {\n                result += c.toLower match {\n  \
    \                  case 'a' => 'A'\n                    case 'b' => 'B'\n    \
    \                case 'c' => 'C'\n                    case 'd' => 'D'\n      \
    \              case 'e' => 'E'\n                    case 'f' => 'F'\n        \
    \            case 'g' => 'G'\n                    case 'h' => 'H'\n          \
    \          case 'i' => 'I'\n                    case 'j' => 'J'\n            \
    \        case 'k' => 'K'\n                    case 'l' => 'L'\n              \
    \      case 'm' => 'M'\n                    case 'n' => 'N'\n                \
    \    case 'o' => 'O'\n                    case 'p' => 'P'\n                  \
    \  case 'q' => 'Q'\n                    case 'r' => 'R'\n                    case\
    \ 's' => 'S'\n                    case 't' => 'T'\n                    case 'u'\
    \ => 'U'\n                    case 'v' => 'V'\n                    case 'w' =>\
    \ 'W'\n                    case 'x' => 'X'\n                    case 'y' => 'Y'\n\
    \                    case 'z' => 'Z'\n                }\n            }\n     \
    \   }\n        result.toString", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toUpper\n            } else {\n            \
    \    if (c.isUpper) {\n                    alphabet(alphabetMap(c.toLower)).toUpper\n\
    \                } else {\n                    alphabet(alphabetMap(c)).toLower\n\
    \                }\n            }\n        })\n        encoded", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetSize\
    \ = alphabet.size\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels.contains(c)) {\n                val index = alphabetMap(c)\n       \
    \         val newIndex = (index + 2) % alphabetSize\n                alphabet(newIndex)\n\
    \            } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar).mkString", "   \
    \     val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x =>\
    \ (x._2, x._1)).toMap\n        val messageArray = message.toLowerCase.toCharArray\n\
    \        for (i <- 0 until messageArray.length) {\n            if (vowels.contains(messageArray(i)))\
    \ {\n                messageArray(i) = vowelsMap2((vowelsMap(messageArray(i))\
    \ + 2) % 5)\n            }\n            else if (alphabet.contains(messageArray(i)))\
    \ {\n                messageArray(i) = alphabetMap2((alphabetMap(messageArray(i))\
    \ + 2) % 26)\n            }\n        }\n        messageArray.mkString", "    \
    \    val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val encodedAlphabet = alphabet.map(x => {\n            val index = alphabetMap(x)\n\
    \            if (vowels.contains(x)) {\n                val newIndex = (index\
    \ + 2) % alphabet.length\n                alphabet(newIndex)\n            } else\
    \ {\n                x\n            }\n        })\n        val encodedAlphabetMap\
    \ = encodedAlphabet.zipWithIndex.toMap\n        message.map(x => {\n         \
    \   val index = alphabetMap(x.toLower)\n            val encodedChar = encodedAlphabet(index)\n\
    \            if (x.isUpper) {\n                encodedChar.toUpper\n         \
    \   } else {\n                encodedChar\n            }\n        })", "     \
    \   val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        val lower = c.toLower\n            if (vowels.contains(lower)) {\n  \
    \              val index = vowelsMap(lower)\n                val newIndex = (index\
    \ + 2) % vowels.length\n                vowels(newIndex)\n            } else if\
    \ (alphabet.contains(lower)) {\n                val index = alphabetMap(lower)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex)\n            } else {\n                c\n            }\n\
    \        })\n        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ vowels(nextIndex).toUpper\n            } else {\n                if (c.isUpper)\
    \ alphabet(alphabetMap(c.toLower) + 1).toUpper\n                else alphabet(alphabetMap(c)\
    \ + 1)\n            }\n        })\n        encoded", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetSize = alphabet.size\n\
    \        message.map(c => {\n            if (vowels.contains(c.toLower)) {\n \
    \               val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabetSize\n                alphabet(newIndex)\n         \
    \   } else {\n                c\n            }\n        }).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        var result = \"\"\n        for\
    \ (c <- message) {\n            if (c.isUpper) {\n                result += c.toLower\n\
    \            } else if (c.isLower) {\n                result += c.toUpper\n  \
    \          } else {\n                result += c\n            }\n        }\n \
    \       result", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = 'a' to 'z'\n        message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ alphabet((index + 2) % alphabet.size)\n            } else {\n              \
    \  c\n            }\n        }).mkString", "        val vowels = Set('a', 'e',\
    \ 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    \
    \    val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 =\
    \ alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "        val\
    \ vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encoded =\
    \ for (c <- message) yield {\n            if (vowels.contains(c.toLower)) {\n\
    \                val index = alphabetMap(c.toLower)\n                val nextIndex\
    \ = if (index + 2 > alphabet.length - 1) (index + 2) % alphabet.length else index\
    \ + 2\n                alphabet(nextIndex).toString\n            } else {\n  \
    \              c.toString\n            }\n        }\n        encoded.mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex)\n      \
    \      } else {\n                c\n            }\n        })\n        encoded.mkString",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else {\n                if (c.isUpper) alphabet(alphabetMap(c.toLower)).toUpper\n\
    \                else alphabet(alphabetMap(c))\n            }\n        })\n  \
    \      encoded", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toUpper\n            } else {\n          \
    \      c\n            }\n        })\n        encoded", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toUpper\n            } else {\n          \
    \      c\n            }\n        })\n        encoded", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        def\
    \ encodeChar(c : Char) : Char = {\n            if (vowels.contains(c)) {\n   \
    \             val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap5\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap10\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap11\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap13\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap14\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap15\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap17\
    \ = alphabet.zipWithIndex.map(x", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 ->\
    \ x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = if (index + 2 > 4) (index + 2) % 5 else index\
    \ + 2\n                vowels(newIndex).toUpper\n            } else {\n      \
    \          if (c.isUpper) alphabet(alphabetMap(c.toLower)).toUpper else alphabet(alphabetMap(c))\n\
    \            }\n        })\n        encoded", "        val vowels = Set('a', 'e',\
    \ 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val encoded\
    \ = message.map(c => {\n            if (vowels.contains(c.toLower)) {\n      \
    \          val index = alphabet.indexOf(c.toLower)\n                val newIndex\
    \ = if (index + 2 < alphabet.length) index + 2 else index + 2 - alphabet.length\n\
    \                alphabet(newIndex).toString\n            } else {\n         \
    \       c.toString\n            }\n        })\n        encoded.mkString", "  \
    \      val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encoded = message.map(c => {\n            if (c.isUpper) {\n        \
    \        c.toLower\n            } else if (vowels.contains(c)) {\n           \
    \     val index = alphabetMap(c)\n                alphabet((index + 2) % alphabet.length)\n\
    \            } else {\n                c\n            }\n        })\n        encoded.map(c\
    \ => {\n            if (c.isUpper) {\n                c.toLower\n            }\
    \ else if (vowels.contains(c)) {\n                val index = alphabetMap(c)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        }).mkString", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedMessage\
    \ = message.map(c => {\n            val cLower = c.toLower\n            if (vowels.contains(cLower))\
    \ {\n                val index = alphabetMap(cLower)\n                alphabet(if\
    \ (index + 2 > 25) index + 2 - 26 else index + 2)\n            } else {\n    \
    \            c\n            }\n        })\n        encodedMessage.toUpperCase",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        message.map(c => if (vowels.contains(c.toLower)) alphabet((alphabet.indexOf(c.toLower)\
    \ + 2) % 26) else c).map(c => if (c.isUpper) c.toLower else c.toUpper)", "   \
    \     val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val next = (index + 2) % vowels.length\n                vowels(next).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n      \
    \  val alphabet = ('a' to 'z').toList\n        message.map(c => if (vowels.contains(c.toLower))\
    \ alphabet((alphabet.indexOf(c.toLower) + 2) % 26) else c).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val map = Map[Char, Char]()\n        for (i <- 0 until alphabet.length)\
    \ {\n            val c = alphabet(i)\n            val c2 = if (i + 2 >= alphabet.length)\
    \ alphabet(i + 2 - alphabet.length) else alphabet(i + 2)\n            map += (c\
    \ -> c2)\n        }\n        var result = \"\"\n        for (c <- message) {\n\
    \            if (vowels.contains(c)) result += map(c)\n            else result\
    \ += c\n        }\n        result", "        var encoded = \"\"\n        for (c\
    \ <- message) {\n            if (c.isUpper) {\n                encoded += c.toLower\n\
    \            } else if (c.isLower) {\n                encoded += c.toUpper\n \
    \           } else {\n                encoded += c\n            }\n        }\n\
    \        encoded.map(c => {\n            if (c == 'a') 'c'\n            else if\
    \ (c == 'e') 'g'\n            else if (c == 'i') 'k'\n            else if (c ==\
    \ 'o') 'q'\n            else if (c == 'u') 'y'\n            else c\n        })",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val encodeMap = alphabet.zip(alphabet.drop(2) ::: alphabet.take(2)).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) encodeMap(c.toLower)\
    \ else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "     \
    \   val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else {\n                if (c.isUpper) alphabet(alphabetMap(c.toLower)).toUpper\n\
    \                else alphabet(alphabetMap(c))\n            }\n        })\n  \
    \      encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex)\n      \
    \      } else {\n                c\n            }\n        })\n        encoded.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n \
    \       val alphabetMap = alphabet.zipWithIndex.toMap\n        message.map(c =>\
    \ {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex)\n            } else {\n                c\n\
    \            }\n        }).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map { case (c, i) => (c, (i + 2)\
    \ % alphabet.length) }.toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ alphabet(alphabetMap2(c.toLower)) else c).map(c => if (c.isUpper) c.toLower\
    \ else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMapReverse = alphabetMap.map(_.swap)\n        val messageList\
    \ = message.toList\n        val encodedList = messageList.map(x => {\n       \
    \     if (vowels.contains(x)) {\n                val index = alphabetMap(x)\n\
    \                alphabetMapReverse(index + 2)\n            } else {\n       \
    \         x\n            }\n        })\n        encodedList.mkString", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        var result = \"\"\n        for (c <- message)\
    \ {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = alphabet.indexOf(c.toLower)\n                val newIndex = (index + 2) %\
    \ alphabet.length\n                result += alphabet(newIndex).toUpper\n    \
    \        } else {\n                result += c.toUpper\n            }\n      \
    \  }\n        result", "        var result = \"\"\n        for (c <- message)\
    \ {\n            if (c.isLetter) {\n                if (c.isUpper) {\n       \
    \             result += c.toLower\n                } else {\n                \
    \    result += c.toUpper\n                }\n            } else {\n          \
    \      result += c\n            }\n        }\n        result", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val message2 = message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2((alphabetMap(x.toLower) + 2) % 26) else x)\n        message2.map(x\
    \ => if (x.isUpper) x.toLower else x.toUpper).mkString", "        val vowels =\
    \ List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.map(x => {\n            val index = alphabetMap(x)\n            if\
    \ (vowels.contains(x)) {\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex)\n            } else {\n                x\n\
    \            }\n        })\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => {\n            val encodedChar = encodedAlphabetMap(x.toLower)\n\
    \            if (x.isUpper) {\n                encodedChar.toUpper\n         \
    \   } else {\n                encodedChar\n            }\n        })", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c)) {\n\
    \                val index = alphabetMap(c)\n                alphabet((index +\
    \ 2) % alphabet.length)\n            } else {\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.map(x => {\n            if (vowels.contains(x)) {\n             \
    \   if (x == 'u') 'a'\n                else alphabet(alphabetMap(x) + 2)\n   \
    \         }\n            else x\n        })\n        val encodedAlphabetMap =\
    \ encodedAlphabet.zipWithIndex.toMap\n        message.map(x => {\n           \
    \ if (x.isUpper) {\n                encodedAlphabet(encodedAlphabetMap(x.toLower)).toUpper\n\
    \            }\n            else encodedAlphabet(encodedAlphabetMap(x))\n    \
    \    })", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toArray\n        message.map(c => if (vowels.contains(c.toLower))\
    \ alphabet((alphabet.indexOf(c.toLower) + 2) % alphabet.length) else c)", "  \
    \      val vowels = \"aeiou\".toList\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    .toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encodedVowels = vowels.map(v => alphabet((alphabetMap(v)\
    \ + 2) % alphabet.length))\n        val encodedVowelsMap = vowels.zip(encodedVowels).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) encodedVowelsMap(c.toLower)\
    \ else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val encoded = message.map(c => if (vowels.contains(c.toLower)) {\n         \
    \   val index = alphabetMap(c.toLower)\n            val newIndex = (index + 2)\
    \ % alphabet.length\n            alphabet(newIndex)\n        } else if (c.isUpper)\
    \ {\n            c.toLower\n        } else {\n            c.toUpper\n        })\n\
    \        encoded.mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encodedMessage\
    \ = new StringBuilder\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                encodedMessage.append(vowels(newIndex).toUpper)\n\
    \            } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                encodedMessage.append(alphabet(newIndex).toUpper)\n         \
    \   } else {\n                encodedMessage.append(c)\n            }\n      \
    \  }\n        encodedMessage.toString", "        val vowels = \"aeiou\"\n    \
    \    val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetArray = alphabet.toArray\n        val vowelsArray = vowels.toArray\n\
    \        val messageArray = message.toArray\n        for (i <- 0 until messageArray.length)\
    \ {\n            if (vowelsMap.contains(messageArray(i))) {\n                val\
    \ index = vowelsMap(messageArray(i))\n                messageArray(i) = vowelsArray((index\
    \ + 2) % vowelsArray.length)\n            } else if (alphabetMap.contains(messageArray(i)))\
    \ {\n                val index = alphabetMap(messageArray(i))\n              \
    \  messageArray(i) = alphabetArray((index + 2) % alphabetArray.length)\n     \
    \       }\n        }\n        messageArray.mkString", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else {\n                if (c.isUpper) c.toLower else c.toUpper\n\
    \            }\n        })\n        encoded", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = if (index + 2 >= vowels.length) (index + 2) % vowels.length else index + 2\n\
    \                vowels(newIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = if (index + 2 >= alphabet.length) (index + 2) % alphabet.length else index\
    \ + 2\n                alphabet(newIndex).toUpper\n            } else {\n    \
    \            c\n            }\n        })\n        encoded", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = List('a', 'e', 'i', 'o', 'u')\n        message.map(c => if (vowels.contains(c.toLower))\
    \ (c + 2).toChar else c)", "        var encoded = \"\"\n        for (c <- message)\
    \ {\n            if (c.isUpper) {\n                encoded += c.toLower\n    \
    \        } else if (c.isLower) {\n                encoded += c.toUpper\n     \
    \       } else {\n                encoded += c\n            }\n        }\n   \
    \     encoded.map(c => {\n            if (c == 'a') {\n                'c'\n \
    \           } else if (c == 'e') {\n                'g'\n            } else if\
    \ (c == 'i') {\n                'k'\n            } else if (c == 'o') {\n    \
    \            'q'\n            } else if (c == 'u') {\n                'w'\n  \
    \          } else {\n                c\n            }\n        })", "        val\
    \ vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ vowels(nextIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(nextIndex).toUpper\n\
    \            } else {\n                c\n            }\n        })\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val newAlphabet\
    \ = alphabet.substring(2) + alphabet.substring(0, 2)\n        val newAlphabetMap\
    \ = newAlphabet.zipWithIndex.toMap\n        message.map(c => if (vowels.contains(c))\
    \ newAlphabetMap(c) else alphabetMap(c)).map(c => if (c < 26) c + 65 else c +\
    \ 71).map(c => c.toChar).mkString", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x)", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap10 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap11 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap12 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap13 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap14 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap15 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap16 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap17 = alphabet.zipWithIndex.map",
  "        // TODO: Implement me\n        return \"\"", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.drop(2) + alphabet.take(2)\n        val encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n\
    \        val encodedMessage = message.map(c => if (vowels.contains(c.toLower))\
    \ encodedAlphabet(alphabetMap(c.toLower)) else c)\n        encodedMessage.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val vowels =\
    \ List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.map(x => {\n            if (vowels.contains(x)) {\n             \
    \   val index = alphabetMap(x)\n                alphabet((index + 2) % alphabet.length)\n\
    \            } else x\n        })\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => {\n            if (x.isUpper) {\n                encodedAlphabetMap(x.toLower).toUpper\n\
    \            } else {\n                encodedAlphabetMap(x)\n            }\n\
    \        })", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val encoded = message.map(c => if (vowels.contains(c.toLower)) alphabet((alphabet.indexOf(c.toLower)\
    \ + 2) % 26) else c)\n        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        var result = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ result += alphabet((index + 2) % 26)\n            } else {\n               \
    \ result += c\n            }\n        }\n        result", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        def encodeChar(c : Char) : Char = {\n\
    \            if (vowels.contains(c)) {\n                val next = c + 2\n   \
    \             if (next > 'z') {\n                    ('a' + (next - 'z') - 1).toChar\n\
    \                } else {\n                    next\n                }\n     \
    \       } else {\n                c\n            }\n        }\n        message.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar).mkString", "   \
    \     val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = Map() ++ alphabet.zipWithIndex\n        val vowelsMap\
    \ = Map() ++ vowels.zipWithIndex\n        val encoded = message.map(c => {\n \
    \           if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n\
    \            } else {\n                val index = alphabetMap(c.toLower)\n  \
    \              val newIndex = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            }\n        })\n        encoded", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val vowelsMap2 = vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val result = new StringBuilder\n        for (c <- message) {\n       \
    \     if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = (index + 2) % 5\n                val newChar =\
    \ vowelsMap2(newIndex)\n                result.append(newChar)\n            }\
    \ else if (alphabet.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % 26\n                val newChar\
    \ = alphabetMap2(newIndex)\n                result.append(newChar)\n         \
    \   } else {\n                result.append(c)\n            }\n        }\n   \
    \     result.toString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n \
    \       val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c)) {\n                val index = vowelsMap(c)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ vowels(nextIndex)\n            } else {\n                val index = alphabetMap(c)\n\
    \                val nextIndex = (index + 2) % alphabet.length\n             \
    \   alphabet(nextIndex)\n            }\n        })\n        encoded", "      \
    \  val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val encoded =\
    \ message.map(x => if (vowels.contains(x)) alphabetMap2((alphabetMap(x) + 2) %\
    \ alphabet.length) else x)\n        encoded.map(x => if (x.isUpper) x.toLower\
    \ else x.toUpper).mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toUpper\n            } else {\n            \
    \    if (c.isUpper) alphabet(alphabetMap(c.toLower) + 1).toUpper\n           \
    \     else alphabet(alphabetMap(c) + 1)\n            }\n        })\n        encoded",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetIndex = alphabet.zipWithIndex.toMap\n\
    \        val vowelsIndex = vowels.zipWithIndex.toMap\n        val encoded = message.map(x\
    \ => {\n            if (vowels.contains(x.toLower)) {\n                val index\
    \ = vowelsIndex(x.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toUpper\n            } else {\n            \
    \    x.toUpper\n            }\n        })\n        encoded", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toArray\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encoded =\
    \ message.map(c => {\n            if (vowels.contains(c.toLower)) {\n        \
    \        val index = alphabetMap(c.toLower)\n                val newIndex = (index\
    \ + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n       \
    \     } else {\n                c.toUpper\n            }\n        })\n       \
    \ encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val messageList = message.toLowerCase.toList\n        val encodedList\
    \ = messageList.map(x => if (vowels.contains(x)) alphabetMap2((alphabetMap(x)\
    \ + 2) % 26) else x)\n        encodedList.map(x => if (x.isUpper) x.toLower else\
    \ x.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n \
    \       val alphabet = 'a' to 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val message2 = message.map(x => if (vowels.contains(x.toLower)) alphabetMap2((alphabetMap(x.toLower)\
    \ + 2) % 26) else x)\n        message2.map(x => if (x.isUpper) x.toLower else\
    \ x.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n \
    \       val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                alphabetMap2((index\
    \ + 2) % alphabet.length)\n            } else {\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n            }\n        }\n        message.map(encodeChar)",
  "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val map = HashMap[Char, Char]()\n        for (i <- 0 until vowels.length)\
    \ {\n            map += vowels(i) -> vowels((i + 2) % vowels.length)\n       \
    \ }\n        message.map(x => if (vowels.contains(x.toLower)) map(x.toLower) else\
    \ x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "        val\
    \ vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = if (index + 2 >= vowels.length) (index + 2) %\
    \ vowels.length else index + 2\n                vowels(newIndex).toUpper\n   \
    \         } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = if (index + 2 >= alphabet.length)\
    \ (index + 2) % alphabet.length else index + 2\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c\n            }\n        })\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n \
    \       def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) c.toLower else c.toUpper).map(encodeChar).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val map = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' ->\
    \ 's')\n        message.map(c => if (vowels.contains(c.toLower)) map(c.toLower)\
    \ else c).map(c => if (c.isUpper) c.toLower else c.toUpper)", "        val vowels\
    \ = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n       \
    \ val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            val index = alphabetMap(c.toLower)\n\
    \            if (vowels.contains(c.toLower)) {\n                val vowelIndex\
    \ = vowelsMap(c.toLower)\n                val newVowelIndex = (vowelIndex + 2)\
    \ % vowels.length\n                val newVowel = vowels(newVowelIndex)\n    \
    \            if (c.isUpper) newVowel.toUpper else newVowel\n            } else\
    \ if (c.isUpper) alphabet(index).toUpper else alphabet(index)\n        })\n  \
    \      encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encodeMap = alphabet.zip(alphabet.drop(2) ++ alphabet.take(2)).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) encodeMap(c.toLower)\
    \ else c)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 =", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 ->\
    \ x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        var result = \"\"\n        for (c <- message) {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                result +=\
    \ alphabet((index + 2) % alphabet.length)\n            } else if (alphabet.contains(c))\
    \ {\n                val index = alphabet.indexOf(c)\n                result +=\
    \ alphabet((index + alphabet.length / 2) % alphabet.length)\n            } else\
    \ {\n                result += c\n            }\n        }\n        result", " \
    \       val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val encoded = message.toLowerCase.map(c => if (vowels.contains(c))\
    \ alphabet((alphabet.indexOf(c) + 2) % alphabet.length) else c)\n        encoded.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n \
    \       val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMapInv\
    \ = alphabetMap.map(_.swap)\n        val alphabetMapInv2 = alphabetMapInv.map(x\
    \ => (x._1 + 2, x._2))\n        val alphabetMap2 = alphabetMapInv2.map(_.swap)\n\
    \        def encodeChar(c : Char) : Char = {\n            if (c.isUpper) {\n \
    \               alphabetMap2(c.toLower).toUpper\n            } else if (vowels.contains(c))\
    \ {\n                alphabetMap2(c)\n            } else {\n                c\n\
    \            }\n        }\n        message.map(encodeChar)", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap5\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap10\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap11\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap13\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap14\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap15\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap17\
    \ = alphabet.zipWithIndex.map", "        var result = \"\"\n        for (c <-\
    \ message) {\n            if (c.isUpper) {\n                result += c.toLower\n\
    \            } else if (c.isLower) {\n                result += c.toUpper\n  \
    \          } else {\n                result += c\n            }\n        }\n \
    \       result", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encoded =\
    \ message.map(c => {\n            val upper = c.isUpper\n            val lower\
    \ = c.toLower\n            if (vowels.contains(lower)) {\n                val\
    \ index = alphabetMap(lower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                val newChar = alphabet(newIndex)\n                if (upper)\
    \ newChar.toUpper else newChar\n            } else {\n                if (upper)\
    \ lower.toUpper else lower\n            }\n        })\n        encoded", "   \
    \     val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ val nextVowel = vowels(nextIndex)\n                if (c.isUpper) nextVowel.toUpper\
    \ else nextVowel\n            } else if (alphabet.contains(c.toLower)) {\n   \
    \             val index = alphabetMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % alphabet.length\n                val nextLetter = alphabet(nextIndex)\n\
    \                if (c.isUpper) nextLetter.toUpper else nextLetter\n         \
    \   } else c\n        })\n        encoded", "        val vowels = List('a', 'e',\
    \ 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encoded = message.map(c => {\n  \
    \          if (vowels.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex)\n            } else {\n                c\n            }\n\
    \        })\n        encoded.mkString", "        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageList = message.toList\n        val\
    \ encodedMessage = messageList.map(x => {\n            if (vowels.contains(x))\
    \ {\n                alphabetMap2((alphabetMap(x) + 2) % 26)\n            } else\
    \ {\n                x\n            }\n        })\n        encodedMessage.mkString",
  "        val vowels = \"aeiouAEIOU\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2) % alphabet.length -> x._1)\n\
    \        message.map(x => if (vowels.contains(x)) alphabetMap2(alphabetMap(x))\
    \ else x)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.toMap.map(x => (x._2 + 2) %\
    \ 26 -> x._1)\n        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n\
    \        val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        def encodeChar(c\
    \ : Char) : Char = {\n            if (vowels.contains(c)) {\n                val\
    \ index = alphabetMap(c)\n                alphabetMap2((index + 2) % 26)\n   \
    \         } else {\n                c.toUpper\n            }\n        }\n    \
    \    message.map(encodeChar).mkString", "        val vowels = \"aeiou\"\n    \
    \    val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val encoded = for\
    \ (c <- message) yield {\n            if (vowels.contains(c.toLower)) {\n    \
    \            val index = alphabet.indexOf(c.toLower)\n                alphabet((index\
    \ + 2) % alphabet.length)\n            } else {\n                if (c.isUpper)\
    \ c.toLower else c.toUpper\n            }\n        }\n        encoded.mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap6 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap7 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap9 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap10 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap11 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap12 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap13 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap14 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap15 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap16 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap17 = alphabet.zipWithIndex.map", "        val vowels =\
    \ List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val vowelsMap2 = vowels.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val messageList = message.toList\n        val\
    \ result = messageList.map(x => {\n            if (vowels.contains(x)) {\n   \
    \             val index = vowelsMap(x)\n                val newIndex = (index\
    \ + 2) % vowels.length\n                vowelsMap2(newIndex)\n            } else\
    \ {\n                val index = alphabetMap(x)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabetMap2(newIndex)\n  \
    \          }\n        })\n        result.mkString", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val encoded =\
    \ message.map(c => {\n            if (vowels.contains(c.toLower)) {\n        \
    \        val index = alphabet.indexOf(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c.toUpper\n            }\n        })\n\
    \        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n      \
    \  val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetSize = alphabet.size\n        message.map(c => if (vowels.contains(c.toLower))\
    \ alphabet((alphabetMap(c.toLower) + 2) % alphabetSize) else c)", "        val\
    \ vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.map(x => {\n            if (vowels.contains(x)) {\n             \
    \   alphabet((alphabetMap(x) + 2) % alphabet.length)\n            } else {\n \
    \               x\n            }\n        })\n        val alphabetMap2 = encodedAlphabet.zipWithIndex.toMap\n\
    \        val encodedMessage = message.map(x => {\n            if (x.isUpper) {\n\
    \                encodedAlphabet(alphabetMap2(x.toLower)).toUpper\n          \
    \  } else {\n                encodedAlphabet(alphabetMap2(x))\n            }\n\
    \        })\n        encodedMessage", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetSize = alphabet.size\n  \
    \      message.map(c => {\n            if (vowels.contains(c.toLower)) {\n   \
    \             val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = if (index + 2 >= alphabetSize) index + 2 - alphabetSize else index + 2\n \
    \               alphabet(newIndex).toString\n            } else if (c.isUpper)\
    \ {\n                c.toLower.toString\n            } else {\n              \
    \  c.toUpper.toString\n            }\n        }).mkString", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x)", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val newIndex = (index + 2) % alphabet.length\n\
    \                alphabet(newIndex).toUpper\n            } else {\n          \
    \      c\n            }\n        })\n        encoded", "        val vowels = \"\
    aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else {\n                if (c.isUpper) alphabet(alphabetMap(c.toLower)\
    \ + 1).toUpper\n                else alphabet(alphabetMap(c) + 1)\n          \
    \  }\n        })\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x =>\
    \ {\n            if (vowels.contains(x)) {\n                val index = alphabetMap(x)\n\
    \                val nextIndex = (index + 2) % alphabet.length\n             \
    \   alphabet(nextIndex)\n            } else {\n                x\n           \
    \ }\n        })\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => {\n            if (x.isUpper) {\n                encodedAlphabetMap(x.toLower).toUpper\n\
    \            } else {\n                encodedAlphabetMap(x)\n            }\n\
    \        })", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex)\n      \
    \      } else {\n                c\n            }\n        })\n        encoded.map(c\
    \ => if (c.isUpper) c.toLower else c.toUpper).mkString", "        var encoded\
    \ = \"\"\n        for (c <- message) {\n            if (c.isUpper) {\n       \
    \         encoded += c.toLower\n            } else if (c.isLower) {\n        \
    \        encoded += c.toUpper\n            } else {\n                encoded +=\
    \ c\n            }\n        }\n        encoded", "        val vowels = \"aeiou\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex).toUpper\n  \
    \          } else {\n                c.toUpper\n            }\n        })\n  \
    \      encoded", "        val vowels = \"AEIOUaeiou\"\n        val alphabet =\
    \ \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n        val alphabet2\
    \ = \"CDEFGHIJKLMNOPQRSTUVWXYZABcdefghijklmnopqrstuvwxyzab\"\n        val mapping\
    \ = alphabet.zip(alphabet2).toMap\n        message.map(c => if (vowels.contains(c))\
    \ mapping(c) else c)", "        val vowels = \"aeiou\"\n        val alphabet =\
    \ \"abcdefghijklmnopqrstuvwxyz\"\n        val map = alphabet.zipWithIndex.toMap\n\
    \        val map2 = alphabet.zipWithIndex.map(_.swap).toMap\n        val newMessage\
    \ = message.map(c => if (vowels.contains(c.toLower)) map2(map(c.toLower) + 2)\
    \ else c)\n        newMessage.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val map = alphabet.zip(alphabet.drop(2) ++ alphabet.take(2)).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) map(c.toLower) else\
    \ c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val encoded =\
    \ message.map(x => {\n            if (vowels.contains(x.toLower)) {\n        \
    \        val index = alphabetMap(x.toLower)\n                val index2 = (index\
    \ + 2) % 26\n                alphabetMap2(index2).toUpper\n            } else\
    \ {\n                x.toUpper\n            }\n        })\n        encoded", " \
    \       val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ vowels(nextIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(nextIndex).toUpper\n\
    \            } else {\n                c\n            }\n        })\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(x => {\n    \
    \        if (vowels.contains(x.toLower)) {\n                val index = vowelsMap(x.toLower)\n\
    \                val nextIndex = (index + 2) % vowels.length\n               \
    \ vowels(nextIndex).toUpper\n            } else {\n                x.toUpper\n\
    \            }\n        })\n        encoded", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                val newChar = vowels(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            } else\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                val newChar = alphabet(newIndex)\n\
    \                if (c.isUpper) newChar.toUpper else newChar\n            }\n\
    \        })\n        encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % alphabet.length) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) encodedAlphabetMap(x.toLower)\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toArray\n        message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ alphabet((index + 2) % alphabet.length)\n            } else if (c.isUpper) {\n\
    \                c.toLower\n            } else {\n                c.toUpper\n\
    \            }\n        })", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = 'a' to 'z'\n        val map = (alphabet zip alphabet.tail.tail).toMap\n\
    \        message.map(c => if (vowels.contains(c.toLower)) map(c.toLower) else\
    \ c).map(c => if (c.isUpper) c.toLower else c.toUpper)", "        val vowels =\
    \ Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n \
    \       val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap5\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap10\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap11\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap13\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap14\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap15\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap17\
    \ = alphabet.zipWithIndex.map", "        val vowels = \"aeiouAEIOU\"\n       \
    \ val alphabet = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  \
    \      val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % alphabet.length -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x)) alphabetMap2(alphabetMap(x))\
    \ else x)", "        val vowels = Array('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = Array('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',\
    \ 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n    \
    \    val messageArray = message.toCharArray\n        for (i <- 0 until messageArray.length)\
    \ {\n            if (vowels.contains(messageArray(i))) {\n                val\
    \ index = alphabet.indexOf(messageArray(i))\n                messageArray(i) =\
    \ alphabet((index + 2) % alphabet.length)\n            }\n            if (messageArray(i).isUpper)\
    \ messageArray(i) = messageArray(i).toLower\n            else messageArray(i)\
    \ = messageArray(i).toUpper\n        }\n        messageArray.mkString", "    \
    \    val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to\
    \ 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n       \
    \ val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % 26) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x)).mkString", "        val vowels = List('a', 'e',\
    \ 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encoded = message.map(c => {\n  \
    \          if (vowels.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex)\n            } else {\n                c\n            }\n\
    \        })\n        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet\
    \ = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) %\
    \ alphabet.size) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x))", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetArray\
    \ = alphabet.toArray\n        val vowelsArray = vowels.toArray\n        val messageArray\
    \ = message.toArray\n        for (i <- 0 until messageArray.length) {\n      \
    \      if (vowels.contains(messageArray(i))) {\n                val index = (vowelsMap(messageArray(i))\
    \ + 2) % vowelsArray.length\n                messageArray(i) = vowelsArray(index)\n\
    \            } else if (alphabet.contains(messageArray(i))) {\n              \
    \  val index = (alphabetMap(messageArray(i)) + 2) % alphabetArray.length\n   \
    \             messageArray(i) = alphabetArray(index)\n            }\n        }\n\
    \        messageArray.mkString", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x).map(x => if (x.isUpper) x.toLower\
    \ else x.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.tail +\
    \ alphabet.head\n        val encodedAlphabetMap = encodedAlphabet.zipWithIndex.toMap\n\
    \        val encodedAlphabetMap2 = encodedAlphabet.tail + encodedAlphabet.head\n\
    \        val encodedAlphabetMap2Map = encodedAlphabetMap2.zipWithIndex.toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                val index = alphabetMap(c)\n                val index2 =\
    \ (index + 2) % alphabet.length\n                encodedAlphabetMap2Map(index2)\n\
    \            } else {\n                val index = alphabetMap(c)\n          \
    \      val index2 = (index + 2) % alphabet.length\n                encodedAlphabetMap(index2)\n\
    \            }\n        }\n        message.map(c => if (c.isUpper) encodeChar(c.toLower).toUpper\
    \ else encodeChar(c))", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n \
    \       val alphabet = ('a' to 'z').toArray\n        val encodeMap = Map('a' ->\
    \ 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n        val encodeMap2\
    \ = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n        val\
    \ encodeMap3 = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n\
    \        val encodeMap4 = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q',\
    \ 'u' -> 'y')\n        val encodeMap5 = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k',\
    \ 'o' -> 'q', 'u' -> 'y')\n        val encodeMap6 = Map('a' -> 'c', 'e' -> 'g',\
    \ 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n        val encodeMap7 = Map('a' -> 'c',\
    \ 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n        val encodeMap8 = Map('a'\
    \ -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n        val encodeMap9\
    \ = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n        val\
    \ encodeMap10 = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'y')\n\
    \        val encodeMap11 = Map('a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q',\
    \ 'u' -> 'y')\n        val encode", "        val vowels = List('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        val alphabetMap3 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap4 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap5 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap6 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap7 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap8 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap10 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap11 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap12 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap13 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap14 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap15 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap16 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap\n        val alphabetMap17 = alphabet.zipWithIndex.map",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = Map(alphabet.zip(alphabet.tail :::\
    \ List('a')):_*)\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels.contains(c)) alphabetMap(c)\n            else if (c.isUpper) c.toLower\n\
    \            else c.toUpper\n        }\n        message.map(encodeChar)", "  \
    \      val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        var encoded = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ val nextIndex = (index + 2) % alphabet.length\n                encoded += alphabet(nextIndex).toUpper\n\
    \            } else {\n                encoded += c.toUpper\n            }\n \
    \       }\n        encoded", "        val vowels = \"AEIOUaeiou\"\n        val\
    \ alphabet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n      \
    \  val encoded = message.map(c => {\n            if (vowels.contains(c)) {\n \
    \               val index = alphabet.indexOf(c)\n                alphabet(index\
    \ + 2)\n            } else if (alphabet.contains(c)) {\n                alphabet((alphabet.indexOf(c)\
    \ + alphabet.length / 2) % alphabet.length)\n            } else {\n          \
    \      c\n            }\n        })\n        encoded", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val encoded =\
    \ message.map(x => {\n            if (vowels.contains(x.toLower)) {\n        \
    \        val index = alphabetMap(x.toLower)\n                val newIndex = (index\
    \ + 2) % 26\n                alphabetMap2(newIndex).toUpper\n            } else\
    \ {\n                x.toUpper\n            }\n        })\n        encoded", " \
    \       val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % alphabet.length) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isLower) encodedAlphabetMap(x) else encodedAlphabetMap(x.toLower).toUpper)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x)", "        var result = \"\"\n        for (c <- message) {\n            if\
    \ (c.isUpper) result += c.toLower\n            else if (c.isLower) result += c.toUpper\n\
    \            else result += c\n        }\n        result", "        val vowels\
    \ = List('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetList\
    \ = alphabet.toList\n        val encoded = message.toList.map(c => {\n       \
    \     if (vowels.contains(c.toLower)) {\n                val index = alphabetMap(c.toLower)\n\
    \                alphabetList(index + 2)\n            } else {\n             \
    \   c\n            }\n        })\n        encoded.mkString", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x)", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toArray\n        message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ alphabet((index + 2) % alphabet.length)\n            } else {\n            \
    \    c\n            }\n        }).mkString", "        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val vowelsMap = vowels.zipWithIndex.toMap\n\
    \        val encoded = message.map(c => {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = vowelsMap(c.toLower)\n                val nextIndex\
    \ = (index + 2) % vowels.length\n                vowels(nextIndex).toUpper\n \
    \           } else if (alphabet.contains(c.toLower)) {\n                val index\
    \ = alphabetMap(c.toLower)\n                val nextIndex = (index + 2) % alphabet.length\n\
    \                alphabet(nextIndex).toUpper\n            } else {\n         \
    \       c\n            }\n        })\n        encoded", "        var result =\
    \ \"\"\n        for (c <- message) {\n            if (c.isUpper) {\n         \
    \       result += c.toLower\n            } else if (c.isLower) {\n           \
    \     result += c.toUpper\n            } else {\n                result += c\n\
    \            }\n        }\n        result", "        val vowels = Set('a', 'e',\
    \ 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x).map(x => if (x.isUpper) x.toLower\
    \ else x.toUpper).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val map = Map('a'\
    \ -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 's')\n        val encoded\
    \ = message.map(c => if (vowels.contains(c.toLower)) map(c.toLower) else c)\n\
    \        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to\
    \ 'z'\n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap5\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap10\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap11\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap13\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap14\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap15\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap17\
    \ = alphabet.zipWithIndex.map", "        val vowels = Set('a', 'e', 'i', 'o',\
    \ 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap =\
    \ alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x)", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x\
    \ => if (vowels.contains(x)) alphabet((alphabetMap(x) + 2) % alphabet.length)\
    \ else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isLower) encodedAlphabetMap(x) else encodedAlphabetMap(x.toLower).toUpper)",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val messageMap\
    \ = message.toLowerCase.map(x => if (vowels.contains(x)) alphabetMap2((alphabetMap(x)\
    \ + 2) % 26) else x)\n        messageMap.map(x => if (x.isLower) x.toUpper else\
    \ x.toLower).mkString", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n \
    \       val alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 ->\
    \ x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2, x._1)).toMap\n        def encodeChar(c : Char) : Char = {\n      \
    \      if (vowels.contains(c)) {\n                val index = vowelsMap(c)\n \
    \               val newIndex = (index + 2) % vowels.length\n                alphabetMap2(newIndex)\n\
    \            } else if (alphabet.contains(c)) {\n                val index = alphabetMap(c)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabetMap2(newIndex)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(x => if (x.isUpper) encodeChar(x.toLower).toUpper\
    \ else encodeChar(x))", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val encoded = message.map(c => {\n\
    \            if (vowels.contains(c.toLower)) {\n                val index = alphabet.indexOf(c.toLower)\n\
    \                alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        })\n        encoded.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x)", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower))\
    \ alphabetMap2(alphabetMap(x.toLower)) else x).map(x => if (x.isUpper) x.toLower\
    \ else x.toUpper).mkString", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            val char = c.toLower\n            if (vowels.contains(char))\
    \ {\n                val index = vowelsMap(char)\n                val newIndex\
    \ = (index + 2) % vowels.length\n                vowels(newIndex)\n          \
    \  } else if (alphabet.contains(char)) {\n                val index = alphabetMap(char)\n\
    \                val newIndex = (index + 2) % alphabet.length\n              \
    \  alphabet(newIndex)\n            } else {\n                char\n          \
    \  }\n        })\n        encoded.map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n \
    \       val alphabetMap3 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap4 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n\
    \        def encodeChar(c : Char) : Char = {\n            if (vowels.contains(c))\
    \ {\n                alphabetMap5(alphabetMap4(alphabetMap3(alphabetMap2(alphabetMap(c)))))\n\
    \            } else {\n                alphabetMap5(alphabetMap4(alphabetMap3(alphabetMap2(alphabetMap(c)))))\n\
    \            }\n        }\n        message.map(encodeChar)", "        val vowels\
    \ = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n        message.map(x\
    \ => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower)) else\
    \ x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = if (index + 2 > 4) (index + 2) % 5 else index\
    \ + 2\n                vowels(newIndex).toUpper\n            } else {\n      \
    \          if (c.isUpper) alphabet(alphabetMap(c.toLower) + 1).toUpper\n     \
    \           else alphabet(alphabetMap(c) + 1)\n            }\n        })\n   \
    \     encoded", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = ('a' to 'z').toList\n        def encodeChar(c : Char) : Char = {\n\
    \            if (vowels.contains(c)) {\n                alphabet((alphabet.indexOf(c)\
    \ + 2) % alphabet.length)\n            } else {\n                c\n         \
    \   }\n        }\n        message.map(c => if (c.isUpper) encodeChar(c.toLower).toUpper\
    \ else encodeChar(c)).mkString", "        val vowels = \"aeiou\"\n        val\
    \ alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabet2 = alphabet\
    \ + alphabet\n        val vowels2 = alphabet2.slice(alphabet.indexOf('a'), alphabet.indexOf('a')\
    \ + vowels.length)\n        val map = Map[Char, Char]() ++ vowels.zip(vowels2)\n\
    \        message.map(c => if (vowels.contains(c.toLower)) map(c.toLower) else\
    \ c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString", "        val\
    \ vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val encoded =\
    \ message.map(c => {\n            if (vowels.contains(c.toLower)) {\n        \
    \        val index = alphabetMap(c.toLower)\n                val newIndex = (index\
    \ + 2) % alphabet.length\n                alphabet(newIndex)\n            } else\
    \ {\n                c\n            }\n        })\n        encoded.map(c => if\
    \ (c.isUpper) c.toLower else c.toUpper).mkString", "        val vowels = Set('a',\
    \ 'e', 'i', 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val\
    \ alphabetMap = alphabet.zipWithIndex.toMap\n        val encodedAlphabet = alphabet.map(x\
    \ => {\n            if (vowels.contains(x)) {\n                alphabet((alphabetMap(x)\
    \ + 2) % alphabet.length)\n            } else {\n                x\n         \
    \   }\n        })\n        val alphabetMapEncoded = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => {\n            if (x.isUpper) {\n                alphabetMapEncoded(x.toLower).toUpper\n\
    \            } else {\n                alphabetMapEncoded(x)\n            }\n\
    \        })", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (vowels.contains(c.toLower)) {\n                val index = vowelsMap(c.toLower)\n\
    \                val newIndex = if (index + 2 > 4) index + 2 - 5 else index +\
    \ 2\n                vowels(newIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = if (index + 2 > 25) index + 2 - 26 else index + 2\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c\n            }\n        })\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 -> x._1).toMap\n\
    \        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x).map(x => if (x.isUpper) x.toLower else x.toUpper).mkString", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap5\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap8\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap9\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap10\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap11\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap12\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap13\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap14\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap15\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap16\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap17\
    \ =", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 ->\
    \ x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val map = new HashMap[Char, Char]\n        for (i <- 0 until vowels.length)\
    \ {\n            map(vowels(i)) = vowels((i + 2) % vowels.length)\n        }\n\
    \        var result = \"\"\n        for (i <- 0 until message.length) {\n    \
    \        val c = message(i)\n            if (map.contains(c)) {\n            \
    \    result += map(c)\n            } else if (c.isUpper) {\n                result\
    \ += c.toLower\n            } else if (c.isLower) {\n                result +=\
    \ c.toUpper\n            } else {\n                result += c\n            }\n\
    \        }\n        result", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val alphabetMap2 =\
    \ alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val vowelsMap2 =\
    \ vowels.zipWithIndex.map(x => (x._2, x._1)).toMap\n        def encodeChar(c :\
    \ Char) : Char = {\n            if (c.isUpper) {\n                val index =\
    \ alphabetMap(c.toLower)\n                alphabetMap2(index).toUpper\n      \
    \      } else if (vowelsMap.contains(c)) {\n                val index = vowelsMap(c)\n\
    \                vowelsMap2((index + 2) % 5)\n            } else {\n         \
    \       c\n            }\n        }\n        message.map(encodeChar)", "     \
    \   val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = 'a' to 'z'\n\
    \        val alphabetMap = alphabet.zipWithIndex.toMap\n        val alphabetMap2\
    \ = alphabet.zipWithIndex.map(x => (x._2, x._1)).toMap\n        val alphabetMap3\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\n        val alphabetMap4\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap ++ Map(0 -> 'a', 1\
    \ -> 'b')\n        val alphabetMap5 = alphabet.zipWithIndex.map(x => (x._2 + 2,\
    \ x._1)).toMap ++ Map(0 -> 'a', 1 -> 'b', 26 -> 'a', 27 -> 'b')\n        val alphabetMap6\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap ++ Map(0 -> 'a', 1\
    \ -> 'b', 26 -> 'a', 27 -> 'b', 28 -> 'a', 29 -> 'b')\n        val alphabetMap7\
    \ = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap ++ Map(0 -> 'a', 1\
    \ -> 'b', 26 -> 'a', 27 -> 'b', 28 -> 'a', 29 -> 'b', 30 -> 'a', 31 -> 'b')\n\
    \        val alphabetMap8 = alphabet.zipWithIndex.map(x => (x._2 + 2, x._1)).toMap\
    \ ++ Map(0 -> 'a', 1 -> 'b', 26 -> 'a', 27 -> 'b', 28 -> 'a', 29 -> 'b', 30 ->\
    \ 'a', 31 -> 'b', 32 -> 'a', 33 -> 'b')\n        val alphabetMap9 = alphabet.zipWithIndex.map(x\
    \ => (x._2 + 2, x._1)).toMap ++ Map(0 -> 'a', 1 -> 'b', 26 -> 'a', 27 -> 'b',\
    \ 28 -> 'a', 29 -> 'b', 30 -> 'a', 31 -> 'b', 32 -> 'a', 33 -> 'b', 34 -> 'a',\
    \ 35 -> '", "        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val alphabet\
    \ = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % 26) else x)\n        val alphabetMapEncoded = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) alphabetMapEncoded(x.toLower).toUpper\
    \ else alphabetMapEncoded(x)).mkString", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val alphabetMap\
    \ = alphabet.zipWithIndex.toMap\n        val encodeMap = alphabet.zip(alphabet.drop(2)\
    \ ++ alphabet.take(2)).toMap\n        message.map(c => if (vowels.contains(c.toLower))\
    \ encodeMap(c.toLower) else c).map(c => if (c.isUpper) c.toLower else c.toUpper).mkString",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n    \
    \    val encodedAlphabet = alphabet.map(x => if (vowels.contains(x)) alphabet((alphabetMap(x)\
    \ + 2) % alphabet.length) else x)\n        val encodedAlphabetMap = alphabet.zip(encodedAlphabet).toMap\n\
    \        message.map(x => if (x.isUpper) encodedAlphabetMap(x.toLower).toUpper\
    \ else encodedAlphabetMap(x)).mkString", "        val vowels = Set('a', 'e', 'i',\
    \ 'o', 'u')\n        val alphabet = ('a' to 'z').toList\n        val encoder =\
    \ alphabet.zip(alphabet.drop(2) ::: alphabet.take(2)).toMap\n        message.map(c\
    \ => if (vowels.contains(c.toLower)) encoder(c.toLower) else c).map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).mkString", "        val vowels = \"aeiou\"\n     \
    \   val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = alphabet.indexOf(c.toLower)\n                alphabet((index + 2) % alphabet.length)\n\
    \            } else {\n                c\n            }\n        })\n        encoded.map(c\
    \ => {\n            if (c.isUpper) {\n                c.toLower\n            }\
    \ else {\n                c.toUpper\n            }\n        }).mkString", "  \
    \      val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        var encoded = \"\"\n        for (c <- message) {\n            if (vowels.contains(c.toLower))\
    \ {\n                val index = alphabet.indexOf(c.toLower)\n               \
    \ val newIndex = (index + 2) % 26\n                encoded += alphabet(newIndex).toUpper\n\
    \            } else {\n                encoded += c.toUpper\n            }\n \
    \       }\n        encoded", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val vowelsMap = vowels.zipWithIndex.toMap\n        val encoded = message.map(c\
    \ => {\n            if (vowels.contains(c.toLower)) {\n                val index\
    \ = vowelsMap(c.toLower)\n                val newIndex = (index + 2) % vowels.length\n\
    \                vowels(newIndex).toUpper\n            } else if (alphabet.contains(c.toLower))\
    \ {\n                val index = alphabetMap(c.toLower)\n                val newIndex\
    \ = (index + 2) % alphabet.length\n                alphabet(newIndex).toUpper\n\
    \            } else {\n                c\n            }\n        })\n        encoded",
  "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val alphabet = ('a'\
    \ to 'z').toList\n        def encodeChar(c : Char) : Char = {\n            if\
    \ (vowels.contains(c)) {\n                val index = alphabet.indexOf(c)\n  \
    \              alphabet((index + 2) % alphabet.length)\n            } else {\n\
    \                c\n            }\n        }\n        message.map(c => if (c.isUpper)\
    \ c.toLower else c.toUpper).map(encodeChar).mkString", "        // Write your\
    \ code here\n        null", "        val vowels = \"aeiou\"\n        val alphabet\
    \ = \"abcdefghijklmnopqrstuvwxyz\"\n        val alphabet2 = alphabet + alphabet\n\
    \        val alphabet3 = alphabet2 + alphabet\n        val alphabet4 = alphabet3\
    \ + alphabet\n        val alphabet5 = alphabet4 + alphabet\n        val alphabet6\
    \ = alphabet5 + alphabet\n        val alphabet7 = alphabet6 + alphabet\n     \
    \   val alphabet8 = alphabet7 + alphabet\n        val alphabet9 = alphabet8 +\
    \ alphabet\n        val alphabet10 = alphabet9 + alphabet\n        val alphabet11\
    \ = alphabet10 + alphabet\n        val alphabet12 = alphabet11 + alphabet\n  \
    \      val alphabet13 = alphabet12 + alphabet\n        val alphabet14 = alphabet13\
    \ + alphabet\n        val alphabet15 = alphabet14 + alphabet\n        val alphabet16\
    \ = alphabet15 + alphabet\n        val alphabet17 = alphabet16 + alphabet\n  \
    \      val alphabet18 = alphabet17 + alphabet\n        val alphabet19 = alphabet18\
    \ + alphabet\n        val alphabet20 = alphabet19 + alphabet\n        val alphabet21\
    \ = alphabet20 + alphabet\n        val alphabet22 = alphabet21 + alphabet\n  \
    \      val alphabet23 = alphabet22 + alphabet\n        val alphabet24 = alphabet23\
    \ + alphabet\n        val alphabet25 = alphabet24 + alphabet\n        val alphabet26\
    \ = alphabet25 + alphabet\n        val alphabet27 = alphabet26 + alphabet\n  \
    \      val alphabet28 = alphabet27 + alphabet\n        val alphabet29 = alphabet28\
    \ + alphabet\n        val alphabet30 = alphabet29 + alphabet\n        val alphabet31\
    \ = alphabet30 + alphabet\n        val alphabet32 = alphabet31 + alphabet\n  \
    \      val alphabet33 = alphabet32 + alphabet\n        val alphabet34 = alphabet33\
    \ + alphabet\n        val alphabet35 = alphabet34 + alphabet\n        val alphabet36\
    \ = alphabet35 + alphabet\n        val alphabet37 = alphabet36 + alphabet\n  \
    \      val alphabet38 = alphabet37 + alphabet\n        val alphabet39 = alphabet38\
    \ + alphabet\n        val alphabet40 = alphabet39 + alphabet\n        val alphabet41\
    \ = alphabet40 + alphabet\n        val alphabet42 = alphabet41 + alphabet\n  \
    \      val alphabet43 = alphabet42 + alphabet\n        val alphabet44 = alphabet43\
    \ + alphabet\n        val alphabet45 = alphabet44 + alphabet\n        val alphabet46\
    \ = alphabet45 + alphabet\n        val alphabet47 = alphabet46 + alphabet\n  \
    \      val alphabet48 = alphabet47 + alphabet\n        val alphabet49 = alphabet48\
    \ + alphabet\n", "        val vowels = Set('a', 'e', 'i', 'o', 'u')\n        val\
    \ alphabet = ('a' to 'z').toList\n        val alphabetMap = alphabet.zipWithIndex.toMap\n\
    \        val alphabetMap2 = alphabet.zipWithIndex.map(x => (x._2 + 2) % 26 ->\
    \ x._1).toMap\n        message.map(x => if (vowels.contains(x.toLower)) alphabetMap2(alphabetMap(x.toLower))\
    \ else x)", "        val vowels = \"aeiou\"\n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        val alphabetMap = alphabet.zipWithIndex.toMap\n        val vowelsMap\
    \ = vowels.zipWithIndex.toMap\n        val encoded = message.map(c => {\n    \
    \        if (c.isUpper) {\n                c.toLower\n            } else if (c.isLower)\
    \ {\n                if (vowels.contains(c)) {\n                    val index\
    \ = vowelsMap(c)\n                    val newIndex = (index + 2) % vowels.length\n\
    \                    vowels(newIndex).toUpper\n                } else {\n    \
    \                c.toUpper\n                }\n            } else {\n        \
    \        c\n            }\n        })\n        encoded"]
stop_tokens:
- "\n    }\n"
