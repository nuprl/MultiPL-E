name: HumanEval_87_get_row
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a 2 dimensional data, as a nested lists,\n    // which is\
  \ similar to matrix, however, unlike matrices,\n    // each row may contain a different\
  \ number of columns.\n    // Given lst, and integer x, find integers x in the list,\n\
  \    // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    // each\
  \ tuple is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates\
  \ initially by rows in ascending order.\n    // Also, sort coordinates of the row\
  \ by columns in descending order.\n    // Examples:\n    // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
  \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
  \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
  \ x : Long) : List[Tuple2[Long, Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l,\
  \ 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
  \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
  \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
  \ Long]]((2l, 2l)))));\n    }\n\n}\n"
completions: ["        // Fill up this function body\n        // `lst` is a list of\
    \ lists\n        // `x` is the element to find\n        // You have to return\
    \ a list of tuples\n        // Each tuple is a coordinate - (row, column)\n  \
    \      // Sort coordinates initially by rows in ascending order\n        // Also,\
    \ sort coordinates of the row by columns in descending order\n        // If `x`\
    \ is not found in `lst`, return empty list\n        // If `lst` is empty, return\
    \ empty list\n        var result = List[Tuple2[Long, Long]]()\n        for (i\
    \ <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n \
    \               if (lst(i)(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            val row = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = (i, j) ::\
    \ result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, which is similar to matrix,\
    \ however, unlike matrices,\n        // each row may contain a different number\
    \ of columns.\n        // 'x' is an integer\n        // You have to return a list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => a._1 <\
    \ b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = (i, j) :: result\n                }\n      \
    \      }\n        }\n        result.sortWith((a, b) => {\n            if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    a._1 < b._1\n            }\n        })", "        val lst2 = lst.zipWithIndex.map(x\
    \ => x._1.zipWithIndex.map(y => (x._2, y._2, y._1))).flatten.filter(x => x._3\
    \ == x).map(x => (x._1, x._2)).sortWith((x, y) => x._1 < y._1 || (x._1 == y._1\
    \ && x._2 > y._2))\n        return lst2", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, however, unlike matrices,\n\
    \        // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer.\n        // You have to find integers x in the list,\n      \
    \  // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        //\
    \ each tuple is a coordinate - (row, columns), starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        // If x is not found in\
    \ the list, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // Note:\n        // 1. You can assume that x is always present\
    \ in the list.\n        // 2. You can assume that the list is not empty.\n   \
    \     // 3. You can assume that the list is not null.\n        // 4. You can assume\
    \ that the list is not a string.\n        // 5. You can assume that the list is\
    \ not a set.\n        // 6. You can assume that the list is not a map.\n     \
    \   // 7. You can assume that the list is not a vector.\n        // 8. You can\
    \ assume that the list is not a stream.\n        // 9. You can assume that the\
    \ list is not a sequence.\n        // 10. You can assume that the list is not\
    \ a range.\n        // 11. You can assume that the list is not a queue.\n    \
    \    // 12. You can assume that the list is not a stack.\n        // 13. You can\
    \ assume that the list is not a priority queue.\n        // 14. You can assume\
    \ that the list is not a deque.\n        // 15. You can assume that the list is\
    \ not a double ended queue.\n        // 16. You can assume that the list is not\
    \ a linked list.\n        // 17. You can assume that the list is not a doubly\
    \ linked list.\n        // 18. You can assume that the list is not a circular\
    \ linked list.\n        // 19. You can assume that the list is not a circular\
    \ doubly linked list.\n        // 20. You can assume that the list is not a circular\
    \ queue.\n        // 21", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 < b._1)\
    \ {\n                true\n            } else if (a._1 == b._1) {\n          \
    \      a._2 > b._2\n            } else {\n                false\n            }\n\
    \        })", "        // Fill up this function body\n        // 'lst' is a nested\
    \ list, which is similar to matrix, however, unlike matrices,\n        // each\
    \ row may contain a different number of columns.\n        // 'x' is an integer\n\
    \        // You have to return a list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      var result = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length\
    \ - 1) {\n            var row = lst(i)\n            for (j <- 0 to row.length\
    \ - 1) {\n                if (row(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, which is similar to matrix,\n\
    \        // however, unlike matrices, each row may contain a different number\
    \ of columns.\n        // 'x' is an integer.\n        // You have to find integers\
    \ 'x' in the list,\n        // and return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If there are no such coordinates, return an empty list.\n        //\
    \ If the list is empty, return an empty list.\n        // Note: You can use built-in\
    \ functions sortWith and sorted.\n        // Note: You can use built-in function\
    \ zipWithIndex.\n        // Note: You can use built-in function flatten.\n   \
    \     // Note: You can use built-in function filter.\n        // Note: You can\
    \ use built-in function map.\n        // Note: You can use built-in function reverse.\n\
    \        // Note: You can use built-in function zip.\n        // Note: You can\
    \ use built-in function sortBy.\n        // Note: You can use built-in function\
    \ groupBy.\n        // Note: You can use built-in function toList.\n        //\
    \ Note: You can use built-in function toSeq.\n        // Note: You can use built-in\
    \ function toSet.\n        // Note: You can use built-in function toMap.\n   \
    \     // Note: You can use built-in function toVector.\n        // Note: You can\
    \ use built-in function toArray.\n        // Note: You can use built-in function\
    \ toIterable.\n        // Note: You can use built-in function toIndexedSeq.\n\
    \        // Note: You can use built-in function toStream.\n        // Note: You\
    \ can use built-in function to.\n        // Note: You can use built-in function\
    \ toTraversable.\n        // Note: You can use built-in function toSeq.\n    \
    \    // Note: You can use built-in function toIterable.\n       ", "        //\
    \ Fill up this function body\n        // 'lst' is a nested list, similar to matrix,\
    \ but each row may contain different number of columns.\n        // 'x' is the\
    \ integer to be searched in the list.\n        // Return list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns),\n\
    \        // starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If x is not found in the list, return empty list.\n\
    \        // If lst is empty, return empty list.\n        // If lst is a list of\
    \ empty lists, return empty list.\n        // If lst is a list of lists, each\
    \ containing empty list, return empty list.\n        // If lst is a list of lists,\
    \ each containing x, return list of tuples, [(0, 0), (1, 0), (2, 0) ...]\n   \
    \     // If lst is a list of lists, each containing x, return list of tuples,\
    \ [(0, 0), (1, 0), (2, 0) ...]\n        // If lst is a list of lists, each containing\
    \ x, return list of tuples, [(0, 0), (1, 0), (2, 0) ...]\n        // If lst is\
    \ a list of lists, each containing x, return list of tuples, [(0, 0), (1, 0),\
    \ (2, 0) ...]\n        // If lst is a list of lists, each containing x, return\
    \ list of tuples, [(0, 0), (1, 0), (2, 0) ...]\n        // If lst is a list of\
    \ lists, each containing x, return list of tuples, [(0, 0), (1, 0), (2, 0) ...]\n\
    \        // If lst is a list of lists, each containing x, return list of tuples,\
    \ [(0, 0), (1, 0), (2, 0) ...]\n        // If lst is a list of lists, each containing\
    \ x, return list of tuples, [(0, 0), (1, 0), (2, 0) ...]\n        // If lst is\
    \ a list of", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        val lst2 = lst.zipWithIndex.map(x => x._1.zipWithIndex.map(y\
    \ => (x._2, y._2))).flatten.filter(x => x._2 == x._1).sortBy(x => x._1)\n    \
    \    lst2", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = (i, j) :: result\n                }\n            }\n        }\n  \
    \      result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        // Fill up this function body\n        // 'lst' is a nested list, and 'x'\
    \ is the integer to be searched\n        // Return a list of tuples, each tuple\
    \ is a coordinate - (row, column)\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found, return an empty list\n \
    \       // If lst is empty, return an empty list\n        // If lst is a list\
    \ of empty lists, return an empty list\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            val row = lst(i)\n            for (j <- 0 until row.length) {\n \
    \               if (row(j) == x) {\n                    result = (i, j) :: result\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = (i, j) ::\
    \ result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        val result\
    \ = ListBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            val row = lst(i)\n            for (j <- 0 until row.length) {\n \
    \               if (row(j) == x) {\n                    result += Tuple2(i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.toList.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, similar to matrix, but unlike\
    \ matrix,\n        // each row may contain a different number of columns.\n  \
    \      // 'x' is an integer.\n        // Return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If x is not present in the list, return empty list.\n   \
    \     // If the list is empty, return empty list.\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        var row : Long = 0\n        for\
    \ (l <- lst) {\n            var col : Long = 0\n            for (e <- l) {\n \
    \               if (e == x) {\n                    result = result :+ (row, col)\n\
    \                }\n                col += 1\n            }\n            row +=\
    \ 1\n        }\n        result.sortWith((a, b) => {\n            if (a._1 < b._1)\
    \ {\n                true\n            } else if (a._1 == b._1) {\n          \
    \      a._2 > b._2\n            } else {\n                false\n            }\n\
    \        })", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        // Fill up this function body\n        // `lst` is\
    \ a nested list, similar to matrix, but each row may contain a different number\
    \ of columns\n        // `x` is an integer\n        // return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 to lst.length - 1) {\n            for (j <- 0 to lst(i).length\
    \ - 1) {\n                if (lst(i)(j) == x) {\n                    result =\
    \ result :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n\
    \        result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n      \
    \          a._2 > b._2\n            } else {\n                a._1 < b._1\n  \
    \          }\n        })", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 to lst.length - 1) {\n            for (j <- 0\
    \ to lst(i).length - 1) {\n                if (lst(i)(j) == x) {\n           \
    \         result = (i, j) :: result\n                }\n            }\n      \
    \  }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 >\
    \ b._2))", "        // Fill up this function body\n        // 'lst' is a list\
    \ of lists\n        // 'x' is the element to be found\n        // You have to\
    \ return a list of tuples\n        // [(x1, y1), (x2, y2) ...] such that\n   \
    \     // each tuple is a coordinate - (row, columns), starting with 0.\n     \
    \   // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => {\n  \
    \          if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })", " \
    \       var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n \
    \       for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 < b._1) {\n            \
    \    true\n            } else if (a._1 == b._1) {\n                a._2 > b._2\n\
    \            } else {\n                false\n            }\n        })", "  \
    \      // Fill up this function body\n        // 'lst' is a nested list, similar\
    \ to matrix,\n        // 'x' is the integer to be searched in the list\n     \
    \   // Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each\
    \ tuple is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 != b._1)\
    \ {\n                a._1 < b._1\n            } else {\n                a._2 >\
    \ b._2\n            }\n        })", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        var row : Long = 0\n        for (i <-\
    \ lst) {\n            var col : Long = 0\n            for (j <- i) {\n       \
    \         if (j == x) {\n                    result = result :+ (row, col)\n \
    \               }\n                col += 1\n            }\n            row +=\
    \ 1\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1\
    \ && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 < b._1)\
    \ {\n                true\n            } else if (a._1 == b._1) {\n          \
    \      a._2 > b._2\n            } else {\n                false\n            }\n\
    \        })", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 < b._1)\
    \ {\n                true\n            } else if (a._1 == b._1) {\n          \
    \      a._2 > b._2\n            } else {\n                false\n            }\n\
    \        })", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] = List()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = (i, j) :: result\n  \
    \              }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ {\n            if (a._1 == b._1) {\n                a._2 > b._2\n          \
    \  } else {\n                a._1 < b._1\n            }\n        })", "      \
    \  // Fill up this function body\n        // 'lst' is a list of lists, and 'x'\
    \ is the number to be searched\n        // Return a list of tuples, each tuple\
    \ is a coordinate - (row, columns)\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If 'x' is not found in the list, return an\
    \ empty list\n        // If 'lst' is empty, return an empty list\n        // If\
    \ 'lst' is a list of empty lists, return an empty list\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })", " \
    \       var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n \
    \       for (i <- 0 until lst.length) {\n            val row = lst(i)\n      \
    \      for (j <- 0 until row.length) {\n                if (row(j) == x) {\n \
    \                   result = (i, j) :: result\n                }\n           \
    \ }\n        }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length - 1) {\n   \
    \         for (j <- 0 to lst(i).length - 1) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => {\n  \
    \          if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            val row = lst(i)\n            for (j <- 0 until\
    \ row.length) {\n                if (row(j) == x) {\n                    result\
    \ = (i, j) :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        // Fill up this function body\n        //\
    \ 'lst' is a nested list, similar to matrix,\n        // however, unlike matrices,\
    \ each row may contain a different number of columns.\n        // 'x' is an integer,\
    \ which you need to find in the list.\n        // Return list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\n        // each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If x is not found in the list, return empty list.\n\
    \        // If list is empty, return empty list.\n        // If list is None,\
    \ return empty list.\n        // If list is not a nested list, return empty list.\n\
    \        // If list is a nested list, but does not contain any list, return empty\
    \ list.\n        // If list is a nested list, but does not contain any integer,\
    \ return empty list.\n        // If list is a nested list, but does not contain\
    \ any integer, return empty list.\n        // If list is a nested list, but does\
    \ not contain any integer, return empty list.\n        // If list is a nested\
    \ list, but does not contain any integer, return empty list.\n        // If list\
    \ is a nested list, but does not contain any integer, return empty list.\n   \
    \     // If list is a nested list, but does not contain any integer, return empty\
    \ list.\n        // If list is a nested list, but does not contain any integer,\
    \ return empty list.\n        // If list is a nested list, but does not contain\
    \ any integer, return empty list.\n        // If list is a nested list, but does\
    \ not contain any integer, return empty list.\n        // If list is a nested\
    \ list, but does not contain any integer, return empty list.\n        // If list\
    \ is a nested list, but does not contain any integer, return empty list.\n   \
    \     // If list is a nested list, but does not contain any integer, return empty\
    \ list.\n        // If list is a nested list, but does not contain any integer,\
    \ return empty list.\n        // If list is a nested list, but does not contain\
    \ any integer, return empty list.\n        // If list is a", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => if (a._1 < b._1) true else if (a._1 == b._1) a._2 > b._2 else false)",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => if (a._1 == b._1) a._2 > b._2 else a._1 < b._1)", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = (i, j) :: result\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ {\n            if (a._1 == b._1) {\n                a._2 > b._2\n          \
    \  } else {\n                a._1 < b._1\n            }\n        })", "      \
    \  var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n      \
    \  for (i <- 0 until lst.length) {\n            var row : List[Long] = lst(i)\n\
    \            for (j <- 0 until row.length) {\n                if (row(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => {\n     \
    \       if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      val row = lst(i)\n            for (j <- 0 until row.length) {\n       \
    \         if (row(j) == x) {\n                    result = (i, j) :: result\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, similar to matrix, but each row may\
    \ contain a different number of columns.\n        // 'x' is an integer to be found\
    \ in the list.\n        // Return a list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      // If x is not found in the list, return empty list.\n        // If the\
    \ list is empty, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // If the list is empty, return empty list.\n        // If the\
    \ list is empty, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // If the list is empty, return empty list.\n        // If the\
    \ list is empty, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // If the list is empty, return empty list.\n        // If the\
    \ list is empty, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // If the list is empty, return empty list.\n        // If the\
    \ list is empty, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // If the list is empty, return empty list.\n        // If the\
    \ list is empty, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // If the list is empty, return empty list.\n        // If the\
    \ list is empty, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // If the list is empty, return empty list.\n        // If the\
    \ list is empty, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // If the list is empty, return empty list.\n        // If the\
    \ list is empty, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // If the list is empty, return empty list.\n        // If the\
    \ list is empty, return empty list.\n        // If the list is", "        var\
    \ result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for\
    \ (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n\
    \                if (lst(i)(j) == x) {\n                    result = (i, j) ::\
    \ result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // `lst` is a nested list, which is similar to matrix,\
    \ however, unlike matrices,\n        // each row may contain a different number\
    \ of columns.\n        // `x` is an integer to find in the list.\n        // You\
    \ have to return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        //\
    \ each tuple is a coordinate - (row, columns), starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        // Fill up this function body\n \
    \       // 'lst' is a nested list, similar to matrix, but each row may contain\
    \ a different number of columns.\n        // 'x' is an integer to be found in\
    \ the list.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If x\
    \ is not found in the list, return empty list.\n        // If list is empty, return\
    \ empty list.\n        // If list is empty, return empty list.\n        // If\
    \ list is empty, return empty list.\n        // If list is empty, return empty\
    \ list.\n        // If list is empty, return empty list.\n        // If list is\
    \ empty, return empty list.\n        // If list is empty, return empty list.\n\
    \        // If list is empty, return empty list.\n        // If list is empty,\
    \ return empty list.\n        // If list is empty, return empty list.\n      \
    \  // If list is empty, return empty list.\n        // If list is empty, return\
    \ empty list.\n        // If list is empty, return empty list.\n        // If\
    \ list is empty, return empty list.\n        // If list is empty, return empty\
    \ list.\n        // If list is empty, return empty list.\n        // If list is\
    \ empty, return empty list.\n        // If list is empty, return empty list.\n\
    \        // If list is empty, return empty list.\n        // If list is empty,\
    \ return empty list.\n        // If list is empty, return empty list.\n      \
    \  // If list is empty, return empty list.\n        // If list is empty, return\
    \ empty list.\n        // If list is empty, return empty list.\n        // If\
    \ list is empty, return empty list.\n        // If list is empty, return empty\
    \ list.\n        // If list is empty, return empty list.\n        // If list is\
    \ empty, return empty list.\n        // If list is empty, return empty list.\n\
    \        // If list is empty, return empty list.\n        // If list is empty,\
    \ return empty list.", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => if (a._1 == b._1) a._2 > b._2 else\
    \ a._1 < b._1)", "        // Fill up this function body\n        // 'lst' is a\
    \ nested list, similar to matrix, but each row may contain a different number\
    \ of columns.\n        // 'x' is an integer.\n        // You have to find integers\
    \ 'x' in the list, and return list of tuples,\n        // [(x1, y1), (x2, y2)\
    \ ...] such that each tuple is a coordinate - (row, columns),\n        // starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If the list is empty, return an empty list.\n        // If the list\
    \ does not contain 'x', return an empty list.\n        // If the list contains\
    \ 'x', return a list of tuples,\n        // [(x1, y1), (x2, y2) ...] such that\
    \ each tuple is a coordinate - (row, columns),\n        // starting with 0.\n\
    \        // Sort coordinates initially by rows in ascending order.\n        //\
    \ Also, sort coordinates of the row by columns in descending order.\n        //\
    \ If the list is empty, return an empty list.\n        // If the list does not\
    \ contain 'x', return an empty list.\n        // If the list contains 'x', return\
    \ a list of tuples,\n        // [(x1, y1), (x2, y2) ...] such that each tuple\
    \ is a coordinate - (row, columns),\n        // starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        // If the list is empty,\
    \ return an empty list.\n        // If the list does not contain 'x', return an\
    \ empty list.\n        // If the list contains 'x', return a list of tuples,\n\
    \        // [(x1, y1), (x2, y2) ...] such that each tuple is a coordinate - (row,\
    \ columns),\n        // starting with 0.\n        // Sort coordinates initially\
    \ by rows in ascending order.\n        // Also, sort coordinates of the row by\
    \ columns in descending order.\n        // If the list is empty, return an empty\
    \ list.\n        // If the list does not contain 'x', return an empty list.\n\
    \       ", "        val result = new ListBuffer[Tuple2[Long, Long]]()\n      \
    \  for (i <- 0 until lst.length) {\n            val row = lst(i)\n           \
    \ for (j <- 0 until row.length) {\n                if (row(j) == x) {\n      \
    \              result += Tuple2(i.toLong, j.toLong)\n                }\n     \
    \       }\n        }\n        result.toList.sortWith((a, b) => {\n           \
    \ if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n   \
    \             a._1 < b._1\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => {\n            if\
    \ (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n      \
    \          a._1 < b._1\n            }\n        })", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, similar to matrix, but each row may\
    \ contain a different number of columns.\n        // 'x' is the integer to be\
    \ searched in the list.\n        // Return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If the integer 'x' is not found in the list, return an empty list.\n\
    \        // If the list is empty, return an empty list.\n        var result =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => {\n     \
    \       if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                a._1 < b._1\n            }\n        })", "        // Fill up\
    \ this function body\n        // `lst` is a nested list, which is similar to matrix,\n\
    \        // however, unlike matrices, each row may contain a different number\
    \ of columns.\n        // `x` is an integer, which you need to find in the list.\n\
    \        // Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n      \
    \  // each tuple is a coordinate - (row, columns), starting with 0.\n        //\
    \ Sort coordinates initially by rows in ascending order.\n        // Also, sort\
    \ coordinates of the row by columns in descending order.\n        var result =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => if (a._1\
    \ == b._1) a._2 > b._2 else a._1 < b._1)", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        // Fill up\
    \ this function body\n        // 'lst' is a nested list, and 'x' is the integer\
    \ to find\n        // Return a list of tuples, each tuple is a coordinate - (row,\
    \ columns)\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        var result = List[Tuple2[Long, Long]]()\n        var row = 0\n      \
    \  for (i <- lst) {\n            var col = 0\n            for (j <- i) {\n   \
    \             if (j == x) {\n                    result = result :+ (row, col)\n\
    \                }\n                col += 1\n            }\n            row +=\
    \ 1\n        }\n        result.sortBy(x => (x._1, -x._2))", "        var result\
    \ : List[Tuple2[Long, Long]] = List()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // `lst` is a nested list, which is similar to matrix, however,\
    \ unlike matrices,\n        // each row may contain a different number of columns.\n\
    \        // `x` is an integer\n        // You have to return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // Example:\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n        //\
    \ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n\
    \        // >>> getRow((List[List[Long]]()), (1l))\n        // (List[Tuple2[Long,\
    \ Long]]())\n        // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong),\
    \ List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n        // (List[Tuple2[Long,\
    \ Long]]((2l, 2l)))\n        var result = List[Tuple2[Long, Long]]()\n       \
    \ var row = 0l\n        for (i <- lst) {\n            var col = 0l\n         \
    \   for (j <- i) {\n                if (j == x) {\n                    result\
    \ = result :+ (row, col)\n                }\n                col +=", "      \
    \  var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n      \
    \  for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 < b._1) {\n            \
    \    true\n            } else if (a._1 == b._1) {\n                a._2 > b._2\n\
    \            } else {\n                false\n            }\n        })", "  \
    \      // Fill up this function body\n        // `lst` is a list of lists, where\
    \ each list is a row\n        // `x` is the element to find\n        // return\
    \ a list of tuples, where each tuple is a coordinate\n        // (row, column)\n\
    \        // sort the coordinates initially by rows in ascending order\n      \
    \  // also, sort coordinates of the row by columns in descending order\n     \
    \   // example:\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n        //\
    \ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n\
    \        // >>> getRow((List[List[Long]]()), (1l))\n        // (List[Tuple2[Long,\
    \ Long]]())\n        // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong),\
    \ List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n        // (List[Tuple2[Long,\
    \ Long]]((2l, 2l)))\n        var result = List[Tuple2[Long, Long]]()\n       \
    \ for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 < b._1) {\n            \
    \    true\n           ", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        // Fill up this function body\n \
    \       // 'lst' is a nested list, similar to matrix,\n        // 'x' is an integer\
    \ to be searched in the list\n        // Return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        var result = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ to lst.length - 1) {\n            for (j <- 0 to lst(i).length - 1) {\n    \
    \            if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        // Fill up\
    \ this function body\n        // 'lst' is a list of lists, each list is a row\n\
    \        // 'x' is the element to be searched\n        // Return a list of tuples,\
    \ each tuple is a coordinate (row, column)\n        // Sort the list of tuples\
    \ by rows in ascending order\n        // Also, sort the list of tuples of the\
    \ row by columns in descending order\n        // If the element is not found,\
    \ return an empty list\n        // If the list is empty, return an empty list\n\
    \        // If the list is empty, return an empty list\n        // If the list\
    \ is empty, return an empty list\n        // If the list is empty, return an empty\
    \ list\n        // If the list is empty, return an empty list\n        // If the\
    \ list is empty, return an empty list\n        // If the list is empty, return\
    \ an empty list\n        // If the list is empty, return an empty list\n     \
    \   // If the list is empty, return an empty list\n        // If the list is empty,\
    \ return an empty list\n        // If the list is empty, return an empty list\n\
    \        // If the list is empty, return an empty list\n        // If the list\
    \ is empty, return an empty list\n        // If the list is empty, return an empty\
    \ list\n        // If the list is empty, return an empty list\n        // If the\
    \ list is empty, return an empty list\n        // If the list is empty, return\
    \ an empty list\n        // If the list is empty, return an empty list\n     \
    \   // If the list is empty, return an empty list\n        // If the list is empty,\
    \ return an empty list\n        // If the list is empty, return an empty list\n\
    \        // If the list is empty, return an empty list\n        // If the list\
    \ is empty, return an empty list\n        // If the list is empty, return an empty\
    \ list\n        // If the list is empty, return an empty list\n        // If the\
    \ list is empty, return an empty list\n        // If the list is empty, return\
    \ an empty list\n        // If the list is empty, return an empty list\n     \
    \   // If the list is empty, return an empty list\n        // If the list is empty,\
    \ return an empty list\n        // If the list is empty, return an empty list\n\
    \        // If", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = (i, j) :: result\n                }\n            }\n        }\n  \
    \      result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, which is similar to matrix,\n     \
    \   // however, unlike matrices, each row may contain a different number of columns.\n\
    \        // 'x' is an integer\n        // You have to find integers 'x' in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length - 1) {\n   \
    \         for (j <- 0 to lst(i).length - 1) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = (i, j) :: result\n                }\n   \
    \         }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        // Fill up this function body\n        //\
    \ 'lst' is a nested list, which is similar to matrix, however, unlike matrices,\n\
    \        // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer\n        // You have to return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 to lst.length - 1) {\n            for (j <- 0 to lst(i).length\
    \ - 1) {\n                if (lst(i)(j) == x) {\n                    result =\
    \ result :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n\
    \        result.sortWith(_._1 < _._1).sortWith(_._2 > _._2)", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            val row = lst(i)\n            for (j <- 0 until\
    \ row.length) {\n                if (row(j) == x) {\n                    result\
    \ = result :+ (i.toLong, j.toLong)\n                }\n            }\n       \
    \ }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n  \
    \              a._2 > b._2\n            } else {\n                a._1 < b._1\n\
    \            }\n        })", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((t1, t2) => {\n   \
    \         if (t1._1 < t2._1) {\n                true\n            } else if (t1._1\
    \ == t2._1) {\n                t1._2 > t2._2\n            } else {\n         \
    \       false\n            }\n        })", "        var res = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            var row = lst(i)\n\
    \            for (j <- 0 until row.length) {\n                if (row(j) == x)\
    \ {\n                    res = res :+ (i.toLong, j.toLong)\n                }\n\
    \            }\n        }\n        res.sortWith((a, b) => {\n            if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    a._1 < b._1\n            }\n        })", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, similar to matrix, but unlike matrix,\n\
    \        // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      var result = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length\
    \ - 1) {\n            for (j <- 0 to lst(i).length - 1) {\n                if\
    \ (lst(i)(j) == x) {\n                    result = result :+ (i.toLong, j.toLong)\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ {\n            if (a._1 < b._1) {\n                true\n            } else\
    \ if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n   \
    \             false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => if\
    \ (a._1 == b._1) a._2 > b._2 else a._1 < b._1)", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => a._1 < b._1\
    \ || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 < b._1) {\n                true\n            } else if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    false\n            }\n        })", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix,\n        // 'x' is an integer\n\
    \        // Return a list of tuples, [(x1, y1), (x2, y2) ...]\n        // such\
    \ that each tuple is a coordinate - (row, columns),\n        // starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      // For example,\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n        //\
    \ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n\
    \        // >>> getRow((List[List[Long]]()), (1l))\n        // (List[Tuple2[Long,\
    \ Long]]())\n        // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong),\
    \ List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n        // (List[Tuple2[Long,\
    \ Long]]((2l, 2l)))\n        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 to lst.length - 1) {\n            for (j <- 0\
    \ to lst(i).length - 1) {\n                if (lst(i)(j) == x) {\n           \
    \         result = result :+ (i.toLong, j.toLong)\n                }", "     \
    \   // Fill up this function body\n        // 'lst' is a nested list, similar\
    \ to matrix, but each row may contain a different number of columns.\n       \
    \ // 'x' is an integer.\n        // You have to find 'x' in the list, and return\
    \ list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If 'x' is not found in the\
    \ list, return empty list.\n        // If the list is empty, return empty list.\n\
    \        // If the list is a list of empty lists, return empty list.\n       \
    \ // If the list is a list of empty lists, except one list, and 'x' is not found\
    \ in that list, return empty list.\n        // If the list is a list of empty\
    \ lists, except one list, and 'x' is found in that list, return list of tuples,\
    \ [(0, 0)]\n        // If the list is a list of empty lists, except one list,\
    \ and 'x' is not found in that list, return empty list.\n        // If the list\
    \ is a list of empty lists, except one list, and 'x' is found in that list, return\
    \ list of tuples, [(0, 0)]\n        // If the list is a list of empty lists, except\
    \ one list, and 'x' is not found in that list, return empty list.\n        //\
    \ If the list is a list of empty lists, except one list, and 'x' is found in that\
    \ list, return list of tuples, [(0, 0)]\n        // If the list is a list of empty\
    \ lists, except one list, and 'x' is not found in that list, return empty list.\n\
    \        // If the list is a list of empty lists, except one list, and 'x' is\
    \ found in that list, return list of tuples, [(0, 0)]\n        // If the list\
    \ is a list of empty lists, except one list, and 'x' is not found in that list,\
    \ return empty list.\n        // If the list is a list of empty lists, except\
    \ one list, and 'x' is", "        // Fill up this function body\n        // 'lst'\
    \ is a list of lists, and 'x' is the integer to be found\n        // Return a\
    \ list of tuples, each tuple is a coordinate - (row, columns)\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            var row = lst(i)\n\
    \            for (j <- 0 until row.length) {\n                if (row(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => {\n     \
    \       if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                a._1 < b._1\n            }\n        })", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            var row : List[Long] = lst(i)\n           \
    \ for (j <- 0 until row.length) {\n                if (row(j) == x) {\n      \
    \              result = result :+ (i.toLong, j.toLong)\n                }\n  \
    \          }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        // Fill up this function body\n        //\
    \ 'lst' is a nested list, similar to matrix,\n        // 'x' is an integer\n \
    \       // You have to return a list of tuples,\n        // each tuple is a coordinate\
    \ - (row, columns),\n        // starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        var row = 0l\n        var col = 0l\n        for (i <- lst)\
    \ {\n            col = 0l\n            for (j <- i) {\n                if (j ==\
    \ x) {\n                    result = result :+ (row, col)\n                }\n\
    \                col += 1\n            }\n            row += 1\n        }\n  \
    \      result.sortWith(_._1 < _._1).sortWith(_._2 > _._2)", "        // Fill up\
    \ this function body\n        // `lst` is a list of lists, where each list is\
    \ a row of the matrix\n        // `x` is the number to be searched in the matrix\n\
    \        // Return a list of tuples, where each tuple is a coordinate of the number\
    \ `x`\n        // Sort the list of tuples by rows in ascending order, and then\
    \ by columns in descending order\n        // If `x` is not found in the matrix,\
    \ return an empty list\n        // If the matrix is empty, return an empty list\n\
    \        var result = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length\
    \ - 1) {\n            for (j <- 0 to lst(i).length - 1) {\n                if\
    \ (lst(i)(j) == x) {\n                    result = result :+ (i.toLong, j.toLong)\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ if (a._1 != b._1) a._1 < b._1 else a._2 > b._2)", "        var res = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  res = (i, j) :: res\n                }\n            }\n        }\n        res.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) true\n            else if (a._1 == b._1)\
    \ {\n                if (a._2 > b._2) true\n                else false\n     \
    \       }\n            else false\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer to be found in the list.\n        // Return list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found in the list, return empty\
    \ list.\n        // If list is empty, return empty list.\n        // If list is\
    \ not a nested list, return empty list.\n        // If list is a nested list,\
    \ but contains empty lists, return empty list.\n        // If list is a nested\
    \ list, but contains empty lists, return empty list.\n        // If list is a\
    \ nested list, but contains empty lists, return empty list.\n        // If list\
    \ is a nested list, but contains empty lists, return empty list.\n        // If\
    \ list is a nested list, but contains empty lists, return empty list.\n      \
    \  // If list is a nested list, but contains empty lists, return empty list.\n\
    \        // If list is a nested list, but contains empty lists, return empty list.\n\
    \        // If list is a nested list, but contains empty lists, return empty list.\n\
    \        // If list is a nested list, but contains empty lists, return empty list.\n\
    \        // If list is a nested list, but contains empty lists, return empty list.\n\
    \        // If list is a nested list, but contains empty lists, return empty list.\n\
    \        // If list is a nested list, but contains empty lists, return empty list.\n\
    \        // If list is a nested list, but contains empty lists, return empty list.\n\
    \        // If list is a nested list, but contains empty lists, return empty list.\n\
    \        // If list is a nested list, but contains empty lists, return empty list.\n\
    \        // If list is a nested list, but contains empty lists, return empty list.\n\
    \        // If list is a nested list, but contains empty lists, return empty list.\n\
    \        // If list is a nested list, but contains empty lists", "        // Fill\
    \ up this function body\n        // `lst` is a list of lists, each list is a row\n\
    \        // `x` is the integer to be searched in the list\n        // Return a\
    \ list of tuples, each tuple is a coordinate - (row, column)\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        // For example, if lst is\
    \ [[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 1, 6], [1, 2, 3, 4, 5, 1]]\n        // and\
    \ x is 1, then return [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n        // Note:\n\
    \        // 1. If x is not found in the list, return an empty list.\n        //\
    \ 2. If lst is empty, return an empty list.\n        // 3. If lst is [[]] (a list\
    \ containing an empty list), return an empty list.\n        // 4. If lst is [[],\
    \ [1], [1, 2, 3]] (a list containing empty list and non-empty lists),\n      \
    \  //    return [(1, 0), (2, 0), (2, 1), (2, 2)]\n        // 5. If lst is [[1,\
    \ 2, 3], [], [1, 2, 3]] (a list containing non-empty lists and empty list),\n\
    \        //    return [(0, 0), (0, 1), (0, 2), (2, 0), (2, 1), (2, 2)]\n     \
    \   // 6. If lst is [[1, 2, 3], [1, 2, 3], []] (a list containing non-empty lists\
    \ and empty list),\n        //    return [(0, 0), (0, 1), (0, 2), (1, 0), (1,\
    \ 1), (1, 2)]\n        // 7. If lst is [[1, 2, 3], [1, 2, 3], [1, 2, 3]] (a list\
    \ containing non-empty lists),\n        //    return [(0, 0), (0, 1), (0, 2),\
    \ (1, 0), (1, 1), (1,", "        // Fill up this function body\n        // 'lst'\
    \ is a nested list, similar to matrix,\n        // 'x' is the integer to be searched\
    \ in the list\n        // Return a list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      // If the integer is not found in the list, return empty list.\n      \
    \  // If the list is empty, return empty list.\n        // If the list is not\
    \ empty, and the integer is not found, return empty list.\n        // If the list\
    \ is not empty, and the integer is found, return list of tuples.\n        // If\
    \ the list is not empty, and the integer is found, return list of tuples.\n  \
    \      // If the list is not empty, and the integer is found, return list of tuples.\n\
    \        // If the list is not empty, and the integer is found, return list of\
    \ tuples.\n        // If the list is not empty, and the integer is found, return\
    \ list of tuples.\n        // If the list is not empty, and the integer is found,\
    \ return list of tuples.\n        // If the list is not empty, and the integer\
    \ is found, return list of tuples.\n        // If the list is not empty, and the\
    \ integer is found, return list of tuples.\n        // If the list is not empty,\
    \ and the integer is found, return list of tuples.\n        // If the list is\
    \ not empty, and the integer is found, return list of tuples.\n        // If the\
    \ list is not empty, and the integer is found, return list of tuples.\n      \
    \  // If the list is not empty, and the integer is found, return list of tuples.\n\
    \        // If the list is not empty, and the integer is found, return list of\
    \ tuples.\n        // If the list is not empty, and the integer is found, return\
    \ list of tuples.\n        // If the list is not empty, and the integer is found,\
    \ return list of tuples.\n        // If the list is not empty, and the integer\
    \ is found, return list", "        val result = new ListBuffer[Tuple2[Long, Long]]\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result += Tuple2(i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.toList.sortWith((a,\
    \ b) => if (a._1 == b._1) a._2 > b._2 else a._1 < b._1)", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            var row : List[Long] = lst(i)\n           \
    \ for (j <- 0 until row.length) {\n                if (row(j) == x) {\n      \
    \              result = (i, j) :: result\n                }\n            }\n \
    \       }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => a._1 <\
    \ b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but each row may contain\
    \ a different number of columns.\n        // 'x' is an integer to be found in\
    \ the list.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If x\
    \ is not found in the list, return empty list.\n        // If lst is empty, return\
    \ empty list.\n        // If lst is not a nested list, return empty list.\n  \
    \      // If lst is a nested list, but each row is empty, return empty list.\n\
    \        // If lst is a nested list, but each row is not a list, return empty\
    \ list.\n        // If lst is a nested list, but each row is a list, but each\
    \ element is not an integer, return empty list.\n        // If lst is a nested\
    \ list, but each row is a list, but each element is an integer, but x is not an\
    \ integer, return empty list.\n        // If lst is a nested list, but each row\
    \ is a list, but each element is an integer, but x is an integer, but x is not\
    \ found in the list, return empty list.\n        // If lst is a nested list, but\
    \ each row is a list, but each element is an integer, but x is an integer, but\
    \ x is found in the list, return list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      // If x is not found in the list, return empty list.\n        // If lst\
    \ is empty, return empty list.\n        // If lst is not a nested list, return\
    \ empty list.\n        // If lst is a nested list, but each row is empty, return\
    \ empty list.\n        // If lst is a nested list, but each row", "        var\
    \ result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for\
    \ (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n\
    \                if (lst(i)(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, similar to matrix, but unlike\
    \ matrix,\n        // each row may contain a different number of columns.\n  \
    \      // 'x' is an integer.\n        // You have to find all the coordinates\
    \ of 'x' in the list,\n        // and return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If 'x' is not found in the list, return empty list.\n   \
    \     // If 'lst' is empty, return empty list.\n        // If 'lst' is a list\
    \ of empty lists, return empty list.\n        // Note: You can use any built-in\
    \ functions in Scala.\n        var result = List[Tuple2[Long, Long]]()\n     \
    \   for (i <- 0 to lst.length - 1) {\n            for (j <- 0 to lst(i).length\
    \ - 1) {\n                if (lst(i)(j) == x) {\n                    result =\
    \ result :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n\
    \        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            var row : List[Long] = lst(i)\n\
    \            for (j <- 0 until row.length) {\n                if (row(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => a._1 < b._1\
    \ || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, but each row may contain\
    \ a different number of columns.\n        // 'x' is the integer to be found in\
    \ the list.\n        // Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If x\
    \ is not found in the list, return empty list.\n        // If the list is empty,\
    \ return empty list.\n        // If the list is not a nested list, return empty\
    \ list.\n        // If the list is a nested list, but it is not a list of lists,\
    \ return empty list.\n        // If the list is a nested list, but it is not a\
    \ list of lists of integers, return empty list.\n        // If the list is a nested\
    \ list, but it is not a list of lists of integers, return empty list.\n      \
    \  // If the list is a nested list, but it is not a list of lists of integers,\
    \ return empty list.\n        // If the list is a nested list, but it is not a\
    \ list of lists of integers, return empty list.\n        // If the list is a nested\
    \ list, but it is not a list of lists of integers, return empty list.\n      \
    \  // If the list is a nested list, but it is not a list of lists of integers,\
    \ return empty list.\n        // If the list is a nested list, but it is not a\
    \ list of lists of integers, return empty list.\n        // If the list is a nested\
    \ list, but it is not a list of lists of integers, return empty list.\n      \
    \  // If the list is a nested list, but it is not a list of lists of integers,\
    \ return empty list.\n        // If the list is a nested list, but it is not a\
    \ list of lists of integers, return empty list.\n        // If the list is a nested\
    \ list, but it is not a list of lists of integers, return empty list.\n      \
    \  // If the list is a nested list, but it is not a list of lists of integers,\
    \ return empty list.\n        // If the list is", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, which is similar to matrix, however,\
    \ unlike matrices,\n        // each row may contain a different number of columns.\n\
    \        // Given lst, and integer x, find integers x in the list,\n        //\
    \ and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each\
    \ tuple is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // Examples:\n        // >>>\
    \ getRow((List[List[Long]](List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 1l.toLong, 6l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong))), (1l))\n        // (List[Tuple2[Long, Long]]((0l, 0l),\
    \ (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n        // >>> getRow((List[List[Long]]()),\
    \ (1l))\n        // (List[Tuple2[Long, Long]]())\n        // >>> getRow((List[List[Long]](List[Long](),\
    \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
    \        // (List[Tuple2[Long, Long]]((2l, 2l)))\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length - 1)\
    \ {\n            var row : List[Long] = lst(i)\n            for (j <- 0 to row.length\
    \ - 1", "        // Fill up this function body\n        // 'lst' is a nested list,\
    \ which is similar to matrix, however, unlike matrices,\n        // each row may\
    \ contain a different number of columns.\n        // 'x' is an integer\n     \
    \   // You have to return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        val result\
    \ = ListBuffer[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result += Tuple2(i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.toList.sortWith((a, b) =>\
    \ {\n            if (a._1 < b._1) true\n            else if (a._1 == b._1) a._2\
    \ > b._2\n            else false\n        })", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, which is similar to matrix,\n     \
    \   // however, unlike matrices, each row may contain a different number of columns.\n\
    \        // 'x' is an integer.\n        // You have to find integers 'x' in the\
    \ list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If 'x'\
    \ is not found in the list, return empty list.\n        // If 'lst' is empty,\
    \ return empty list.\n        // If 'lst' is a list of empty lists, return empty\
    \ list.\n        // If 'lst' is a list of lists of empty lists, return empty list.\n\
    \        // If 'lst' is a list of lists of lists of empty lists, return empty\
    \ list.\n        // If 'lst' is a list of lists of lists of lists of empty lists,\
    \ return empty list.\n        // If 'lst' is a list of lists of lists of lists\
    \ of lists of empty lists, return empty list.\n        // If 'lst' is a list of\
    \ lists of lists of lists of lists of lists of empty lists, return empty list.\n\
    \        // If 'lst' is a list of lists of lists of lists of lists of lists of\
    \ lists of empty lists, return empty list.\n        // If 'lst' is a list of lists\
    \ of lists of lists of lists of lists of lists of lists of empty lists, return\
    \ empty list.\n        // If 'lst' is a list of lists of lists of lists of lists\
    \ of lists of lists of lists of lists of empty lists, return empty list.\n   \
    \     // If 'lst' is a list of lists of lists of lists of lists of lists of lists\
    \ of lists of lists of lists of empty lists, return empty list.\n        // If\
    \ 'lst' is a list of lists of lists of lists of lists of lists of lists of lists\
    \ of lists of lists of lists of empty lists, return empty list.\n        // If\
    \ 'lst' is a list of lists of lists of", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, similar to matrix,\n        // however,\
    \ unlike matrices, each row may contain a different number of columns.\n     \
    \   // 'x' is an integer.\n        // You have to find integers x in the list,\n\
    \        // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n  \
    \      // each tuple is a coordinate - (row, columns), starting with 0.\n    \
    \    // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If x\
    \ is not found in the list, return empty list.\n        // If the list is empty,\
    \ return empty list.\n        // If the list is a list of empty lists, return\
    \ empty list.\n        // If the list is a list of list of empty lists, return\
    \ empty list.\n        // If the list is a list of list of list of empty lists,\
    \ return empty list.\n        // If the list is a list of list of list of list\
    \ of empty lists, return empty list.\n        // If the list is a list of list\
    \ of list of list of list of empty lists, return empty list.\n        // If the\
    \ list is a list of list of list of list of list of list of empty lists, return\
    \ empty list.\n        // If the list is a list of list of list of list of list\
    \ of list of list of empty lists, return empty list.\n        // If the list is\
    \ a list of list of list of list of list of list of list of list of empty lists,\
    \ return empty list.\n        // If the list is a list of list of list of list\
    \ of list of list of list of list of list of empty lists, return empty list.\n\
    \        // If the list is a list of list of list of list of list of list of list\
    \ of list of list of list of empty lists, return empty list.\n        // If the\
    \ list is a list of list of list of list of list of list of list of list of list\
    \ of list of list of empty lists, return empty list.\n        // If the list is\
    \ a list of list of list of list of list of list of list of list of list of list\
    \ of list of list of empty lists, return empty list.\n        // If the list is",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 < b._1) {\n            \
    \    true\n            } else if (a._1 == b._1) {\n                a._2 > b._2\n\
    \            } else {\n                false\n            }\n        })", "  \
    \      var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((x,\
    \ y) => x._1 < y._1 || (x._1 == y._1 && x._2 > y._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, similar to matrix,\n     \
    \   // 'x' is an integer,\n        // return a list of tuples, such that each\
    \ tuple is a coordinate - (row, columns),\n        // starting with 0.\n     \
    \   // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        var result\
    \ : List[Tuple2[Long, Long]] = List()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => a._1 < b._1\
    \ || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) result = result\
    \ :+ (i.toLong, j.toLong)\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        // Fill up this function\
    \ body\n        // 'lst' is a list of lists, and 'x' is the integer to be found\n\
    \        // Return a list of tuples, each tuple is a coordinate - (row, columns)\n\
    \        // Sort coordinates initially by rows in ascending order.\n        //\
    \ Also, sort coordinates of the row by columns in descending order.\n        var\
    \ result = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })", "        // Fill\
    \ up this function body\n        // 'lst' is a list of lists, and 'x' is an integer\n\
    \        // Return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n    \
    \    // each tuple is a coordinate - (row, columns), starting with 0.\n      \
    \  // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        var result\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = (i, j) :: result\n                }\n   \
    \         }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => {\n  \
    \          if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        // Fill up\
    \ this function body\n        // 'lst' is a nested list, similar to matrix,\n\
    \        // 'x' is the integer to find in the list\n        // You have to return\
    \ a list of tuples,\n        // each tuple is a coordinate - (row, columns),\n\
    \        // starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If 'x' is not found in the list, return empty\
    \ list.\n        // If 'lst' is empty, return empty list.\n        // If 'lst'\
    \ is not a nested list, return empty list.\n        // If 'lst' is not a list\
    \ of lists, return empty list.\n        // If 'lst' is a list of empty lists,\
    \ return empty list.\n        // If 'lst' is a list of lists, but not all lists\
    \ are of same length,\n        // return empty list.\n        // If 'lst' is a\
    \ list of lists, but not all lists are of type Long,\n        // return empty\
    \ list.\n        // If 'x' is not of type Long, return empty list.\n        //\
    \ If 'x' is of type Long, but not found in the list, return empty list.\n    \
    \    // If 'x' is of type Long, and found in the list, return list of tuples.\n\
    \        // If 'x' is of type Long, and found in the list, return list of tuples.\n\
    \        // If 'x' is of type Long, and found in the list, return list of tuples.\n\
    \        // If 'x' is of type Long, and found in the list, return list of tuples.\n\
    \        // If 'x' is of type Long, and found in the list, return list of tuples.\n\
    \        // If 'x' is of type Long, and found in the list, return list of tuples.\n\
    \        // If 'x' is of type Long, and found in the list, return list of tuples.\n\
    \        // If 'x' is of type Long, and found in the list, return list of tuples.\n\
    \        // If 'x' is of type Long, and found in the list, return list of tuples.\n\
    \        // If 'x'", "        var result : List[Tuple2[Long, Long]] = List()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        // Fill up this function body\n        // `lst` is a nested list, which\
    \ is similar to matrix,\n        // however, unlike matrices, each row may contain\
    \ a different number of columns.\n        // Given lst, and integer x, find integers\
    \ x in the list,\n        // and return list of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // Examples:\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n        //\
    \ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n\
    \        // >>> getRow((List[List[Long]]()), (1l))\n        // (List[Tuple2[Long,\
    \ Long]]())\n        // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong),\
    \ List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n        // (List[Tuple2[Long,\
    \ Long]]((2l, 2l)))\n        var result = List[Tuple2[Long, Long]]()\n       \
    \ for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.", "        // Fill up this function body\n        // `lst` is a list\
    \ of lists, and `x` is an integer.\n        // Return a list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\n        // each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If there are no such coordinates, return empty\
    \ list.\n        // If there are multiple such coordinates, return all of them.\n\
    \        // If there are no rows, return empty list.\n        // If there are\
    \ no columns in a row, return empty list.\n        // If there are no elements\
    \ in a column, return empty list.\n        // If there are no elements in the\
    \ list, return empty list.\n        // If there are no elements in the list of\
    \ lists, return empty list.\n        // If there are no elements in the list of\
    \ lists of lists, return empty list.\n        // If there are no elements in the\
    \ list of lists of lists of lists, return empty list.\n        // If there are\
    \ no elements in the list of lists of lists of lists of lists, return empty list.\n\
    \        // If there are no elements in the list of lists of lists of lists of\
    \ lists of lists, return empty list.\n        // If there are no elements in the\
    \ list of lists of lists of lists of lists of lists of lists, return empty list.\n\
    \        // If there are no elements in the list of lists of lists of lists of\
    \ lists of lists of lists of lists, return empty list.\n        // If there are\
    \ no elements in the list of lists of lists of lists of lists of lists of lists\
    \ of lists of lists, return empty list.\n        // If there are no elements in\
    \ the list of lists of lists of lists of lists of lists of lists of lists of lists\
    \ of lists, return empty list.\n        // If there are no elements in the list\
    \ of lists of lists of lists of lists of lists of lists of lists of lists of lists\
    \ of lists, return empty list.\n        // If there are no elements in the list\
    \ of lists of lists of lists of lists of lists of lists of lists of lists of lists\
    \ of lists of lists, return empty list.\n        // If there are no elements in\
    \ the list", "        var res = List[Tuple2[Long, Long]]()\n        for (i <-\
    \ 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n    \
    \            if (lst(i)(j) == x) {\n                    res = res :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        res.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // `lst` is a list of lists, where each list is a row\n\
    \        // `x` is the number to be searched in the list\n        // Return a\
    \ list of tuples, each tuple is a coordinate - (row, column)\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        val result = ListBuffer[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            val row = lst(i)\n\
    \            for (j <- 0 until row.length) {\n                if (row(j) == x)\
    \ {\n                    result += Tuple2(i.toLong, j.toLong)\n              \
    \  }\n            }\n        }\n        result.toList.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, which is similar to matrix, however,\
    \ unlike matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer\n        // You have to return list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that\n        // each tuple is a coordinate - (row,\
    \ columns), starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        lst.zipWithIndex.flatMap(x => x._1.zipWithIndex.filter(y\
    \ => y._1 == x._2).map(y => (x._2, y._2))).sortBy(x => (x._1, -x._2))", "    \
    \    var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        // Fill up this function body\n        // 'lst' is a nested list, which\
    \ is similar to matrix, however, unlike matrices,\n        // each row may contain\
    \ a different number of columns.\n        // 'x' is an integer.\n        // You\
    \ have to find integers 'x' in the list,\n        // and return list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n           \
    \     a._2 > b._2\n            } else {\n                a._1 < b._1\n       \
    \     }\n        })", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        // Fill up this function body\n        // 'lst' is\
    \ a nested list, and 'x' is an integer\n        // You have to return a list of\
    \ tuples,\n        // where each tuple is a coordinate - (row, columns),\n   \
    \     // starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        var lst1 = List[Tuple2[Long, Long]]()\n        for (i <- 0 to\
    \ lst.length - 1) {\n            for (j <- 0 to lst(i).length - 1) {\n       \
    \         if (lst(i)(j) == x) {\n                    lst1 = lst1 :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        lst1.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, which is similar to matrix,\n\
    \        // however, unlike matrices, each row may contain a different number\
    \ of columns.\n        // 'x' is an integer, which is to be found in the list.\n\
    \        // Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n      \
    \  // each tuple is a coordinate - (row, columns), starting with 0.\n        //\
    \ Sort coordinates initially by rows in ascending order.\n        // Also, sort\
    \ coordinates of the row by columns in descending order.\n        var result =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = (i, j) :: result\n                }\n      \
    \      }\n        }\n        result.sortWith((a, b) => if (a._1 == b._1) a._2\
    \ > b._2 else a._1 < b._1)", "        // Fill up this function body\n        //\
    \ `lst` is a nested list, similar to matrix,\n        // however, unlike matrices,\
    \ each row may contain a different number of columns.\n        // `x` is an integer.\n\
    \        // You have to find integers `x` in the list,\n        // and return\
    \ list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If you find no `x` in the\
    \ list, return an empty list.\n        // If you find `x` in the list, return\
    \ a list of tuples.\n        // If you find `x` multiple times in the list, return\
    \ a list of tuples.\n        // If you find `x` multiple times in the same row,\
    \ return a list of tuples.\n        // If you find `x` multiple times in the same\
    \ row,\n        // sort coordinates of the row by columns in descending order.\n\
    \        // If you find `x` multiple times in the same row,\n        // sort coordinates\
    \ of the row by columns in descending order.\n        // If you find `x` multiple\
    \ times in the same row,\n        // sort coordinates of the row by columns in\
    \ descending order.\n        // If you find `x` multiple times in the same row,\n\
    \        // sort coordinates of the row by columns in descending order.\n    \
    \    // If you find `x` multiple times in the same row,\n        // sort coordinates\
    \ of the row by columns in descending order.\n        // If you find `x` multiple\
    \ times in the same row,\n        // sort coordinates of the row by columns in\
    \ descending order.\n        // If you find `x` multiple times in the same row,\n\
    \        // sort coordinates of the row by columns in descending order.\n    \
    \    // If you find `x` multiple times in the same row,\n        // sort coordinates\
    \ of the row by columns in descending order.\n        // If you find `x` multiple\
    \ times in the same row,\n        // sort coordinates of the row by columns in\
    \ descending order.\n        // If you find `x` multiple times in the same row,",
  "        // Fill up this function body\n        // 'lst' is a nested list, similar\
    \ to matrix,\n        // 'x' is an integer to be searched in the list\n      \
    \  // Return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n        //\
    \ each tuple is a coordinate - (row, columns), starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        var result = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        var result : List[Tuple2[Long, Long]]\
    \ = List()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = (i, j) :: result\n                }\n            }\n        }\n  \
    \      result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        // Fill up this function body\n        // 'lst' is a nested list, similar\
    \ to matrix, but unlike matrix,\n        // each row may contain a different number\
    \ of columns.\n        // 'x' is an integer.\n        // You have to find all\
    \ the integers 'x' in the list,\n        // and return list of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        var result = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a list of lists\n        // 'x' is the element\
    \ to be searched for\n        // You have to return a list of tuples\n       \
    \ // Each tuple is a coordinate - (row, column)\n        // Sort the tuples initially\
    \ by rows in ascending order\n        // Also, sort the tuples of the row by columns\
    \ in descending order\n        var result = List[Tuple2[Long, Long]]()\n     \
    \   for (i <- 0 until lst.length) {\n            var row = lst(i)\n          \
    \  for (j <- 0 until row.length) {\n                if (row(j) == x) {\n     \
    \               result = result :+ (i.toLong, j.toLong)\n                }\n \
    \           }\n        }\n        result.sortWith((a, b) => if (a._1 == b._1)\
    \ a._2 > b._2 else a._1 < b._1)", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        return\
    \ result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", " \
    \       var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n \
    \       for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))",
  "        // Fill up this function body\n        // 'lst' is a list of lists\n  \
    \      // 'x' is the element to be searched\n        // You have to return a list\
    \ of tuples\n        // [(x1, y1), (x2, y2) ...] such that\n        // each tuple\
    \ is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        val lst1 = lst.zipWithIndex\n\
    \        val lst2 = lst1.map(x => x._1.zipWithIndex.filter(y => y._1 == x._2).map(y\
    \ => (x._2, y._2)))\n        val lst3 = lst2.filter(x => x.length > 0)\n     \
    \   val lst4 = lst3.map(x => x.map(y => (y._1, y._2)))\n        val lst5 = lst4.flatten\n\
    \        val lst6 = lst5.sortBy(x => x._1)\n        val lst7 = lst6.sortBy(x =>\
    \ x._2)\n        lst7", "        // Fill up this function body\n        // 'lst'\
    \ is a nested list of integers\n        // 'x' is an integer to be searched in\
    \ the nested list\n        // Return a list of tuples, [(x1, y1), (x2, y2) ...]\
    \ such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If x is not found in the nested list, return an empty list.\n    \
    \    // If the nested list is empty, return an empty list.\n        // If the\
    \ nested list is None, return an empty list.\n        // If the nested list is\
    \ not a list of lists, return an empty list.\n        // If the nested list is\
    \ not a list of integers, return an empty list.\n        // If the nested list\
    \ is not a list of lists of integers, return an empty list.\n        // If the\
    \ nested list is not a list of lists of integers, return an empty list.\n    \
    \    // If the nested list is not a list of lists of integers, return an empty\
    \ list.\n        // If the nested list is not a list of lists of integers, return\
    \ an empty list.\n        // If the nested list is not a list of lists of integers,\
    \ return an empty list.\n        // If the nested list is not a list of lists\
    \ of integers, return an empty list.\n        // If the nested list is not a list\
    \ of lists of integers, return an empty list.\n        // If the nested list is\
    \ not a list of lists of integers, return an empty list.\n        // If the nested\
    \ list is not a list of lists of integers, return an empty list.\n        // If\
    \ the nested list is not a list of lists of integers, return an empty list.\n\
    \        // If the nested list is not a list of lists of integers, return an empty\
    \ list.\n        // If the nested list is not a list of lists of integers, return\
    \ an empty list.\n        // If the nested list is not a list of lists of integers,\
    \ return an empty list.\n        // If the nested list is not a list of lists\
    \ of integers, return an empty list.\n        // If the nested list is not a list\
    \ of lists of integers, return an empty list.", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, which is similar to matrix, however,\
    \ unlike matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer\n        // You have to return a list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((x, y) => {\n            if (x._1 < y._1) {\n            \
    \    true\n            } else if (x._1 == y._1) {\n                x._2 > y._2\n\
    \            } else {\n                false\n            }\n        })", "  \
    \      // Fill up this function body\n        // 'lst' is a nested list, similar\
    \ to matrix, but unlike matrix,\n        // each row may contain a different number\
    \ of columns.\n        // 'x' is an integer to be found in the list.\n       \
    \ // Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each\
    \ tuple is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If x is not found in the\
    \ list, return empty list.\n        // If lst is empty, return empty list.\n \
    \       var result = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List()\n        for (i <- 0 until lst.length) {\n            for (j\
    \ <- 0 until lst(i).length) {\n                if (lst(i)(j) == x) {\n       \
    \             result = result :+ (i.toLong, j.toLong)\n                }\n   \
    \         }\n        }\n        result.sortWith((a, b) => if (a._1 == b._1) a._2\
    \ > b._2 else a._1 < b._1)", "        // Fill up this function body\n        //\
    \ 'lst' is a list of lists, each list is a row\n        // 'x' is the integer\
    \ you need to find in the list\n        // Return a list of tuples, each tuple\
    \ is a coordinate - (row, columns)\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = new ListBuffer[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result += Tuple2(i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.toList.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, and 'x' is an integer\n  \
    \      // You have to return a list of tuples,\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If there is no 'x' in the list, return empty\
    \ list.\n        var result = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, similar to matrix,\n     \
    \   // however, unlike matrices, each row may contain a different number of columns.\n\
    \        // 'x' is an integer, which you need to find in the list.\n        //\
    \ Return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple\
    \ is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If x is not found in the\
    \ list, return empty list.\n        // If list is empty, return empty list.\n\
    \        // If list is None, return empty list.\n        // If list is not a list\
    \ of lists, return empty list.\n        // If list is not a list of lists of integers,\
    \ return empty list.\n        // If list is not a list of lists of integers, return\
    \ empty list.\n        // If list is not a list of lists of integers, return empty\
    \ list.\n        // If list is not a list of lists of integers, return empty list.\n\
    \        // If list is not a list of lists of integers, return empty list.\n \
    \       // If list is not a list of lists of integers, return empty list.\n  \
    \      // If list is not a list of lists of integers, return empty list.\n   \
    \     // If list is not a list of lists of integers, return empty list.\n    \
    \    // If list is not a list of lists of integers, return empty list.\n     \
    \   // If list is not a list of lists of integers, return empty list.\n      \
    \  // If list is not a list of lists of integers, return empty list.\n       \
    \ // If list is not a list of lists of integers, return empty list.\n        //\
    \ If list is not a list of lists of integers, return empty list.\n        // If\
    \ list is not a list of lists of integers, return empty list.\n        // If list\
    \ is not a list of lists of integers, return empty list.\n        // If list is\
    \ not a list of lists of integers, return empty list.\n        // If list is not\
    \ a list of lists of integers, return empty list.\n        // If list is not a\
    \ list of lists of integers, return", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, and 'x' is an integer\n        // You have\
    \ to return a list of tuples,\n        // where each tuple is a coordinate - (row,\
    \ columns),\n        // starting with 0.\n        // Sort coordinates initially\
    \ by rows in ascending order.\n        // Also, sort coordinates of the row by\
    \ columns in descending order.\n        var result = List[Tuple2[Long, Long]]()\n\
    \        for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 == b._1) {\n           \
    \     a._2 > b._2\n            } else {\n                a._1 < b._1\n       \
    \     }\n        })", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 to lst.length - 1) {\n            for (j <- 0\
    \ to lst(i).length - 1) {\n                if (lst(i)(j) == x) {\n           \
    \         result = result :+ (i.toLong, j.toLong)\n                }\n       \
    \     }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 ==\
    \ b._1 && a._2 > b._2))", "        // Fill up this function body\n        // 'lst'\
    \ is a nested list, similar to matrix,\n        // 'x' is an integer to be searched\
    \ in the list\n        // Return a list of tuples, [(x1, y1), (x2, y2) ...]\n\
    \        // such that each tuple is a coordinate - (row, columns),\n        //\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        var result = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = (i, j) :: result\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ if (a._1 == b._1) a._2 > b._2 else a._1 < b._1)", "        // Fill up this function\
    \ body\n        // 'lst' is a list of lists\n        // 'x' is the element to\
    \ be searched in the list\n        // Return a list of tuples, each tuple is a\
    \ coordinate - (row, columns)\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        var result = List[Tuple2[Long, Long]]()\n       \
    \ for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            var row : List[Long] = lst(i)\n\
    \            for (j <- 0 until row.length) {\n                if (row(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => a._1 < b._1\
    \ || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, however, unlike matrices,\n\
    \        // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer to be searched in the list.\n        // You have to return a list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        // Fill up this function body\n        // 'lst' is a list of lists\n  \
    \      // 'x' is the element to be searched\n        // You have to return a list\
    \ of tuples\n        // Each tuple is a coordinate - (row, column)\n        //\
    \ Sort coordinates initially by rows in ascending order\n        // Also, sort\
    \ coordinates of the row by columns in descending order\n        // If the element\
    \ is not found, return an empty list\n        // If the list is empty, return\
    \ an empty list\n        // If the list is empty, return an empty list\n     \
    \   // If the list is empty, return an empty list\n        // If the list is empty,\
    \ return an empty list\n        // If the list is empty, return an empty list\n\
    \        // If the list is empty, return an empty list\n        // If the list\
    \ is empty, return an empty list\n        // If the list is empty, return an empty\
    \ list\n        // If the list is empty, return an empty list\n        // If the\
    \ list is empty, return an empty list\n        // If the list is empty, return\
    \ an empty list\n        // If the list is empty, return an empty list\n     \
    \   // If the list is empty, return an empty list\n        // If the list is empty,\
    \ return an empty list\n        // If the list is empty, return an empty list\n\
    \        // If the list is empty, return an empty list\n        // If the list\
    \ is empty, return an empty list\n        // If the list is empty, return an empty\
    \ list\n        // If the list is empty, return an empty list\n        // If the\
    \ list is empty, return an empty list\n        // If the list is empty, return\
    \ an empty list\n        // If the list is empty, return an empty list\n     \
    \   // If the list is empty, return an empty list\n        // If the list is empty,\
    \ return an empty list\n        // If the list is empty, return an empty list\n\
    \        // If the list is empty, return an empty list\n        // If the list\
    \ is empty, return an empty list\n        // If the list is empty, return an empty\
    \ list\n        // If the list is empty, return an empty list\n        // If the\
    \ list is empty, return an empty list\n        // If the list is empty, return\
    \ an empty list\n        // If the list is empty, return an", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, similar to matrix, but unlike\
    \ matrix,\n        // each row may contain a different number of columns.\n  \
    \      // 'x' is an integer.\n        // Return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        val result = new ListBuffer[Tuple2[Long, Long]]()\n        for\
    \ (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n\
    \                if (lst(i)(j) == x) {\n                    result += ((i.toLong,\
    \ j.toLong))\n                }\n            }\n        }\n        result.toList.sortWith((a,\
    \ b) => if (a._1 == b._1) a._2 > b._2 else a._1 < b._1)", "        // Fill up\
    \ this function body\n        // 'lst' is a nested list, similar to matrix, but\
    \ unlike matrix,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer, which is to be found in the list.\n        // Return\
    \ list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is\
    \ a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If x is not found in the\
    \ list, return empty list.\n        // If list is empty, return empty list.\n\
    \        // For example,\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n        //\
    \ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n\
    \        // >>> getRow((List[List[Long]]()), (1l))\n        // (List[Tuple2[Long,\
    \ Long]]())\n        // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong),\
    \ List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n        // (List[Tuple2[Long,\
    \ Long]]((2l, 2l)))\n        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        var row : Long = 0\n        for (i <- lst) {\n", "       \
    \ var result : List[Tuple2[Long, Long]] = List()\n        for (i <- 0 until lst.length)\
    \ {\n            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => {\n            if\
    \ (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n      \
    \          a._1 < b._1\n            }\n        })", "        // Fill up this function\
    \ body\n        // 'lst' is a nested list, which is similar to matrix, however,\
    \ unlike matrices,\n        // each row may contain a different number of columns.\n\
    \        // 'x' is an integer to be found in the list.\n        // You have to\
    \ return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple\
    \ is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        // If the integer 'x' is not\
    \ found in the list, return empty list.\n        // If the list is empty, return\
    \ empty list.\n        // If the list is None, return empty list.\n        //\
    \ Note:\n        // The list may contain duplicate elements.\n        // The list\
    \ may contain None.\n        // The list may contain empty lists.\n        //\
    \ The list may contain empty lists at the end.\n        // The list may contain\
    \ empty lists in between.\n        // The list may contain empty lists at the\
    \ beginning.\n        // The list may contain empty lists at the beginning and\
    \ end.\n        // The list may contain empty lists in between and at the beginning\
    \ and end.\n        // The list may contain empty lists at the beginning and end\
    \ and in between.\n        // The list may contain empty lists at the beginning\
    \ and end and in between and in the middle.\n        // The list may contain empty\
    \ lists at the beginning and end and in between and in the middle and everywhere.\n\
    \        // The list may contain empty lists at the beginning and end and in between\
    \ and in the middle and everywhere and nowhere.\n        // The list may contain\
    \ empty lists at the beginning and end and in between and in the middle and everywhere\
    \ and nowhere and everywhere.\n        // The list may contain empty lists at\
    \ the beginning and end and in between and in the middle and everywhere and nowhere\
    \ and everywhere and nowhere.\n        // The list may contain empty lists at\
    \ the beginning and end and in between and in the middle and everywhere and nowhere\
    \ and everywhere and nowhere and everywhere.\n        // The list may contain\
    \ empty lists at the beginning and end and in between and in the middle and everywhere\
    \ and nowhere and everywhere and nowhere and everywhere and nowhere.\n       \
    \ // The list may contain empty lists at", "        // Fill up this function body\n\
    \        // 'lst' is a list of lists, which is similar to matrix,\n        //\
    \ however, unlike matrices, each row may contain a different number of columns.\n\
    \        // Given lst, and integer x, find integers x in the list,\n        //\
    \ and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each\
    \ tuple is a coordinate - (row, columns), starting with 0.\n        // Sort coordinates\
    \ initially by rows in ascending order.\n        // Also, sort coordinates of\
    \ the row by columns in descending order.\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        var row : Long = 0\n        for\
    \ (i <- lst) {\n            var col : Long = 0\n            for (j <- i) {\n \
    \               if (j == x) {\n                    result = result :+ (row, col)\n\
    \                }\n                col += 1\n            }\n            row +=\
    \ 1\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1\
    \ && a._2 > b._2))", "        // Fill up this function body\n        // `lst`\
    \ is a nested list, similar to matrix,\n        // but each row may contain a\
    \ different number of columns.\n        // `x` is an integer to be found in the\
    \ list.\n        // Return a list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
    \        // each tuple is a coordinate - (row, columns), starting with 0.\n  \
    \      // Sort coordinates initially by rows in ascending order.\n        // Also,\
    \ sort coordinates of the row by columns in descending order.\n        // If `x`\
    \ is not found in the list, return an empty list.\n        // If `lst` is empty,\
    \ return an empty list.\n        // If `lst` is a list of empty lists, return\
    \ an empty list.\n        // If `lst` is a list of lists, where each list is empty,\n\
    \        // return an empty list.\n        // If `lst` is a list of lists, where\
    \ each list contains\n        // only one element, and that element is `x`, return\
    \ a list\n        // of tuples, where each tuple is a coordinate - (row, 0).\n\
    \        // If `lst` is a list of lists, where each list contains\n        //\
    \ only one element, and that element is not `x`, return an\n        // empty list.\n\
    \        // If `lst` is a list of lists, where each list contains\n        //\
    \ only one element, and that element is `x`, return a list\n        // of tuples,\
    \ where each tuple is a coordinate - (row, 0).\n        // If `lst` is a list\
    \ of lists, where each list contains\n        // only one element, and that element\
    \ is not `x`, return an\n        // empty list.\n        // If `lst` is a list\
    \ of lists, where each list contains\n        // only one element, and that element\
    \ is `x`, return a list\n        // of tuples, where each tuple is a coordinate\
    \ - (row, 0).\n        // If `lst` is a list of lists, where each list contains\n\
    \        // only one element, and that element is not `x`, return an\n       \
    \ // empty list.\n        // If `lst` is a list of lists, where each", "     \
    \   // Fill up this function body\n        // `lst` is a nested list, which is\
    \ similar to matrix,\n        // however, unlike matrices, each row may contain\
    \ a different number of columns.\n        // `x` is an integer to be searched\
    \ in the list.\n        // You have to return a list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        var result = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })", " \
    \       // Fill up this function body\n        // 'lst' is a nested list, similar\
    \ to matrix, however, unlike matrices,\n        // each row may contain a different\
    \ number of columns.\n        // 'x' is an integer\n        // You have to find\
    \ integers x in the list,\n        // and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // For example,\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n        //\
    \ (List[Tuple2[Long, Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n\
    \        // >>> getRow((List[List[Long]]()), (1l))\n        // (List[Tuple2[Long,\
    \ Long]]())\n        // >>> getRow((List[List[Long]](List[Long](), List[Long](1l.toLong),\
    \ List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n        // (List[Tuple2[Long,\
    \ Long]]((2l, 2l)))\n        // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
    \ 2l.to", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n\
    \        var row : Long = 0\n        for (rowList <- lst) {\n            var col\
    \ : Long = 0\n            for (element <- rowList) {\n                if (element\
    \ == x) {\n                    result = result :+ (row, col)\n               \
    \ }\n                col += 1\n            }\n            row += 1\n        }\n\
    \        result.sortWith((a, b) => if (a._1 < b._1) true else if (a._1 == b._1)\
    \ a._2 > b._2 else false)", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => (a._1 < b._1) || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] = List()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        // Fill up this function body\n        // `lst` is a nested list, similar\
    \ to matrix,\n        // however, unlike matrices, each row may contain a different\
    \ number of columns.\n        // `x` is an integer.\n        // You need to find\
    \ integers `x` in the list,\n        // and return list of tuples, [(x1, y1),\
    \ (x2, y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If `x` is not found in the list, return empty list.\n   \
    \     // If `lst` is empty, return empty list.\n        // If `lst` is a list\
    \ of empty lists, return empty list.\n        // If `lst` is a list of lists,\
    \ each of which is empty, return empty list.\n        // If `lst` is a list of\
    \ lists, each of which is a list of empty lists, return empty list.\n        //\
    \ If `lst` is a list of lists, each of which is a list of lists, each of which\
    \ is empty, return empty list.\n        // If `lst` is a list of lists, each of\
    \ which is a list of lists, each of which is a list of empty lists, return empty\
    \ list.\n        // If `lst` is a list of lists, each of which is a list of lists,\
    \ each of which is a list of lists, each of which is empty, return empty list.\n\
    \        // If `lst` is a list of lists, each of which is a list of lists, each\
    \ of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n        // If `lst` is a list of lists, each of which is a list\
    \ of lists, each of which is a list of lists, each of which is a list of lists,\
    \ each of which is empty, return empty list.\n        // If `lst` is a list of\
    \ lists, each of which is a list of lists, each of which is a list of lists, each\
    \ of which is a list of lists, each of which is a list of empty lists, return\
    \ empty list.\n       ", "        // Fill up this function body\n        // 'lst'\
    \ is a nested list, which is similar to matrix,\n        // however, unlike matrices,\
    \ each row may contain a different number of columns.\n        // 'x' is an integer\
    \ to be found in the list.\n        // Return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n        // each tuple is a coordinate - (row, columns),\
    \ starting with 0.\n        // Sort coordinates initially by rows in ascending\
    \ order.\n        // Also, sort coordinates of the row by columns in descending\
    \ order.\n        // If x is not found in the list, return empty list.\n     \
    \   // If the list is empty, return empty list.\n        // If the list is null,\
    \ return empty list.\n        // If the list is not a nested list, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers, return empty\
    \ list.\n        // If the list is not a nested list of integers,", "        var\
    \ result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for\
    \ (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n\
    \                if (lst(i)(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => (a._1 < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ to lst.length - 1) {\n            for (j <- 0 to lst(i).length - 1) {\n    \
    \            if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 == b._1) {\n                a._2 > b._2\n    \
    \        } else {\n                a._1 < b._1\n            }\n        })", " \
    \       var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n \
    \       for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 < b._1) {\n            \
    \    true\n            } else if (a._1 == b._1) {\n                a._2 > b._2\n\
    \            } else {\n                false\n            }\n        })", "  \
    \      var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            var row : List[Long] = lst(i)\n\
    \            for (j <- 0 until row.length) {\n                if (row(j) == x)\
    \ {\n                    result = result :+ (i.toLong, j.toLong)\n           \
    \     }\n            }\n        }\n        result.sortWith((a, b) => a._1 < b._1\
    \ || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            var row : List[Long] = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => if (a._1 == b._1) a._2 > b._2 else a._1 < b._1)", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ until lst.length) {\n            for (j <- 0 until lst(i).length) {\n      \
    \          if (lst(i)(j) == x) {\n                    result = (i, j) :: result\n\
    \                }\n            }\n        }\n        result.sortWith((a, b) =>\
    \ a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => (a._1\
    \ < b._1) || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => {\n\
    \            if (a._1 == b._1) {\n                a._2 > b._2\n            } else\
    \ {\n                a._1 < b._1\n            }\n        })", "        var result\
    \ : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0\
    \ to lst.length - 1) {\n            for (j <- 0 to lst(i).length - 1) {\n    \
    \            if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => {\n            if (a._1 < b._1) {\n                true\n            }\
    \ else if (a._1 == b._1) {\n                a._2 > b._2\n            } else {\n\
    \                false\n            }\n        })", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        var row : Long = 0\n        for\
    \ (i <- lst) {\n            var col : Long = 0\n            for (j <- i) {\n \
    \               if (j == x) {\n                    result = result :+ (row, col)\n\
    \                }\n                col += 1\n            }\n            row +=\
    \ 1\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1\
    \ && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        // Fill up this function body\n        // 'lst' is\
    \ a nested list, which is similar to matrix, however, unlike matrices,\n     \
    \   // each row may contain a different number of columns.\n        // 'x' is\
    \ an integer to be searched in the nested list.\n        // Return list of tuples,\
    \ [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate -\
    \ (row, columns), starting with 0.\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        var result = List[Tuple2[Long, Long]]()\n    \
    \    for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => {\n            if (a._1 < b._1) true\n         \
    \   else if (a._1 == b._1) a._2 > b._2\n            else false\n        })", " \
    \       var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n \
    \       for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))"]
stop_tokens:
- "\n    }\n"
