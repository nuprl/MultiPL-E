name: HumanEval_87_get_row
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a 2 dimensional data, as a nested lists,\n    // which is\
  \ similar to matrix, however, unlike matrices,\n    // each row may contain a different\
  \ number of columns.\n    // Given lst, and integer x, find integers x in the list,\n\
  \    // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    // each\
  \ tuple is a coordinate - (row, columns), starting with 0.\n    // Sort coordinates\
  \ initially by rows in ascending order.\n    // Also, sort coordinates of the row\
  \ by columns in descending order.\n    // Examples:\n    // >>> getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l))\n    // (List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))\n    // >>> getRow((List[List[Long]]()),\
  \ (1l))\n    // (List[Tuple2[Long, Long]]())\n    // >>> getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l))\n\
  \    // (List[Tuple2[Long, Long]]((2l, 2l)))\n    def getRow(lst : List[List[Long]],\
  \ x : Long) : List[Tuple2[Long, Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 4l), (1l, 0l), (2l, 5l), (2l, 0l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong))), (2l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 1l), (1l, 1l), (2l, 1l), (3l, 1l), (4l, 1l), (5l, 1l)))));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 1l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 4l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 1l.toLong, 5l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 6l.toLong), List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong))), (1l)).equals((List[Tuple2[Long,\
  \ Long]]((0l, 0l), (1l, 0l), (2l, 1l), (2l, 0l), (3l, 2l), (3l, 0l), (4l, 3l), (4l,\
  \ 0l), (5l, 4l), (5l, 0l), (6l, 5l), (6l, 0l)))));\n    assert(getRow((List[List[Long]]()),\
  \ (1l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](1l.toLong))),\
  \ (2l)).equals((List[Tuple2[Long, Long]]())));\n    assert(getRow((List[List[Long]](List[Long](),\
  \ List[Long](1l.toLong), List[Long](1l.toLong, 2l.toLong, 3l.toLong))), (3l)).equals((List[Tuple2[Long,\
  \ Long]]((2l, 2l)))));\n    }\n\n}\n"
completions: ["        // Fill up this function body\n        // `lst` is a list of\
    \ lists\n        // `x` is the element to find\n        // You have to return\
    \ a list of tuples\n        // Each tuple is a coordinate - (row, column)\n  \
    \      // Sort coordinates initially by rows in ascending order\n        // Also,\
    \ sort coordinates of the row by columns in descending order\n        // If `x`\
    \ is not found in `lst`, return empty list\n        // If `lst` is empty, return\
    \ empty list\n        var result = List[Tuple2[Long, Long]]()\n        for (i\
    \ <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length) {\n \
    \               if (lst(i)(j) == x) {\n                    result = result :+\
    \ (i.toLong, j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            for (j <- 0 until lst(i).length) {\n            \
    \    if (lst(i)(j) == x) {\n                    result = result :+ (i.toLong,\
    \ j.toLong)\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result :\
    \ List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until\
    \ lst.length) {\n            val row = lst(i)\n            for (j <- 0 until row.length)\
    \ {\n                if (row(j) == x) {\n                    result = (i, j) ::\
    \ result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, which is similar to matrix,\
    \ however, unlike matrices,\n        // each row may contain a different number\
    \ of columns.\n        // 'x' is an integer\n        // You have to return a list\
    \ of tuples, [(x1, y1), (x2, y2) ...] such that\n        // each tuple is a coordinate\
    \ - (row, columns), starting with 0.\n        // Sort coordinates initially by\
    \ rows in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If there are no coordinates, return empty list.\n        // If there\
    \ are no coordinates, return empty list.\n        // If there are no coordinates,\
    \ return empty list.\n        // If there are no coordinates, return empty list.\n\
    \        // If", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 == b._1)\
    \ {\n                a._2 > b._2\n            } else {\n                a._1 <\
    \ b._1\n            }\n        })", "        var result : List[Tuple2[Long, Long]]\
    \ = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n    \
    \        for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) ==\
    \ x) {\n                    result = result :+ (i.toLong, j.toLong)\n        \
    \        }\n            }\n        }\n        result.sortWith((a, b) => a._1 <\
    \ b._1 || (a._1 == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = (i, j) :: result\n                }\n\
    \            }\n        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1\
    \ == b._1 && a._2 > b._2))", "        var result : List[Tuple2[Long, Long]] =\
    \ List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n      \
    \      for (j <- 0 until lst(i).length) {\n                if (lst(i)(j) == x)\
    \ {\n                    result = (i, j) :: result\n                }\n      \
    \      }\n        }\n        result.sortWith((a, b) => {\n            if (a._1\
    \ == b._1) {\n                a._2 > b._2\n            } else {\n            \
    \    a._1 < b._1\n            }\n        })", "        val lst2 = lst.zipWithIndex.map(x\
    \ => x._1.zipWithIndex.map(y => (x._2, y._2, y._1))).flatten.filter(x => x._3\
    \ == x).map(x => (x._1, x._2)).sortWith((x, y) => x._1 < y._1 || (x._1 == y._1\
    \ && x._2 > y._2))\n        return lst2", "        // Fill up this function body\n\
    \        // 'lst' is a nested list, similar to matrix, however, unlike matrices,\n\
    \        // each row may contain a different number of columns.\n        // 'x'\
    \ is an integer.\n        // You have to find integers x in the list,\n      \
    \  // and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n        //\
    \ each tuple is a coordinate - (row, columns), starting with 0.\n        // Sort\
    \ coordinates initially by rows in ascending order.\n        // Also, sort coordinates\
    \ of the row by columns in descending order.\n        // If x is not found in\
    \ the list, return empty list.\n        // If the list is empty, return empty\
    \ list.\n        // Note:\n        // 1. You can assume that x is always present\
    \ in the list.\n        // 2. You can assume that the list is not empty.\n   \
    \     // 3. You can assume that the list is not null.\n        // 4. You can assume\
    \ that the list is not a string.\n        // 5. You can assume that the list is\
    \ not a set.\n        // 6. You can assume that the list is not a map.\n     \
    \   // 7. You can assume that the list is not a vector.\n        // 8. You can\
    \ assume that the list is not a stream.\n        // 9. You can assume that the\
    \ list is not a sequence.\n        // 10. You can assume that the list is not\
    \ a range.\n        // 11. You can assume that the list is not a queue.\n    \
    \    // 12. You can assume that the list is not a stack.\n        // 13. You can\
    \ assume that the list is not a priority queue.\n        // 14. You can assume\
    \ that the list is not a deque.\n        // 15. You can assume that the list is\
    \ not a double ended queue.\n        // 16. You can assume that the list is not\
    \ a linked list.\n        // 17. You can assume that the list is not a doubly\
    \ linked list.\n        // 18. You can assume that the list is not a circular\
    \ linked list.\n        // 19. You can assume that the list is not a circular\
    \ doubly linked list.\n        // 20. You can assume that the list is not a circular\
    \ queue.\n        // 21", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => {\n            if (a._1 < b._1)\
    \ {\n                true\n            } else if (a._1 == b._1) {\n          \
    \      a._2 > b._2\n            } else {\n                false\n            }\n\
    \        })", "        // Fill up this function body\n        // 'lst' is a nested\
    \ list, which is similar to matrix, however, unlike matrices,\n        // each\
    \ row may contain a different number of columns.\n        // 'x' is an integer\n\
    \        // You have to return a list of tuples, [(x1, y1), (x2, y2) ...] such\
    \ that\n        // each tuple is a coordinate - (row, columns), starting with\
    \ 0.\n        // Sort coordinates initially by rows in ascending order.\n    \
    \    // Also, sort coordinates of the row by columns in descending order.\n  \
    \      var result = List[Tuple2[Long, Long]]()\n        for (i <- 0 to lst.length\
    \ - 1) {\n            var row = lst(i)\n            for (j <- 0 to row.length\
    \ - 1) {\n                if (row(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = result\
    \ :+ (i.toLong, j.toLong)\n                }\n            }\n        }\n     \
    \   result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long, Long]]()\n  \
    \      for (i <- 0 until lst.length) {\n            for (j <- 0 until lst(i).length)\
    \ {\n                if (lst(i)(j) == x) {\n                    result = (i, j)\
    \ :: result\n                }\n            }\n        }\n        result.sortWith((a,\
    \ b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))", "        // Fill up this\
    \ function body\n        // 'lst' is a nested list, which is similar to matrix,\n\
    \        // however, unlike matrices, each row may contain a different number\
    \ of columns.\n        // 'x' is an integer.\n        // You have to find integers\
    \ 'x' in the list,\n        // and return list of tuples, [(x1, y1), (x2, y2)\
    \ ...] such that\n        // each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n        // Sort coordinates initially by rows in ascending order.\n\
    \        // Also, sort coordinates of the row by columns in descending order.\n\
    \        // If there are no such coordinates, return an empty list.\n        //\
    \ If the list is empty, return an empty list.\n        // Note: You can use built-in\
    \ functions sortWith and sorted.\n        // Note: You can use built-in function\
    \ zipWithIndex.\n        // Note: You can use built-in function flatten.\n   \
    \     // Note: You can use built-in function filter.\n        // Note: You can\
    \ use built-in function map.\n        // Note: You can use built-in function reverse.\n\
    \        // Note: You can use built-in function zip.\n        // Note: You can\
    \ use built-in function sortBy.\n        // Note: You can use built-in function\
    \ groupBy.\n        // Note: You can use built-in function toList.\n        //\
    \ Note: You can use built-in function toSeq.\n        // Note: You can use built-in\
    \ function toSet.\n        // Note: You can use built-in function toMap.\n   \
    \     // Note: You can use built-in function toVector.\n        // Note: You can\
    \ use built-in function toArray.\n        // Note: You can use built-in function\
    \ toIterable.\n        // Note: You can use built-in function toIndexedSeq.\n\
    \        // Note: You can use built-in function toStream.\n        // Note: You\
    \ can use built-in function to.\n        // Note: You can use built-in function\
    \ toTraversable.\n        // Note: You can use built-in function toSeq.\n    \
    \    // Note: You can use built-in function toIterable.\n       ", "        //\
    \ Fill up this function body\n        // 'lst' is a nested list, similar to matrix,\
    \ but each row may contain different number of columns.\n        // 'x' is the\
    \ integer to be searched in the list.\n        // Return list of tuples, [(x1,\
    \ y1), (x2, y2) ...] such that each tuple is a coordinate - (row, columns),\n\
    \        // starting with 0.\n        // Sort coordinates initially by rows in\
    \ ascending order.\n        // Also, sort coordinates of the row by columns in\
    \ descending order.\n        // If x is not found in the list, return empty list.\n\
    \        // If lst is empty, return empty list.\n        // If lst is a list of\
    \ empty lists, return empty list.\n        // If lst is a list of lists, each\
    \ containing empty list, return empty list.\n        // If lst is a list of lists,\
    \ each containing x, return list of tuples, [(0, 0), (1, 0), (2, 0) ...]\n   \
    \     // If lst is a list of lists, each containing x, return list of tuples,\
    \ [(0, 0), (1, 0), (2, 0) ...]\n        // If lst is a list of lists, each containing\
    \ x, return list of tuples, [(0, 0), (1, 0), (2, 0) ...]\n        // If lst is\
    \ a list of lists, each containing x, return list of tuples, [(0, 0), (1, 0),\
    \ (2, 0) ...]\n        // If lst is a list of lists, each containing x, return\
    \ list of tuples, [(0, 0), (1, 0), (2, 0) ...]\n        // If lst is a list of\
    \ lists, each containing x, return list of tuples, [(0, 0), (1, 0), (2, 0) ...]\n\
    \        // If lst is a list of lists, each containing x, return list of tuples,\
    \ [(0, 0), (1, 0), (2, 0) ...]\n        // If lst is a list of lists, each containing\
    \ x, return list of tuples, [(0, 0), (1, 0), (2, 0) ...]\n        // If lst is\
    \ a list of", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = result :+ (i.toLong, j.toLong)\n                }\n            }\n\
    \        }\n        result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 &&\
    \ a._2 > b._2))", "        val lst2 = lst.zipWithIndex.map(x => x._1.zipWithIndex.map(y\
    \ => (x._2, y._2))).flatten.filter(x => x._2 == x._1).sortBy(x => x._1)\n    \
    \    lst2", "        var result : List[Tuple2[Long, Long]] = List[Tuple2[Long,\
    \ Long]]()\n        for (i <- 0 until lst.length) {\n            for (j <- 0 until\
    \ lst(i).length) {\n                if (lst(i)(j) == x) {\n                  \
    \  result = (i, j) :: result\n                }\n            }\n        }\n  \
    \      result.sortWith((a, b) => a._1 < b._1 || (a._1 == b._1 && a._2 > b._2))",
  "        // Fill up this function body\n        // 'lst' is a nested list, and 'x'\
    \ is the integer to be searched\n        // Return a list of tuples, each tuple\
    \ is a coordinate - (row, column)\n        // Sort coordinates initially by rows\
    \ in ascending order.\n        // Also, sort coordinates of the row by columns\
    \ in descending order.\n        // If x is not found, return an empty list\n \
    \       // If lst is empty, return an empty list\n        // If lst is a list\
    \ of empty lists, return an empty list\n        var result : List[Tuple2[Long,\
    \ Long]] = List[Tuple2[Long, Long]]()\n        for (i <- 0 until lst.length) {\n\
    \            for (j <- 0 until lst(i).length) {\n                if (lst(i)(j)\
    \ == x) {\n                    result = result :+ (i.toLong, j.toLong)\n     \
    \           }\n            }\n        }\n        result.sortWith((a, b) => a._1\
    \ < b._1 || (a._1 == b._1 && a._2 > b._2))"]
stop_tokens:
- "\n    }\n"
