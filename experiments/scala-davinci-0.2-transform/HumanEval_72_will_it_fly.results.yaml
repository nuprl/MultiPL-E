language: scala
name: HumanEval_72_will_it_fly
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length % 2 == 0) return false\n        if (q.sum\
    \ > w) return false\n        for (i <- 0 until q.length / 2) {\n            if\
    \ (q(i) != q(q.length - 1 - i)) return false\n        }\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9k8ovyc_.scala:35)\n\tat Problem.main(tmp9k8ovyc_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var sum = 0l\n        for (i <- q) {\n            sum += i\n        }\n\
    \        if (sum > w) return false\n        val q2 = q.reverse\n        for (i\
    \ <- 0 until q.length) {\n            if (q(i) != q2(i)) return false\n      \
    \  }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isPalindrome = q == q.reverse\n        sum\
    \ <= w && isPalindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val qSum = q.sum\n        val qReverse = q.reverse\n        val qIsPalindrome\
    \ = q == qReverse\n        val qWillFly = qSum <= w\n        qIsPalindrome &&\
    \ qWillFly\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 0) return true\n            if (q.length == 1) return true\n            if\
    \ (q.head == q.last) return isBalanced(q.tail.init)\n            return false\n\
    \        }\n        if (isBalanced(q) && q.sum <= w) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q.reverse == q\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 0) return true\n            if (q.length == 1) return true\n            if\
    \ (q.head == q.last) return isBalanced(q.tail.init)\n            return false\n\
    \        }\n        if (isBalanced(q) && q.sum <= w) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 0) return true\n            if (q.length == 1) return true\n            if\
    \ (q.head == q.last) return isBalanced(q.tail.init)\n            return false\n\
    \        }\n        def sum(q : List[Long]) : Long = {\n            if (q.length\
    \ == 0) return 0\n            return q.head + sum(q.tail)\n        }\n       \
    \ if (isBalanced(q) && sum(q) <= w) return true\n        return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        val half = q.length / 2\n        val left = q.slice(0,\
    \ half)\n        val right = q.slice(half + 1, q.length)\n        val leftSum\
    \ = left.sum\n        val rightSum = right.sum\n        if (leftSum > w) return\
    \ false\n        if (rightSum > w) return false\n        if (leftSum != rightSum)\
    \ return false\n        for (i <- 0 until half) {\n            if (left(i) !=\
    \ right(half - 1 - i)) return false\n        }\n        return true\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        if (sum > w) return false\n        val qq =\
    \ q.map(_.toString).mkString\n        val qqq = qq.reverse\n        return qq\
    \ == qqq\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return q(0)\
    \ <= w\n        if (q.length == 2) return q(0) + q(1) <= w\n        if (q.length\
    \ % 2 == 0) return false\n        var sum = 0l\n        for (i <- 0 until q.length)\
    \ {\n            sum += q(i)\n            if (sum > w) return false\n        }\n\
    \        var i = 0\n        var j = q.length - 1\n        while (i < j) {\n  \
    \          if (q(i) != q(j)) return false\n            i += 1\n            j -=\
    \ 1\n        }\n        true\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpphs55e29.scala:40)\n\tat Problem.main(tmpphs55e29.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q.reverse == q\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        val half = q.length / 2\n        val left = q.slice(0,\
    \ half)\n        val right = q.slice(half + 1, q.length)\n        val leftSum\
    \ = left.foldLeft(0l)((a, b) => a + b)\n        val rightSum = right.foldLeft(0l)((a,\
    \ b) => a + b)\n        if (leftSum != rightSum) return false\n        val leftReverse\
    \ = left.reverse\n        for (i <- 0 until half) {\n            if (left(i) !=\
    \ leftReverse(i)) return false\n        }\n        if (leftSum > w) return false\n\
    \        return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        if (q.length == 0) return true\n   \
    \     if (q.length == 1) return true\n        if (q.length == 2) return q(0) ==\
    \ q(1)\n        if (q.length % 2 == 0) return false\n        val mid = q.length\
    \ / 2\n        val left = q.slice(0, mid)\n        val right = q.slice(mid + 1,\
    \ q.length)\n        val sum = q.sum\n        if (sum > w) return false\n    \
    \    if (left.sum != right.sum) return false\n        return true\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        palindrome\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 1) return true\n            if (q.length == 2) return q(0) == q(1)\n    \
    \        if (q(0) == q(q.length - 1)) return isPalindrome(q.slice(1, q.length\
    \ - 1))\n            return false\n        }\n        if (isPalindrome(q)) {\n\
    \            var sum = 0l\n            for (x <- q) sum += x\n            return\
    \ sum <= w\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length % 2 == 0) return false\n        val mid =\
    \ q.length / 2\n        val left = q.slice(0, mid)\n        val right = q.slice(mid\
    \ + 1, q.length)\n        val leftSum = left.sum\n        val rightSum = right.sum\n\
    \        if (leftSum > w) return false\n        if (rightSum > w) return false\n\
    \        if (leftSum + rightSum > w) return false\n        if (left != right.reverse)\
    \ return false\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxc93zm82.scala:40)\n\tat Problem.main(tmpxc93zm82.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length % 2 == 0) return false\n        val half\
    \ = q.length / 2\n        val left = q.slice(0, half)\n        val right = q.slice(half\
    \ + 1, q.length)\n        val leftSum = left.sum\n        val rightSum = right.sum\n\
    \        if (leftSum > w) return false\n        if (rightSum > w) return false\n\
    \        if (leftSum != rightSum) return false\n        return true\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxvtyrulc.scala:39)\n\tat Problem.main(tmpxvtyrulc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.foldLeft(0l)((a, b) => a + b)\n        val palindrome = q.reverse\
    \ == q\n        palindrome && sum <= w\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length == 4) return q(0) == q(3) && q(1) == q(2)\n\
    \        if (q.length % 2 == 0) return false\n        val n = q.length\n     \
    \   val m = n / 2\n        for (i <- 0 until m) {\n            if (q(i) != q(n\
    \ - i - 1)) return false\n        }\n        var sum = 0l\n        for (i <- 0\
    \ until n) {\n            sum += q(i)\n        }\n        return sum <= w\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppiixusew.scala:41)\n\tat Problem.main(tmppiixusew.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return q(0)\
    \ <= w\n        if (q.length % 2 == 0) return false\n        var sum = 0l\n  \
    \      for (i <- 0 until q.length) {\n            sum += q(i)\n            if\
    \ (sum > w) return false\n        }\n        if (sum > w) return false\n     \
    \   var i = 0\n        var j = q.length - 1\n        while (i < j) {\n       \
    \     if (q(i) != q(j)) return false\n            i += 1\n            j -= 1\n\
    \        }\n        return true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isPalindrome = q == q.reverse\n        sum\
    \ <= w && isPalindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        palindrome\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            q == q.reverse\n\
    \        }\n        def sum(q : List[Long]) : Long = {\n            q.foldLeft(0l)((a,\
    \ b) => a + b)\n        }\n        isPalindrome(q) && sum(q) <= w\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        var sum = 0l\n        for (i <- q) sum\
    \ += i\n        if (sum > w) return false\n        var i = 0\n        var j =\
    \ q.length - 1\n        while (i < j) {\n            if (q(i) != q(j)) return\
    \ false\n            i += 1\n            j -= 1\n        }\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.foldLeft(0l)((a, b) => a + b)\n        val palindrome = q.reverse\
    \ == q\n        sum <= w && palindrome\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.sum <= w && q == q.reverse) true else false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length == 4) return q(0) == q(3) && q(1) == q(2)\n\
    \        if (q.length == 5) return q(0) == q(4) && q(1) == q(3)\n        if (q.length\
    \ == 6) return q(0) == q(5) && q(1) == q(4) && q(2) == q(3)\n        if (q.length\
    \ == 7) return q(0) == q(6) && q(1) == q(5) && q(2) == q(4)\n        if (q.length\
    \ == 8) return q(0) == q(7) && q(1) == q(6) && q(2) == q(5) && q(3) == q(4)\n\
    \        if (q.length == 9) return q(0) == q(8) && q(1) == q(7) && q(2) == q(6)\
    \ && q(3) == q(5)\n        if (q.length == 10) return q(0) == q(9) && q(1) ==\
    \ q(8) && q(2) == q(7) && q(3) == q(6) && q(4) == q(5)\n        if (q.length ==\
    \ 11) return q(0) == q(10) && q(1) == q(9) && q(2) == q(8) && q(3) == q(7) &&\
    \ q(4) == q(6)\n        if (q.length == 12) return q(0) == q(11) && q(1) == q(10)\
    \ && q(2) == q(9) && q(3) == q(8) && q(4) == q(7) && q(5) == q(6)\n        if\
    \ (q.length == 13) return q(0) == q(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptqakmacr.scala:33:45 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mif\e[0m (q.length == \e[31m13\e[0m) \e\
    [33mreturn\e[0m q(\e[31m0\e[0m) == q(\n\e[31m\e[31m   |\e[0m                 \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \              expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800547
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var sum = 0l\n        for (i <- q) sum += i\n        if (sum > w) return\
    \ false\n        var i = 0\n        var j = q.length - 1\n        while (i < j)\
    \ {\n            if (q(i) != q(j)) return false\n            i += 1\n        \
    \    j -= 1\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isPalindrome = q == q.reverse\n        sum\
    \ <= w && isPalindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            def isPalindrome(q\
    \ : List[Long], i : Int) : Boolean = {\n                if (i >= q.length / 2)\
    \ true\n                else if (q(i) != q(q.length - 1 - i)) false\n        \
    \        else isPalindrome(q, i + 1)\n            }\n            isPalindrome(q,\
    \ 0)\n        }\n        def sum(q : List[Long]) : Long = {\n            def sum(q\
    \ : List[Long], i : Int, s : Long) : Long = {\n                if (i >= q.length)\
    \ s\n                else sum(q, i + 1, s + q(i))\n            }\n           \
    \ sum(q, 0, 0)\n        }\n        isPalindrome(q) && sum(q) <= w\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.foldLeft(0l)((a, b) => a + b)\n        val palindrome = q.reverse\
    \ == q\n        palindrome && sum <= w\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length % 2 == 0) return false\n        val half\
    \ = q.length / 2\n        var sum = 0l\n        for (i <- 0 until half) {\n  \
    \          sum += q(i)\n        }\n        for (i <- half + 1 until q.length)\
    \ {\n            sum += q(i)\n        }\n        if (sum > w) return false\n \
    \       for (i <- 0 until half) {\n            if (q(i) != q(q.length - 1 - i))\
    \ return false\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5h2nc_qh.scala:43)\n\tat Problem.main(tmp5h2nc_qh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        val half = q.length / 2\n        val left = q.slice(0,\
    \ half)\n        val right = q.slice(half + 1, q.length)\n        val rightReversed\
    \ = right.reverse\n        if (left == rightReversed) {\n            val sum =\
    \ q.sum\n            if (sum <= w) return true\n        }\n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        val sum = q.sum\n        val isBalanced\
    \ = q.reverse == q\n        sum <= w && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.size == 0) return true\n        if (q.size == 1) return true\n\
    \        if (q.size % 2 == 0) return false\n        if (q.size == 2) return false\n\
    \        if (q.size == 3) return true\n        if (q.size == 4) return false\n\
    \        if (q.size == 5) return true\n        if (q.size == 6) return false\n\
    \        if (q.size == 7) return true\n        if (q.size == 8) return false\n\
    \        if (q.size == 9) return true\n        if (q.size == 10) return false\n\
    \        if (q.size == 11) return true\n        if (q.size == 12) return false\n\
    \        if (q.size == 13) return true\n        if (q.size == 14) return false\n\
    \        if (q.size == 15) return true\n        if (q.size == 16) return false\n\
    \        if (q.size == 17) return true\n        if (q.size == 18) return false\n\
    \        if (q.size == 19) return true\n        if (q.size == 20) return false\n\
    \        if (q.size == 21) return true\n        if (q.size == 22) return false\n\
    \        if (q.size == 23) return true\n        if (q.size == 24) return false\n\
    \        if (q.size == 25) return true\n        if (q.size == 26) return false\n\
    \        if (q.size == 27) return true\n        if (q.size == 28) return false\n\
    \        if (q.size == 29) return true\n        if (q.size == 30) return false\n\
    \        if (q.size == 31) return true\n        if (q.size == 32) return false\n\
    \        if (q.size == 33) return true\n        if (q.size == 34) return false\n\
    \        if (q.size == 35) return true\n        if (q.size == 36) return false\n\
    \        if (q.size == 37) return true\n        if (q.size == 38) return false\n\
    \        if (q.size == 39) return true\n        if (q.size == 40) return false\n\
    \        if (q.\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpls2ot4dt.scala:63:4 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n1 error found\n"
  stdout: ''
  timestamp: 1659800546
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            q.reverse ==\
    \ q\n        }\n        def sum(q : List[Long]) : Long = {\n            q.foldLeft(0l)((acc,\
    \ x) => acc + x)\n        }\n        isBalanced(q) && sum(q) <= w\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            if (q.length\
    \ <= 1) true\n            else if (q.head == q.last) isPalindrome(q.tail.init)\n\
    \            else false\n        }\n        if (isPalindrome(q)) q.sum <= w\n\
    \        else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return q(0)\
    \ <= w\n        if (q.length == 2) return q(0) + q(1) <= w\n        if (q.length\
    \ % 2 == 0) return false\n        val n = q.length / 2\n        var sum = 0l\n\
    \        for (i <- 0 until n) {\n            sum += q(i)\n            sum += q(q.length\
    \ - 1 - i)\n        }\n        sum <= w\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqou0flr7.scala:34)\n\tat Problem.main(tmpqou0flr7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            def isPalindromeHelper(q\
    \ : List[Long], qReverse : List[Long]) : Boolean = (q, qReverse) match {\n   \
    \             case (Nil, Nil) => true\n                case (Nil, _) => false\n\
    \                case (_, Nil) => false\n                case (x :: xs, y :: ys)\
    \ => if (x == y) isPalindromeHelper(xs, ys) else false\n            }\n      \
    \      isPalindromeHelper(q, q.reverse)\n        }\n        def sum(q : List[Long])\
    \ : Long = q match {\n            case Nil => 0\n            case x :: xs => x\
    \ + sum(xs)\n        }\n        isPalindrome(q) && sum(q) <= w\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var sum = 0l\n        for (i <- q) sum += i\n        if (sum > w) return\
    \ false\n        var left = 0\n        var right = q.length - 1\n        while\
    \ (left < right) {\n            if (q(left) != q(right)) return false\n      \
    \      left += 1\n            right -= 1\n        }\n        return true\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def sum(l : List[Long]) : Long = l match {\n            case Nil => 0\n\
    \            case x :: xs => x + sum(xs)\n        }\n        def isPalindrome(l\
    \ : List[Long]) : Boolean = l match {\n            case Nil => true\n        \
    \    case x :: Nil => true\n            case x :: xs => x == xs.last && isPalindrome(xs.init)\n\
    \        }\n        isPalindrome(q) && sum(q) <= w\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.size == 0) return true\n        if (q.size == 1) return true\n\
    \        if (q.size == 2) return false\n        if (q.size % 2 == 0) return false\n\
    \        if (q.size == 3) return q(0) + q(1) + q(2) <= w\n        val mid = q.size\
    \ / 2\n        val left = q.slice(0, mid)\n        val right = q.slice(mid + 1,\
    \ q.size)\n        val sum = q(mid) + left.sum + right.sum\n        if (sum >\
    \ w) return false\n        if (left.size == 1 && right.size == 1) return true\n\
    \        if (left.size == 2 && right.size == 2) return false\n        if (left.size\
    \ == 3 && right.size == 3) return left(0) + left(1) + left(2) + right(0) + right(1)\
    \ + right(2) <= w\n        if (left.size == 3 && right.size == 2) return false\n\
    \        if (left.size == 2 && right.size == 3) return false\n        if (left.size\
    \ == 4 && right.size == 4) return false\n        if (left.size == 4 && right.size\
    \ == 3) return false\n        if (left.size == 3 && right.size == 4) return false\n\
    \        if (left.size == 5 && right.size == 5) return left(0) + left(1) + left(2)\
    \ + left(3) + left(4) + right(0) + right(1) + right(2) + right(3) + right(4) <=\
    \ w\n        if (left.size == 5 && right.size == 4) return false\n        if (left.size\
    \ == 4 && right.size == 5) return false\n        if (left.size == 6 && right.size\
    \ == 6) return false\n        if (left.size == 6 && right.size == 5) return false\n\
    \        if (left.size == 5 && right.size == 6) return false\n        if (left.size\
    \ == 7 && right.size == 7) return left(0) + left(1) + left(2) + left(3)\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9zt5v5_3.scala:44:54\
    \ --------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mif\e[0m (left.size\
    \ == \e[31m7\e[0m && right.size == \e[31m7\e[0m) \e[33mreturn\e[0m left(\e[31m0\e\
    [0m) + left(\e[31m1\e[0m) + left(\e[31m2\e[0m) + left(\e[31m3\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                      Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \   Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800549
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length % 2 == 0) return false\n        if (q.length\
    \ % 2 == 1) {\n            val half = q.length / 2\n            val left = q.slice(0,\
    \ half)\n            val right = q.slice(half + 1, q.length)\n            if (left\
    \ == right.reverse) {\n                val sum = q.sum\n                if (sum\
    \ <= w) return true\n                else return false\n            }\n      \
    \      else return false\n        }\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfvnnjokt.scala:42)\n\tat Problem.main(tmpfvnnjokt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 1) true\n            else if (q.length == 2) q(0) == q(1)\n            else\
    \ if (q(0) == q(q.length - 1)) isPalindrome(q.slice(1, q.length - 1))\n      \
    \      else false\n        }\n        def sum(q : List[Long]) : Long = {\n   \
    \         if (q.length == 1) q(0)\n            else q(0) + sum(q.slice(1, q.length))\n\
    \        }\n        if (isPalindrome(q) && sum(q) <= w) true\n        else false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        // Return either True or False\n   \
    \     true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgoc4kegg.scala:26)\n\tat Problem.main(tmpgoc4kegg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800550
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length == 4) return q(0) == q(3) && q(1) == q(2)\n\
    \        if (q.length == 5) return q(0) == q(4) && q(1) == q(3)\n        if (q.length\
    \ == 6) return q(0) == q(5) && q(1) == q(4) && q(2) == q(3)\n        if (q.length\
    \ == 7) return q(0) == q(6) && q(1) == q(5) && q(2) == q(4)\n        if (q.length\
    \ == 8) return q(0) == q(7) && q(1) == q(6) && q(2) == q(5) && q(3) == q(4)\n\
    \        if (q.length == 9) return q(0) == q(8) && q(1) == q(7) && q(2) == q(6)\
    \ && q(3) == q(5)\n        if (q.length == 10) return q(0) == q(9) && q(1) ==\
    \ q(8) && q(2) == q(7) && q(3) == q(6) && q(4) == q(5)\n        if (q.length ==\
    \ 11) return q(0) == q(10) && q(1) == q(9) && q(2) == q(8) && q(3) == q(7) &&\
    \ q(4) == q(6)\n        if (q.length == 12) return q(0) == q(11) && q(1) == q(10)\
    \ && q(2) == q(9) && q(3) == q(8) && q(4) == q(7) && q(5) == q(6)\n        if\
    \ (q.length == 13) return q(0) == q(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptqakmacr.scala:33:45 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mif\e[0m (q.length == \e[31m13\e[0m) \e\
    [33mreturn\e[0m q(\e[31m0\e[0m) == q(\n\e[31m\e[31m   |\e[0m                 \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \              expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800547
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        var sum = 0l\n        for (i <- 0 until q.length) {\n\
    \            sum += q(i)\n        }\n        if (sum > w) return false\n     \
    \   for (i <- 0 until q.length / 2) {\n            if (q(i) != q(q.length - 1\
    \ - i)) return false\n        }\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isPalindrome = q.reverse == q\n        return\
    \ sum <= w && isPalindrome\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 0) return true\n            if (q.length == 1) return true\n            if\
    \ (q.head == q.last) return isBalanced(q.slice(1, q.length - 1))\n           \
    \ return false\n        }\n        if (isBalanced(q) && q.sum <= w) return true\n\
    \        return false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800551
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length == 4) return q(0) == q(3) && q(1) == q(2)\n\
    \        if (q.length % 2 == 0) return false\n        val n = q.length\n     \
    \   val m = n / 2\n        val a = q.slice(0, m)\n        val b = q.slice(m +\
    \ 1, n)\n        val c = q.slice(m, m + 1)\n        val d = a.sum + b.sum + c(0)\n\
    \        if (d > w) return false\n        if (a.length == 1) return a(0) == b(0)\n\
    \        if (a.length == 2) return a(0) == b(1) && a(1) == b(0)\n        if (a.length\
    \ == 3) return a(0) == b(2) && a(1) == b(1) && a(2) == b(0)\n        if (a.length\
    \ == 4) return a(0) == b(3) && a(1) == b(2) && a(2) == b(1) && a(3) == b(0)\n\
    \        if (a.length % 2 == 0) return false\n        val e = a.length\n     \
    \   val f = e / 2\n        val g = a.slice(0, f)\n        val h = a.slice(f +\
    \ 1, e)\n        val i = b.slice(0, f)\n        val j = b.slice(f + 1, e)\n  \
    \      if (g.length != i.length || h.length != j.length) return false\n      \
    \  if (g.length == 1) return g(0) == i(0) && h(0) == j(0)\n        if (g.length\
    \ == 2) return g(0) == i(1) && g(1) == i(0) && h(0) == j(1)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplpcm_3b0.scala:46:8\
    \ ---------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mif\e[0m (g.length\
    \ == \e[31m2\e[0m) \e[33mreturn\e[0m g(\e[31m0\e[0m) == i(\e[31m1\e[0m) && g(\e\
    [31m1\e[0m) == i(\e[31m0\e[0m) && h(\e[31m0\e[0m) == j(\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: Boolean\n\
    \e[31m   |\e[0m        Maybe you are missing an else part for the conditional?\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800554
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 0) return true\n            if (q.length == 1) return true\n            if\
    \ (q.head == q.last) return isBalanced(q.tail.init)\n            return false\n\
    \        }\n        def sum(q : List[Long]) : Long = {\n            if (q.length\
    \ == 0) return 0\n            return q.head + sum(q.tail)\n        }\n       \
    \ if (isBalanced(q) && sum(q) <= w) return true\n        return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        val mid = q.length / 2\n        val left = q.slice(0,\
    \ mid)\n        val right = q.slice(mid + 1, q.length)\n        val sum = left.sum\
    \ + right.sum\n        if (sum > w) return false\n        if (left.length == right.length)\
    \ {\n            if (left.length == 1) return left(0) == right(0)\n          \
    \  if (left.length == 2) return left(0) == right(1) && left(1) == right(0)\n \
    \           if (left.length % 2 == 0) return false\n            val mid = left.length\
    \ / 2\n            val leftleft = left.slice(0, mid)\n            val leftright\
    \ = left.slice(mid + 1, left.length)\n            val rightleft = right.slice(0,\
    \ mid)\n            val rightright = right.slice(mid + 1, right.length)\n    \
    \        val leftsum = leftleft.sum + leftright.sum\n            val rightsum\
    \ = rightleft.sum + rightright.sum\n            if (leftsum != rightsum) return\
    \ false\n            if (leftleft.length == leftright.length) {\n            \
    \    if (leftleft.length == 1) return leftleft(0) == leftright(0)\n          \
    \      if (leftleft.length == 2) return leftleft(0) == leftright(1) && leftleft(1)\
    \ == leftright(0)\n                if (leftleft.length % 2 == 0) return false\n\
    \                val mid = leftleft.length / 2\n                val leftleftleft\
    \ = leftleft.slice(0, mid)\n                val leftleftright = leftleft.slice(mid\
    \ + 1, leftleft.length)\n                val leftrightsum = leftleftleft.sum +\
    \ leftleftright.sum\n                val rightleftleft = rightleft.slice(0, mid)\n\
    \                val rightleftright = rightleft.slice(mid + 1, rightleft.length)\n\
    \                val rightrightsum = right\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_pf1pev7.scala:63:0 ----------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_pf1pev7.scala:29:8\
    \ ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mif\e[0m (left.length\
    \ == right.length) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m   \
    \     Found:    Unit\n\e[31m   |\e[0m        Required: Boolean\n\e[31m   |\e[0m\
    \        Maybe you are missing an else part for the conditional?\n\e[31m30 |\e\
    [0m            \e[33mif\e[0m (left.length == \e[31m1\e[0m) \e[33mreturn\e[0m left(\e\
    [31m0\e[0m) == right(\e[31m0\e[0m)\n\e[31m31 |\e[0m            \e[33mif\e[0m (left.length\
    \ == \e[31m2\e[0m) \e[33mreturn\e[0m left(\e[31m0\e[0m) == right(\e[31m1\e[0m)\
    \ && left(\e[31m1\e[0m) == right(\e[31m0\e[0m)\n\e[31m32 |\e[0m            \e\
    [33mif\e[0m (left.length % \e[31m2\e[0m == \e[31m0\e[0m) \e[33mreturn\e[0m \e\
    [31mfalse\e[0m\n\e[31m33 |\e[0m            \e[33mval\e[0m \e[36mmid\e[0m = left.length\
    \ / \e[31m2\e[0m\n\e[31m34 |\e[0m            \e[33mval\e[0m \e[36mleftleft\e[0m\
    \ = left.slice(\e[31m0\e[0m, mid)\n\e[31m35 |\e[0m            \e[33mval\e[0m \e\
    [36mleftright\e[0m = left.slice(mid + \e[31m1\e[0m, left.length)\n\e[31m36 |\e\
    [0m            \e[33mval\e[0m \e[36mrightleft\e[0m = right.slice(\e[31m0\e[0m,\
    \ mid)\n\e[31m37 |\e[0m            \e[33mval\e[0m \e[36mrightright\e[0m = right.slice(mid\
    \ + \e[31m1\e[0m, right.length)\n\e[31m38 |\e[0m            \e[33mval\e[0m \e\
    [36mleftsum\e[0m = leftleft.sum + leftright.sum\n\e[31m39 |\e[0m            \e\
    [33mval\e[0m \e[36mrightsum\e[0m = rightleft.sum + rightright.sum\n\e[31m40 |\e\
    [0m            \e[33mif\e[0m (leftsum != rightsum) \e[33mreturn\e[0m \e[31mfalse\e\
    [0m\n\e[31m41 |\e[0m            \e[33mif\e[0m (leftleft.length == leftright.length)\
    \ {\n\e[31m42 |\e[0m                \e[33mif\e[0m (leftleft.length == \e[31m1\e\
    [0m) \e[33mreturn\e[0m leftleft(\e[31m0\e[0m) == leftright(\e[31m0\e[0m)\n\e[31m43\
    \ |\e[0m                \e[33mif\e[0m (leftleft.length == \e[31m2\e[0m) \e[33mreturn\e\
    [0m leftleft(\e[31m0\e[0m) == leftright(\e[31m1\e[0m) && leftleft(\e[31m1\e[0m)\
    \ == leftright(\e[31m0\e[0m)\n\e[31m44 |\e[0m   "
  stdout: ''
  timestamp: 1659800554
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        if (q.sum > w) return false\n        for (i <- 0 until\
    \ q.length / 2) {\n            if (q(i) != q(q.length - 1 - i)) return false\n\
    \        }\n        return true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800560
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            def isPalindromeHelper(q\
    \ : List[Long], i : Int) : Boolean = {\n                if (i == q.length / 2)\
    \ true\n                else if (q(i) == q(q.length - 1 - i)) isPalindromeHelper(q,\
    \ i + 1)\n                else false\n            }\n            isPalindromeHelper(q,\
    \ 0)\n        }\n        def sum(q : List[Long]) : Long = {\n            def sumHelper(q\
    \ : List[Long], i : Int, acc : Long) : Long = {\n                if (i == q.length)\
    \ acc\n                else sumHelper(q, i + 1, acc + q(i))\n            }\n \
    \           sumHelper(q, 0, 0)\n        }\n        isPalindrome(q) && sum(q) <=\
    \ w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800560
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var sum = 0l\n        for (i <- q) {\n            sum += i\n        }\n\
    \        if (sum > w) return false\n        var q2 = q.reverse\n        for (i\
    \ <- 0 until q.length) {\n            if (q(i) != q2(i)) return false\n      \
    \  }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        if (q.length == 0) return true\n   \
    \     if (q.length == 1) return true\n        if (q.length == 2) return q(0) ==\
    \ q(1)\n        if (q.length % 2 == 0) return false\n        val half = q.length\
    \ / 2\n        val left = q.slice(0, half)\n        val right = q.slice(half +\
    \ 1, q.length)\n        val leftSum = left.sum\n        val rightSum = right.sum\n\
    \        if (leftSum > w) return false\n        if (rightSum > w) return false\n\
    \        if (leftSum != rightSum) return false\n        for (i <- 0 until half)\
    \ {\n            if (left(i) != right(half - 1 - i)) return false\n        }\n\
    \        return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.sum <= w && q == q.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        if (q.sum > w) return false\n        var i = 0\n     \
    \   var j = q.length - 1\n        while (i < j) {\n            if (q(i) != q(j))\
    \ return false\n            i += 1\n            j -= 1\n        }\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        palindrome\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var sum = 0l\n        for (i <- q) {\n            sum += i\n        }\n\
    \        if (sum > w) return false\n        var q2 = q.reverse\n        for (i\
    \ <- 0 until q.length) {\n            if (q(i) != q2(i)) return false\n      \
    \  }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.sum <= w && q == q.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 0) return true\n            if (q.length == 1) return true\n            if\
    \ (q.head == q.last) return isBalanced(q.tail.init)\n            return false\n\
    \        }\n        def sum(q : List[Long]) : Long = {\n            if (q.length\
    \ == 0) return 0\n            return q.head + sum(q.tail)\n        }\n       \
    \ if (isBalanced(q) && sum(q) <= w) return true\n        return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        palindrome\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1u2unc4y.scala:24)\n\tat Problem.main(tmp1u2unc4y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800560
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 0) true\n            else if (q.length == 1) true\n            else if (q.head\
    \ == q.last) isBalanced(q.tail.init)\n            else false\n        }\n    \
    \    def sum(q : List[Long]) : Long = {\n            if (q.length == 0) 0\n  \
    \          else q.head + sum(q.tail)\n        }\n        if (isBalanced(q) &&\
    \ sum(q) <= w) true\n        else false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length % 2 == 0) return false\n        var sum =\
    \ 0l\n        for (i <- 0 until q.length) {\n            sum += q(i)\n       \
    \ }\n        if (sum > w) return false\n        for (i <- 0 until q.length / 2)\
    \ {\n            if (q(i) != q(q.length - 1 - i)) return false\n        }\n  \
    \      return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp42arn923.scala:39)\n\tat Problem.main(tmp42arn923.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.sum <= w && q == q.reverse) true else false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        val half = q.length / 2\n        val left = q.slice(0,\
    \ half)\n        val right = q.slice(half + 1, q.length)\n        val leftSum\
    \ = left.sum\n        val rightSum = right.sum\n        if (leftSum > w) return\
    \ false\n        if (rightSum > w) return false\n        if (leftSum != rightSum)\
    \ return false\n        for (i <- 0 until half) {\n            if (left(i) !=\
    \ right(half - 1 - i)) return false\n        }\n        return true\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 0) return true\n            if (q.length == 1) return true\n            if\
    \ (q.head == q.last) return isBalanced(q.tail.init)\n            return false\n\
    \        }\n        if (isBalanced(q) && q.sum <= w) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length == 4) return q(0) == q(3) && q(1) == q(2)\n\
    \        if (q.length == 5) return q(0) == q(4) && q(1) == q(3)\n        if (q.length\
    \ == 6) return q(0) == q(5) && q(1) == q(4) && q(2) == q(3)\n        if (q.length\
    \ == 7) return q(0) == q(6) && q(1) == q(5) && q(2) == q(4)\n        if (q.length\
    \ == 8) return q(0) == q(7) && q(1) == q(6) && q(2) == q(5) && q(3) == q(4)\n\
    \        if (q.length == 9) return q(0) == q(8) && q(1) == q(7) && q(2) == q(6)\
    \ && q(3) == q(5)\n        if (q.length == 10) return q(0) == q(9) && q(1) ==\
    \ q(8) && q(2) == q(7) && q(3) == q(6) && q(4) == q(5)\n        if (q.length ==\
    \ 11) return q(0) == q(10) && q(1) == q(9) && q(2) == q(8) && q(3) == q(7) &&\
    \ q(4) == q(6)\n        if (q.length == 12) return q(0) == q(11) && q(1) == q(10)\
    \ && q(2) == q(9) && q(3) == q(8) && q(4) == q(7) && q(5) == q(6)\n        if\
    \ (q.length == 13) return q(0) == q(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptqakmacr.scala:33:45 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mif\e[0m (q.length == \e[31m13\e[0m) \e\
    [33mreturn\e[0m q(\e[31m0\e[0m) == q(\n\e[31m\e[31m   |\e[0m                 \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \              expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800547
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isPalindrome = q.reverse == q\n        sum\
    \ <= w && isPalindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 0) return true\n            if (q.length == 1) return true\n            if\
    \ (q.head == q.last) return isBalanced(q.tail.init)\n            else return false\n\
    \        }\n        if (isBalanced(q) && q.sum <= w) return true\n        else\
    \ return false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            q == q.reverse\n\
    \        }\n        isPalindrome(q) && q.sum <= w\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.foldLeft(0l)((a, b) => a + b)\n        val palindrome = q.reverse\
    \ == q\n        palindrome && sum <= w\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        val m = q.length / 2\n        val s = q.slice(0, m)\n\
    \        val t = q.slice(m + 1, q.length)\n        val u = s.zip(t).map(x => x._1\
    \ + x._2)\n        val v = u.foldLeft(0l)((x, y) => x + y)\n        if (v > w)\
    \ return false\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpop25cdem.scala:37)\n\tat Problem.main(tmpop25cdem.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.sum > w) return false\n\
    \        if (q.length == 1) return true\n        val q2 = q.slice(1, q.length\
    \ - 1)\n        if (q.head == q.last) willItFly(q2, w)\n        else false\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        palindrome\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var sum = 0l\n        for (i <- q) {\n            sum += i\n        }\n\
    \        if (sum > w) return false\n        var left = 0\n        var right =\
    \ q.length - 1\n        while (left < right) {\n            if (q(left) != q(right))\
    \ return false\n            left += 1\n            right -= 1\n        }\n   \
    \     return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 0) return true\n            if (q.length == 1) return true\n            if\
    \ (q.head == q.last) return isBalanced(q.tail.init)\n            return false\n\
    \        }\n        if (isBalanced(q) && q.sum <= w) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.size == 0) return true\n        if (q.size == 1) return true\n\
    \        if (q.size == 2) return q(0) == q(1)\n        if (q.size == 3) return\
    \ q(0) == q(2)\n        if (q.size % 2 == 0) return false\n        val n = q.size\n\
    \        val m = n / 2\n        val s = q.sum\n        if (s > w) return false\n\
    \        for (i <- 0 until m) {\n            if (q(i) != q(n - i - 1)) return\
    \ false\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpje5s8h4f.scala:38)\n\tat Problem.main(tmpje5s8h4f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q.reverse == q\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val max = w\n        val isBalanced = q == q.reverse\n\
    \        sum <= max && isBalanced\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var sum = 0l\n        for (i <- q) sum += i\n        if (sum > w) return\
    \ false\n        var i = 0\n        var j = q.length - 1\n        while (i < j)\
    \ {\n            if (q(i) != q(j)) return false\n            i += 1\n        \
    \    j -= 1\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return q(0)\
    \ <= w\n        if (q.length % 2 == 0) return false\n        val half = q.length\
    \ / 2\n        val left = q.slice(0, half)\n        val right = q.slice(half +\
    \ 1, q.length)\n        val leftSum = left.sum\n        val rightSum = right.sum\n\
    \        if (leftSum != rightSum) return false\n        if (leftSum > w) return\
    \ false\n        return true\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q.reverse == q\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q.reverse == q\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 0) return true\n            if (q.length == 1) return true\n            if\
    \ (q.head == q.last) return isBalanced(q.tail.init)\n            return false\n\
    \        }\n        if (isBalanced(q) && q.sum <= w) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        return q.sum <= w && q == q.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length % 2 == 0) return false\n        val mid =\
    \ q.length / 2\n        val left = q.slice(0, mid)\n        val right = q.slice(mid\
    \ + 1, q.length)\n        val leftSum = left.sum\n        val rightSum = right.sum\n\
    \        if (leftSum > w) return false\n        if (rightSum > w) return false\n\
    \        if (leftSum != rightSum) return false\n        for (i <- 0 until mid)\
    \ {\n            if (left(i) != right(mid - i - 1)) return false\n        }\n\
    \        true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg8wtlv2i.scala:42)\n\tat Problem.main(tmpg8wtlv2i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q.reverse == q\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length == 4) return q(0) == q(3) && q(1) == q(2)\n\
    \        if (q.length == 5) return q(0) == q(4) && q(1) == q(3)\n        if (q.length\
    \ == 6) return q(0) == q(5) && q(1) == q(4) && q(2) == q(3)\n        if (q.length\
    \ == 7) return q(0) == q(6) && q(1) == q(5) && q(2) == q(4)\n        if (q.length\
    \ == 8) return q(0) == q(7) && q(1) == q(6) && q(2) == q(5) && q(3) == q(4)\n\
    \        if (q.length == 9) return q(0) == q(8) && q(1) == q(7) && q(2) == q(6)\
    \ && q(3) == q(5)\n        if (q.length == 10) return q(0) == q(9) && q(1) ==\
    \ q(8) && q(2) == q(7) && q(3) == q(6) && q(4) == q(5)\n        if (q.length ==\
    \ 11) return q(0) == q(10) && q(1) == q(9) && q(2) == q(8) && q(3) == q(7) &&\
    \ q(4) == q(6)\n        if (q.length == 12) return q(0) == q(11) && q(1) == q(10)\
    \ && q(2) == q(9) && q(3) == q(8) && q(4) == q(7) && q(5) == q(6)\n        if\
    \ (q.length == 13) return q(0) == q(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmptqakmacr.scala:33:45 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mif\e[0m (q.length == \e[31m13\e[0m) \e\
    [33mreturn\e[0m q(\e[31m0\e[0m) == q(\n\e[31m\e[31m   |\e[0m                 \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \              expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659800547
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q.reverse == q\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val balanced = q == q.reverse\n        balanced\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            q == q.reverse\n\
    \        }\n        def sum(q : List[Long]) : Long = {\n            q.foldLeft(0l)((a,\
    \ b) => a + b)\n        }\n        isBalanced(q) && sum(q) <= w\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800565
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            def isPalindrome(q\
    \ : List[Long], i : Int) : Boolean = {\n                if (i >= q.length / 2)\
    \ true\n                else if (q(i) != q(q.length - 1 - i)) false\n        \
    \        else isPalindrome(q, i + 1)\n            }\n            isPalindrome(q,\
    \ 0)\n        }\n        def sum(q : List[Long]) : Long = {\n            def sum(q\
    \ : List[Long], i : Int, acc : Long) : Long = {\n                if (i >= q.length)\
    \ acc\n                else sum(q, i + 1, acc + q(i))\n            }\n       \
    \     sum(q, 0, 0)\n        }\n        isPalindrome(q) && sum(q) <= w\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800565
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Your code here\n        val sum = q.sum\n        val isBalanced =\
    \ q.reverse == q\n        sum <= w && isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isPalindrome = q.reverse == q\n        sum\
    \ <= w && isPalindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.sum <= w && q == q.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            q == q.reverse\n\
    \        }\n        def sum(q : List[Long]) : Long = {\n            q.foldLeft(0l)((a,\
    \ b) => a + b)\n        }\n        isPalindrome(q) && sum(q) <= w\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q.reverse == q\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        val half = q.length / 2\n        val left = q.slice(0,\
    \ half)\n        val right = q.slice(half + 1, q.length)\n        val leftSum\
    \ = left.sum\n        val rightSum = right.sum\n        if (leftSum > w) return\
    \ false\n        if (rightSum > w) return false\n        if (leftSum != rightSum)\
    \ return false\n        for (i <- 0 until half) {\n            if (left(i) !=\
    \ right(half - 1 - i)) return false\n        }\n        return true\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 1) return true\n            if (q.head == q.last) return isPalindrome(q.tail.init)\n\
    \            return false\n        }\n        if (isPalindrome(q) && q.sum <=\
    \ w) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        // Return True if the object q will\
    \ fly, and False otherwise.\n        val sum = q.sum\n        val isBalanced =\
    \ q.reverse == q\n        sum <= w && isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var sum = 0l\n        for (i <- q) sum += i\n        if (sum > w) return\
    \ false\n        var l = 0\n        var r = q.length - 1\n        while (l < r)\
    \ {\n            if (q(l) != q(r)) return false\n            l += 1\n        \
    \    r -= 1\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800570
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q.reverse == q\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 1) true\n            else if (q.length == 2) q(0) == q(1)\n            else\
    \ if (q(0) == q(q.length - 1)) isPalindrome(q.slice(1, q.length - 1))\n      \
    \      else false\n        }\n        def sum(q : List[Long]) : Long = {\n   \
    \         if (q.length == 1) q(0)\n            else q(0) + sum(q.slice(1, q.length))\n\
    \        }\n        if (isPalindrome(q) && sum(q) <= w) true\n        else false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return q(0)\
    \ <= w\n        if (q.length % 2 == 0) return false\n        val half = q.length\
    \ / 2\n        val left = q.slice(0, half)\n        val right = q.slice(half +\
    \ 1, q.length)\n        val leftSum = left.sum\n        val rightSum = right.sum\n\
    \        if (leftSum != rightSum) return false\n        if (leftSum + q(half)\
    \ > w) return false\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        var sum = 0l\n        for (i <- 0 until q.length) {\n\
    \            sum += q(i)\n        }\n        if (sum > w) return false\n     \
    \   for (i <- 0 until q.length / 2) {\n            if (q(i) != q(q.length - 1\
    \ - i)) return false\n        }\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800551
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.foldLeft(0l)((a, b) => a + b)\n        val palindrome = q.reverse\
    \ == q\n        sum <= w && palindrome\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.size == 0) return true\n        if (q.size == 1) return q(0) <=\
    \ w\n        if (q.size == 2) return q(0) + q(1) <= w\n        if (q.size % 2\
    \ == 0) return false\n        val mid = q.size / 2\n        var sum = 0l\n   \
    \     for (i <- 0 until mid) {\n            sum += q(i)\n            if (sum >\
    \ w) return false\n        }\n        for (i <- mid + 1 until q.size) {\n    \
    \        sum += q(i)\n            if (sum > w) return false\n        }\n     \
    \   return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmproalxc_2.scala:38)\n\tat Problem.main(tmproalxc_2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return q(0)\
    \ <= w\n        if (q.length == 2) return q(0) + q(1) <= w\n        if (q.length\
    \ % 2 == 0) return false\n        val mid = q.length / 2\n        val left = q.slice(0,\
    \ mid)\n        val right = q.slice(mid + 1, q.length)\n        if (left.sum +\
    \ right.sum + q(mid) > w) return false\n        for (i <- 0 until mid) {\n   \
    \         if (left(i) != right(mid - i - 1)) return false\n        }\n       \
    \ return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp25eijf49.scala:35)\n\tat Problem.main(tmp25eijf49.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        return\
    \ isBalanced && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return q(0)\
    \ <= w\n        if (q.length == 2) return q(0) + q(1) <= w\n        if (q.length\
    \ % 2 == 0) return false\n        val half = q.length / 2\n        val left =\
    \ q.slice(0, half)\n        val right = q.slice(half + 1, q.length)\n        val\
    \ leftSum = left.sum\n        val rightSum = right.sum\n        if (leftSum !=\
    \ rightSum) return false\n        leftSum + q(half) <= w\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppptpeb5e.scala:34)\n\tat Problem.main(tmppptpeb5e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q.reverse == q\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1u2unc4y.scala:24)\n\tat Problem.main(tmp1u2unc4y.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800560
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length == 3) return\
    \ q(0) == q(2)\n        if (q.length % 2 == 0) return false\n        var sum =\
    \ 0l\n        for (i <- 0 until q.length) {\n            sum += q(i)\n       \
    \ }\n        if (sum > w) return false\n        var i = 0\n        var j = q.length\
    \ - 1\n        while (i < j) {\n            if (q(i) != q(j)) return false\n \
    \           i += 1\n            j -= 1\n        }\n        return true\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuj_gk3yw.scala:43)\n\tat Problem.main(tmpuj_gk3yw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            q.reverse\
    \ == q\n        }\n        def sum(q : List[Long]) : Long = {\n            q.foldLeft(0l)((a,\
    \ b) => a + b)\n        }\n        isPalindrome(q) && sum(q) <= w\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800571
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        var sum = 0l\n        for (i <- q) sum += i\n        if (sum > w) return\
    \ false\n        var i = 0\n        var j = q.length - 1\n        while (i < j)\
    \ {\n            if (q(i) != q(j)) return false\n            i += 1\n        \
    \    j -= 1\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.foldLeft(0l)((a,b) => a + b)\n        val isBalanced = q.zip(q.reverse).foldLeft(true)((a,b)\
    \ => a && b._1 == b._2)\n        sum <= w && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        return\
    \ (sum <= w) && palindrome\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        val half = q.length / 2\n        val left = q.slice(0,\
    \ half)\n        val right = q.slice(half + 1, q.length)\n        val leftSum\
    \ = left.sum\n        val rightSum = right.sum\n        if (leftSum > w) return\
    \ false\n        if (rightSum > w) return false\n        if (leftSum != rightSum)\
    \ return false\n        for (i <- 0 until half) {\n            if (left(i) !=\
    \ right(half - 1 - i)) return false\n        }\n        return true\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            def isPalindromeHelper(q\
    \ : List[Long], r : List[Long]) : Boolean = {\n                if (q.length ==\
    \ 0) true\n                else if (q.head != r.head) false\n                else\
    \ isPalindromeHelper(q.tail, r.tail)\n            }\n            isPalindromeHelper(q,\
    \ q.reverse)\n        }\n        def sum(q : List[Long]) : Long = {\n        \
    \    def sumHelper(q : List[Long], acc : Long) : Long = {\n                if\
    \ (q.length == 0) acc\n                else sumHelper(q.tail, acc + q.head)\n\
    \            }\n            sumHelper(q, 0)\n        }\n        isPalindrome(q)\
    \ && sum(q) <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        isBalanced\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val max = q.max\n        val min = q.min\n \
    \       val palindrome = q.reverse == q\n        if (sum <= w && palindrome &&\
    \ max == min) true else false\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9kh0y4nq.scala:27)\n\tat Problem.main(tmp9kh0y4nq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 1) true\n            else if (q.length == 2) q(0) == q(1)\n            else\
    \ if (q(0) == q(q.length - 1)) isPalindrome(q.slice(1, q.length - 1))\n      \
    \      else false\n        }\n        def sum(q : List[Long]) : Long = {\n   \
    \         if (q.length == 1) q(0)\n            else q(0) + sum(q.slice(1, q.length))\n\
    \        }\n        isPalindrome(q) && sum(q) <= w\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isPalindrome = q.reverse == q\n        sum\
    \ <= w && isPalindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(l : List[Long]) : Boolean = {\n            if (l.length\
    \ == 1) true\n            else if (l.head == l.last) isPalindrome(l.slice(1, l.length\
    \ - 1))\n            else false\n        }\n        if (isPalindrome(q) && q.sum\
    \ <= w) true\n        else false\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwm2_rnzv.scala:25)\n\tat Problem.main(tmpwm2_rnzv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.foldLeft(0l)((a, b) => a + b)\n        val palindrome = q.reverse\
    \ == q\n        sum <= w && palindrome\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val balanced = q == q.reverse\n        sum <=\
    \ w && balanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        val mid = q.length / 2\n        val left = q.slice(0,\
    \ mid)\n        val right = q.slice(mid + 1, q.length)\n        if (left.sum +\
    \ right.sum > w) return false\n        if (left != right.reverse) return false\n\
    \        return true\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4oken_79.scala:24)\n\tat Problem.main(tmp4oken_79.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwm2_rnzv.scala:25)\n\tat Problem.main(tmpwm2_rnzv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            if (q.length\
    \ == 1) true\n            else if (q.length == 2) q(0) == q(1)\n            else\
    \ if (q(0) == q(q.length - 1)) isPalindrome(q.slice(1, q.length - 1))\n      \
    \      else false\n        }\n        def sum(q : List[Long]) : Long = {\n   \
    \         if (q.length == 1) q(0)\n            else q(0) + sum(q.slice(1, q.length))\n\
    \        }\n        isPalindrome(q) && sum(q) <= w\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800572
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isPalindrome = q.reverse == q\n        sum\
    \ <= w && isPalindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            if (q.length\
    \ <= 1) true\n            else if (q.head == q.last) isPalindrome(q.tail.init)\n\
    \            else false\n        }\n        def sum(q : List[Long]) : Long = {\n\
    \            if (q.length == 0) 0\n            else q.head + sum(q.tail)\n   \
    \     }\n        isPalindrome(q) && sum(q) <= w\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return q(0)\
    \ <= w\n        if (q.length == 2) return q(0) + q(1) <= w\n        if (q.length\
    \ % 2 == 0) return false\n        val half = q.length / 2\n        val left =\
    \ q.slice(0, half)\n        val right = q.slice(half + 1, q.length)\n        val\
    \ leftSum = left.sum\n        val rightSum = right.sum\n        if (leftSum !=\
    \ rightSum) return false\n        leftSum + q(half) <= w\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppptpeb5e.scala:34)\n\tat Problem.main(tmppptpeb5e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800572
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return (q(0) == q(1))\n        if (q.length == 3)\
    \ return (q(0) == q(2))\n        if (q.length == 4) return (q(0) == q(3)) && (q(1)\
    \ == q(2))\n        if (q.length == 5) return (q(0) == q(4)) && (q(1) == q(3))\n\
    \        if (q.length == 6) return (q(0) == q(5)) && (q(1) == q(4)) && (q(2) ==\
    \ q(3))\n        if (q.length == 7) return (q(0) == q(6)) && (q(1) == q(5)) &&\
    \ (q(2) == q(4))\n        if (q.length == 8) return (q(0) == q(7)) && (q(1) ==\
    \ q(6)) && (q(2) == q(5)) && (q(3) == q(4))\n        if (q.length == 9) return\
    \ (q(0) == q(8)) && (q(1) == q(7)) && (q(2) == q(6)) && (q(3) == q(5))\n     \
    \   if (q.length == 10) return (q(0) == q(9)) && (q(1) == q(8)) && (q(2) == q(7))\
    \ && (q(3) == q(6)) && (q(4) == q(5))\n        if (q.length == 11) return (q(0)\
    \ == q(10)) && (q(1) == q(9)) && (q(2) == q(8)) && (q(3) == q(7)) && (q(4) ==\
    \ q(6))\n        if (q.length == 12) return (q(0) == q(11)) && (q(1) == q(10))\
    \ && (q(2) == q(9)) && (q(3) == q(8)) && (q(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp3_lwtusv.scala:32:112 --------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mif\e[0m (q.length == \e[31m12\e[0m) \e\
    [33mreturn\e[0m (q(\e[31m0\e[0m) == q(\e[31m11\e[0m)) && (q(\e[31m1\e[0m) == q(\e\
    [31m10\e[0m)) && (q(\e[31m2\e[0m) == q(\e[31m9\e[0m)) && (q(\e[31m3\e[0m) == q(\e\
    [31m8\e[0m)) && (q(\n\e[31m\e[31m   |\e[0m                                   \
    \                                                                            \
    \ ^\e[0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659800574
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        q.sum <= w && q == q.reverse\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800561
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q == q.reverse\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800550
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isPalindrome(q : List[Long]) : Boolean = {\n            q == q.reverse\n\
    \        }\n        def sum(q : List[Long]) : Long = {\n            q.foldLeft(0l)((a,\
    \ b) => a + b)\n        }\n        isPalindrome(q) && sum(q) <= w\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        sum\
    \ <= w && palindrome\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length == 2) return q(0) == q(1)\n        if (q.length % 2 == 0)\
    \ return false\n        val mid = q.length / 2\n        val left = q.slice(0,\
    \ mid)\n        val right = q.slice(mid + 1, q.length)\n        val leftSum =\
    \ left.sum\n        val rightSum = right.sum\n        if (leftSum > w || rightSum\
    \ > w) return false\n        if (leftSum != rightSum) return false\n        for\
    \ (i <- 0 until mid) {\n            if (left(i) != right(mid - i - 1)) return\
    \ false\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800577
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length % 2 == 0) return false\n        val half = q.length / 2\n\
    \        val left = q.slice(0, half)\n        val right = q.slice(half + 1, q.length)\n\
    \        val leftSum = left.sum\n        val rightSum = right.sum\n        if\
    \ (leftSum > w) return false\n        if (rightSum > w) return false\n       \
    \ if (leftSum != rightSum) return false\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800576
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val palindrome = q.reverse == q\n        palindrome\
    \ && sum <= w\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            q.reverse ==\
    \ q\n        }\n        def sum(q : List[Long]) : Long = {\n            q.foldLeft(0l)((x,\
    \ y) => x + y)\n        }\n        isBalanced(q) && sum(q) <= w\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800576
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q.reverse == q\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.length\
    \ <= 1) true\n            else if (q.head == q.last) isBalanced(q.tail.init)\n\
    \            else false\n        }\n        def sum(q : List[Long]) : Long = {\n\
    \            if (q.length == 0) 0\n            else q.head + sum(q.tail)\n   \
    \     }\n        if (isBalanced(q) && sum(q) <= w) true\n        else false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800577
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        val isBalanced = q.reverse == q\n        sum\
    \ <= w && isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800540
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        if (q.length == 0) return true\n        if (q.length == 1) return true\n\
    \        if (q.length % 2 == 0) return false\n        var sum = 0l\n        for\
    \ (i <- 0 until q.length) {\n            sum += q(i)\n        }\n        if (sum\
    \ > w) return false\n        for (i <- 0 until q.length / 2) {\n            if\
    \ (q(i) != q(q.length - 1 - i)) return false\n        }\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800577
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        if (q.sum <= w && q == q.reverse) true\
    \ else false\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800577
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        // Write your code here\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0tl9g_8h.scala:25)\n\tat Problem.main(tmp0tl9g_8h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659800539
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        def isBalanced(q : List[Long]) : Boolean = {\n            if (q.size\
    \ == 0) true\n            else if (q.size == 1) true\n            else if (q.head\
    \ == q.last) isBalanced(q.tail.init)\n            else false\n        }\n    \
    \    if (q.sum <= w) isBalanced(q)\n        else false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800577
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // >>> willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l))\n    // (false)\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // >>> willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (1l))\n    // (false)\n    // # it's balanced, but 3+2+3 is more\
    \ than the maximum possible weight.\n    // >>> willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l))\n    // (true)\n    // # 3+2+3 is less than the\
    \ maximum possible weight, and it's balanced.\n    // >>> willItFly((List[Long](3l.toLong)),\
    \ (5l))\n    // (true)\n    // # 3 is less than the maximum possible weight, and\
    \ it's balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n\
    \        val sum = q.sum\n        sum <= w && q == q.reverse\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659800577
