name: HumanEval_65_circular_shift
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Circular shift the digits of the integer x, shift the digits right by shift\n\
  \    // and return the result as a string.\n    // If shift > number of digits,\
  \ return digits reversed.\n    // >>> circularShift((12l), (1l))\n    // (\"21\"\
  )\n    // >>> circularShift((12l), (2l))\n    // (\"12\")\n    def circularShift(x\
  \ : Long, shift : Long) : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(circularShift((100l),\
  \ (2l)).equals((\"001\")));\n    assert(circularShift((12l), (2l)).equals((\"12\"\
  )));\n    assert(circularShift((97l), (8l)).equals((\"79\")));\n    assert(circularShift((12l),\
  \ (1l)).equals((\"21\")));\n    assert(circularShift((11l), (101l)).equals((\"11\"\
  )));\n    }\n\n}\n"
completions: ["        val s = x.toString\n        val n = s.length\n        if (shift\
    \ > n) s.reverse\n        else s.substring(n - shift.toInt) + s.substring(0, n\
    \ - shift.toInt)", "        val digits = x.toString.length\n        if (shift\
    \ > digits) x.toString.reverse\n        else {\n            val shiftDigits =\
    \ x.toString.substring(0, digits - shift.toInt)\n            val unshiftDigits\
    \ = x.toString.substring(digits - shift.toInt, digits)\n            unshiftDigits\
    \ + shiftDigits\n        }", "        val s = x.toString\n        val n = s.length\n\
    \        val shiftMod = shift % n\n        if (shiftMod == 0) s\n        else\
    \ if (shiftMod == 1) s.last + s.substring(0, n - 1)\n        else s.substring(n\
    \ - shiftMod, n) + s.substring(0, n - shiftMod)", "        val s = x.toString\n\
    \        val n = s.length\n        if (shift > n) s.reverse\n        else s.substring(n\
    \ - shift.toInt) + s.substring(0, n - shift.toInt)", "        val digits = x.toString.length\n\
    \        if (shift > digits) {\n            return x.toString.reverse\n      \
    \  }\n        val right = x % pow(10, shift).toLong\n        val left = x / pow(10,\
    \ shift).toLong\n        (right.toString + left.toString).reverse", "        val\
    \ s = x.toString\n        val n = s.length\n        if (shift > n) s.reverse\n\
    \        else s.substring(n - shift.toInt) + s.substring(0, n - shift.toInt)",
  "        val digits = x.toString.length\n        if (shift > digits) {\n       \
    \     x.toString.reverse\n        } else {\n            val (a, b) = x.toString.splitAt(digits\
    \ - shift.toInt)\n            b + a\n        }", "        val digits = x.toString.toList\n\
    \        val n = digits.length\n        if (shift >= n) digits.reverse.mkString\n\
    \        else digits.slice(n - shift.toInt, n) ++ digits.slice(0, n - shift.toInt)\
    \ mkString", "        val digits = x.toString.length\n        if (shift > digits)\
    \ x.toString.reverse\n        else x.toString.substring(digits - shift.toInt)\
    \ + x.toString.substring(0, digits - shift.toInt)", "        val digits = x.toString.toList\n\
    \        val n = digits.length\n        val shift1 = if (shift > n) n - shift\
    \ else shift\n        val shift2 = if (shift > n) shift - n else 0\n        val\
    \ (left, right) = digits.splitAt(n - shift1)\n        (right ++ left).reverse.mkString",
  "        val digits = x.toString.length\n        if (shift >= digits) x.toString.reverse\n\
    \        else {\n            val (a, b) = x.toString.splitAt(digits - shift.toInt)\n\
    \            b + a\n        }", "        val digits = x.toString.map(_.asDigit)\n\
    \        val shiftDigits = digits.slice(digits.length - shift.toInt, digits.length)\n\
    \        val remainingDigits = digits.slice(0, digits.length - shift.toInt)\n\
    \        (shiftDigits ++ remainingDigits).mkString", "        val digits = x.toString.toList\n\
    \        val n = digits.length\n        val shift2 = if (shift > n) n - shift\
    \ else shift\n        val (a, b) = digits.splitAt(shift2)\n        (b ++ a).mkString",
  "        val digits = x.toString.toList\n        val shiftDigits = digits.drop((digits.length\
    \ - shift.toInt) % digits.length)\n        val remainingDigits = digits.take((digits.length\
    \ - shift.toInt) % digits.length)\n        (shiftDigits ::: remainingDigits).mkString",
  "        val str = x.toString\n        val len = str.length\n        if (shift >=\
    \ len) str.reverse\n        else str.substring(len - shift.toInt) + str.substring(0,\
    \ len - shift.toInt)", "        val s = x.toString\n        val n = s.length\n\
    \        if (shift >= n) s.reverse\n        else s.substring(n - shift.toInt)\
    \ + s.substring(0, n - shift.toInt)", "        val digits = x.toString.toList\n\
    \        val n = digits.length\n        val shift1 = if (shift > n) n else shift\n\
    \        val shift2 = if (shift1 == n) 0 else shift1\n        val (left, right)\
    \ = digits.splitAt(n - shift2)\n        (right ::: left).mkString", "        val\
    \ s = x.toString\n        val n = s.length\n        if (shift >= n) s.reverse\n\
    \        else s.substring(n - shift.toInt) + s.substring(0, n - shift.toInt)",
  "        val digits = x.toString.length\n        if (shift > digits) x.toString.reverse\n\
    \        else x.toString.substring(digits - shift.toInt) + x.toString.substring(0,\
    \ digits - shift.toInt)", "        val s = x.toString\n        val n = s.length\n\
    \        if (shift >= n) s.reverse\n        else s.substring(n - shift.toInt)\
    \ + s.substring(0, n - shift.toInt)"]
stop_tokens:
- "\n    }\n"
