name: HumanEval_120_maximum
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n\
  \    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n   \
  \ // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    //\
  \ >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong,\
  \ 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n\
  \    // Note:\n    // 1. The length of the array will be in the range of [1, 1000].\n\
  \    // 2. The elements in the array will be in the range of [-1000, 1000].\n  \
  \  // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
  \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
  \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
  \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
  \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
  \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
  \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
  \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
  \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong,\
  \ 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong,\
  \ 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong,\
  \ -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
  \ -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong,\
  \ 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ["        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n   \
    \     for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        val heap\
    \ = new Heap[Long]((x : Long, y : Long) => x < y)\n        for (i <- 0 until k.toInt)\
    \ heap.insert(arr(i))\n        for (i <- k.toInt until arr.length) {\n       \
    \     if (arr(i) > heap.peek) {\n                heap.remove()\n             \
    \   heap.insert(arr(i))\n            }\n        }\n        heap.toList", "   \
    \     val heap = new Heap[Long]((x : Long, y : Long) => x > y)\n        for (i\
    \ <- arr) {\n            heap.add(i)\n            if (heap.size > k) heap.remove()\n\
    \        }\n        heap.toList", "        // Fill up this function body\n   \
    \     // `arr` is a list of integers\n        // `k` is a positive integer\n \
    \       // Return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        arr.sorted.takeRight(k.toInt)", "        // We can use a min heap to\
    \ solve this problem.\n        // The heap will contain the k largest elements\
    \ in arr.\n        // As we iterate through arr, we will add elements to the heap.\n\
    \        // If the heap size is greater than k, we will remove the smallest element.\n\
    \        // This will ensure that the heap always contains the k largest elements.\n\
    \        // At the end, we will return the heap as a sorted list.\n        //\
    \ Time Complexity: O(n log k)\n        // Space Complexity: O(k)\n        val\
    \ heap = new mutable.PriorityQueue[Long]()\n        for (x <- arr) {\n       \
    \     heap.enqueue(x)\n            if (heap.size > k) heap.dequeue\n        }\n\
    \        heap.toList.sorted", "        val sorted = arr.sorted\n        sorted.takeRight(k.toInt)",
  "        // Fill this\n        return arr", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sorted.takeRight(k.toInt)", "        // We will\
    \ use a heap to store the maximum k numbers.\n        // We will use a min-heap\
    \ to store the negative numbers, and a max-heap to store the positive numbers.\n\
    \        // We will use a min-heap to store the negative numbers, and a max-heap\
    \ to store the positive numbers.\n        // We will use a min-heap to store the\
    \ negative numbers, and a max-heap to store the positive numbers.\n        //\
    \ We will use a min-heap to store the negative numbers, and a max-heap to store\
    \ the positive numbers.\n        // We will use a min-heap to store the negative\
    \ numbers, and a max-heap to store the positive numbers.\n        // We will use\
    \ a min-heap to store the negative numbers, and a max-heap to store the positive\
    \ numbers.\n        // We will use a min-heap to store the negative numbers, and\
    \ a max-heap to store the positive numbers.\n        // We will use a min-heap\
    \ to store the negative numbers, and a max-heap to store the positive numbers.\n\
    \        // We will use a min-heap to store the negative numbers, and a max-heap\
    \ to store the positive numbers.\n        // We will use a min-heap to store the\
    \ negative numbers, and a max-heap to store the positive numbers.\n        //\
    \ We will use a min-heap to store the negative numbers, and a max-heap to store\
    \ the positive numbers.\n        // We will use a min-heap to store the negative\
    \ numbers, and a max-heap to store the positive numbers.\n        // We will use\
    \ a min-heap to store the negative numbers, and a max-heap to store the positive\
    \ numbers.\n        // We will use a min-heap to store the negative numbers, and\
    \ a max-heap to store the positive numbers.\n        // We will use a min-heap\
    \ to store the negative numbers, and a max-heap to store the positive numbers.\n\
    \        // We will use a min-heap to store the negative numbers, and a max-heap\
    \ to store the positive numbers.\n        // We will use a min-heap to store the\
    \ negative numbers, and a max-heap to store the positive numbers.\n        //\
    \ We", "        // Fill this function body\n        // Sort the array in descending\
    \ order\n        // Return the first k elements\n        arr.sortWith(_ > _).take(k.toInt)",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // return a sorted list of length\
    \ `k` with the maximum `k` numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        val sorted = arr.sorted\n        sorted.takeRight(k.toInt)", "        //\
    \ We can use a max heap to solve this problem.\n        // The heap will have\
    \ size k.\n        // We will iterate through the array, and add each element\
    \ to the heap.\n        // If the heap is full, we will remove the largest element\
    \ from the heap.\n        // After iterating through the array, we will have the\
    \ k largest elements.\n        // We will then return the heap in reverse order.\n\
    \        // Time complexity: O(n log k)\n        // Space complexity: O(k)\n \
    \       val heap = new mutable.PriorityQueue[Long]()\n        for (element <-\
    \ arr) {\n            if (heap.size < k) {\n                heap.enqueue(element)\n\
    \            } else {\n                if (element > heap.head) {\n          \
    \          heap.dequeue\n                    heap.enqueue(element)\n         \
    \       }\n            }\n        }\n        heap.toList.reverse", "        val\
    \ heap = new Heap[Long]((x : Long, y : Long) => x < y)\n        for (i <- arr)\
    \ {\n            heap.push(i)\n            if (heap.size > k) heap.pop\n     \
    \   }\n        heap.toList", "        val heap = new PriorityQueue[Long]()(Ordering.by((_:\
    \ Long) * -1))\n        for (i <- arr) {\n            heap.enqueue(i)\n      \
    \      if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted",
  "        // We can use a max heap to solve this problem.\n        // The max heap\
    \ will contain the largest k elements in the array.\n        // We will iterate\
    \ through the array and add each element to the max heap.\n        // If the max\
    \ heap is larger than k, we will remove the largest element from the max heap.\n\
    \        // Once we have iterated through the entire array, we will return the\
    \ max heap.\n        // The max heap will be sorted in descending order.\n   \
    \     // Time Complexity: O(n log k)\n        // Space Complexity: O(k)\n    \
    \    val maxHeap = new scala.collection.mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (x <- arr) {\n            maxHeap.enqueue(x)\n            if (maxHeap.size\
    \ > k) {\n                maxHeap.dequeue()\n            }\n        }\n      \
    \  maxHeap.toList", "        // Fill this in.\n        var result : List[Long]\
    \ = List[Long]()\n        var temp : List[Long] = List[Long]()\n        for (i\
    \ <- 0 until arr.length) {\n            temp = arr(i) :: temp\n            temp\
    \ = temp.sorted\n            if (temp.length > k) {\n                temp = temp.dropRight(1)\n\
    \            }\n        }\n        result = temp.sorted\n        result = result.reverse\n\
    \        return result", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ this\n        return List[Long]()", "        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is a positive integer\n\
    \        // Return a sorted list of length 'k' with the maximum 'k' numbers in\
    \ 'arr'\n        arr.sorted.takeRight(k.toInt)"]
stop_tokens:
- "\n    }\n"
