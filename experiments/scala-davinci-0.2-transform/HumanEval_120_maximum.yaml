name: HumanEval_120_maximum
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given an array arr of integers and a positive integer k, return a sorted\
  \ list \n    // of length k with the maximum k numbers in arr.\n    // Example 1:\n\
  \    // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n   \
  \ // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n    // Example 2:\n    //\
  \ >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n    // (List[Long](4l.toLong,\
  \ 4l.toLong))\n    // Example 3:\n    // >>> maximum((List[Long](-3l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n    // (List[Long](2l.toLong))\n\
  \    // Note:\n    // 1. The length of the array will be in the range of [1, 1000].\n\
  \    // 2. The elements in the array will be in the range of [-1000, 1000].\n  \
  \  // 3. 0 <= k <= len(arr)\n    def maximum(arr : List[Long], k : Long) : List[Long]\
  \ = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(maximum((List[Long](-3l.toLong,\
  \ -4l.toLong, 5l.toLong)), (3l)).equals((List[Long](-4l.toLong, -3l.toLong, 5l.toLong))));\n\
  \    assert(maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l)).equals((List[Long](4l.toLong,\
  \ 4l.toLong))));\n    assert(maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l)).equals((List[Long](2l.toLong))));\n\
  \    assert(maximum((List[Long](123l.toLong, -123l.toLong, 20l.toLong, 0l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong)), (3l)).equals((List[Long](2l.toLong, 20l.toLong,\
  \ 123l.toLong))));\n    assert(maximum((List[Long](-123l.toLong, 20l.toLong, 0l.toLong,\
  \ 1l.toLong, 2l.toLong, -3l.toLong)), (4l)).equals((List[Long](0l.toLong, 1l.toLong,\
  \ 2l.toLong, 20l.toLong))));\n    assert(maximum((List[Long](5l.toLong, 15l.toLong,\
  \ 0l.toLong, 3l.toLong, -13l.toLong, -8l.toLong, 0l.toLong)), (7l)).equals((List[Long](-13l.toLong,\
  \ -8l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 5l.toLong, 15l.toLong))));\n    assert(maximum((List[Long](-1l.toLong,\
  \ 0l.toLong, 2l.toLong, 5l.toLong, 3l.toLong, -10l.toLong)), (2l)).equals((List[Long](3l.toLong,\
  \ 5l.toLong))));\n    assert(maximum((List[Long](1l.toLong, 0l.toLong, 5l.toLong,\
  \ -7l.toLong)), (1l)).equals((List[Long](5l.toLong))));\n    assert(maximum((List[Long](4l.toLong,\
  \ -4l.toLong)), (2l)).equals((List[Long](-4l.toLong, 4l.toLong))));\n    assert(maximum((List[Long](-10l.toLong,\
  \ 10l.toLong)), (2l)).equals((List[Long](-10l.toLong, 10l.toLong))));\n    assert(maximum((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, -23l.toLong, 243l.toLong, -400l.toLong, 0l.toLong)), (0l)).equals((List[Long]())));\n\
  \    }\n\n}\n"
completions: ["        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n   \
    \     for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        val heap\
    \ = new Heap[Long]((x : Long, y : Long) => x < y)\n        for (i <- 0 until k.toInt)\
    \ heap.insert(arr(i))\n        for (i <- k.toInt until arr.length) {\n       \
    \     if (arr(i) > heap.peek) {\n                heap.remove()\n             \
    \   heap.insert(arr(i))\n            }\n        }\n        heap.toList", "   \
    \     val heap = new Heap[Long]((x : Long, y : Long) => x > y)\n        for (i\
    \ <- arr) {\n            heap.add(i)\n            if (heap.size > k) heap.remove()\n\
    \        }\n        heap.toList", "        // Fill up this function body\n   \
    \     // `arr` is a list of integers\n        // `k` is a positive integer\n \
    \       // Return a sorted list of length `k` with the maximum k numbers in `arr`\n\
    \        arr.sorted.takeRight(k.toInt)", "        // We can use a min heap to\
    \ solve this problem.\n        // The heap will contain the k largest elements\
    \ in arr.\n        // As we iterate through arr, we will add elements to the heap.\n\
    \        // If the heap size is greater than k, we will remove the smallest element.\n\
    \        // This will ensure that the heap always contains the k largest elements.\n\
    \        // At the end, we will return the heap as a sorted list.\n        //\
    \ Time Complexity: O(n log k)\n        // Space Complexity: O(k)\n        val\
    \ heap = new mutable.PriorityQueue[Long]()\n        for (x <- arr) {\n       \
    \     heap.enqueue(x)\n            if (heap.size > k) heap.dequeue\n        }\n\
    \        heap.toList.sorted", "        val sorted = arr.sorted\n        sorted.takeRight(k.toInt)",
  "        // Fill this\n        return arr", "        // Fill up this function body\n\
    \        // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        arr.sorted.takeRight(k.toInt)", "        // We will\
    \ use a heap to store the maximum k numbers.\n        // We will use a min-heap\
    \ to store the negative numbers, and a max-heap to store the positive numbers.\n\
    \        // We will use a min-heap to store the negative numbers, and a max-heap\
    \ to store the positive numbers.\n        // We will use a min-heap to store the\
    \ negative numbers, and a max-heap to store the positive numbers.\n        //\
    \ We will use a min-heap to store the negative numbers, and a max-heap to store\
    \ the positive numbers.\n        // We will use a min-heap to store the negative\
    \ numbers, and a max-heap to store the positive numbers.\n        // We will use\
    \ a min-heap to store the negative numbers, and a max-heap to store the positive\
    \ numbers.\n        // We will use a min-heap to store the negative numbers, and\
    \ a max-heap to store the positive numbers.\n        // We will use a min-heap\
    \ to store the negative numbers, and a max-heap to store the positive numbers.\n\
    \        // We will use a min-heap to store the negative numbers, and a max-heap\
    \ to store the positive numbers.\n        // We will use a min-heap to store the\
    \ negative numbers, and a max-heap to store the positive numbers.\n        //\
    \ We will use a min-heap to store the negative numbers, and a max-heap to store\
    \ the positive numbers.\n        // We will use a min-heap to store the negative\
    \ numbers, and a max-heap to store the positive numbers.\n        // We will use\
    \ a min-heap to store the negative numbers, and a max-heap to store the positive\
    \ numbers.\n        // We will use a min-heap to store the negative numbers, and\
    \ a max-heap to store the positive numbers.\n        // We will use a min-heap\
    \ to store the negative numbers, and a max-heap to store the positive numbers.\n\
    \        // We will use a min-heap to store the negative numbers, and a max-heap\
    \ to store the positive numbers.\n        // We will use a min-heap to store the\
    \ negative numbers, and a max-heap to store the positive numbers.\n        //\
    \ We", "        // Fill this function body\n        // Sort the array in descending\
    \ order\n        // Return the first k elements\n        arr.sortWith(_ > _).take(k.toInt)",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // return a sorted list of length\
    \ `k` with the maximum `k` numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        val sorted = arr.sorted\n        sorted.takeRight(k.toInt)", "        //\
    \ We can use a max heap to solve this problem.\n        // The heap will have\
    \ size k.\n        // We will iterate through the array, and add each element\
    \ to the heap.\n        // If the heap is full, we will remove the largest element\
    \ from the heap.\n        // After iterating through the array, we will have the\
    \ k largest elements.\n        // We will then return the heap in reverse order.\n\
    \        // Time complexity: O(n log k)\n        // Space complexity: O(k)\n \
    \       val heap = new mutable.PriorityQueue[Long]()\n        for (element <-\
    \ arr) {\n            if (heap.size < k) {\n                heap.enqueue(element)\n\
    \            } else {\n                if (element > heap.head) {\n          \
    \          heap.dequeue\n                    heap.enqueue(element)\n         \
    \       }\n            }\n        }\n        heap.toList.reverse", "        val\
    \ heap = new Heap[Long]((x : Long, y : Long) => x < y)\n        for (i <- arr)\
    \ {\n            heap.push(i)\n            if (heap.size > k) heap.pop\n     \
    \   }\n        heap.toList", "        val heap = new PriorityQueue[Long]()(Ordering.by((_:\
    \ Long) * -1))\n        for (i <- arr) {\n            heap.enqueue(i)\n      \
    \      if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted",
  "        // We can use a max heap to solve this problem.\n        // The max heap\
    \ will contain the largest k elements in the array.\n        // We will iterate\
    \ through the array and add each element to the max heap.\n        // If the max\
    \ heap is larger than k, we will remove the largest element from the max heap.\n\
    \        // Once we have iterated through the entire array, we will return the\
    \ max heap.\n        // The max heap will be sorted in descending order.\n   \
    \     // Time Complexity: O(n log k)\n        // Space Complexity: O(k)\n    \
    \    val maxHeap = new scala.collection.mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (x <- arr) {\n            maxHeap.enqueue(x)\n            if (maxHeap.size\
    \ > k) {\n                maxHeap.dequeue()\n            }\n        }\n      \
    \  maxHeap.toList", "        // Fill this in.\n        var result : List[Long]\
    \ = List[Long]()\n        var temp : List[Long] = List[Long]()\n        for (i\
    \ <- 0 until arr.length) {\n            temp = arr(i) :: temp\n            temp\
    \ = temp.sorted\n            if (temp.length > k) {\n                temp = temp.dropRight(1)\n\
    \            }\n        }\n        result = temp.sorted\n        result = result.reverse\n\
    \        return result", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ this\n        return List[Long]()", "        // Fill up this function body\n\
    \        // 'arr' is a list of integers\n        // 'k' is a positive integer\n\
    \        // Return a sorted list of length 'k' with the maximum 'k' numbers in\
    \ 'arr'\n        arr.sorted.takeRight(k.toInt)", "        // The idea is to use\
    \ a min heap to store the k largest elements.\n        // The heap is initialized\
    \ with the first k elements of the array.\n        // Then we iterate through\
    \ the remaining elements of the array.\n        // If the current element is greater\
    \ than the minimum element in the heap,\n        // we remove the minimum element\
    \ from the heap and add the current element to the heap.\n        // In the end,\
    \ the heap will contain the k largest elements.\n        // The time complexity\
    \ is O(nlogk) where n is the length of the array.\n        // The space complexity\
    \ is O(k).\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n  \
    \      for (i <- 0 until k.toInt) heap.enqueue(arr(i))\n        for (i <- k.toInt\
    \ until arr.length) {\n            if (arr(i) > heap.head) {\n               \
    \ heap.dequeue\n                heap.enqueue(arr(i))\n            }\n        }\n\
    \        heap.toList", "        // We can use a heap to solve this problem.\n\
    \        // The heap will contain the k largest elements in the array.\n     \
    \   // We will iterate through the array and add each element to the heap.\n \
    \       // If the heap is full, we will remove the smallest element from the heap.\n\
    \        // If the heap is not full, we will add the element to the heap.\n  \
    \      // After we have iterated through the array, the heap will contain the\
    \ k largest elements.\n        // We will then sort the heap and return it.\n\
    \        // Time complexity: O(n log k)\n        // Space complexity: O(k)\n \
    \       val heap = new mutable.PriorityQueue[Long]()\n        for (x <- arr) {\n\
    \            if (heap.size < k) heap.enqueue(x)\n            else if (x > heap.head)\
    \ {\n                heap.dequeue\n                heap.enqueue(x)\n         \
    \   }\n        }\n        heap.toList.sorted", "        // We can use a heap to\
    \ solve this problem.\n        // The heap will store the k largest elements.\n\
    \        // If the heap has less than k elements, we add the current element to\
    \ the heap.\n        // If the heap has k elements, we compare the current element\
    \ with the minimum element in the heap.\n        // If the current element is\
    \ greater than the minimum element in the heap, we remove the minimum element\
    \ from the heap and add the current element to the heap.\n        // If the current\
    \ element is less than the minimum element in the heap, we do nothing.\n     \
    \   // After we have processed all the elements in the array, we return the elements\
    \ in the heap.\n        // The time complexity of this algorithm is O(n log k).\n\
    \        // The space complexity of this algorithm is O(k).\n        val heap\
    \ = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (i <- arr) {\n\
    \            if (heap.size < k) heap.enqueue(i)\n            else if (i > heap.head)\
    \ {\n                heap.dequeue\n                heap.enqueue(i)\n         \
    \   }\n        }\n        heap.toList", "        // We can use a priority queue\
    \ to solve this problem.\n        // The priority queue will contain the k largest\
    \ elements.\n        // We can then sort the priority queue and return the result.\n\
    \        // The time complexity of this algorithm is O(n log k) and the space\
    \ complexity is O(k).\n        val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (x <- arr) {\n            pq.enqueue(x)\n            if (pq.size\
    \ > k) pq.dequeue\n        }\n        pq.toList.sorted", "        // We can use\
    \ a min-heap to solve this problem.\n        // The heap will contain the k largest\
    \ elements.\n        // If we encounter an element that is larger than the minimum\
    \ element in the heap,\n        // we remove the minimum element and add the new\
    \ element.\n        // This will ensure that the heap contains the k largest elements.\n\
    \        // The time complexity is O(n log k) and the space complexity is O(k).\n\
    \        val heap = new scala.collection.mutable.PriorityQueue[Long]()\n     \
    \   for (x <- arr) {\n            if (heap.size < k) heap.enqueue(x)\n       \
    \     else if (x > heap.head) {\n                heap.dequeue\n              \
    \  heap.enqueue(x)\n            }\n        }\n        heap.toList.sorted", " \
    \       val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i\
    \ <- arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        // We can use a heap to solve\
    \ this problem.\n        // The heap will be a min-heap.\n        // The heap\
    \ will contain the k largest elements.\n        // We will iterate through the\
    \ array and add each element to the heap.\n        // If the heap is full, we\
    \ will remove the smallest element in the heap.\n        // After we have iterated\
    \ through the array, we will return the heap.\n        // The heap will be sorted\
    \ in ascending order.\n        // We will reverse the heap to get the descending\
    \ order.\n        // We will return the heap.\n        // Time Complexity: O(n\
    \ log k)\n        // Space Complexity: O(k)\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.reverse", "        val heap\
    \ = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- arr) {\n   \
    \         heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n     \
    \   }\n        heap.toList.sorted", "        // Fill up this function body\n \
    \       // `arr` is a list of integers\n        // `k` is a positive integer\n\
    \        // You have to return a sorted list of length `k` with the maximum k\
    \ numbers in `arr`\n        // You can assume that `k` is less than or equal to\
    \ the length of `arr`\n        // You can assume that `k` is greater than 0\n\
    \        var result = List[Long]()\n        var max = -1001l\n        var maxIndex\
    \ = -1\n        for (i <- 0 until k.toInt) {\n            for (j <- 0 until arr.length)\
    \ {\n                if (arr(j) > max) {\n                    max = arr(j)\n \
    \                   maxIndex = j\n                }\n            }\n         \
    \   result = result :+ max\n            arr = arr.patch(maxIndex, Nil, 1)\n  \
    \          max = -1001l\n            maxIndex = -1\n        }\n        result",
  "        // We can use a min-heap to solve this problem.\n        // The idea is\
    \ to keep the heap size at k, and if the next element is greater than the minimum\n\
    \        // element in the heap, we remove the minimum element and add the next\
    \ element to the heap.\n        // This way, we will always have the k largest\
    \ elements in the heap.\n        // We can use a min-heap to solve this problem.\n\
    \        // The idea is to keep the heap size at k, and if the next element is\
    \ greater than the minimum\n        // element in the heap, we remove the minimum\
    \ element and add the next element to the heap.\n        // This way, we will\
    \ always have the k largest elements in the heap.\n        val heap = new PriorityQueue[Long]()(Ordering.by((_\
    \ : Long) * -1))\n        for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n\
    \            else if (i > heap.head) {\n                heap.dequeue\n       \
    \         heap.enqueue(i)\n            }\n        }\n        heap.toList.sorted",
  "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <-\
    \ arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // We can\
    \ use a heap to solve this problem.\n        // The heap will be of size k.\n\
    \        // We will add the first k elements to the heap.\n        // For each\
    \ element after the first k elements, we will compare it to the minimum element\
    \ in the heap.\n        // If the element is greater than the minimum element,\
    \ we will remove the minimum element and add the new element.\n        // We will\
    \ continue this process until we have processed all elements.\n        // Then\
    \ we will return the heap.\n        // The time complexity is O(n log k) and the\
    \ space complexity is O(k).\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (i <- 0 until k.toInt) {\n            heap.enqueue(arr(i))\n    \
    \    }\n        for (i <- k.toInt until arr.length) {\n            if (arr(i)\
    \ > heap.head) {\n                heap.dequeue\n                heap.enqueue(arr(i))\n\
    \            }\n        }\n        heap.toList.sorted", "        var result :\
    \ List[Long] = List[Long]()\n        var max : Long = 0\n        var maxIndex\
    \ : Int = 0\n        for (i <- 0 to k.toInt - 1) {\n            max = arr(0)\n\
    \            maxIndex = 0\n            for (j <- 0 to arr.length - 1) {\n    \
    \            if (arr(j) > max) {\n                    max = arr(j)\n         \
    \           maxIndex = j\n                }\n            }\n            result\
    \ = result :+ max\n            arr = arr.take(maxIndex) ++ arr.drop(maxIndex +\
    \ 1)\n        }\n        return result", "        // Fill up this function body\n\
    \        // You can add another function as well, if required\n        var result\
    \ : List[Long] = List[Long]()\n        var temp : List[Long] = List[Long]()\n\
    \        var index : Long = 0l\n        var max : Long = 0l\n        var maxIndex\
    \ : Long = 0l\n        for (i <- 0l until k) {\n            max = arr(i.toInt)\n\
    \            maxIndex = i\n            for (j <- i + 1l until arr.length) {\n\
    \                if (arr(j.toInt) > max) {\n                    max = arr(j.toInt)\n\
    \                    maxIndex = j\n                }\n            }\n        \
    \    temp = arr.updated(maxIndex.toInt, arr(i.toInt))\n            temp = temp.updated(i.toInt,\
    \ max)\n            arr = temp\n            result = result :+ max\n        }\n\
    \        return result", "        // We can use a heap to solve this problem.\n\
    \        // The heap will store the largest k elements in the array.\n       \
    \ // If the heap is full and the next element is larger than the smallest element\
    \ in the heap,\n        // then we remove the smallest element and add the new\
    \ element.\n        // The heap will be sorted in descending order.\n        //\
    \ The heap will have a maximum size of k.\n        // We will use a min-heap to\
    \ store the elements.\n        // The heap will be sorted in ascending order.\n\
    \        // The heap will have a maximum size of k.\n        // We will use a\
    \ max-heap to store the elements.\n        // The heap will be sorted in descending\
    \ order.\n        // The heap will have a maximum size of k.\n        // We will\
    \ use a min-heap to store the elements.\n        // The heap will be sorted in\
    \ ascending order.\n        // The heap will have a maximum size of k.\n     \
    \   // We will use a max-heap to store the elements.\n        // The heap will\
    \ be sorted in descending order.\n        // The heap will have a maximum size\
    \ of k.\n        // We will use a min-heap to store the elements.\n        //\
    \ The heap will be sorted in ascending order.\n        // The heap will have a\
    \ maximum size of k.\n        // We will use a max-heap to store the elements.\n\
    \        // The heap will be sorted in descending order.\n        // The heap\
    \ will have a maximum size of k.\n        // We will use a min-heap to store the\
    \ elements.\n        // The heap will be sorted in ascending order.\n        //\
    \ The heap will have a maximum size of k.\n        // We will use a max-heap to\
    \ store the elements.\n        // The heap will be sorted in descending order.\n\
    \        // The heap will have a maximum size of k.\n        // We will use a\
    \ min-heap to store the elements.\n        // The heap will be sorted in ascending\
    \ order.\n        // The heap will have a maximum size of k.\n        // We will\
    \ use a max-heap to store the elements.\n        // The heap will be sorted in\
    \ descending order.\n        // The heap will have a maximum size of k.\n    \
    \    // We will use a min-heap to", "        // Fill this in.\n        var result\
    \ : List[Long] = List[Long]()\n        var temp : List[Long] = List[Long]()\n\
    \        var temp2 : List[Long] = List[Long]()\n        var temp3 : List[Long]\
    \ = List[Long]()\n        var temp4 : List[Long] = List[Long]()\n        var temp5\
    \ : List[Long] = List[Long]()\n        var temp6 : List[Long] = List[Long]()\n\
    \        var temp7 : List[Long] = List[Long]()\n        var temp8 : List[Long]\
    \ = List[Long]()\n        var temp9 : List[Long] = List[Long]()\n        var temp10\
    \ : List[Long] = List[Long]()\n        var temp11 : List[Long] = List[Long]()\n\
    \        var temp12 : List[Long] = List[Long]()\n        var temp13 : List[Long]\
    \ = List[Long]()\n        var temp14 : List[Long] = List[Long]()\n        var\
    \ temp15 : List[Long] = List[Long]()\n        var temp16 : List[Long] = List[Long]()\n\
    \        var temp17 : List[Long] = List[Long]()\n        var temp18 : List[Long]\
    \ = List[Long]()\n        var temp19 : List[Long] = List[Long]()\n        var\
    \ temp20 : List[Long] = List[Long]()\n        var temp21 : List[Long] = List[Long]()\n\
    \        var temp22 : List[Long] = List[Long]()\n        var temp23 : List[Long]\
    \ = List[Long]()\n        var temp24 : List[Long] = List[Long]()\n        var\
    \ temp25 : List[Long] = List[Long]()\n        var temp26 : List[Long] = List[Long]()\n\
    \        var temp27 : List[Long] = List[Long]()\n        var temp28 : List[Long]\
    \ = List[Long]()\n        var temp29 : List[Long] = List[Long]()\n        var\
    \ temp30 : List[Long] = List[Long]()\n        var temp31 : List[Long] =", "  \
    \      // We can solve this problem using a max heap.\n        // The max heap\
    \ will contain the k largest elements.\n        // We can then iterate over the\
    \ array and add each element to the heap.\n        // If the heap is full, we\
    \ can compare the current element to the top of the heap.\n        // If the current\
    \ element is larger than the top of the heap, we can remove the top of the heap\n\
    \        // and add the current element to the heap.\n        // After iterating\
    \ over the array, we can return the heap as a sorted list.\n        // This algorithm\
    \ runs in O(n log k) time and O(k) space.\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n  \
    \          else if (i > heap.head) {\n                heap.dequeue\n         \
    \       heap.enqueue(i)\n            }\n        }\n        heap.toList.sorted",
  "        val heap = new PriorityQueue[Long]()(Ordering.by[Long, Long](-_))\n   \
    \     for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        val heap\
    \ = new Heap[Long]((a : Long, b : Long) => a > b)\n        for (i <- arr) {\n\
    \            heap.add(i)\n            if (heap.size > k) heap.remove()\n     \
    \   }\n        heap.toList", "        val pq = new PriorityQueue[Long]()(Ordering.by(x\
    \ => -x))\n        for (i <- arr) {\n            pq.enqueue(i)\n            if\
    \ (pq.size > k) pq.dequeue\n        }\n        pq.toList", "        // Given an\
    \ array arr of integers and a positive integer k, return a sorted list \n    \
    \    // of length k with the maximum k numbers in arr.\n        // Example 1:\n\
    \        // >>> maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n\
    \        // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n        // Example\
    \ 2:\n        // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \        // (List[Long](4l.toLong, 4l.toLong))\n        // Example 3:\n      \
    \  // >>> maximum((List[Long](-3l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong,\
    \ -2l.toLong, 1l.toLong)), (1l))\n        // (List[Long](2l.toLong))\n       \
    \ // Note:\n        // 1. The length of the array will be in the range of [1,\
    \ 1000].\n        // 2. The elements in the array will be in the range of [-1000,\
    \ 1000].\n        // 3. 0 <= k <= len(arr)\n        def maximum(arr : List[Long],\
    \ k : Long) : List[Long] = {\n            // Given an array arr of integers and\
    \ a positive integer k, return a sorted list \n            // of length k with\
    \ the maximum k numbers in arr.\n            // Example 1:\n            // >>>\
    \ maximum((List[Long](-3l.toLong, -4l.toLong, 5l.toLong)), (3l))\n           \
    \ // (List[Long](-4l.toLong, -3l.toLong, 5l.toLong))\n            // Example 2:\n\
    \            // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)), (2l))\n\
    \            // (List[Long](4l.toLong, 4l.toLong))\n            // Example 3:\n\
    \            // >>> maximum((List[Long](-3l.toLong, 2l.toLong,", "        val\
    \ heap = new Heap[Long](arr, (a : Long, b : Long) => a > b)\n        val result\
    \ = new ListBuffer[Long]\n        for (i <- 0l until k) {\n            result\
    \ += heap.pop\n        }\n        result.toList", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        val heap\
    \ = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- arr) {\n   \
    \         heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n     \
    \   }\n        heap.toList.sorted", "        var result : List[Long] = List[Long]()\n\
    \        var max : Long = 0\n        for (i <- 0 until k.toInt) {\n          \
    \  max = arr.max\n            result = result :+ max\n            arr = arr.filter(x\
    \ => x != max)\n        }\n        return result", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.dequeueAll.toList", "        // We\
    \ can use a heap to solve this problem.\n        // We can use a max heap to store\
    \ the k largest elements.\n        // The heap will be sorted in descending order.\n\
    \        // We can then return the heap as a list.\n        // The time complexity\
    \ is O(n * log(k)) and the space complexity is O(k).\n        val heap = new mutable.PriorityQueue[Long]()\n\
    \        for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n  \
    \          else {\n                if (i > heap.head) {\n                    heap.dequeue\n\
    \                    heap.enqueue(i)\n                }\n            }\n     \
    \   }\n        heap.toList.sorted.reverse", "        val heap = new PriorityQueue[Long]()(Ordering.by((_:\
    \ Long) * -1))\n        for (i <- arr) {\n            heap.enqueue(i)\n      \
    \      if (heap.size > k) heap.dequeue\n        }\n        heap.toList.sorted",
  "        // Fill this function body\n        // You can add another function as\
    \ well, if required\n        arr.sorted.takeRight(k.toInt)", "        val heap\
    \ = new PriorityQueue[Long]()(Ordering.by((_: Long) * -1))\n        for (i <-\
    \ arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        // Fill this in.\n        var\
    \ result : List[Long] = List[Long]()\n        var max : Long = 0\n        var\
    \ maxIndex : Int = 0\n        var i : Int = 0\n        while (i < k) {\n     \
    \       max = -1000\n            maxIndex = 0\n            for (j <- 0 to arr.length\
    \ - 1) {\n                if (arr(j) > max) {\n                    max = arr(j)\n\
    \                    maxIndex = j\n                }\n            }\n        \
    \    result = result :+ max\n            arr = arr.updated(maxIndex, -1001)\n\
    \            i += 1\n        }\n        return result", "        // Fill up this\
    \ function body\n        // `arr` is a list of integers\n        // `k` is a positive\
    \ integer\n        // You have to return a sorted list of length `k` with the\
    \ maximum k numbers in `arr`\n        // You can assume that `k` is less than\
    \ or equal to the length of `arr`\n        // You can assume that `k` is greater\
    \ than 0\n        arr.sorted.takeRight(k.toInt)", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ up this function body\n        // `arr` is a list of integers\n        // `k`\
    \ is a positive integer\n        // Return a sorted list of length `k` with the\
    \ maximum k numbers in `arr`\n        arr.sorted.takeRight(k.toInt)", "      \
    \  val sorted = arr.sorted\n        sorted.takeRight(k.toInt)", "        val heap\
    \ = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- arr) {\n   \
    \         heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n     \
    \   }\n        heap.toList.sorted", "        // We can use a heap to solve this\
    \ problem.\n        // We can use a min-heap to store the maximum k numbers.\n\
    \        // We can use a max-heap to store the minimum k numbers.\n        //\
    \ We can use a min-heap to store the maximum k numbers.\n        // We can use\
    \ a max-heap to store the minimum k numbers.\n        // We can use a min-heap\
    \ to store the maximum k numbers.\n        // We can use a max-heap to store the\
    \ minimum k numbers.\n        // We can use a min-heap to store the maximum k\
    \ numbers.\n        // We can use a max-heap to store the minimum k numbers.\n\
    \        // We can use a min-heap to store the maximum k numbers.\n        //\
    \ We can use a max-heap to store the minimum k numbers.\n        // We can use\
    \ a min-heap to store the maximum k numbers.\n        // We can use a max-heap\
    \ to store the minimum k numbers.\n        // We can use a min-heap to store the\
    \ maximum k numbers.\n        // We can use a max-heap to store the minimum k\
    \ numbers.\n        // We can use a min-heap to store the maximum k numbers.\n\
    \        // We can use a max-heap to store the minimum k numbers.\n        //\
    \ We can use a min-heap to store the maximum k numbers.\n        // We can use\
    \ a max-heap to store the minimum k numbers.\n        // We can use a min-heap\
    \ to store the maximum k numbers.\n        // We can use a max-heap to store the\
    \ minimum k numbers.\n        // We can use a min-heap to store the maximum k\
    \ numbers.\n        // We can use a max-heap to store the minimum k numbers.\n\
    \        // We can use a min-heap to store the maximum k numbers.\n        //\
    \ We can use a max-heap to store the minimum k numbers.\n        // We can use\
    \ a min-heap to store the maximum k numbers.\n        // We can use a max-heap\
    \ to store the minimum k numbers.\n        // We can use a min-heap to store the\
    \ maximum k numbers.\n        // We can use a max-heap to store", "        //\
    \ We can use a heap to solve this problem.\n        // The heap will store the\
    \ k largest elements in the array.\n        // If the heap has k elements and\
    \ the next element in the array is larger than the smallest element in the heap,\n\
    \        // then we remove the smallest element from the heap and add the new\
    \ element.\n        // Otherwise, we do nothing.\n        // At the end, we return\
    \ the elements in the heap in sorted order.\n        // The heap will be implemented\
    \ as a min-heap.\n        // The heap will be implemented as a min-heap.\n   \
    \     // The heap will be implemented as a min-heap.\n        // The heap will\
    \ be implemented as a min-heap.\n        // The heap will be implemented as a\
    \ min-heap.\n        // The heap will be implemented as a min-heap.\n        //\
    \ The heap will be implemented as a min-heap.\n        // The heap will be implemented\
    \ as a min-heap.\n        // The heap will be implemented as a min-heap.\n   \
    \     // The heap will be implemented as a min-heap.\n        // The heap will\
    \ be implemented as a min-heap.\n        // The heap will be implemented as a\
    \ min-heap.\n        // The heap will be implemented as a min-heap.\n        //\
    \ The heap will be implemented as a min-heap.\n        // The heap will be implemented\
    \ as a min-heap.\n        // The heap will be implemented as a min-heap.\n   \
    \     // The heap will be implemented as a min-heap.\n        // The heap will\
    \ be implemented as a min-heap.\n        // The heap will be implemented as a\
    \ min-heap.\n        // The heap will be implemented as a min-heap.\n        //\
    \ The heap will be implemented as a min-heap.\n        // The heap will be implemented\
    \ as a min-heap.\n        // The heap will be implemented as a min-heap.\n   \
    \     // The heap will be implemented as a min-heap.\n        // The heap will\
    \ be implemented as a min-heap.\n        // The heap will be implemented as a\
    \ min-heap.\n        // The heap will be implemented as a min-heap.\n        //\
    \ The heap will be implemented", "        // We can use a max heap to solve this\
    \ problem.\n        // The max heap will have a size of k.\n        // We will\
    \ iterate through the array and add each element to the heap.\n        // If the\
    \ heap is full, we will remove the largest element from the heap.\n        //\
    \ After iterating through the array, we will have the k largest elements in the\
    \ heap.\n        // We will then return the heap as a sorted list.\n        val\
    \ heap = new MaxHeap[Long](k.toInt)\n        for (i <- arr) {\n            if\
    \ (heap.size < k) {\n                heap.add(i)\n            } else {\n     \
    \           if (i > heap.peek) {\n                    heap.remove()\n        \
    \            heap.add(i)\n                }\n            }\n        }\n      \
    \  heap.toList", "        // We can use a heap to solve this problem.\n      \
    \  // The heap will store the k largest elements.\n        // If the heap size\
    \ is less than k, then we add the element to the heap.\n        // If the heap\
    \ size is equal to k, then we check if the element is greater than the minimum\
    \ element in the heap.\n        // If it is, then we remove the minimum element\
    \ and add the new element.\n        // If it is not, then we do nothing.\n   \
    \     // After we have iterated through the entire array, we return the heap.\n\
    \        // The heap will be sorted in ascending order, so we reverse it.\n  \
    \      // Time Complexity: O(n * log(k))\n        // Space Complexity: O(k)\n\
    \        val heap = new mutable.PriorityQueue[Long]()\n        for (element <-\
    \ arr) {\n            if (heap.size < k) heap.enqueue(element)\n            else\
    \ if (element > heap.head) {\n                heap.dequeue\n                heap.enqueue(element)\n\
    \            }\n        }\n        heap.toList.reverse", "        val sorted =\
    \ arr.sorted\n        sorted.takeRight(k.toInt)", "        val heap = new Heap[Long]((x\
    \ : Long, y : Long) => x > y)\n        for (i <- arr) {\n            heap.insert(i)\n\
    \            if (heap.size > k) heap.extract()\n        }\n        heap.toList",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // You have to return a sorted\
    \ list of length `k` with the maximum k numbers in `arr`\n        // You can assume\
    \ that `k` is less than or equal to the length of `arr`\n        // You can assume\
    \ that `k` is greater than 0\n        arr.sorted.takeRight(k.toInt)", '        arr.sortWith(_
    > _).take(k.toInt)', "        // We can use a priority queue to solve this problem.\n\
    \        // We can use a min heap to store the first k elements.\n        // Then,\
    \ for each element after the first k, we can compare it to the top of the heap.\n\
    \        // If it is greater than the top of the heap, we can remove the top of\
    \ the heap and add the new element.\n        // This will ensure that the heap\
    \ always contains the k largest elements.\n        // Then, we can simply return\
    \ the heap as a sorted list.\n        // This will take O(n log k) time and O(k)\
    \ space.\n        val heap = new mutable.PriorityQueue[Long]()\n        for (i\
    \ <- 0 until k.toInt) {\n            heap.enqueue(arr(i))\n        }\n       \
    \ for (i <- k.toInt until arr.length) {\n            if (arr(i) > heap.head) {\n\
    \                heap.dequeue\n                heap.enqueue(arr(i))\n        \
    \    }\n        }\n        heap.toList.sorted", "        // We can use a max heap\
    \ to solve this problem.\n        // The time complexity is O(n log k).\n    \
    \    // The space complexity is O(k).\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ up this function body\n        // `arr` is a list of integers\n        // `k`\
    \ is a positive integer\n        // You have to return a sorted list of length\
    \ `k` with the maximum k numbers in `arr`\n        // You can assume that `k`\
    \ is less than or equal to the length of `arr`\n        // You can assume that\
    \ `k` is greater than 0\n        arr.sortWith(_ > _).take(k.toInt)", "       \
    \ // Fill this function body\n        // You have to return a list of Long\n \
    \       // Do not change the function signature\n        arr.sorted.takeRight(k.toInt)",
  "        // We can use a heap to solve this problem.\n        // A heap is a data\
    \ structure that allows us to efficiently find the maximum element.\n        //\
    \ We can use a min-heap to find the maximum k elements in the array.\n       \
    \ // We can use the heap to keep track of the k largest elements we've seen so\
    \ far.\n        // As we iterate through each element of the array, we will offer\
    \ it to the heap.\n        // If the heap has fewer than k elements, we can offer\
    \ the element to the heap.\n        // If the heap has k elements, we can peek\
    \ at the minimum element.\n        // If the current element is greater than the\
    \ minimum element, we can poll the minimum element and offer the current element.\n\
    \        // This will maintain the heap property.\n        // After we are done\
    \ iterating through the array, we can poll all the elements from the heap.\n \
    \       // This will give us the maximum k elements in the array.\n        //\
    \ Time Complexity: O(n log k)\n        // Space Complexity: O(k)\n        val\
    \ heap = new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (x <- arr)\
    \ {\n            if (heap.size < k) heap.offer(x)\n            else if (x > heap.peek)\
    \ {\n                heap.poll\n                heap.offer(x)\n            }\n\
    \        }\n        val result = new ListBuffer[Long]()\n        while (!heap.isEmpty)\
    \ result += heap.poll\n        result.toList", "        var result : List[Long]\
    \ = List[Long]()\n        var max : Long = -1001l\n        var maxIndex : Int\
    \ = -1\n        for (i <- 0 until k.toInt) {\n            for (j <- 0 until arr.length)\
    \ {\n                if (arr(j) > max) {\n                    max = arr(j)\n \
    \                   maxIndex = j\n                }\n            }\n         \
    \   result = result :+ max\n            arr(maxIndex) = -1001l\n            max\
    \ = -1001l\n        }\n        return result", "        val heap = new Heap[Long]((a\
    \ : Long, b : Long) => a > b)\n        for (i <- 0 until arr.length) {\n     \
    \       if (heap.size < k) heap.insert(arr(i))\n            else if (arr(i) >\
    \ heap.peek) {\n                heap.pop\n                heap.insert(arr(i))\n\
    \            }\n        }\n        heap.toList", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        val heap\
    \ = new PriorityQueue[Long]()(Ordering.by(x => -x))\n        for (i <- arr) {\n\
    \            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n  \
    \      }\n        heap.toList", "        // We can use a min heap to solve this\
    \ problem.\n        // The heap will contain the k largest elements in the array.\n\
    \        // We will iterate through the array, and if the element is larger than\
    \ the smallest element in the heap,\n        // we will remove the smallest element\
    \ and add the new element to the heap.\n        // At the end, we will have the\
    \ k largest elements in the heap.\n        // We can then sort the heap and return\
    \ it.\n        // Time Complexity: O(n log k)\n        // Space Complexity: O(k)\n\
    \        val heap = new mutable.PriorityQueue[Long]()\n        for (i <- arr)\
    \ {\n            if (heap.size < k) heap.enqueue(i)\n            else if (i >\
    \ heap.head) {\n                heap.dequeue\n                heap.enqueue(i)\n\
    \            }\n        }\n        heap.toList.sorted", "        val heap = new\
    \ MinHeap[Long](k.toInt)\n        for (i <- arr) {\n            if (heap.size\
    \ < k) heap.insert(i)\n            else if (i > heap.peek) {\n               \
    \ heap.remove\n                heap.insert(i)\n            }\n        }\n    \
    \    heap.toList", "        // We can use a min-heap to solve this problem.\n\
    \        // The heap will contain the maximum k numbers in arr.\n        // We\
    \ will iterate through arr and add each element to the heap.\n        // If the\
    \ heap contains more than k elements, we will remove the minimum element.\n  \
    \      // After iterating through arr, we will return the sorted heap.\n     \
    \   val heap = new mutable.PriorityQueue[Long]()\n        for (x <- arr) {\n \
    \           heap.enqueue(x)\n            if (heap.size > k) heap.dequeue\n   \
    \     }\n        heap.toList.sorted", "        // Fill this in.\n        var result\
    \ : List[Long] = List[Long]()\n        var max : Long = 0\n        var maxIndex\
    \ : Int = 0\n        for (i <- 0 to arr.length - 1) {\n            if (arr(i)\
    \ > max) {\n                max = arr(i)\n                maxIndex = i\n     \
    \       }\n        }\n        result = result :+ max\n        arr.remove(maxIndex)\n\
    \        for (i <- 0 to k - 2) {\n            max = 0\n            maxIndex =\
    \ 0\n            for (j <- 0 to arr.length - 1) {\n                if (arr(j)\
    \ > max) {\n                    max = arr(j)\n                    maxIndex = j\n\
    \                }\n            }\n            result = result :+ max\n      \
    \      arr.remove(maxIndex)\n        }\n        result", "        val heap = new\
    \ Heap[Long]((a : Long, b : Long) => a > b)\n        for (i <- arr) {\n      \
    \      heap.add(i)\n            if (heap.size > k) heap.remove\n        }\n  \
    \      heap.toList", "        // We can use a heap to solve this problem.\n  \
    \      // The heap will be a max-heap, and it will contain the k largest elements.\n\
    \        // We will iterate through the array, and if the current element is larger\
    \ than the smallest element in the heap,\n        // we will replace the smallest\
    \ element in the heap with the current element.\n        // At the end, we will\
    \ return the heap.\n        // The heap will be implemented using a priority queue.\n\
    \        // The priority queue will be a max-heap.\n        // The priority queue\
    \ will be implemented using a binary heap.\n        // The binary heap will be\
    \ implemented using an array.\n        // The binary heap will be a max-heap.\n\
    \        // The binary heap will be implemented using the following functions:\n\
    \        // 1. get_left_child_index(index)\n        // 2. get_right_child_index(index)\n\
    \        // 3. get_parent_index(index)\n        // 4. swap(index1, index2)\n \
    \       // 5. heapify_up(index)\n        // 6. heapify_down(index)\n        //\
    \ 7. insert(value)\n        // 8. extract_max()\n        // 9. get_max()\n   \
    \     // 10. get_size()\n        // 11. is_empty()\n        // 12. heap_sort(array)\n\
    \        // 13. print_heap()\n        // 14. print_array(array)\n        // The\
    \ heap will be implemented using the following functions:\n        // 1. get_left_child_index(index)\n\
    \        // 2. get_right_child_index(index)\n        // 3. get_parent_index(index)\n\
    \        // 4. swap(index1, index2)\n        // 5. heapify_up(index)\n       \
    \ // 6. heapify_down(index)\n        // 7. insert(value)\n        // 8. extract_max()\n\
    \        // 9. get_max()\n        // 10. get_size()\n        // 11. is_empty()\n\
    \        // 12. heap_sort(array)\n        // 13. print_heap()\n        // 14.\
    \ print_array(array)\n        // The heap will be implemented using the following\
    \ functions", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Define\
    \ a recursive function to solve this problem\n        def maximumHelper(arr :\
    \ List[Long], k : Long, result : List[Long]) : List[Long] = {\n            if\
    \ (k == 0) result\n            else {\n                val max = arr.max\n   \
    \             val index = arr.indexOf(max)\n                val newArr = arr.take(index)\
    \ ++ arr.drop(index + 1)\n                maximumHelper(newArr, k - 1, result\
    \ :+ max)\n            }\n        }\n        // Return the result\n        maximumHelper(arr,\
    \ k, List[Long]())", "        // Fill this\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill this\n        return List[Long]()", "        // We can use a heap\
    \ to solve this problem.\n        // We can use a min heap to keep track of the\
    \ largest k elements.\n        // We can then sort the heap and return the result.\n\
    \        // This will take O(n log k) time and O(k) space.\n        val heap =\
    \ new Heap[Long]((x : Long, y : Long) => x < y)\n        for (x <- arr) {\n  \
    \          if (heap.size < k) heap.push(x)\n            else {\n             \
    \   if (x > heap.peek) {\n                    heap.pop\n                    heap.push(x)\n\
    \                }\n            }\n        }\n        heap.sort", "        //\
    \ Fill this in.\n        val sorted = arr.sorted\n        val length = sorted.length\n\
    \        val result = sorted.slice(length - k.toInt, length)\n        result",
  "        // Fill this in.\n        val sorted = arr.sorted\n        val result =\
    \ new ListBuffer[Long]\n        for (i <- 0 until k.toInt) {\n            result\
    \ += sorted(sorted.length - 1 - i)\n        }\n        result.toList", "     \
    \   val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- arr)\
    \ {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        // Define a recursive function\
    \ to solve this problem\n        def maximumHelper(arr : List[Long], k : Long,\
    \ acc : List[Long]) : List[Long] = {\n            // Base case\n            if\
    \ (k == 0) acc\n            // Recursive case\n            else {\n          \
    \      val max = arr.max\n                maximumHelper(arr.filter(x => x != max),\
    \ k - 1, acc :+ max)\n            }\n        }\n        // Call the helper function\n\
    \        maximumHelper(arr, k, List[Long]())", "        var result : List[Long]\
    \ = List[Long]()\n        var max : Long = 0\n        var maxIndex : Int = 0\n\
    \        for (i <- 0 to arr.length - 1) {\n            if (arr(i) > max) {\n \
    \               max = arr(i)\n                maxIndex = i\n            }\n  \
    \      }\n        result = result :+ max\n        var arr2 : List[Long] = arr.slice(0,\
    \ maxIndex) ++ arr.slice(maxIndex + 1, arr.length)\n        for (i <- 0 to k -\
    \ 2) {\n            max = 0\n            maxIndex = 0\n            for (j <- 0\
    \ to arr2.length - 1) {\n                if (arr2(j) > max) {\n              \
    \      max = arr2(j)\n                    maxIndex = j\n                }\n  \
    \          }\n            result = result :+ max\n            arr2 = arr2.slice(0,\
    \ maxIndex) ++ arr2.slice(maxIndex + 1, arr2.length)\n        }\n        return\
    \ result", "        var result : List[Long] = List()\n        var arr_copy : List[Long]\
    \ = arr\n        for (i <- 0l.toLong to k - 1l.toLong) {\n            val max_value\
    \ : Long = arr_copy.max\n            result = result :+ max_value\n          \
    \  arr_copy = arr_copy.filter(x => x != max_value)\n        }\n        return\
    \ result", "        val sorted = arr.sorted\n        val result = new ListBuffer[Long]\n\
    \        for (i <- (sorted.length - k).toInt to sorted.length - 1) {\n       \
    \     result += sorted(i)\n        }\n        result.toList", "        val heap\
    \ = new Heap[Long]((x : Long, y : Long) => x > y)\n        for (x <- arr) {\n\
    \            heap.push(x)\n            if (heap.size > k) heap.pop\n        }\n\
    \        heap.toList", "        val heap = new PriorityQueue[Long]()(Ordering.by[Long,\
    \ Long](-_))\n        for (i <- arr) {\n            heap.enqueue(i)\n        \
    \    if (heap.size > k) heap.dequeue\n        }\n        heap.dequeueAll.toList",
  "        // Fill this in.\n        val arr_sorted = arr.sorted\n        val arr_sorted_rev\
    \ = arr_sorted.reverse\n        val arr_sorted_rev_k = arr_sorted_rev.take(k.toInt)\n\
    \        arr_sorted_rev_k", "        val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            pq.enqueue(i)\n            if (pq.size\
    \ > k) pq.dequeue\n        }\n        pq.toList.sorted", "        val heap = new\
    \ PriorityQueue[Long]()(Ordering.by((_: Long) * -1))\n        for (i <- arr) {\n\
    \            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n  \
    \      }\n        heap.toList.sorted", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ this in.\n        arr.sortWith(_ > _).take(k.toInt)", "        // We can use\
    \ a heap to solve this problem.\n        // We can use a max heap to store the\
    \ k largest elements.\n        // We can use a min heap to store the k smallest\
    \ elements.\n        // We can use a max heap to store the k largest elements.\n\
    \        // We can use a min heap to store the k smallest elements.\n        //\
    \ We can use a max heap to store the k largest elements.\n        // We can use\
    \ a min heap to store the k smallest elements.\n        // We can use a max heap\
    \ to store the k largest elements.\n        // We can use a min heap to store\
    \ the k smallest elements.\n        // We can use a max heap to store the k largest\
    \ elements.\n        // We can use a min heap to store the k smallest elements.\n\
    \        // We can use a max heap to store the k largest elements.\n        //\
    \ We can use a min heap to store the k smallest elements.\n        // We can use\
    \ a max heap to store the k largest elements.\n        // We can use a min heap\
    \ to store the k smallest elements.\n        // We can use a max heap to store\
    \ the k largest elements.\n        // We can use a min heap to store the k smallest\
    \ elements.\n        // We can use a max heap to store the k largest elements.\n\
    \        // We can use a min heap to store the k smallest elements.\n        //\
    \ We can use a max heap to store the k largest elements.\n        // We can use\
    \ a min heap to store the k smallest elements.\n        // We can use a max heap\
    \ to store the k largest elements.\n        // We can use a min heap to store\
    \ the k smallest elements.\n        // We can use a max heap to store the k largest\
    \ elements.\n        // We can use a min heap to store the k smallest elements.\n\
    \        // We can use a max heap to store the k largest elements.\n        //\
    \ We can use a min heap to store the k smallest elements.\n        // We can use\
    \ a max heap to store the k largest elements.\n        // We can use a min heap\
    \ to store the k smallest elements.\n        // We can use a max heap to store\
    \ the k largest elements.\n        // We can use a min heap to store the k smallest\
    \ elements.\n        // We can use a max heap to store the k largest elements.\n\
    \        //", "        var result : List[Long] = List[Long]()\n        var max\
    \ : Long = 0\n        var maxIndex : Int = 0\n        for (i <- 0 to arr.length\
    \ - 1) {\n            if (arr(i) > max) {\n                max = arr(i)\n    \
    \            maxIndex = i\n            }\n        }\n        result = result :+\
    \ max\n        for (i <- 0 to k - 2) {\n            max = 0\n            for (j\
    \ <- 0 to arr.length - 1) {\n                if (arr(j) > max && j != maxIndex)\
    \ {\n                    max = arr(j)\n                    maxIndex = j\n    \
    \            }\n            }\n            result = result :+ max\n        }\n\
    \        return result", "        // Fill this function body\n        // return\
    \ List[Long]()\n        val sorted = arr.sorted\n        sorted.takeRight(k.toInt)",
  "        // We can use a max heap to solve this problem.\n        // The max heap\
    \ will store the k largest elements.\n        // For each element in the array,\
    \ we will add it to the heap.\n        // If the heap size is greater than k,\
    \ we will remove the largest element.\n        val heap = new MaxHeap[Long]()\n\
    \        for (x <- arr) {\n            heap.add(x)\n            if (heap.size\
    \ > k) heap.remove()\n        }\n        heap.toList", "        var max = new\
    \ ListBuffer[Long]()\n        for (i <- 0l.toLong to k - 1l.toLong) {\n      \
    \      var max_index = 0l.toLong\n            for (j <- i.toLong to arr.length\
    \ - 1l.toLong) {\n                if (arr(j.toInt) > arr(max_index.toInt)) {\n\
    \                    max_index = j\n                }\n            }\n       \
    \     max += arr(max_index.toInt)\n            var temp = arr(i.toInt)\n     \
    \       arr(i.toInt) = arr(max_index.toInt)\n            arr(max_index.toInt)\
    \ = temp\n        }\n        return max.toList", "        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        val sorted\
    \ = arr.sorted\n        val result = new ListBuffer[Long]\n        for (i <- 0\
    \ until k.toInt) {\n            result += sorted(sorted.length - 1 - i)\n    \
    \    }\n        result.toList", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        val heap\
    \ = new PriorityQueue[Long]()(Ordering.by((_: Long) * -1))\n        for (i <-\
    \ arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        var result : List[Long] = List[Long]()\n\
    \        var max : Long = 0l\n        var maxIndex : Int = 0\n        var i :\
    \ Int = 0\n        while (i < k) {\n            max = arr(0)\n            maxIndex\
    \ = 0\n            for (j <- 0 until arr.length) {\n                if (arr(j)\
    \ > max) {\n                    max = arr(j)\n                    maxIndex = j\n\
    \                }\n            }\n            result = result :+ max\n      \
    \      arr = arr.patch(maxIndex, Nil, 1)\n            i += 1\n        }\n    \
    \    return result", "        // Fill this in.\n        var result : List[Long]\
    \ = List[Long]()\n        var temp : List[Long] = List[Long]()\n        for (i\
    \ <- 0 until arr.length) {\n            temp = arr(i) :: temp\n            temp\
    \ = temp.sorted\n            if (temp.length > k) {\n                temp = temp.dropRight(1)\n\
    \            }\n        }\n        result = temp.sorted\n        result = result.reverse\n\
    \        return result", "        // We can use a min-heap to solve this problem.\n\
    \        // The heap will contain the k largest elements.\n        // We will\
    \ iterate through the array, and if the element is larger than the \n        //\
    \ smallest element in the heap, we will remove the smallest element and add \n\
    \        // the new element.\n        // The heap will always contain the k largest\
    \ elements.\n        // When we are done iterating, we will return the heap.\n\
    \        // The heap will be in ascending order, so we will reverse it.\n    \
    \    val heap = new mutable.PriorityQueue[Long]()\n        for (i <- arr) {\n\
    \            if (heap.size < k) heap.enqueue(i)\n            else if (i > heap.head)\
    \ {\n                heap.dequeue\n                heap.enqueue(i)\n         \
    \   }\n        }\n        heap.toList.reverse", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        val sorted\
    \ = arr.sorted\n        val result = new ListBuffer[Long]\n        for (i <- 0\
    \ until k.toInt) {\n            result += sorted(sorted.length - 1 - i)\n    \
    \    }\n        result.toList", "        var result : List[Long] = List[Long]()\n\
    \        var max : Long = 0\n        var index : Long = 0\n        var count :\
    \ Long = 0\n        while (count < k) {\n            max = 0\n            index\
    \ = 0\n            for (i <- 0 to arr.length - 1) {\n                if (arr(i)\
    \ > max) {\n                    max = arr(i)\n                    index = i\n\
    \                }\n            }\n            result = result :+ max\n      \
    \      arr(index) = -1001\n            count += 1\n        }\n        return result",
  "        // We can use a heap to solve this problem.\n        // We can use a min-heap\
    \ to store the k largest elements.\n        // The heap will be of size k.\n \
    \       // If the heap is full and the next element is greater than the root,\n\
    \        // then we can remove the root and insert the next element.\n       \
    \ // If the heap is not full, then we can insert the next element.\n        //\
    \ Once we have gone through the entire array, we can return the heap.\n      \
    \  // Since the heap is a min-heap, we can reverse the heap to get the k largest\
    \ elements.\n        // Time Complexity: O(n * log(k))\n        // Space Complexity:\
    \ O(k)\n        val heap = new mutable.PriorityQueue[Long]()\n        for (x <-\
    \ arr) {\n            if (heap.size < k) heap.enqueue(x)\n            else if\
    \ (x > heap.head) {\n                heap.dequeue\n                heap.enqueue(x)\n\
    \            }\n        }\n        heap.toList.reverse", "        // We will use\
    \ a heap to store the k largest elements.\n        // We will use a max heap to\
    \ store the k largest elements.\n        // We will use a min heap to store the\
    \ k smallest elements.\n        // We will use a max heap to store the k largest\
    \ elements.\n        // We will use a min heap to store the k smallest elements.\n\
    \        // We will use a max heap to store the k largest elements.\n        //\
    \ We will use a min heap to store the k smallest elements.\n        // We will\
    \ use a max heap to store the k largest elements.\n        // We will use a min\
    \ heap to store the k smallest elements.\n        // We will use a max heap to\
    \ store the k largest elements.\n        // We will use a min heap to store the\
    \ k smallest elements.\n        // We will use a max heap to store the k largest\
    \ elements.\n        // We will use a min heap to store the k smallest elements.\n\
    \        // We will use a max heap to store the k largest elements.\n        //\
    \ We will use a min heap to store the k smallest elements.\n        // We will\
    \ use a max heap to store the k largest elements.\n        // We will use a min\
    \ heap to store the k smallest elements.\n        // We will use a max heap to\
    \ store the k largest elements.\n        // We will use a min heap to store the\
    \ k smallest elements.\n        // We will use a max heap to store the k largest\
    \ elements.\n        // We will use a min heap to store the k smallest elements.\n\
    \        // We will use a max heap to store the k largest elements.\n        //\
    \ We will use a min heap to store the k smallest elements.\n        // We will\
    \ use a max heap to store the k largest elements.\n        // We will use a min\
    \ heap to store the k smallest elements.\n        // We will use a max heap to\
    \ store the k largest elements.\n        // We will use a min heap to store the\
    \ k smallest elements.\n        // We will use a max heap to store the k largest\
    \ elements.\n        // We will use a min heap to store the k smallest elements.\n\
    \        // We will use a max heap to store the k largest elements.\n        //\
    \ We will use a min heap to store the k smallest elements.\n        // We will\
    \ use a max heap to store the k largest elements.\n", "        // Fill this in.\n\
    \        var result : List[Long] = List[Long]()\n        var arr_sorted : List[Long]\
    \ = arr.sorted\n        for (i <- 0 until k.toInt) {\n            result = result\
    \ :+ arr_sorted(arr_sorted.length - 1 - i)\n        }\n        return result",
  "        // We can use a heap to solve this problem.\n        // A heap is a data\
    \ structure that allows us to efficiently find the minimum or maximum element.\n\
    \        // We can use a min heap to find the maximum k elements.\n        //\
    \ The min heap will contain the k largest elements.\n        // We can iterate\
    \ through the array and add each element to the heap.\n        // If the heap\
    \ contains more than k elements, we remove the minimum element.\n        // This\
    \ will ensure that the heap contains the k largest elements.\n        // After\
    \ iterating through the array, we can return the elements in the heap.\n     \
    \   // Time Complexity: O(n log k)\n        // Space Complexity: O(k)\n      \
    \  val heap = new mutable.PriorityQueue[Long]()\n        for (x <- arr) {\n  \
    \          heap.enqueue(x)\n            if (heap.size > k) heap.dequeue\n    \
    \    }\n        heap.toList.sorted", "        // We can use a max heap to solve\
    \ this problem.\n        // The max heap will have a size of k.\n        // We\
    \ will iterate through the array and add each element to the heap.\n        //\
    \ If the heap size is greater than k, we will remove the max element.\n      \
    \  // After iterating through the array, we will return the heap.\n        val\
    \ heap = new MaxHeap[Long](k.toInt)\n        for (i <- arr) {\n            heap.add(i)\n\
    \        }\n        heap.toList", "        val heap = new Heap[Long]((x : Long,\
    \ y : Long) => x > y)\n        for (i <- arr) {\n            heap.push(i)\n  \
    \          if (heap.size > k) heap.pop\n        }\n        heap.toList", "   \
    \     // Fill this in.\n        var result = List[Long]()\n        var max = arr.max\n\
    \        for (i <- 0 until k.toInt) {\n            result = result :+ max\n  \
    \          arr.remove(arr.indexOf(max))\n            max = arr.max\n        }\n\
    \        result", "        // We can use a priority queue to solve this problem.\n\
    \        // The priority queue will be sorted by the absolute value of the elements\
    \ in the array.\n        // The first k elements in the priority queue will be\
    \ the answer.\n        // Time complexity: O(n * log(k))\n        // Space complexity:\
    \ O(k)\n        val pq = new PriorityQueue[Long]()(Ordering.by(x => abs(x)))\n\
    \        for (x <- arr) {\n            pq.enqueue(x)\n            if (pq.size\
    \ > k) pq.dequeue\n        }\n        pq.toList.sorted", "        // We can use\
    \ a max heap to solve this problem.\n        // The heap will have a maximum size\
    \ of k.\n        // If the heap is full, we will only add an element if it is\
    \ greater than the root of the heap.\n        // If the heap is not full, we will\
    \ add the element.\n        // The heap will be sorted from greatest to least.\n\
    \        // The heap will be sorted from greatest to least.\n        // We will\
    \ return the heap as a list.\n        // Time Complexity: O(nlogk)\n        //\
    \ Space Complexity: O(k)\n        val heap = new MaxHeap[Long](k.toInt)\n    \
    \    for (i <- arr) {\n            if (heap.size < k) heap.add(i)\n          \
    \  else if (i > heap.peek) {\n                heap.poll\n                heap.add(i)\n\
    \            }\n        }\n        heap.toList", "        // Fill this in.\n \
    \       var result = List[Long]()\n        var max = 0l\n        var maxIndex\
    \ = 0\n        for (i <- 0 until k.toInt) {\n            max = arr(0)\n      \
    \      maxIndex = 0\n            for (j <- 0 until arr.length) {\n           \
    \     if (arr(j) > max) {\n                    max = arr(j)\n                \
    \    maxIndex = j\n                }\n            }\n            result = result\
    \ :+ max\n            arr = arr.patch(maxIndex, Nil, 1)\n        }\n        result",
  "        val heap = new PriorityQueue[Long]()(Ordering.by((_: Long) * -1))\n   \
    \     for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ up this function body\n        // `arr` is a list of integers\n        // `k`\
    \ is a positive integer\n        // You have to return a sorted list of length\
    \ `k` with the maximum k numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        val maxHeap = new MaxHeap[Long](k.toInt)\n        for (i <- arr) {\n  \
    \          maxHeap.insert(i)\n        }\n        maxHeap.toList", "        val\
    \ heap = new Heap[Long]((x : Long, y : Long) => x > y)\n        for (i <- arr)\
    \ {\n            heap.insert(i)\n            if (heap.size > k) heap.extract\n\
    \        }\n        heap.toList", "        // Fill this\n        arr.sortWith(_\
    \ > _).take(k.toInt)", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // We can\
    \ use a max heap to solve this problem.\n        // The max heap will have size\
    \ k.\n        // We will iterate through the array and add each element to the\
    \ heap.\n        // If the heap is full, we will remove the maximum element from\
    \ the heap.\n        // After we iterate through the array, we will return the\
    \ heap.\n        val heap = new MaxHeap[Long](k.toInt)\n        for (i <- arr)\
    \ {\n            if (heap.size < k) {\n                heap.add(i)\n         \
    \   } else {\n                if (i > heap.peek) {\n                    heap.poll\n\
    \                    heap.add(i)\n                }\n            }\n        }\n\
    \        heap.toList", "        // Fill up this function body\n        // `arr`\
    \ is a list of integers\n        // `k` is a positive integer\n        // return\
    \ a sorted list of length `k` with the maximum `k` numbers in `arr`\n        var\
    \ result = new ListBuffer[Long]()\n        for (i <- 0 until k.toInt) {\n    \
    \        var max = arr.max\n            result += max\n            arr = arr.filter(_\
    \ != max)\n        }\n        result.toList", "        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ arr.sorted.takeRight(k.toInt)", "        // We can use a max heap to solve this\
    \ problem.\n        // The max heap will be of size k.\n        // We will iterate\
    \ through the array and add each element to the heap.\n        // If the heap\
    \ is full, we will remove the maximum element from the heap and add the current\
    \ element.\n        // We will then return the heap as a sorted list.\n      \
    \  // This algorithm will run in O(n log k) time and O(k) space.\n        val\
    \ heap = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <-\
    \ arr) {\n            if (heap.size < k) heap.enqueue(i)\n            else {\n\
    \                if (i > heap.head) {\n                    heap.dequeue\n    \
    \                heap.enqueue(i)\n                }\n            }\n        }\n\
    \        heap.toList.sorted", "        var result : List[Long] = List[Long]()\n\
    \        var max : Long = 0\n        var maxIndex : Int = 0\n        var i : Int\
    \ = 0\n        while (i < k) {\n            max = arr(0)\n            maxIndex\
    \ = 0\n            for (j <- 0 until arr.length) {\n                if (arr(j)\
    \ > max) {\n                    max = arr(j)\n                    maxIndex = j\n\
    \                }\n            }\n            result = result :+ max\n      \
    \      arr = arr.take(maxIndex) ++ arr.drop(maxIndex + 1)\n            i += 1\n\
    \        }\n        return result", "        // Given an array arr of integers\
    \ and a positive integer k, return a sorted list \n        // of length k with\
    \ the maximum k numbers in arr.\n        // >>> maximum((List[Long](-3l.toLong,\
    \ -4l.toLong, 5l.toLong)), (3l))\n        // (List[Long](-4l.toLong, -3l.toLong,\
    \ 5l.toLong))\n        // >>> maximum((List[Long](4l.toLong, -4l.toLong, 4l.toLong)),\
    \ (2l))\n        // (List[Long](4l.toLong, 4l.toLong))\n        // >>> maximum((List[Long](-3l.toLong,\
    \ 2l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -2l.toLong, 1l.toLong)), (1l))\n\
    \        // (List[Long](2l.toLong))\n        // Note:\n        // 1. The length\
    \ of the array will be in the range of [1, 1000].\n        // 2. The elements\
    \ in the array will be in the range of [-1000, 1000].\n        // 3. 0 <= k <=\
    \ len(arr)\n        def loop(arr : List[Long], k : Long, acc : List[Long]) : List[Long]\
    \ = {\n            if (k == 0l) acc\n            else {\n                val max\
    \ = arr.max\n                loop(arr.filterNot(_ == max), k - 1l, acc :+ max)\n\
    \            }\n        }\n        loop(arr, k, List[Long]())", "        // Define\
    \ the maximum function as a recursive function\n        def maximum(arr : List[Long],\
    \ k : Long, acc : List[Long]) : List[Long] = {\n            // If the size of\
    \ the accumulator is equal to k, return the accumulator\n            if (acc.size\
    \ == k) acc\n            // Otherwise, if the size of the accumulator is less\
    \ than k,\n            // find the maximum element in the list and add it to the\
    \ accumulator\n            else {\n                // Find the maximum element\
    \ in the list\n                val max = arr.max\n                // Add the maximum\
    \ element to the accumulator\n                val newAcc = acc :+ max\n      \
    \          // Remove the maximum element from the list\n                val newArr\
    \ = arr.filter(x => x != max)\n                // Recursively call the maximum\
    \ function\n                maximum(newArr, k, newAcc)\n            }\n      \
    \  }\n        // Call the maximum function\n        maximum(arr, k, List[Long]())",
  "        val heap = new Heap(arr)\n        val result = new ListBuffer[Long]\n \
    \       for (i <- 0 until k.toInt) {\n            result += heap.pop\n       \
    \ }\n        result.toList", "        // Fill this\n        return List[Long]()",
  "        val heap = new PriorityQueue[Long]()(Ordering.by((_: Long) * -1))\n   \
    \     for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        val heap\
    \ = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- arr) {\n   \
    \         heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n     \
    \   }\n        heap.toList.sorted", "        // We can use a heap to solve this\
    \ problem.\n        // The heap will be a min-heap.\n        // We will add the\
    \ first k elements to the heap.\n        // Then we will iterate through the rest\
    \ of the elements.\n        // If the current element is greater than the minimum\
    \ element in the heap,\n        // we will remove the minimum element and add\
    \ the current element.\n        // Finally, we will return the heap as a sorted\
    \ list.\n        val heap = new Heap[Long]((x : Long, y : Long) => x < y)\n  \
    \      for (i <- 0l until k) {\n            heap.add(arr(i.toInt))\n        }\n\
    \        for (i <- k until arr.length) {\n            if (arr(i.toInt) > heap.peek)\
    \ {\n                heap.remove()\n                heap.add(arr(i.toInt))\n \
    \           }\n        }\n        heap.toList", "        // Fill up this function\
    \ body\n        // You can add another function as well, if required\n       \
    \ val n = arr.length\n        val result = new ListBuffer[Long]\n        for (i\
    \ <- 0 until n) {\n            if (result.length < k) {\n                result\
    \ += arr(i)\n            } else {\n                val min = result.min\n    \
    \            if (arr(i) > min) {\n                    result -= min\n        \
    \            result += arr(i)\n                }\n            }\n        }\n \
    \       result.toList", "        // Fill up this function body\n        // `arr`\
    \ is a list of integers\n        // `k` is a positive integer\n        // return\
    \ a sorted list of length `k` with the maximum `k` numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  "        val heap = new Heap[Long]((a : Long, b : Long) => a > b)\n        for (i\
    \ <- arr) {\n            heap.add(i)\n            if (heap.size > k) heap.remove\n\
    \        }\n        heap.toList", "        val sorted = arr.sorted\n        val\
    \ result = new ListBuffer[Long]\n        for (i <- 0 to k.toInt - 1) {\n     \
    \       result += sorted(sorted.length - 1 - i)\n        }\n        result.toList",
  "        // Fill this function body\n        // You can add another function as\
    \ well, if required\n        val arr2 = arr.sorted\n        val arr3 = arr2.reverse\n\
    \        val arr4 = arr3.take(k.toInt)\n        arr4", "        val sorted = arr.sorted\n\
    \        sorted.takeRight(k.toInt)", "        val sorted = arr.sorted\n      \
    \  sorted.takeRight(k.toInt)", "        // We can use a heap to solve this problem.\n\
    \        // The heap will store the k largest elements in the array.\n       \
    \ // We will iterate through the array and add elements to the heap.\n       \
    \ // If the heap is full, we will remove the smallest element from the heap.\n\
    \        // If the heap is not full, we will add the element to the heap.\n  \
    \      // After iterating through the array, we will return the heap.\n      \
    \  // The heap will be sorted in ascending order.\n        // We will reverse\
    \ the heap to get the result.\n        // Time Complexity: O(n log k)\n      \
    \  // Space Complexity: O(k)\n        val heap = new PriorityQueue[Long]()\n \
    \       for (element <- arr) {\n            if (heap.size < k) {\n           \
    \     heap.enqueue(element)\n            } else {\n                if (element\
    \ > heap.head) {\n                    heap.dequeue\n                    heap.enqueue(element)\n\
    \                }\n            }\n        }\n        heap.toList.reverse", " \
    \       // Define a recursive function to solve this problem\n        def maximumHelper(arr\
    \ : List[Long], k : Long, acc : List[Long]) : List[Long] = {\n            if (k\
    \ == 0) acc\n            else {\n                val max = arr.max\n         \
    \       val newArr = arr.filter(x => x != max)\n                maximumHelper(newArr,\
    \ k - 1, acc :+ max)\n            }\n        }\n        maximumHelper(arr, k,\
    \ List[Long]())", "        // Fill up this function body\n        // 'arr' is\
    \ a list of integers\n        // 'k' is the number of maximum numbers to be returned\n\
    \        // Return a list of maximum numbers of length 'k'\n        arr.sorted.takeRight(k.toInt)",
  "        // We can use a max heap to solve this problem.\n        // The max heap\
    \ will have a size of k.\n        // We will iterate through the array and add\
    \ the elements to the heap.\n        // If the heap is full, we will remove the\
    \ largest element from the heap and add the new element.\n        // If the heap\
    \ is not full, we will just add the new element.\n        // After we iterate\
    \ through the array, we will return the heap.\n        val heap = new MaxHeap[Long](k.toInt)\n\
    \        for (i <- arr) {\n            if (heap.size == k) {\n               \
    \ heap.remove()\n            }\n            heap.add(i)\n        }\n        heap.toList",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is a positive integer\n        // Return a sorted list of length\
    \ `k` with the maximum `k` numbers in `arr`\n        arr.sorted.takeRight(k.toInt)",
  '        arr.sorted.takeRight(k.toInt)', "        // We can use a heap to solve\
    \ this problem.\n        // We can use a min heap to store the k largest elements.\n\
    \        // We can use a max heap to store the k smallest elements.\n        //\
    \ We can use a min heap to store the k largest elements.\n        // We can use\
    \ a max heap to store the k smallest elements.\n        // We can use a min heap\
    \ to store the k largest elements.\n        // We can use a max heap to store\
    \ the k smallest elements.\n        // We can use a min heap to store the k largest\
    \ elements.\n        // We can use a max heap to store the k smallest elements.\n\
    \        // We can use a min heap to store the k largest elements.\n        //\
    \ We can use a max heap to store the k smallest elements.\n        // We can use\
    \ a min heap to store the k largest elements.\n        // We can use a max heap\
    \ to store the k smallest elements.\n        // We can use a min heap to store\
    \ the k largest elements.\n        // We can use a max heap to store the k smallest\
    \ elements.\n        // We can use a min heap to store the k largest elements.\n\
    \        // We can use a max heap to store the k smallest elements.\n        //\
    \ We can use a min heap to store the k largest elements.\n        // We can use\
    \ a max heap to store the k smallest elements.\n        // We can use a min heap\
    \ to store the k largest elements.\n        // We can use a max heap to store\
    \ the k smallest elements.\n        // We can use a min heap to store the k largest\
    \ elements.\n        // We can use a max heap to store the k smallest elements.\n\
    \        // We can use a min heap to store the k largest elements.\n        //\
    \ We can use a max heap to store the k smallest elements.\n        // We can use\
    \ a min heap to store the k largest elements.\n        // We can use a max heap\
    \ to store the k smallest elements.\n        // We can use a min heap to store\
    \ the k largest elements.\n        // We can use a max heap to store the k smallest\
    \ elements.\n        // We can use a min heap to store the k largest elements.\n\
    \        // We can use a max heap to store the k smallest elements.\n        //\
    \ We can use a min heap to store the k largest elements.\n        //", "     \
    \   val heap = new Heap[Long]((x : Long, y : Long) => x > y)\n        for (i <-\
    \ arr) {\n            heap.add(i)\n            if (heap.size > k) heap.remove\n\
    \        }\n        heap.toList", "        // We can use a max heap to solve this\
    \ problem.\n        // We can also use a min heap to solve this problem.\n   \
    \     // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        //", "        // We will\
    \ use a heap to store the maximum k numbers.\n        // The heap will be a min-heap,\
    \ so that the minimum number is always at the top.\n        // We will use a heap\
    \ of size k, and we will insert the first k numbers into the heap.\n        //\
    \ For each subsequent number, we will compare it to the minimum number in the\
    \ heap.\n        // If the number is greater than the minimum number, we will\
    \ remove the minimum number from the heap and insert the new number.\n       \
    \ // After we have processed all numbers, we will return the heap.\n        //\
    \ The heap is a min-heap, so we will reverse the heap to get the maximum k numbers.\n\
    \        // Time Complexity: O(n log k)\n        // Space Complexity: O(k)\n \
    \       val heap = new Heap(k)\n        for (i <- 0 until arr.length) {\n    \
    \        if (i < k) heap.insert(arr(i))\n            else {\n                if\
    \ (arr(i) > heap.minimum()) {\n                    heap.removeMinimum()\n    \
    \                heap.insert(arr(i))\n                }\n            }\n     \
    \   }\n        heap.heap.reverse", "        // Fill this in.\n        var result\
    \ : List[Long] = List[Long]()\n        var temp : List[Long] = List[Long]()\n\
    \        var i : Long = 0l\n        while (i < k) {\n            var max : Long\
    \ = -1001l\n            var index : Long = 0l\n            var j : Long = 0l\n\
    \            while (j < arr.length) {\n                if (!temp.contains(j) &&\
    \ arr(j.toInt) > max) {\n                    max = arr(j.toInt)\n            \
    \        index = j\n                }\n                j += 1\n            }\n\
    \            result = result :+ max\n            temp = temp :+ index\n      \
    \      i += 1\n        }\n        return result", "        // Fill this in.\n\
    \        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i\
    \ <- arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        val sorted = arr.sorted\n  \
    \      sorted.takeRight(k.toInt)", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        val pq =\
    \ new PriorityQueue[Long]()(Ordering.Long.reverse)\n        for (i <- arr) {\n\
    \            pq.enqueue(i)\n            if (pq.size > k) pq.dequeue\n        }\n\
    \        pq.toList", "        val maxHeap = new MaxHeap[Long](k.toInt)\n     \
    \   for (x <- arr) {\n            maxHeap.insert(x)\n        }\n        maxHeap.getSortedList()",
  "        // We can use a heap to solve this problem.\n        // We can use a min-heap\
    \ to store the k largest elements.\n        // We can use a max-heap to store\
    \ the k smallest elements.\n        // We can use a min-heap to store the k largest\
    \ elements.\n        // We can use a max-heap to store the k smallest elements.\n\
    \        // We can use a min-heap to store the k largest elements.\n        //\
    \ We can use a max-heap to store the k smallest elements.\n        // We can use\
    \ a min-heap to store the k largest elements.\n        // We can use a max-heap\
    \ to store the k smallest elements.\n        // We can use a min-heap to store\
    \ the k largest elements.\n        // We can use a max-heap to store the k smallest\
    \ elements.\n        // We can use a min-heap to store the k largest elements.\n\
    \        // We can use a max-heap to store the k smallest elements.\n        //\
    \ We can use a min-heap to store the k largest elements.\n        // We can use\
    \ a max-heap to store the k smallest elements.\n        // We can use a min-heap\
    \ to store the k largest elements.\n        // We can use a max-heap to store\
    \ the k smallest elements.\n        // We can use a min-heap to store the k largest\
    \ elements.\n        // We can use a max-heap to store the k smallest elements.\n\
    \        // We can use a min-heap to store the k largest elements.\n        //\
    \ We can use a max-heap to store the k smallest elements.\n        // We can use\
    \ a min-heap to store the k largest elements.\n        // We can use a max-heap\
    \ to store the k smallest elements.\n        // We can use a min-heap to store\
    \ the k largest elements.\n        // We can use a max-heap to store the k smallest\
    \ elements.\n        // We can use a min-heap to store the k largest elements.\n\
    \        // We can use a max-heap to store the k smallest elements.\n        //\
    \ We can use a min-heap to store the k largest elements.\n        // We can use\
    \ a max-heap to store", "        val heap = new PriorityQueue[Long]()(Ordering.by((x\
    \ : Long) => -x))\n        for (x <- arr) {\n            heap.enqueue(x)\n   \
    \         if (heap.size > k) heap.dequeue\n        }\n        heap.toList", " \
    \       val arr2 = arr.sortWith(_ > _)\n        arr2.take(k.toInt)", "       \
    \ // Fill this in.\n        val sorted = arr.sorted\n        val result = sorted.takeRight(k.toInt)\n\
    \        result", "        val heap = new Heap(arr)\n        var result = List[Long]()\n\
    \        for (i <- 0l until k) {\n            result = heap.pop() :: result\n\
    \        }\n        result.reverse", "        // Fill this in.\n        var result\
    \ : List[Long] = List[Long]()\n        var max : Long = 0\n        var maxIndex\
    \ : Int = 0\n        var count : Long = 0\n        while (count < k) {\n     \
    \       max = arr(0)\n            maxIndex = 0\n            for (i <- 0 until\
    \ arr.length) {\n                if (arr(i) > max) {\n                    max\
    \ = arr(i)\n                    maxIndex = i\n                }\n            }\n\
    \            result = result :+ max\n            arr = arr.patch(maxIndex, Nil,\
    \ 1)\n            count += 1\n        }\n        result", "        val sorted\
    \ = arr.sorted\n        val result = new ListBuffer[Long]\n        for (i <- 0\
    \ until k.toInt) {\n            result += sorted(sorted.length - i - 1)\n    \
    \    }\n        result.toList", "        // Fill this function body\n        //\
    \ You can add another function as well, if required\n        var result = List[Long]()\n\
    \        var temp = List[Long]()\n        for (i <- 0 until arr.length) {\n  \
    \          if (temp.length < k) {\n                temp = temp :+ arr(i)\n   \
    \         } else {\n                var min = temp(0)\n                var index\
    \ = 0\n                for (j <- 0 until temp.length) {\n                    if\
    \ (temp(j) < min) {\n                        min = temp(j)\n                 \
    \       index = j\n                    }\n                }\n                if\
    \ (arr(i) > min) {\n                    temp = temp.updated(index, arr(i))\n \
    \               }\n            }\n        }\n        temp = temp.sorted\n    \
    \    for (i <- 0 until temp.length) {\n            result = result :+ temp(temp.length\
    \ - 1 - i)\n        }\n        result", "        val heap = new PriorityQueue[Long]()(Ordering.by(x\
    \ => -x))\n        for (i <- arr) {\n            heap.enqueue(i)\n           \
    \ if (heap.size > k) heap.dequeue\n        }\n        heap.toList", "        val\
    \ sorted = arr.sorted\n        sorted.takeRight(k.toInt)", "        val heap =\
    \ new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- arr) {\n     \
    \       heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n       \
    \ }\n        heap.toList.sorted", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        val sorted\
    \ = arr.sorted\n        sorted.takeRight(k.toInt)", "        val sorted = arr.sorted\n\
    \        val result = new ListBuffer[Long]\n        for (i <- 0 until k.toInt)\
    \ {\n            result += sorted(sorted.length - 1 - i)\n        }\n        result.toList",
  "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <-\
    \ arr) {\n            heap.enqueue(i)\n            if (heap.size > k) heap.dequeue\n\
    \        }\n        heap.toList.sorted", "        val n = arr.length\n       \
    \ val pq = new PriorityQueue[Long]()(Ordering.by(-_))\n        for (i <- 0 until\
    \ n) {\n            pq.enqueue(arr(i))\n            if (pq.length > k) pq.dequeue\n\
    \        }\n        pq.toList", "        val heap = new Heap[Long]((x : Long,\
    \ y : Long) => x > y)\n        for (i <- arr) {\n            heap.add(i)\n   \
    \         if (heap.size > k) heap.poll\n        }\n        heap.toList", "   \
    \     val sorted = arr.sorted\n        sorted.takeRight(k.toInt)", "        //\
    \ We can use a priority queue to solve this problem.\n        // We can also use\
    \ a heap to solve this problem.\n        // We can also use a binary search tree\
    \ to solve this problem.\n        // We can also use a hash table to solve this\
    \ problem.\n        // We can also use a binary search to solve this problem.\n\
    \        // We can also use a merge sort to solve this problem.\n        // We\
    \ can also use a quick sort to solve this problem.\n        // We can also use\
    \ a selection sort to solve this problem.\n        // We can also use a bubble\
    \ sort to solve this problem.\n        // We can also use a insertion sort to\
    \ solve this problem.\n        // We can also use a shell sort to solve this problem.\n\
    \        // We can also use a counting sort to solve this problem.\n        //\
    \ We can also use a radix sort to solve this problem.\n        // We can also\
    \ use a bucket sort to solve this problem.\n        // We can also use a heap\
    \ sort to solve this problem.\n        // We can also use a tree sort to solve\
    \ this problem.\n        // We can also use a merge sort to solve this problem.\n\
    \        // We can also use a quick sort to solve this problem.\n        // We\
    \ can also use a selection sort to solve this problem.\n        // We can also\
    \ use a bubble sort to solve this problem.\n        // We can also use a insertion\
    \ sort to solve this problem.\n        // We can also use a shell sort to solve\
    \ this problem.\n        // We can also use a counting sort to solve this problem.\n\
    \        // We can also use a radix sort to solve this problem.\n        // We\
    \ can also use a bucket sort to solve this problem.\n        // We can also use\
    \ a heap sort to solve this problem.\n        // We can also use a tree sort to\
    \ solve this problem.\n        // We can also use a merge sort to solve this problem.\n\
    \        // We can also use a quick sort to solve this problem.\n        // We\
    \ can also use a selection sort to solve this problem.\n        // We can also\
    \ use a bubble sort to solve this problem.\n        // We can also use a insertion\
    \ sort to solve this problem.\n        // We can also use a shell sort to solve\
    \ this problem.\n        // We can also use a counting sort to solve this problem.\n",
  "        // Fill this\n        arr.sorted.takeRight(k.toInt)", "        // We can\
    \ do this in O(n) time and O(k) space.\n        // First, we create a list of\
    \ the first k elements.\n        // Then, we iterate through the rest of the elements.\n\
    \        // If the element is greater than the minimum element in the list,\n\
    \        // we remove the minimum element and add the new element.\n        //\
    \ Finally, we return the list.\n        val list = new ListBuffer[Long]()\n  \
    \      for (i <- 0 until k.toInt) {\n            list += arr(i)\n        }\n \
    \       for (i <- k.toInt until arr.length) {\n            if (arr(i) > list.min)\
    \ {\n                list -= list.min\n                list += arr(i)\n      \
    \      }\n        }\n        list.toList", "        // We can use a heap to solve\
    \ this problem.\n        // The heap will be a min heap.\n        // The heap\
    \ will contain the k largest elements.\n        // We will iterate through the\
    \ array.\n        // If the heap is not full, add the element to the heap.\n \
    \       // If the heap is full, check if the element is larger than the minimum\
    \ element in the heap.\n        // If it is, remove the minimum element and add\
    \ the new element.\n        // If it is not, do nothing.\n        // Once we have\
    \ iterated through the array, we will have the k largest elements in the heap.\n\
    \        // We will then sort the heap and return it.\n        // Time Complexity:\
    \ O(n log k)\n        // Space Complexity: O(k)\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n  \
    \          else if (i > heap.head) {\n                heap.dequeue\n         \
    \       heap.enqueue(i)\n            }\n        }\n        heap.toList.sorted",
  "        // Fill up this function body\n        // `arr` is a list of integers\n\
    \        // `k` is the number of elements to return\n        // return a list\
    \ of integers\n        arr.sorted.takeRight(k.toInt)", "        // We can use\
    \ a max heap to solve this problem.\n        // We can also use a min heap to\
    \ solve this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        // We can\
    \ also use a max heap to solve this problem.\n        // We can also use a min\
    \ heap to solve this problem.\n        // We can also use a max heap to solve\
    \ this problem.\n        // We can also use a min heap to solve this problem.\n\
    \        // We can also use a max heap to solve this problem.\n        // We can\
    \ also use a min heap to solve this problem.\n        // We can also use a max\
    \ heap to solve this problem.\n        // We can also use a min heap to solve\
    \ this problem.\n        // We can also use a max heap to solve this problem.\n\
    \        // We can also use a min heap to solve this problem.\n        //", " \
    \       // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max heap to solve this problem.\n   \
    \     // We can use a max heap to solve this problem.\n        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max heap to solve this problem.\n        // We can use a max heap\
    \ to solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max heap to solve this problem.\n   \
    \     // We can use a max heap to solve this problem.\n        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max heap to solve this problem.\n        // We can use a max heap\
    \ to solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max heap to solve this problem.\n   \
    \     // We can use a max heap to solve this problem.\n        // We can use a\
    \ max heap to solve this problem.\n        // We can use a max heap to solve this\
    \ problem.\n        // We can use a max heap to solve this problem.\n        //\
    \ We can use a max heap to solve this problem.\n        // We can use a max heap\
    \ to solve this problem.\n        // We can use a max heap to solve this problem.\n\
    \        // We can use a max heap to solve this problem.\n        // We can use\
    \ a max heap to solve this problem.\n        // We can use a max heap to solve\
    \ this problem.\n        // We can use a max", "        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted", "        // Fill\
    \ this in.\n        var result = List[Long]()\n        var max = -1001l\n    \
    \    var maxIndex = -1\n        for (i <- 0 until k.toInt) {\n            max\
    \ = -1001l\n            maxIndex = -1\n            for (j <- i until arr.length)\
    \ {\n                if (arr(j) > max) {\n                    max = arr(j)\n \
    \                   maxIndex = j\n                }\n            }\n         \
    \   result = result :+ max\n            arr(maxIndex) = -1001l\n        }\n  \
    \      result", "        // We can use a min-heap to solve this problem.\n   \
    \     // The heap will contain the k largest elements.\n        // We will iterate\
    \ through the array, and if the current element is larger than the\n        //\
    \ smallest element in the heap, we will remove the smallest element and add the\
    \ current\n        // element.\n        // After iterating through the array,\
    \ we will return the heap.\n        val heap = new mutable.PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- arr) {\n            if (heap.size < k) heap.enqueue(i)\n  \
    \          else if (i > heap.head) {\n                heap.dequeue\n         \
    \       heap.enqueue(i)\n            }\n        }\n        heap.toList", "   \
    \     // Fill up this function body\n        // 'arr' is a list of integers\n\
    \        // 'k' is a positive integer\n        // Return a sorted list of length\
    \ 'k' with the maximum k numbers in 'arr'\n        arr.sorted.takeRight(k.toInt)",
  "        // Fill this in.\n        var result = List[Long]()\n        var arr2 =\
    \ arr.sorted\n        for (i <- 0 until k.toInt) {\n            result = result\
    \ :+ arr2(arr2.length - 1 - i)\n        }\n        result", "        // Fill up\
    \ this function body\n        // 'arr' is a list of integers\n        // 'k' is\
    \ the number of maximum elements to return\n        // You can use the 'scala.math.Ordering'\
    \ object\n        // For example, 'Ordering.Long' compares two Longs\n       \
    \ // You can use the 'sorted' method of a list\n        // For example, 'List(1,\
    \ 2, 3).sorted' returns a sorted list\n        // You can use the 'take' method\
    \ of a list\n        // For example, 'List(1, 2, 3).take(2)' returns a list with\
    \ the first two elements\n        arr.sorted.take(k.toInt).reverse", "       \
    \ // We can use a min heap to keep track of the k largest elements.\n        //\
    \ The heap will be initialized with the first k elements of the array.\n     \
    \   // Then, we iterate through the array, and if the current element is larger\n\
    \        // than the minimum element in the heap, we remove the minimum element\
    \ and\n        // insert the current element.\n        // The heap will always\
    \ contain the k largest elements.\n        // The time complexity is O(n log k)\
    \ and the space complexity is O(k).\n        val heap = new PriorityQueue[Long]()(Ordering.by(-_))\n\
    \        for (i <- 0 until k.toInt) heap.enqueue(arr(i))\n        for (i <- k.toInt\
    \ until arr.length) {\n            if (arr(i) > heap.head) {\n               \
    \ heap.dequeue\n                heap.enqueue(arr(i))\n            }\n        }\n\
    \        heap.toList.sorted", "        val sorted = arr.sorted\n        sorted.takeRight(k.toInt)",
  "        val heap = new PriorityQueue[Long]()(Ordering.by((_: Long) * -1))\n   \
    \     for (i <- arr) {\n            heap.enqueue(i)\n            if (heap.size\
    \ > k) heap.dequeue\n        }\n        heap.toList.sorted"]
stop_tokens:
- "\n    }\n"
