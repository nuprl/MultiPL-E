name: HumanEval_69_search
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given a non-empty list of positive integers. Return the greatest\
  \ integer that is greater than \n    // zero, and has a frequency greater than or\
  \ equal to the value of the integer itself. \n    // The frequency of an integer\
  \ is the number of times it appears in the list.\n    // If no such a value exist,\
  \ return -1.\n    // Examples:\n    // >>> search((List[Long](4l.toLong, 1l.toLong,\
  \ 2l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\n    // (2l)\n    // >>> search((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong, 4l.toLong)))\n\
  \    // (3l)\n    // >>> search((List[Long](5l.toLong, 5l.toLong, 4l.toLong, 4l.toLong,\
  \ 4l.toLong)))\n    // (-1l)\n    def search(lst : List[Long]) : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(search((List[Long](5l.toLong,\
  \ 5l.toLong, 5l.toLong, 5l.toLong, 1l.toLong))) == (1l));\n    assert(search((List[Long](4l.toLong,\
  \ 1l.toLong, 4l.toLong, 1l.toLong, 4l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](3l.toLong,\
  \ 3l.toLong))) == (-1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 8l.toLong,\
  \ 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong, 8l.toLong))) == (8l));\n    assert(search((List[Long](2l.toLong,\
  \ 3l.toLong, 3l.toLong, 2l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](2l.toLong,\
  \ 7l.toLong, 8l.toLong, 8l.toLong, 4l.toLong, 8l.toLong, 7l.toLong, 3l.toLong, 9l.toLong,\
  \ 6l.toLong, 5l.toLong, 10l.toLong, 4l.toLong, 3l.toLong, 6l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 4l.toLong, 10l.toLong, 8l.toLong, 1l.toLong))) == (1l));\n\
  \    assert(search((List[Long](3l.toLong, 2l.toLong, 8l.toLong, 2l.toLong))) ==\
  \ (2l));\n    assert(search((List[Long](6l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 10l.toLong, 5l.toLong, 8l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (1l));\n    assert(search((List[Long](8l.toLong, 8l.toLong, 3l.toLong, 6l.toLong,\
  \ 5l.toLong, 6l.toLong, 4l.toLong))) == (-1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 6l.toLong, 7l.toLong, 1l.toLong, 4l.toLong, 7l.toLong, 1l.toLong, 8l.toLong,\
  \ 8l.toLong, 9l.toLong, 8l.toLong, 10l.toLong, 10l.toLong, 8l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 10l.toLong, 1l.toLong, 2l.toLong, 9l.toLong, 5l.toLong,\
  \ 7l.toLong, 9l.toLong))) == (1l));\n    assert(search((List[Long](1l.toLong, 9l.toLong,\
  \ 10l.toLong, 1l.toLong, 3l.toLong))) == (1l));\n    assert(search((List[Long](6l.toLong,\
  \ 9l.toLong, 7l.toLong, 5l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 3l.toLong, 7l.toLong,\
  \ 5l.toLong, 10l.toLong, 10l.toLong, 3l.toLong, 6l.toLong, 10l.toLong, 2l.toLong,\
  \ 8l.toLong, 6l.toLong, 5l.toLong, 4l.toLong, 9l.toLong, 5l.toLong, 3l.toLong, 10l.toLong)))\
  \ == (5l));\n    assert(search((List[Long](1l.toLong))) == (1l));\n    assert(search((List[Long](8l.toLong,\
  \ 8l.toLong, 10l.toLong, 6l.toLong, 4l.toLong, 3l.toLong, 5l.toLong, 8l.toLong,\
  \ 2l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 4l.toLong, 6l.toLong, 10l.toLong,\
  \ 4l.toLong, 2l.toLong, 1l.toLong, 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong,\
  \ 5l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong, 10l.toLong, 4l.toLong,\
  \ 8l.toLong, 2l.toLong, 10l.toLong, 5l.toLong, 1l.toLong, 2l.toLong, 9l.toLong,\
  \ 5l.toLong, 5l.toLong, 6l.toLong, 3l.toLong, 8l.toLong, 6l.toLong, 4l.toLong, 10l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](1l.toLong, 6l.toLong, 10l.toLong, 1l.toLong,\
  \ 6l.toLong, 9l.toLong, 10l.toLong, 8l.toLong, 6l.toLong, 8l.toLong, 7l.toLong,\
  \ 3l.toLong))) == (1l));\n    assert(search((List[Long](9l.toLong, 2l.toLong, 4l.toLong,\
  \ 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong, 2l.toLong, 5l.toLong, 7l.toLong, 7l.toLong,\
  \ 7l.toLong, 3l.toLong, 10l.toLong, 1l.toLong, 5l.toLong, 4l.toLong, 2l.toLong,\
  \ 8l.toLong, 4l.toLong, 1l.toLong, 9l.toLong, 10l.toLong, 7l.toLong, 10l.toLong,\
  \ 2l.toLong, 8l.toLong, 10l.toLong, 9l.toLong, 4l.toLong))) == (4l));\n    assert(search((List[Long](2l.toLong,\
  \ 6l.toLong, 4l.toLong, 2l.toLong, 8l.toLong, 7l.toLong, 5l.toLong, 6l.toLong, 4l.toLong,\
  \ 10l.toLong, 4l.toLong, 6l.toLong, 3l.toLong, 7l.toLong, 8l.toLong, 8l.toLong,\
  \ 3l.toLong, 1l.toLong, 4l.toLong, 2l.toLong, 2l.toLong, 10l.toLong, 7l.toLong)))\
  \ == (4l));\n    assert(search((List[Long](9l.toLong, 8l.toLong, 6l.toLong, 10l.toLong,\
  \ 2l.toLong, 6l.toLong, 10l.toLong, 2l.toLong, 7l.toLong, 8l.toLong, 10l.toLong,\
  \ 3l.toLong, 8l.toLong, 2l.toLong, 6l.toLong, 2l.toLong, 3l.toLong, 1l.toLong)))\
  \ == (2l));\n    assert(search((List[Long](5l.toLong, 5l.toLong, 3l.toLong, 9l.toLong,\
  \ 5l.toLong, 6l.toLong, 3l.toLong, 2l.toLong, 8l.toLong, 5l.toLong, 6l.toLong, 10l.toLong,\
  \ 10l.toLong, 6l.toLong, 8l.toLong, 4l.toLong, 10l.toLong, 7l.toLong, 7l.toLong,\
  \ 10l.toLong, 8l.toLong))) == (-1l));\n    assert(search((List[Long](10l.toLong)))\
  \ == (-1l));\n    assert(search((List[Long](9l.toLong, 7l.toLong, 7l.toLong, 2l.toLong,\
  \ 4l.toLong, 7l.toLong, 2l.toLong, 10l.toLong, 9l.toLong, 7l.toLong, 5l.toLong,\
  \ 7l.toLong, 2l.toLong))) == (2l));\n    assert(search((List[Long](5l.toLong, 4l.toLong,\
  \ 10l.toLong, 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 3l.toLong, 6l.toLong,\
  \ 1l.toLong, 8l.toLong))) == (1l));\n    assert(search((List[Long](7l.toLong, 9l.toLong,\
  \ 9l.toLong, 9l.toLong, 3l.toLong, 4l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 1l.toLong,\
  \ 2l.toLong, 1l.toLong, 1l.toLong, 10l.toLong, 7l.toLong, 5l.toLong, 6l.toLong,\
  \ 7l.toLong, 6l.toLong, 7l.toLong, 7l.toLong, 6l.toLong))) == (1l));\n    assert(search((List[Long](3l.toLong,\
  \ 10l.toLong, 10l.toLong, 9l.toLong, 2l.toLong))) == (-1l));\n    }\n\n}\n"
completions: ["        val map = new HashMap[Long, Long]\n        for (i <- lst) {\n\
    \            if (map.contains(i)) map(i) += 1 else map(i) = 1\n        }\n   \
    \     var max = -1l\n        for (i <- map.keys) {\n            if (i <= map(i)\
    \ && i > max) max = i\n        }\n        max", "        val map = new HashMap[Long,\
    \ Long]()\n        for (i <- lst) {\n            if (map.contains(i)) {\n    \
    \            map(i) += 1\n            } else {\n                map(i) = 1\n \
    \           }\n        }\n        var max = -1l\n        for (i <- map.keys) {\n\
    \            if (i <= map(i) && i > max) {\n                max = i\n        \
    \    }\n        }\n        return max", "        val m = lst.groupBy(x => x).mapValues(_.size)\n\
    \        val max = m.keys.max\n        val maxFreq = m(max)\n        if (maxFreq\
    \ >= max) max else -1", "        val m = new HashMap[Long, Long]\n        for\
    \ (i <- lst) {\n            if (m.contains(i)) m(i) += 1\n            else m(i)\
    \ = 1\n        }\n        var max = -1l\n        for (i <- m.keys) {\n       \
    \     if (i <= m(i) && i > max) max = i\n        }\n        max", "        val\
    \ m = lst.groupBy(identity).mapValues(_.size)\n        val r = m.filter(x => x._1\
    \ <= x._2).toList.sortBy(_._1).reverse\n        if (r.isEmpty) -1 else r.head._1",
  "        val freq = new HashMap[Long, Long]\n        for (i <- lst) {\n        \
    \    if (freq.contains(i)) freq(i) += 1\n            else freq(i) = 1\n      \
    \  }\n        var max = -1l\n        for (i <- freq.keys) {\n            if (freq(i)\
    \ >= i && i > max) max = i\n        }\n        return max", "        val map =\
    \ new HashMap[Long, Long]\n        for (i <- lst) {\n            if (map.contains(i))\
    \ map(i) += 1\n            else map(i) = 1\n        }\n        var max = -1l\n\
    \        for (i <- map.keys) {\n            if (i <= map(i) && i > max) max =\
    \ i\n        }\n        max", "        val m = lst.groupBy(identity).mapValues(_.size)\n\
    \        val v = m.filter(x => x._1 <= x._2).maxBy(x => x._1)\n        if (v._1\
    \ == v._2) v._1 else -1", "        val m = lst.groupBy(x => x).map(x => (x._1,\
    \ x._2.length))\n        val max = m.maxBy(x => x._2)\n        if (max._2 >= max._1)\
    \ max._1 else -1", "        val map = new HashMap[Long, Long]\n        for (i\
    \ <- lst) {\n            if (map.contains(i)) map(i) += 1\n            else map(i)\
    \ = 1\n        }\n        var max = -1l\n        for (i <- lst) {\n          \
    \  if (map(i) >= i && i > max) max = i\n        }\n        return max", "    \
    \    val map = new HashMap[Long, Long]\n        for (i <- lst) {\n           \
    \ if (map.contains(i)) map(i) += 1\n            else map(i) = 1\n        }\n \
    \       var max = -1l\n        for (i <- map.keys) {\n            if (i <= map(i)\
    \ && i > max) max = i\n        }\n        max", "        val freq = new HashMap[Long,\
    \ Long]\n        for (i <- lst) {\n            if (freq.contains(i)) freq(i) +=\
    \ 1\n            else freq(i) = 1\n        }\n        var max = -1l\n        for\
    \ (i <- freq.keys) {\n            if (freq(i) >= i && i > max) max = i\n     \
    \   }\n        return max", "        val m = lst.groupBy(identity).mapValues(_.size)\n\
    \        val keys = m.keys.toList.sorted\n        for (i <- keys.length - 1 to\
    \ 0 by -1) {\n            if (m(keys(i)) >= keys(i)) return keys(i)\n        }\n\
    \        return -1", "        val m = lst.groupBy(identity).mapValues(_.size)\n\
    \        val r = m.filter(x => x._1 <= x._2).toList.sortBy(_._1).reverse\n   \
    \     if (r.isEmpty) -1 else r.head._1", "        val m = lst.groupBy(x => x).mapValues(_.size)\n\
    \        val l = m.keys.toList.sorted\n        val r = l.filter(x => m(x) >= x)\n\
    \        if (r.size == 0) -1 else r.last", "        val m = lst.groupBy(x => x).mapValues(_.size)\n\
    \        val k = m.keys.toList.sorted\n        for (i <- k.size - 1 to 0 by -1)\
    \ {\n            if (m(k(i)) >= k(i)) return k(i)\n        }\n        return -1",
  "        val m = lst.groupBy(identity).mapValues(_.size)\n        val r = m.filter(x\
    \ => x._1 <= x._2).toList.sortBy(_._1).reverse\n        if (r.isEmpty) -1 else\
    \ r.head._1", "        val m = lst.groupBy(x => x).mapValues(_.size)\n       \
    \ val keys = m.keys.toList.sorted\n        val values = m.values.toList.sorted\n\
    \        val max = keys.max\n        val min = keys.min\n        val maxValue\
    \ = values.max\n        val minValue = values.min\n        if (maxValue < max)\
    \ -1\n        else if (minValue > min) min\n        else {\n            var i\
    \ = max - 1\n            while (i >= min) {\n                if (m.getOrElse(i,\
    \ 0) >= i) return i\n                i -= 1\n            }\n            -1\n \
    \       }", "        val m = lst.groupBy(identity).mapValues(_.size)\n       \
    \ val max = m.keys.max\n        val maxFreq = m(max)\n        if (maxFreq >= max)\
    \ max else -1", "        val map = new HashMap[Long, Long]\n        for (i <-\
    \ lst) {\n            if (map.contains(i)) map(i) += 1\n            else map(i)\
    \ = 1\n        }\n        var max = -1l\n        for (i <- lst) {\n          \
    \  if (map(i) >= i && i > max) max = i\n        }\n        return max"]
stop_tokens:
- "\n    }\n"
