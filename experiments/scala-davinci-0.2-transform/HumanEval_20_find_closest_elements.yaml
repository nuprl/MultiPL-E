name: HumanEval_20_find_closest_elements
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // From a supplied list of numbers (of length at least two) select and return\
  \ two that are the closest to each\n    // other and return them in order (smaller\
  \ number, larger number).\n    // >>> findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat)))\n    //\
  \ ((2.0f, 2.2f))\n    // >>> findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat)))\n    // ((2.0f, 2.0f))\n\
  \    def findClosestElements(numbers : List[Float]) : Tuple2[Float, Float] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((3.9f,\
  \ 4.0f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 5.9f.toFloat, 4.0f.toFloat, 5.0f.toFloat))).equals(((5.0f, 5.9f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat,\
  \ 2.0f.toFloat, 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.2f.toFloat))).equals(((2.0f,\
  \ 2.2f))));\n    assert(findClosestElements((List[Float](1.0f.toFloat, 2.0f.toFloat,\
  \ 3.0f.toFloat, 4.0f.toFloat, 5.0f.toFloat, 2.0f.toFloat))).equals(((2.0f, 2.0f))));\n\
  \    assert(findClosestElements((List[Float](1.1f.toFloat, 2.2f.toFloat, 3.1f.toFloat,\
  \ 4.1f.toFloat, 5.1f.toFloat))).equals(((2.2f, 3.1f))));\n    }\n\n}\n"
completions: ["        var minDiff = Float.MaxValue\n        var minDiffElements =\
    \ (Float.MaxValue, Float.MaxValue)\n        for (i <- 0 until numbers.length -\
    \ 1) {\n            val diff = abs(numbers(i) - numbers(i + 1))\n            if\
    \ (diff < minDiff) {\n                minDiff = diff\n                minDiffElements\
    \ = (numbers(i), numbers(i + 1))\n            }\n        }\n        minDiffElements",
  "        var closest : Tuple2[Float, Float] = (numbers(0), numbers(1))\n       \
    \ var closestDistance : Float = abs(numbers(0) - numbers(1))\n        for (i <-\
    \ 0 until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val distance = abs(numbers(i) - numbers(j))\n           \
    \     if (distance < closestDistance) {\n                    closest = (numbers(i),\
    \ numbers(j))\n                    closestDistance = distance\n              \
    \  }\n            }\n        }\n        closest", "        var minDiff = Float.MaxValue\n\
    \        var minPair = (0.0f, 0.0f)\n        for (i <- 0 until numbers.length\
    \ - 1) {\n            for (j <- i + 1 until numbers.length) {\n              \
    \  val diff = abs(numbers(i) - numbers(j))\n                if (diff < minDiff)\
    \ {\n                    minDiff = diff\n                    minPair = (numbers(i),\
    \ numbers(j))\n                }\n            }\n        }\n        minPair",
  "        var closest : Tuple2[Float, Float] = (numbers(0), numbers(1))\n       \
    \ var closestDistance : Float = abs(numbers(0) - numbers(1))\n        for (i <-\
    \ 0 until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val distance = abs(numbers(i) - numbers(j))\n           \
    \     if (distance < closestDistance) {\n                    closest = (numbers(i),\
    \ numbers(j))\n                    closestDistance = distance\n              \
    \  }\n            }\n        }\n        closest", "        var closest : Tuple2[Float,\
    \ Float] = (numbers(0), numbers(1))\n        for (i <- 0 until numbers.length\
    \ - 1) {\n            for (j <- i + 1 until numbers.length) {\n              \
    \  if (abs(numbers(i) - numbers(j)) < abs(closest._1 - closest._2)) {\n      \
    \              closest = (numbers(i), numbers(j))\n                }\n       \
    \     }\n        }\n        closest", "        var min = Float.MaxValue\n    \
    \    var minTuple = (0.0f, 0.0f)\n        for (i <- 0 until numbers.length - 1)\
    \ {\n            for (j <- i + 1 until numbers.length) {\n                val\
    \ diff = abs(numbers(i) - numbers(j))\n                if (diff < min) {\n   \
    \                 min = diff\n                    minTuple = (numbers(i), numbers(j))\n\
    \                }\n            }\n        }\n        minTuple", "        var\
    \ closestElements : Tuple2[Float, Float] = (numbers(0), numbers(1))\n        var\
    \ closestDistance : Float = abs(numbers(0) - numbers(1))\n        for (i <- 0\
    \ until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val distance = abs(numbers(i) - numbers(j))\n           \
    \     if (distance < closestDistance) {\n                    closestDistance =\
    \ distance\n                    closestElements = (numbers(i), numbers(j))\n \
    \               }\n            }\n        }\n        closestElements", "     \
    \   var closest = (numbers(0), numbers(1))\n        var closestDistance = abs(numbers(0)\
    \ - numbers(1))\n        for (i <- 0 until numbers.length - 1) {\n           \
    \ for (j <- i + 1 until numbers.length) {\n                val distance = abs(numbers(i)\
    \ - numbers(j))\n                if (distance < closestDistance) {\n         \
    \           closest = (numbers(i), numbers(j))\n                    closestDistance\
    \ = distance\n                }\n            }\n        }\n        closest", " \
    \       var minDiff = Float.MaxValue\n        var minPair : Tuple2[Float, Float]\
    \ = null\n        for (i <- 0 until numbers.length - 1) {\n            for (j\
    \ <- i + 1 until numbers.length) {\n                val diff = abs(numbers(i)\
    \ - numbers(j))\n                if (diff < minDiff) {\n                    minDiff\
    \ = diff\n                    minPair = (min(numbers(i), numbers(j)), max(numbers(i),\
    \ numbers(j)))\n                }\n            }\n        }\n        minPair",
  "        var minDiff = Float.MaxValue\n        var minPair : Tuple2[Float, Float]\
    \ = null\n        for (i <- 0 until numbers.length - 1) {\n            val diff\
    \ = abs(numbers(i) - numbers(i + 1))\n            if (diff < minDiff) {\n    \
    \            minDiff = diff\n                minPair = (numbers(i), numbers(i\
    \ + 1))\n            }\n        }\n        minPair", "        var closest : Tuple2[Float,\
    \ Float] = (numbers(0), numbers(1))\n        var closestDistance : Float = abs(numbers(0)\
    \ - numbers(1))\n        for (i <- 0 until numbers.length - 1) {\n           \
    \ for (j <- i + 1 until numbers.length) {\n                val distance = abs(numbers(i)\
    \ - numbers(j))\n                if (distance < closestDistance) {\n         \
    \           closest = (numbers(i), numbers(j))\n                    closestDistance\
    \ = distance\n                }\n            }\n        }\n        closest", " \
    \       var closest = (numbers(0), numbers(1))\n        var closestDistance =\
    \ abs(numbers(0) - numbers(1))\n        for (i <- 0 until numbers.length - 1)\
    \ {\n            for (j <- i + 1 until numbers.length) {\n                val\
    \ distance = abs(numbers(i) - numbers(j))\n                if (distance < closestDistance)\
    \ {\n                    closest = (numbers(i), numbers(j))\n                \
    \    closestDistance = distance\n                }\n            }\n        }\n\
    \        if (closest._1 > closest._2) {\n            (closest._2, closest._1)\n\
    \        } else {\n            closest\n        }", "        var minDiff = Float.MaxValue\n\
    \        var minPair = (0.0f, 0.0f)\n        for (i <- 0 until numbers.length\
    \ - 1) {\n            for (j <- i + 1 until numbers.length) {\n              \
    \  val diff = abs(numbers(i) - numbers(j))\n                if (diff < minDiff)\
    \ {\n                    minDiff = diff\n                    minPair = (numbers(i),\
    \ numbers(j))\n                }\n            }\n        }\n        minPair",
  "        var minDiff = Float.MaxValue\n        var minPair : Tuple2[Float, Float]\
    \ = null\n        for (i <- 0 until numbers.length - 1) {\n            val diff\
    \ = abs(numbers(i) - numbers(i + 1))\n            if (diff < minDiff) {\n    \
    \            minDiff = diff\n                minPair = (numbers(i), numbers(i\
    \ + 1))\n            }\n        }\n        minPair", "        var minDiff = Float.MaxValue\n\
    \        var minPair = (0.0f, 0.0f)\n        for (i <- 0 until numbers.length\
    \ - 1) {\n            for (j <- i + 1 until numbers.length) {\n              \
    \  val diff = abs(numbers(i) - numbers(j))\n                if (diff < minDiff)\
    \ {\n                    minDiff = diff\n                    minPair = (numbers(i),\
    \ numbers(j))\n                }\n            }\n        }\n        minPair",
  "        var closest : Tuple2[Float, Float] = (numbers(0), numbers(1))\n       \
    \ var closestDistance : Float = abs(numbers(0) - numbers(1))\n        for (i <-\
    \ 0 until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val distance = abs(numbers(i) - numbers(j))\n           \
    \     if (distance < closestDistance) {\n                    closest = (numbers(i),\
    \ numbers(j))\n                    closestDistance = distance\n              \
    \  }\n            }\n        }\n        closest", "        var closest = (numbers(0),\
    \ numbers(1))\n        var closestDiff = abs(numbers(0) - numbers(1))\n      \
    \  for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1 until\
    \ numbers.length) {\n                val diff = abs(numbers(i) - numbers(j))\n\
    \                if (diff < closestDiff) {\n                    closest = (numbers(i),\
    \ numbers(j))\n                    closestDiff = diff\n                }\n   \
    \         }\n        }\n        closest", "        var closest : Tuple2[Float,\
    \ Float] = (numbers(0), numbers(1))\n        var closestDistance : Float = abs(numbers(0)\
    \ - numbers(1))\n        for (i <- 0 until numbers.length - 1) {\n           \
    \ for (j <- i + 1 until numbers.length) {\n                val distance = abs(numbers(i)\
    \ - numbers(j))\n                if (distance < closestDistance) {\n         \
    \           closest = (numbers(i), numbers(j))\n                    closestDistance\
    \ = distance\n                }\n            }\n        }\n        closest", " \
    \       var min = Float.MaxValue\n        var minPair = (0.0f, 0.0f)\n       \
    \ for (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val diff = abs(numbers(i) - numbers(j))\n               \
    \ if (diff < min) {\n                    min = diff\n                    minPair\
    \ = (numbers(i), numbers(j))\n                }\n            }\n        }\n  \
    \      minPair", "        var closest : Tuple2[Float, Float] = (numbers(0), numbers(1))\n\
    \        var closestDistance : Float = abs(numbers(0) - numbers(1))\n        for\
    \ (i <- 0 until numbers.length - 1) {\n            for (j <- i + 1 until numbers.length)\
    \ {\n                val distance = abs(numbers(i) - numbers(j))\n           \
    \     if (distance < closestDistance) {\n                    closest = (numbers(i),\
    \ numbers(j))\n                    closestDistance = distance\n              \
    \  }\n            }\n        }\n        closest"]
stop_tokens:
- "\n    }\n"
