name: HumanEval_11_string_xor
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform\
  \ binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"\
  010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String)\
  \ : String = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"\
  ), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"\
  0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n   \
  \ }\n\n}\n"
completions: ["        val aBits = a.map(c => c.toString.toInt)\n        val bBits\
    \ = b.map(c => c.toString.toInt)\n        val result = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        result.map(i => i.toString).reduceLeft(_ + _)", " \
    \       val aBits = a.map(c => c.toString.toInt)\n        val bBits = b.map(c\
    \ => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p => p._1 ^\
    \ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)", "        val\
    \ aBits = a.toList.map(c => c.toString.toInt)\n        val bBits = b.toList.map(c\
    \ => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p => p._1 ^\
    \ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)", "        val\
    \ aBits = a.map(c => c.toString.toInt)\n        val bBits = b.map(c => c.toString.toInt)\n\
    \        val xorBits = aBits.zip(bBits).map(p => p._1 ^ p._2)\n        xorBits.map(b\
    \ => b.toString).reduceLeft(_ + _)", "        val result = new StringBuilder\n\
    \        for (i <- 0 until a.length) {\n            result += (if (a(i) == b(i))\
    \ '0' else '1')\n        }\n        result.toString", "        val aBits = a.toList.map(c\
    \ => c.toString.toInt)\n        val bBits = b.toList.map(c => c.toString.toInt)\n\
    \        val xorBits = aBits.zip(bBits).map(p => p._1 ^ p._2)\n        xorBits.map(b\
    \ => b.toString).reduceLeft(_ + _)", "        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)", " \
    \       val c = new StringBuilder\n        for (i <- 0 until a.length) {\n   \
    \         c.append((if (a(i) == '1') 1 else 0) ^ (if (b(i) == '1') 1 else 0))\n\
    \        }\n        c.toString", "        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val cBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        cBits.map(c => c.toString).reduceLeft(_ + _)", "  \
    \      val aBits = a.map(c => c.toString.toInt)\n        val bBits = b.map(c =>\
    \ c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p => p._1 ^ p._2)\n\
    \        xorBits.map(b => b.toString).reduceLeft(_ + _)", "        val aBits =\
    \ a.map(c => c.toString.toInt)\n        val bBits = b.map(c => c.toString.toInt)\n\
    \        val xorBits = aBits.zip(bBits).map(p => p._1 ^ p._2)\n        xorBits.map(b\
    \ => b.toString).reduceLeft(_ + _)", "        val aBits = a.toList.map(c => c.toString.toInt)\n\
    \        val bBits = b.toList.map(c => c.toString.toInt)\n        val xorBits\
    \ = aBits.zip(bBits).map(p => p._1 ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_\
    \ + _)", "        val a_bytes = a.getBytes\n        val b_bytes = b.getBytes\n\
    \        val xor_bytes = a_bytes.zip(b_bytes).map(x => (x._1 ^ x._2).toByte)\n\
    \        new String(xor_bytes)", "        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        (aBits zip bBits).map(p\
    \ => (p._1 ^ p._2).toString).mkString", "        val c = new StringBuilder\n \
    \       for (i <- 0 until a.length) {\n            c.append((a(i) - '0') ^ (b(i)\
    \ - '0'))\n        }\n        c.toString", "        val aBits = a.toList.map(c\
    \ => c.toString.toInt)\n        val bBits = b.toList.map(c => c.toString.toInt)\n\
    \        val xorBits = aBits.zip(bBits).map(p => p._1 ^ p._2)\n        xorBits.map(b\
    \ => b.toString).reduceLeft(_ + _)", "        val aBits = a.map(c => c.toString.toInt)\n\
    \        val bBits = b.map(c => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p\
    \ => p._1 ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)", " \
    \       val aBits = a.map(c => c.toString.toInt)\n        val bBits = b.map(c\
    \ => c.toString.toInt)\n        val xorBits = aBits.zip(bBits).map(p => p._1 ^\
    \ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)", "        val\
    \ aBits = a.toList.map(c => c.toString.toInt)\n        val bBits = b.toList.map(c\
    \ => c.toString.toInt)\n        val xorBits = (aBits zip bBits).map(p => p._1\
    \ ^ p._2)\n        xorBits.map(b => b.toString).reduceLeft(_ + _)", "        val\
    \ aBits = a.map(c => if (c == '1') 1 else 0)\n        val bBits = b.map(c => if\
    \ (c == '1') 1 else 0)\n        val xorBits = (aBits zip bBits).map(t => t._1\
    \ ^ t._2)\n        xorBits.map(b => if (b == 1) '1' else '0').mkString"]
stop_tokens:
- "\n    }\n"
