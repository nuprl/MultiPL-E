name: HumanEval_96_count_up_to
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Implement a function that takes an non-negative integer and returns an array\
  \ of the first n\n    // integers that are prime numbers and less than n.\n    //\
  \ for example:\n    // >>> countUpTo((5l))\n    // (List[Long](2l.toLong, 3l.toLong))\n\
  \    // >>> countUpTo((11l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong))\n    // >>> countUpTo((0l))\n    // (List[Long]())\n    // >>> countUpTo((20l))\n\
  \    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong,\
  \ 17l.toLong, 19l.toLong))\n    // >>> countUpTo((1l))\n    // (List[Long]())\n\
  \    // >>> countUpTo((18l))\n    // (List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))\n    def countUpTo(n : Long) :\
  \ List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(countUpTo((5l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong))));\n    assert(countUpTo((6l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong))));\n    assert(countUpTo((7l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong))));\n    assert(countUpTo((10l)).equals((List[Long](2l.toLong, 3l.toLong,\
  \ 5l.toLong, 7l.toLong))));\n    assert(countUpTo((0l)).equals((List[Long]())));\n\
  \    assert(countUpTo((22l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong))));\n    assert(countUpTo((1l)).equals((List[Long]())));\n\
  \    assert(countUpTo((18l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong))));\n    assert(countUpTo((47l)).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong,\
  \ 23l.toLong, 29l.toLong, 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong))));\n\
  \    assert(countUpTo((101l)).equals((List[Long](2l.toLong, 3l.toLong, 5l.toLong,\
  \ 7l.toLong, 11l.toLong, 13l.toLong, 17l.toLong, 19l.toLong, 23l.toLong, 29l.toLong,\
  \ 31l.toLong, 37l.toLong, 41l.toLong, 43l.toLong, 47l.toLong, 53l.toLong, 59l.toLong,\
  \ 61l.toLong, 67l.toLong, 71l.toLong, 73l.toLong, 79l.toLong, 83l.toLong, 89l.toLong,\
  \ 97l.toLong))));\n    }\n\n}\n"
completions: ["        if (n < 2) {\n            return List[Long]()\n        }\n\
    \        var primes = new ListBuffer[Long]()\n        var i = 2l\n        while\
    \ (i < n) {\n            if (isPrime(i)) {\n                primes += i\n    \
    \        }\n            i += 1\n        }\n        primes.toList", "        //\
    \ your code here\n        var result = List[Long]()\n        for (i <- 2l to n)\
    \ {\n            if (isPrime(i)) {\n                result = result :+ i\n   \
    \         }\n        }\n        result", "        // your code here\n        var\
    \ primes = List[Long]()\n        for (i <- 2l to n) {\n            if (isPrime(i))\
    \ {\n                primes = primes :+ i\n            }\n        }\n        primes",
  "        var primes = List[Long]()\n        var i = 2l\n        while (i < n) {\n\
    \            if (isPrime(i)) {\n                primes = primes :+ i\n       \
    \     }\n            i += 1\n        }\n        primes", "        // your code\
    \ here\n        var list = List[Long]()\n        for (i <- 2l to n) {\n      \
    \      if (isPrime(i)) {\n                list = list :+ i\n            }\n  \
    \      }\n        list", "        def isPrime(n : Long) : Boolean = {\n      \
    \      if (n <= 1) return false\n            if (n == 2) return true\n       \
    \     if (n % 2 == 0) return false\n            val sqrtN = sqrt(n).toLong\n \
    \           var i = 3\n            while (i <= sqrtN) {\n                if (n\
    \ % i == 0) return false\n                i += 2\n            }\n            return\
    \ true\n        }\n        var result = List[Long]()\n        var i = 2l\n   \
    \     while (i < n) {\n            if (isPrime(i)) result = result :+ i\n    \
    \        i += 1\n        }\n        return result", "        def isPrime(n : Long)\
    \ : Boolean = {\n            if (n < 2) return false\n            if (n == 2)\
    \ return true\n            if (n % 2 == 0) return false\n            val sqrtN\
    \ = sqrt(n).toLong\n            var i = 3l\n            while (i <= sqrtN) {\n\
    \                if (n % i == 0) return false\n                i += 2\n      \
    \      }\n            return true\n        }\n        var result = List[Long]()\n\
    \        var i = 2l\n        while (i < n) {\n            if (isPrime(i)) result\
    \ = i :: result\n            i += 1\n        }\n        return result", "    \
    \    if (n <= 1) return List[Long]()\n        var primes = new ListBuffer[Long]()\n\
    \        for (i <- 2l to n) {\n            if (isPrime(i)) primes += i\n     \
    \   }\n        primes.toList", "        var primes = new ListBuffer[Long]()\n\
    \        for (i <- 2l to n) {\n            if (isPrime(i)) primes += i\n     \
    \   }\n        primes.toList", "        if (n <= 1) {\n            return List[Long]()\n\
    \        }\n        var primes = ListBuffer[Long]()\n        for (i <- 2l to n)\
    \ {\n            if (isPrime(i)) {\n                primes += i\n            }\n\
    \        }\n        primes.toList", "        // your code here\n        var primes\
    \ = new ListBuffer[Long]()\n        for (i <- 2l to n) {\n            if (isPrime(i))\
    \ {\n                primes += i\n            }\n        }\n        primes.toList",
  "        // your code here\n        var result = List[Long]()\n        var i = 2l\n\
    \        while (i < n) {\n            if (isPrime(i)) {\n                result\
    \ = result :+ i\n            }\n            i += 1\n        }\n        result",
  "        if (n < 2) return List[Long]()\n        var primes = List[Long](2l)\n \
    \       var i = 3l\n        while (i < n) {\n            if (primes.forall(p =>\
    \ i % p != 0)) primes = primes :+ i\n            i += 2\n        }\n        primes",
  "        def isPrime(n : Long) : Boolean = {\n            if (n <= 1) return false\n\
    \            if (n == 2) return true\n            if (n % 2 == 0) return false\n\
    \            val sqrtN = sqrt(n).toLong\n            for (i <- 3l to sqrtN by\
    \ 2) {\n                if (n % i == 0) return false\n            }\n        \
    \    return true\n        }\n        var result = List[Long]()\n        for (i\
    \ <- 2l to n) {\n            if (isPrime(i)) result = result :+ i\n        }\n\
    \        return result", "        // Your code here\n        var result = List[Long]()\n\
    \        for (i <- 2l to n) {\n            if (isPrime(i)) {\n               \
    \ result = result :+ i\n            }\n        }\n        result", "        var\
    \ result = List[Long]()\n        for (i <- 2l to n) {\n            if (isPrime(i))\
    \ result = result :+ i\n        }\n        result", "        // your code here\n\
    \        var result = List[Long]()\n        for (i <- 2l to n) {\n           \
    \ if (isPrime(i)) {\n                result = result :+ i\n            }\n   \
    \     }\n        result", "        // your code here\n        var result = List[Long]()\n\
    \        for (i <- 2l to n) {\n            if (isPrime(i)) {\n               \
    \ result = result :+ i\n            }\n        }\n        result", "        //\
    \ your code here\n        var primes = new ListBuffer[Long]()\n        for (i\
    \ <- 2l to n) {\n            if (isPrime(i)) {\n                primes += i\n\
    \            }\n        }\n        primes.toList", "        // your solution here\n\
    \        var list = List[Long]()\n        for (i <- 2l to n) {\n            if\
    \ (isPrime(i)) {\n                list = list :+ i\n            }\n        }\n\
    \        list"]
stop_tokens:
- "\n    }\n"
