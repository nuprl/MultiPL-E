name: HumanEval_136_largest_smallest_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
  \ largest of negative integers, and 'b' is the smallest\n    // of positive integers\
  \ in a list.\n    // If there is no negative or positive integers, return them as\
  \ None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
  \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
  \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n   \
  \ // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
  \ : Tuple2[Option[Long], Option[Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
  \ 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong,\
  \ 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong,\
  \ 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n\
  \    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
  \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
  \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
  \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
  \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
  \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n\
  \    }\n\n}\n"
completions: ["        // Fill in the code here\n        val neg = lst.filter(_ <\
    \ 0)\n        val pos = lst.filter(_ > 0)\n        (if (neg.isEmpty) None else\
    \ Some(neg.max), if (pos.isEmpty) None else Some(pos.min))", "        // Fill\
    \ in the code here\n        var maxNeg = None : Option[Long]\n        var minPos\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (maxNeg == None) maxNeg = Some(i)\n                else if\
    \ (i > maxNeg.get) maxNeg = Some(i)\n            }\n            else if (i > 0)\
    \ {\n                if (minPos == None) minPos = Some(i)\n                else\
    \ if (i < minPos.get) minPos = Some(i)\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        // Fill in the code here\n        var min = Long.MaxValue\n\
    \        var max = Long.MinValue\n        for (i <- lst) {\n            if (i\
    \ < 0) {\n                if (i > max) max = i\n            } else {\n       \
    \         if (i < min) min = i\n            }\n        }\n        if (min == Long.MaxValue)\
    \ min = None\n        if (max == Long.MinValue) max = None\n        (Some(max),\
    \ Some(min))", "        // Fill in the code here\n        (None, None)", "   \
    \     // Fill in the code here\n        return (None, None)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        var maxNeg : Option[Long] = None\n    \
    \    var minPos : Option[Long] = None\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) {\n                    maxNeg\
    \ = Some(i)\n                } else {\n                    maxNeg = Some(max(maxNeg.get,\
    \ i))\n                }\n            } else if (i > 0) {\n                if\
    \ (minPos == None) {\n                    minPos = Some(i)\n                }\
    \ else {\n                    minPos = Some(min(minPos.get, i))\n            \
    \    }\n            }\n        }\n        (maxNeg, minPos)", "        val negatives\
    \ = lst.filter(x => x < 0)\n        val positives = lst.filter(x => x > 0)\n \
    \       val largestNegative = negatives.size match {\n            case 0 => None\n\
    \            case _ => Some(negatives.max)\n        }\n        val smallestPositive\
    \ = positives.size match {\n            case 0 => None\n            case _ =>\
    \ Some(positives.min)\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        return (None, None)", "        // Fill\
    \ in the code here\n        (None, None)", "        // Fill in the code here\n\
    \        return (None, None)", "        var largestNegative : Option[Long] = None\n\
    \        var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        return (largestNegative, smallestPositive)", "        // Fill\
    \ in the code here\n        var maxNegative = None:Option[Long]\n        var minPositive\
    \ = None:Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (maxNegative == None) {\n                    maxNegative = Some(i)\n\
    \                } else {\n                    if (i > maxNegative.get) {\n  \
    \                      maxNegative = Some(i)\n                    }\n        \
    \        }\n            } else if (i > 0) {\n                if (minPositive ==\
    \ None) {\n                    minPositive = Some(i)\n                } else {\n\
    \                    if (i < minPositive.get) {\n                        minPositive\
    \ = Some(i)\n                    }\n                }\n            }\n       \
    \ }\n        (maxNegative, minPositive)", "        // Fill in the code here\n\
    \        var neg = None:Option[Long]\n        var pos = None:Option[Long]\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (neg ==\
    \ None) neg = Some(i)\n                else if (i > neg.get) neg = Some(i)\n \
    \           }\n            else if (i > 0) {\n                if (pos == None)\
    \ pos = Some(i)\n                else if (i < pos.get) pos = Some(i)\n       \
    \     }\n        }\n        (neg, pos)", "        // Fill in the code here\n \
    \       var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        return (None, None)", "        // Fill\
    \ in the code here\n        return (None, None)", "        // Fill in the code\
    \ here\n        return (None, None)", "        // Fill in the code here\n    \
    \    var maxNeg = None:Option[Long]\n        var minPos = None:Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None) {\n                    maxNeg = Some(i)\n                } else {\n\
    \                    if (i > maxNeg.get) {\n                        maxNeg = Some(i)\n\
    \                    }\n                }\n            } else if (i > 0) {\n \
    \               if (minPos == None) {\n                    minPos = Some(i)\n\
    \                } else {\n                    if (i < minPos.get) {\n       \
    \                 minPos = Some(i)\n                    }\n                }\n\
    \            }\n        }\n        (maxNeg, minPos)"]
stop_tokens:
- "\n    }\n"
