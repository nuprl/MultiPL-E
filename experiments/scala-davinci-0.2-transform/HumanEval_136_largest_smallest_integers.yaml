name: HumanEval_136_largest_smallest_integers
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Create a function that returns a tuple (a, b), where 'a' is\n    // the\
  \ largest of negative integers, and 'b' is the smallest\n    // of positive integers\
  \ in a list.\n    // If there is no negative or positive integers, return them as\
  \ None.\n    // Examples:\n    // >>> largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong)))\n    // (Some(None),\
  \ Some(1l))\n    // >>> largestSmallestIntegers((List[Long]()))\n    // (Some(None),\
  \ Some(None))\n    // >>> largestSmallestIntegers((List[Long](0l.toLong)))\n   \
  \ // (Some(None), Some(None))\n    def largestSmallestIntegers(lst : List[Long])\
  \ : Tuple2[Option[Long], Option[Long]] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(largestSmallestIntegers((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 3l.toLong, 5l.toLong, 7l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](2l.toLong, 4l.toLong, 1l.toLong,\
  \ 3l.toLong, 5l.toLong, 7l.toLong, 0l.toLong))).equals((Some(None), Some(1l))));\n\
  \    assert(largestSmallestIntegers((List[Long](1l.toLong, 3l.toLong, 2l.toLong,\
  \ 4l.toLong, 5l.toLong, 6l.toLong, -2l.toLong))).equals((-2l, 1l)));\n    assert(largestSmallestIntegers((List[Long](4l.toLong,\
  \ 5l.toLong, 3l.toLong, 6l.toLong, 2l.toLong, 7l.toLong, -7l.toLong))).equals((-7l,\
  \ 2l)));\n    assert(largestSmallestIntegers((List[Long](7l.toLong, 3l.toLong, 8l.toLong,\
  \ 4l.toLong, 9l.toLong, 2l.toLong, 5l.toLong, -9l.toLong))).equals((-9l, 2l)));\n\
  \    assert(largestSmallestIntegers((List[Long]())).equals((Some(None), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](0l.toLong))).equals((Some(None),\
  \ Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong, -3l.toLong,\
  \ -5l.toLong, -6l.toLong))).equals((Some(-1l), Some(None))));\n    assert(largestSmallestIntegers((List[Long](-1l.toLong,\
  \ -3l.toLong, -5l.toLong, -6l.toLong, 0l.toLong))).equals((Some(-1l), Some(None))));\n\
  \    assert(largestSmallestIntegers((List[Long](-6l.toLong, -4l.toLong, -4l.toLong,\
  \ -3l.toLong, 1l.toLong))).equals((-3l, 1l)));\n    assert(largestSmallestIntegers((List[Long](-6l.toLong,\
  \ -4l.toLong, -4l.toLong, -3l.toLong, -100l.toLong, 1l.toLong))).equals((-3l, 1l)));\n\
  \    }\n\n}\n"
completions: ["        // Fill in the code here\n        val neg = lst.filter(_ <\
    \ 0)\n        val pos = lst.filter(_ > 0)\n        (if (neg.isEmpty) None else\
    \ Some(neg.max), if (pos.isEmpty) None else Some(pos.min))", "        // Fill\
    \ in the code here\n        var maxNeg = None : Option[Long]\n        var minPos\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (maxNeg == None) maxNeg = Some(i)\n                else if\
    \ (i > maxNeg.get) maxNeg = Some(i)\n            }\n            else if (i > 0)\
    \ {\n                if (minPos == None) minPos = Some(i)\n                else\
    \ if (i < minPos.get) minPos = Some(i)\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        // Fill in the code here\n        var min = Long.MaxValue\n\
    \        var max = Long.MinValue\n        for (i <- lst) {\n            if (i\
    \ < 0) {\n                if (i > max) max = i\n            } else {\n       \
    \         if (i < min) min = i\n            }\n        }\n        if (min == Long.MaxValue)\
    \ min = None\n        if (max == Long.MinValue) max = None\n        (Some(max),\
    \ Some(min))", "        // Fill in the code here\n        (None, None)", "   \
    \     // Fill in the code here\n        return (None, None)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        var maxNeg : Option[Long] = None\n    \
    \    var minPos : Option[Long] = None\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) {\n                    maxNeg\
    \ = Some(i)\n                } else {\n                    maxNeg = Some(max(maxNeg.get,\
    \ i))\n                }\n            } else if (i > 0) {\n                if\
    \ (minPos == None) {\n                    minPos = Some(i)\n                }\
    \ else {\n                    minPos = Some(min(minPos.get, i))\n            \
    \    }\n            }\n        }\n        (maxNeg, minPos)", "        val negatives\
    \ = lst.filter(x => x < 0)\n        val positives = lst.filter(x => x > 0)\n \
    \       val largestNegative = negatives.size match {\n            case 0 => None\n\
    \            case _ => Some(negatives.max)\n        }\n        val smallestPositive\
    \ = positives.size match {\n            case 0 => None\n            case _ =>\
    \ Some(positives.min)\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        return (None, None)", "        // Fill\
    \ in the code here\n        (None, None)", "        // Fill in the code here\n\
    \        return (None, None)", "        var largestNegative : Option[Long] = None\n\
    \        var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        return (largestNegative, smallestPositive)", "        // Fill\
    \ in the code here\n        var maxNegative = None:Option[Long]\n        var minPositive\
    \ = None:Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (maxNegative == None) {\n                    maxNegative = Some(i)\n\
    \                } else {\n                    if (i > maxNegative.get) {\n  \
    \                      maxNegative = Some(i)\n                    }\n        \
    \        }\n            } else if (i > 0) {\n                if (minPositive ==\
    \ None) {\n                    minPositive = Some(i)\n                } else {\n\
    \                    if (i < minPositive.get) {\n                        minPositive\
    \ = Some(i)\n                    }\n                }\n            }\n       \
    \ }\n        (maxNegative, minPositive)", "        // Fill in the code here\n\
    \        var neg = None:Option[Long]\n        var pos = None:Option[Long]\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (neg ==\
    \ None) neg = Some(i)\n                else if (i > neg.get) neg = Some(i)\n \
    \           }\n            else if (i > 0) {\n                if (pos == None)\
    \ pos = Some(i)\n                else if (i < pos.get) pos = Some(i)\n       \
    \     }\n        }\n        (neg, pos)", "        // Fill in the code here\n \
    \       var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        return (None, None)", "        // Fill\
    \ in the code here\n        return (None, None)", "        // Fill in the code\
    \ here\n        return (None, None)", "        // Fill in the code here\n    \
    \    var maxNeg = None:Option[Long]\n        var minPos = None:Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None) {\n                    maxNeg = Some(i)\n                } else {\n\
    \                    if (i > maxNeg.get) {\n                        maxNeg = Some(i)\n\
    \                    }\n                }\n            } else if (i > 0) {\n \
    \               if (minPos == None) {\n                    minPos = Some(i)\n\
    \                } else {\n                    if (i < minPos.get) {\n       \
    \                 minPos = Some(i)\n                    }\n                }\n\
    \            }\n        }\n        (maxNeg, minPos)", "        val neg = lst.filter(x\
    \ => x < 0).sortWith(_ > _)\n        val pos = lst.filter(x => x > 0).sortWith(_\
    \ < _)\n        val a = if (neg.length > 0) Some(neg(0)) else None\n        val\
    \ b = if (pos.length > 0) Some(pos(0)) else None\n        (a, b)", "        //\
    \ Fill in the code here.\n        var largestNegative : Option[Long] = None\n\
    \        var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        // Fill in the\
    \ code here\n        (None, None)", "        // Fill in the implementation here.\n\
    \        var maxNeg = None:Option[Long]\n        var minPos = None:Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None) maxNeg = Some(i)\n                else if (i > maxNeg.get) maxNeg =\
    \ Some(i)\n            }\n            else if (i > 0) {\n                if (minPos\
    \ == None) minPos = Some(i)\n                else if (i < minPos.get) minPos =\
    \ Some(i)\n            }\n        }\n        return (maxNeg, minPos)", "     \
    \   var largestNegative : Option[Long] = None\n        var smallestPositive :\
    \ Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) largestNegative = Some(i)\n      \
    \          else if (i > largestNegative.get) largestNegative = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None : Option[Long]\n        var minPos = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg\
    \ = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        return (maxNeg, minPos)", "        // Fill\
    \ in the code here\n        val negative = lst.filter(_ < 0)\n        val positive\
    \ = lst.filter(_ > 0)\n        val largestNegative = if (negative.isEmpty) None\
    \ else Some(negative.max)\n        val smallestPositive = if (positive.isEmpty)\
    \ None else Some(positive.min)\n        (largestNegative, smallestPositive)",
  "        val lst2 = lst.filter(x => x != 0)\n        if (lst2.isEmpty) {\n     \
    \       return (Some(None), Some(None))\n        }\n        val lst3 = lst2.filter(x\
    \ => x < 0)\n        val lst4 = lst2.filter(x => x > 0)\n        if (lst3.isEmpty)\
    \ {\n            return (Some(None), Some(lst4.min))\n        }\n        if (lst4.isEmpty)\
    \ {\n            return (Some(lst3.max), Some(None))\n        }\n        return\
    \ (Some(lst3.max), Some(lst4.min))", "        // Fill in the code here\n     \
    \   var maxNeg = None:Option[Long]\n        var minPos = None:Option[Long]\n \
    \       for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None) {\n                    maxNeg = Some(i)\n                } else {\n\
    \                    maxNeg = Some(max(maxNeg.get, i))\n                }\n  \
    \          } else if (i > 0) {\n                if (minPos == None) {\n      \
    \              minPos = Some(i)\n                } else {\n                  \
    \  minPos = Some(min(minPos.get, i))\n                }\n            }\n     \
    \   }\n        (maxNeg, minPos)", "        val negative = lst.filter(x => x <\
    \ 0)\n        val positive = lst.filter(x => x > 0)\n        if (negative.isEmpty)\
    \ {\n            if (positive.isEmpty) (Some(None), Some(None))\n            else\
    \ (Some(None), Some(positive.min))\n        }\n        else {\n            if\
    \ (positive.isEmpty) (Some(negative.max), Some(None))\n            else (Some(negative.max),\
    \ Some(positive.min))\n        }", "        // Fill in the code here\n       \
    \ var maxNeg = None:Option[Long]\n        var minPos = None:Option[Long]\n   \
    \     for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg ==\
    \ None) maxNeg = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n\
    \            }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        (maxNeg, minPos)", "        val negative =\
    \ lst.filter(x => x < 0).sortWith(_ > _)\n        val positive = lst.filter(x\
    \ => x > 0).sortWith(_ < _)\n        val largestNegative = if (negative.isEmpty)\
    \ None else Some(negative.head)\n        val smallestPositive = if (positive.isEmpty)\
    \ None else Some(positive.head)\n        (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var neg : Long = 0\n        var pos :\
    \ Long = 0\n        var neg_flag : Boolean = false\n        var pos_flag : Boolean\
    \ = false\n        for (i <- lst) {\n            if (i < 0) {\n              \
    \  if (neg_flag == false) {\n                    neg = i\n                   \
    \ neg_flag = true\n                }\n                else {\n               \
    \     if (i > neg) {\n                        neg = i\n                    }\n\
    \                }\n            }\n            else if (i > 0) {\n           \
    \     if (pos_flag == false) {\n                    pos = i\n                \
    \    pos_flag = true\n                }\n                else {\n            \
    \        if (i < pos) {\n                        pos = i\n                   \
    \ }\n                }\n            }\n        }\n        if (neg_flag == false)\
    \ {\n            (Some(None), Some(pos))\n        }\n        else if (pos_flag\
    \ == false) {\n            (Some(neg), Some(None))\n        }\n        else {\n\
    \            (Some(neg), Some(pos))\n        }", "        val sorted = lst.sortWith(_\
    \ < _)\n        val negatives = sorted.filter(_ < 0)\n        val positives =\
    \ sorted.filter(_ > 0)\n        val largestNegative = if (negatives.isEmpty) None\
    \ else Some(negatives.last)\n        val smallestPositive = if (positives.isEmpty)\
    \ None else Some(positives.head)\n        (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNegative = None : Option[Long]\n\
    \        var minPositive = None : Option[Long]\n        for (i <- lst) {\n   \
    \         if (i < 0) {\n                if (maxNegative == None) {\n         \
    \           maxNegative = Some(i)\n                } else {\n                \
    \    if (i > maxNegative.get) {\n                        maxNegative = Some(i)\n\
    \                    }\n                }\n            } else if (i > 0) {\n \
    \               if (minPositive == None) {\n                    minPositive =\
    \ Some(i)\n                } else {\n                    if (i < minPositive.get)\
    \ {\n                        minPositive = Some(i)\n                    }\n  \
    \              }\n            }\n        }\n        (maxNegative, minPositive)",
  "        // Fill in the code here\n        (None, None)", "        // Fill in the\
    \ code here\n        var maxNeg = Option.empty[Long]\n        var minPos = Option.empty[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg.isEmpty)\
    \ maxNeg = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n\
    \            }\n            else if (i > 0) {\n                if (minPos.isEmpty)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        (maxNeg, minPos)", "        // Fill in the\
    \ code here\n        return (None, None)", "        // Fill in the implementation\
    \ here.\n        var largestNegative = None:Option[Long]\n        var smallestPositive\
    \ = None:Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n    \
    \    var minPos = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) {\n                    maxNeg\
    \ = Some(i)\n                } else {\n                    maxNeg = Some(max(maxNeg.get,\
    \ i))\n                }\n            } else if (i > 0) {\n                if\
    \ (minPos == None) {\n                    minPos = Some(i)\n                }\
    \ else {\n                    minPos = Some(min(minPos.get, i))\n            \
    \    }\n            }\n        }\n        (maxNeg, minPos)", "        val negs\
    \ = lst.filter(x => x < 0)\n        val poss = lst.filter(x => x > 0)\n      \
    \  val neg = if (negs.length > 0) Some(negs.max) else None\n        val pos =\
    \ if (poss.length > 0) Some(poss.min) else None\n        (neg, pos)", "      \
    \  // Fill in the code here\n        var maxNegative = Option.empty[Long]\n  \
    \      var minPositive = Option.empty[Long]\n        for (i <- lst) {\n      \
    \      if (i < 0) {\n                if (maxNegative.isEmpty) maxNegative = Some(i)\n\
    \                else if (i > maxNegative.get) maxNegative = Some(i)\n       \
    \     }\n            else if (i > 0) {\n                if (minPositive.isEmpty)\
    \ minPositive = Some(i)\n                else if (i < minPositive.get) minPositive\
    \ = Some(i)\n            }\n        }\n        (maxNegative, minPositive)", " \
    \       // Fill in the code here\n        var a = None:Option[Long]\n        var\
    \ b = None:Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (a == None) {\n                    a = Some(i)\n         \
    \       } else {\n                    if (i > a.get) {\n                     \
    \   a = Some(i)\n                    }\n                }\n            } else\
    \ {\n                if (b == None) {\n                    b = Some(i)\n     \
    \           } else {\n                    if (i < b.get) {\n                 \
    \       b = Some(i)\n                    }\n                }\n            }\n\
    \        }\n        (a, b)", "        // Fill in the code here\n        var maxNeg\
    \ = None:Option[Long]\n        var minPos = None:Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg\
    \ = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        (maxNeg, minPos)", "        // Fill in the\
    \ code here\n        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None : Option[Long]\n        var minPos = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None) {\n\
    \                    maxNeg = Some(i)\n                } else {\n            \
    \        if (i > maxNeg.get) {\n                        maxNeg = Some(i)\n   \
    \                 }\n                }\n            } else if (i > 0) {\n    \
    \            if (minPos == None) {\n                    minPos = Some(i)\n   \
    \             } else {\n                    if (i < minPos.get) {\n          \
    \              minPos = Some(i)\n                    }\n                }\n  \
    \          }\n        }\n        return (maxNeg, minPos)", "        // Fill in\
    \ the code here\n        var largestNegative : Option[Long] = None\n        var\
    \ smallestPositive : Option[Long] = None\n        for (i <- lst) {\n         \
    \   if (i < 0) {\n                if (largestNegative == None) {\n           \
    \         largestNegative = Some(i)\n                } else {\n              \
    \      if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        // Fill in the code here\n  \
    \      var neg = None:Option[Long]\n        var pos = None:Option[Long]\n    \
    \    for (i <- lst) {\n            if (i < 0) {\n                if (neg == None)\
    \ neg = Some(i)\n                else if (i > neg.get) neg = Some(i)\n       \
    \     }\n            else if (i > 0) {\n                if (pos == None) pos =\
    \ Some(i)\n                else if (i < pos.get) pos = Some(i)\n            }\n\
    \        }\n        (neg, pos)", "        var largestNegative : Option[Long] =\
    \ None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        var maxNeg = None : Option[Long]\n    \
    \    var minPos = None : Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) maxNeg = Some(i)\n          \
    \      else if (i > maxNeg.get) maxNeg = Some(i)\n            }\n            else\
    \ if (i > 0) {\n                if (minPos == None) minPos = Some(i)\n       \
    \         else if (i < minPos.get) minPos = Some(i)\n            }\n        }\n\
    \        (maxNeg, minPos)", "        // Fill in the code here\n        var maxNeg\
    \ = Option.empty[Long]\n        var minPos = Option.empty[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg.isEmpty) maxNeg\
    \ = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (minPos.isEmpty)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        (maxNeg, minPos)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    val sorted = lst.sorted\n        val negative = sorted.filter(x => x < 0)\n\
    \        val positive = sorted.filter(x => x > 0)\n        val largestNegative\
    \ = if (negative.isEmpty) None else Some(negative.last)\n        val smallestPositive\
    \ = if (positive.isEmpty) None else Some(positive.head)\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None : Option[Long]\n        var minPos = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg\
    \ = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        (maxNeg, minPos)", "        // Fill in the\
    \ code here\n        var maxNeg = None:Option[Long]\n        var minPos = None:Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None) maxNeg = Some(i)\n                else maxNeg = Some(max(maxNeg.get,\
    \ i))\n            }\n            else if (i > 0) {\n                if (minPos\
    \ == None) minPos = Some(i)\n                else minPos = Some(min(minPos.get,\
    \ i))\n            }\n        }\n        (maxNeg, minPos)", "        // Fill in\
    \ the code here\n        val neg = lst.filter(x => x < 0)\n        val pos = lst.filter(x\
    \ => x > 0)\n        val negMax = if (neg.isEmpty) None else Some(neg.max)\n \
    \       val posMin = if (pos.isEmpty) None else Some(pos.min)\n        (negMax,\
    \ posMin)", "        // Fill in the code here\n        var maxNeg = None : Option[Long]\n\
    \        var minPos = None : Option[Long]\n        for (i <- lst) {\n        \
    \    if (i < 0) {\n                if (maxNeg == None) {\n                   \
    \ maxNeg = Some(i)\n                } else {\n                    if (i > maxNeg.get)\
    \ {\n                        maxNeg = Some(i)\n                    }\n       \
    \         }\n            } else if (i > 0) {\n                if (minPos == None)\
    \ {\n                    minPos = Some(i)\n                } else {\n        \
    \            if (i < minPos.get) {\n                        minPos = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        // Fill in the code here\n        var maxNeg = None : Option[Long]\n\
    \        var minPos = None : Option[Long]\n        for (i <- lst) {\n        \
    \    if (i < 0) {\n                if (maxNeg == None) maxNeg = Some(i)\n    \
    \            else if (i > maxNeg.get) maxNeg = Some(i)\n            }\n      \
    \      else if (i > 0) {\n                if (minPos == None) minPos = Some(i)\n\
    \                else if (i < minPos.get) minPos = Some(i)\n            }\n  \
    \      }\n        (maxNeg, minPos)", "        val negative = lst.filter(x => x\
    \ < 0).sortWith(_ > _)\n        val positive = lst.filter(x => x > 0).sortWith(_\
    \ < _)\n        val largestNegative = if (negative.isEmpty) None else Some(negative.head)\n\
    \        val smallestPositive = if (positive.isEmpty) None else Some(positive.head)\n\
    \        (largestNegative, smallestPositive)", "        // Fill in the code here\n\
    \        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n    \
    \    var minPos = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) maxNeg = Some(i)\n          \
    \      else if (i > maxNeg.get) maxNeg = Some(i)\n            }\n            else\
    \ if (i > 0) {\n                if (minPos == None) minPos = Some(i)\n       \
    \         else if (i < minPos.get) minPos = Some(i)\n            }\n        }\n\
    \        (maxNeg, minPos)", "        // Fill in the code here\n        var maxNeg\
    \ : Option[Long] = None\n        var minPos : Option[Long] = None\n        for\
    \ (i <- lst) {\n            if (i < 0) {\n                if (maxNeg == None)\
    \ {\n                    maxNeg = Some(i)\n                } else {\n        \
    \            if (i > maxNeg.get) {\n                        maxNeg = Some(i)\n\
    \                    }\n                }\n            } else if (i > 0) {\n \
    \               if (minPos == None) {\n                    minPos = Some(i)\n\
    \                } else {\n                    if (i < minPos.get) {\n       \
    \                 minPos = Some(i)\n                    }\n                }\n\
    \            }\n        }\n        (maxNeg, minPos)", "        // Fill in the\
    \ implementation here.\n        val (neg, pos) = lst.partition(_ < 0)\n      \
    \  (neg.headOption, pos.headOption)", "        // Fill in the code here\n    \
    \    return (None, None)", "        // Fill in the code here\n        val neg\
    \ = lst.filter(_ < 0)\n        val pos = lst.filter(_ > 0)\n        val negMax\
    \ = if (neg.isEmpty) None else Some(neg.max)\n        val posMin = if (pos.isEmpty)\
    \ None else Some(pos.min)\n        (negMax, posMin)", "        // Fill in the\
    \ code here\n        val negative = lst.filter(_ < 0)\n        val positive =\
    \ lst.filter(_ > 0)\n        val largestNegative = if (negative.isEmpty) None\
    \ else Some(negative.max)\n        val smallestPositive = if (positive.isEmpty)\
    \ None else Some(positive.min)\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var largestNegative = None:Option[Long]\n\
    \        var smallestPositive = None:Option[Long]\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) {\n  \
    \                  largestNegative = Some(i)\n                } else {\n     \
    \               if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) {\n   \
    \                 largestNegative = Some(i)\n                } else {\n      \
    \              if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        return (None,\
    \ None)", "        // Fill in the code here\n        (None, None)", "        //\
    \ Fill in the code here\n        val lst2 = lst.filter(x => x > 0)\n        val\
    \ lst3 = lst.filter(x => x < 0)\n        val lst4 = lst.filter(x => x == 0)\n\
    \        val lst5 = lst.filter(x => x != 0)\n        if (lst5.isEmpty) {\n   \
    \         (None, None)\n        } else if (lst2.isEmpty) {\n            (Some(lst3.max),\
    \ None)\n        } else if (lst3.isEmpty) {\n            (None, Some(lst2.min))\n\
    \        } else {\n            (Some(lst3.max), Some(lst2.min))\n        }", " \
    \       var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the implementation here.\n        var\
    \ largestNegative = None : Option[Long]\n        var smallestPositive = None :\
    \ Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n         \
    \       if (largestNegative == None) largestNegative = Some(i)\n             \
    \   else if (i > largestNegative.get) largestNegative = Some(i)\n            }\n\
    \            else if (i > 0) {\n                if (smallestPositive == None)\
    \ smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        // Fill in the\
    \ code here\n        var maxNeg = None:Option[Long]\n        var minPos = None:Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNeg\
    \ == None) {\n                    maxNeg = Some(i)\n                } else {\n\
    \                    maxNeg = Some(max(maxNeg.get, i))\n                }\n  \
    \          } else if (i > 0) {\n                if (minPos == None) {\n      \
    \              minPos = Some(i)\n                } else {\n                  \
    \  minPos = Some(min(minPos.get, i))\n                }\n            }\n     \
    \   }\n        (maxNeg, minPos)", "        // Fill in the implementation here.\n\
    \        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        val positives = lst.filter(_ > 0)\n \
    \       val negatives = lst.filter(_ < 0)\n        (negatives.size match {\n \
    \           case 0 => None\n            case _ => Some(negatives.max)\n      \
    \  }, positives.size match {\n            case 0 => None\n            case _ =>\
    \ Some(positives.min)\n        })", "        val negatives = lst.filter(x => x\
    \ < 0).sorted\n        val positives = lst.filter(x => x > 0).sorted\n       \
    \ (if (negatives.isEmpty) None else Some(negatives.last), if (positives.isEmpty)\
    \ None else Some(positives.head))", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNegative : Option[Long] = None\n\
    \        var minPositive : Option[Long] = None\n        for (i <- lst) {\n   \
    \         if (i < 0) {\n                if (maxNegative == None) {\n         \
    \           maxNegative = Some(i)\n                } else {\n                \
    \    if (i > maxNegative.get) {\n                        maxNegative = Some(i)\n\
    \                    }\n                }\n            } else if (i > 0) {\n \
    \               if (minPositive == None) {\n                    minPositive =\
    \ Some(i)\n                } else {\n                    if (i < minPositive.get)\
    \ {\n                        minPositive = Some(i)\n                    }\n  \
    \              }\n            }\n        }\n        (maxNegative, minPositive)",
  "        // Fill in the code here\n        var min = Long.MaxValue\n        var\
    \ max = Long.MinValue\n        for (i <- lst) {\n            if (i > 0 && i <\
    \ min) min = i\n            if (i < 0 && i > max) max = i\n        }\n       \
    \ if (min == Long.MaxValue) (Some(None), Some(None))\n        else if (max ==\
    \ Long.MinValue) (Some(None), Some(min))\n        else (Some(max), Some(min))",
  "        // Fill in the code here\n        val lst1 = lst.filter(x => x < 0)\n \
    \       val lst2 = lst.filter(x => x > 0)\n        if (lst1.isEmpty) {\n     \
    \       (None, Some(lst2.min))\n        } else if (lst2.isEmpty) {\n         \
    \   (Some(lst1.max), None)\n        } else {\n            (Some(lst1.max), Some(lst2.min))\n\
    \        }", "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0 && (largestNegative\
    \ == None || i > largestNegative.get)) largestNegative = Some(i)\n           \
    \ if (i > 0 && (smallestPositive == None || i < smallestPositive.get)) smallestPositive\
    \ = Some(i)\n        }\n        return (largestNegative, smallestPositive)", " \
    \       // Your code here\n        var maxNeg = None : Option[Long]\n        var\
    \ minPos = None : Option[Long]\n        for (x <- lst) {\n            if (x <\
    \ 0) {\n                if (maxNeg == None) {\n                    maxNeg = Some(x)\n\
    \                } else {\n                    if (x > maxNeg.get) {\n       \
    \                 maxNeg = Some(x)\n                    }\n                }\n\
    \            } else if (x > 0) {\n                if (minPos == None) {\n    \
    \                minPos = Some(x)\n                } else {\n                \
    \    if (x < minPos.get) {\n                        minPos = Some(x)\n       \
    \             }\n                }\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        // Fill in the code here\n        val neg = lst.filter(_\
    \ < 0)\n        val pos = lst.filter(_ > 0)\n        val negMax = if (neg.isEmpty)\
    \ None else Some(neg.max)\n        val posMin = if (pos.isEmpty) None else Some(pos.min)\n\
    \        (negMax, posMin)", "        // Fill in the code here\n        var neg\
    \ = List[Long]()\n        var pos = List[Long]()\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                neg = neg :+ i\n            } else if\
    \ (i > 0) {\n                pos = pos :+ i\n            }\n        }\n      \
    \  if (neg.isEmpty) {\n            (None, Some(pos.min))\n        } else if (pos.isEmpty)\
    \ {\n            (Some(neg.max), None)\n        } else {\n            (Some(neg.max),\
    \ Some(pos.min))\n        }", "        // Fill in the code here\n        (None,\
    \ None)", "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        var largestNegative : Option[Long] = None\n   \
    \     var smallestPositive : Option[Long] = None\n        for (i <- lst) {\n \
    \           if (i < 0) {\n                if (largestNegative == None) {\n   \
    \                 largestNegative = Some(i)\n                } else {\n      \
    \              if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var largestNegative : Option[Long] = None\n        var smallestPositive :\
    \ Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) largestNegative = Some(i)\n      \
    \          else if (i > largestNegative.get) largestNegative = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None:Option[Long]\n        var minPos = None:Option[Long]\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg\
    \ = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        (maxNeg, minPos)", "        val neg = lst.filter(_\
    \ < 0).sorted\n        val pos = lst.filter(_ > 0).sorted\n        (if (neg.isEmpty)\
    \ None else Some(neg.last), if (pos.isEmpty) None else Some(pos.head))", "   \
    \     var maxNegative : Option[Long] = None\n        var minPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (maxNegative == None) maxNegative = Some(i)\n                else if (i >\
    \ maxNegative.get) maxNegative = Some(i)\n            }\n            else if (i\
    \ > 0) {\n                if (minPositive == None) minPositive = Some(i)\n   \
    \             else if (i < minPositive.get) minPositive = Some(i)\n          \
    \  }\n        }\n        (maxNegative, minPositive)", "        // Fill in the\
    \ code here\n        val negative = lst.filter(_ < 0).sortWith(_ > _)\n      \
    \  val positive = lst.filter(_ > 0).sortWith(_ < _)\n        val largestNegative\
    \ = if (negative.isEmpty) None else Some(negative.head)\n        val smallestPositive\
    \ = if (positive.isEmpty) None else Some(positive.head)\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        //\
    \ Fill in the code here\n        var max = None:Option[Long]\n        var min\
    \ = None:Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (max == None) max = Some(i)\n                else if (i > max.get)\
    \ max = Some(i)\n            }\n            else if (i > 0) {\n              \
    \  if (min == None) min = Some(i)\n                else if (i < min.get) min =\
    \ Some(i)\n            }\n        }\n        (max, min)", "        // Fill in\
    \ the code here\n        var largestNegative : Option[Long] = None\n        var\
    \ smallestPositive : Option[Long] = None\n        for (i <- lst) {\n         \
    \   if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        var\
    \ largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) {\n                    largestNegative = Some(i)\n\
    \                } else {\n                    if (i > largestNegative.get) {\n\
    \                        largestNegative = Some(i)\n                    }\n  \
    \              }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None : Option[Long]\n        var minPos = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None) {\n\
    \                    maxNeg = Some(i)\n                } else {\n            \
    \        if (i > maxNeg.get) {\n                        maxNeg = Some(i)\n   \
    \                 }\n                }\n            } else if (i > 0) {\n    \
    \            if (minPos == None) {\n                    minPos = Some(i)\n   \
    \             } else {\n                    if (i < minPos.get) {\n          \
    \              minPos = Some(i)\n                    }\n                }\n  \
    \          }\n        }\n        (maxNeg, minPos)", "        // Fill in the implementation\
    \ here.\n        var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        val positives\
    \ = lst.filter(_ > 0)\n        val negatives = lst.filter(_ < 0)\n        val\
    \ largestNegative = negatives.maxOption\n        val smallestPositive = positives.minOption\n\
    \        (largestNegative, smallestPositive)", "        // Fill in the code here\n\
    \        (None, None)", "        // Fill in the code here\n        var min = None:Option[Long]\n\
    \        var max = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i > 0) {\n                if (min == None) {\n                    min = Some(i)\n\
    \                } else {\n                    min = Some(min.get.min(i))\n  \
    \              }\n            } else if (i < 0) {\n                if (max ==\
    \ None) {\n                    max = Some(i)\n                } else {\n     \
    \               max = Some(max.get.max(i))\n                }\n            }\n\
    \        }\n        (max, min)", "        var largestNegative : Option[Long] =\
    \ None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        (None, None)", "        // Fill in the\
    \ code here\n        return (None, None)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        val neg = lst.filter(_ < 0)\n       \
    \ val pos = lst.filter(_ > 0)\n        val negMax = if (neg.isEmpty) None else\
    \ Some(neg.max)\n        val posMin = if (pos.isEmpty) None else Some(pos.min)\n\
    \        (negMax, posMin)", "        // Fill in the code here\n        return\
    \ (None, None)", "        var largestNegative : Option[Long] = None\n        var\
    \ smallestPositive : Option[Long] = None\n        for (i <- lst) {\n         \
    \   if (i < 0) {\n                if (largestNegative == None) largestNegative\
    \ = Some(i)\n                else if (i > largestNegative.get) largestNegative\
    \ = Some(i)\n            }\n            else if (i > 0) {\n                if\
    \ (smallestPositive == None) smallestPositive = Some(i)\n                else\
    \ if (i < smallestPositive.get) smallestPositive = Some(i)\n            }\n  \
    \      }\n        return (largestNegative, smallestPositive)", "        // Fill\
    \ in the code here\n        var max = None:Option[Long]\n        var min = None:Option[Long]\n\
    \        for (i <- lst) {\n            if (i > 0) {\n                if (min ==\
    \ None) {\n                    min = Some(i)\n                } else {\n     \
    \               if (i < min.get) {\n                        min = Some(i)\n  \
    \                  }\n                }\n            } else if (i < 0) {\n   \
    \             if (max == None) {\n                    max = Some(i)\n        \
    \        } else {\n                    if (i > max.get) {\n                  \
    \      max = Some(i)\n                    }\n                }\n            }\n\
    \        }\n        (max, min)", "        // Fill in the code here\n        var\
    \ maxNegative = None : Option[Long]\n        var minPositive = None : Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (maxNegative\
    \ == None) {\n                    maxNegative = Some(i)\n                } else\
    \ {\n                    if (i > maxNegative.get) {\n                        maxNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (minPositive == None) {\n                    minPositive\
    \ = Some(i)\n                } else {\n                    if (i < minPositive.get)\
    \ {\n                        minPositive = Some(i)\n                    }\n  \
    \              }\n            }\n        }\n        (maxNegative, minPositive)",
  "        // Fill in the code here\n        var maxNeg = None : Option[Long]\n  \
    \      var minPos = None : Option[Long]\n        for (i <- lst) {\n          \
    \  if (i < 0) {\n                if (maxNeg == None) maxNeg = Some(i)\n      \
    \          else if (i > maxNeg.get) maxNeg = Some(i)\n            }\n        \
    \    else if (i > 0) {\n                if (minPos == None) minPos = Some(i)\n\
    \                else if (i < minPos.get) minPos = Some(i)\n            }\n  \
    \      }\n        return (maxNeg, minPos)", "        // Fill in the implementation\
    \ here.\n        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var neg = None:Option[Long]\n       \
    \ var pos = None:Option[Long]\n        for (i <- lst) {\n            if (i < 0)\
    \ {\n                if (neg == None) neg = Some(i)\n                else if (i\
    \ > neg.get) neg = Some(i)\n            }\n            else if (i > 0) {\n   \
    \             if (pos == None) pos = Some(i)\n                else if (i < pos.get)\
    \ pos = Some(i)\n            }\n        }\n        (neg, pos)", "        val lst2\
    \ = lst.filter(x => x != 0)\n        if (lst2.isEmpty) return (Some(None), Some(None))\n\
    \        val lst3 = lst2.filter(x => x < 0)\n        val lst4 = lst2.filter(x\
    \ => x > 0)\n        val a = if (lst3.isEmpty) Some(None) else Some(lst3.max)\n\
    \        val b = if (lst4.isEmpty) Some(None) else Some(lst4.min)\n        (a,\
    \ b)", "        // Fill in the implementation here.\n        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        (None, None)", "        // Fill in the\
    \ code here\n        (None, None)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        (None, None)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        return (None,\
    \ None)", "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        return (None,\
    \ None)", "        // Fill in the function here\n        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        var\
    \ largestNegative : Option[Long] = None\n        var smallestPositive : Option[Long]\
    \ = None\n        for (i <- lst) {\n            if (i < 0) {\n               \
    \ if (largestNegative == None) largestNegative = Some(i)\n                else\
    \ if (i > largestNegative.get) largestNegative = Some(i)\n            }\n    \
    \        else if (i > 0) {\n                if (smallestPositive == None) smallestPositive\
    \ = Some(i)\n                else if (i < smallestPositive.get) smallestPositive\
    \ = Some(i)\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        val negs = lst.filter(_ < 0)\n      \
    \  val poss = lst.filter(_ > 0)\n        (if (negs.isEmpty) None else Some(negs.max),\
    \ if (poss.isEmpty) None else Some(poss.min))", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        //\
    \ Fill in the code here\n        val neg = lst.filter(_ < 0)\n        val pos\
    \ = lst.filter(_ > 0)\n        val negMax = if (neg.isEmpty) None else Some(neg.max)\n\
    \        val posMin = if (pos.isEmpty) None else Some(pos.min)\n        (negMax,\
    \ posMin)", "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the implementation here.\n        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ {\n                    largestNegative = Some(i)\n                } else {\n\
    \                    largestNegative = Some(max(largestNegative.get, i))\n   \
    \             }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    smallestPositive = Some(min(smallestPositive.get,\
    \ i))\n                }\n            }\n        }\n        return (largestNegative,\
    \ smallestPositive)", "        // Fill in the implementation here.\n        return\
    \ null", "        // Fill in the code here\n        val neg = lst.filter(x =>\
    \ x < 0)\n        val pos = lst.filter(x => x > 0)\n        val negMax = if (neg.isEmpty)\
    \ None else Some(neg.max)\n        val posMin = if (pos.isEmpty) None else Some(pos.min)\n\
    \        (negMax, posMin)", "        // Fill in the code here\n        var maxNegative\
    \ = None : Option[Long]\n        var minPositive = None : Option[Long]\n     \
    \   for (i <- lst) {\n            if (i < 0) {\n                if (maxNegative\
    \ == None) {\n                    maxNegative = Some(i)\n                } else\
    \ {\n                    if (i > maxNegative.get) {\n                        maxNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (minPositive == None) {\n                    minPositive\
    \ = Some(i)\n                } else {\n                    if (i < minPositive.get)\
    \ {\n                        minPositive = Some(i)\n                    }\n  \
    \              }\n            }\n        }\n        (maxNegative, minPositive)",
  "        // Write your code here\n        var largestNegative = None : Option[Long]\n\
    \        var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) {\n  \
    \                  largestNegative = Some(i)\n                } else {\n     \
    \               if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        return (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n    \
    \    var minPos = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) maxNeg = Some(i)\n          \
    \      else if (i > maxNeg.get) maxNeg = Some(i)\n            }\n            else\
    \ if (i > 0) {\n                if (minPos == None) minPos = Some(i)\n       \
    \         else if (i < minPos.get) minPos = Some(i)\n            }\n        }\n\
    \        (maxNeg, minPos)", "        // Fill in the code here\n        var maxNegative\
    \ : Option[Long] = None\n        var minPositive : Option[Long] = None\n     \
    \   for (i <- lst) {\n            if (i < 0) {\n                if (maxNegative\
    \ == None) {\n                    maxNegative = Some(i)\n                } else\
    \ {\n                    if (i > maxNegative.get) {\n                        maxNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (minPositive == None) {\n                    minPositive\
    \ = Some(i)\n                } else {\n                    if (i < minPositive.get)\
    \ {\n                        minPositive = Some(i)\n                    }\n  \
    \              }\n            }\n        }\n        (maxNegative, minPositive)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n    \
    \    var minPos = None:Option[Long]\n        for (i <- lst) {\n            if\
    \ (i < 0) {\n                if (maxNeg == None) maxNeg = Some(i)\n          \
    \      else if (i > maxNeg.get) maxNeg = Some(i)\n            }\n            else\
    \ if (i > 0) {\n                if (minPos == None) minPos = Some(i)\n       \
    \         else if (i < minPos.get) minPos = Some(i)\n            }\n        }\n\
    \        (maxNeg, minPos)", "        // Fill in the code here\n        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        //\
    \ Fill in the code here\n        var maxNeg = None:Option[Long]\n        var minPos\
    \ = None:Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (maxNeg == None) maxNeg = Some(i)\n                else maxNeg\
    \ = Some(max(maxNeg.get, i))\n            }\n            else if (i > 0) {\n \
    \               if (minPos == None) minPos = Some(i)\n                else minPos\
    \ = Some(min(minPos.get, i))\n            }\n        }\n        (maxNeg, minPos)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None:Option[Long]\n        var minPos = None:Option[Long]\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg\
    \ = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        (maxNeg, minPos)", "        // Fill in the\
    \ code here\n        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None:Option[Long]\n        var minPos = None:Option[Long]\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg\
    \ = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        (maxNeg, minPos)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0 && (largestNegative == None ||\
    \ i > largestNegative.get)) largestNegative = Some(i)\n            if (i > 0 &&\
    \ (smallestPositive == None || i < smallestPositive.get)) smallestPositive = Some(i)\n\
    \        }\n        (largestNegative, smallestPositive)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    var largestNegative : Option[Long] = None\n        var smallestPositive :\
    \ Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n  \
    \              if (largestNegative == None) largestNegative = Some(i)\n      \
    \          else if (i > largestNegative.get) largestNegative = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        (None, None)",
  "        // Fill in the implementation here.\n        var largestNegative = None\
    \ : Option[Long]\n        var smallestPositive = None : Option[Long]\n       \
    \ for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        return (largestNegative, smallestPositive)", " \
    \       // Fill in the code here\n        (None, None)", "        // Fill in the\
    \ code here\n        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        val neg = lst.filter(_\
    \ < 0)\n        val pos = lst.filter(_ > 0)\n        val negMax = if (neg.isEmpty)\
    \ None else Some(neg.max)\n        val posMin = if (pos.isEmpty) None else Some(pos.min)\n\
    \        (negMax, posMin)", "        // Fill in the code here\n        var maxNeg\
    \ = None:Option[Long]\n        var minPos = None:Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None) {\n\
    \                    maxNeg = Some(i)\n                } else {\n            \
    \        maxNeg = Some(max(maxNeg.get, i))\n                }\n            } else\
    \ if (i > 0) {\n                if (minPos == None) {\n                    minPos\
    \ = Some(i)\n                } else {\n                    minPos = Some(min(minPos.get,\
    \ i))\n                }\n            }\n        }\n        (maxNeg, minPos)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        (largestNegative, smallestPositive)",
  "        val neg = lst.filter(x => x < 0)\n        val pos = lst.filter(x => x >\
    \ 0)\n        val negMax = if (neg.isEmpty) None else Some(neg.max)\n        val\
    \ posMin = if (pos.isEmpty) None else Some(pos.min)\n        (negMax, posMin)",
  "        var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        val negative\
    \ = lst.filter(_ < 0)\n        val positive = lst.filter(_ > 0)\n        val largestNegative\
    \ = if (negative.isEmpty) None else Some(negative.max)\n        val smallestPositive\
    \ = if (positive.isEmpty) None else Some(positive.min)\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        var maxNeg =\
    \ None : Option[Long]\n        var minPos = None : Option[Long]\n        for (i\
    \ <- lst) {\n            if (i < 0) {\n                if (maxNeg == None) maxNeg\
    \ = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n     \
    \       }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        (maxNeg, minPos)", "        // Fill in the\
    \ code here\n        var maxNeg = None\n        var minPos = None\n        for\
    \ (i <- lst) {\n            if (i < 0) {\n                if (maxNeg == None)\
    \ maxNeg = Some(i)\n                else if (i > maxNeg.get) maxNeg = Some(i)\n\
    \            }\n            else if (i > 0) {\n                if (minPos == None)\
    \ minPos = Some(i)\n                else if (i < minPos.get) minPos = Some(i)\n\
    \            }\n        }\n        (maxNeg, minPos)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        return (largestNegative, smallestPositive)", " \
    \       // Fill in the code here\n        var largestNegative = None : Option[Long]\n\
    \        var smallestPositive = None : Option[Long]\n        for (i <- lst) {\n\
    \            if (i < 0) {\n                if (largestNegative == None) {\n  \
    \                  largestNegative = Some(i)\n                } else {\n     \
    \               if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        return\
    \ (largestNegative, smallestPositive)", "        // Fill in the implementation\
    \ here.\n        val positive = lst.filter(_ > 0)\n        val negative = lst.filter(_\
    \ < 0)\n        val largestNegative = if (negative.isEmpty) None else Some(negative.max)\n\
    \        val smallestPositive = if (positive.isEmpty) None else Some(positive.min)\n\
    \        (largestNegative, smallestPositive)", "        val negatives = lst.filter(x\
    \ => x < 0)\n        val positives = lst.filter(x => x > 0)\n        val largestNegative\
    \ = negatives.length match {\n            case 0 => None\n            case _ =>\
    \ Some(negatives.max)\n        }\n        val smallestPositive = positives.length\
    \ match {\n            case 0 => None\n            case _ => Some(positives.min)\n\
    \        }\n        (largestNegative, smallestPositive)", "        // Fill in\
    \ the code here\n        var min = None:Option[Long]\n        var max = None:Option[Long]\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (max ==\
    \ None) max = Some(i)\n                else if (i > max.get) max = Some(i)\n \
    \           }\n            else if (i > 0) {\n                if (min == None)\
    \ min = Some(i)\n                else if (i < min.get) min = Some(i)\n       \
    \     }\n        }\n        (max, min)", "        val pos = lst.filter(x => x\
    \ > 0)\n        val neg = lst.filter(x => x < 0)\n        val posMin = if (pos.length\
    \ > 0) Some(pos.min) else None\n        val negMax = if (neg.length > 0) Some(neg.max)\
    \ else None\n        (negMax, posMin)", "        // Fill in the code here\n  \
    \      var largestNegative = None : Option[Long]\n        var smallestPositive\
    \ = None : Option[Long]\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) largestNegative = Some(i)\n    \
    \            else if (i > largestNegative.get) largestNegative = Some(i)\n   \
    \         }\n            else if (i > 0) {\n                if (smallestPositive\
    \ == None) smallestPositive = Some(i)\n                else if (i < smallestPositive.get)\
    \ smallestPositive = Some(i)\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        // Fill in the code here\n        return (None,\
    \ None)", "        // Fill in the code here\n        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    val lst1 = lst.filter(x => x < 0)\n        val lst2 = lst.filter(x => x >\
    \ 0)\n        val max1 = if (lst1.isEmpty) None else Some(lst1.max)\n        val\
    \ min2 = if (lst2.isEmpty) None else Some(lst2.min)\n        (max1, min2)", " \
    \       var largestNegative : Option[Long] = None\n        var smallestPositive\
    \ : Option[Long] = None\n        for (i <- lst) {\n            if (i < 0) {\n\
    \                if (largestNegative == None) {\n                    largestNegative\
    \ = Some(i)\n                } else {\n                    if (i > largestNegative.get)\
    \ {\n                        largestNegative = Some(i)\n                    }\n\
    \                }\n            } else if (i > 0) {\n                if (smallestPositive\
    \ == None) {\n                    smallestPositive = Some(i)\n               \
    \ } else {\n                    if (i < smallestPositive.get) {\n            \
    \            smallestPositive = Some(i)\n                    }\n             \
    \   }\n            }\n        }\n        return (largestNegative, smallestPositive)",
  "        val negative = lst.filter(x => x < 0)\n        val positive = lst.filter(x\
    \ => x > 0)\n        val largestNegative = if (negative.isEmpty) None else Some(negative.max)\n\
    \        val smallestPositive = if (positive.isEmpty) None else Some(positive.min)\n\
    \        (largestNegative, smallestPositive)", "        var largestNegative :\
    \ Option[Long] = None\n        var smallestPositive : Option[Long] = None\n  \
    \      for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here\n        (None, None)", "        // Fill in the\
    \ code here\n        return (None, None)", "        var largestNegative : Option[Long]\
    \ = None\n        var smallestPositive : Option[Long] = None\n        for (i <-\
    \ lst) {\n            if (i < 0) {\n                if (largestNegative == None)\
    \ largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    val lst2 = lst.filter(x => x != 0)\n        if (lst2.length == 0) {\n   \
    \         (Some(None), Some(None))\n        } else {\n            val lst3 = lst2.filter(x\
    \ => x < 0)\n            val lst4 = lst2.filter(x => x > 0)\n            if (lst3.length\
    \ == 0) {\n                (Some(None), Some(lst4.min))\n            } else if\
    \ (lst4.length == 0) {\n                (Some(lst3.max), Some(None))\n       \
    \     } else {\n                (Some(lst3.max), Some(lst4.min))\n           \
    \ }\n        }", "        // Fill in the code here\n        var maxNeg = None:Option[Long]\n\
    \        var minPos = None:Option[Long]\n        for (i <- lst) {\n          \
    \  if (i < 0) {\n                if (maxNeg == None) {\n                    maxNeg\
    \ = Some(i)\n                } else {\n                    if (i > maxNeg.get)\
    \ {\n                        maxNeg = Some(i)\n                    }\n       \
    \         }\n            } else if (i > 0) {\n                if (minPos == None)\
    \ {\n                    minPos = Some(i)\n                } else {\n        \
    \            if (i < minPos.get) {\n                        minPos = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (maxNeg,\
    \ minPos)", "        // Fill in the code here\n        (None, None)", "      \
    \  val negative = lst.filter(_ < 0).sortWith(_ > _)\n        val positive = lst.filter(_\
    \ > 0).sortWith(_ < _)\n        (if (negative.isEmpty) None else Some(negative.head),\
    \ if (positive.isEmpty) None else Some(positive.head))", "        // Fill in the\
    \ code here\n        return (None, None)", "        // Fill in the code here\n\
    \        return (None, None)", "        // Fill in the code here\n        return\
    \ (None, None)", "        var largestNegative : Option[Long] = None\n        var\
    \ smallestPositive : Option[Long] = None\n        for (i <- lst) {\n         \
    \   if (i < 0) {\n                if (largestNegative == None) {\n           \
    \         largestNegative = Some(i)\n                } else {\n              \
    \      if (i > largestNegative.get) {\n                        largestNegative\
    \ = Some(i)\n                    }\n                }\n            } else if (i\
    \ > 0) {\n                if (smallestPositive == None) {\n                  \
    \  smallestPositive = Some(i)\n                } else {\n                    if\
    \ (i < smallestPositive.get) {\n                        smallestPositive = Some(i)\n\
    \                    }\n                }\n            }\n        }\n        (largestNegative,\
    \ smallestPositive)", "        var largest : Option[Long] = None\n        var\
    \ smallest : Option[Long] = None\n        for (i <- lst) {\n            if (i\
    \ < 0) {\n                if (largest == None) largest = Some(i)\n           \
    \     else largest = Some(max(largest.get, i))\n            }\n            else\
    \ if (i > 0) {\n                if (smallest == None) smallest = Some(i)\n   \
    \             else smallest = Some(min(smallest.get, i))\n            }\n    \
    \    }\n        (largest, smallest)", "        // Fill in the code here\n    \
    \    return (None, None)", "        // Fill in the code here\n        var largestNegative\
    \ = None:Option[Long]\n        var smallestPositive = None:Option[Long]\n    \
    \    for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) {\n                    largestNegative = Some(i)\n                }\
    \ else {\n                    if (i > largestNegative.get) {\n               \
    \         largestNegative = Some(i)\n                    }\n                }\n\
    \            } else if (i > 0) {\n                if (smallestPositive == None)\
    \ {\n                    smallestPositive = Some(i)\n                } else {\n\
    \                    if (i < smallestPositive.get) {\n                       \
    \ smallestPositive = Some(i)\n                    }\n                }\n     \
    \       }\n        }\n        (largestNegative, smallestPositive)", "        //\
    \ Fill in the code here\n        var min = None:Option[Long]\n        var max\
    \ = None:Option[Long]\n        for (i <- lst) {\n            if (i > 0) {\n  \
    \              if (min == None) min = Some(i)\n                else if (i < min.get)\
    \ min = Some(i)\n            }\n            else if (i < 0) {\n              \
    \  if (max == None) max = Some(i)\n                else if (i > max.get) max =\
    \ Some(i)\n            }\n        }\n        (max, min)", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)", "    \
    \    // Fill in the code here.\n        // You can use the following functions:\n\
    \        // - lst.filter(...)\n        // - lst.min(...)\n        // - lst.max(...)\n\
    \        // - lst.isEmpty(...)\n        // - lst.sortWith(...)\n        // - lst.reverse(...)\n\
    \        // - lst.head(...)\n        // - lst.tail(...)\n        // - lst.take(...)\n\
    \        // - lst.drop(...)\n        // - lst.count(...)\n        // - lst.exists(...)\n\
    \        // - lst.forall(...)\n        // - lst.foreach(...)\n        // - lst.map(...)\n\
    \        // - lst.flatMap(...)\n        // - lst.sum(...)\n        // - lst.product(...)\n\
    \        // - lst.reduce(...)\n        // - lst.reduceLeft(...)\n        // -\
    \ lst.reduceRight(...)\n        // - lst.fold(...)\n        // - lst.foldLeft(...)\n\
    \        // - lst.foldRight(...)\n        // - lst.zip(...)\n        // - lst.zipWithIndex(...)\n\
    \        // - lst.zipAll(...)\n        // - lst.zipWithLongestLength(...)\n  \
    \      // - lst.unzip(...)\n        // - lst.unzip3(...)\n        // - lst.groupBy(...)\n\
    \        // - lst.partition(...)\n        // - lst.span(...)\n        // - lst.splitAt(...)\n\
    \        // - lst.takeWhile(...)\n        // - lst.dropWhile(...)\n        //\
    \ - lst.slice(...)\n        // - lst.sliding(...)\n        // - lst.grouped(...)\n\
    \        // - lst.mkString(...)\n        // - lst.mkString(..., ...)\n       \
    \ // - lst.mkString(..., ..., ...)\n        // - lst.addString(...)\n        //\
    \ - lst.addString(..., ...)\n        // - lst.", "        var largestNegative\
    \ : Option[Long] = None\n        var smallestPositive : Option[Long] = None\n\
    \        for (i <- lst) {\n            if (i < 0) {\n                if (largestNegative\
    \ == None) largestNegative = Some(i)\n                else if (i > largestNegative.get)\
    \ largestNegative = Some(i)\n            }\n            else if (i > 0) {\n  \
    \              if (smallestPositive == None) smallestPositive = Some(i)\n    \
    \            else if (i < smallestPositive.get) smallestPositive = Some(i)\n \
    \           }\n        }\n        (largestNegative, smallestPositive)"]
stop_tokens:
- "\n    }\n"
