name: HumanEval_6_parse_nested_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n    // For each of the group, output the deepest\
  \ level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of\
  \ nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((()))\
  \ () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n\
  \    def parseNestedParens(paren_string : String) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
  (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
  \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
  )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
completions: ["        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (c == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      result += max_level\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var result = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var max_depth = 0\n            var current_depth\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               current_depth += 1\n                    max_depth = max(max_depth,\
    \ current_depth)\n                } else if (c == ')') {\n                   \
    \ current_depth -= 1\n                }\n            }\n            result = result\
    \ :+ max_depth\n        }\n        return result", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_level = 0\n         \
    \   var level = 0\n            for (c <- group) {\n                if (c == '(')\
    \ {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (c <- group) {\n                if (c == '(') level += 1\n  \
    \              else if (c == ')') level -= 1\n                if (level > max_level)\
    \ max_level = level\n            }\n            paren_levels += max_level\n  \
    \      }\n        paren_levels.toList", "        paren_string.split(\" \").map(x\
    \ => {\n            var max_nesting = 0\n            var current_nesting = 0\n\
    \            for (c <- x) {\n                if (c == '(') {\n               \
    \     current_nesting += 1\n                    max_nesting = max(max_nesting,\
    \ current_nesting)\n                } else if (c == ')') {\n                 \
    \   current_nesting -= 1\n                }\n            }\n            max_nesting\n\
    \        }).toList.map(x => x.toLong)", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]()\n        for (group\
    \ <- paren_groups) {\n            var max_nesting_level = 0\n            var nesting_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    nesting_level += 1\n                    if (nesting_level\
    \ > max_nesting_level) {\n                        max_nesting_level = nesting_level\n\
    \                    }\n                } else if (paren == ')') {\n         \
    \           nesting_level -= 1\n                }\n            }\n           \
    \ max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (x(i) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            max_level\n        })\n\
    \        paren_levels.toList.map(x => x.toLong)", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_level = 0\n         \
    \   var level = 0\n            for (c <- group) {\n                if (c == '(')\
    \ {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val parens = paren_string.split(\" \")\n        val max_nesting = parens.map(x\
    \ => {\n            var max_level = 0\n            var level = 0\n           \
    \ for (i <- 0 until x.length) {\n                if (x(i) == '(') {\n        \
    \            level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (x(i) == ')') {\n                    level -= 1\n \
    \               }\n            }\n            max_level\n        })\n        max_nesting.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (c == ')') {\n          \
    \          depth -= 1\n                }\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (ch <- group) {\n                if (ch == '(') {\n               \
    \     current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (ch == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.toList.foldLeft(0l.toLong,\
    \ 0l.toLong)((acc, c) => {\n            if (c == '(') (acc._1 + 1, max(acc._1\
    \ + 1, acc._2))\n            else if (c == ')') (acc._1 - 1, acc._2)\n       \
    \     else (acc._1, acc._2)\n        })._2)\n        paren_levels.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') {\n   \
    \                 level += 1\n                    if (level > max_level) max_level\
    \ = level\n                }\n                else if (paren == ')') {\n     \
    \               level -= 1\n                }\n            }\n            paren_levels\
    \ += max_level\n        }\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var result = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var max_depth = 0\n            var depth\
    \ = 0\n            for (c <- group) {\n                if (c == '(') depth +=\
    \ 1\n                else if (c == ')') depth -= 1\n                if (depth\
    \ > max_depth) max_depth = depth\n            }\n            result = result :+\
    \ max_depth\n        }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var paren_levels = List[Long]()\n        for (i <- 0 until paren_groups.length)\
    \ {\n            var paren_level = 0l\n            var max_paren_level = 0l\n\
    \            for (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') {\n                    paren_level += 1\n                    if (paren_level\
    \ > max_paren_level) max_paren_level = paren_level\n                }\n      \
    \          else if (paren_groups(i)(j) == ')') {\n                    paren_level\
    \ -= 1\n                }\n            }\n            paren_levels = paren_levels\
    \ :+ max_paren_level\n        }\n        return paren_levels", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_level = 0\n       \
    \     var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        paren_string.split(\" \").map(s => {\n\
    \            var max_depth = 0\n            var cur_depth = 0\n            for\
    \ (c <- s) {\n                if (c == '(') {\n                    cur_depth +=\
    \ 1\n                    max_depth = max(max_depth, cur_depth)\n             \
    \   } else if (c == ')') {\n                    cur_depth -= 1\n             \
    \   }\n            }\n            max_depth\n        }).toList.map(x => x.toLong)",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x.toList, 0, 0)).toList\n  \
    \      paren_levels"]
stop_tokens:
- "\n    }\n"
