name: HumanEval_6_parse_nested_parens
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Input to this function is a string represented multiple groups for nested\
  \ parentheses separated by spaces.\n    // For each of the group, output the deepest\
  \ level of nesting of parentheses.\n    // E.g. (()()) has maximum two levels of\
  \ nesting while ((())) has three.\n    // >>> parseNestedParens((\"(()()) ((()))\
  \ () ((())()())\"))\n    // (List[Long](2l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))\n\
  \    def parseNestedParens(paren_string : String) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(parseNestedParens((\"\
  (()()) ((())) () ((())()())\")).equals((List[Long](2l.toLong, 3l.toLong, 1l.toLong,\
  \ 3l.toLong))));\n    assert(parseNestedParens((\"() (()) ((())) (((())))\")).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(parseNestedParens((\"(()(())((())))\"\
  )).equals((List[Long](4l.toLong))));\n    }\n\n}\n"
completions: ["        val paren_groups = paren_string.split(\" \")\n        val result\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ max_level = 0\n            var level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (c == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      result += max_level\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var result = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var max_depth = 0\n            var current_depth\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               current_depth += 1\n                    max_depth = max(max_depth,\
    \ current_depth)\n                } else if (c == ')') {\n                   \
    \ current_depth -= 1\n                }\n            }\n            result = result\
    \ :+ max_depth\n        }\n        return result", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_level = 0\n         \
    \   var level = 0\n            for (c <- group) {\n                if (c == '(')\
    \ {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (c <- group) {\n                if (c == '(') level += 1\n  \
    \              else if (c == ')') level -= 1\n                if (level > max_level)\
    \ max_level = level\n            }\n            paren_levels += max_level\n  \
    \      }\n        paren_levels.toList", "        paren_string.split(\" \").map(x\
    \ => {\n            var max_nesting = 0\n            var current_nesting = 0\n\
    \            for (c <- x) {\n                if (c == '(') {\n               \
    \     current_nesting += 1\n                    max_nesting = max(max_nesting,\
    \ current_nesting)\n                } else if (c == ')') {\n                 \
    \   current_nesting -= 1\n                }\n            }\n            max_nesting\n\
    \        }).toList.map(x => x.toLong)", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]()\n        for (group\
    \ <- paren_groups) {\n            var max_nesting_level = 0\n            var nesting_level\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    nesting_level += 1\n                    if (nesting_level\
    \ > max_nesting_level) {\n                        max_nesting_level = nesting_level\n\
    \                    }\n                } else if (paren == ')') {\n         \
    \           nesting_level -= 1\n                }\n            }\n           \
    \ max_nesting_levels += max_nesting_level\n        }\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (x(i) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            max_level\n        })\n\
    \        paren_levels.toList.map(x => x.toLong)", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_level = 0\n         \
    \   var level = 0\n            for (c <- group) {\n                if (c == '(')\
    \ {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val parens = paren_string.split(\" \")\n        val max_nesting = parens.map(x\
    \ => {\n            var max_level = 0\n            var level = 0\n           \
    \ for (i <- 0 until x.length) {\n                if (x(i) == '(') {\n        \
    \            level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (x(i) == ')') {\n                    level -= 1\n \
    \               }\n            }\n            max_level\n        })\n        max_nesting.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    depth += 1\n                    max_depth\
    \ = max(max_depth, depth)\n                } else if (c == ')') {\n          \
    \          depth -= 1\n                }\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (ch <- group) {\n                if (ch == '(') {\n               \
    \     current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (ch == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.toList.foldLeft(0l.toLong,\
    \ 0l.toLong)((acc, c) => {\n            if (c == '(') (acc._1 + 1, max(acc._1\
    \ + 1, acc._2))\n            else if (c == ')') (acc._1 - 1, acc._2)\n       \
    \     else (acc._1, acc._2)\n        })._2)\n        paren_levels.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (paren <- group) {\n                if (paren == '(') {\n   \
    \                 level += 1\n                    if (level > max_level) max_level\
    \ = level\n                }\n                else if (paren == ')') {\n     \
    \               level -= 1\n                }\n            }\n            paren_levels\
    \ += max_level\n        }\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var result = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var max_depth = 0\n            var depth\
    \ = 0\n            for (c <- group) {\n                if (c == '(') depth +=\
    \ 1\n                else if (c == ')') depth -= 1\n                if (depth\
    \ > max_depth) max_depth = depth\n            }\n            result = result :+\
    \ max_depth\n        }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var paren_levels = List[Long]()\n        for (i <- 0 until paren_groups.length)\
    \ {\n            var paren_level = 0l\n            var max_paren_level = 0l\n\
    \            for (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') {\n                    paren_level += 1\n                    if (paren_level\
    \ > max_paren_level) max_paren_level = paren_level\n                }\n      \
    \          else if (paren_groups(i)(j) == ')') {\n                    paren_level\
    \ -= 1\n                }\n            }\n            paren_levels = paren_levels\
    \ :+ max_paren_level\n        }\n        return paren_levels", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_level = 0\n       \
    \     var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        paren_string.split(\" \").map(s => {\n\
    \            var max_depth = 0\n            var cur_depth = 0\n            for\
    \ (c <- s) {\n                if (c == '(') {\n                    cur_depth +=\
    \ 1\n                    max_depth = max(max_depth, cur_depth)\n             \
    \   } else if (c == ')') {\n                    cur_depth -= 1\n             \
    \   }\n            }\n            max_depth\n        }).toList.map(x => x.toLong)",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x.toList, 0, 0)).toList\n  \
    \      paren_levels", "        val paren_groups = paren_string.split(\" \")\n\
    \        val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (char <- group) {\n                if (char == '(') {\n                    level\
    \ += 1\n                    if (level > max_level) max_level = level\n       \
    \         }\n                else if (char == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (c <- group) {\n                if (c == '(') {\n           \
    \         level += 1\n                    if (level > max_level) max_level = level\n\
    \                }\n                else if (c == ')') {\n                   \
    \ level -= 1\n                }\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(group => {\n            var\
    \ level = 0\n            var max_level = 0\n            for (c <- group) {\n \
    \               if (c == '(') {\n                    level += 1\n            \
    \        max_level = max(max_level, level)\n                } else if (c == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      max_level\n        })\n        paren_levels.toList.map(x => x.toLong)",
  "        val paren_list = paren_string.split(\" \").toList\n        val max_nesting_list\
    \ = paren_list.map(x => {\n            var max_nesting = 0\n            var nesting\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') nesting += 1\n                else if (x(i) == ')') nesting -= 1\n    \
    \            if (nesting > max_nesting) max_nesting = nesting\n            }\n\
    \            max_nesting\n        })\n        max_nesting_list", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val max_nesting_levels = paren_groups.map(x\
    \ => x.count(y => y == '(') - x.count(y => y == ')'))\n        max_nesting_levels.map(x\
    \ => if (x < 0) 0 else x).toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        var result = List[Long]()\n        var max_nesting = 0\n        var current_nesting\
    \ = 0\n        for (c <- paren_string) {\n            if (c == '(') {\n      \
    \          current_nesting += 1\n                max_nesting = max(max_nesting,\
    \ current_nesting)\n            } else if (c == ')') {\n                current_nesting\
    \ -= 1\n            } else if (c == ' ') {\n                result = result :+\
    \ max_nesting\n                max_nesting = 0\n                current_nesting\
    \ = 0\n            }\n        }\n        result = result :+ max_nesting\n    \
    \    return result", "        val paren_groups = paren_string.split(\" \")\n \
    \       val paren_levels = paren_groups.map(x => x.toList.foldLeft(0l)((acc, x)\
    \ => if (x == '(') acc + 1 else acc - 1)).toList\n        val paren_max_levels\
    \ = paren_levels.map(x => x.abs)\n        paren_max_levels", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var result = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var max_level = 0\n            var level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            result = result :+ max_level\n    \
    \    }\n        result", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = paren_groups.map(x => x.toList.foldLeft(List[Long](0l.toLong))((acc,\
    \ c) => {\n            if (c == '(') {\n                acc.head + 1l.toLong ::\
    \ acc\n            } else {\n                acc.head - 1l.toLong :: acc\n   \
    \         }\n        }).reverse.tail)\n        paren_levels.map(x => x.max).toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val parens = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (paren <- parens)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- paren) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var\
    \ level = 0l\n            var max_level = 0l\n            for (c <- group) {\n\
    \                if (c == '(') {\n                    level += 1\n           \
    \         if (level > max_level) max_level = level\n                }\n      \
    \          else if (c == ')') {\n                    level -= 1\n            \
    \    }\n            }\n            paren_levels += max_level\n        }\n    \
    \    paren_levels.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        var result = List[Long]()\n        for (paren_group <- paren_string.split(\"\
    \ \")) {\n            var current_level = 0\n            var max_level = 0\n \
    \           for (paren <- paren_group) {\n                if (paren == '(') current_level\
    \ += 1\n                else if (paren == ')') current_level -= 1\n          \
    \      if (current_level > max_level) max_level = current_level\n            }\n\
    \            result = result :+ max_level\n        }\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (i <- 0 until group.length) {\n                if (group(i) == '(') {\n    \
    \                depth += 1\n                    max_depth = max(max_depth, depth)\n\
    \                } else if (group(i) == ')') {\n                    depth -= 1\n\
    \                }\n            }\n            result += max_depth\n        }\n\
    \        result.toList", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = paren_groups.map(x => x.toList.foldLeft(0l)((acc,\
    \ x) => if (x == '(') acc + 1 else acc - 1)).toList\n        val max_levels =\
    \ paren_levels.map(x => if (x < 0) 0 else x)\n        max_levels", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var current_level = 0\n            for (c <- group) {\n               \
    \ if (c == '(') {\n                    current_level += 1\n                  \
    \  max_level = max(max_level, current_level)\n                } else if (c ==\
    \ ')') {\n                    current_level -= 1\n                }\n        \
    \    }\n            result += max_level\n        }\n        result.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') level += 1\n                else if (c == ')') level -= 1\n\
    \                max_level = max(max_level, level)\n            }\n          \
    \  result += max_level\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val max_nesting_levels = new ListBuffer[Long]()\n\
    \        for (paren_group <- paren_groups) {\n            var max_nesting_level\
    \ = 0\n            var current_nesting_level = 0\n            for (paren <- paren_group)\
    \ {\n                if (paren == '(') {\n                    current_nesting_level\
    \ += 1\n                    if (current_nesting_level > max_nesting_level) {\n\
    \                        max_nesting_level = current_nesting_level\n         \
    \           }\n                } else if (paren == ')') {\n                  \
    \  current_nesting_level -= 1\n                }\n            }\n            max_nesting_levels\
    \ += max_nesting_level\n        }\n        max_nesting_levels.toList", "     \
    \   val paren_groups = paren_string.split(\" \")\n        val max_levels = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var level\
    \ = 0\n            var max_level = 0\n            for (c <- group) {\n       \
    \         if (c == '(') {\n                    level += 1\n                  \
    \  if (level > max_level) max_level = level\n                }\n             \
    \   else if (c == ')') {\n                    level -= 1\n                }\n\
    \            }\n            max_levels += max_level\n        }\n        max_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.count(y => y == '(')\
    \ - x.count(y => y == ')'))\n        val max_levels = paren_levels.map(x => if\
    \ (x < 0) 0 else x)\n        max_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_list = new ListBuffer[Long]()\n        for (group\
    \ <- paren_groups) {\n            var max_nesting = 0\n            var current_nesting\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') {\n\
    \                    current_nesting += 1\n                    if (current_nesting\
    \ > max_nesting) max_nesting = current_nesting\n                }\n          \
    \      else if (paren == ')') {\n                    current_nesting -= 1\n  \
    \              }\n            }\n            max_nesting_list += max_nesting\n\
    \        }\n        max_nesting_list.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = paren_groups.map(paren_group => {\n            var\
    \ max_level = 0\n            var level = 0\n            for (i <- 0 until paren_group.length)\
    \ {\n                if (paren_group(i) == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (paren_group(i) == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            max_level\n        }).toList\n        result",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(group => {\n            var max_level = 0\n            var\
    \ current_level = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') {\n                    current_level += 1\n                    max_level\
    \ = max(max_level, current_level)\n                } else if (paren == ')') {\n\
    \                    current_level -= 1\n                }\n            }\n  \
    \          max_level\n        })\n        max_nesting_levels.toList", "      \
    \  val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var current_depth = 0\n            for (c <- group) {\n               \
    \ if (c == '(') {\n                    current_depth += 1\n                  \
    \  max_depth = max(max_depth, current_depth)\n                } else if (c ==\
    \ ')') {\n                    current_depth -= 1\n                }\n        \
    \    }\n            result = result :+ max_depth\n        }\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (i <- 0 until x.length) {\n                if (x(i) ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (x(i) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            max_level\n        })\n\
    \        paren_levels.toList.map(x => x.toLong)", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (i <- 0 until paren_groups.length) {\n            val paren_group =\
    \ paren_groups(i)\n            var max_nesting = 0\n            var current_nesting\
    \ = 0\n            for (j <- 0 until paren_group.length) {\n                if\
    \ (paren_group(j) == '(') {\n                    current_nesting += 1\n      \
    \              max_nesting = max(max_nesting, current_nesting)\n             \
    \   } else if (paren_group(j) == ')') {\n                    current_nesting -=\
    \ 1\n                }\n            }\n            result += max_nesting\n   \
    \     }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.count(y => y == '(')\
    \ - x.count(y => y == ')'))\n        val max_level = paren_levels.max\n      \
    \  val max_level_index = paren_levels.indexOf(max_level)\n        val max_level_paren_group\
    \ = paren_groups(max_level_index)\n        val max_level_paren_group_levels =\
    \ max_level_paren_group.map(x => if (x == '(') 1 else -1).scanLeft(0)(_ + _).toList\n\
    \        val max_level_paren_group_max_level = max_level_paren_group_levels.max\n\
    \        val max_level_paren_group_max_level_index = max_level_paren_group_levels.indexOf(max_level_paren_group_max_level)\n\
    \        val max_level_paren_group_max_level_paren_group = max_level_paren_group.substring(0,\
    \ max_level_paren_group_max_level_index + 1)\n        val max_level_paren_group_max_level_paren_group_levels\
    \ = max_level_paren_group_max_level_paren_group.map(x => if (x == '(') 1 else\
    \ -1).scanLeft(0)(_ + _).toList\n        val max_level_paren_group_max_level_paren_group_max_level\
    \ = max_level_paren_group_max_level_paren_group_levels.max\n        val max_level_paren_group_max_level_paren_group_max_level_index\
    \ = max_level_paren_group_max_level_paren_group_levels.indexOf(max_level_paren_group_max_level_paren_group_max_level)\n\
    \        val max_level_paren_group_max_level_paren_group_max_level_paren_group\
    \ = max_level_paren_group_max_level_paren_group.substring(0, max_level_paren_group_max_level_paren_group",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.toList.map(y => if (y == '(') 1 else -1).scanLeft(0)(_\
    \ + _).max)\n        paren_levels.toList.map(x => x.toLong)", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_level = 0\n       \
    \     var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        var result = List[Long]()\n        val\
    \ paren_groups = paren_string.split(\" \")\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.foldLeft(0l)((acc, c)\
    \ => if (c == '(') acc + 1 else acc - 1))\n        val max_levels = paren_levels.map(x\
    \ => abs(x))\n        max_levels.toList", "        val parens = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (paren <- parens)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- paren) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                if (depth > max_depth) max_depth = depth\n            }\n   \
    \         result += max_depth\n        }\n        result.toList", "        //\
    \ Split the string into groups\n        val groups = paren_string.split(\" \"\
    )\n        // For each group, find the maximum level of nesting\n        val max_nesting\
    \ = groups.map(group => {\n            var max_nesting = 0\n            var current_nesting\
    \ = 0\n            for (i <- 0 until group.length) {\n                if (group(i)\
    \ == '(') {\n                    current_nesting += 1\n                    max_nesting\
    \ = max(max_nesting, current_nesting)\n                } else if (group(i) ==\
    \ ')') {\n                    current_nesting -= 1\n                }\n      \
    \      }\n            max_nesting\n        })\n        // Return the maximum level\
    \ of nesting for each group\n        max_nesting.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x =>\
    \ x.toList.foldLeft(0l)((acc, c) => if (c == '(') acc + 1 else if (c == ')') acc\
    \ - 1 else acc)).toList\n        paren_levels", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (paren <- group) {\n                if (paren == '(') {\n         \
    \           current_level += 1\n                    max_level = max(max_level,\
    \ current_level)\n                } else if (paren == ')') {\n               \
    \     current_level -= 1\n                }\n            }\n            result\
    \ += max_level\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        var result = List[Long]()\n        for (group\
    \ <- paren_groups) {\n            var max_level = 0\n            var level = 0\n\
    \            for (char <- group) {\n                if (char == '(') {\n     \
    \               level += 1\n                    if (level > max_level) max_level\
    \ = level\n                }\n                else if (char == ')') {\n      \
    \              level -= 1\n                }\n            }\n            result\
    \ = result :+ max_level\n        }\n        return result", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n     \
    \   for (group <- paren_groups) {\n            var max_level = 0\n           \
    \ var level = 0\n            for (c <- group) {\n                if (c == '(')\
    \ {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.count(y => y == '(')\
    \ - x.count(y => y == ')'))\n        val max_levels = paren_levels.map(x => if\
    \ (x < 0) 0 else x)\n        max_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (ch <- group) {\n                if (ch == '(') depth += 1\n               \
    \ else if (ch == ')') depth -= 1\n                if (depth > max_depth) max_depth\
    \ = depth\n            }\n            result += max_depth\n        }\n       \
    \ result.toList", "        val paren_groups = paren_string.split(\" \")\n    \
    \    val paren_levels = paren_groups.map(x => x.toList.foldLeft(0, 0)((acc, y)\
    \ => {\n            if (y == '(') (acc._1 + 1, max(acc._1 + 1, acc._2))\n    \
    \        else if (y == ')') (acc._1 - 1, acc._2)\n            else acc\n     \
    \   })._2)\n        paren_levels.map(x => x.toLong).toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') level += 1\n                else if (c == ')') level -= 1\n           \
    \     if (level > max_level) max_level = level\n            }\n            paren_levels\
    \ += max_level\n        }\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_level = 0\n       \
    \     var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (paren_group\
    \ <- paren_groups) {\n            var max_level = 0l\n            var level =\
    \ 0l\n            for (paren <- paren_group) {\n                if (paren == '(')\
    \ {\n                    level += 1\n                    if (level > max_level)\
    \ max_level = level\n                }\n                else if (paren == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      paren_levels += max_level\n        }\n        paren_levels.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n          \
    \  var max_level = 0\n            var level = 0\n            for (c <- paren_group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result += max_level\n        }\n        result.toList", "       \
    \ val paren_groups = paren_string.split(\" \")\n        val paren_levels = new\
    \ ListBuffer[Long]()\n        for (paren_group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- paren_group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 if (level > max_level) max_level = level\n                }\n\
    \                else if (paren == ')') {\n                    level -= 1\n  \
    \              }\n            }\n            paren_levels += max_level\n     \
    \   }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result = result :+ max_depth\n        }\n\
    \        return result", "        val paren_groups = paren_string.split(\" \"\
    )\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var cur_level = 0\n          \
    \  for (c <- group) {\n                if (c == '(') {\n                    cur_level\
    \ += 1\n                    max_level = max(max_level, cur_level)\n          \
    \      } else if (c == ')') {\n                    cur_level -= 1\n          \
    \      }\n            }\n            result += max_level\n        }\n        result.toList",
  "        var paren_list = paren_string.split(\" \").toList\n        var result =\
    \ List[Long]()\n        for (paren <- paren_list) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (i <- 0 until paren.length)\
    \ {\n                if (paren(i) == '(') depth += 1\n                else depth\
    \ -= 1\n                max_depth = max(max_depth, depth)\n            }\n   \
    \         result = result :+ max_depth\n        }\n        return result", " \
    \       // Split the string into groups of parentheses separated by spaces.\n\
    \        val paren_groups = paren_string.split(\" \")\n        // For each group,\
    \ find the maximum depth of nesting of parentheses.\n        paren_groups.map(group\
    \ => {\n            // Keep track of the maximum depth of nesting of parentheses.\n\
    \            var max_depth = 0\n            // Keep track of the current depth\
    \ of nesting of parentheses.\n            var current_depth = 0\n            //\
    \ Iterate through each character in the group.\n            for (c <- group) {\n\
    \                // If the character is an opening parenthesis, increment the\
    \ current depth of nesting.\n                if (c == '(') {\n               \
    \     current_depth += 1\n                    // Update the maximum depth of nesting\
    \ if the current depth is greater.\n                    if (current_depth > max_depth)\
    \ max_depth = current_depth\n                }\n                // If the character\
    \ is a closing parenthesis, decrement the current depth of nesting.\n        \
    \        else if (c == ')') current_depth -= 1\n            }\n            //\
    \ Return the maximum depth of nesting.\n            max_depth\n        }).toList",
  "        var max_depth = 0\n        var cur_depth = 0\n        var result = List[Long]()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    cur_depth += 1\n                max_depth = max(max_depth, cur_depth)\n \
    \           } else if (c == ')') {\n                cur_depth -= 1\n         \
    \   } else if (c == ' ') {\n                result = result :+ max_depth\n   \
    \             max_depth = 0\n                cur_depth = 0\n            }\n  \
    \      }\n        result", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    if (level > max_level) max_level = level\n          \
    \      }\n                else if (c == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.toList.map(y => if (y\
    \ == '(') 1 else -1).scanLeft(0)(_ + _).max)\n        paren_levels.toList.map(x\
    \ => x.toLong)", "        val paren_groups = paren_string.split(\" \")\n     \
    \   var result = List[Long]()\n        for (group <- paren_groups) {\n       \
    \     var max_level = 0\n            var level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             max_level = max(max_level, level)\n                } else if (c\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result = result :+ max_level\n        }\n        result", "     \
    \   val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (i <- 0 until paren_groups.length) {\n            var max_depth =\
    \ 0\n            var depth = 0\n            for (j <- 0 until paren_groups(i).length)\
    \ {\n                if (paren_groups(i)(j) == '(') depth += 1\n             \
    \   else if (paren_groups(i)(j) == ')') depth -= 1\n                if (depth\
    \ > max_depth) max_depth = depth\n            }\n            result = result :+\
    \ max_depth\n        }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.count(y => y == '(')\
    \ - x.count(y => y == ')'))\n        val paren_nesting = paren_groups.map(x =>\
    \ x.count(y => y == '(') + x.count(y => y == ')'))\n        val paren_max_nesting\
    \ = paren_nesting.map(x => x / 2)\n        val paren_levels_max_nesting = paren_levels.zip(paren_max_nesting).map(x\
    \ => x._1 + x._2)\n        paren_levels_max_nesting.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x =>\
    \ parseNestedParensHelper(x))\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var result = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var max_level = 0\n            var level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            result = result :+ max_level\n    \
    \    }\n        result", "        val paren_groups = paren_string.split(\" \"\
    )\n        val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (paren <- group) {\n                if (paren == '(') {\n                  \
    \  level += 1\n                    if (level > max_level) max_level = level\n\
    \                }\n                else if (paren == ')') {\n               \
    \     level -= 1\n                }\n            }\n            paren_levels +=\
    \ max_level\n        }\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var max_depth = 0\n        var depth =\
    \ 0\n        var result = List[Long]()\n        for (group <- paren_groups) {\n\
    \            for (c <- group) {\n                if (c == '(') {\n           \
    \         depth += 1\n                    max_depth = max(max_depth, depth)\n\
    \                } else if (c == ')') {\n                    depth -= 1\n    \
    \            }\n            }\n            result = result :+ max_depth.toLong\n\
    \            max_depth = 0\n            depth = 0\n        }\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val max_levels = paren_levels.map(x => if (x < 0) 0 else x)\n        max_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        var result = List[Long]()\n        for (paren_group <- paren_string.split(\"\
    \ \")) {\n            var max_depth = 0\n            var depth = 0\n         \
    \   for (c <- paren_group) {\n                if (c == '(') depth += 1\n     \
    \           else if (c == ')') depth -= 1\n                if (depth > max_depth)\
    \ max_depth = depth\n            }\n            result = result :+ max_depth\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (paren <- parens)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- paren) {\n                if (c == '(') {\n                    depth +=\
    \ 1\n                    max_depth = max(max_depth, depth)\n                }\
    \ else if (c == ')') {\n                    depth -= 1\n                }\n  \
    \          }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val paren_levels_with_index = paren_levels.zipWithIndex\n        val paren_levels_with_index_filtered\
    \ = paren_levels_with_index.filter(x => x._1 >= 0)\n        val paren_levels_with_index_filtered_sorted\
    \ = paren_levels_with_index_filtered.sortBy(x => x._1)\n        val paren_levels_with_index_filtered_sorted_grouped\
    \ = paren_levels_with_index_filtered_sorted.groupBy(x => x._1)\n        val paren_levels_with_index_filtered_sorted_grouped_map\
    \ = paren_levels_with_index_filtered_sorted_grouped.map(x => x._2.map(y => y._2))\n\
    \        val paren_levels_with_index_filtered_sorted_grouped_map_sorted = paren_levels_with_index_filtered_sorted_grouped_map.toList.sortBy(x\
    \ => x.head)\n        val paren_levels_with_index_filtered_sorted_grouped_map_sorted_flattened\
    \ = paren_levels_with_index_filtered_sorted_grouped_map_sorted.flatten\n     \
    \   val paren_levels_with_index_filtered_sorted_grouped_map_sorted_flattened_map\
    \ = paren_levels_with_index_filtered_sorted_grouped_map_sorted_flattened.map(x\
    \ => paren_levels(x))\n        paren_levels_with_index_filtered_sorted_grouped_map_sorted_flattened_map",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(group => {\n            var level = 0\n            var max_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               level += 1\n                    max_level = max(max_level, level)\n\
    \                } else if (c == ')') {\n                    level -= 1\n    \
    \            }\n            }\n            max_level\n        })\n        paren_levels.toList.map(x\
    \ => x.toLong)", "        val paren_groups = paren_string.split(\" \")\n     \
    \   val result = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n\
    \            var max_depth = 0\n            var depth = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') depth += 1\n                else\
    \ depth -= 1\n                max_depth = max(max_depth, depth)\n            }\n\
    \            result += max_depth\n        }\n        result.toList", "       \
    \ val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var current_depth = 0\n            for (c <- group) {\n               \
    \ if (c == '(') {\n                    current_depth += 1\n                  \
    \  max_depth = max(max_depth, current_depth)\n                } else if (c ==\
    \ ')') {\n                    current_depth -= 1\n                }\n        \
    \    }\n            result = result :+ max_depth\n        }\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (paren <- group) {\n       \
    \         if (paren == '(') {\n                    level += 1\n              \
    \      max_level = max(max_level, level)\n                } else if (paren ==\
    \ ')') {\n                    level -= 1\n                }\n            }\n \
    \           result += max_level\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var level = 0\n          \
    \  var max_level = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') {\n                    level += 1\n                    if (level > max_level)\
    \ max_level = level\n                }\n                else if (paren == ')')\
    \ {\n                    level -= 1\n                }\n            }\n      \
    \      paren_levels += max_level\n        }\n        paren_levels.toList", " \
    \       val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (i <- 0 until group.length) {\n                if (group(i) == '(')\
    \ {\n                    current_depth += 1\n                    max_depth = max(max_depth,\
    \ current_depth)\n                } else if (group(i) == ')') {\n            \
    \        current_depth -= 1\n                }\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var current_level = 0\n     \
    \       var max_level = 0\n            for (c <- group) {\n                if\
    \ (c == '(') {\n                    current_level += 1\n                    max_level\
    \ = max(max_level, current_level)\n                } else if (c == ')') {\n  \
    \                  current_level -= 1\n                }\n            }\n    \
    \        result += max_level\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x\
    \ => parseNestedParensHelper(x))\n        paren_levels.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var result = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var max_depth = 0\n            var depth\
    \ = 0\n            for (paren <- group) {\n                if (paren == '(') depth\
    \ += 1\n                else if (paren == ')') depth -= 1\n                if\
    \ (depth > max_depth) max_depth = depth\n            }\n            result = result\
    \ :+ max_depth\n        }\n        return result", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n   \
    \     for (group <- paren_groups) {\n            var max_depth = 0\n         \
    \   var depth = 0\n            for (c <- group) {\n                if (c == '(')\
    \ depth += 1\n                else if (c == ')') depth -= 1\n                if\
    \ (depth > max_depth) max_depth = depth\n            }\n            result +=\
    \ max_depth\n        }\n        result.toList", "        // Split the string into\
    \ multiple groups.\n        val groups = paren_string.split(\" \")\n        //\
    \ For each group, find the maximum depth of nesting.\n        groups.map(group\
    \ => {\n            // Keep track of the maximum depth of nesting.\n         \
    \   var max_depth = 0\n            // Keep track of the current depth of nesting.\n\
    \            var current_depth = 0\n            // For each character in the group,\
    \ update the current depth of nesting.\n            group.foreach(c => {\n   \
    \             c match {\n                    case '(' => current_depth += 1\n\
    \                    case ')' => current_depth -= 1\n                }\n     \
    \           // Update the maximum depth of nesting if the current depth is greater.\n\
    \                if (current_depth > max_depth) max_depth = current_depth\n  \
    \          })\n            // Return the maximum depth of nesting.\n         \
    \   max_depth\n        }).map(x => x.toLong).toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n     \
    \   for (group <- paren_groups) {\n            var max_level = 0\n           \
    \ var current_level = 0\n            for (c <- group) {\n                if (c\
    \ == '(') {\n                    current_level += 1\n                    max_level\
    \ = max(max_level, current_level)\n                } else if (c == ')') {\n  \
    \                  current_level -= 1\n                }\n            }\n    \
    \        result += max_level\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x\
    \ => x.count(y => y == '(') - x.count(y => y == ')'))\n        val paren_stack\
    \ = new Stack[Char]\n        val paren_max_levels = paren_groups.map(x => {\n\
    \            var max_level = 0\n            var current_level = 0\n          \
    \  for (paren <- x) {\n                if (paren == '(') {\n                 \
    \   paren_stack.push(paren)\n                    current_level += 1\n        \
    \            if (current_level > max_level) max_level = current_level\n      \
    \          }\n                else if (paren == ')') {\n                    paren_stack.pop\n\
    \                    current_level -= 1\n                }\n            }\n  \
    \          max_level\n        })\n        paren_max_levels.toList", "        val\
    \ parens = paren_string.split(\" \")\n        var result = List[Long]()\n    \
    \    for (paren <- parens) {\n            var max_depth = 0\n            var depth\
    \ = 0\n            for (c <- paren) {\n                if (c == '(') depth +=\
    \ 1\n                else if (c == ')') depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result = result :+ max_depth\n\
    \        }\n        return result", "        var paren_list = paren_string.split(\"\
    \ \").toList\n        var result = List[Long]()\n        for (paren <- paren_list)\
    \ {\n            var stack = Stack[Char]()\n            var max_depth = 0\n  \
    \          var current_depth = 0\n            for (c <- paren) {\n           \
    \     if (c == '(') {\n                    stack.push(c)\n                   \
    \ current_depth += 1\n                    if (current_depth > max_depth) max_depth\
    \ = current_depth\n                }\n                else if (c == ')') {\n \
    \                   if (stack.isEmpty) throw new Exception(\"Invalid input\")\n\
    \                    stack.pop\n                    current_depth -= 1\n     \
    \           }\n            }\n            if (!stack.isEmpty) throw new Exception(\"\
    Invalid input\")\n            result = result :+ max_depth\n        }\n      \
    \  return result", "        val paren_groups = paren_string.split(\" \")\n   \
    \     val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result += max_depth\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(group => {\n            var\
    \ max_level = 0\n            var current_level = 0\n            for (paren <-\
    \ group) {\n                if (paren == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (paren == ')') {\n                    current_level -= 1\n\
    \                }\n            }\n            max_level\n        })\n       \
    \ paren_levels.toList.map(level => level.toLong)", "        val paren_groups =\
    \ paren_string.split(\" \")\n        var result = List[Long]()\n        for (group\
    \ <- paren_groups) {\n            var max_depth = 0\n            var depth = 0\n\
    \            for (c <- group) {\n                if (c == '(') depth += 1\n  \
    \              else if (c == ')') depth -= 1\n                if (depth > max_depth)\
    \ max_depth = depth\n            }\n            result = max_depth :: result\n\
    \        }\n        return result.reverse", "        val groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- groups) {\n  \
    \          var max_depth = 0\n            var depth = 0\n            for (paren\
    \ <- group) {\n                if (paren == '(') depth += 1\n                else\
    \ if (paren == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result = result :+ max_depth\n        }\n        return\
    \ result", "        var result = List[Long]()\n        var current_level = 0\n\
    \        var max_level = 0\n        for (c <- paren_string) {\n            if\
    \ (c == '(') {\n                current_level += 1\n                max_level\
    \ = max(max_level, current_level)\n            } else if (c == ')') {\n      \
    \          current_level -= 1\n            } else if (c == ' ') {\n          \
    \      result = result :+ max_level\n                max_level = 0\n         \
    \       current_level = 0\n            }\n        }\n        result = result :+\
    \ max_level\n        return result", "        val groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')'))\n \
    \       val max_levels = paren_levels.map(x => if (x < 0) 0 else x)\n        max_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var current_level = 0\n            for (paren <- group) {\n           \
    \     if (paren == '(') {\n                    current_level += 1\n          \
    \          max_level = max(max_level, current_level)\n                } else if\
    \ (paren == ')') {\n                    current_level -= 1\n                }\n\
    \            }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length) {\n\
    \            var paren_level = 0l\n            var max_paren_level = 0l\n    \
    \        for (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') paren_level += 1\n                else if (paren_groups(i)(j) == ')')\
    \ paren_level -= 1\n                if (paren_level > max_paren_level) max_paren_level\
    \ = paren_level\n            }\n            paren_levels += max_paren_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => parseNestedParensHelper(x))\n\
    \        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var stack = Stack[Char]()\n            var max_depth = 0\n  \
    \          var depth = 0\n            for (c <- group) {\n                if (c\
    \ == '(') {\n                    stack.push(c)\n                    depth += 1\n\
    \                    max_depth = max(max_depth, depth)\n                } else\
    \ if (c == ')') {\n                    stack.pop\n                    depth -=\
    \ 1\n                }\n            }\n            result = result :+ max_depth\n\
    \        }\n        result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = new ListBuffer[Long]()\n        for (group\
    \ <- paren_groups) {\n            var max_level = 0\n            var current_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               current_level += 1\n                    if (current_level > max_level)\
    \ max_level = current_level\n                }\n                else if (c ==\
    \ ')') {\n                    current_level -= 1\n                }\n        \
    \    }\n            max_nesting_levels += max_level\n        }\n        max_nesting_levels.toList",
  "        // Split the input string into groups of parentheses.\n        val paren_groups\
    \ = paren_string.split(\" \")\n        // For each group, find the maximum nesting\
    \ level.\n        val max_nesting_levels = paren_groups.map(group => {\n     \
    \       // Keep track of the current nesting level.\n            var current_nesting_level\
    \ = 0\n            // Keep track of the maximum nesting level.\n            var\
    \ max_nesting_level = 0\n            // Iterate through each character in the\
    \ group.\n            for (i <- 0 until group.length) {\n                // If\
    \ the character is an opening parenthesis, increase the current nesting level.\n\
    \                if (group(i) == '(') {\n                    current_nesting_level\
    \ += 1\n                    // Update the maximum nesting level if necessary.\n\
    \                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                // If the character\
    \ is a closing parenthesis, decrease the current nesting level.\n            \
    \    else if (group(i) == ')') current_nesting_level -= 1\n            }\n   \
    \         // Return the maximum nesting level.\n            max_nesting_level\n\
    \        })\n        // Return the maximum nesting levels.\n        max_nesting_levels.toList.map(level\
    \ => level.toLong)", "        val paren_groups = paren_string.split(\" \")\n \
    \       val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    if (level > max_level) max_level = level\n          \
    \      }\n                else if (c == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val max_nesting_levels = paren_groups.map(group => {\n        \
    \    var max_level = 0\n            var current_level = 0\n            for (c\
    \ <- group) {\n                if (c == '(') {\n                    current_level\
    \ += 1\n                    max_level = max(max_level, current_level)\n      \
    \          } else if (c == ')') {\n                    current_level -= 1\n  \
    \              }\n            }\n            max_level\n        })\n        max_nesting_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_depth += 1\n                    max_depth = max(max_depth, current_depth)\n\
    \                } else if (c == ')') {\n                    current_depth -=\
    \ 1\n                }\n            }\n            result = result :+ max_depth\n\
    \        }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val depths = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var depth = 0\n            var max_depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            depths += max_depth\n        }\n        depths.toList",
  "        var result = List[Long]()\n        var paren_groups = paren_string.split(\"\
    \ \")\n        for (i <- 0 until paren_groups.length) {\n            var paren_group\
    \ = paren_groups(i)\n            var max_depth = 0\n            var depth = 0\n\
    \            for (j <- 0 until paren_group.length) {\n                if (paren_group(j)\
    \ == '(') depth += 1\n                else if (paren_group(j) == ')') depth -=\
    \ 1\n                if (depth > max_depth) max_depth = depth\n            }\n\
    \            result = result :+ max_depth\n        }\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                if (depth > max_depth) max_depth = depth\n            }\n   \
    \         result += max_depth\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x\
    \ => x.count(y => y == '(') - x.count(y => y == ')'))\n        val paren_counts\
    \ = paren_groups.map(x => x.count(y => y == '('))\n        val paren_levels_max\
    \ = paren_levels.max\n        val paren_levels_min = paren_levels.min\n      \
    \  val paren_counts_max = paren_counts.max\n        val paren_counts_min = paren_counts.min\n\
    \        val paren_levels_max_count = paren_levels.count(x => x == paren_levels_max)\n\
    \        val paren_levels_min_count = paren_levels.count(x => x == paren_levels_min)\n\
    \        val paren_counts_max_count = paren_counts.count(x => x == paren_counts_max)\n\
    \        val paren_counts_min_count = paren_counts.count(x => x == paren_counts_min)\n\
    \        val paren_levels_max_count_max = List(paren_levels_max_count, paren_levels_min_count).max\n\
    \        val paren_counts_max_count_max = List(paren_counts_max_count, paren_counts_min_count).max\n\
    \        val paren_levels_max_count_min = List(paren_levels_max_count, paren_levels_min_count).min\n\
    \        val paren_counts_max_count_min = List(paren_counts_max_count, paren_counts_min_count).min\n\
    \        List(paren_levels_max_count_max, paren_counts_max_count_max, paren_levels_max_count_min,\
    \ paren_counts_max_count_min).map(x => x.toLong)", "        val paren_groups =\
    \ paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n       \
    \ for (paren_group <- paren_groups) {\n            var max_level = 0\n       \
    \     var current_level = 0\n            for (paren <- paren_group) {\n      \
    \          if (paren == '(') {\n                    current_level += 1\n     \
    \               max_level = max(max_level, current_level)\n                } else\
    \ if (paren == ')') {\n                    current_level -= 1\n              \
    \  }\n            }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x))\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') depth += 1\n                else depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result = result :+ max_depth\n\
    \        }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var max_level = 0\n            var current_level\
    \ = 0\n            for (c <- group) {\n                if (c == '(') {\n     \
    \               current_level += 1\n                    if (current_level > max_level)\
    \ {\n                        max_level = current_level\n                    }\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        var result = List[Long]()\n\
    \        var current_level = 0\n        var max_level = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                current_level += 1\n       \
    \         max_level = max(max_level, current_level)\n            } else if (c\
    \ == ')') {\n                current_level -= 1\n            } else if (c == '\
    \ ') {\n                result = result :+ max_level\n                max_level\
    \ = 0\n                current_level = 0\n            }\n        }\n        result\
    \ = result :+ max_level\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = ListBuffer[Long]()\n        for (i <- 0 until\
    \ paren_groups.length) {\n            var level = 0\n            var max_level\
    \ = 0\n            for (j <- 0 until paren_groups(i).length) {\n             \
    \   if (paren_groups(i)(j) == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (paren_groups(i)(j) == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            paren_levels += max_level\n\
    \        }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var max_nesting_level = 0\n            var current_nesting_level = 0\n    \
    \        for (ch <- group) {\n                if (ch == '(') {\n             \
    \       current_nesting_level += 1\n                    if (current_nesting_level\
    \ > max_nesting_level) max_nesting_level = current_nesting_level\n           \
    \     }\n                else if (ch == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_levels += max_nesting_level\n\
    \        }\n        max_nesting_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => parseNestedParensHelper(x))\n\
    \        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    if (level > max_level) max_level = level\n          \
    \      }\n                else if (c == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList", "        var max_depth = 0\n        var\
    \ depth = 0\n        var result = List[Long]()\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                depth += 1\n               \
    \ max_depth = max(max_depth, depth)\n            } else if (c == ')') {\n    \
    \            depth -= 1\n            } else if (c == ' ') {\n                result\
    \ = result :+ max_depth\n                max_depth = 0\n                depth\
    \ = 0\n            }\n        }\n        result = result :+ max_depth\n      \
    \  return result", "        val paren_groups = paren_string.split(\" \")\n   \
    \     val max_nesting_levels = paren_groups.map(group => {\n            var max_nesting_level\
    \ = 0\n            var current_nesting_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    current_nesting_level\
    \ += 1\n                    if (current_nesting_level > max_nesting_level) max_nesting_level\
    \ = current_nesting_level\n                }\n                else if (paren ==\
    \ ')') {\n                    current_nesting_level -= 1\n                }\n\
    \            }\n            max_nesting_level\n        })\n        max_nesting_levels.toList.map(level\
    \ => level.toLong)", "        val paren_groups = paren_string.split(\" \")\n \
    \       var result = List[Long]()\n        for (i <- 0 until paren_groups.length)\
    \ {\n            var max_nesting = 0\n            var current_nesting = 0\n  \
    \          for (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') current_nesting += 1\n                else if (paren_groups(i)(j) ==\
    \ ')') current_nesting -= 1\n                if (current_nesting > max_nesting)\
    \ max_nesting = current_nesting\n            }\n            result = result :+\
    \ max_nesting\n        }\n        return result", "        val paren_groups =\
    \ paren_string.split(\" \")\n        var max_levels = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var current_level = 0\n            var\
    \ max_level = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') {\n                    current_level += 1\n                    if (current_level\
    \ > max_level) max_level = current_level\n                }\n                else\
    \ if (paren == ')') {\n                    current_level -= 1\n              \
    \  }\n            }\n            max_levels = max_levels :+ max_level\n      \
    \  }\n        return max_levels", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                if (depth > max_depth) max_depth =\
    \ depth\n            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var depth\
    \ = 0\n            var max_depth = 0\n            for (c <- group) {\n       \
    \         if (c == '(') {\n                    depth += 1\n                  \
    \  max_depth = max(max_depth, depth)\n                } else if (c == ')') {\n\
    \                    depth -= 1\n                }\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = paren_groups.map(x => {\n\
    \            var max_depth = 0\n            var current_depth = 0\n          \
    \  for (i <- 0 until x.length) {\n                if (x(i) == '(') {\n       \
    \             current_depth += 1\n                    max_depth = max(max_depth,\
    \ current_depth)\n                } else if (x(i) == ')') {\n                \
    \    current_depth -= 1\n                }\n            }\n            max_depth\n\
    \        }).toList\n        result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var current_level = 0\n      \
    \      for (c <- group) {\n                if (c == '(') {\n                 \
    \   current_level += 1\n                    max_level = max(max_level, current_level)\n\
    \                } else if (c == ')') {\n                    current_level -=\
    \ 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        var max_depth = 0\n        var depth = 0\n        var result = List[Long]()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    depth += 1\n                max_depth = max(max_depth, depth)\n         \
    \   } else if (c == ')') {\n                depth -= 1\n            } else if\
    \ (c == ' ') {\n                result = result :+ max_depth\n               \
    \ max_depth = 0\n                depth = 0\n            }\n        }\n       \
    \ result = result :+ max_depth\n        return result", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_level = 0\n       \
    \     var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val parens = paren_string.split(\" \"\
    )\n        var result = List[Long]()\n        for (paren <- parens) {\n      \
    \      var max_depth = 0\n            var depth = 0\n            for (c <- paren)\
    \ {\n                if (c == '(') depth += 1\n                else depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result = result :+ max_depth\n        }\n        return result", "        val\
    \ paren_groups = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var level = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (c == ')') {\n                    level -=\
    \ 1\n                }\n            }\n            result += max_level\n     \
    \   }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (c <- group) {\n                if (c == '(') current_depth += 1\n\
    \                else if (c == ')') current_depth -= 1\n                max_depth\
    \ = max(max_depth, current_depth)\n            }\n            result += max_depth\n\
    \        }\n        result.toList", "        var result = List[Long]()\n     \
    \   var current_level = 0\n        var max_level = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                current_level += 1\n       \
    \         max_level = max(max_level, current_level)\n            } else if (c\
    \ == ')') {\n                current_level -= 1\n            } else if (c == '\
    \ ') {\n                result = result :+ max_level\n                max_level\
    \ = 0\n                current_level = 0\n            }\n        }\n        result\
    \ = result :+ max_level\n        return result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = new ListBuffer[Long]()\n        for (group <-\
    \ paren_groups) {\n            var level = 0\n            var max_level = 0\n\
    \            for (c <- group) {\n                if (c == '(') level += 1\n  \
    \              else if (c == ')') level -= 1\n                if (level > max_level)\
    \ max_level = level\n            }\n            paren_levels += max_level\n  \
    \      }\n        paren_levels.toList", "        val parens = paren_string.split(\"\
    \ \")\n        val result = new ListBuffer[Long]()\n        for (paren <- parens)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- paren) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var current_depth = 0\n            for (c <- group) {\n   \
    \             if (c == '(') {\n                    current_depth += 1\n      \
    \              max_depth = max(max_depth, current_depth)\n                } else\
    \ if (c == ')') {\n                    current_depth -= 1\n                }\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_nesting = 0\n    \
    \        var current_nesting = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    current_nesting += 1\n            \
    \        max_nesting = max(max_nesting, current_nesting)\n                } else\
    \ if (c == ')') {\n                    current_nesting -= 1\n                }\n\
    \            }\n            result = result :+ max_nesting\n        }\n      \
    \  return result", "        paren_string.split(\" \").map(x => {\n           \
    \ var max_depth = 0\n            var current_depth = 0\n            for (c <-\
    \ x) {\n                if (c == '(') {\n                    current_depth +=\
    \ 1\n                    max_depth = max(max_depth, current_depth)\n         \
    \       } else if (c == ')') {\n                    current_depth -= 1\n     \
    \           }\n            }\n            max_depth\n        }).toList.map(x =>\
    \ x.toLong)", "        val paren_groups = paren_string.split(\" \")\n        val\
    \ paren_levels = paren_groups.map(x => x.toList.map(y => if (y == '(') 1 else\
    \ -1).scanLeft(0)(_ + _).max)\n        paren_levels.toList.map(x => x.toLong)",
  "        val paren_groups = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var depth = 0\n            for (c <- group) {\n                if (c ==\
    \ '(') depth += 1\n                else if (c == ')') depth -= 1\n           \
    \     if (depth > max_depth) max_depth = depth\n            }\n            result\
    \ += max_depth\n        }\n        result.toList", "        val paren_groups =\
    \ paren_string.split(\" \")\n        paren_groups.map(x => parseNestedParensHelper(x)).toList",
  "        val paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_level = 0\n      \
    \      var level = 0\n            for (paren <- group) {\n                if (paren\
    \ == '(') {\n                    level += 1\n                    max_level = max(max_level,\
    \ level)\n                } else if (paren == ')') {\n                    level\
    \ -= 1\n                }\n            }\n            result = result :+ max_level\n\
    \        }\n        return result", "        var result = List[Long]()\n     \
    \   var max_depth = 0\n        var depth = 0\n        for (c <- paren_string)\
    \ {\n            if (c == '(') {\n                depth += 1\n               \
    \ max_depth = max(max_depth, depth)\n            } else if (c == ')') {\n    \
    \            depth -= 1\n            } else if (c == ' ') {\n                result\
    \ = result :+ max_depth\n                max_depth = 0\n                depth\
    \ = 0\n            }\n        }\n        result = result :+ max_depth\n      \
    \  return result", "        val paren_groups = paren_string.split(\" \")\n   \
    \     var result = List[Long]()\n        for (group <- paren_groups) {\n     \
    \       var max_depth = 0\n            var depth = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    depth += 1\n       \
    \             max_depth = max(max_depth, depth)\n                } else if (c\
    \ == ')') {\n                    depth -= 1\n                }\n            }\n\
    \            result = result :+ max_depth\n        }\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') level += 1\n                else if (c == ')')\
    \ level -= 1\n                if (level > max_level) max_level = level\n     \
    \       }\n            paren_levels += max_level\n        }\n        paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        paren_groups.map(group\
    \ => {\n            var max_nesting = 0\n            var current_nesting = 0\n\
    \            for (c <- group) {\n                if (c == '(') current_nesting\
    \ += 1\n                else if (c == ')') current_nesting -= 1\n            \
    \    max_nesting = max(max_nesting, current_nesting)\n            }\n        \
    \    max_nesting\n        }).toList.map(_.toLong)", "        val paren_groups\
    \ = paren_string.split(\" \")\n        var result = List[Long]()\n        for\
    \ (group <- paren_groups) {\n            var max_depth = 0\n            var depth\
    \ = 0\n            for (c <- group) {\n                if (c == '(') depth +=\
    \ 1\n                else if (c == ')') depth -= 1\n                max_depth\
    \ = max(max_depth, depth)\n            }\n            result = result :+ max_depth\n\
    \        }\n        return result", "        val parens = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (paren <- parens)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- paren) {\n                if (c == '(') {\n                    depth +=\
    \ 1\n                    max_depth = max(max_depth, depth)\n                }\
    \ else if (c == ')') {\n                    depth -= 1\n                }\n  \
    \          }\n            result += max_depth\n        }\n        result.toList",
  "        // Split the string by spaces.\n        val paren_groups = paren_string.split(\"\
    \ \")\n        // For each group, find the maximum nesting level.\n        val\
    \ max_nesting_levels = paren_groups.map(group => {\n            // Keep track\
    \ of the current nesting level.\n            var current_nesting_level = 0\n \
    \           // Keep track of the maximum nesting level.\n            var max_nesting_level\
    \ = 0\n            // Iterate over the characters in the group.\n            for\
    \ (character <- group) {\n                // If the character is a left parenthesis,\
    \ increment the current nesting level.\n                if (character == '(')\
    \ {\n                    current_nesting_level += 1\n                }\n     \
    \           // If the character is a right parenthesis, decrement the current\
    \ nesting level.\n                else if (character == ')') {\n             \
    \       current_nesting_level -= 1\n                }\n                // If the\
    \ current nesting level is greater than the maximum nesting level, update the\
    \ maximum nesting level.\n                if (current_nesting_level > max_nesting_level)\
    \ {\n                    max_nesting_level = current_nesting_level\n         \
    \       }\n            }\n            // Return the maximum nesting level.\n \
    \           max_nesting_level\n        })\n        // Return the list of maximum\
    \ nesting levels.\n        max_nesting_levels.toList.map(level => level.toLong)",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = paren_groups.map(x => parseNestedParensHelper(x))\n        return paren_levels.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') {\n                    level += 1\n                    max_level\
    \ = max(max_level, level)\n                } else if (c == ')') {\n          \
    \          level -= 1\n                }\n            }\n            result +=\
    \ max_level\n        }\n        result.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.count(y => y == '(')\
    \ - x.count(y => y == ')'))\n        val paren_max_levels = paren_levels.map(x\
    \ => if (x < 0) 0 else x)\n        paren_max_levels.toList.map(x => x.toLong)",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_level\
    \ = 0\n            var level = 0\n            for (c <- group) {\n           \
    \     if (c == '(') level += 1\n                else if (c == ')') level -= 1\n\
    \                max_level = max(max_level, level)\n            }\n          \
    \  result += max_level\n        }\n        result.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = ListBuffer[Long]()\n     \
    \   for (paren_group <- paren_groups) {\n            var max_depth = 0\n     \
    \       var current_depth = 0\n            for (paren <- paren_group) {\n    \
    \            if (paren == '(') {\n                    current_depth += 1\n   \
    \                 max_depth = max(max_depth, current_depth)\n                }\
    \ else if (paren == ')') {\n                    current_depth -= 1\n         \
    \       }\n            }\n            result += max_depth\n        }\n       \
    \ result.toList", "        val paren_groups = paren_string.split(\" \")\n    \
    \    val paren_levels = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var level = 0\n            var max_level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    if (level > max_level) max_level = level\n          \
    \      }\n                else if (c == ')') {\n                    level -= 1\n\
    \                }\n            }\n            paren_levels += max_level\n   \
    \     }\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (c <- group)\
    \ {\n                if (c == '(') {\n                    level += 1\n       \
    \             if (level > max_level) max_level = level\n                }\n  \
    \              else if (c == ')') {\n                    level -= 1\n        \
    \        }\n            }\n            paren_levels += max_level\n        }\n\
    \        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => parseNestedParensHelper(x.toList,\
    \ 0, 0))\n        paren_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.toList.map(y => if (y\
    \ == '(') 1 else -1).scanLeft(0)(_ + _).max)\n        paren_levels.toList.map(x\
    \ => x.toLong)", "        val paren_groups = paren_string.split(\" \")\n     \
    \   val result = ListBuffer[Long]()\n        for (i <- 0 until paren_groups.length)\
    \ {\n            var max_depth = 0\n            var current_depth = 0\n      \
    \      for (j <- 0 until paren_groups(i).length) {\n                if (paren_groups(i)(j)\
    \ == '(') {\n                    current_depth += 1\n                    max_depth\
    \ = max(max_depth, current_depth)\n                }\n                else if\
    \ (paren_groups(i)(j) == ')') {\n                    current_depth -= 1\n    \
    \            }\n            }\n            result += max_depth\n        }\n  \
    \      result.toList", "        val paren_groups = paren_string.split(\" \")\n\
    \        val max_nesting_levels = paren_groups.map(x => {\n            var max_nesting_level\
    \ = 0\n            var current_nesting_level = 0\n            for (i <- 0 until\
    \ x.length) {\n                if (x(i) == '(') {\n                    current_nesting_level\
    \ += 1\n                    max_nesting_level = max(max_nesting_level, current_nesting_level)\n\
    \                } else if (x(i) == ')') {\n                    current_nesting_level\
    \ -= 1\n                }\n            }\n            max_nesting_level\n    \
    \    }).toList\n        max_nesting_levels", "        val parens = paren_string.split(\"\
    \ \")\n        var result = List[Long]()\n        for (paren <- parens) {\n  \
    \          var max_depth = 0\n            var depth = 0\n            for (c <-\
    \ paren) {\n                if (c == '(') depth += 1\n                else if\
    \ (c == ')') depth -= 1\n                if (depth > max_depth) max_depth = depth\n\
    \            }\n            result = result :+ max_depth\n        }\n        return\
    \ result", "        val groups = paren_string.split(\" \")\n        val depths\
    \ = new ListBuffer[Long]()\n        for (group <- groups) {\n            var depth\
    \ = 0\n            var max_depth = 0\n            for (c <- group) {\n       \
    \         if (c == '(') {\n                    depth += 1\n                  \
    \  max_depth = max(max_depth, depth)\n                } else if (c == ')') {\n\
    \                    depth -= 1\n                }\n            }\n          \
    \  depths += max_depth\n        }\n        depths.toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val paren_levels = paren_groups.map(x =>\
    \ x.count(y => y == '(') - x.count(y => y == ')'))\n        val paren_levels_max\
    \ = paren_levels.map(x => if (x < 0) 0 else x)\n        paren_levels_max.toList",
  "        var result = List[Long]()\n        var paren_groups = paren_string.split(\"\
    \ \")\n        for (i <- 0 until paren_groups.length) {\n            var paren_group\
    \ = paren_groups(i)\n            var max_level = 0\n            var level = 0\n\
    \            for (j <- 0 until paren_group.length) {\n                if (paren_group(j)\
    \ == '(') {\n                    level += 1\n                    if (level > max_level)\
    \ max_level = level\n                }\n                else if (paren_group(j)\
    \ == ')') {\n                    level -= 1\n                }\n            }\n\
    \            result = result :+ max_level\n        }\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val paren_levels\
    \ = new ListBuffer[Long]()\n        for (group <- paren_groups) {\n          \
    \  var level = 0\n            var max_level = 0\n            for (paren <- group)\
    \ {\n                if (paren == '(') {\n                    level += 1\n   \
    \                 if (level > max_level) max_level = level\n                }\n\
    \                else if (paren == ')') {\n                    level -= 1\n  \
    \              }\n            }\n            paren_levels += max_level\n     \
    \   }\n        paren_levels.toList", "        paren_string.split(\" \").map(s\
    \ => {\n            var max_depth = 0\n            var depth = 0\n           \
    \ for (c <- s) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            max_depth\n        }).toList", "        val paren_groups\
    \ = paren_string.split(\" \")\n        val result = new ListBuffer[Long]()\n \
    \       for (group <- paren_groups) {\n            var max_level = 0\n       \
    \     var current_level = 0\n            for (c <- group) {\n                if\
    \ (c == '(') {\n                    current_level += 1\n                    max_level\
    \ = max(max_level, current_level)\n                } else if (c == ')') {\n  \
    \                  current_level -= 1\n                }\n            }\n    \
    \        result += max_level\n        }\n        result.toList", "        val\
    \ paren_groups = paren_string.split(\" \")\n        var result = List[Long]()\n\
    \        for (group <- paren_groups) {\n            var max_depth = 0\n      \
    \      var current_depth = 0\n            for (c <- group) {\n               \
    \ if (c == '(') {\n                    current_depth += 1\n                  \
    \  max_depth = max(max_depth, current_depth)\n                } else if (c ==\
    \ ')') {\n                    current_depth -= 1\n                }\n        \
    \    }\n            result = result :+ max_depth\n        }\n        return result",
  "        val paren_groups = paren_string.split(\" \")\n        val result = new\
    \ ListBuffer[Long]()\n        for (group <- paren_groups) {\n            var max_depth\
    \ = 0\n            var depth = 0\n            for (c <- group) {\n           \
    \     if (c == '(') depth += 1\n                else if (c == ')') depth -= 1\n\
    \                max_depth = max(max_depth, depth)\n            }\n          \
    \  result += max_depth\n        }\n        result.toList", "        // Write your\
    \ code here\n        var result = List[Long]()\n        var stack = Stack[Char]()\n\
    \        for (c <- paren_string) {\n            if (c == '(') {\n            \
    \    stack.push(c)\n            } else if (c == ')') {\n                stack.pop()\n\
    \            } else if (c == ' ') {\n                result = result :+ stack.size\n\
    \            }\n        }\n        result", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val paren_levels = paren_groups.map(x => x.count(y => y == '(')\
    \ - x.count(y => y == ')'))\n        val max_levels = paren_levels.map(x => if\
    \ (x < 0) 0 else x)\n        max_levels.toList", "        val paren_groups = paren_string.split(\"\
    \ \")\n        val result = ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_depth = 0\n            var depth = 0\n            for\
    \ (c <- group) {\n                if (c == '(') depth += 1\n                else\
    \ if (c == ')') depth -= 1\n                max_depth = max(max_depth, depth)\n\
    \            }\n            result += max_depth\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        paren_groups.map(x\
    \ => {\n            var max_level = 0\n            var current_level = 0\n   \
    \         for (i <- 0 until x.length) {\n                if (x(i) == '(') {\n\
    \                    current_level += 1\n                    max_level = max(max_level,\
    \ current_level)\n                } else if (x(i) == ')') {\n                \
    \    current_level -= 1\n                }\n            }\n            max_level\n\
    \        }).toList", "        val paren_groups = paren_string.split(\" \")\n \
    \       val result = new ListBuffer[Long]()\n        for (group <- paren_groups)\
    \ {\n            var max_level = 0\n            var level = 0\n            for\
    \ (c <- group) {\n                if (c == '(') {\n                    level +=\
    \ 1\n                    max_level = max(max_level, level)\n                }\
    \ else if (c == ')') {\n                    level -= 1\n                }\n  \
    \          }\n            result += max_level\n        }\n        result.toList",
  "        val paren_groups = paren_string.split(\" \")\n        val max_nesting_levels\
    \ = paren_groups.map(x => x.count(y => y == '(') - x.count(y => y == ')')).map(x\
    \ => abs(x)).toList\n        return max_nesting_levels"]
stop_tokens:
- "\n    }\n"
