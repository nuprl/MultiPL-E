name: HumanEval_58_common
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Return sorted unique common elements for two lists.\n    // >>> common((List[Long](1l.toLong,\
  \ 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong,\
  \ 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong)))\n    //\
  \ (List[Long](1l.toLong, 5l.toLong, 653l.toLong))\n    // >>> common((List[Long](5l.toLong,\
  \ 3l.toLong, 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong)))\n    //\
  \ (List[Long](2l.toLong, 3l.toLong))\n    def common(l1 : List[Long], l2 : List[Long])\
  \ : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(common((List[Long](1l.toLong,\
  \ 4l.toLong, 3l.toLong, 34l.toLong, 653l.toLong, 2l.toLong, 5l.toLong)), (List[Long](5l.toLong,\
  \ 7l.toLong, 1l.toLong, 5l.toLong, 9l.toLong, 653l.toLong, 121l.toLong))).equals((List[Long](1l.toLong,\
  \ 5l.toLong, 653l.toLong))));\n    assert(common((List[Long](5l.toLong, 3l.toLong,\
  \ 2l.toLong, 8l.toLong)), (List[Long](3l.toLong, 2l.toLong))).equals((List[Long](2l.toLong,\
  \ 3l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong, 2l.toLong,\
  \ 8l.toLong)), (List[Long](3l.toLong, 2l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
  \ 3l.toLong, 4l.toLong))));\n    assert(common((List[Long](4l.toLong, 3l.toLong,\
  \ 2l.toLong, 8l.toLong)), (List[Long]())).equals((List[Long]())));\n    }\n\n}\n"
completions: ["        var l = List[Long]()\n        for (i <- l1) {\n           \
    \ if (l2.contains(i)) {\n                l = l :+ i\n            }\n        }\n\
    \        l.sorted", "        val l1s = l1.sorted\n        val l2s = l2.sorted\n\
    \        val l1l = l1s.length\n        val l2l = l2s.length\n        var i = 0\n\
    \        var j = 0\n        var result = List[Long]()\n        while (i < l1l\
    \ && j < l2l) {\n            if (l1s(i) == l2s(j)) {\n                result =\
    \ result :+ l1s(i)\n                i += 1\n                j += 1\n         \
    \   } else if (l1s(i) < l2s(j)) {\n                i += 1\n            } else\
    \ {\n                j += 1\n            }\n        }\n        result", "    \
    \    // Fill in the code here.\n        var l3 = List[Long]()\n        for (i\
    \ <- l1) {\n            if (l2.contains(i)) {\n                l3 = l3 :+ i\n\
    \            }\n        }\n        return l3.distinct.sorted", "        val s1\
    \ = l1.toSet\n        val s2 = l2.toSet\n        (s1 & s2).toList.sorted", " \
    \       val s1 = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n\
    \        s3.toList.sorted", "        val set1 = l1.toSet\n        val set2 = l2.toSet\n\
    \        val set3 = set1.intersect(set2)\n        set3.toList.sorted", "     \
    \   val l1s = l1.sorted\n        val l2s = l2.sorted\n        val l1l = l1s.length\n\
    \        val l2l = l2s.length\n        var i = 0\n        var j = 0\n        var\
    \ result = List[Long]()\n        while (i < l1l && j < l2l) {\n            if\
    \ (l1s(i) == l2s(j)) {\n                result = result :+ l1s(i)\n          \
    \      i += 1\n                j += 1\n            } else if (l1s(i) < l2s(j))\
    \ {\n                i += 1\n            } else {\n                j += 1\n  \
    \          }\n        }\n        result", "        val h = new HashMap[Long, Int]\n\
    \        for (i <- l1) {\n            if (h.contains(i)) h(i) += 1\n         \
    \   else h(i) = 1\n        }\n        for (i <- l2) {\n            if (h.contains(i))\
    \ h(i) += 1\n            else h(i) = 1\n        }\n        val result = new ListBuffer[Long]\n\
    \        for ((k, v) <- h) {\n            if (v == 2) result += k\n        }\n\
    \        result.toList.sorted", "        val m1 = l1.groupBy(identity).mapValues(_.size)\n\
    \        val m2 = l2.groupBy(identity).mapValues(_.size)\n        val m = m1.keySet.intersect(m2.keySet).map(x\
    \ => (x, min(m1(x), m2(x)))).toMap\n        m.flatMap(x => List.fill(x._2)(x._1)).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n\
    \        s3.toList.sorted", "        val s1 = l1.toSet\n        val s2 = l2.toSet\n\
    \        val s3 = s1.intersect(s2)\n        s3.toList.sorted", "        val set1\
    \ = l1.toSet\n        val set2 = l2.toSet\n        (set1 & set2).toList.sorted",
  "        val s1 = l1.toSet\n        val s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n\
    \        s3.toList.sorted", "        val l3 = l1.intersect(l2)\n        l3.sorted",
  "        val l1s = l1.sorted\n        val l2s = l2.sorted\n        var i = 0\n \
    \       var j = 0\n        var result = List[Long]()\n        while (i < l1s.length\
    \ && j < l2s.length) {\n            if (l1s(i) == l2s(j)) {\n                result\
    \ = l1s(i) :: result\n                i += 1\n                j += 1\n       \
    \     } else if (l1s(i) < l2s(j)) {\n                i += 1\n            } else\
    \ {\n                j += 1\n            }\n        }\n        result.reverse",
  "        var result = List[Long]()\n        var l1s = l1.sorted\n        var l2s\
    \ = l2.sorted\n        while (!l1s.isEmpty && !l2s.isEmpty) {\n            if\
    \ (l1s.head == l2s.head) {\n                result = l1s.head :: result\n    \
    \            l1s = l1s.tail\n                l2s = l2s.tail\n            } else\
    \ if (l1s.head < l2s.head) {\n                l1s = l1s.tail\n            } else\
    \ {\n                l2s = l2s.tail\n            }\n        }\n        result.reverse",
  "        val l = l1.intersect(l2)\n        l.sorted", "        val l3 = l1.intersect(l2)\n\
    \        l3.sorted", "        val set1 = l1.toSet\n        val set2 = l2.toSet\n\
    \        (set1 & set2).toList.sorted", "        val s1 = l1.toSet\n        val\
    \ s2 = l2.toSet\n        val s3 = s1.intersect(s2)\n        s3.toList.sorted"]
stop_tokens:
- "\n    }\n"
