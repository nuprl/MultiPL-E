language: scala
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // We can use a greedy algorithm to solve this problem.\n\
    \        // We will use a stack to keep track of the elements in the array.\n\
    \        // We will iterate through the array and push the elements on to the\
    \ stack.\n        // If the current element is less than the top element of the\
    \ stack, then\n        // we will pop the top element of the stack and push the\
    \ current element.\n        // If the current element is greater than the top\
    \ element of the stack, then\n        // we will push the current element on to\
    \ the stack.\n        // If the stack is empty, then we will push the current\
    \ element on to the stack.\n        // If the stack is not empty and the current\
    \ element is less than the top element\n        // of the stack, then we will\
    \ pop the top element of the stack and push the current\n        // element.\n\
    \        // If the stack is not empty and the current element is greater than\
    \ the top element\n        // of the stack, then we will push the current element\
    \ on to the stack.\n        // If the stack is not empty and the current element\
    \ is equal to the top element\n        // of the stack, then we will push the\
    \ current element on to the stack.\n        // If the stack is not empty and the\
    \ current element is equal to the top element\n        // of the stack, then we\
    \ will push the current element on to the stack.\n        // If the stack is not\
    \ empty and the current element is equal to the top element\n        // of the\
    \ stack, then we will push the current element on to the stack.\n        // If\
    \ the stack is not empty and the current element is equal to the top element\n\
    \        // of the stack, then we will push the current element on to the stack.\n\
    \        // If the stack is not empty and the current element is equal to the\
    \ top element\n        // of the stack, then we will push the current element\
    \ on to the stack.\n        // If the stack is not empty and the current element\
    \ is equal to the top element\n        // of the stack, then we will push the\
    \ current element on to the stack.\n        // If the stack is not empty and the\
    \ current element is equal to the top element\n        // of the stack, then we\
    \ will push the current element on to the stack.\n        // If the stack is not\
    \ empty and the current element is equal to the top element\n        // of\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1alxo84h.scala:25:50\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mmoveOneBall\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mBoolean\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Unit\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m26 |\e[0m        \e[34m// We can use a greedy algorithm to solve\
    \ this problem.\e[0m\n\e[31m27 |\e[0m        \e[34m// We will use a stack to keep\
    \ track of the elements in the array.\e[0m\n\e[31m28 |\e[0m        \e[34m// We\
    \ will iterate through the array and push the elements on to the stack.\e[0m\n\
    \e[31m29 |\e[0m        \e[34m// If the current element is less than the top element\
    \ of the stack, then\e[0m\n\e[31m30 |\e[0m        \e[34m// we will pop the top\
    \ element of the stack and push the current element.\e[0m\n\e[31m31 |\e[0m   \
    \     \e[34m// If the current element is greater than the top element of the stack,\
    \ then\e[0m\n\e[31m32 |\e[0m        \e[34m// we will push the current element\
    \ on to the stack.\e[0m\n\e[31m33 |\e[0m        \e[34m// If the stack is empty,\
    \ then we will push the current element on to the stack.\e[0m\n\e[31m34 |\e[0m\
    \        \e[34m// If the stack is not empty and the current element is less than\
    \ the top element\e[0m\n\e[31m35 |\e[0m        \e[34m// of the stack, then we\
    \ will pop the top element of the stack and push the current\e[0m\n\e[31m36 |\e\
    [0m        \e[34m// element.\e[0m\n\e[31m37 |\e[0m        \e[34m// If the stack\
    \ is not empty and the current element is greater than the top element\e[0m\n\e\
    [31m38 |\e[0m        \e[34m// of the stack, then we will push the current element\
    \ on to the stack.\e[0m\n\e[31m39 |\e[0m        \e[34m// If the stack is not empty\
    \ and the current element is equal to the top element\e[0m\n\e[31m40 |\e[0m  \
    \      \e[34m// of the stack, then we will push the current element on to the\
    \ stack.\e[0m\n\e[31m41 |\e[0m        \e[34m// If the stack is not empty and the\
    \ current element is equal to the top el"
  stdout: ''
  timestamp: 1659797867
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sortedArr\
    \ = arr.sorted\n        val min = sortedArr.head\n        val max = sortedArr.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) {\n            if (maxIndex == arr.length - 1) return\
    \ true\n            else return false\n        }\n        else if (maxIndex ==\
    \ arr.length - 1) return false\n        else {\n            val newArr = arr.take(minIndex)\
    \ ++ arr.drop(minIndex + 1)\n            val newMinIndex = newArr.indexOf(min)\n\
    \            if (newMinIndex == 0) return true\n            else return false\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpey26t8ow.scala:45)\n\tat Problem.main(tmpey26t8ow.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val minIndex = arr.indexOf(min)\n        val maxIndex\
    \ = arr.indexOf(max)\n        if (minIndex == 0) {\n            if (maxIndex ==\
    \ n - 1) return true\n            else return false\n        }\n        if (maxIndex\
    \ == n - 1) {\n            if (minIndex == 0) return true\n            else return\
    \ false\n        }\n        if (maxIndex - minIndex == n - 1) return true\n  \
    \      else return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd39lmhk_.scala:45)\n\tat Problem.main(tmpd39lmhk_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        var i = 0\n        var j = n - 1\n        while (i < n - 1 && arr(i)\
    \ <= arr(i + 1)) i += 1\n        while (j > 0 && arr(j) >= arr(j - 1)) j -= 1\n\
    \        if (i == n - 1) return true\n        if (j == 0) return false\n     \
    \   if (i < j) return false\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkl7rhf91.scala:38)\n\tat Problem.main(tmpkl7rhf91.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val max = arr.max\n        val min = arr.min\n        if (max - min +\
    \ 1 == n) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp18pe3ei.scala:35)\n\tat Problem.main(tmpp18pe3ei.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // We will use a stack to keep track of the elements\
    \ in the array.\n        // We will start from the first element in the array\
    \ and push it onto the stack.\n        // We will then iterate through the array\
    \ and keep pushing elements onto the stack\n        // until we find an element\
    \ that is less than the top element in the stack.\n        // When we find such\
    \ an element, we will pop elements from the stack until we find\n        // an\
    \ element that is greater than the current element.\n        // If the stack is\
    \ empty after popping elements, we will push the current element\n        // onto\
    \ the stack.\n        // If the stack is not empty after popping elements, we\
    \ will check if the current\n        // element is greater than the top element\
    \ in the stack. If it is, we will push\n        // the current element onto the\
    \ stack. If it is not, we will return false.\n        // If we reach the end of\
    \ the array, we will return true.\n        val stack = new Stack[Long]\n     \
    \   stack.push(arr(0))\n        for (i <- 1 until arr.length) {\n            while\
    \ (!stack.isEmpty && stack.top > arr(i)) {\n                stack.pop\n      \
    \      }\n            if (stack.isEmpty) {\n                stack.push(arr(i))\n\
    \            } else if (stack.top < arr(i)) {\n                stack.push(arr(i))\n\
    \            } else {\n                return false\n            }\n        }\n\
    \        true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph5s4rwgn.scala:57)\n\tat Problem.main(tmph5s4rwgn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val max = arr.max\n        val min = arr.min\n        val maxIndex =\
    \ arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n        if (maxIndex\
    \ == n - 1) return true\n        if (minIndex == 0) return false\n        if (maxIndex\
    \ == n - 2) return true\n        if (minIndex == 1) return false\n        if (maxIndex\
    \ == n - 3) return true\n        if (minIndex == 2) return false\n        if (maxIndex\
    \ == n - 4) return true\n        if (minIndex == 3) return false\n        if (maxIndex\
    \ == n - 5) return true\n        if (minIndex == 4) return false\n        if (maxIndex\
    \ == n - 6) return true\n        if (minIndex == 5) return false\n        if (maxIndex\
    \ == n - 7) return true\n        if (minIndex == 6) return false\n        if (maxIndex\
    \ == n - 8) return true\n        if (minIndex == 7) return false\n        if (maxIndex\
    \ == n - 9) return true\n        if (minIndex == 8) return false\n        if (maxIndex\
    \ == n - 10) return true\n        if (minIndex == 9) return false\n        if\
    \ (maxIndex == n - 11) return true\n        if (minIndex == 10) return false\n\
    \        if (maxIndex == n - 12) return true\n        if (minIndex == 11) return\
    \ false\n        if (maxIndex == n - 13) return true\n        if (minIndex ==\
    \ 12) return false\n        if (maxIndex == n - 14) return true\n        if (minIndex\
    \ == 13) return false\n        if (maxIndex == n - 15) return true\n        if\
    \ (minIndex == 14) return false\n        if (maxIndex == n - 16) return true\n\
    \        if (minIndex == 15) return false\n        if (maxIndex == n - 17) return\
    \ true\n        if (minIndex == 16) return false\n        if (maxIndex == n -\
    \ 18) return true\n        if (minIndex == 17) return false\n        if (maxIndex\
    \ == n - 19) return true\n        if (minIndex ==\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkfwgnuxw.scala:69:23 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mif\e[0m (minIndex ==\n\e[31m\e[31m   |\e\
    [0m                       ^\e[0m\n\e[31m   |\e[0m                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797865
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x =>\
    \ x._1 - x._2).toArray\n        val max = diff.max\n        val min = diff.min\n\
    \        if (max - min > 1) return false\n        if (max == min) return true\n\
    \        val maxCount = diff.count(_ == max)\n        val minCount = diff.count(_\
    \ == min)\n        if (maxCount == 1 && minCount == n - 1) return true\n     \
    \   if (maxCount == n - 1 && minCount == 1) return true\n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpewdf5jvx.scala:41)\n\tat Problem.main(tmpewdf5jvx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797869
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) return true\n        if (maxIndex == arr.length -\
    \ 1) return true\n        if (minIndex > maxIndex) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp02cam_u4.scala:40)\n\tat Problem.main(tmp02cam_u4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwnut30q1.scala:38)\n\tat Problem.main(tmpwnut30q1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val minPos = arr.indexOf(min)\n        val maxPos = arr.indexOf(max)\n\
    \        if (minPos == 0) return true\n        if (maxPos == n - 1) return true\n\
    \        if (maxPos < minPos) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprqxjub6h.scala:41)\n\tat Problem.main(tmprqxjub6h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        var count = 0\n        for (i <- 0 until\
    \ n) {\n            if (arr(i) != sorted(i)) count += 1\n        }\n        if\
    \ (count == 0) return true\n        if (count == 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplato3up9.scala:38)\n\tat Problem.main(tmplato3up9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwnut30q1.scala:38)\n\tat Problem.main(tmpwnut30q1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val minIndex = arr.indexOf(min)\n        val maxIndex\
    \ = arr.indexOf(max)\n        val minDistance = minIndex\n        val maxDistance\
    \ = n - maxIndex - 1\n        if (minDistance == maxDistance) return true\n  \
    \      else if (minDistance > maxDistance) return false\n        else {\n    \
    \        val maxDistance2 = n - minIndex - 1\n            if (maxDistance2 > maxDistance)\
    \ return false\n            else return true\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_kne9atx.scala:44)\n\tat Problem.main(tmp_kne9atx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        var i = 0\n        var j = n - 1\n        while (i < n - 1 && arr(i)\
    \ <= arr(i + 1)) i += 1\n        while (j > 0 && arr(j) >= arr(j - 1)) j -= 1\n\
    \        if (i == n - 1) return true\n        if (i == j) return false\n     \
    \   var k = i + 1\n        while (k <= j) {\n            if (arr(k) < arr(k -\
    \ 1)) return false\n            k += 1\n        }\n        return true\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv6zya491.scala:42)\n\tat Problem.main(tmpv6zya491.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val sorted_arr = sorted.toArray\n  \
    \      val arr_arr = arr.toArray\n        val dp = Array.ofDim[Boolean](n, n)\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == j) dp(i)(j) = true\n                else dp(i)(j) = false\n\
    \            }\n        }\n        for (i <- 0 until n) {\n            for (j\
    \ <- 0 until n) {\n                if (i == j) dp(i)(j) = true\n             \
    \   else if (i + 1 == j) {\n                    if (sorted_arr(i) == arr_arr(j)\
    \ || sorted_arr(j) == arr_arr(i)) dp(i)(j) = true\n                    else dp(i)(j)\
    \ = false\n                }\n                else {\n                    if (sorted_arr(i)\
    \ == arr_arr(j) || sorted_arr(j) == arr_arr(i)) dp(i)(j) = dp(i + 1)(j - 1)\n\
    \                    else dp(i)(j) = false\n                }\n            }\n\
    \        }\n        dp(0)(n - 1)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length\
    \ 5\n\tat Problem$.moveOneBall$$anonfun$2$$anonfun$1(tmprnwxcrfr.scala:46)\n\t\
    at scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall$$anonfun$2(tmprnwxcrfr.scala:49)\n\
    \tat scala.runtime.java8.JFunction1$mcVI$sp.apply(JFunction1$mcVI$sp.scala:18)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.moveOneBall(tmprnwxcrfr.scala:50)\n\
    \tat Problem$.main(tmprnwxcrfr.scala:54)\n\tat Problem.main(tmprnwxcrfr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797869
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        var i = 0\n        var j = n - 1\n        while (i < n - 1 && arr(i)\
    \ <= arr(i + 1)) i += 1\n        while (j > 0 && arr(j) >= arr(j - 1)) j -= 1\n\
    \        if (i == n - 1) return true\n        if (j == 0) return false\n     \
    \   var k = i + 1\n        while (k <= j) {\n            if (arr(k) < arr(k -\
    \ 1)) return false\n            k += 1\n        }\n        return true\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprdmbojfa.scala:42)\n\tat Problem.main(tmprdmbojfa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val sorted = arr.sorted\n\
    \        val n = arr.length\n        for (i <- 0 until n) {\n            val shifted\
    \ = arr.slice(i, n) ++ arr.slice(0, i)\n            if (shifted == sorted) return\
    \ true\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val minIndex = arr.indexOf(min)\n        val\
    \ max = arr.max\n        val maxIndex = arr.indexOf(max)\n        val sorted =\
    \ arr.sorted\n        if (minIndex == 0 && maxIndex == n - 1) return true\n  \
    \      if (minIndex == 0 && maxIndex != n - 1) return false\n        if (minIndex\
    \ != 0 && maxIndex == n - 1) return true\n        if (minIndex != 0 && maxIndex\
    \ != n - 1) return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpezcn_ccv.scala:36:8\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mif\e[0m (minIndex\
    \ != \e[31m0\e[0m && maxIndex != n - \e[31m1\e[0m) \e[33mreturn\e[0m \e[31mfalse\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: Boolean\n\
    \e[31m   |\e[0m        Maybe you are missing an else part for the conditional?\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797865
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val diff = (0 until n).map(i => sorted(i)\
    \ - arr(i)).toList\n        val max = diff.max\n        val min = diff.min\n \
    \       if (max - min > 1) return false\n        val minCount = diff.count(_ ==\
    \ min)\n        val maxCount = diff.count(_ == max)\n        if (minCount == n\
    \ - 1 && maxCount == 1) return true\n        if (minCount == 1 && maxCount ==\
    \ n - 1) return true\n        if (minCount == n) return true\n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpos9va_aj.scala:41)\n\tat Problem.main(tmpos9va_aj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val minIndex = arr.indexOf(min)\n        val\
    \ max = arr.max\n        val maxIndex = arr.indexOf(max)\n        val sorted =\
    \ arr.sorted\n        if (minIndex == 0 && maxIndex == n - 1) return true\n  \
    \      if (minIndex == 0 && maxIndex == n - 2) return true\n        if (minIndex\
    \ == 1 && maxIndex == n - 1) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyd9o74tj.scala:39)\n\tat Problem.main(tmpyd9o74tj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797869
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val max = sorted.last\n        val min\
    \ = sorted.head\n        val maxIndex = arr.indexOf(max)\n        val minIndex\
    \ = arr.indexOf(min)\n        if (maxIndex == n - 1) return true\n        if (minIndex\
    \ == 0) return true\n        if (maxIndex == n - 2 && minIndex == 1) return true\n\
    \        return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph7aklkhk.scala:39)\n\tat Problem.main(tmph7aklkhk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val max = arr.max\n        val minIndex =\
    \ arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        val minIndex2\
    \ = arr.lastIndexOf(min)\n        val maxIndex2 = arr.lastIndexOf(max)\n     \
    \   if (minIndex == maxIndex) return true\n        if (minIndex == 0) return true\n\
    \        if (maxIndex == n - 1) return true\n        if (minIndex2 == maxIndex2)\
    \ return true\n        if (minIndex2 == 0) return true\n        if (maxIndex2\
    \ == n - 1) return true\n        false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0ft6resn.scala:43)\n\tat Problem.main(tmp0ft6resn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        var min = arr.head\n\
    \        var max = arr.head\n        for (i <- arr) {\n            if (i < min)\
    \ min = i\n            if (i > max) max = i\n        }\n        if (max - min\
    \ == arr.length - 1) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp152kv0rm.scala:38)\n\tat Problem.main(tmp152kv0rm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797876
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var max = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < max) return\
    \ false\n            max = max max arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo3e7acm0.scala:35)\n\tat Problem.main(tmpo3e7acm0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797877
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        for (i <- 0 until n) {\n           \
    \ val j = (i + 1) % n\n            if (arr(j) < arr(i)) return false\n       \
    \ }\n        return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8xj1jabq.scala:36)\n\tat Problem.main(tmp8xj1jabq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val sorted = arr.sorted\n\
    \        val min = sorted.head\n        val max = sorted.last\n        val minIndex\
    \ = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        if (minIndex\
    \ == 0) {\n            if (maxIndex == arr.length - 1) return true\n         \
    \   else return false\n        }\n        else if (maxIndex == arr.length - 1)\
    \ return false\n        else {\n            val subList = arr.slice(minIndex,\
    \ maxIndex + 1)\n            val subSorted = subList.sorted\n            if (subList\
    \ == subSorted) return true\n            else return false\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo6z7yxp5.scala:47)\n\tat Problem.main(tmpo6z7yxp5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        var min = arr(0)\n        for (i <- 1 until n) {\n            if (arr(i)\
    \ < min) return false\n            min = min min arr(i)\n        }\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfcl9vard.scala:36)\n\tat Problem.main(tmpfcl9vard.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // We will use a greedy algorithm.\n        // We will\
    \ iterate through the array and find the smallest element.\n        // We will\
    \ then move the smallest element to the front of the array.\n        // We will\
    \ then repeat the process until the array is sorted.\n        // If we can't find\
    \ the smallest element in the array, then we will return\n        // false.\n\
    \        // We will use a list to store the indices of the array.\n        //\
    \ We will then remove the index of the smallest element from the list.\n     \
    \   // We will then move the smallest element to the front of the array.\n   \
    \     // We will then repeat the process until the list is empty.\n        //\
    \ If we can't find the smallest element in the list, then we will return\n   \
    \     // false.\n        // We will use a list to store the indices of the array.\n\
    \        val indices = (0 until arr.length).toList\n        // We will then remove\
    \ the index of the smallest element from the list.\n        // We will then move\
    \ the smallest element to the front of the array.\n        // We will then repeat\
    \ the process until the list is empty.\n        // If we can't find the smallest\
    \ element in the list, then we will return\n        // false.\n        def moveOneBallHelper(arr\
    \ : List[Long], indices : List[Int]) : Boolean = {\n            // We will then\
    \ remove the index of the smallest element from the list.\n            // We will\
    \ then move the smallest element to the front of the array.\n            // We\
    \ will then repeat the process until the list is empty.\n            // If we\
    \ can't find the smallest element in the list, then we will return\n         \
    \   // false.\n            if (indices.isEmpty) {\n                // We will\
    \ then repeat the process until the list is empty.\n                // If we can't\
    \ find the smallest element in the list, then we will return\n               \
    \ // false.\n                true\n            } else {\n                // We\
    \ will then move the smallest element to the front of the array.\n           \
    \     // We will then repeat the process until the list is empty.\n          \
    \      // If we can't find the smallest element in the list, then we will return\n\
    \                // false.\n                // We will then remove the index of\
    \ the smallest element from the list.\n                // We will then move the\
    \ smallest element\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0ej4u7nh.scala:73:0 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0ej4u7nh.scala:72:1\
    \ ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp0ej4u7nh.scala:64:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m64 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1659797878
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x =>\
    \ x._1 - x._2).toList\n        val max = diff.max\n        val min = diff.min\n\
    \        if (max - min > 1) return false\n        val diffCount = diff.groupBy(identity).mapValues(_.size)\n\
    \        if (diffCount.contains(0)) return true\n        if (diffCount.contains(1)\
    \ && diffCount.contains(-1)) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4xn6uf1j.scala:39)\n\tat Problem.main(tmp4xn6uf1j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val max = arr.max\n        if (min == max)\
    \ return true\n        val minIndex = arr.indexOf(min)\n        val maxIndex =\
    \ arr.indexOf(max)\n        if (minIndex == 0) return true\n        if (maxIndex\
    \ == n - 1) return true\n        if (minIndex > maxIndex) return true\n      \
    \  return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_wk9qgsq.scala:41)\n\tat Problem.main(tmp_wk9qgsq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val map = HashMap[Long, Int]()\n   \
    \     for (i <- 0 until n) {\n            map(arr(i)) = i\n        }\n       \
    \ var i = 0\n        while (i < n) {\n            if (arr(i) != sorted(i)) {\n\
    \                val j = map(sorted(i))\n                if (j == i) return false\n\
    \                val temp = arr(j)\n                arr(j) = arr(i)\n        \
    \        arr(i) = temp\n                map(arr(j)) = j\n                map(arr(i))\
    \ = i\n            }\n            i += 1\n        }\n        true\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc38bbb6j.scala:39:16 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                arr(j) = arr(i)\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc38bbb6j.scala:40:16\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                arr(i) =\
    \ temp\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value\
    \ update is not a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min + 1 == arr.length) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgv9miu1e.scala:38)\n\tat Problem.main(tmpgv9miu1e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val sorted = arr.sorted\n\
    \        val min = arr.min\n        val max = arr.max\n        val minIndex =\
    \ arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        val sortedMinIndex\
    \ = sorted.indexOf(min)\n        val sortedMaxIndex = sorted.indexOf(max)\n  \
    \      if (minIndex == sortedMinIndex && maxIndex == sortedMaxIndex) return true\n\
    \        if (minIndex == sortedMinIndex && maxIndex != sortedMaxIndex) return\
    \ false\n        if (minIndex != sortedMinIndex && maxIndex == sortedMaxIndex)\
    \ return false\n        if (minIndex != sortedMinIndex && maxIndex != sortedMaxIndex)\
    \ return false\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxhoqyjoj.scala:41)\n\tat Problem.main(tmpxhoqyjoj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) {\n            if (maxIndex == arr.length - 1) return\
    \ true\n            else return false\n        }\n        if (maxIndex == arr.length\
    \ - 1) {\n            if (minIndex == 0) return true\n            else return\
    \ false\n        }\n        if (minIndex < maxIndex) return false\n        else\
    \ return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpea3o9c07.scala:46)\n\tat Problem.main(tmpea3o9c07.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        else\
    \ return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp390_1h0q.scala:38)\n\tat Problem.main(tmp390_1h0q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val max = arr.max\n        val min = arr.min\n        if (max - min +\
    \ 1 == n) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp18pe3ei.scala:35)\n\tat Problem.main(tmpp18pe3ei.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (min == 1 && max == arr.length) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl5d4bdwx.scala:38)\n\tat Problem.main(tmpl5d4bdwx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (min == max) return true\n        var count = 0\n     \
    \   for (i <- 0 until arr.length) {\n            if (arr(i) == min) count += 1\n\
    \        }\n        if (count > 1) return false\n        return true\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpq_i_l2i5.scala:44)\n\tat Problem.main(tmpq_i_l2i5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val max = sorted.last\n        val min = sorted.head\n\
    \        val maxIndex = arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n\
    \        if (maxIndex == 0) return true\n        if (minIndex == arr.length -\
    \ 1) return true\n        if (maxIndex == arr.length - 1) return false\n     \
    \   if (minIndex == 0) return false\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7k110yvj.scala:41)\n\tat Problem.main(tmp7k110yvj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val min = arr.min\n\
    \        val minIndex = arr.indexOf(min)\n        val max = arr.max\n        val\
    \ maxIndex = arr.indexOf(max)\n        if (minIndex == 0) {\n            return\
    \ true\n        } else if (maxIndex == arr.length - 1) {\n            return false\n\
    \        } else {\n            val newArr = arr.slice(minIndex, maxIndex + 1)\n\
    \            val newMin = newArr.min\n            val newMinIndex = newArr.indexOf(newMin)\n\
    \            val newMax = newArr.max\n            val newMaxIndex = newArr.indexOf(newMax)\n\
    \            if (newMinIndex == 0 && newMaxIndex == newArr.length - 1) {\n   \
    \             return true\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\
    \tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\
    \tat Problem$.moveOneBall(tmpe8skhyej.scala:37)\n\tat Problem$.main(tmpe8skhyej.scala:49)\n\
    \tat Problem.main(tmpe8skhyej.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (min == max) return true\n        var count = 0\n     \
    \   for (i <- 0 until arr.length) {\n            if (arr(i) == min) count += 1\n\
    \        }\n        if (count == arr.length) return true\n        count = 0\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) == max) count\
    \ += 1\n        }\n        if (count == arr.length) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb9ji038i.scala:47)\n\tat Problem.main(tmpb9ji038i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val max = arr.max\n        val minIndex =\
    \ arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        if (minIndex\
    \ == 0) {\n            if (maxIndex == n - 1) return true\n            else return\
    \ false\n        }\n        else if (maxIndex == n - 1) return false\n       \
    \ else {\n            if (minIndex < maxIndex) return true\n            else return\
    \ false\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp36k973c9.scala:43)\n\tat Problem.main(tmp36k973c9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // We will use a greedy algorithm to solve this problem.\n\
    \        // We will start from the left and keep moving to the right.\n      \
    \  // We will keep track of the minimum element seen so far.\n        // If we\
    \ see an element less than the minimum element seen so far,\n        // then we\
    \ cannot get a non-decreasing order.\n        // If we see an element greater\
    \ than the minimum element seen so far,\n        // then we can get a non-decreasing\
    \ order.\n        // The reason is that we can move the element to the left of\
    \ the minimum\n        // element seen so far.\n        // If we see an element\
    \ equal to the minimum element seen so far,\n        // then we can get a non-decreasing\
    \ order.\n        // The reason is that we can move the element to the left of\
    \ the minimum\n        // element seen so far.\n        // If we see an element\
    \ equal to the minimum element seen so far,\n        // then we can get a non-decreasing\
    \ order.\n        // The reason is that we can move the element to the left of\
    \ the minimum\n        // element seen so far.\n        // If we see an element\
    \ equal to the minimum element seen so far,\n        // then we can get a non-decreasing\
    \ order.\n        // The reason is that we can move the element to the left of\
    \ the minimum\n        // element seen so far.\n        // If we see an element\
    \ equal to the minimum element seen so far,\n        // then we can get a non-decreasing\
    \ order.\n        // The reason is that we can move the element to the left of\
    \ the minimum\n        // element seen so far.\n        // If we see an element\
    \ equal to the minimum element seen so far,\n        // then we can get a non-decreasing\
    \ order.\n        // The reason is that we can move the element to the left of\
    \ the minimum\n        // element seen so far.\n        // If we see an element\
    \ equal to the minimum element seen so far,\n        // then we can get a non-decreasing\
    \ order.\n        // The reason is that we can move the element to the left of\
    \ the minimum\n        // element seen so far.\n        // If we see an element\
    \ equal to the minimum element seen so far,\n        // then we can get a non-decre\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4odg9lkm.scala:25:50\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mmoveOneBall\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mBoolean\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Unit\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m26 |\e[0m        \e[34m// We will use a greedy algorithm to solve\
    \ this problem.\e[0m\n\e[31m27 |\e[0m        \e[34m// We will start from the left\
    \ and keep moving to the right.\e[0m\n\e[31m28 |\e[0m        \e[34m// We will\
    \ keep track of the minimum element seen so far.\e[0m\n\e[31m29 |\e[0m       \
    \ \e[34m// If we see an element less than the minimum element seen so far,\e[0m\n\
    \e[31m30 |\e[0m        \e[34m// then we cannot get a non-decreasing order.\e[0m\n\
    \e[31m31 |\e[0m        \e[34m// If we see an element greater than the minimum\
    \ element seen so far,\e[0m\n\e[31m32 |\e[0m        \e[34m// then we can get a\
    \ non-decreasing order.\e[0m\n\e[31m33 |\e[0m        \e[34m// The reason is that\
    \ we can move the element to the left of the minimum\e[0m\n\e[31m34 |\e[0m   \
    \     \e[34m// element seen so far.\e[0m\n\e[31m35 |\e[0m        \e[34m// If we\
    \ see an element equal to the minimum element seen so far,\e[0m\n\e[31m36 |\e\
    [0m        \e[34m// then we can get a non-decreasing order.\e[0m\n\e[31m37 |\e\
    [0m        \e[34m// The reason is that we can move the element to the left of\
    \ the minimum\e[0m\n\e[31m38 |\e[0m        \e[34m// element seen so far.\e[0m\n\
    \e[31m39 |\e[0m        \e[34m// If we see an element equal to the minimum element\
    \ seen so far,\e[0m\n\e[31m40 |\e[0m        \e[34m// then we can get a non-decreasing\
    \ order.\e[0m\n\e[31m41 |\e[0m        \e[34m// The reason is that we can move\
    \ the element to the left of the minimum\e[0m\n\e[31m42 |\e[0m        \e[34m//\
    \ element seen so far.\e[0m\n\e[31m43 |\e[0m        \e[34m// If we see an element\
    \ equal to the minimum element seen so far,\e[0m\n\e[31m44 |\e[0m        \e[34m//\
    \ then we can get a non-decreasing order.\e[0m\n\e[31m45"
  stdout: ''
  timestamp: 1659797878
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // Fill up this function body\n        // 'arr' is a\
    \ list of integers.\n        // 'arr' is guaranteed to have unique elements.\n\
    \        // 'arr' is guaranteed to have at least one element.\n        // 'arr'\
    \ is guaranteed to be non-empty.\n        // 'arr' is guaranteed to be sorted\
    \ in non-decreasing order.\n        // 'arr' is guaranteed to have at least one\
    \ element.\n        // 'arr' is guaranteed to be non-empty.\n        // 'arr'\
    \ is guaranteed to be sorted in non-decreasing order.\n        // 'arr' is guaranteed\
    \ to have at least one element.\n        // 'arr' is guaranteed to be non-empty.\n\
    \        // 'arr' is guaranteed to be sorted in non-decreasing order.\n      \
    \  // 'arr' is guaranteed to have at least one element.\n        // 'arr' is guaranteed\
    \ to be non-empty.\n        // 'arr' is guaranteed to be sorted in non-decreasing\
    \ order.\n        // 'arr' is guaranteed to have at least one element.\n     \
    \   // 'arr' is guaranteed to be non-empty.\n        // 'arr' is guaranteed to\
    \ be sorted in non-decreasing order.\n        // 'arr' is guaranteed to have at\
    \ least one element.\n        // 'arr' is guaranteed to be non-empty.\n      \
    \  // 'arr' is guaranteed to be sorted in non-decreasing order.\n        // 'arr'\
    \ is guaranteed to have at least one element.\n        // 'arr' is guaranteed\
    \ to be non-empty.\n        // 'arr' is guaranteed to be sorted in non-decreasing\
    \ order.\n        // 'arr' is guaranteed to have at least one element.\n     \
    \   // 'arr' is guaranteed to be non-empty.\n        // 'arr' is guaranteed to\
    \ be sorted in non-decreasing order.\n        // 'arr' is guaranteed to have at\
    \ least one element.\n        // 'arr' is guaranteed to be non-empty.\n      \
    \  // 'arr' is guaranteed to be sorted in non-decreasing order.\n        // 'arr'\
    \ is guaranteed to have at least one element.\n        // 'arr' is guaranteed\
    \ to be non-empty.\n        // 'arr' is guaranteed to be sorted in non-decreasing\
    \ order\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpflpd450p.scala:25:50\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mmoveOneBall\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mBoolean\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Unit\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m26 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e\
    [31m27 |\e[0m        \e[34m// 'arr' is a list of integers.\e[0m\n\e[31m28 |\e\
    [0m        \e[34m// 'arr' is guaranteed to have unique elements.\e[0m\n\e[31m29\
    \ |\e[0m        \e[34m// 'arr' is guaranteed to have at least one element.\e[0m\n\
    \e[31m30 |\e[0m        \e[34m// 'arr' is guaranteed to be non-empty.\e[0m\n\e\
    [31m31 |\e[0m        \e[34m// 'arr' is guaranteed to be sorted in non-decreasing\
    \ order.\e[0m\n\e[31m32 |\e[0m        \e[34m// 'arr' is guaranteed to have at\
    \ least one element.\e[0m\n\e[31m33 |\e[0m        \e[34m// 'arr' is guaranteed\
    \ to be non-empty.\e[0m\n\e[31m34 |\e[0m        \e[34m// 'arr' is guaranteed to\
    \ be sorted in non-decreasing order.\e[0m\n\e[31m35 |\e[0m        \e[34m// 'arr'\
    \ is guaranteed to have at least one element.\e[0m\n\e[31m36 |\e[0m        \e\
    [34m// 'arr' is guaranteed to be non-empty.\e[0m\n\e[31m37 |\e[0m        \e[34m//\
    \ 'arr' is guaranteed to be sorted in non-decreasing order.\e[0m\n\e[31m38 |\e\
    [0m        \e[34m// 'arr' is guaranteed to have at least one element.\e[0m\n\e\
    [31m39 |\e[0m        \e[34m// 'arr' is guaranteed to be non-empty.\e[0m\n\e[31m40\
    \ |\e[0m        \e[34m// 'arr' is guaranteed to be sorted in non-decreasing order.\e\
    [0m\n\e[31m41 |\e[0m        \e[34m// 'arr' is guaranteed to have at least one\
    \ element.\e[0m\n\e[31m42 |\e[0m        \e[34m// 'arr' is guaranteed to be non-empty.\e\
    [0m\n\e[31m43 |\e[0m        \e[34m// 'arr' is guaranteed to be sorted in non-decreasing\
    \ order.\e[0m\n\e[31m44 |\e[0m        \e[34m// 'arr' is guaranteed to have at\
    \ least one element.\e[0m\n\e[31m45 |\e[0m        \e[34m// 'arr' is guaranteed\
    \ to be non-empty.\e[0m\n\e[31m46 |\e[0m        \e[3"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val n = arr.length\n\
    \        val max = arr.max\n        val min = arr.min\n        val maxIndex =\
    \ arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n        if (maxIndex\
    \ == n - 1) {\n            if (minIndex == 0) return true\n            else return\
    \ false\n        }\n        else {\n            if (minIndex == 0) return false\n\
    \            else return true\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_a2okcdx.scala:44)\n\tat Problem.main(tmp_a2okcdx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x =>\
    \ x._1 - x._2).toList\n        val max = diff.max\n        val min = diff.min\n\
    \        if (max - min > 1) return false\n        if (max == min) return true\n\
    \        val maxIndex = diff.indexOf(max)\n        val minIndex = diff.indexOf(min)\n\
    \        if (maxIndex == 0) return true\n        if (minIndex == n - 1) return\
    \ true\n        if (maxIndex - minIndex == 1) return true\n        return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd4y9l9j1.scala:42)\n\tat Problem.main(tmpd4y9l9j1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        var i = 0\n        while (i < n - 1) {\n            if (arr(i) > arr(i\
    \ + 1)) return false\n            i += 1\n        }\n        return true\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv3toedlr.scala:36)\n\tat Problem.main(tmpv3toedlr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797888
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        var i = 0\n        var j = 0\n        while (i < n - 1) {\n         \
    \   if (arr(i) > arr(i + 1)) {\n                j = i + 1\n                while\
    \ (j < n - 1 && arr(j) > arr(j + 1)) j += 1\n                if (j == n - 1) return\
    \ false\n                else {\n                    val temp = arr(j)\n     \
    \               for (k <- j to i by -1) arr(k) = arr(k - 1)\n                \
    \    arr(i) = temp\n                }\n            }\n            i += 1\n   \
    \     }\n        true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp39zm3r5j.scala:37:44 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                    \e[33mfor\e[0m (k <- j to i by -\e\
    [31m1\e[0m) arr(k) = arr(k - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            \
    \                                ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp39zm3r5j.scala:38:20 ------------------------\e[0m\e[0m\n\
    \e[31m38 |\e[0m                    arr(i) = temp\n\e[31m\e[31m   |\e[0m      \
    \              ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1659797887
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val max = arr.max\n        val minIndex =\
    \ arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        if (minIndex\
    \ == 0) {\n            if (maxIndex == n - 1) return true\n            else return\
    \ false\n        }\n        else {\n            if (maxIndex == n - 1) return\
    \ false\n            else return true\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpflrf4uom.scala:44)\n\tat Problem.main(tmpflrf4uom.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797889
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val sorted = arr.sorted\n\
    \        val min = sorted.head\n        val max = sorted.last\n        val minIndex\
    \ = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        if (minIndex\
    \ == 0) return true\n        if (maxIndex == arr.length - 1) return true\n   \
    \     val left = arr.slice(0, minIndex)\n        val right = arr.slice(minIndex,\
    \ arr.length)\n        if (left.sorted == left && right.sorted == right) return\
    \ true\n        return false\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 0 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpivabpuft.scala:38)\n\tat Problem.main(tmpivabpuft.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min + 1 == arr.length) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgv9miu1e.scala:38)\n\tat Problem.main(tmpgv9miu1e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        var sorted = arr.sorted\n        var count = 0\n    \
    \    for (i <- 0 until arr.length) {\n            if (arr(i) != sorted(i)) count\
    \ += 1\n        }\n        if (count > 2) return false\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3cftk2q_.scala:35)\n\tat Problem.main(tmp3cftk2q_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val m = arr.max\n        val min = arr.min\n        if (m - min + 1 ==\
    \ n) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwjq6l67t.scala:35)\n\tat Problem.main(tmpwjq6l67t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) {\n            return true\n   \
    \     }\n        val sorted = arr.sorted\n        val min = sorted.head\n    \
    \    val max = sorted.last\n        val minIndex = arr.indexOf(min)\n        val\
    \ maxIndex = arr.indexOf(max)\n        if (minIndex == 0) {\n            return\
    \ true\n        }\n        if (maxIndex == arr.length - 1) {\n            return\
    \ true\n        }\n        if (minIndex > maxIndex) {\n            return true\n\
    \        }\n        return false\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppiw7xf22.scala:48)\n\tat Problem.main(tmppiw7xf22.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // Fill up this function body\n        // 'arr' is a\
    \ list of integers\n        // 'true' if it is possible to get a non-decreasing\
    \ array by performing\n        // right shift operation any number of times\n\
    \        // 'false' otherwise\n        // You can use the 'readLine' function\
    \ to read input from the standard input\n        // device. e.g.\n        // val\
    \ a_line = readLine()\n        // val b_line = readLine()\n        // val a =\
    \ a_line.toInt\n        // val b = b_line.toInt\n        // val c = a + b\n  \
    \      // println(c)\n        // The above code reads two integer numbers from\
    \ the standard input device and\n        // prints their sum to the standard output\
    \ device.\n        // Write your code here\n        val n = arr.length\n     \
    \   if (n == 0) return true\n        val a = arr.toArray\n        val b = new\
    \ Array[Long](n)\n        for (i <- 0 until n) b(i) = a(i)\n        scala.util.Sorting.quickSort(b)\n\
    \        var i = 0\n        while (i < n && a(i) == b(i)) i += 1\n        if (i\
    \ == n) return true\n        var j = i + 1\n        while (j < n && a(j) == b(i))\
    \ j += 1\n        if (j == n) return false\n        var k = j + 1\n        while\
    \ (k < n && a(k) == b(j)) k += 1\n        if (k == n) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2v4_vxzw.scala:60)\n\tat Problem.main(tmp2v4_vxzw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val max = arr.max\n        val min = arr.min\n        if (max - min +\
    \ 1 == n) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp18pe3ei.scala:35)\n\tat Problem.main(tmpp18pe3ei.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwnut30q1.scala:38)\n\tat Problem.main(tmpwnut30q1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val minIndex = arr.indexOf(min)\n        val maxIndex\
    \ = arr.indexOf(max)\n        if (minIndex == 0) return true\n        if (maxIndex\
    \ == n - 1) return true\n        if (minIndex == n - 1) return true\n        if\
    \ (maxIndex == 0) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw5inzodc.scala:40)\n\tat Problem.main(tmpw5inzodc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min + 1 == arr.length) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgv9miu1e.scala:38)\n\tat Problem.main(tmpgv9miu1e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val arr2 = arr.toArray\n        val arr3 = arr.toArray\n        var i\
    \ = 0\n        while (i < n) {\n            arr2(i) = arr(i)\n            arr3(i)\
    \ = arr(i)\n            i += 1\n        }\n        scala.util.Sorting.quickSort(arr2)\n\
    \        i = 0\n        while (i < n) {\n            if (arr2(i) != arr3(i)) {\n\
    \                var j = i + 1\n                while (j < n) {\n            \
    \        if (arr2(i) == arr3(j)) {\n                        var k = j\n      \
    \                  while (k > i) {\n                            val temp = arr3(k)\n\
    \                            arr3(k) = arr3(k - 1)\n                         \
    \   arr3(k - 1) = temp\n                            k -= 1\n                 \
    \       }\n                        break\n                    }\n            \
    \        j += 1\n                }\n            }\n            i += 1\n      \
    \  }\n        i = 0\n        while (i < n) {\n            if (arr2(i) != arr3(i))\
    \ return false\n            i += 1\n        }\n        return true\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp256tybgk.scala:50:24 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797887
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val arr2 =\
    \ arr.sorted\n        val arr3 = arr.reverse.sorted\n        var i = 0\n     \
    \   while (i < arr.length) {\n            if (arr2(i) != arr(i) && arr3(i) !=\
    \ arr(i)) return false\n            i += 1\n        }\n        return true\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiattxpqq.scala:37)\n\tat Problem.main(tmpiattxpqq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   min = min min arr(i)\n            max = max max arr(i)\n        }\n      \
    \  if (max - min + 1 == arr.length) return true\n        else return false\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyn3gox8z.scala:38)\n\tat Problem.main(tmpyn3gox8z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) return true\n        if (maxIndex == arr.length -\
    \ 1) return true\n        if (minIndex < maxIndex) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy2u4_f5m.scala:38)\n\tat Problem.main(tmpy2u4_f5m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val a = arr.toArray\n        val b = arr.sorted.toArray\n        var\
    \ i = 0\n        while (i < n) {\n            if (a(i) != b(i)) return false\n\
    \            i += 1\n        }\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp07jtdf37.scala:38)\n\tat Problem.main(tmp07jtdf37.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) return true\n        if (maxIndex == arr.length -\
    \ 1) return true\n        if (minIndex > maxIndex) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp02cam_u4.scala:40)\n\tat Problem.main(tmp02cam_u4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwnut30q1.scala:38)\n\tat Problem.main(tmpwnut30q1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val arr2 = arr.toArray\n        for (i <- 0 until n) {\n            var\
    \ j = i\n            while (j > 0 && arr2(j) < arr2(j - 1)) {\n              \
    \  val temp = arr2(j)\n                arr2(j) = arr2(j - 1)\n               \
    \ arr2(j - 1) = temp\n                j -= 1\n            }\n        }\n     \
    \   for (i <- 0 until n - 1) {\n            if (arr2(i) > arr2(i + 1)) return\
    \ false\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe59ogq2d.scala:46)\n\tat Problem.main(tmpe59ogq2d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val sorted = arr.sorted\n\
    \        val min = sorted.head\n        val max = sorted.last\n        val minIndex\
    \ = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        if (minIndex\
    \ == 0) return true\n        if (maxIndex == arr.length - 1) return true\n   \
    \     if (minIndex > maxIndex) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl2ns0rii.scala:40)\n\tat Problem.main(tmpl2ns0rii.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797891
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (min == max) return true\n        var count = 0\n     \
    \   for (i <- 0 until arr.length) {\n            if (arr(i) == min) count += 1\n\
    \        }\n        if (count == arr.length) return true\n        var index =\
    \ -1\n        for (i <- 0 until arr.length) {\n            if (arr(i) == min)\
    \ {\n                index = i\n                break\n            }\n       \
    \ }\n        if (index == -1) return false\n        for (i <- 0 until arr.length)\
    \ {\n            if (arr(i) == max) {\n                if (i < index) return false\n\
    \            }\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprq2a21pg.scala:43:16 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                break\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^\e[0m\n\e[31m   |\e[0m                Not found: break\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659797888
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val max = arr.max\n        if (min == max)\
    \ return true\n        val minIndex = arr.indexOf(min)\n        val maxIndex =\
    \ arr.indexOf(max)\n        if (minIndex == 0) {\n            if (maxIndex ==\
    \ n - 1) return true\n            else return false\n        }\n        if (maxIndex\
    \ == n - 1) {\n            if (minIndex == 0) return true\n            else return\
    \ false\n        }\n        if (minIndex < maxIndex) return false\n        else\
    \ return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6ai3x69r.scala:47)\n\tat Problem.main(tmp6ai3x69r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) return true\n        if (maxIndex == arr.length -\
    \ 1) return true\n        if (minIndex == maxIndex) return true\n        if (minIndex\
    \ < maxIndex) return false\n        if (maxIndex == 0) return true\n        if\
    \ (minIndex == arr.length - 1) return true\n        if (minIndex - maxIndex ==\
    \ 1) return true\n        if (maxIndex - minIndex == 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptqeek17g.scala:45)\n\tat Problem.main(tmptqeek17g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = arr.min\n        val max = arr.max\n       \
    \ val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n \
    \       if (minIndex == maxIndex) return true\n        val minIndexSorted = sorted.indexOf(min)\n\
    \        val maxIndexSorted = sorted.indexOf(max)\n        if (minIndexSorted\
    \ == maxIndexSorted) return true\n        if (minIndexSorted == 0 && maxIndexSorted\
    \ == arr.length - 1) return true\n        if (minIndexSorted == arr.length - 1\
    \ && maxIndexSorted == 0) return true\n        if (minIndexSorted == 0 && maxIndexSorted\
    \ == arr.length - 2) return true\n        if (minIndexSorted == 1 && maxIndexSorted\
    \ == arr.length - 1) return true\n        if (minIndexSorted == arr.length - 2\
    \ && maxIndexSorted == 0) return true\n        if (minIndexSorted == arr.length\
    \ - 1 && maxIndexSorted == 1) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyzmt4wrw.scala:47)\n\tat Problem.main(tmpyzmt4wrw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797891
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val arr2 = arr.zipWithIndex.sortBy(_._1).map(_._2)\n        var max =\
    \ 0\n        for (i <- 0 until n) {\n            max = max.max(arr2(i) - i)\n\
    \        }\n        max <= 1\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpejnpbeab.scala:36)\n\tat Problem.main(tmpejnpbeab.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val max = arr.max\n        val minIndex =\
    \ arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        if (minIndex\
    \ == 0) {\n            if (maxIndex == n - 1) return true\n            else return\
    \ false\n        }\n        else {\n            if (maxIndex == n - 1) return\
    \ false\n            else return true\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpflrf4uom.scala:44)\n\tat Problem.main(tmpflrf4uom.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797889
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // Fill up this function body\n        // 'arr' is a\
    \ list of integers\n        // You have to return a boolean value\n        //\
    \ If it is possible to get the sorted array by performing right shift\n      \
    \  // operations then return True else return False\n        // If the given array\
    \ is empty then return True\n        // The given list is guaranteed to have unique\
    \ elements\n        // You can use the built-in sort function\n        // You\
    \ can use the built-in reverse function\n        // You can use the built-in max\
    \ function\n        // You can use the built-in min function\n        // You can\
    \ use the built-in sum function\n        // You can use the built-in product function\n\
    \        // You can use the built-in size function\n        // You can use the\
    \ built-in head function\n        // You can use the built-in tail function\n\
    \        // You can use the built-in init function\n        // You can use the\
    \ built-in last function\n        // You can use the built-in isEmpty function\n\
    \        // You can use the built-in reverse function\n        // You can use\
    \ the built-in take function\n        // You can use the built-in drop function\n\
    \        // You can use the built-in slice function\n        // You can use the\
    \ built-in splitAt function\n        // You can use the built-in apply function\n\
    \        // You can use the built-in indices function\n        // You can use\
    \ the built-in indices function\n        // You can use the built-in range function\n\
    \        // You can use the built-in range function\n        // You can use the\
    \ built-in until function\n        // You can use the built-in to function\n \
    \       // You can use the built-in by function\n        // You can use the built-in\
    \ mkString function\n        // You can use the built-in mkString function\n \
    \       // You can use the built-in flatten function\n        // You can use the\
    \ built-in flatMap function\n        // You can use the built-in zip function\n\
    \        // You can use the built-in zipWithIndex function\n        // You can\
    \ use the built-in transpose function\n        // You can use the built-in mkString\
    \ function\n        // You can use the built-in unzip function\n        // You\
    \ can use the built-in unzip3 function\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvp8q887u.scala:25:50\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mmoveOneBall\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mBoolean\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Unit\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m26 |\e[0m        \e[34m// Fill up this function body\e[0m\n\e\
    [31m27 |\e[0m        \e[34m// 'arr' is a list of integers\e[0m\n\e[31m28 |\e[0m\
    \        \e[34m// You have to return a boolean value\e[0m\n\e[31m29 |\e[0m   \
    \     \e[34m// If it is possible to get the sorted array by performing right shift\e\
    [0m\n\e[31m30 |\e[0m        \e[34m// operations then return True else return False\e\
    [0m\n\e[31m31 |\e[0m        \e[34m// If the given array is empty then return True\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// The given list is guaranteed to have unique\
    \ elements\e[0m\n\e[31m33 |\e[0m        \e[34m// You can use the built-in sort\
    \ function\e[0m\n\e[31m34 |\e[0m        \e[34m// You can use the built-in reverse\
    \ function\e[0m\n\e[31m35 |\e[0m        \e[34m// You can use the built-in max\
    \ function\e[0m\n\e[31m36 |\e[0m        \e[34m// You can use the built-in min\
    \ function\e[0m\n\e[31m37 |\e[0m        \e[34m// You can use the built-in sum\
    \ function\e[0m\n\e[31m38 |\e[0m        \e[34m// You can use the built-in product\
    \ function\e[0m\n\e[31m39 |\e[0m        \e[34m// You can use the built-in size\
    \ function\e[0m\n\e[31m40 |\e[0m        \e[34m// You can use the built-in head\
    \ function\e[0m\n\e[31m41 |\e[0m        \e[34m// You can use the built-in tail\
    \ function\e[0m\n\e[31m42 |\e[0m        \e[34m// You can use the built-in init\
    \ function\e[0m\n\e[31m43 |\e[0m        \e[34m// You can use the built-in last\
    \ function\e[0m\n\e[31m44 |\e[0m        \e[34m// You can use the built-in isEmpty\
    \ function\e[0m\n\e[31m45 |\e[0m        \e[34m// You can use the built-in reverse\
    \ function\e[0m\n\e[31m46 |\e[0m        \e[34m// You can use the built-in take\
    \ function\e[0m\n\e[31m47 |\e[0m        \e[34m// You can use the bu"
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   min = min min arr(i)\n            max = max max arr(i)\n        }\n      \
    \  if (max - min + 1 == arr.length) return true\n        return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyryalrbx.scala:38)\n\tat Problem.main(tmpyryalrbx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var max = arr(0)\n\
    \        var min = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) > max) max = arr(i)\n            if (arr(i) < min) min = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        else\
    \ return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqauvukdm.scala:38)\n\tat Problem.main(tmpqauvukdm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797898
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x =>\
    \ x._1 - x._2).filter(x => x != 0)\n        if (diff.length == 0) return true\n\
    \        if (diff.length == 1) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpau0fj7zj.scala:35)\n\tat Problem.main(tmpau0fj7zj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        val minDistance = minIndex - 0\n        val maxDistance = arr.length\
    \ - 1 - maxIndex\n        val distance = minDistance + maxDistance\n        if\
    \ (distance >= arr.length - 1) return true\n        else return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp41det1h4.scala:41)\n\tat Problem.main(tmp41det1h4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x =>\
    \ x._1 - x._2).toList\n        val max = diff.max\n        val min = diff.min\n\
    \        if (max == min) return true\n        val maxIndex = diff.indexOf(max)\n\
    \        val minIndex = diff.indexOf(min)\n        if (maxIndex == 0) return false\n\
    \        if (minIndex == n - 1) return false\n        if (maxIndex < minIndex)\
    \ return true\n        if (maxIndex == minIndex + 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_hnpfjnz.scala:42)\n\tat Problem.main(tmp_hnpfjnz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwnut30q1.scala:38)\n\tat Problem.main(tmpwnut30q1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val minIndex = arr.indexOf(min)\n        val maxIndex\
    \ = arr.indexOf(max)\n        if (minIndex == 0 && maxIndex == n - 1) return true\n\
    \        if (minIndex == 0 && maxIndex != n - 1) return false\n        if (minIndex\
    \ != 0 && maxIndex == n - 1) return false\n        if (minIndex != 0 && maxIndex\
    \ != n - 1) return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa_rwhea7.scala:36:8\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mif\e[0m (minIndex\
    \ != \e[31m0\e[0m && maxIndex != n - \e[31m1\e[0m) \e[33mreturn\e[0m \e[31mtrue\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    Unit\n\e[31m   |\e[0m        Required: Boolean\n\
    \e[31m   |\e[0m        Maybe you are missing an else part for the conditional?\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797897
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // We will use a greedy algorithm.\n        // We will\
    \ start from the end of the list and move towards the beginning.\n        // We\
    \ will keep track of the minimum value we have seen so far.\n        // If we\
    \ see a value that is less than the minimum value, then we know that\n       \
    \ // we cannot sort the list.\n        // If we see a value that is greater than\
    \ the minimum value, then we know\n        // that we can sort the list.\n   \
    \     // We will keep track of the minimum value by using a stack.\n        //\
    \ We will push the minimum value onto the stack and pop it off when we see\n \
    \       // a value that is greater than the minimum value.\n        // We will\
    \ start with the minimum value being the maximum value.\n        val stack = new\
    \ Stack[Long]\n        stack.push(Long.MaxValue)\n        for (i <- arr.length\
    \ - 1 to 0 by -1) {\n            if (arr(i) < stack.top) {\n                return\
    \ false\n            } else if (arr(i) > stack.top) {\n                stack.pop\n\
    \            }\n            stack.push(arr(i))\n        }\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjg23fbce.scala:50)\n\tat Problem.main(tmpjg23fbce.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val sorted = arr.sorted\n\
    \        val max = sorted.last\n        val min = sorted.head\n        val maxIndex\
    \ = arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n        if (maxIndex\
    \ == 0) return true\n        if (minIndex == arr.length - 1) return true\n   \
    \     if (maxIndex < minIndex) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf1kuz7jz.scala:40)\n\tat Problem.main(tmpf1kuz7jz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797900
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val sorted = arr.sorted\n\
    \        val min = arr.min\n        val max = arr.max\n        val minIndex =\
    \ arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        val minIndexSorted\
    \ = sorted.indexOf(min)\n        val maxIndexSorted = sorted.indexOf(max)\n  \
    \      if (minIndex == minIndexSorted && maxIndex == maxIndexSorted) return true\n\
    \        if (minIndex == maxIndexSorted && maxIndex == minIndexSorted) return\
    \ true\n        return false\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptbhznzxt.scala:39)\n\tat Problem.main(tmptbhznzxt.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val min = arr.min\n\
    \        val minIndex = arr.indexOf(min)\n        val max = arr.max\n        val\
    \ maxIndex = arr.indexOf(max)\n        if (minIndex == 0) return true\n      \
    \  if (maxIndex == arr.length - 1) return true\n        if (minIndex > maxIndex)\
    \ return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxumccrqd.scala:39)\n\tat Problem.main(tmpxumccrqd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val minIndex = arr.indexOf(min)\n        val maxIndex\
    \ = arr.indexOf(max)\n        if (minIndex == 0 && maxIndex == n - 1) return true\n\
    \        if (maxIndex == 0 && minIndex == n - 1) return true\n        if (maxIndex\
    \ == 0 && minIndex == n - 2) return true\n        if (maxIndex == 1 && minIndex\
    \ == n - 1) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpectjk2md.scala:40)\n\tat Problem.main(tmpectjk2md.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) {\n            if (maxIndex == arr.length - 1) return\
    \ true\n            else return false\n        }\n        else if (maxIndex ==\
    \ arr.length - 1) return false\n        else {\n            val left = arr.slice(0,\
    \ minIndex)\n            val right = arr.slice(minIndex, arr.length)\n       \
    \     val leftSorted = left.sorted\n            val rightSorted = right.sorted\n\
    \            if (leftSorted.last > rightSorted.head) return false\n          \
    \  else return true\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp76qluomz.scala:47)\n\tat Problem.main(tmp76qluomz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwnut30q1.scala:38)\n\tat Problem.main(tmpwnut30q1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        var count = 0\n        for (i <- 0 until\
    \ n) {\n            if (arr(i) != sorted(i)) count += 1\n        }\n        if\
    \ (count == 0) return true\n        if (count == 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplato3up9.scala:38)\n\tat Problem.main(tmplato3up9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) > max) max = arr(i)\n            if (arr(i) < min) min = arr(i)\n\
    \        }\n        if (max - min + 1 == arr.length) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpc886a7rp.scala:38)\n\tat Problem.main(tmpc886a7rp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) return true\n        if (maxIndex == arr.length -\
    \ 1) return true\n        if (maxIndex - minIndex == arr.length - 1) return true\n\
    \        return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzika2nvz.scala:38)\n\tat Problem.main(tmpzika2nvz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x =>\
    \ x._1 - x._2).filter(x => x != 0)\n        if (diff.length > 1) return false\n\
    \        val diffIndex = arr.zip(sorted).map(x => x._1 - x._2).indexOf(diff(0))\n\
    \        val diffIndex2 = arr.zip(sorted).map(x => x._1 - x._2).lastIndexOf(diff(0))\n\
    \        if (diffIndex == 0) return true\n        if (diffIndex == n - 1) return\
    \ true\n        if (diffIndex2 == n - 1) return true\n        if (diffIndex2 ==\
    \ 0) return true\n        if (diffIndex2 - diffIndex == 1) return true\n     \
    \   if (diffIndex2 - diffIndex == n - 1) return true\n        return false\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpah54pds0.scala:42)\n\tat Problem.main(tmpah54pds0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797902
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val max = arr.max\n        val minIndex =\
    \ arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        if (minIndex\
    \ == 0) return true\n        if (maxIndex == n - 1) return true\n        if (minIndex\
    \ == n - 1) return false\n        if (maxIndex == 0) return false\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9n_9wuk2.scala:42)\n\tat Problem.main(tmp9n_9wuk2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797902
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        var min = arr(0)\n        var max = arr(0)\n        for (i <- 1 until\
    \ n) {\n            if (arr(i) < min) min = arr(i)\n            if (arr(i) > max)\
    \ max = arr(i)\n        }\n        if (max - min + 1 == n) return true\n     \
    \   else return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpr4nmszrk.scala:39)\n\tat Problem.main(tmpr4nmszrk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 0 until arr.length) {\n         \
    \   min = min min arr(i)\n            max = max max arr(i)\n        }\n      \
    \  if (min == 1 && max == arr.length) return true\n        return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpte4xc0j4.scala:38)\n\tat Problem.main(tmpte4xc0j4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val sorted = arr.sorted\n\
    \        val sortedSet = sorted.toSet\n        val arrSet = arr.toSet\n      \
    \  if (sortedSet != arrSet) return false\n        if (n == 0) return true\n  \
    \      val min = arr.min\n        val max = arr.max\n        val minIndex = arr.indexOf(min)\n\
    \        val maxIndex = arr.indexOf(max)\n        val minToMax = maxIndex - minIndex\n\
    \        val maxToMin = n - minToMax\n        val minToMaxSorted = sorted.indexOf(min)\
    \ - sorted.indexOf(max)\n        val maxToMinSorted = n - minToMaxSorted\n   \
    \     if (minToMaxSorted == minToMax || maxToMinSorted == maxToMin) true\n   \
    \     else false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpytu7ke7d.scala:44)\n\tat Problem.main(tmpytu7ke7d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797902
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 0 until arr.length) {\n         \
    \   min = min min arr(i)\n            max = max max arr(i)\n        }\n      \
    \  if (max - min + 1 == arr.length) return true\n        return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmph37ebgce.scala:38)\n\tat Problem.main(tmph37ebgce.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        else\
    \ return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp390_1h0q.scala:38)\n\tat Problem.main(tmp390_1h0q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) return true\n        if (maxIndex == arr.length -\
    \ 1) return true\n        if (maxIndex - minIndex == 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpd6c9wcbg.scala:38)\n\tat Problem.main(tmpd6c9wcbg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val a = arr.toArray\n   \
    \     val b = new Array[Long](n)\n        for (i <- 0 until n) b(i) = a(i)\n \
    \       scala.util.Sorting.quickSort(b)\n        var i = 0\n        while (i <\
    \ n && a(i) == b(i)) i += 1\n        if (i == n) return true\n        var j =\
    \ i + 1\n        while (j < n && a(j) == b(i)) j += 1\n        if (j == n) return\
    \ false\n        while (j < n && a(j) == b(j)) j += 1\n        if (j == n) return\
    \ true\n        return false\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdg1_cg3p.scala:42)\n\tat Problem.main(tmpdg1_cg3p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797901
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val sorted = arr.sorted\n\
    \        val min = sorted.head\n        val max = sorted.last\n        val minIndex\
    \ = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        val minIndexSorted\
    \ = sorted.indexOf(min)\n        val maxIndexSorted = sorted.indexOf(max)\n  \
    \      if (minIndexSorted == 0 && maxIndexSorted == arr.length - 1) {\n      \
    \      if (minIndex == 0 && maxIndex == arr.length - 1) return true\n        \
    \    else if (minIndex == 0 && maxIndex != arr.length - 1) return false\n    \
    \        else if (minIndex != 0 && maxIndex == arr.length - 1) return true\n \
    \           else return false\n        }\n        else if (minIndexSorted == 0\
    \ && maxIndexSorted != arr.length - 1) {\n            if (minIndex == 0 && maxIndex\
    \ == arr.length - 1) return true\n            else if (minIndex == 0 && maxIndex\
    \ != arr.length - 1) return false\n            else if (minIndex != 0 && maxIndex\
    \ == arr.length - 1) return true\n            else return false\n        }\n \
    \       else if (minIndexSorted != 0 && maxIndexSorted == arr.length - 1) {\n\
    \            if (minIndex == 0 && maxIndex == arr.length - 1) return true\n  \
    \          else if (minIndex == 0 && maxIndex != arr.length - 1) return false\n\
    \            else if (minIndex != 0 && maxIndex == arr.length - 1) return true\n\
    \            else return false\n        }\n        else {\n            if (minIndex\
    \ == 0 && maxIndex == arr.length - 1) return true\n            else if (minIndex\
    \ == 0 && maxIndex != arr.length - 1) return false\n            else if (minIndex\
    \ != 0 && maxIndex == arr.length - 1) return true\n            else return false\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7z6b5fna.scala:60)\n\tat Problem.main(tmp7z6b5fna.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797902
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_1nqj404.scala:35)\n\tat Problem.main(tmp_1nqj404.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797908
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) {\n            return true\n   \
    \     }\n        val sorted = arr.sorted\n        val min = sorted.head\n    \
    \    val max = sorted.last\n        val minIndex = arr.indexOf(min)\n        val\
    \ maxIndex = arr.indexOf(max)\n        if (minIndex == 0) {\n            return\
    \ true\n        }\n        if (maxIndex == arr.length - 1) {\n            return\
    \ true\n        }\n        if (maxIndex - minIndex == 1) {\n            return\
    \ true\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppul7f1g3.scala:46)\n\tat Problem.main(tmppul7f1g3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797910
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   min = min min arr(i)\n            max = max max arr(i)\n        }\n      \
    \  return (max - min) <= arr.length - 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2qu8e7qx.scala:37)\n\tat Problem.main(tmp2qu8e7qx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797909
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (min == max) return true\n        var count = 0\n     \
    \   for (i <- 0 until arr.length) {\n            if (arr(i) == min) count += 1\n\
    \        }\n        if (count == arr.length) return true\n        count = 0\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) == max) count\
    \ += 1\n        }\n        if (count == arr.length) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb9ji038i.scala:47)\n\tat Problem.main(tmpb9ji038i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797880
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        var i = 0\n        while (i < arr.length) {\n        \
    \    if (arr(i) != sorted(i)) {\n                val j = arr.indexOf(sorted(i))\n\
    \                if (j == 0) return false\n                val temp = arr(j)\n\
    \                arr(j) = arr(j - 1)\n                arr(j - 1) = temp\n    \
    \        }\n            i += 1\n        }\n        return true\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9_i7of4e.scala:34:16 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                arr(j) = arr(j - \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp9_i7of4e.scala:35:16 ------------------------\e[0m\e[0m\n\
    \e[31m35 |\e[0m                arr(j - \e[31m1\e[0m) = temp\n\e[31m\e[31m   |\e\
    [0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of\
    \ List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1659797909
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val arr2 = arr.toArray\n        var i = 0\n        while (i < n) {\n\
    \            var j = i\n            while (j < n && arr2(j) == arr(i)) j += 1\n\
    \            if (j == n) return true\n            if (arr2(j) < arr(i)) return\
    \ false\n            i = j\n        }\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzbo2b7xn.scala:40)\n\tat Problem.main(tmpzbo2b7xn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797910
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val arr2 = arr.toArray\n        val arr3 = arr.toArray\n        for (i\
    \ <- 0 until n) {\n            val x = arr2(i)\n            var j = i\n      \
    \      while (j > 0 && arr2(j - 1) > x) {\n                arr2(j) = arr2(j -\
    \ 1)\n                j -= 1\n            }\n            arr2(j) = x\n       \
    \ }\n        for (i <- 0 until n) {\n            val x = arr3(i)\n           \
    \ var j = i\n            while (j < n - 1 && arr3(j + 1) < x) {\n            \
    \    arr3(j) = arr3(j + 1)\n                j += 1\n            }\n          \
    \  arr3(j) = x\n        }\n        for (i <- 0 until n) {\n            if (arr(i)\
    \ != arr2(i) && arr(i) != arr3(i)) return false\n        }\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp72mj1i64.scala:54)\n\tat Problem.main(tmp72mj1i64.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797911
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        var count = 0\n        for (i <- 0 until n - 1) {\n            if (arr(i)\
    \ > arr(i + 1)) count += 1\n        }\n        if (count > 1) return false\n \
    \       else return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797912
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val n = arr.length\n\
    \        val min = arr.min\n        val max = arr.max\n        val minIndex =\
    \ arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        val minIndexInSorted\
    \ = 0\n        val maxIndexInSorted = n - 1\n        if (minIndex == minIndexInSorted\
    \ && maxIndex == maxIndexInSorted) return true\n        if (minIndex == maxIndexInSorted\
    \ && maxIndex == minIndexInSorted) return true\n        return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9ykc0_kf.scala:39)\n\tat Problem.main(tmp9ykc0_kf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797912
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) {\n            if (maxIndex == arr.length - 1) return\
    \ true\n            else return false\n        }\n        else if (maxIndex ==\
    \ arr.length - 1) return false\n        else {\n            val minIndex2 = arr.indexOf(min,\
    \ minIndex + 1)\n            val maxIndex2 = arr.indexOf(max, maxIndex + 1)\n\
    \            if (minIndex2 == -1) {\n                if (maxIndex2 == -1) return\
    \ true\n                else return false\n            }\n            else if\
    \ (maxIndex2 == -1) return false\n            else {\n                if (minIndex2\
    \ < maxIndex2) return true\n                else return false\n            }\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnj96e_xq.scala:54)\n\tat Problem.main(tmpnj96e_xq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        var count = 0\n        for (i <- 0 until\
    \ n) {\n            if (arr(i) != sorted(i)) count += 1\n        }\n        if\
    \ (count == 0) return true\n        if (count > 2) return false\n        if (count\
    \ == 2) {\n            for (i <- 0 until n) {\n                if (arr(i) != sorted(i))\
    \ {\n                    val temp = arr(i)\n                    arr(i) = arr(i\
    \ + 1)\n                    arr(i + 1) = temp\n                    break\n   \
    \             }\n            }\n            if (arr == sorted) return true\n \
    \           else return false\n        }\n        if (count == 1) {\n        \
    \    var i = 0\n            while (i < n - 1) {\n                if (arr(i) >\
    \ arr(i + 1)) {\n                    val temp = arr(i)\n                    arr(i)\
    \ = arr(i + 1)\n                    arr(i + 1) = temp\n                    break\n\
    \                }\n                i += 1\n            }\n            if (arr\
    \ == sorted) return true\n            else return false\n        }\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpim9kj_dh.scala:39:20 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    arr(i) = arr(i + \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update\
    \ is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpim9kj_dh.scala:40:20 ------------------------\e[0m\e\
    [0m\n\e[31m40 |\e[0m                    arr(i + \e[31m1\e[0m) = temp\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpim9kj_dh.scala:41:20 ------------------------\e[0m\e[0m\n\
    \e[31m41 |\e[0m                    break\n\e[31m\e[31m   |\e[0m              \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpim9kj_dh.scala:52:20 ------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m                    arr(i) = arr(i + \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update\
    \ is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpim9kj_dh.scala:53:20 ------------------------\e[0m\e\
    [0m\n\e[31m53 |\e[0m                    arr(i + \e[31m1\e[0m) = temp\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpim9kj_dh.scala:54:20 ------------------------\e[0m\e[0m\n\
    \e[31m54 |\e[0m                    break\n\e[31m\e[31m   |\e[0m              \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    6 errors found\n"
  stdout: ''
  timestamp: 1659797912
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // We can solve this problem by using a greedy algorithm.\n\
    \        // We will keep track of the minimum value we have seen so far.\n   \
    \     // If we see a value that is less than the minimum value, then we know\n\
    \        // that we cannot sort the array.\n        // If we see a value that\
    \ is greater than the minimum value, then we know\n        // that we can sort\
    \ the array.\n        // We will also keep track of the index of the minimum value.\n\
    \        // If we see a value that is less than the minimum value, then we know\n\
    \        // that we cannot sort the array.\n        // If we see a value that\
    \ is greater than the minimum value, then we know\n        // that we can sort\
    \ the array.\n        // We will also keep track of the index of the minimum value.\n\
    \        // If we see a value that is less than the minimum value, then we know\n\
    \        // that we cannot sort the array.\n        // If we see a value that\
    \ is greater than the minimum value, then we know\n        // that we can sort\
    \ the array.\n        // We will also keep track of the index of the minimum value.\n\
    \        // If we see a value that is less than the minimum value, then we know\n\
    \        // that we cannot sort the array.\n        // If we see a value that\
    \ is greater than the minimum value, then we know\n        // that we can sort\
    \ the array.\n        // We will also keep track of the index of the minimum value.\n\
    \        // If we see a value that is less than the minimum value, then we know\n\
    \        // that we cannot sort the array.\n        // If we see a value that\
    \ is greater than the minimum value, then we know\n        // that we can sort\
    \ the array.\n        // We will also keep track of the index of the minimum value.\n\
    \        // If we see a value that is less than the minimum value, then we know\n\
    \        // that we cannot sort the array.\n        // If we see a value that\
    \ is greater than the minimum value, then we know\n        // that we can sort\
    \ the array.\n        // We will also keep track of the index of the minimum value.\n\
    \        // If we see a value that is less than the minimum value, then we know\n\
    \        // that we cannot sort the array.\n        // If we see a value\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi_d0edjk.scala:25:50\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mmoveOneBall\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mBoolean\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Unit\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m26 |\e[0m        \e[34m// We can solve this problem by using\
    \ a greedy algorithm.\e[0m\n\e[31m27 |\e[0m        \e[34m// We will keep track\
    \ of the minimum value we have seen so far.\e[0m\n\e[31m28 |\e[0m        \e[34m//\
    \ If we see a value that is less than the minimum value, then we know\e[0m\n\e\
    [31m29 |\e[0m        \e[34m// that we cannot sort the array.\e[0m\n\e[31m30 |\e\
    [0m        \e[34m// If we see a value that is greater than the minimum value,\
    \ then we know\e[0m\n\e[31m31 |\e[0m        \e[34m// that we can sort the array.\e\
    [0m\n\e[31m32 |\e[0m        \e[34m// We will also keep track of the index of the\
    \ minimum value.\e[0m\n\e[31m33 |\e[0m        \e[34m// If we see a value that\
    \ is less than the minimum value, then we know\e[0m\n\e[31m34 |\e[0m        \e\
    [34m// that we cannot sort the array.\e[0m\n\e[31m35 |\e[0m        \e[34m// If\
    \ we see a value that is greater than the minimum value, then we know\e[0m\n\e\
    [31m36 |\e[0m        \e[34m// that we can sort the array.\e[0m\n\e[31m37 |\e[0m\
    \        \e[34m// We will also keep track of the index of the minimum value.\e\
    [0m\n\e[31m38 |\e[0m        \e[34m// If we see a value that is less than the minimum\
    \ value, then we know\e[0m\n\e[31m39 |\e[0m        \e[34m// that we cannot sort\
    \ the array.\e[0m\n\e[31m40 |\e[0m        \e[34m// If we see a value that is greater\
    \ than the minimum value, then we know\e[0m\n\e[31m41 |\e[0m        \e[34m// that\
    \ we can sort the array.\e[0m\n\e[31m42 |\e[0m        \e[34m// We will also keep\
    \ track of the index of the minimum value.\e[0m\n\e[31m43 |\e[0m        \e[34m//\
    \ If we see a value that is less than the minimum value, then we know\e[0m\n\e\
    [31m44 |\e[0m        \e[34m// that we cannot sort"
  stdout: ''
  timestamp: 1659797911
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val max = arr.max\n        val min = arr.min\n        if (max - min >\
    \ n - 1) return false\n        val map = new HashMap[Long, Int]\n        for (i\
    \ <- 0 until n) {\n            if (map.contains(arr(i))) return false\n      \
    \      map(arr(i)) = i\n        }\n        var count = 0\n        for (i <- 0\
    \ until n) {\n            if (arr(i) != i + 1) {\n                count += 1\n\
    \                val index = map(i + 1)\n                map(arr(i)) = index\n\
    \                arr(index) = arr(i)\n                arr(i) = i + 1\n       \
    \     }\n        }\n        return count <= 1\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpqg8g2ton.scala:42:16 ------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                arr(index) = arr(i)\n\e[31m\e[31m   |\e\
    [0m                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of\
    \ List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpqg8g2ton.scala:43:16 ------------------------\e[0m\e[0m\n\e[31m43 |\e\
    [0m                arr(i) = i + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m          \
    \      ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long] -\
    \ did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1659797912
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) return true\n        if (minIndex == maxIndex) return\
    \ false\n        if (minIndex > maxIndex) return true\n        if (minIndex <\
    \ maxIndex) return false\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprfkxgvbm.scala:41)\n\tat Problem.main(tmprfkxgvbm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797912
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min + 1 == arr.length) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgv9miu1e.scala:38)\n\tat Problem.main(tmpgv9miu1e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val max = arr.max\n        val min =\
    \ arr.min\n        var i = 0\n        while (i < n) {\n            if (arr(i)\
    \ == max) {\n                if (i == n - 1) return true\n                else\
    \ if (arr(i + 1) == min) return true\n                else return false\n    \
    \        }\n            i += 1\n        }\n        return true\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797913
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwnut30q1.scala:38)\n\tat Problem.main(tmpwnut30q1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val arr2 = arr.toArray\n        val arr3 = arr.toArray\n        var i\
    \ = 0\n        while (i < n) {\n            arr2(i) = arr(i)\n            arr3(i)\
    \ = arr(i)\n            i += 1\n        }\n        var j = 0\n        while (j\
    \ < n) {\n            i = 0\n            while (i < n) {\n                arr2(i)\
    \ = arr(i)\n                i += 1\n            }\n            val temp = arr2(j)\n\
    \            i = j\n            while (i < n - 1) {\n                arr2(i) =\
    \ arr2(i + 1)\n                i += 1\n            }\n            arr2(n - 1)\
    \ = temp\n            i = 0\n            while (i < n - 1) {\n               \
    \ if (arr2(i) > arr2(i + 1)) {\n                    break\n                }\n\
    \                i += 1\n            }\n            if (i == n - 1) {\n      \
    \          return true\n            }\n            j += 1\n        }\n       \
    \ return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxi6wf2ju.scala:53:20 ------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797910
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val max = arr.max\n        val minIndex =\
    \ arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        if (minIndex\
    \ == 0) {\n            if (maxIndex == n - 1) return true\n            else return\
    \ false\n        }\n        else if (maxIndex == n - 1) return false\n       \
    \ else return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoaq2sxjf.scala:42)\n\tat Problem.main(tmpoaq2sxjf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797913
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (min == 1 && max == arr.length) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl5d4bdwx.scala:38)\n\tat Problem.main(tmpl5d4bdwx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        var i = 0\n        while (i < n) {\n\
    \            if (arr(i) != sorted(i)) {\n                if (i == n - 1) return\
    \ false\n                if (arr(i + 1) == sorted(i)) {\n                    val\
    \ temp = arr(i)\n                    arr(i) = arr(i + 1)\n                   \
    \ arr(i + 1) = temp\n                } else return false\n            }\n    \
    \        i += 1\n        }\n        true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpy880lubi.scala:35:20 ------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                    arr(i) = arr(i + \e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update\
    \ is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpy880lubi.scala:36:20 ------------------------\e[0m\e\
    [0m\n\e[31m36 |\e[0m                    arr(i + \e[31m1\e[0m) = temp\n\e[31m\e\
    [31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1659797912
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) return false\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        return true\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl3qfa6ng.scala:36)\n\tat Problem.main(tmpl3qfa6ng.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797913
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   min = min min arr(i)\n            max = max max arr(i)\n        }\n      \
    \  if (max - min + 1 == arr.length) return true\n        return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyryalrbx.scala:38)\n\tat Problem.main(tmpyryalrbx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        for (i <- 0 until arr.length) {\n            val shifted\
    \ = arr.slice(i, arr.length) ++ arr.slice(0, i)\n            if (shifted == sorted)\
    \ return true\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797913
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val sorted = arr.sorted\n        val min = sorted.head\n\
    \        val max = sorted.last\n        val minIndex = arr.indexOf(min)\n    \
    \    val maxIndex = arr.indexOf(max)\n        val minToMax = maxIndex - minIndex\n\
    \        val maxToMin = arr.length - minToMax\n        if (minToMax == 0 || maxToMin\
    \ == 0) {\n            true\n        } else {\n            minToMax == maxToMin\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj7q4k1vn.scala:40)\n\tat Problem.main(tmpj7q4k1vn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797913
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // We will use a stack to keep track of the elements.\n\
    \        // We will start with the first element in the array.\n        // If\
    \ the next element is greater than the current element, then we will\n       \
    \ // push it to the stack.\n        // If the next element is less than the current\
    \ element, then we will pop\n        // the current element from the stack and\
    \ replace it with the next element.\n        // If the stack is empty, then we\
    \ will push the next element to the stack.\n        // If the stack is not empty\
    \ and the next element is greater than the top\n        // element in the stack,\
    \ then we will push the next element to the stack.\n        // If the stack is\
    \ not empty and the next element is less than the top\n        // element in the\
    \ stack, then we will pop the top element from the stack\n        // and replace\
    \ it with the next element.\n        // If the stack is not empty and the next\
    \ element is equal to the top\n        // element in the stack, then we will push\
    \ the next element to the stack.\n        // If the stack is not empty and the\
    \ next element is equal to the top\n        // element in the stack, then we will\
    \ push the next element to the stack.\n        // If the stack is not empty and\
    \ the next element is equal to the top\n        // element in the stack, then\
    \ we will push the next element to the stack.\n        // If the stack is not\
    \ empty and the next element is equal to the top\n        // element in the stack,\
    \ then we will push the next element to the stack.\n        // If the stack is\
    \ not empty and the next element is equal to the top\n        // element in the\
    \ stack, then we will push the next element to the stack.\n        // If the stack\
    \ is not empty and the next element is equal to the top\n        // element in\
    \ the stack, then we will push the next element to the stack.\n        // If the\
    \ stack is not empty and the next element is equal to the top\n        // element\
    \ in the stack, then we will push the next element to the stack.\n        // If\
    \ the stack is not empty and the next element is equal to the top\n        //\
    \ element in the stack, then we will push the next element to the stack.\n   \
    \     // If the stack is not empty and the next element is equal to the top\n\
    \        // element\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpko7b8z4f.scala:25:50\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mmoveOneBall\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mBoolean\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Unit\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m26 |\e[0m        \e[34m// We will use a stack to keep track of\
    \ the elements.\e[0m\n\e[31m27 |\e[0m        \e[34m// We will start with the first\
    \ element in the array.\e[0m\n\e[31m28 |\e[0m        \e[34m// If the next element\
    \ is greater than the current element, then we will\e[0m\n\e[31m29 |\e[0m    \
    \    \e[34m// push it to the stack.\e[0m\n\e[31m30 |\e[0m        \e[34m// If the\
    \ next element is less than the current element, then we will pop\e[0m\n\e[31m31\
    \ |\e[0m        \e[34m// the current element from the stack and replace it with\
    \ the next element.\e[0m\n\e[31m32 |\e[0m        \e[34m// If the stack is empty,\
    \ then we will push the next element to the stack.\e[0m\n\e[31m33 |\e[0m     \
    \   \e[34m// If the stack is not empty and the next element is greater than the\
    \ top\e[0m\n\e[31m34 |\e[0m        \e[34m// element in the stack, then we will\
    \ push the next element to the stack.\e[0m\n\e[31m35 |\e[0m        \e[34m// If\
    \ the stack is not empty and the next element is less than the top\e[0m\n\e[31m36\
    \ |\e[0m        \e[34m// element in the stack, then we will pop the top element\
    \ from the stack\e[0m\n\e[31m37 |\e[0m        \e[34m// and replace it with the\
    \ next element.\e[0m\n\e[31m38 |\e[0m        \e[34m// If the stack is not empty\
    \ and the next element is equal to the top\e[0m\n\e[31m39 |\e[0m        \e[34m//\
    \ element in the stack, then we will push the next element to the stack.\e[0m\n\
    \e[31m40 |\e[0m        \e[34m// If the stack is not empty and the next element\
    \ is equal to the top\e[0m\n\e[31m41 |\e[0m        \e[34m// element in the stack,\
    \ then we will push the next element to the stack.\e[0m\n\e[31m42 |\e[0m     \
    \   \e[34m// If the stack is not empty and the ne"
  stdout: ''
  timestamp: 1659797912
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val max = arr.max\n        val minIndex =\
    \ arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        if (minIndex\
    \ == 0) {\n            if (maxIndex == n - 1) return true\n            else return\
    \ false\n        }\n        else if (maxIndex == n - 1) return false\n       \
    \ else return true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpoaq2sxjf.scala:42)\n\tat Problem.main(tmpoaq2sxjf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797913
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val minIndex = arr.indexOf(min)\n        val maxIndex\
    \ = arr.indexOf(max)\n        if (minIndex == 0) {\n            if (maxIndex ==\
    \ n - 1) return true\n            else return false\n        }\n        else {\n\
    \            if (maxIndex == n - 1) return true\n            else return false\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuqlibu6x.scala:43)\n\tat Problem.main(tmpuqlibu6x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797913
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (min == max) return true\n        var count = 0\n     \
    \   for (i <- 0 until arr.length) {\n            if (arr(i) == min) count += 1\n\
    \        }\n        if (count == arr.length) return true\n        if (count ==\
    \ 1) return false\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw0rq2hhe.scala:43)\n\tat Problem.main(tmpw0rq2hhe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797913
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) return true\n        if (maxIndex == arr.length -\
    \ 1) return true\n        if (minIndex < maxIndex) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy2u4_f5m.scala:38)\n\tat Problem.main(tmpy2u4_f5m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797890
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val minIndex = arr.indexOf(min)\n        val maxIndex\
    \ = arr.indexOf(max)\n        if (minIndex == 0 && maxIndex == n - 1) return true\n\
    \        if (maxIndex == 0 && minIndex == n - 1) return true\n        if (maxIndex\
    \ - minIndex == 1) return true\n        if (minIndex == 0 && maxIndex == n - 2)\
    \ return true\n        if (maxIndex == 0 && minIndex == n - 2) return true\n \
    \       return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp69z8375w.scala:41)\n\tat Problem.main(tmp69z8375w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val min = arr.min\n\
    \        val minIndex = arr.indexOf(min)\n        val max = arr.max\n        val\
    \ maxIndex = arr.indexOf(max)\n        if (minIndex == 0) return true\n      \
    \  if (maxIndex == arr.length - 1) return true\n        if (minIndex < maxIndex)\
    \ return false\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8iw18q5z.scala:39)\n\tat Problem.main(tmp8iw18q5z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val diff = arr.zip(sorted).map(x =>\
    \ x._1 - x._2).filter(x => x != 0)\n        if (diff.length == 0) return true\n\
    \        if (diff.length == 1) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpau0fj7zj.scala:35)\n\tat Problem.main(tmpau0fj7zj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797899
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // We can sort the array in O(NlogN) time.\n        //\
    \ Then we can check if the array is sorted in O(N) time.\n        // If it is\
    \ sorted, then we can return true.\n        // If it is not sorted, then we can\
    \ return false.\n        // The total time complexity is O(NlogN).\n        //\
    \ The total space complexity is O(N).\n        val sortedArr = arr.sorted\n  \
    \      for (i <- 0 until arr.length) {\n            if (arr(i) != sortedArr(i))\
    \ return false\n        }\n        return true\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5xazo1ge.scala:39)\n\tat Problem.main(tmp5xazo1ge.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var max = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < max) return\
    \ false\n            max = max max arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo3e7acm0.scala:35)\n\tat Problem.main(tmpo3e7acm0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797877
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // We can use a greedy algorithm to solve this problem.\n\
    \        // We will start from the leftmost element and we will try to find the\n\
    \        // smallest element in the array. If we find a smaller element than the\n\
    \        // current element then we will swap the two elements.\n        // If\
    \ we find a smaller element then we will swap the two elements.\n        // If\
    \ we do not find a smaller element then we will move to the next\n        // element.\n\
    \        // If we are able to sort the array then we will return true else we\
    \ will\n        // return false.\n        // We will use the following algorithm\
    \ to sort the array:\n        // 1. We will start from the leftmost element.\n\
    \        // 2. We will try to find the smallest element in the array.\n      \
    \  // 3. If we find a smaller element then we will swap the two elements.\n  \
    \      // 4. If we do not find a smaller element then we will move to the next\n\
    \        // element.\n        // 5. If we are able to sort the array then we will\
    \ return true else we will\n        // return false.\n        // We will use the\
    \ following algorithm to find the smallest element in the\n        // array:\n\
    \        // 1. We will start from the leftmost element.\n        // 2. We will\
    \ keep track of the smallest element in the array.\n        // 3. We will keep\
    \ track of the index of the smallest element in the array.\n        // 4. We will\
    \ keep track of the index of the current element.\n        // 5. If the current\
    \ element is smaller than the smallest element then we\n        // will update\
    \ the smallest element and the index of the smallest element.\n        // 6. We\
    \ will move to the next element.\n        // 7. We will repeat steps 5 and 6 until\
    \ we reach the end of the array.\n        // 8. We will return the index of the\
    \ smallest element.\n        // We will use the following algorithm to swap two\
    \ elements in the array:\n        // 1. We will start from the leftmost element.\n\
    \        // 2. We will keep track of the index of the current element.\n     \
    \   // 3. We will keep track of the index of the element to be swapped.\n    \
    \    // 4. We will swap the current element with the element to be swapped.\n\
    \        // 5. We will move to the next element.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcrhc8mk9.scala:25:50\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mmoveOneBall\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mBoolean\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Unit\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m26 |\e[0m        \e[34m// We can use a greedy algorithm to solve\
    \ this problem.\e[0m\n\e[31m27 |\e[0m        \e[34m// We will start from the leftmost\
    \ element and we will try to find the\e[0m\n\e[31m28 |\e[0m        \e[34m// smallest\
    \ element in the array. If we find a smaller element than the\e[0m\n\e[31m29 |\e\
    [0m        \e[34m// current element then we will swap the two elements.\e[0m\n\
    \e[31m30 |\e[0m        \e[34m// If we find a smaller element then we will swap\
    \ the two elements.\e[0m\n\e[31m31 |\e[0m        \e[34m// If we do not find a\
    \ smaller element then we will move to the next\e[0m\n\e[31m32 |\e[0m        \e\
    [34m// element.\e[0m\n\e[31m33 |\e[0m        \e[34m// If we are able to sort the\
    \ array then we will return true else we will\e[0m\n\e[31m34 |\e[0m        \e\
    [34m// return false.\e[0m\n\e[31m35 |\e[0m        \e[34m// We will use the following\
    \ algorithm to sort the array:\e[0m\n\e[31m36 |\e[0m        \e[34m// 1. We will\
    \ start from the leftmost element.\e[0m\n\e[31m37 |\e[0m        \e[34m// 2. We\
    \ will try to find the smallest element in the array.\e[0m\n\e[31m38 |\e[0m  \
    \      \e[34m// 3. If we find a smaller element then we will swap the two elements.\e\
    [0m\n\e[31m39 |\e[0m        \e[34m// 4. If we do not find a smaller element then\
    \ we will move to the next\e[0m\n\e[31m40 |\e[0m        \e[34m// element.\e[0m\n\
    \e[31m41 |\e[0m        \e[34m// 5. If we are able to sort the array then we will\
    \ return true else we will\e[0m\n\e[31m42 |\e[0m        \e[34m// return false.\e\
    [0m\n\e[31m43 |\e[0m        \e[34m// We will use the following algorithm to find\
    \ the smallest element in the\e[0m\n\e[31m44 |\e[0m        \e[34m// array:\e[0m\n\
    \e[31m45 |\e[0m        \e[34m// 1. W"
  stdout: ''
  timestamp: 1659797919
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) return true\n        if (maxIndex == 0) return false\n\
    \        if (maxIndex == minIndex + 1) return true\n        if (maxIndex == arr.length\
    \ - 1) return true\n        if (minIndex == arr.length - 1) return false\n   \
    \     if (maxIndex == minIndex + 2) return true\n        return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkifw7lz7.scala:41)\n\tat Problem.main(tmpkifw7lz7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var max = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < max) return\
    \ false\n            else max = arr(i)\n        }\n        return true\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpuxmeb7fx.scala:35)\n\tat Problem.main(tmpuxmeb7fx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        var min = arr(0)\n        for (i <- 1 until n) {\n            if (arr(i)\
    \ < min) return false\n            min = min min arr(i)\n        }\n        return\
    \ true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfcl9vard.scala:36)\n\tat Problem.main(tmpfcl9vard.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) {\n            return true\n   \
    \     }\n        val sorted = arr.sorted\n        val min = sorted.head\n    \
    \    val max = sorted.last\n        val minIndex = arr.indexOf(min)\n        val\
    \ maxIndex = arr.indexOf(max)\n        if (minIndex == 0) {\n            return\
    \ true\n        }\n        if (maxIndex == arr.length - 1) {\n            return\
    \ true\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw9i7xqxc.scala:43)\n\tat Problem.main(tmpw9i7xqxc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797923
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val max = arr.max\n        if (min == max)\
    \ return true\n        val minIndex = arr.indexOf(min)\n        val maxIndex =\
    \ arr.indexOf(max)\n        val minIndex2 = arr.lastIndexOf(min)\n        val\
    \ maxIndex2 = arr.lastIndexOf(max)\n        if (minIndex == maxIndex) return true\n\
    \        if (minIndex == 0) return true\n        if (maxIndex == n - 1) return\
    \ true\n        if (minIndex2 == maxIndex2) return true\n        if (minIndex2\
    \ == 0) return true\n        if (maxIndex2 == n - 1) return true\n        if (minIndex\
    \ == maxIndex2) return true\n        if (minIndex2 == maxIndex) return true\n\
    \        return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpclbn7dex.scala:46)\n\tat Problem.main(tmpclbn7dex.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797923
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val max = arr.max\n        val min = arr.min\n        if (max - min +\
    \ 1 == n) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp18pe3ei.scala:35)\n\tat Problem.main(tmpp18pe3ei.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        val min = arr.min\n     \
    \   val minIndex = arr.indexOf(min)\n        val max = arr.max\n        val maxIndex\
    \ = arr.indexOf(max)\n        if (minIndex == 0) {\n            if (maxIndex ==\
    \ n - 1) return true\n            else return false\n        }\n        else if\
    \ (maxIndex == n - 1) return false\n        else return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpezc605sm.scala:41)\n\tat Problem.main(tmpezc605sm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797923
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        var minIndex = arr.indexOf(min)\n        var maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) return true\n        if (maxIndex == arr.length -\
    \ 1) return true\n        if (minIndex > maxIndex) return false\n        val left\
    \ = arr.slice(0, minIndex)\n        val right = arr.slice(minIndex, arr.length)\n\
    \        val leftSorted = left.sorted\n        val rightSorted = right.sorted\n\
    \        if (leftSorted.head != min) return false\n        if (rightSorted.last\
    \ != max) return false\n        if (leftSorted.last > rightSorted.head) return\
    \ false\n        return true\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2xen2hwu.scala:45)\n\tat Problem.main(tmp2xen2hwu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797923
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        var arr2 = arr.toArray\n        var count = 0\n     \
    \   for (i <- 0 until arr2.length) {\n            if (arr2(i) != i + 1) {\n  \
    \              count += 1\n            }\n        }\n        if (count == 1) {\n\
    \            return true\n        }\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpeg1sqmoa.scala:39)\n\tat Problem.main(tmpeg1sqmoa.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797923
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   min = min min arr(i)\n            max = max max arr(i)\n        }\n      \
    \  if (min == 1 && max == arr.length) return true\n        else return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb_luig67.scala:38)\n\tat Problem.main(tmpb_luig67.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // We will use a stack to keep track of the elements.\n\
    \        // We will iterate through the list, and if the current element is greater\n\
    \        // than the top element of the stack, we will pop the top element and\
    \ add\n        // it to the end of the list.\n        // If the current element\
    \ is less than the top element of the stack, we will\n        // push the current\
    \ element to the stack.\n        // If the current element is equal to the top\
    \ element of the stack, we will\n        // push the current element to the stack.\n\
    \        // If the stack is empty, we will push the current element to the stack.\n\
    \        // If the stack is not empty, and the current element is less than the\
    \ top\n        // element of the stack, we will push the current element to the\
    \ stack.\n        // If the stack is not empty, and the current element is equal\
    \ to the top\n        // element of the stack, we will push the current element\
    \ to the stack.\n        // If the stack is not empty, and the current element\
    \ is greater than the top\n        // element of the stack, we will pop the top\
    \ element and add it to the end of\n        // the list.\n        // If the stack\
    \ is not empty, and the current element is greater than the top\n        // element\
    \ of the stack, we will pop the top element and add it to the end of\n       \
    \ // the list.\n        // If the stack is not empty, and the current element\
    \ is greater than the top\n        // element of the stack, we will pop the top\
    \ element and add it to the end of\n        // the list.\n        // If the stack\
    \ is not empty, and the current element is greater than the top\n        // element\
    \ of the stack, we will pop the top element and add it to the end of\n       \
    \ // the list.\n        // If the stack is not empty, and the current element\
    \ is greater than the top\n        // element of the stack, we will pop the top\
    \ element and add it to the end of\n        // the list.\n        // If the stack\
    \ is not empty, and the current element is greater than the top\n        // element\
    \ of the stack, we will pop the top element and add it to the end of\n       \
    \ // the list.\n        // If the stack is not empty, and the current element\
    \ is greater than the top\n\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph103fora.scala:25:50\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m    \e[33mdef\e[0m \e[36mmoveOneBall\e\
    [0m(\e[36marr\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m]) : \e[35mBoolean\e[0m =\
    \ {\n\e[31m\e[31m   |\e[0m                                                  ^\e\
    [0m\n\e[31m   |\e[0m                                                  Found: \
    \   Unit\n\e[31m   |\e[0m                                                  Required:\
    \ Boolean\n\e[31m26 |\e[0m        \e[34m// We will use a stack to keep track of\
    \ the elements.\e[0m\n\e[31m27 |\e[0m        \e[34m// We will iterate through\
    \ the list, and if the current element is greater\e[0m\n\e[31m28 |\e[0m      \
    \  \e[34m// than the top element of the stack, we will pop the top element and\
    \ add\e[0m\n\e[31m29 |\e[0m        \e[34m// it to the end of the list.\e[0m\n\e\
    [31m30 |\e[0m        \e[34m// If the current element is less than the top element\
    \ of the stack, we will\e[0m\n\e[31m31 |\e[0m        \e[34m// push the current\
    \ element to the stack.\e[0m\n\e[31m32 |\e[0m        \e[34m// If the current element\
    \ is equal to the top element of the stack, we will\e[0m\n\e[31m33 |\e[0m    \
    \    \e[34m// push the current element to the stack.\e[0m\n\e[31m34 |\e[0m   \
    \     \e[34m// If the stack is empty, we will push the current element to the\
    \ stack.\e[0m\n\e[31m35 |\e[0m        \e[34m// If the stack is not empty, and\
    \ the current element is less than the top\e[0m\n\e[31m36 |\e[0m        \e[34m//\
    \ element of the stack, we will push the current element to the stack.\e[0m\n\e\
    [31m37 |\e[0m        \e[34m// If the stack is not empty, and the current element\
    \ is equal to the top\e[0m\n\e[31m38 |\e[0m        \e[34m// element of the stack,\
    \ we will push the current element to the stack.\e[0m\n\e[31m39 |\e[0m       \
    \ \e[34m// If the stack is not empty, and the current element is greater than\
    \ the top\e[0m\n\e[31m40 |\e[0m        \e[34m// element of the stack, we will\
    \ pop the top element and add it to the end of\e[0m\n\e[31m41 |\e[0m        \e\
    [34m// the list.\e[0m\n\e[31m42 |\e[0m        \e[34m// If the stack is not empty,\
    \ and the current element is greater than the top\e[0m\n\e[31"
  stdout: ''
  timestamp: 1659797922
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwnut30q1.scala:38)\n\tat Problem.main(tmpwnut30q1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // We will use a stack to store the elements of the array.\n\
    \        val stack = new Stack[Long]\n        // We will use a variable to store\
    \ the minimum element of the array.\n        var min = Long.MaxValue\n       \
    \ // We will use a variable to store the maximum element of the array.\n     \
    \   var max = Long.MinValue\n        // We will use a variable to store the number\
    \ of elements in the array.\n        var n = 0\n        // We will use a variable\
    \ to store the number of elements in the stack.\n        var m = 0\n        //\
    \ We will use a variable to store the number of elements in the stack.\n     \
    \   var k = 0\n        // We will use a variable to store the number of elements\
    \ in the stack.\n        var l = 0\n        // We will use a variable to store\
    \ the number of elements in the stack.\n        var i = 0\n        // We will\
    \ use a variable to store the number of elements in the stack.\n        var j\
    \ = 0\n        // We will use a variable to store the number of elements in the\
    \ stack.\n        var x = 0\n        // We will use a variable to store the number\
    \ of elements in the stack.\n        var y = 0\n        // We will use a variable\
    \ to store the number of elements in the stack.\n        var z = 0\n        //\
    \ We will use a variable to store the number of elements in the stack.\n     \
    \   var a = 0\n        // We will use a variable to store the number of elements\
    \ in the stack.\n        var b = 0\n        // We will use a variable to store\
    \ the number of elements in the stack.\n        var c = 0\n        // We will\
    \ use a variable to store the number of elements in the stack.\n        var d\
    \ = 0\n        // We will use a variable to store the number of elements in the\
    \ stack.\n        var e = 0\n        // We will use a variable to store the number\
    \ of elements in the stack.\n        var f = 0\n        // We will use a variable\
    \ to store the number of elements in the stack.\n        var g = 0\n        //\
    \ We will use a variable to store the number of elements in the stack.\n     \
    \   var h = 0\n        // We will use a variable to store the number of elements\
    \ in the stack.\n        var p = 0\n       \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb05g20xl.scala:69:5\
    \ ---------------------\e[0m\e[0m\n\e[31m69 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659797922
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        val minDistance = minIndex\n        val maxDistance = arr.length - maxIndex\
    \ - 1\n        if (minDistance == maxDistance) return true\n        if (minDistance\
    \ > maxDistance) return false\n        val distance = maxDistance - minDistance\n\
    \        if (distance == 1) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfb2unpes.scala:41)\n\tat Problem.main(tmpfb2unpes.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797923
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        if (minIndex == 0) {\n            if (maxIndex == arr.length - 1) return\
    \ true\n            else return false\n        }\n        else if (maxIndex ==\
    \ arr.length - 1) return false\n        else {\n            val newArr = arr.slice(minIndex,\
    \ maxIndex + 1)\n            val newSorted = newArr.sorted\n            if (newArr\
    \ == newSorted) return true\n            else return false\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_abq24zw.scala:47)\n\tat Problem.main(tmp_abq24zw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797924
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   min = min min arr(i)\n            max = max max arr(i)\n        }\n      \
    \  if (max - min == arr.length - 1) return true\n        return false\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgyrabfnv.scala:38)\n\tat Problem.main(tmpgyrabfnv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797924
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        var i = 0\n        while (i < n) {\n\
    \            if (arr(i) != sorted(i)) {\n                val j = arr.indexOf(sorted(i))\n\
    \                if (j == n - 1) return false\n                val k = arr.indexOf(sorted(i\
    \ + 1))\n                if (k == n - 1) return false\n                if (arr(j\
    \ + 1) != sorted(i + 1)) return false\n                if (arr(k + 1) != sorted(i))\
    \ return false\n                return true\n            }\n            i += 1\n\
    \        }\n        true\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp851yes3s.scala:45)\n\tat Problem.main(tmp851yes3s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797924
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        var min = arr.min\n\
    \        var max = arr.max\n        var minIndex = arr.indexOf(min)\n        var\
    \ maxIndex = arr.indexOf(max)\n        if (minIndex == 0) return true\n      \
    \  if (maxIndex == arr.length - 1) return true\n        if (minIndex > maxIndex)\
    \ return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjfs5bw0_.scala:39)\n\tat Problem.main(tmpjfs5bw0_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797924
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val minIndex = arr.indexOf(min)\n        val maxIndex\
    \ = arr.indexOf(max)\n        val minDistance = minIndex - 0\n        val maxDistance\
    \ = n - 1 - maxIndex\n        if (minDistance == maxDistance) return true\n  \
    \      else if (minDistance > maxDistance) return false\n        else {\n    \
    \        val minDistance = minIndex - 0\n            val maxDistance = n - 1 -\
    \ maxIndex\n            if (minDistance == maxDistance) return true\n        \
    \    else if (minDistance > maxDistance) return false\n            else {\n  \
    \              val minDistance = minIndex - 0\n                val maxDistance\
    \ = n - 1 - maxIndex\n                if (minDistance == maxDistance) return true\n\
    \                else if (minDistance > maxDistance) return false\n          \
    \      else {\n                    val minDistance = minIndex - 0\n          \
    \          val maxDistance = n - 1 - maxIndex\n                    if (minDistance\
    \ == maxDistance) return true\n                    else if (minDistance > maxDistance)\
    \ return false\n                    else {\n                        val minDistance\
    \ = minIndex - 0\n                        val maxDistance = n - 1 - maxIndex\n\
    \                        if (minDistance == maxDistance) return true\n       \
    \                 else if (minDistance > maxDistance) return false\n         \
    \               else {\n                            val minDistance = minIndex\
    \ - 0\n                            val maxDistance = n - 1 - maxIndex\n      \
    \                      if (minDistance == maxDistance) return true\n         \
    \                   else if (minDistance > maxDistance) return false\n       \
    \                     else {\n                                val minDistance\
    \ = minIndex - 0\n                                val maxDistance = n - 1 - maxIndex\n\
    \                                if (minDistance == maxDistance) return true\n\
    \                                else if (minDistance > maxDistance) return false\n\
    \                                else {\n                                    val\
    \ minDistance = minIndex - 0\n                                    val maxDistance\
    \ = n - 1 - maxIndex\n                                    if (minDistance == maxDistance)\
    \ return true\n                                    else if (minDistance > maxDistance)\
    \ return false\n                                    else {\n                 \
    \                       val minDistance = minIndex - 0\n                     \
    \                   val maxDistance = n -\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpa7t32nnl.scala:74:61 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m                                        \e[33mval\e[0m\
    \ \e[36mmaxDistance\e[0m = n -\n\e[31m\e[31m   |\e[0m                        \
    \                                     ^\e[0m\n\e[31m   |\e[0m                \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa7t32nnl.scala:85:0 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa7t32nnl.scala:84:1\
    \ ---------------------\e[0m\e[0m\n\e[31m84 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpa7t32nnl.scala:76:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1659797923
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var i = 0\n\
    \        while (i < arr.length - 1) {\n            if (arr(i) > arr(i + 1)) return\
    \ false\n            i += 1\n        }\n        return true\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp929887t0.scala:35)\n\tat Problem.main(tmp929887t0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797924
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min + 1 == arr.length) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgv9miu1e.scala:38)\n\tat Problem.main(tmpgv9miu1e.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        // We can use the following algorithm to solve this problem:\n\
    \        // 1. Find the minimum element in the array.\n        // 2. Find the\
    \ index of the minimum element in the array.\n        // 3. Find the number of\
    \ right shift operations required to move the minimum\n        // element to the\
    \ 0th index.\n        // 4. Perform the right shift operations.\n        // 5.\
    \ Check if the array is sorted in non-decreasing order.\n        // 6. If the\
    \ array is sorted in non-decreasing order then return True else\n        // return\
    \ False.\n        // The time complexity of this algorithm is O(N) where N is\
    \ the length of the\n        // array.\n        // The space complexity of this\
    \ algorithm is O(1).\n        if (arr.length == 0) return true\n        val min\
    \ = arr.min\n        val minIndex = arr.indexOf(min)\n        val shift = minIndex\n\
    \        val newArr = arr.slice(shift, arr.length) ++ arr.slice(0, shift)\n  \
    \      val isSorted = newArr.sorted.equals(newArr)\n        isSorted\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797924
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val sorted = arr.sorted\n        val min = sorted.head\n\
    \        val max = sorted.last\n        val minIndex = arr.indexOf(min)\n    \
    \    val maxIndex = arr.indexOf(max)\n        if (minIndex == 0) {\n         \
    \   if (maxIndex == arr.length - 1) {\n                return true\n         \
    \   } else {\n                return false\n            }\n        } else {\n\
    \            if (maxIndex == arr.length - 1) {\n                return false\n\
    \            } else {\n                return true\n            }\n        }\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpturija9_.scala:48)\n\tat Problem.main(tmpturija9_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797924
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (min == max) return true\n        var count = 0\n     \
    \   for (i <- 0 until arr.length) {\n            if (arr(i) == min) count += 1\n\
    \        }\n        if (count == arr.length) return true\n        count = 0\n\
    \        for (i <- 0 until arr.length) {\n            if (arr(i) == max) count\
    \ += 1\n        }\n        if (count == arr.length) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb9ji038i.scala:47)\n\tat Problem.main(tmpb9ji038i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797880
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val max = arr.max\n        val min = arr.min\n        val maxIndex =\
    \ arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n        if (maxIndex\
    \ == n - 1) return true\n        if (minIndex == 0) return false\n        if (maxIndex\
    \ < minIndex) return true\n        if (maxIndex == minIndex) return true\n   \
    \     if (maxIndex == n - 2) return true\n        return false\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphwnay0vz.scala:42)\n\tat Problem.main(tmphwnay0vz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797928
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        for (i <- 0 until arr.length) {\n            if (sorted(i)\
    \ != arr(i)) {\n                if (sorted(i) != arr(i + 1)) return false\n  \
    \              else return true\n            }\n        }\n        return true\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo89omxmg.scala:37)\n\tat Problem.main(tmpo89omxmg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797929
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (min == 1 && max == arr.length) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpl5d4bdwx.scala:38)\n\tat Problem.main(tmpl5d4bdwx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797879
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val min = arr.min\n        val max = arr.max\n        val minIndex =\
    \ arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        if (minIndex\
    \ == 0) return true\n        if (maxIndex == n - 1) return true\n        if (minIndex\
    \ == n - 1) return false\n        if (maxIndex == 0) return false\n        if\
    \ (minIndex < maxIndex) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnvab7kx7.scala:40)\n\tat Problem.main(tmpnvab7kx7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797929
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length <= 1) return true\n        val sorted\
    \ = arr.sorted\n        val min = arr.min\n        val max = arr.max\n       \
    \ val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n \
    \       if (minIndex == 0) {\n            if (maxIndex == arr.length - 1) return\
    \ true\n            else return false\n        }\n        else {\n           \
    \ if (maxIndex == arr.length - 1) return true\n            else return false\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5je26p47.scala:42)\n\tat Problem.main(tmp5je26p47.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797929
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val arr2 = arr.toArray\n        val arr3 = arr.toArray\n        val arr4\
    \ = arr.toArray\n        val arr5 = arr.toArray\n        val arr6 = arr.toArray\n\
    \        val arr7 = arr.toArray\n        val arr8 = arr.toArray\n        val arr9\
    \ = arr.toArray\n        val arr10 = arr.toArray\n        val arr11 = arr.toArray\n\
    \        val arr12 = arr.toArray\n        val arr13 = arr.toArray\n        val\
    \ arr14 = arr.toArray\n        val arr15 = arr.toArray\n        val arr16 = arr.toArray\n\
    \        val arr17 = arr.toArray\n        val arr18 = arr.toArray\n        val\
    \ arr19 = arr.toArray\n        val arr20 = arr.toArray\n        val arr21 = arr.toArray\n\
    \        val arr22 = arr.toArray\n        val arr23 = arr.toArray\n        val\
    \ arr24 = arr.toArray\n        val arr25 = arr.toArray\n        val arr26 = arr.toArray\n\
    \        val arr27 = arr.toArray\n        val arr28 = arr.toArray\n        val\
    \ arr29 = arr.toArray\n        val arr30 = arr.toArray\n        val arr31 = arr.toArray\n\
    \        val arr32 = arr.toArray\n        val arr33 = arr.toArray\n        val\
    \ arr34 = arr.toArray\n        val arr35 = arr.toArray\n        val arr36 = arr.toArray\n\
    \        val arr37 = arr.toArray\n        val arr38 = arr.toArray\n        val\
    \ arr39 = arr.toArray\n        val arr40 = arr.toArray\n        val arr41 = arr.toArray\n\
    \        val arr42 = arr.toArray\n        val arr43 = arr.toArray\n        val\
    \ arr44 = arr.toArray\n        val arr45 = arr.toArray\n        val arr46 = arr.toArray\n\
    \        val arr47 = arr.toArray\n        val arr48 = arr.toArray\n        val\
    \ arr49 = arr.toArray\n        val arr50 = arr.toArray\n        val arr\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4vu2g26u.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4vu2g26u.scala:26:20\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mn\e[0m = arr.length\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                value length is not a member of Null\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp4vu2g26u.scala:28:23 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr2\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ toArray is not a member of Null, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.buffer AsJavaList\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp4vu2g26u.scala:29:23\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36marr3\e[0m = arr.toArray\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toArray is not a member of Null, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Opti"
  stdout: ''
  timestamp: 1659797933
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        val min = sorted.head\n        val max\
    \ = sorted.last\n        val minIndex = arr.indexOf(min)\n        val maxIndex\
    \ = arr.indexOf(max)\n        if (minIndex == 0) {\n            if (maxIndex ==\
    \ n - 1) return true\n            else return false\n        }\n        if (maxIndex\
    \ == n - 1) {\n            if (minIndex == 0) return true\n            else return\
    \ false\n        }\n        if (minIndex > maxIndex) return true\n        else\
    \ return false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2l8w4htx.scala:47)\n\tat Problem.main(tmp2l8w4htx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797929
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var max = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < max) return\
    \ false\n            max = max max arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo3e7acm0.scala:35)\n\tat Problem.main(tmpo3e7acm0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797877
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        var min = arr(0)\n        var max = arr(0)\n        for (i <- 1 until\
    \ n) {\n            min = min min arr(i)\n            max = max max arr(i)\n \
    \       }\n        if (max - min == n - 1) return true\n        else return false\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy74zwxta.scala:39)\n\tat Problem.main(tmpy74zwxta.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        for (i <- 1 until arr.length) {\n            if (arr(i) < min) return\
    \ false\n            min = min min arr(i)\n        }\n        return true\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2ta7mv_z.scala:35)\n\tat Problem.main(tmp2ta7mv_z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val sorted = arr.sorted\n\
    \        val min = sorted.head\n        val max = sorted.last\n        val minIndex\
    \ = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        if (minIndex\
    \ == 0 && maxIndex == arr.length - 1) return true\n        if (minIndex == 0 &&\
    \ maxIndex == arr.length - 2) return true\n        if (minIndex == 1 && maxIndex\
    \ == arr.length - 1) return true\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf7zoe4xd.scala:38)\n\tat Problem.main(tmpf7zoe4xd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val sorted = arr.sorted\n        for (i <- 0 until n) {\n           \
    \ val shifted = arr.slice(i, n) ++ arr.slice(0, i)\n            if (shifted ==\
    \ sorted) return true\n        }\n        return false\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        var min = arr(0)\n\
    \        var max = arr(0)\n        for (i <- 1 until arr.length) {\n         \
    \   if (arr(i) < min) min = arr(i)\n            if (arr(i) > max) max = arr(i)\n\
    \        }\n        if (max - min == arr.length - 1) return true\n        return\
    \ false\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwnut30q1.scala:38)\n\tat Problem.main(tmpwnut30q1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val arr2 = arr.toArray\n        val arr3 = arr.toArray\n        for (i\
    \ <- 0 until n) {\n            arr2(i) = arr(i)\n            arr3(i) = arr(i)\n\
    \        }\n        scala.util.Sorting.quickSort(arr2)\n        val arr4 = arr2.toList\n\
    \        val arr5 = arr3.toList\n        val arr6 = arr4.toArray\n        val\
    \ arr7 = arr5.toArray\n        for (i <- 0 until n) {\n            arr6(i) = arr4(i)\n\
    \            arr7(i) = arr5(i)\n        }\n        scala.util.Sorting.quickSort(arr6)\n\
    \        val arr8 = arr6.toList\n        val arr9 = arr7.toList\n        val arr10\
    \ = arr8.toArray\n        val arr11 = arr9.toArray\n        for (i <- 0 until\
    \ n) {\n            arr10(i) = arr8(i)\n            arr11(i) = arr9(i)\n     \
    \   }\n        scala.util.Sorting.quickSort(arr10)\n        val arr12 = arr10.toList\n\
    \        val arr13 = arr11.toList\n        val arr14 = arr12.toArray\n       \
    \ val arr15 = arr13.toArray\n        for (i <- 0 until n) {\n            arr14(i)\
    \ = arr12(i)\n            arr15(i) = arr13(i)\n        }\n        scala.util.Sorting.quickSort(arr14)\n\
    \        val arr16 = arr14.toList\n        val arr17 = arr15.toList\n        val\
    \ arr18 = arr16.toArray\n        val arr19 = arr17.toArray\n        for (i <-\
    \ 0 until n) {\n            arr18(i) = arr16(i)\n            arr19(i) = arr17(i)\n\
    \        }\n        scala.util.Sorting.quickSort(arr18)\n        val arr20 = arr18.toList\n\
    \        val arr21 = arr19.\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjjt41unq.scala:73:4 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpjjt41unq.scala:73:5 ---------------------\e[0m\e[0m\n\e[31m73\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659797930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        val diff = maxIndex - minIndex\n        if (diff == arr.length - 1) return\
    \ true\n        else return false\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsj_fekk0.scala:37)\n\tat Problem.main(tmpsj_fekk0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        val min = sorted.head\n        val max = sorted.last\n\
    \        val minIndex = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n\
    \        val minDistance = minIndex - 0\n        val maxDistance = arr.length\
    \ - 1 - maxIndex\n        if (minDistance == maxDistance) return true\n      \
    \  if (minDistance < maxDistance) {\n            val newArr = arr.slice(minIndex,\
    \ arr.length) ++ arr.slice(0, minIndex)\n            return newArr == sorted\n\
    \        }\n        else {\n            val newArr = arr.slice(maxIndex + 1, arr.length)\
    \ ++ arr.slice(0, maxIndex + 1)\n            return newArr == sorted\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi7wtrb_d.scala:48)\n\tat Problem.main(tmpi7wtrb_d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val sorted = arr.sorted\n\
    \        val max = arr.max\n        val min = arr.min\n        val maxIndex =\
    \ arr.indexOf(max)\n        val minIndex = arr.indexOf(min)\n        if (maxIndex\
    \ == 0) return false\n        if (minIndex == arr.length - 1) return false\n \
    \       if (maxIndex < minIndex) return true\n        return false\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsoxef0n1.scala:41)\n\tat Problem.main(tmpsoxef0n1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.length == 0) return true\n        val sorted\
    \ = arr.sorted\n        for (i <- 0 until arr.length) {\n            val shifted\
    \ = arr.slice(i, arr.length) ++ arr.slice(0, i)\n            if (shifted == sorted)\
    \ return true\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1659797913
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        if (arr.isEmpty) return true\n        val sorted = arr.sorted\n\
    \        val min = sorted.head\n        val max = sorted.last\n        val minIndex\
    \ = arr.indexOf(min)\n        val maxIndex = arr.indexOf(max)\n        val minDistance\
    \ = minIndex\n        val maxDistance = arr.length - maxIndex - 1\n        if\
    \ (minDistance == maxDistance) return true\n        if (minDistance < maxDistance)\
    \ {\n            if (minIndex == 0) return true\n            else return false\n\
    \        }\n        else {\n            if (maxIndex == arr.length - 1) return\
    \ true\n            else return false\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_6ws7co7.scala:45)\n\tat Problem.main(tmp_6ws7co7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // >>> moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\n    // (true)\n    // Explanation:\
    \ By performin 2 right shift operations, non-decreasing order can\n    // be achieved\
    \ for the given array.\n    // >>> moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 4l.toLong, 1l.toLong, 2l.toLong)))\n    // (false)\n    // Explanation:It is\
    \ not possible to get non-decreasing order for the given\n    // array by performing\
    \ any number of right shift operations.\n    def moveOneBall(arr : List[Long])\
    \ : Boolean = {\n        val n = arr.length\n        if (n == 0) return true\n\
    \        val max = arr.max\n        val min = arr.min\n        if (max - min +\
    \ 1 == n) return true\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp18pe3ei.scala:35)\n\tat Problem.main(tmpp18pe3ei.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659797868
