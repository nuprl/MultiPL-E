name: HumanEval_129_minPath
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a grid with N rows and N columns (N >= 2) and a positive integer k,\
  \ \n    // each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n    // inclusive appears exactly once on the cells of the grid.\n    //\
  \ You have to find the minimum path of length k in the grid. You can start\n   \
  \ // from any cell, and in each step you can move to any of the neighbor cells,\n\
  \    // in other words, you can go to cells which share an edge with you current\n\
  \    // cell.\n    // Please note that a path of length k means visiting exactly\
  \ k cells (not\n    // necessarily distinct).\n    // You CANNOT go off the grid.\n\
  \    // A path A (of length k) is considered less than a path B (of length k) if\n\
  \    // after making the ordered lists of the values on the cells that A and B go\n\
  \    // through (let's call them lst_A and lst_B), lst_A is lexicographically less\n\
  \    // than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n\
  \    // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    //\
  \ lst_A[j] = lst_B[j].\n    // It is guaranteed that the answer is unique.\n   \
  \ // Return an ordered list of the values on the cells that the minimum path go\
  \ through.\n    // Examples:    \n    // >>> minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l))\n    // (List[Long](1l.toLong, 2l.toLong, 1l.toLong))\n\
  \    // >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l))\n    // (List[Long](1l.toLong))\n    def minPath(grid : List[List[Long]],\
  \ k : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong,\
  \ 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong,\
  \ 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong,\
  \ 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong,\
  \ 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong,\
  \ 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](11l.toLong,\
  \ 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong,\
  \ 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong,\
  \ 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong,\
  \ 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong,\
  \ 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong,\
  \ 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong),\
  \ List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong,\
  \ 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong,\
  \ 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong,\
  \ 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong),\
  \ List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        // Write your code here\n        // Return the ordered list\
    \ of the values on the cells that the minimum path go through.\n        return\
    \ List[Long]()", "        // Your code here\n        return List[Long]()", " \
    \       // Write your code here\n        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n    \
    \    val pq = new PriorityQueue[(Long, Int, Int, Int)]()(Ordering.by(-_._1))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j)(1) = grid(i)(j)\n                pq.enqueue((dp(i)(j)(1), i,\
    \ j, 1))\n            }\n        }\n        while (pq.nonEmpty) {\n          \
    \  val (v, i, j, l) = pq.dequeue\n            if (l == k) return List.tabulate(l.toInt)(x\
    \ => dp(i)(j)(x + 1))\n            if (i > 0 && dp(i - 1)(j)(l + 1) == 0) {\n\
    \                dp(i - 1)(j)(l + 1) = v + grid(i - 1)(j)\n                pq.enqueue((dp(i\
    \ - 1)(j)(l + 1), i - 1, j, l + 1))\n            }\n            if (i < n - 1\
    \ && dp(i + 1)(j)(l + 1) == 0) {\n                dp(i + 1)(j)(l + 1) = v + grid(i\
    \ + 1)(j)\n                pq.enqueue((dp(i + 1)(j)(l + 1), i + 1, j, l + 1))\n\
    \            }\n            if (j > 0 && dp(i)(j - 1)(l + 1) == 0) {\n       \
    \         dp(i)(j - 1)(l + 1) = v + grid(i)(j - 1)\n                pq.enqueue((dp(i)(j\
    \ - 1)(l + 1), i, j - 1, l + 1))\n            }\n            if (j < m - 1 &&\
    \ dp(i)(j + 1)(l + 1) == 0) {\n                dp(i)(j + 1)(l + 1) = v + grid(i)(j",
  "        // Write your code here\n        // Return the ordered list of the values\
    \ on the cells that the minimum path go through.\n        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        val path = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                dp(i)(j)(1)\
    \ = grid(i)(j)\n                path(i)(j)(1) = grid(i)(j)\n            }\n  \
    \      }\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until n)\
    \ {\n                for (j <- 0 until m) {\n                    dp(i)(j)(l) =\
    \ Long.MaxValue\n                    for (x <- 0 until n) {\n                \
    \        for (y <- 0 until m) {\n                            if (abs(x - i) +\
    \ abs(y - j) == 1) {\n                                if (dp(x)(y)(l - 1) < dp(i)(j)(l))\
    \ {\n                                    dp(i)(j)(l) = dp(x)(y)(l - 1)\n     \
    \                               path(i)(j)(l) = grid(i)(j)\n                 \
    \               }\n                            }\n                        }\n\
    \                    }\n                }\n            }\n        }\n        var\
    \ min = Long.MaxValue\n        var x = 0\n        var y = 0\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt)\
    \ < min) {\n                    min = dp(i)(j)(k.toInt)\n                    x\
    \ = i\n                    y = j\n                }\n            }\n        }\n\
    \        var ans = List[Long]()\n        for (l <- k.toInt to 1 by -1) {\n   \
    \         ans = path(x)(y)(l) :: ans\n            for (i <- 0 until n) {\n   \
    \             for (j <- 0 until m) {\n                    if (abs(x - i)", " \
    \       // Your code here\n        null", "        // Your code here\n       \
    \ return List[Long]()", "        // Write your code here\n        return List[Long]()",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                if (dp(i)(j).length == k.toInt) {\n                    val lst\
    \ = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n                    if\
    \ (lst.length == k.toInt && lst < dp(i)(j)) dp(i)(j) = lst\n                }\n\
    \            }\n        }\n        dp(n - 1)(m - 1)", "        // Your code here\n\
    \        return List[Long]()", "        // Your code here\n        null", "  \
    \      val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    var min = List[Long]()\n          \
    \          if (i > 0) {\n                        val tmp = dp(i - 1)(j)\n    \
    \                    if (tmp.length == k) min = tmp\n                        else\
    \ if (tmp.length < k) min = tmp :+ grid(i)(j)\n                    }\n       \
    \             if (j > 0) {\n                        val tmp = dp(i)(j - 1)\n \
    \                       if (tmp.length == k) min = tmp\n                     \
    \   else if (tmp.length < k) {\n                            if (min.length ==\
    \ 0) min = tmp :+ grid(i)(j)\n                            else if (min.length\
    \ < k) {\n                                val tmp2 = tmp :+ grid(i)(j)\n     \
    \                           if (tmp2 < min) min = tmp2\n                     \
    \       }\n                        }\n                    }\n                \
    \    dp(i)(j) = min\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1)", "        // grid: List[List[Long]]\n        // k: Long\n     \
    \   // return: List[Long]\n        var n = grid.length\n        var m = grid(0).length\n\
    \        var dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                for (l <- 0 to k.toInt)\
    \ {\n                    dp(i)(j)(l) = Long.MaxValue\n                }\n    \
    \        }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                dp(i)(j)(1) = grid(i)(j)\n            }\n      \
    \  }\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until n) {\n\
    \                for (j <- 0 until m) {\n                    if (i > 0) {\n  \
    \                      dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n \
    \                   }\n                    if (i < n - 1) {\n                \
    \        dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n               \
    \     }\n                    if (j > 0) {\n                        dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n                    }\n           \
    \         if (j < m - 1) {\n                        dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1))\n                    }\n                }\n           \
    \ }\n        }\n        var ans = Long.MaxValue\n        var ansi = -1\n     \
    \   var ansj = -1\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (dp(i)(j)(k.toInt) < ans) {\n                    ans\
    \ = dp(i)(j)(k.toInt)\n                    ansi = i\n                    ansj\
    \ = j\n                }\n            }", "        val n = grid.length\n     \
    \   val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val dp2 = Array.fill(n, m)(List[Long]())\n        val dirs = List((0,\
    \ 1), (0, -1), (1, 0), (-1, 0))\n        def valid(x : Int, y : Int) : Boolean\
    \ = {\n            x >= 0 && x < n && y >= 0 && y < m\n        }\n        def\
    \ dfs(x : Int, y : Int, k : Long) : Long = {\n            if (dp(x)(y) != Long.MaxValue)\
    \ return dp(x)(y)\n            if (k == 0) return grid(x)(y)\n            var\
    \ min = Long.MaxValue\n            var minPath = List[Long]()\n            for\
    \ (dir <- dirs) {\n                val nx = x + dir._1\n                val ny\
    \ = y + dir._2\n                if (valid(nx, ny)) {\n                    val\
    \ cur = dfs(nx, ny, k - 1)\n                    if (cur < min) {\n           \
    \             min = cur\n                        minPath = grid(x)(y) :: dp2(nx)(ny)\n\
    \                    }\n                }\n            }\n            dp(x)(y)\
    \ = min\n            dp2(x)(y) = minPath\n            min\n        }\n       \
    \ var min = Long.MaxValue\n        var minPath = List[Long]()\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                val cur\
    \ = dfs(i, j, k - 1)\n                if (cur < min) {\n                    min\
    \ = cur\n                    minPath = dp2(i)(j)\n                }\n        \
    \    }\n        }\n        minPath", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if\
    \ (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                else\
    \ if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n               \
    \ else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n        \
    \        if (dp(i)(j).length > k.toInt) dp(i)(j) = dp(i)(j).dropRight(1)\n   \
    \             if (j > 0) {\n                    val tmp = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                    if (tmp.length > k.toInt) tmp.dropRight(1)\n            \
    \        if (tmp.length < k.toInt) tmp\n                    else if (tmp < dp(i)(j))\
    \ dp(i)(j) = tmp\n                }\n            }\n        }\n        dp(n -\
    \ 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n \
    \       val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else dp(i)(j) = (dp(i - 1)(j)\
    \ :+ grid(i)(j)).sorted.take(k.toInt)\n                if (j > 0) {\n        \
    \            val l = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n     \
    \               if (l.length < dp(i)(j).length || (l.length == dp(i)(j).length\
    \ && l < dp(i)(j))) dp(i)(j) = l\n                }\n            }\n        }\n\
    \        dp(n - 1)(m - 1)", "        // Your code here\n        return List[Long]()",
  "        // Fill in the code here\n        null", "        // Your code here\n \
    \       return List[Long]()", "        // Your code here\n        return List[Long]()",
  "        // Fill in the code here\n        return List[Long]()", "        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val dp2 = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  dp(i)(j) = grid(i)(j)\n                dp2(i)(j) = List(grid(i)(j))\n     \
    \       }\n        }\n        for (i <- 1 until n) {\n            for (j <- 0\
    \ until m) {\n                if (dp(i - 1)(j) < dp(i)(j)) {\n               \
    \     dp(i)(j) = dp(i - 1)(j)\n                    dp2(i)(j) = dp2(i - 1)(j)\n\
    \                }\n            }\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 1 until m) {\n                if (dp(i)(j - 1) < dp(i)(j))\
    \ {\n                    dp(i)(j) = dp(i)(j - 1)\n                    dp2(i)(j)\
    \ = dp2(i)(j - 1)\n                }\n            }\n        }\n        for (i\
    \ <- 1 until n) {\n            for (j <- 1 until m) {\n                if (dp(i\
    \ - 1)(j - 1) < dp(i)(j)) {\n                    dp(i)(j) = dp(i - 1)(j - 1)\n\
    \                    dp2(i)(j) = dp2(i - 1)(j - 1)\n                }\n      \
    \      }\n        }\n        val dp3 = Array.fill(n, m)(Long.MaxValue)\n     \
    \   val dp4 = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                dp3(i)(j) = dp(i)(j)\n  \
    \              dp4(i)(j) = dp2(i)(j)\n            }\n        }\n        for (i",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0l)\n        val path = Array.fill(n, m)(List[Long]())\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (i == 0\
    \ && j == 0) {\n                    dp(i)(j) = grid(i)(j)\n                  \
    \  path(i)(j) = List(grid(i)(j))\n                } else if (i == 0) {\n     \
    \               dp(i)(j) = dp(i)(j - 1) + grid(i)(j)\n                    path(i)(j)\
    \ = path(i)(j - 1) :+ grid(i)(j)\n                } else if (j == 0) {\n     \
    \               dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n                    path(i)(j)\
    \ = path(i - 1)(j) :+ grid(i)(j)\n                } else {\n                 \
    \   if (dp(i - 1)(j) < dp(i)(j - 1)) {\n                        dp(i)(j) = dp(i\
    \ - 1)(j) + grid(i)(j)\n                        path(i)(j) = path(i - 1)(j) :+\
    \ grid(i)(j)\n                    } else {\n                        dp(i)(j) =\
    \ dp(i)(j - 1) + grid(i)(j)\n                        path(i)(j) = path(i)(j -\
    \ 1) :+ grid(i)(j)\n                    }\n                }\n            }\n\
    \        }\n        path(n - 1)(m - 1).take(k.toInt)", "        // Write your\
    \ code here\n        return List[Long]()", "        // Write your code here\n\
    \        // Return the ordered list of the values on the cells that the minimum\
    \ path go through.\n        List[Long]()", "        // Your code here\n      \
    \  return List[Long]()", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = List(grid(i)(j))\
    \ ::: dp(i)(j - 1)\n                else if (j == 0) dp(i)(j) = List(grid(i)(j))\
    \ ::: dp(i - 1)(j)\n                else {\n                    val a = List(grid(i)(j))\
    \ ::: dp(i)(j - 1)\n                    val b = List(grid(i)(j)) ::: dp(i - 1)(j)\n\
    \                    if (a < b) dp(i)(j) = a\n                    else dp(i)(j)\
    \ = b\n                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        // Your code here\n        return List[Long]()", "        // Your code\
    \ here\n        return List[Long]()", "        // Write your code here\n     \
    \   return List[Long]()", "        // Your code here\n        null", "       \
    \ // Your code here\n        return List[Long]()", "        // Write your code\
    \ here\n        // Return a list of values on the cells that the minimum path\
    \ go through\n        val n = grid.length\n        val m = grid(0).length\n  \
    \      val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        val path = Array.ofDim[Int](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until m) {\n          \
    \  dp(i)(j)(1) = grid(i)(j)\n            path(i)(j)(1) = -1\n        }\n     \
    \   for (l <- 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until m)\
    \ {\n                dp(i)(j)(l) = Long.MaxValue\n                path(i)(j)(l)\
    \ = -1\n                if (i > 0 && dp(i - 1)(j)(l - 1) < dp(i)(j)(l)) {\n  \
    \                  dp(i)(j)(l) = dp(i - 1)(j)(l - 1)\n                    path(i)(j)(l)\
    \ = 0\n                }\n                if (i < n - 1 && dp(i + 1)(j)(l - 1)\
    \ < dp(i)(j)(l)) {\n                    dp(i)(j)(l) = dp(i + 1)(j)(l - 1)\n  \
    \                  path(i)(j)(l) = 1\n                }\n                if (j\
    \ > 0 && dp(i)(j - 1)(l - 1) < dp(i)(j)(l)) {\n                    dp(i)(j)(l)\
    \ = dp(i)(j - 1)(l - 1)\n                    path(i)(j)(l) = 2\n             \
    \   }\n                if (j < m - 1 && dp(i)(j + 1)(l - 1) < dp(i)(j)(l)) {\n\
    \                    dp(i)(j)(l) = dp(i)(j + 1)(l - 1)\n                    path(i)(j)(l)\
    \ = 3\n                }\n                dp(i)(j)(l) += grid(i)(j)\n        \
    \   ", "        // Your code here\n        null", "        // Write your code\
    \ here\n        // Return the ordered list of the values on the cells that the\
    \ minimum path go through\n        return List[Long]()", "        // Your code\
    \ here\n        return List[Long]()", "        // Your code here\n        return\
    \ List[Long]()", "        // Your code here\n        null", "        // Write\
    \ your code here\n        return List[Long]()", "        // Your code here\n \
    \       null", "        // Write your code here\n        // Return an ordered\
    \ list of the values on the cells that the minimum path go through.\n        return\
    \ List[Long]()", "        // Fill in the code here\n        null", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (grid(i)(j) :: dp(i)(j - 1)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (grid(i)(j) :: dp(i - 1)(j)).sorted\n\
    \                else {\n                    val a = dp(i - 1)(j)\n          \
    \          val b = dp(i)(j - 1)\n                    var i1 = 0\n            \
    \        var i2 = 0\n                    var res = List[Long]()\n            \
    \        while (i1 < a.length && i2 < b.length) {\n                        if\
    \ (a(i1) < b(i2)) {\n                            res = a(i1) :: res\n        \
    \                    i1 += 1\n                        }\n                    \
    \    else {\n                            res = b(i2) :: res\n                \
    \            i2 += 1\n                        }\n                    }\n     \
    \               while (i1 < a.length) {\n                        res = a(i1) ::\
    \ res\n                        i1 += 1\n                    }\n              \
    \      while (i2 < b.length) {\n                        res = b(i2) :: res\n \
    \                       i2 += 1\n                    }\n                    dp(i)(j)\
    \ = (grid(i)(j) :: res).sorted\n                }\n            }\n        }\n\
    \        dp(n - 1)(m - 1).take(k.toInt)", "        // Write your code here\n \
    \       // Return the ordered list of the values on the cells that the minimum\
    \ path go through.\n        List[Long]()", "        // Write your code here\n\
    \        // Return the ordered list of the values on the cells that the minimum\
    \ path go through.\n        var result = List[Long]()\n        var min = Long.MaxValue\n\
    \        for (i <- 0 until grid.length) {\n            for (j <- 0 until grid(i).length)\
    \ {\n                var path = List[Long]()\n                var visited = Array.ofDim[Boolean](grid.length,\
    \ grid(0).length)\n                var queue = Queue[(Int, Int)]()\n         \
    \       queue.enqueue((i, j))\n                while (!queue.isEmpty) {\n    \
    \                var (x, y) = queue.dequeue\n                    if (visited(x)(y))\
    \ continue\n                    visited(x)(y) = true\n                    path\
    \ = path :+ grid(x)(y)\n                    if (path.length == k) {\n        \
    \                if (path.mkString(\"\") < min.toString) {\n                 \
    \           min = path.mkString(\"\").toLong\n                            result\
    \ = path\n                        }\n                        break\n         \
    \           }\n                    if (x > 0 && !visited(x - 1)(y)) queue.enqueue((x\
    \ - 1, y))\n                    if (x < grid.length - 1 && !visited(x + 1)(y))\
    \ queue.enqueue((x + 1, y))\n                    if (y > 0 && !visited(x)(y -\
    \ 1)) queue.enqueue((x, y - 1))\n                    if (y < grid(0).length -\
    \ 1 && !visited(x)(y + 1)) queue.enqueue((x, y + 1))\n                }\n    \
    \        }\n        }\n        return result", "        // Write your code here\n\
    \        // Return the ordered list of the values on the cells that the minimum\
    \ path go through.\n        List[Long]()", "        val n = grid.length\n    \
    \    val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List[Long](grid(i)(j))\n                if (i > 0 && dp(i\
    \ - 1)(j).length > 0 && dp(i - 1)(j).head < dp(i)(j).head) dp(i)(j) = dp(i - 1)(j)\n\
    \                if (j > 0 && dp(i)(j - 1).length > 0 && dp(i)(j - 1).head < dp(i)(j).head)\
    \ dp(i)(j) = dp(i)(j - 1)\n            }\n        }\n        var result = List[Long]()\n\
    \        var i = n - 1\n        var j = m - 1\n        while (k > 0) {\n     \
    \       if (i > 0 && dp(i - 1)(j).length > 0 && dp(i - 1)(j).head < dp(i)(j).head)\
    \ {\n                result = dp(i - 1)(j).head :: result\n                i -=\
    \ 1\n            } else if (j > 0 && dp(i)(j - 1).length > 0 && dp(i)(j - 1).head\
    \ < dp(i)(j).head) {\n                result = dp(i)(j - 1).head :: result\n \
    \               j -= 1\n            } else {\n                result = dp(i)(j).head\
    \ :: result\n                i -= 1\n                j -= 1\n            }\n \
    \           k -= 1\n        }\n        result", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n   \
    \             if (dp(i)(j).length > k.toInt) dp(i)(j) = dp(i)(j).take(k.toInt)\n\
    \                if (j > 0) {\n                    val temp = (dp(i)(j - 1) :+\
    \ grid(i)(j)).sorted\n                    if (temp.length > k.toInt) temp.take(k.toInt)\n\
    \                    if (temp.length < k.toInt) dp(i)(j) = temp\n            \
    \        else if (temp < dp(i)(j)) dp(i)(j) = temp\n                }\n      \
    \      }\n        }\n        dp(n - 1)(m - 1)", "        // Write your code here\n\
    \        // Return the ordered list of the values on the cells that the minimum\
    \ path go through.\n        List[Long]()", "        // Write your code here\n\
    \        return List[Long]()", "        // Your code here\n        null", "  \
    \      val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                if (dp(i)(j).length == k.toInt) dp(i)(j) = dp(i)(j).take(k.toInt\
    \ - 1) :+ grid(i)(j)\n                if (j > 0) {\n                    val tmp\
    \ = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                    if (tmp.length ==\
    \ k.toInt) tmp = tmp.take(k.toInt - 1) :+ grid(i)(j)\n                    if (tmp.length\
    \ <= k.toInt && tmp < dp(i)(j)) dp(i)(j) = tmp\n                }\n          \
    \  }\n        }\n        dp(n - 1)(m - 1)", "        // Write your code here\n\
    \        val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until\
    \ m; l <- 0 to k.toInt) dp(i)(j)(l) = Long.MaxValue\n        for (i <- 0 until\
    \ n; j <- 0 until m) dp(i)(j)(1) = grid(i)(j)\n        for (l <- 2 to k.toInt)\
    \ {\n            for (i <- 0 until n; j <- 0 until m) {\n                if (i\
    \ - 1 >= 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n            \
    \    if (i + 1 < n) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n    \
    \            if (j - 1 >= 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n\
    \                if (j + 1 < m) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l\
    \ - 1))\n            }\n        }\n        var ans = List[Long]()\n        var\
    \ i = 0\n        var j = 0\n        var l = k.toInt\n        while (l > 0) {\n\
    \            ans = grid(i)(j) :: ans\n            if (i - 1 >= 0 && dp(i - 1)(j)(l\
    \ - 1) == dp(i)(j)(l)) {\n                i -= 1\n            } else if (i + 1\
    \ < n && dp(i + 1)(j)(l - 1) == dp(i)(j)(l)) {\n                i += 1\n     \
    \       } else if (j - 1 >= 0 && dp(i)(j - 1)(l - 1) == dp(i)(j)(l)) {\n     \
    \           j -= 1\n            } else if (j + 1 <", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n   \
    \             if (dp(i)(j).length > k.toInt) dp(i)(j) = dp(i)(j).take(k.toInt)\n\
    \                if (j > 0) {\n                    val temp = (dp(i)(j - 1) :+\
    \ grid(i)(j)).sorted\n                    if (temp.length > k.toInt) temp.take(k.toInt)\n\
    \                    if (temp.length < k.toInt) dp(i)(j) = temp\n            \
    \        else if (temp < dp(i)(j)) dp(i)(j) = temp\n                }\n      \
    \      }\n        }\n        dp(n - 1)(m - 1)", "        // Write your code here\n\
    \        // Return the ordered list of the values on the cells that the minimum\
    \ path go through.\n        List[Long]()", "        // Your code here\n      \
    \  return List[Long]()", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) {\n          \
    \          if (dp(i)(j - 1).length < k) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    else if (dp(i)(j - 1).length == k) {\n                  \
    \      val lst = dp(i)(j - 1) :+ grid(i)(j)\n                        if (lst <\
    \ dp(i)(j)) dp(i)(j) = lst\n                    }\n                }\n       \
    \         else if (j == 0) {\n                    if (dp(i - 1)(j).length < k)\
    \ dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                    else if (dp(i - 1)(j).length\
    \ == k) {\n                        val lst = dp(i - 1)(j) :+ grid(i)(j)\n    \
    \                    if (lst < dp(i)(j)) dp(i)(j) = lst\n                    }\n\
    \                }\n                else {\n                    if (dp(i - 1)(j).length\
    \ < k) {\n                        val lst = dp(i - 1)(j) :+ grid(i)(j)\n     \
    \                   if (lst < dp(i)(j)) dp(i)(j) = lst\n                    }\n\
    \                    if (dp(i)(j - 1).length < k) {\n                        val\
    \ lst = dp(i)(j - 1) :+ grid(i)(j)\n                        if (lst < dp(i)(j))\
    \ dp(i)(j) = lst\n                    }\n                }\n            }\n  \
    \      }\n        dp(n - 1)(m - 1)", "        // Your code here\n        return\
    \ List[Long]()", "        // Your code here\n        return List()", "       \
    \ // Write your code here\n        var result = List[Long]()\n        var min\
    \ = Long.MaxValue\n        for (i <- 0 until grid.length) {\n            for (j\
    \ <- 0 until grid(i).length) {\n                var path = List[Long]()\n    \
    \            var sum = 0l\n                dfs(grid, i, j, k, path, sum)\n   \
    \             if (sum < min) {\n                    min = sum\n              \
    \      result = path\n                }\n            }\n        }\n        result",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) {\n                    if (dp(i)(j - 1).length\
    \ < k) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                    else if (dp(i)(j\
    \ - 1).length == k) {\n                        if (dp(i)(j - 1).last > grid(i)(j))\
    \ dp(i)(j) = dp(i)(j - 1).init :+ grid(i)(j)\n                        else dp(i)(j)\
    \ = dp(i)(j - 1)\n                    }\n                    else dp(i)(j) = dp(i)(j\
    \ - 1)\n                }\n                else if (j == 0) {\n              \
    \      if (dp(i - 1)(j).length < k) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n  \
    \                  else if (dp(i - 1)(j).length == k) {\n                    \
    \    if (dp(i - 1)(j).last > grid(i)(j)) dp(i)(j) = dp(i - 1)(j).init :+ grid(i)(j)\n\
    \                        else dp(i)(j) = dp(i - 1)(j)\n                    }\n\
    \                    else dp(i)(j) = dp(i - 1)(j)\n                }\n       \
    \         else {\n                    if (dp(i - 1)(j).length < k) {\n       \
    \                 if (dp(i)(j - 1).length < k) {\n                           \
    \ if (dp(i - 1)(j).last < dp(i)(j - 1).last) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                            else dp(i)(j) = dp", "        // Write your code\
    \ here\n        // Return the ordered list of the values on the cells that the\
    \ minimum path go through.\n        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n; j <- 0 until m; l <- 0 to k.toInt) dp(i)(j)(l) = Long.MaxValue\n        for\
    \ (i <- 0 until n; j <- 0 until m) dp(i)(j)(1) = grid(i)(j)\n        for (l <-\
    \ 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until m) {\n      \
    \          if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n  \
    \              if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l -\
    \ 1))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l\
    \ - 1))\n                if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ + 1)(l - 1))\n            }\n        }\n        var min = Long.MaxValue\n  \
    \      var min_i = -1\n        var min_j = -1\n        for (i <- 0 until n; j\
    \ <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min) {\n              \
    \  min = dp(i)(j)(k.toInt)\n                min_i = i\n                min_j =\
    \ j\n            }\n        }\n        val ans = ListBuffer[Long]()\n        ans\
    \ += grid(min_i)(min_j)\n        var cur_i = min_i\n        var cur_j = min_j\n\
    \        for (l <- k.toInt - 1 to 1 by -1) {\n            if (", "        // Your\
    \ code here\n        return List[Long]()", "        val n = grid.length\n    \
    \    val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) {\n                    val lst = dp(i)(j - 1)\n                \
    \    if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n                    else\
    \ if (lst.length == k) {\n                        val lst2 = lst :+ grid(i)(j)\n\
    \                        if (lst2 < dp(i)(j)) dp(i)(j) = lst2\n              \
    \      }\n                }\n                else if (j == 0) {\n            \
    \        val lst = dp(i - 1)(j)\n                    if (lst.length < k) dp(i)(j)\
    \ = lst :+ grid(i)(j)\n                    else if (lst.length == k) {\n     \
    \                   val lst2 = lst :+ grid(i)(j)\n                        if (lst2\
    \ < dp(i)(j)) dp(i)(j) = lst2\n                    }\n                }\n    \
    \            else {\n                    val lst1 = dp(i - 1)(j)\n           \
    \         val lst2 = dp(i)(j - 1)\n                    if (lst1.length < k) {\n\
    \                        if (lst1.length + 1 < lst2.length) dp(i)(j) = lst1 :+\
    \ grid(i)(j)\n                        else if (lst1.length + 1 == lst2.length)\
    \ {\n                            val lst3 = lst1 :+ grid(i)(j)\n             \
    \               if (lst3 < dp(i)(j)) dp(i)(j) = lst3\n                       \
    \ }\n                    }\n                    else if (lst1.length == k) {\n\
    \                        val lst3 = lst1 :+ grid(i)(j)\n                     \
    \   if", "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val candidates = ListBuffer[List[Long]]()\n         \
    \           if (i > 0) candidates += (grid(i)(j) :: dp(i - 1)(j))\n          \
    \          if (j > 0) candidates += (grid(i)(j) :: dp(i)(j - 1))\n           \
    \         if (i > 0 && j > 0) candidates += (grid(i)(j) :: dp(i - 1)(j - 1))\n\
    \                    dp(i)(j) = candidates.minBy(x => x)\n                }\n\
    \            }\n        }\n        dp(n - 1)(n - 1).take(k.toInt)", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = List(grid(i)(j)) ++ dp(i)(j - 1)\n\
    \                else if (j == 0) dp(i)(j) = List(grid(i)(j)) ++ dp(i - 1)(j)\n\
    \                else {\n                    val l1 = List(grid(i)(j)) ++ dp(i)(j\
    \ - 1)\n                    val l2 = List(grid(i)(j)) ++ dp(i - 1)(j)\n      \
    \              if (l1.length < l2.length) dp(i)(j) = l1\n                    else\
    \ if (l1.length > l2.length) dp(i)(j) = l2\n                    else {\n     \
    \                   var flag = true\n                        for (i <- 0 until\
    \ l1.length) {\n                            if (l1(i) < l2(i)) {\n           \
    \                     dp(i)(j) = l1\n                                flag = false\n\
    \                                break\n                            }\n      \
    \                      else if (l1(i) > l2(i)) {\n                           \
    \     dp(i)(j) = l2\n                                flag = false\n          \
    \                      break\n                            }\n                \
    \        }\n                        if (flag) dp(i)(j) = l1\n                \
    \    }\n                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) {\n                    val lst = dp(i)(j - 1)\n\
    \                    if (lst.length == k) dp(i)(j) = lst\n                   \
    \ else dp(i)(j) = (grid(i)(j) :: lst).sorted\n                }\n            \
    \    else if (j == 0) {\n                    val lst = dp(i - 1)(j)\n        \
    \            if (lst.length == k) dp(i)(j) = lst\n                    else dp(i)(j)\
    \ = (grid(i)(j) :: lst).sorted\n                }\n                else {\n  \
    \                  val lst1 = dp(i - 1)(j)\n                    val lst2 = dp(i)(j\
    \ - 1)\n                    if (lst1.length == k) dp(i)(j) = lst1\n          \
    \          else if (lst2.length == k) dp(i)(j) = lst2\n                    else\
    \ {\n                        val lst = (grid(i)(j) :: lst1).sorted\n         \
    \               if (lst.length > k) dp(i)(j) = lst2\n                        else\
    \ {\n                            val lst = (grid(i)(j) :: lst2).sorted\n     \
    \                       if (lst.length > k) dp(i)(j) = lst1\n                \
    \            else dp(i)(j) = lst\n                        }\n                \
    \    }\n                }\n            }\n        }\n        dp(n - 1)(m - 1)",
  "        // Your code here\n        return List[Long]()", "        // Your code\
    \ here\n        return List[Long]()", "        // Your code here\n        return\
    \ List[Long]()", "        // Your code here\n        return List[Long]()", " \
    \       // Your code here\n        return List[Long]()", "        // Fill in the\
    \ code here\n        List[Long]()", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if\
    \ (i == 0) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                else if (j ==\
    \ 0) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                else {\n         \
    \           val up = dp(i - 1)(j) :+ grid(i)(j)\n                    val left\
    \ = dp(i)(j - 1) :+ grid(i)(j)\n                    if (up.length == left.length)\
    \ {\n                        if (up < left) dp(i)(j) = up\n                  \
    \      else dp(i)(j) = left\n                    }\n                    else if\
    \ (up.length < left.length) dp(i)(j) = up\n                    else dp(i)(j) =\
    \ left\n                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) {\n                    val prev = dp(i)(j - 1)\n\
    \                    if (prev.length < k) dp(i)(j) = prev :+ grid(i)(j)\n    \
    \                else if (prev.length == k) {\n                        val cur\
    \ = grid(i)(j)\n                        if (prev.last > cur) dp(i)(j) = prev.init\
    \ :+ cur\n                        else dp(i)(j) = prev\n                    }\n\
    \                    else dp(i)(j) = prev\n                }\n               \
    \ else if (j == 0) {\n                    val prev = dp(i - 1)(j)\n          \
    \          if (prev.length < k) dp(i)(j) = prev :+ grid(i)(j)\n              \
    \      else if (prev.length == k) {\n                        val cur = grid(i)(j)\n\
    \                        if (prev.last > cur) dp(i)(j) = prev.init :+ cur\n  \
    \                      else dp(i)(j) = prev\n                    }\n         \
    \           else dp(i)(j) = prev\n                }\n                else {\n\
    \                    val prev1 = dp(i - 1)(j)\n                    val prev2 =\
    \ dp(i)(j - 1)\n                    if (prev1.length < k && prev2.length < k)\
    \ {\n                        val cur = grid(i)(j)\n                        if\
    \ (prev1.last > cur && prev2.last > cur) dp(i)(j) = prev1.init :+ cur\n      \
    \                  else if (prev1.last > cur) dp(i)(j) = prev1.init :+ cur\n \
    \                       else if (prev2.last > cur) dp(i)(j) = prev2.init :+ cur\n\
    \                        else dp(i)(j) = prev1\n                    }\n      \
    \             ", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) {\n          \
    \          val prev = dp(i)(j - 1)\n                    if (prev.length < k) dp(i)(j)\
    \ = prev :+ grid(i)(j)\n                    else if (prev.length == k) {\n   \
    \                     if (prev.last < grid(i)(j)) dp(i)(j) = prev\n          \
    \              else dp(i)(j) = prev.init :+ grid(i)(j)\n                    }\n\
    \                }\n                else if (j == 0) {\n                    val\
    \ prev = dp(i - 1)(j)\n                    if (prev.length < k) dp(i)(j) = prev\
    \ :+ grid(i)(j)\n                    else if (prev.length == k) {\n          \
    \              if (prev.last < grid(i)(j)) dp(i)(j) = prev\n                 \
    \       else dp(i)(j) = prev.init :+ grid(i)(j)\n                    }\n     \
    \           }\n                else {\n                    val prev1 = dp(i -\
    \ 1)(j)\n                    val prev2 = dp(i)(j - 1)\n                    if\
    \ (prev1.length < k && prev2.length < k) {\n                        if (prev1.last\
    \ < prev2.last) dp(i)(j) = prev1 :+ grid(i)(j)\n                        else dp(i)(j)\
    \ = prev2 :+ grid(i)(j)\n                    }\n                    else if (prev1.length\
    \ < k) {\n                        if (prev1.last < prev2.last) dp(i)(j) = prev1\
    \ :+ grid(i)(j)\n                        else dp(i)(j) = prev2\n             \
    \       }\n                    else if (prev2.length < k) {\n                \
    \        if (prev1.last < prev2.last)", "        // Your code here\n        return\
    \ List[Long]()", "        // Your code here\n        return List[Long]()", " \
    \       // Your code here\n        return List[Long]()", "        // Fill in the\
    \ code here\n        return null", "        // Your code here\n        return\
    \ null", "        // Your code here\n        return List[Long]()", "        //\
    \ Fill in the code here\n        null", "        // Your code here\n        return\
    \ List[Long]()", "        // Write your code here\n        // Return the ordered\
    \ list of values on the cells that the minimum path go through\n        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.ofDim[Long](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt)\
    \ dp(i)(j)(l) = Long.MaxValue\n        for (i <- 0 until n; j <- 0 until m) dp(i)(j)(1)\
    \ = grid(i)(j)\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until\
    \ n; j <- 0 until m) {\n                if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i - 1)(j)(l - 1))\n                if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i + 1)(j)(l - 1))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j - 1)(l - 1))\n                if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1))\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var minI = -1\n        var minJ = -1\n        for (i <- 0 until n; j\
    \ <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min) {\n              \
    \  min = dp(i)(j)(k.toInt)\n                minI = i\n                minJ = j\n\
    \            }\n        }\n        val path = ListBuffer[Long]()\n        var\
    \ i = minI\n        var j = minJ\n        var l = k.toInt\n        while (l >\
    \ 0) {\n            path += grid(i)(j)\n            l -= 1\n            if (i\
    \ > 0 && dp(i)(j)(l", "        // Your code here\n        return List[Long]()",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(0)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n\
    \                dp(i)(j) = grid(i)(j)\n            }\n        }\n        for\
    \ (i <- 1 until n) {\n            dp(i)(0) += dp(i - 1)(0)\n        }\n      \
    \  for (j <- 1 until m) {\n            dp(0)(j) += dp(0)(j - 1)\n        }\n \
    \       for (i <- 1 until n) {\n            for (j <- 1 until m) {\n         \
    \       dp(i)(j) += min(dp(i - 1)(j), dp(i)(j - 1))\n            }\n        }\n\
    \        val result = ArrayBuffer[Long]()\n        var i = n - 1\n        var\
    \ j = m - 1\n        while (k > 0) {\n            result += grid(i)(j)\n     \
    \       if (i == 0) {\n                j -= 1\n            } else if (j == 0)\
    \ {\n                i -= 1\n            } else {\n                if (dp(i -\
    \ 1)(j) < dp(i)(j - 1)) {\n                    i -= 1\n                } else\
    \ {\n                    j -= 1\n                }\n            }\n          \
    \  k -= 1\n        }\n        result.toList", "        // Your code here\n   \
    \     return List[Long]()", "        // Your code here\n        null", "     \
    \   val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                if (dp(i)(j).length > k.toInt) dp(i)(j) = dp(i)(j).dropRight(1)\n\
    \                if (j > 0) {\n                    val temp = (dp(i)(j - 1) :+\
    \ grid(i)(j)).sorted\n                    if (temp.length > k.toInt) temp.dropRight(1)\n\
    \                    if (temp.length == k.toInt && temp < dp(i)(j)) dp(i)(j) =\
    \ temp\n                }\n            }\n        }\n        dp(n - 1)(m - 1)",
  "        // Write your code here\n        null", "        // Your code here\n  \
    \      return List[Long]()", "        // Your code here\n        return List[Long]()",
  "        // Write your code here\n        // Return the ordered list of the values\
    \ on the cells that the minimum path go through.\n        List[Long]()", "   \
    \     // Write your code here\n        return List[Long]()", "        var n =\
    \ grid.length\n        var m = grid(0).length\n        var dp = Array.ofDim[Long](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                for (l <- 0 to k.toInt) {\n                    dp(i)(j)(l)\
    \ = Long.MaxValue\n                }\n            }\n        }\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                dp(i)(j)(1)\
    \ = grid(i)(j)\n            }\n        }\n        for (l <- 2 to k.toInt) {\n\
    \            for (i <- 0 until n) {\n                for (j <- 0 until m) {\n\
    \                    if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l\
    \ - 1))\n                    if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i\
    \ + 1)(j)(l - 1))\n                    if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j - 1)(l - 1))\n                    if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1))\n                }\n            }\n        }\n        var\
    \ ans = Long.MaxValue\n        var x = 0\n        var y = 0\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt)\
    \ < ans) {\n                    ans = dp(i)(j)(k.toInt)\n                    x\
    \ = i\n                    y = j\n                }\n            }\n        }\n\
    \        var res = List[Long]()\n        res = res :+ ans\n        for (l <- k.toInt\
    \ - 1 to 1 by -1) {\n            if (x > 0 && dp(x)(y)(l", "        // Write your\
    \ code here\n        val n = grid.length\n        val m = grid(0).length\n   \
    \     val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        val path = Array.ofDim[Long](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                dp(i)(j)(1) = grid(i)(j)\n                path(i)(j)(1)\
    \ = grid(i)(j)\n            }\n        }\n        for (l <- 2 to k.toInt) {\n\
    \            for (i <- 0 until n) {\n                for (j <- 0 until m) {\n\
    \                    dp(i)(j)(l) = Long.MaxValue\n                    for (di\
    \ <- -1 to 1) {\n                        for (dj <- -1 to 1) {\n             \
    \               if (di * di + dj * dj == 1) {\n                              \
    \  val ni = i + di\n                                val nj = j + dj\n        \
    \                        if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n     \
    \                               if (dp(ni)(nj)(l - 1) < dp(i)(j)(l)) {\n     \
    \                                   dp(i)(j)(l) = dp(ni)(nj)(l - 1)\n        \
    \                                path(i)(j)(l) = grid(i)(j)\n                \
    \                    }\n                                }\n                  \
    \          }\n                        }\n                    }\n             \
    \   }\n            }\n        }\n        var min = Long.MaxValue\n        var\
    \ minx = 0\n        var miny = 0\n        for (i <- 0 until n) {\n           \
    \ for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt) < min) {\n   \
    \                 min = dp(i)(j)(k.toInt)\n                    minx = i\n    \
    \                miny = j\n                }\n            }\n        }\n     \
    \   var ans = List[Long]()\n        for (l <- k.toInt to 1 by -1) {\n        \
    \    ans = path(minx)(miny)(l) :: ans\n", "        // Your code here\n       \
    \ null", "        // Your code here\n        return List[Long]()", "        //\
    \ Your code here\n        return List[Long]()", "        // Fill in the code here\n\
    \        return List[Long]()", "        // Write your code here\n        var result\
    \ = List[Long]()\n        var min = Long.MaxValue\n        for (i <- 0 until grid.length)\
    \ {\n            for (j <- 0 until grid(i).length) {\n                var path\
    \ = List[Long]()\n                var visited = Array.ofDim[Boolean](grid.length,\
    \ grid(0).length)\n                var queue = Queue[(Int, Int)]()\n         \
    \       queue.enqueue((i, j))\n                while (!queue.isEmpty) {\n    \
    \                var (x, y) = queue.dequeue\n                    if (visited(x)(y))\
    \ {\n                        continue\n                    }\n               \
    \     visited(x)(y) = true\n                    path = path :+ grid(x)(y)\n  \
    \                  if (path.length == k) {\n                        if (path.sum\
    \ < min) {\n                            min = path.sum\n                     \
    \       result = path\n                        }\n                        else\
    \ if (path.sum == min) {\n                            if (path < result) {\n \
    \                               result = path\n                            }\n\
    \                        }\n                        break\n                  \
    \  }\n                    if (x > 0) {\n                        queue.enqueue((x\
    \ - 1, y))\n                    }\n                    if (x < grid.length - 1)\
    \ {\n                        queue.enqueue((x + 1, y))\n                    }\n\
    \                    if (y > 0) {\n                        queue.enqueue((x, y\
    \ - 1))\n                    }\n                    if (y < grid(x).length - 1)\
    \ {\n                        queue.enqueue((x, y + 1))\n                    }\n\
    \                }\n            }\n        }\n        return result", "      \
    \  // Write your code here\n        List[Long]()", "        // Your code here\n\
    \        return List[Long]()", "        // Fill in the code here\n        null",
  "        val n = grid.length\n        val dp = Array.fill(n, n)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until n) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ {\n                    val lst = ListBuffer[List[Long]]()\n                \
    \    if (i > 0) lst += dp(i - 1)(j)\n                    if (j > 0) lst += dp(i)(j\
    \ - 1)\n                    if (i > 0 && j > 0) lst += dp(i - 1)(j - 1)\n    \
    \                lst += List(grid(i)(j))\n                    dp(i)(j) = lst.minBy(x\
    \ => x)\n                }\n            }\n        }\n        dp(n - 1)(n - 1).take(k.toInt)",
  "        // Your code here\n        return List[Long]()", "        // Write your\
    \ code here\n        return null", "        val n = grid.length\n        val m\
    \ = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                dp(i)(j)\
    \ = List(grid(i)(j))\n                if (i > 0 && (dp(i - 1)(j).length < k ||\
    \ dp(i - 1)(j) < dp(i)(j))) dp(i)(j) = dp(i - 1)(j)\n                if (j > 0\
    \ && (dp(i)(j - 1).length < k || dp(i)(j - 1) < dp(i)(j))) dp(i)(j) = dp(i)(j\
    \ - 1)\n            }\n        }\n        dp(n - 1)(m - 1)", "        var result\
    \ = List[Long]()\n        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n; j <- 0 until m; l <- 0 to k.toInt) dp(i)(j)(l) = Long.MaxValue\n        for\
    \ (i <- 0 until n; j <- 0 until m) dp(i)(j)(1) = grid(i)(j)\n        for (l <-\
    \ 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until m) {\n      \
    \          if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n  \
    \              if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l -\
    \ 1))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l\
    \ - 1))\n                if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ + 1)(l - 1))\n            }\n        }\n        var min = Long.MaxValue\n  \
    \      for (i <- 0 until n; j <- 0 until m) min = min(min, dp(i)(j)(k.toInt))\n\
    \        var i = 0\n        var j = 0\n        for (i <- 0 until n; j <- 0 until\
    \ m) if (dp(i)(j)(k.toInt) == min) break\n        result = result :+ grid(i)(j)\n\
    \        for (l <- 2 to k.toInt) {\n            if (i > 0 && dp(i - 1)(j)(l -\
    \ 1) == dp(i)(j)(l)) {\n                result = result :+ grid(i - 1)(j)\n  \
    \              i -= 1\n            } else if (i < n - 1 && dp(i +", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) {\n                    val lst = dp(i)(j - 1)\n\
    \                    if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n      \
    \              else if (lst.length == k) {\n                        if (lst.last\
    \ > grid(i)(j)) dp(i)(j) = lst.init :+ grid(i)(j)\n                        else\
    \ dp(i)(j) = lst\n                    }\n                    else dp(i)(j) = lst\n\
    \                }\n                else if (j == 0) {\n                    val\
    \ lst = dp(i - 1)(j)\n                    if (lst.length < k) dp(i)(j) = lst :+\
    \ grid(i)(j)\n                    else if (lst.length == k) {\n              \
    \          if (lst.last > grid(i)(j)) dp(i)(j) = lst.init :+ grid(i)(j)\n    \
    \                    else dp(i)(j) = lst\n                    }\n            \
    \        else dp(i)(j) = lst\n                }\n                else {\n    \
    \                val lst1 = dp(i - 1)(j)\n                    val lst2 = dp(i)(j\
    \ - 1)\n                    if (lst1.length < k) {\n                        if\
    \ (lst2.length < k) {\n                            if (lst1.length < lst2.length)\
    \ dp(i)(j) = lst1 :+ grid(i)(j)\n                            else if (lst1.length\
    \ > lst2.length) dp(i)(j) = lst2 :+ grid(i)(j)\n                            else\
    \ {\n                                if (lst1.last < lst2.last)", "        //\
    \ Your code here\n        return List[Long]()", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) {\n                    if (dp(i)(j - 1).length < k) dp(i)(j) = dp(i)(j\
    \ - 1) :+ grid(i)(j)\n                    else if (dp(i)(j - 1).length == k) {\n\
    \                        if (dp(i)(j - 1).last > grid(i)(j)) dp(i)(j) = dp(i)(j\
    \ - 1).init :+ grid(i)(j)\n                        else dp(i)(j) = dp(i)(j - 1)\n\
    \                    }\n                    else dp(i)(j) = dp(i)(j - 1)\n   \
    \             }\n                else if (j == 0) {\n                    if (dp(i\
    \ - 1)(j).length < k) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                \
    \    else if (dp(i - 1)(j).length == k) {\n                        if (dp(i -\
    \ 1)(j).last > grid(i)(j)) dp(i)(j) = dp(i - 1)(j).init :+ grid(i)(j)\n      \
    \                  else dp(i)(j) = dp(i - 1)(j)\n                    }\n     \
    \               else dp(i)(j) = dp(i - 1)(j)\n                }\n            \
    \    else {\n                    if (dp(i - 1)(j).length < k) {\n            \
    \            if (dp(i)(j - 1).length < k) {\n                            if (dp(i\
    \ - 1)(j).last > dp(i)(j - 1).last) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n  \
    \                          else dp(i)(j) = dp", "        // Your code here\n \
    \       return List[Long]()", "        // Your code here\n        return List[Long]()",
  "        // Write your code here\n        return List[Long]()", "        // Write\
    \ your code here\n        // Return the ordered list of the values on the cells\
    \ that the minimum path go through\n        List[Long]()", "        // Write your\
    \ code here\n        return List[Long]()", "        // Fill in the code here\n\
    \        null", "        // Write your code here\n        // Return the ordered\
    \ list of the values on the cells that the minimum path go through.\n        List[Long]()",
  "        // Fill in the code here\n        List[Long]()", "        // Your code\
    \ here\n        return List[Long]()", "        // Your code here\n        return\
    \ List[Long]()", "        // Your code here\n        return List[Long]()", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n           \
    \ for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n\
    \                else if (i == 0) {\n                    val lst = dp(i)(j - 1)\n\
    \                    if (lst.length < k) dp(i)(j) = lst :+ grid(i)(j)\n      \
    \              else if (lst.length == k) {\n                        if (lst.last\
    \ > grid(i)(j)) dp(i)(j) = lst.init :+ grid(i)(j)\n                        else\
    \ dp(i)(j) = lst\n                    }\n                    else dp(i)(j) = lst\n\
    \                }\n                else if (j == 0) {\n                    val\
    \ lst = dp(i - 1)(j)\n                    if (lst.length < k) dp(i)(j) = lst :+\
    \ grid(i)(j)\n                    else if (lst.length == k) {\n              \
    \          if (lst.last > grid(i)(j)) dp(i)(j) = lst.init :+ grid(i)(j)\n    \
    \                    else dp(i)(j) = lst\n                    }\n            \
    \        else dp(i)(j) = lst\n                }\n                else {\n    \
    \                val lst1 = dp(i - 1)(j)\n                    val lst2 = dp(i)(j\
    \ - 1)\n                    if (lst1.length < k) {\n                        if\
    \ (lst2.length < k) {\n                            if (lst1.length < lst2.length)\
    \ dp(i)(j) = lst1 :+ grid(i)(j)\n                            else if (lst1.length\
    \ > lst2.length) dp(i)(j) = lst2 :+ grid(i)(j)\n                            else\
    \ {\n                                if (lst1.last < lst2.last)", "        //\
    \ Your code here\n        null", "        // Implement this function.\n      \
    \  // You may add any helper functions you need.\n        def minPathRec(grid\
    \ : List[List[Long]], k : Long, path : List[Long], minPath : List[Long]) : List[Long]\
    \ = {\n            if (k == 0) {\n                if (minPath.isEmpty || path.mkString(\"\
    \") < minPath.mkString(\"\")) path\n                else minPath\n           \
    \ }\n            else {\n                val row = path.last / grid.size\n   \
    \             val col = path.last % grid.size\n                val up = if (row\
    \ == 0) None else Some(grid(row - 1)(col))\n                val down = if (row\
    \ == grid.size - 1) None else Some(grid(row + 1)(col))\n                val left\
    \ = if (col == 0) None else Some(grid(row)(col - 1))\n                val right\
    \ = if (col == grid.size - 1) None else Some(grid(row)(col + 1))\n           \
    \     val neighbors = List(up, down, left, right).filter(_.isDefined).map(_.get)\n\
    \                val newMinPath = neighbors.foldLeft(minPath)((minPath, neighbor)\
    \ => minPathRec(grid, k - 1, path :+ neighbor, minPath))\n                if (newMinPath.isEmpty\
    \ || path.mkString(\"\") < newMinPath.mkString(\"\")) newMinPath\n           \
    \     else minPath\n            }\n        }\n        val minPath = grid.zipWithIndex.foldLeft(List[Long]())((minPath,\
    \ row) => {\n            row._1.zipWithIndex.foldLeft(minPath)((minPath, col)\
    \ => {\n                minPathRec(grid, k - 1, List(row._2 * grid.size + col._2),\
    \ minPath)\n            })\n        })\n        minPath", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ > 0 && (dp(i - 1)(j).length < dp(i)(j).length || (dp(i - 1)(j).length == dp(i)(j).length\
    \ && dp(i - 1)(j) < dp(i)(j)))) dp(i)(j) = dp(i - 1)(j)\n                if (j\
    \ > 0 && dp(i)(j - 1).length > 0 && (dp(i)(j - 1).length < dp(i)(j).length ||\
    \ (dp(i)(j - 1).length == dp(i)(j).length && dp(i)(j - 1) < dp(i)(j)))) dp(i)(j)\
    \ = dp(i)(j - 1)\n            }\n        }\n        var ans = List[Long]()\n \
    \       for (i <- 0 until n) {\n            for (j <- 0 until m) {\n         \
    \       if (dp(i)(j).length > 0 && (ans.length == 0 || (ans.length > 0 && dp(i)(j).length\
    \ < ans.length) || (ans.length > 0 && dp(i)(j).length == ans.length && dp(i)(j)\
    \ < ans))) ans = dp(i)(j)\n            }\n        }\n        return ans", "  \
    \      val n = grid.length\n        val dp = Array.fill(n, n)(Long.MaxValue)\n\
    \        val path = Array.fill(n, n)(List[Long]())\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until n) {\n                if (i == 0 && j ==\
    \ 0) {\n                    dp(i)(j) = grid(i)(j)\n                    path(i)(j)\
    \ = List(grid(i)(j))\n                }\n                else {\n            \
    \        if (i > 0 && dp(i - 1)(j) + grid(i)(j) < dp(i)(j)) {\n              \
    \          dp(i)(j) = dp(i - 1)(j) + grid(i)(j)\n                        path(i)(j)\
    \ = path(i - 1)(j) :+ grid(i)(j)\n                    }\n                    if\
    \ (j > 0 && dp(i)(j - 1) + grid(i)(j) < dp(i)(j)) {\n                        dp(i)(j)\
    \ = dp(i)(j - 1) + grid(i)(j)\n                        path(i)(j) = path(i)(j\
    \ - 1) :+ grid(i)(j)\n                    }\n                }\n            }\n\
    \        }\n        path(n - 1)(n - 1).take(k.toInt)", "        // Write your\
    \ code here\n        return List[Long]()", "        val n = grid.length\n    \
    \    val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt) ::: (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted.take(k.toInt).sorted.take(k.toInt)\n            }\n\
    \        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n   \
    \             if (dp(i)(j).length == k.toInt) dp(i)(j) = dp(i)(j).sorted\n   \
    \             else if (j > 0) {\n                    val temp = (dp(i)(j - 1)\
    \ :+ grid(i)(j)).sorted.take(k.toInt)\n                    if (temp.length ==\
    \ k.toInt) dp(i)(j) = temp.sorted\n                }\n            }\n        }\n\
    \        dp(n - 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                dp(i)(j) = List[Long](grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length > 0 && dp(i - 1)(j).length +\
    \ 1 <= k) {\n                    if (dp(i - 1)(j).length + 1 == k) {\n       \
    \                 if (dp(i - 1)(j) < dp(i)(j)) dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    } else {\n                        if (dp(i - 1)(j) < dp(i)(j))\
    \ dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n                    }\n             \
    \   }\n                if (j > 0 && dp(i)(j - 1).length > 0 && dp(i)(j - 1).length\
    \ + 1 <= k) {\n                    if (dp(i)(j - 1).length + 1 == k) {\n     \
    \                   if (dp(i)(j - 1) < dp(i)(j)) dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n\
    \                    } else {\n                        if (dp(i)(j - 1) < dp(i)(j))\
    \ dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n                    }\n             \
    \   }\n            }\n        }\n        dp(n - 1)(m - 1)", "        // Your code\
    \ here\n        return List[Long]()", "        // Your code here\n        return\
    \ List[Long]()", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else dp(i)(j) = (dp(i - 1)(j)\
    \ :+ grid(i)(j)).sorted.take(k.toInt) ++ (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \            }\n        }\n        dp(n - 1)(m - 1).sorted.take(k.toInt)", " \
    \       // Write your code here\n        null", "        // Your code here\n \
    \       return List[Long]()", "        // Fill in the code here\n        List[Long]()",
  "        // Write your code here\n        null", "        val N = grid.length\n\
    \        val M = grid(0).length\n        val gridMap = new HashMap[(Int, Int),\
    \ Long]\n        for (i <- 0 until N; j <- 0 until M) gridMap((i, j)) = grid(i)(j)\n\
    \        val dp = Array.fill(N, M)(List[Long]())\n        for (i <- 0 until N;\
    \ j <- 0 until M) {\n            if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n\
    \            else if (i == 0) {\n                val prev = dp(i)(j - 1)\n   \
    \             if (prev.length < k) dp(i)(j) = prev :+ grid(i)(j)\n           \
    \     else if (prev.length == k) {\n                    if (prev.last < grid(i)(j))\
    \ dp(i)(j) = prev\n                    else dp(i)(j) = prev.init :+ grid(i)(j)\n\
    \                }\n            }\n            else if (j == 0) {\n          \
    \      val prev = dp(i - 1)(j)\n                if (prev.length < k) dp(i)(j)\
    \ = prev :+ grid(i)(j)\n                else if (prev.length == k) {\n       \
    \             if (prev.last < grid(i)(j)) dp(i)(j) = prev\n                  \
    \  else dp(i)(j) = prev.init :+ grid(i)(j)\n                }\n            }\n\
    \            else {\n                val prev1 = dp(i - 1)(j)\n              \
    \  val prev2 = dp(i)(j - 1)\n                if (prev1.length < k && prev2.length\
    \ < k) {\n                    if (prev1.last < prev2.last) dp(i)(j) = prev1 :+\
    \ grid(i)(j)\n                    else dp(i)(j) = prev2 :+ grid(i)(j)\n      \
    \          }\n                else if (prev1.length < k) {\n                 \
    \   if (prev1.last < prev2.last) dp(i)(j) = prev1 :+ grid(i)(j)\n", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                if (j > 0) {\n                    val tmp = (dp(i)(j - 1) :+\
    \ grid(i)(j)).sorted.take(k.toInt)\n                    if (tmp.length == k.toInt\
    \ && tmp < dp(i)(j)) dp(i)(j) = tmp\n                }\n            }\n      \
    \  }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if (i == 0)\
    \ dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                else if (j ==\
    \ 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n                else dp(i)(j)\
    \ = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n                if (j >\
    \ 0) {\n                    val temp = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                    if (temp.length < dp(i)(j).length || (temp.length == dp(i)(j).length\
    \ && temp < dp(i)(j))) dp(i)(j) = temp\n                }\n            }\n   \
    \     }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if\
    \ (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                else\
    \ if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n               \
    \ else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n        \
    \        if (dp(i)(j).length == k.toInt) {\n                    val tmp = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n                    if (tmp.length\
    \ == k.toInt && tmp < dp(i)(j)) dp(i)(j) = tmp\n                }\n          \
    \  }\n        }\n        dp(n - 1)(m - 1)", "        // Write your code here\n\
    \        return List[Long]()", "        // Write your code here\n        val n\
    \ = grid.length\n        val m = grid(0).length\n        val dp = Array.ofDim[Long](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt)\
    \ {\n            if (l == 0) dp(i)(j)(l) = 0\n            else {\n           \
    \     var min = Long.MaxValue\n                if (i > 0) min = min min (dp(i\
    \ - 1)(j)(l - 1) + grid(i)(j))\n                if (j > 0) min = min min (dp(i)(j\
    \ - 1)(l - 1) + grid(i)(j))\n                if (i < n - 1) min = min min (dp(i\
    \ + 1)(j)(l - 1) + grid(i)(j))\n                if (j < m - 1) min = min min (dp(i)(j\
    \ + 1)(l - 1) + grid(i)(j))\n                dp(i)(j)(l) = min\n            }\n\
    \        }\n        var min = Long.MaxValue\n        var min_i = -1\n        var\
    \ min_j = -1\n        for (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt)\
    \ < min) {\n                min = dp(i)(j)(k.toInt)\n                min_i = i\n\
    \                min_j = j\n            }\n        }\n        var ans = List[Long]()\n\
    \        var i = min_i\n        var j = min_j\n        var l = k.toInt\n     \
    \   while (l > 0) {\n            ans = grid(i)(j) :: ans\n            l -= 1\n\
    \            if (i > 0 && dp(i - 1)(j)(l) + grid(i)(j) == dp(i)(j)(l + 1)) i -=\
    \ 1\n            else if (j > 0 && dp(i)(j - 1)(l) + grid(i)(j) == dp(i)(j)(l\
    \ + 1)) j -= 1\n            else if (i < n - 1 &&", "        // Your code here\n\
    \        null", "        // Write your code here\n        return List[Long]()",
  "        // Your code here\n        return List[Long]()", "        // Your code\
    \ here\n        return List[Long]()", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if\
    \ (i == 0) dp(i)(j) = min(dp(i)(j - 1), List(grid(i)(j)))\n                else\
    \ if (j == 0) dp(i)(j) = min(dp(i - 1)(j), List(grid(i)(j)))\n               \
    \ else dp(i)(j) = min(dp(i - 1)(j), dp(i)(j - 1), dp(i - 1)(j - 1), List(grid(i)(j)))\n\
    \            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        //\
    \ Your code here\n        return List[Long]()", "        // Write your code here\n\
    \        val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until\
    \ m; l <- 0 to k.toInt) {\n            dp(i)(j)(l) = Long.MaxValue\n        }\n\
    \        for (i <- 0 until n; j <- 0 until m) {\n            dp(i)(j)(1) = grid(i)(j)\n\
    \        }\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until n;\
    \ j <- 0 until m) {\n                for (a <- -1 to 1; b <- -1 to 1) {\n    \
    \                if (a == 0 && b == 0) {\n                        dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j)(l - 1))\n                    } else if (i + a >=\
    \ 0 && i + a < n && j + b >= 0 && j + b < m) {\n                        dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i + a)(j + b)(l - 1))\n                    }\n       \
    \         }\n                dp(i)(j)(l) += grid(i)(j)\n            }\n      \
    \  }\n        var ans = List[Long]()\n        var x = 0\n        var y = 0\n \
    \       var l = k.toInt\n        while (l > 0) {\n            ans = grid(x)(y)\
    \ :: ans\n            var minv = Long.MaxValue\n            var minx = -1\n  \
    \          var miny = -1\n            for (a <- -1 to 1; b <- -1 to 1) {\n   \
    \             if (a == 0 && b == 0) {\n                    if (dp(x)(y)(l) < minv)\
    \ {\n                        minv = dp(x)(y)(l)\n                        minx\
    \ = x\n                        miny = y\n                    }\n             \
    \   } else if (x + a >= 0 && x + a < n && y + b >= 0 && y + b < m)", "       \
    \ val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(Long.MaxValue)\n        val dirs = List((0, 1), (0, -1), (1, 0), (-1, 0))\n\
    \        val queue = new PriorityQueue[(Long, Int, Int)]()(Ordering.by(x => x._1))\n\
    \        queue.enqueue((grid(0)(0), 0, 0))\n        dp(0)(0) = grid(0)(0)\n  \
    \      while (!queue.isEmpty) {\n            val (cur, i, j) = queue.dequeue\n\
    \            for ((di, dj) <- dirs) {\n                val ni = i + di\n     \
    \           val nj = j + dj\n                if (ni >= 0 && ni < n && nj >= 0\
    \ && nj < m) {\n                    val ncur = cur + grid(ni)(nj)\n          \
    \          if (ncur < dp(ni)(nj)) {\n                        dp(ni)(nj) = ncur\n\
    \                        queue.enqueue((ncur, ni, nj))\n                    }\n\
    \                }\n            }\n        }\n        val ans = new ListBuffer[Long]()\n\
    \        var i = n - 1\n        var j = m - 1\n        var cur = dp(i)(j)\n  \
    \      while (k > 0) {\n            ans += grid(i)(j)\n            k -= 1\n  \
    \          for ((di, dj) <- dirs) {\n                val ni = i + di\n       \
    \         val nj = j + dj\n                if (ni >= 0 && ni < n && nj >= 0 &&\
    \ nj < m && dp(ni)(nj) < cur) {\n                    cur = dp(ni)(nj)\n      \
    \              i = ni\n                    j = nj\n                }\n       \
    \     }\n        }\n        ans.toList", "        val n = grid.length\n      \
    \  val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n \
    \       for (i <- 0 until n) {\n            for (j <- 0 until m) {\n         \
    \       if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n   \
    \             if (j > 0) {\n                    val tmp = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                    if (tmp.length < dp(i)(j).length || (tmp.length == dp(i)(j).length\
    \ && tmp < dp(i)(j))) dp(i)(j) = tmp\n                }\n            }\n     \
    \   }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n        val m\
    \ = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n        for\
    \ (i <- 0 until n) {\n            for (j <- 0 until m) {\n                if (i\
    \ == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if (i == 0)\
    \ dp(i)(j) = min(dp(i)(j - 1), List(grid(i)(j)))\n                else if (j ==\
    \ 0) dp(i)(j) = min(dp(i - 1)(j), List(grid(i)(j)))\n                else dp(i)(j)\
    \ = min(dp(i - 1)(j), dp(i)(j - 1), dp(i - 1)(j - 1), List(grid(i)(j)))\n    \
    \        }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)", "        // Write\
    \ your code here\n        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n; j <- 0 until m; l <- 0 to k.toInt) {\n            dp(i)(j)(l) = Long.MaxValue\n\
    \        }\n        for (i <- 0 until n; j <- 0 until m) {\n            dp(i)(j)(1)\
    \ = grid(i)(j)\n        }\n        for (l <- 2 to k.toInt) {\n            for\
    \ (i <- 0 until n; j <- 0 until m) {\n                if (i > 0) dp(i)(j)(l) =\
    \ min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n                if (i < n - 1) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n                if (j > 0) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n                if (j < m - 1) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n            }\n        }\n        var\
    \ ans = Long.MaxValue\n        var x = 0\n        var y = 0\n        for (i <-\
    \ 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < ans) {\n \
    \               ans = dp(i)(j)(k.toInt)\n                x = i\n             \
    \   y = j\n            }\n        }\n        val res = ListBuffer[Long]()\n  \
    \      res += grid(x)(y)\n        var cur = k.toInt\n        while (cur > 1) {\n\
    \            if (x > 0 && dp(x)(y)(cur) == dp(x - 1)(y)(cur - 1)) {\n        \
    \        res += grid(x - 1)(y)\n                x", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List[Long](grid(i)(j))\n                if (i > 0 && (dp(i\
    \ - 1)(j).length == 0 || dp(i - 1)(j).length > 1 && dp(i - 1)(j)(0) > grid(i)(j)))\
    \ dp(i)(j) = grid(i)(j) :: dp(i - 1)(j)\n                if (j > 0 && (dp(i)(j\
    \ - 1).length == 0 || dp(i)(j - 1).length > 1 && dp(i)(j - 1)(0) > grid(i)(j)))\
    \ dp(i)(j) = grid(i)(j) :: dp(i)(j - 1)\n            }\n        }\n        val\
    \ result = dp(n - 1)(m - 1)\n        if (result.length == 0) List[Long]() else\
    \ result.reverse", "        // Write your code here\n        // Return the ordered\
    \ list of the values on the cells that the minimum path go through.\n        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.ofDim[Long](n,\
    \ m, k.toInt + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt)\
    \ {\n            dp(i)(j)(l) = Long.MaxValue\n        }\n        for (i <- 0 until\
    \ n; j <- 0 until m) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n    \
    \    for (l <- 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until\
    \ m) {\n                if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l\
    \ - 1))\n                if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i +\
    \ 1)(j)(l - 1))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ - 1)(l - 1))\n                if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1))\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var min_i = -1\n        var min_j = -1\n        for (i <- 0 until n;\
    \ j <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min) {\n            \
    \    min = dp(i)(j)(k.toInt)\n                min_i = i\n                min_j\
    \ = j\n            }\n        }\n        var ans = List[Long]()\n        var i\
    \ = min_i\n        var j = min_j\n        for (l <- k.toInt to 1 by -1) {\n  \
    \          ans = grid(i)(j) :: ans\n", "        // Write your code here\n    \
    \    return List[Long]()", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else dp(i)(j) = (dp(i - 1)(j)\
    \ :+ grid(i)(j)).sorted.take(k.toInt)\n                if (dp(i)(j).length < k.toInt)\
    \ {\n                    val tmp = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                    if (tmp.length == k.toInt) dp(i)(j) = tmp\n             \
    \   }\n            }\n        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n   \
    \             if (j > 0) {\n                    val temp = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                    if (temp.length < dp(i)(j).length || (temp.length == dp(i)(j).length\
    \ && temp < dp(i)(j))) dp(i)(j) = temp\n                }\n            }\n   \
    \     }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if\
    \ (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                else\
    \ if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n               \
    \ else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n        \
    \        if (j > 0) {\n                    val temp = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                    if (temp.length < dp(i)(j).length || (temp.length == dp(i)(j).length\
    \ && temp < dp(i)(j))) dp(i)(j) = temp\n                }\n            }\n   \
    \     }\n        dp(n - 1)(m - 1)", "        // Your code here\n        return\
    \ List[Long]()", "        val n = grid.length\n        val m = grid(0).length\n\
    \        val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                dp(i)(j) = List(grid(i)(j))\n\
    \                if (i > 0 && dp(i - 1)(j).length < k) {\n                   \
    \ val tmp = dp(i - 1)(j) :+ grid(i)(j)\n                    if (tmp.length ==\
    \ k) {\n                        if (dp(i)(j).length == k) {\n                \
    \            if (tmp < dp(i)(j)) dp(i)(j) = tmp\n                        } else\
    \ dp(i)(j) = tmp\n                    } else if (tmp.length < k) dp(i)(j) = tmp\n\
    \                }\n                if (j > 0 && dp(i)(j - 1).length < k) {\n\
    \                    val tmp = dp(i)(j - 1) :+ grid(i)(j)\n                  \
    \  if (tmp.length == k) {\n                        if (dp(i)(j).length == k) {\n\
    \                            if (tmp < dp(i)(j)) dp(i)(j) = tmp\n            \
    \            } else dp(i)(j) = tmp\n                    } else if (tmp.length\
    \ < k) dp(i)(j) = tmp\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1)", "        // Your code here\n        null", "        // Write your\
    \ code here\n        // Return the ordered list of the values on the cells that\
    \ the minimum path go through\n        return List[Long]()", "        // Write\
    \ your code here\n        var n = grid.length\n        var m = grid(0).length\n\
    \        var dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                for (l <- 0 to k.toInt)\
    \ {\n                    dp(i)(j)(l) = Long.MaxValue\n                }\n    \
    \        }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                dp(i)(j)(1) = grid(i)(j)\n            }\n      \
    \  }\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until n) {\n\
    \                for (j <- 0 until m) {\n                    if (i > 0) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n                    if (i < n - 1)\
    \ dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n                    if\
    \ (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n              \
    \      if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n  \
    \              }\n            }\n        }\n        var ans = Long.MaxValue\n\
    \        var x = 0\n        var y = 0\n        for (i <- 0 until n) {\n      \
    \      for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt) < ans) {\n\
    \                    ans = dp(i)(j)(k.toInt)\n                    x = i\n    \
    \                y = j\n                }\n            }\n        }\n        var\
    \ result = List[Long]()\n        result = result :+ ans\n        var cur = ans\n\
    \        var curx = x\n        var cury = y\n        for (l <- k.", "        //\
    \ Write your code here\n        // Return the ordered list of the values on the\
    \ cells that the minimum path go through.\n        var n = grid.length\n     \
    \   var m = grid(0).length\n        var dp = Array.ofDim[Long](n, m, k.toInt +\
    \ 1)\n        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n   \
    \             for (l <- 0 to k.toInt) {\n                    dp(i)(j)(l) = Long.MaxValue\n\
    \                }\n            }\n        }\n        for (i <- 0 until n) {\n\
    \            for (j <- 0 until m) {\n                dp(i)(j)(1) = grid(i)(j)\n\
    \            }\n        }\n        for (l <- 2 to k.toInt) {\n            for\
    \ (i <- 0 until n) {\n                for (j <- 0 until m) {\n               \
    \     if (i - 1 >= 0) {\n                        dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i - 1)(j)(l - 1))\n                    }\n                    if (i + 1 <\
    \ n) {\n                        dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l\
    \ - 1))\n                    }\n                    if (j - 1 >= 0) {\n      \
    \                  dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n     \
    \               }\n                    if (j + 1 < m) {\n                    \
    \    dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n                   \
    \ }\n                }\n            }\n        }\n        var ans = Long.MaxValue\n\
    \        var x = -1\n        var y = -1\n        for (i <- 0 until n) {\n    \
    \        for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt) < ans)\
    \ {\n                    ans = dp(i)(j)(k.toInt)\n                    x = i\n\
    \                    y = j\n                }\n           ", "        // Fill\
    \ in the code here\n        List[Long]()", "        val n = grid.length\n    \
    \    val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        val v = grid(i)(j)\n                val l = List(v)\n               \
    \ dp(i)(j) = l\n                if (i > 0) {\n                    val l2 = dp(i\
    \ - 1)(j)\n                    if (l2.length < k) {\n                        if\
    \ (l2.length + 1 == k) {\n                            if (l2 < l) dp(i)(j) = l2\
    \ ::: l\n                        } else {\n                            dp(i)(j)\
    \ = l2 ::: l\n                        }\n                    }\n             \
    \   }\n                if (j > 0) {\n                    val l2 = dp(i)(j - 1)\n\
    \                    if (l2.length < k) {\n                        if (l2.length\
    \ + 1 == k) {\n                            if (l2 < l) dp(i)(j) = l2 ::: l\n \
    \                       } else {\n                            dp(i)(j) = l2 :::\
    \ l\n                        }\n                    }\n                }\n   \
    \         }\n        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n   \
    \             if (dp(i)(j).length > k.toInt) dp(i)(j) = dp(i)(j).take(k.toInt)\n\
    \                if (j > 0) {\n                    val temp = (dp(i)(j - 1) :+\
    \ grid(i)(j)).sorted\n                    if (temp.length > k.toInt) temp.take(k.toInt)\n\
    \                    if (temp.length < k.toInt) dp(i)(j) = temp\n            \
    \        else if (temp < dp(i)(j)) dp(i)(j) = temp\n                }\n      \
    \      }\n        }\n        dp(n - 1)(m - 1)", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ + 1 <= k) {\n                    val newPath = dp(i - 1)(j) :+ grid(i)(j)\n\
    \                    if (newPath.length == k) dp(i)(j) = newPath\n           \
    \         else if (newPath.length < k && newPath < dp(i)(j)) dp(i)(j) = newPath\n\
    \                }\n                if (j > 0 && dp(i)(j - 1).length + 1 <= k)\
    \ {\n                    val newPath = dp(i)(j - 1) :+ grid(i)(j)\n          \
    \          if (newPath.length == k) dp(i)(j) = newPath\n                    else\
    \ if (newPath.length < k && newPath < dp(i)(j)) dp(i)(j) = newPath\n         \
    \       }\n            }\n        }\n        dp(n - 1)(m - 1)", "        // Your\
    \ code here\n        null", "        // Your code here\n        return List[Long]()",
  "        val n = grid.length\n        var dp = Array.ofDim[Long](n, n, k.toInt +\
    \ 1)\n        for (i <- 0 until n; j <- 0 until n; l <- 0 to k.toInt) dp(i)(j)(l)\
    \ = Long.MaxValue\n        for (i <- 0 until n; j <- 0 until n) dp(i)(j)(0) =\
    \ 0\n        for (l <- 1 to k.toInt) {\n            for (i <- 0 until n; j <-\
    \ 0 until n) {\n                if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i\
    \ - 1)(j)(l - 1) + grid(i)(j))\n                if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i + 1)(j)(l - 1) + grid(i)(j))\n                if (j > 0) dp(i)(j)(l) =\
    \ min(dp(i)(j)(l), dp(i)(j - 1)(l - 1) + grid(i)(j))\n                if (j <\
    \ n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1) + grid(i)(j))\n  \
    \          }\n        }\n        var min = Long.MaxValue\n        var min_i =\
    \ -1\n        var min_j = -1\n        for (i <- 0 until n; j <- 0 until n) {\n\
    \            if (dp(i)(j)(k.toInt) < min) {\n                min = dp(i)(j)(k.toInt)\n\
    \                min_i = i\n                min_j = j\n            }\n       \
    \ }\n        var ans = List[Long]()\n        var i = min_i\n        var j = min_j\n\
    \        for (l <- k.toInt to 1 by -1) {\n            ans = grid(i)(j) :: ans\n\
    \            if (i > 0 && dp(i)(j)(l - 1) + grid(i)(j) ==", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ <= k && dp(i - 1)(j).length < dp(i)(j).length) dp(i)(j) = dp(i - 1)(j)\n   \
    \             if (j > 0 && dp(i)(j - 1).length <= k && dp(i)(j - 1).length < dp(i)(j).length)\
    \ dp(i)(j) = dp(i)(j - 1)\n                if (i > 0 && j > 0 && dp(i - 1)(j -\
    \ 1).length <= k && dp(i - 1)(j - 1).length < dp(i)(j).length) dp(i)(j) = dp(i\
    \ - 1)(j - 1)\n                if (i < n - 1 && dp(i + 1)(j).length <= k && dp(i\
    \ + 1)(j).length < dp(i)(j).length) dp(i)(j) = dp(i + 1)(j)\n                if\
    \ (j < m - 1 && dp(i)(j + 1).length <= k && dp(i)(j + 1).length < dp(i)(j).length)\
    \ dp(i)(j) = dp(i)(j + 1)\n                if (i < n - 1 && j < m - 1 && dp(i\
    \ + 1)(j + 1).length <= k && dp(i + 1)(j + 1).length < dp(i)(j).length) dp(i)(j)\
    \ = dp(i + 1)(j + 1)\n                if (i > 0 && j < m - 1 && dp(i - 1)(j +\
    \ 1).length <= k && dp(i - 1)(j + 1).length < dp(i)(j).length) dp(i)(j) =", " \
    \       // Write your code here\n        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n    \
    \    for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n            dp(i)(j)(l)\
    \ = Long.MaxValue\n        }\n        for (i <- 0 until n; j <- 0 until m) {\n\
    \            dp(i)(j)(1) = grid(i)(j)\n        }\n        for (l <- 2 to k.toInt)\
    \ {\n            for (i <- 0 until n; j <- 0 until m) {\n                if (i\
    \ > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n                if\
    \ (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n          \
    \      if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n      \
    \          if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n\
    \            }\n        }\n        var min = Long.MaxValue\n        var min_i\
    \ = -1\n        var min_j = -1\n        for (i <- 0 until n; j <- 0 until m) {\n\
    \            if (dp(i)(j)(k.toInt) < min) {\n                min = dp(i)(j)(k.toInt)\n\
    \                min_i = i\n                min_j = j\n            }\n       \
    \ }\n        var i = min_i\n        var j = min_j\n        var l = k.toInt\n \
    \       val result = ListBuffer[Long]()\n        while (l > 0) {\n           \
    \ result += grid(i)(j)\n            l -= 1\n            if (i > 0 && dp(i)(j)(l",
  "        // Your code here\n        return List[Long]()", "        // Write your\
    \ code here\n        val n = grid.length\n        val m = grid(0).length\n   \
    \     val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n; j <- 0 until m; l <- 0 to k.toInt) {\n            dp(i)(j)(l) = Long.MaxValue\n\
    \        }\n        for (i <- 0 until n; j <- 0 until m) {\n            dp(i)(j)(1)\
    \ = grid(i)(j)\n        }\n        for (l <- 2 to k.toInt) {\n            for\
    \ (i <- 0 until n; j <- 0 until m) {\n                if (i > 0) dp(i)(j)(l) =\
    \ min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n                if (i < n - 1) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n                if (j > 0) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n                if (j < m - 1) dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1))\n            }\n        }\n        var\
    \ min = Long.MaxValue\n        var min_i = -1\n        var min_j = -1\n      \
    \  for (i <- 0 until n; j <- 0 until m) {\n            if (dp(i)(j)(k.toInt) <\
    \ min) {\n                min = dp(i)(j)(k.toInt)\n                min_i = i\n\
    \                min_j = j\n            }\n        }\n        val ans = ListBuffer[Long]()\n\
    \        ans += grid(min_i)(min_j)\n        var cur_i = min_i\n        var cur_j\
    \ = min_j\n        for (l <- k.toInt - 1 to 1 by -1) {\n            if (cur_i\
    \ > 0 && dp", "        // Your code here\n        null", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n   \
    \             if (j > 0) {\n                    val tmp = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                    if (tmp.length < dp(i)(j).length || (tmp.length == dp(i)(j).length\
    \ && tmp < dp(i)(j))) dp(i)(j) = tmp\n                }\n            }\n     \
    \   }\n        dp(n - 1)(m - 1)", "        // Write your code here\n        return\
    \ List[Long]()", "        // Write your code here\n        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) dp(i)(j)(l)\
    \ = Long.MaxValue\n        for (i <- 0 until n; j <- 0 until m) dp(i)(j)(0) =\
    \ 0\n        for (l <- 1 to k.toInt) {\n            for (i <- 0 until n; j <-\
    \ 0 until m) {\n                if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i\
    \ - 1)(j)(l - 1) + grid(i)(j))\n                if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i + 1)(j)(l - 1) + grid(i)(j))\n                if (j > 0) dp(i)(j)(l) =\
    \ min(dp(i)(j)(l), dp(i)(j - 1)(l - 1) + grid(i)(j))\n                if (j <\
    \ m - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j + 1)(l - 1) + grid(i)(j))\n  \
    \          }\n        }\n        var min = Long.MaxValue\n        var mini = -1\n\
    \        var minj = -1\n        for (i <- 0 until n; j <- 0 until m) {\n     \
    \       if (dp(i)(j)(k.toInt) < min) {\n                min = dp(i)(j)(k.toInt)\n\
    \                mini = i\n                minj = j\n            }\n        }\n\
    \        val path = ListBuffer[Long]()\n        var i = mini\n        var j =\
    \ minj\n        var l = k.toInt\n        while (l > 0) {\n            path +=\
    \ grid(i)(j)\n            l -= 1\n            if (i > 0 && dp(", "        val\
    \ n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                val v = grid(i)(j)\n                var lst = List[Long](v)\n\
    \                if (i > 0) {\n                    val lst2 = dp(i - 1)(j)\n \
    \                   if (lst2.length < k) {\n                        lst = lst\
    \ ::: lst2\n                    } else if (lst2.length == k) {\n             \
    \           if (lst2.head < v) {\n                            lst = lst2\n   \
    \                     } else if (lst2.head == v) {\n                         \
    \   lst = lst2 ::: lst\n                        }\n                    }\n   \
    \             }\n                if (j > 0) {\n                    val lst2 =\
    \ dp(i)(j - 1)\n                    if (lst2.length < k) {\n                 \
    \       lst = lst ::: lst2\n                    } else if (lst2.length == k) {\n\
    \                        if (lst2.head < v) {\n                            lst\
    \ = lst2\n                        } else if (lst2.head == v) {\n             \
    \               lst = lst2 ::: lst\n                        }\n              \
    \      }\n                }\n                dp(i)(j) = lst.distinct.sorted.take(k.toInt)\n\
    \            }\n        }\n        dp(n - 1)(m - 1)", "        // Write your code\
    \ here\n        // Return the answer\n        List[Long]()", "        // Write\
    \ your code here\n        return List[Long]()", "        // Fill in the code here\n\
    \        List[Long]()", "        // Write your code here\n        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        for (i <- 0 until n; j <- 0 until m; l <- 0 to k.toInt) {\n  \
    \          dp(i)(j)(l) = Long.MaxValue\n        }\n        for (i <- 0 until n;\
    \ j <- 0 until m) {\n            dp(i)(j)(1) = grid(i)(j)\n        }\n       \
    \ for (l <- 2 to k.toInt) {\n            for (i <- 0 until n; j <- 0 until m)\
    \ {\n                if (i > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l\
    \ - 1))\n                if (i < n - 1) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i +\
    \ 1)(j)(l - 1))\n                if (j > 0) dp(i)(j)(l) = min(dp(i)(j)(l), dp(i)(j\
    \ - 1)(l - 1))\n                if (j < m - 1) dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1))\n            }\n        }\n        var min = Long.MaxValue\n\
    \        var min_i = -1\n        var min_j = -1\n        for (i <- 0 until n;\
    \ j <- 0 until m) {\n            if (dp(i)(j)(k.toInt) < min) {\n            \
    \    min = dp(i)(j)(k.toInt)\n                min_i = i\n                min_j\
    \ = j\n            }\n        }\n        val result = new ListBuffer[Long]\n \
    \       result += grid(min_i)(min_j)\n        var i = min_i\n        var j = min_j\n\
    \        for (l <- k.toInt - 1 to 1 by -1) {\n            if (i > 0 && dp(i)(j)(l",
  "        // Your code here\n        return List[Long]()", "        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j) = List(grid(i)(j))\n                if (i > 0 && dp(i - 1)(j).length\
    \ > 0 && dp(i - 1)(j).length < k && dp(i - 1)(j).length + 1 < dp(i)(j).length)\
    \ {\n                    dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n             \
    \   }\n                if (j > 0 && dp(i)(j - 1).length > 0 && dp(i)(j - 1).length\
    \ < k && dp(i)(j - 1).length + 1 < dp(i)(j).length) {\n                    dp(i)(j)\
    \ = dp(i)(j - 1) :+ grid(i)(j)\n                }\n            }\n        }\n\
    \        dp(n - 1)(m - 1)", "        // Your code here\n        return List[Long]()",
  "        // Your code here\n        return List[Long]()", "        // Your code\
    \ here\n        return List[Long]()", "        // Your code here\n        null",
  "        // Your code here\n        null", "        val n = grid.length\n      \
    \  val m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n \
    \       for (i <- 0 until n) {\n            for (j <- 0 until m) {\n         \
    \       if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else\
    \ if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n               \
    \ else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n          \
    \      else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n   \
    \             if (j > 0) {\n                    val tmp = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                    if (tmp.length < dp(i)(j).length || (tmp.length == dp(i)(j).length\
    \ && tmp < dp(i)(j))) dp(i)(j) = tmp\n                }\n            }\n     \
    \   }\n        dp(n - 1)(m - 1)", "        // Your code here\n        null", " \
    \       val n = grid.length\n        val m = grid(0).length\n        val dp =\
    \ Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n) {\n           \
    \ for (j <- 0 until m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n\
    \                else if (i == 0) dp(i)(j) = List(grid(i)(j)) ++ dp(i)(j - 1)\n\
    \                else if (j == 0) dp(i)(j) = List(grid(i)(j)) ++ dp(i - 1)(j)\n\
    \                else {\n                    val a = List(grid(i)(j)) ++ dp(i)(j\
    \ - 1)\n                    val b = List(grid(i)(j)) ++ dp(i - 1)(j)\n       \
    \             if (a < b) dp(i)(j) = a\n                    else dp(i)(j) = b\n\
    \                }\n            }\n        }\n        dp(n - 1)(m - 1).take(k.toInt)",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        val dp2 = Array.fill(n, m)(List[Long]())\n       \
    \ for (i <- 0 until n) {\n            for (j <- 0 until m) {\n               \
    \ if (i == 0 && j == 0) {\n                    dp(i)(j) = List(grid(i)(j))\n \
    \                   dp2(i)(j) = List(grid(i)(j))\n                } else if (i\
    \ == 0) {\n                    dp(i)(j) = dp(i)(j - 1) :+ grid(i)(j)\n       \
    \             dp2(i)(j) = dp2(i)(j - 1) :+ grid(i)(j)\n                } else\
    \ if (j == 0) {\n                    dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n \
    \                   dp2(i)(j) = dp2(i - 1)(j) :+ grid(i)(j)\n                }\
    \ else {\n                    if (dp(i - 1)(j).length < dp(i)(j - 1).length) {\n\
    \                        dp(i)(j) = dp(i - 1)(j) :+ grid(i)(j)\n             \
    \           dp2(i)(j) = dp2(i - 1)(j) :+ grid(i)(j)\n                    } else\
    \ if (dp(i - 1)(j).length > dp(i)(j - 1).length) {\n                        dp(i)(j)\
    \ = dp(i)(j - 1) :+ grid(i)(j)\n                        dp2(i)(j) = dp2(i)(j -\
    \ 1) :+ grid(i)(j)\n                    } else {\n                        if (dp2(i\
    \ - 1)(j) < dp2(i)(j - 1)) {\n                            dp(i)(j) = dp(i - 1)(j)\
    \ :+ grid(i)(j)\n                            dp2(i)(j) = dp2(i - 1)(", "     \
    \   // Write your code here\n        // Return the ordered list of the values\
    \ on the cells that the minimum path go through.\n        List[Long]()"]
stop_tokens:
- "\n    }\n"
