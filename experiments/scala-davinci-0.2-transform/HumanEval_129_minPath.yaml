name: HumanEval_129_minPath
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a grid with N rows and N columns (N >= 2) and a positive integer k,\
  \ \n    // each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n    // inclusive appears exactly once on the cells of the grid.\n    //\
  \ You have to find the minimum path of length k in the grid. You can start\n   \
  \ // from any cell, and in each step you can move to any of the neighbor cells,\n\
  \    // in other words, you can go to cells which share an edge with you current\n\
  \    // cell.\n    // Please note that a path of length k means visiting exactly\
  \ k cells (not\n    // necessarily distinct).\n    // You CANNOT go off the grid.\n\
  \    // A path A (of length k) is considered less than a path B (of length k) if\n\
  \    // after making the ordered lists of the values on the cells that A and B go\n\
  \    // through (let's call them lst_A and lst_B), lst_A is lexicographically less\n\
  \    // than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n\
  \    // such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    //\
  \ lst_A[j] = lst_B[j].\n    // It is guaranteed that the answer is unique.\n   \
  \ // Return an ordered list of the values on the cells that the minimum path go\
  \ through.\n    // Examples:    \n    // >>> minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l))\n    // (List[Long](1l.toLong, 2l.toLong, 1l.toLong))\n\
  \    // >>> minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l))\n    // (List[Long](1l.toLong))\n    def minPath(grid : List[List[Long]],\
  \ k : Long) : List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong), List[Long](4l.toLong, 5l.toLong, 6l.toLong), List[Long](7l.toLong,\
  \ 8l.toLong, 9l.toLong))), (3l)).equals((List[Long](1l.toLong, 2l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](5l.toLong, 9l.toLong, 3l.toLong),\
  \ List[Long](4l.toLong, 1l.toLong, 6l.toLong), List[Long](7l.toLong, 8l.toLong,\
  \ 2l.toLong))), (1l)).equals((List[Long](1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong, 3l.toLong, 4l.toLong), List[Long](5l.toLong, 6l.toLong, 7l.toLong,\
  \ 8l.toLong), List[Long](9l.toLong, 10l.toLong, 11l.toLong, 12l.toLong), List[Long](13l.toLong,\
  \ 14l.toLong, 15l.toLong, 16l.toLong))), (4l)).equals((List[Long](1l.toLong, 2l.toLong,\
  \ 1l.toLong, 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 4l.toLong, 13l.toLong, 10l.toLong), List[Long](5l.toLong, 7l.toLong, 12l.toLong,\
  \ 1l.toLong), List[Long](3l.toLong, 16l.toLong, 11l.toLong, 15l.toLong), List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong))), (7l)).equals((List[Long](1l.toLong, 10l.toLong,\
  \ 1l.toLong, 10l.toLong, 1l.toLong, 10l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](8l.toLong,\
  \ 14l.toLong, 9l.toLong, 2l.toLong), List[Long](6l.toLong, 4l.toLong, 13l.toLong,\
  \ 15l.toLong), List[Long](5l.toLong, 7l.toLong, 1l.toLong, 12l.toLong), List[Long](3l.toLong,\
  \ 10l.toLong, 11l.toLong, 16l.toLong))), (5l)).equals((List[Long](1l.toLong, 7l.toLong,\
  \ 1l.toLong, 7l.toLong, 1l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](11l.toLong,\
  \ 8l.toLong, 7l.toLong, 2l.toLong), List[Long](5l.toLong, 16l.toLong, 14l.toLong,\
  \ 4l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](12l.toLong,\
  \ 13l.toLong, 10l.toLong, 1l.toLong))), (9l)).equals((List[Long](1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](12l.toLong, 13l.toLong, 10l.toLong,\
  \ 1l.toLong), List[Long](9l.toLong, 3l.toLong, 15l.toLong, 6l.toLong), List[Long](5l.toLong,\
  \ 16l.toLong, 14l.toLong, 4l.toLong), List[Long](11l.toLong, 8l.toLong, 7l.toLong,\
  \ 2l.toLong))), (12l)).equals((List[Long](1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong,\
  \ 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong, 1l.toLong, 6l.toLong))));\n\
  \    assert(minPath((List[List[Long]](List[Long](2l.toLong, 7l.toLong, 4l.toLong),\
  \ List[Long](3l.toLong, 1l.toLong, 5l.toLong), List[Long](6l.toLong, 8l.toLong,\
  \ 9l.toLong))), (8l)).equals((List[Long](1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](6l.toLong,\
  \ 1l.toLong, 5l.toLong), List[Long](3l.toLong, 8l.toLong, 9l.toLong), List[Long](2l.toLong,\
  \ 7l.toLong, 4l.toLong))), (8l)).equals((List[Long](1l.toLong, 5l.toLong, 1l.toLong,\
  \ 5l.toLong, 1l.toLong, 5l.toLong, 1l.toLong, 5l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong,\
  \ 2l.toLong), List[Long](3l.toLong, 4l.toLong))), (10l)).equals((List[Long](1l.toLong,\
  \ 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong, 2l.toLong, 1l.toLong,\
  \ 2l.toLong))));\n    assert(minPath((List[List[Long]](List[Long](1l.toLong, 3l.toLong),\
  \ List[Long](3l.toLong, 2l.toLong))), (10l)).equals((List[Long](1l.toLong, 3l.toLong,\
  \ 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong, 1l.toLong, 3l.toLong))));\n\
  \    }\n\n}\n"
completions: ["        // Write your code here\n        // Return the ordered list\
    \ of the values on the cells that the minimum path go through.\n        return\
    \ List[Long]()", "        // Your code here\n        return List[Long]()", " \
    \       // Write your code here\n        val n = grid.length\n        val m =\
    \ grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt + 1)\n    \
    \    val pq = new PriorityQueue[(Long, Int, Int, Int)]()(Ordering.by(-_._1))\n\
    \        for (i <- 0 until n) {\n            for (j <- 0 until m) {\n        \
    \        dp(i)(j)(1) = grid(i)(j)\n                pq.enqueue((dp(i)(j)(1), i,\
    \ j, 1))\n            }\n        }\n        while (pq.nonEmpty) {\n          \
    \  val (v, i, j, l) = pq.dequeue\n            if (l == k) return List.tabulate(l.toInt)(x\
    \ => dp(i)(j)(x + 1))\n            if (i > 0 && dp(i - 1)(j)(l + 1) == 0) {\n\
    \                dp(i - 1)(j)(l + 1) = v + grid(i - 1)(j)\n                pq.enqueue((dp(i\
    \ - 1)(j)(l + 1), i - 1, j, l + 1))\n            }\n            if (i < n - 1\
    \ && dp(i + 1)(j)(l + 1) == 0) {\n                dp(i + 1)(j)(l + 1) = v + grid(i\
    \ + 1)(j)\n                pq.enqueue((dp(i + 1)(j)(l + 1), i + 1, j, l + 1))\n\
    \            }\n            if (j > 0 && dp(i)(j - 1)(l + 1) == 0) {\n       \
    \         dp(i)(j - 1)(l + 1) = v + grid(i)(j - 1)\n                pq.enqueue((dp(i)(j\
    \ - 1)(l + 1), i, j - 1, l + 1))\n            }\n            if (j < m - 1 &&\
    \ dp(i)(j + 1)(l + 1) == 0) {\n                dp(i)(j + 1)(l + 1) = v + grid(i)(j",
  "        // Write your code here\n        // Return the ordered list of the values\
    \ on the cells that the minimum path go through.\n        val n = grid.length\n\
    \        val m = grid(0).length\n        val dp = Array.ofDim[Long](n, m, k.toInt\
    \ + 1)\n        val path = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                dp(i)(j)(1)\
    \ = grid(i)(j)\n                path(i)(j)(1) = grid(i)(j)\n            }\n  \
    \      }\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until n)\
    \ {\n                for (j <- 0 until m) {\n                    dp(i)(j)(l) =\
    \ Long.MaxValue\n                    for (x <- 0 until n) {\n                \
    \        for (y <- 0 until m) {\n                            if (abs(x - i) +\
    \ abs(y - j) == 1) {\n                                if (dp(x)(y)(l - 1) < dp(i)(j)(l))\
    \ {\n                                    dp(i)(j)(l) = dp(x)(y)(l - 1)\n     \
    \                               path(i)(j)(l) = grid(i)(j)\n                 \
    \               }\n                            }\n                        }\n\
    \                    }\n                }\n            }\n        }\n        var\
    \ min = Long.MaxValue\n        var x = 0\n        var y = 0\n        for (i <-\
    \ 0 until n) {\n            for (j <- 0 until m) {\n                if (dp(i)(j)(k.toInt)\
    \ < min) {\n                    min = dp(i)(j)(k.toInt)\n                    x\
    \ = i\n                    y = j\n                }\n            }\n        }\n\
    \        var ans = List[Long]()\n        for (l <- k.toInt to 1 by -1) {\n   \
    \         ans = path(x)(y)(l) :: ans\n            for (i <- 0 until n) {\n   \
    \             for (j <- 0 until m) {\n                    if (abs(x - i)", " \
    \       // Your code here\n        null", "        // Your code here\n       \
    \ return List[Long]()", "        // Write your code here\n        return List[Long]()",
  "        val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else if (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                else if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n\
    \                else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n\
    \                if (dp(i)(j).length == k.toInt) {\n                    val lst\
    \ = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n                    if\
    \ (lst.length == k.toInt && lst < dp(i)(j)) dp(i)(j) = lst\n                }\n\
    \            }\n        }\n        dp(n - 1)(m - 1)", "        // Your code here\n\
    \        return List[Long]()", "        // Your code here\n        null", "  \
    \      val n = grid.length\n        val m = grid(0).length\n        val dp = Array.fill(n,\
    \ m)(List[Long]())\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n  \
    \              else {\n                    var min = List[Long]()\n          \
    \          if (i > 0) {\n                        val tmp = dp(i - 1)(j)\n    \
    \                    if (tmp.length == k) min = tmp\n                        else\
    \ if (tmp.length < k) min = tmp :+ grid(i)(j)\n                    }\n       \
    \             if (j > 0) {\n                        val tmp = dp(i)(j - 1)\n \
    \                       if (tmp.length == k) min = tmp\n                     \
    \   else if (tmp.length < k) {\n                            if (min.length ==\
    \ 0) min = tmp :+ grid(i)(j)\n                            else if (min.length\
    \ < k) {\n                                val tmp2 = tmp :+ grid(i)(j)\n     \
    \                           if (tmp2 < min) min = tmp2\n                     \
    \       }\n                        }\n                    }\n                \
    \    dp(i)(j) = min\n                }\n            }\n        }\n        dp(n\
    \ - 1)(m - 1)", "        // grid: List[List[Long]]\n        // k: Long\n     \
    \   // return: List[Long]\n        var n = grid.length\n        var m = grid(0).length\n\
    \        var dp = Array.ofDim[Long](n, m, k.toInt + 1)\n        for (i <- 0 until\
    \ n) {\n            for (j <- 0 until m) {\n                for (l <- 0 to k.toInt)\
    \ {\n                    dp(i)(j)(l) = Long.MaxValue\n                }\n    \
    \        }\n        }\n        for (i <- 0 until n) {\n            for (j <- 0\
    \ until m) {\n                dp(i)(j)(1) = grid(i)(j)\n            }\n      \
    \  }\n        for (l <- 2 to k.toInt) {\n            for (i <- 0 until n) {\n\
    \                for (j <- 0 until m) {\n                    if (i > 0) {\n  \
    \                      dp(i)(j)(l) = min(dp(i)(j)(l), dp(i - 1)(j)(l - 1))\n \
    \                   }\n                    if (i < n - 1) {\n                \
    \        dp(i)(j)(l) = min(dp(i)(j)(l), dp(i + 1)(j)(l - 1))\n               \
    \     }\n                    if (j > 0) {\n                        dp(i)(j)(l)\
    \ = min(dp(i)(j)(l), dp(i)(j - 1)(l - 1))\n                    }\n           \
    \         if (j < m - 1) {\n                        dp(i)(j)(l) = min(dp(i)(j)(l),\
    \ dp(i)(j + 1)(l - 1))\n                    }\n                }\n           \
    \ }\n        }\n        var ans = Long.MaxValue\n        var ansi = -1\n     \
    \   var ansj = -1\n        for (i <- 0 until n) {\n            for (j <- 0 until\
    \ m) {\n                if (dp(i)(j)(k.toInt) < ans) {\n                    ans\
    \ = dp(i)(j)(k.toInt)\n                    ansi = i\n                    ansj\
    \ = j\n                }\n            }", "        val n = grid.length\n     \
    \   val m = grid(0).length\n        val dp = Array.fill(n, m)(Long.MaxValue)\n\
    \        val dp2 = Array.fill(n, m)(List[Long]())\n        val dirs = List((0,\
    \ 1), (0, -1), (1, 0), (-1, 0))\n        def valid(x : Int, y : Int) : Boolean\
    \ = {\n            x >= 0 && x < n && y >= 0 && y < m\n        }\n        def\
    \ dfs(x : Int, y : Int, k : Long) : Long = {\n            if (dp(x)(y) != Long.MaxValue)\
    \ return dp(x)(y)\n            if (k == 0) return grid(x)(y)\n            var\
    \ min = Long.MaxValue\n            var minPath = List[Long]()\n            for\
    \ (dir <- dirs) {\n                val nx = x + dir._1\n                val ny\
    \ = y + dir._2\n                if (valid(nx, ny)) {\n                    val\
    \ cur = dfs(nx, ny, k - 1)\n                    if (cur < min) {\n           \
    \             min = cur\n                        minPath = grid(x)(y) :: dp2(nx)(ny)\n\
    \                    }\n                }\n            }\n            dp(x)(y)\
    \ = min\n            dp2(x)(y) = minPath\n            min\n        }\n       \
    \ var min = Long.MaxValue\n        var minPath = List[Long]()\n        for (i\
    \ <- 0 until n) {\n            for (j <- 0 until m) {\n                val cur\
    \ = dfs(i, j, k - 1)\n                if (cur < min) {\n                    min\
    \ = cur\n                    minPath = dp2(i)(j)\n                }\n        \
    \    }\n        }\n        minPath", "        val n = grid.length\n        val\
    \ m = grid(0).length\n        val dp = Array.fill(n, m)(List[Long]())\n      \
    \  for (i <- 0 until n) {\n            for (j <- 0 until m) {\n              \
    \  if (i == 0 && j == 0) dp(i)(j) = List(grid(i)(j))\n                else if\
    \ (i == 0) dp(i)(j) = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n                else\
    \ if (j == 0) dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted\n               \
    \ else dp(i)(j) = (dp(i - 1)(j) :+ grid(i)(j)).sorted.take(k.toInt)\n        \
    \        if (dp(i)(j).length > k.toInt) dp(i)(j) = dp(i)(j).dropRight(1)\n   \
    \             if (j > 0) {\n                    val tmp = (dp(i)(j - 1) :+ grid(i)(j)).sorted\n\
    \                    if (tmp.length > k.toInt) tmp.dropRight(1)\n            \
    \        if (tmp.length < k.toInt) tmp\n                    else if (tmp < dp(i)(j))\
    \ dp(i)(j) = tmp\n                }\n            }\n        }\n        dp(n -\
    \ 1)(m - 1)", "        val n = grid.length\n        val m = grid(0).length\n \
    \       val dp = Array.fill(n, m)(List[Long]())\n        for (i <- 0 until n)\
    \ {\n            for (j <- 0 until m) {\n                if (i == 0 && j == 0)\
    \ dp(i)(j) = List(grid(i)(j))\n                else if (i == 0) dp(i)(j) = (dp(i)(j\
    \ - 1) :+ grid(i)(j)).sorted\n                else if (j == 0) dp(i)(j) = (dp(i\
    \ - 1)(j) :+ grid(i)(j)).sorted\n                else dp(i)(j) = (dp(i - 1)(j)\
    \ :+ grid(i)(j)).sorted.take(k.toInt)\n                if (j > 0) {\n        \
    \            val l = (dp(i)(j - 1) :+ grid(i)(j)).sorted.take(k.toInt)\n     \
    \               if (l.length < dp(i)(j).length || (l.length == dp(i)(j).length\
    \ && l < dp(i)(j))) dp(i)(j) = l\n                }\n            }\n        }\n\
    \        dp(n - 1)(m - 1)", "        // Your code here\n        return List[Long]()",
  "        // Fill in the code here\n        null", "        // Your code here\n \
    \       return List[Long]()", "        // Your code here\n        return List[Long]()",
  "        // Fill in the code here\n        return List[Long]()"]
stop_tokens:
- "\n    }\n"
